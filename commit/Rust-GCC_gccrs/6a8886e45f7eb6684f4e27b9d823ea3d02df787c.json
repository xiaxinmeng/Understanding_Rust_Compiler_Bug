{"sha": "6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmE4ODg2ZTQ1ZjdlYjY2ODRmNGUyN2I5ZDgyM2VhM2QwMmRmNzg3Yw==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@linux.ibm.com", "date": "2018-06-18T19:10:08Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "2018-06-18T19:10:08Z"}, "message": "re PR target/85358 (PowerPC: Using -mabi=ieeelongdouble -mcpu=power9 breaks __ibm128)\n\n[gcc]\n2018-06-18  Michael Meissner  <meissner@linux.ibm.com>\n\n\tPR target/85358\n\t* config/rs6000/rs6000-modes.def (toplevel): Rework the 128-bit\n\tfloating point modes, so that IFmode is numerically greater than\n\tTFmode, which is greater than KFmode using FRACTIONAL_FLOAT_MODE\n\tto declare the ordering.  This prevents IFmode from being\n\tconverted to TFmode when long double is IEEE 128-bit on an ISA 3.0\n\tmachine.  Include rs6000-modes.h to share the fractional values\n\tbetween genmodes* and the rest of the compiler.\n\t(IFmode): Likewise.\n\t(KFmode): Likewise.\n\t(TFmode): Likewise.\n\t* config/rs6000/rs6000-modes.h: New file.\n\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Change the\n\tmeaning of rs6000_long_double_size so that 126..128 selects an\n\tappropriate 128-bit floating point type.\n\t(rs6000_option_override_internal): Likewise.\n\t* config/rs6000/rs6000.h (toplevel): Include rs6000-modes.h.\n\t(TARGET_LONG_DOUBLE_128): Change the meaning of\n\trs6000_long_double_size so that 126..128 selects an appropriate\n\t128-bit floating point type.\n\t(LONG_DOUBLE_TYPE_SIZE): Update comment.\n\t* config/rs6000/rs6000.md (trunciftf2): Correct the modes of the\n\tsource and destination to match the standard usage.\n\t(truncifkf2): Likewise.\n\t(copysign<mode>3, IEEE iterator): Rework copysign of float128 on\n\tISA 2.07 to use an explicit clobber, instead of passing in a\n\ttemporary.\n\t(copysign<mode>3_soft): Likewise.\n\n[libgcc]\n2018-06-18  Michael Meissner  <meissner@linux.ibm.com>\n\n\t* config/rs6000/t-float128 (FP128_CFLAGS_SW): Compile float128\n\tsupport modules with -mno-gnu-attribute.\n\t* config/rs6000/t-float128-hw (FP128_CFLAGS_HW): Likewise.\n\nFrom-SVN: r261712", "tree": {"sha": "8005da91b739ec8d9e6b89e3b0a29707aff9b968", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8005da91b739ec8d9e6b89e3b0a29707aff9b968"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/comments", "author": null, "committer": null, "parents": [{"sha": "b0874c667d1bcc7e414f130dd4ec3973d388dbfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0874c667d1bcc7e414f130dd4ec3973d388dbfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0874c667d1bcc7e414f130dd4ec3973d388dbfb"}], "stats": {"total": 164, "additions": 136, "deletions": 28}, "files": [{"sha": "6a7359730ef0692729cbdd23934f62f8cd2e0289", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "patch": "@@ -1,3 +1,34 @@\n+2018-06-18  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\tPR target/85358\n+\t* config/rs6000/rs6000-modes.def (toplevel): Rework the 128-bit\n+\tfloating point modes, so that IFmode is numerically greater than\n+\tTFmode, which is greater than KFmode using FRACTIONAL_FLOAT_MODE\n+\tto declare the ordering.  This prevents IFmode from being\n+\tconverted to TFmode when long double is IEEE 128-bit on an ISA 3.0\n+\tmachine.  Include rs6000-modes.h to share the fractional values\n+\tbetween genmodes* and the rest of the compiler.\n+\t(IFmode): Likewise.\n+\t(KFmode): Likewise.\n+\t(TFmode): Likewise.\n+\t* config/rs6000/rs6000-modes.h: New file.\n+\t* config/rs6000/rs6000.c (rs6000_debug_reg_global): Change the\n+\tmeaning of rs6000_long_double_size so that 126..128 selects an\n+\tappropriate 128-bit floating point type.\n+\t(rs6000_option_override_internal): Likewise.\n+\t* config/rs6000/rs6000.h (toplevel): Include rs6000-modes.h.\n+\t(TARGET_LONG_DOUBLE_128): Change the meaning of\n+\trs6000_long_double_size so that 126..128 selects an appropriate\n+\t128-bit floating point type.\n+\t(LONG_DOUBLE_TYPE_SIZE): Update comment.\n+\t* config/rs6000/rs6000.md (trunciftf2): Correct the modes of the\n+\tsource and destination to match the standard usage.\n+\t(truncifkf2): Likewise.\n+\t(copysign<mode>3, IEEE iterator): Rework copysign of float128 on\n+\tISA 2.07 to use an explicit clobber, instead of passing in a\n+\ttemporary.\n+\t(copysign<mode>3_soft): Likewise.\n+\n 2018-06-18  David Malcolm  <dmalcolm@redhat.com>\n \n \t* tree-vect-data-refs.c (vect_analyze_data_ref_dependences):"}, {"sha": "1bdbda7d0b272ab2cc32a2a1b666d89c399f1653", "filename": "gcc/config/rs6000/rs6000-modes.def", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-modes.def?ref=6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "patch": "@@ -18,16 +18,39 @@\n    along with GCC; see the file COPYING3.  If not see\n    <http://www.gnu.org/licenses/>.  */\n \n-/* IBM 128-bit floating point.  IFmode and KFmode use the fractional float\n-   support in order to declare 3 128-bit floating point types.  */\n-FRACTIONAL_FLOAT_MODE (IF, 106, 16, ibm_extended_format);\n+/* We order the 3 128-bit floating point types so that IFmode (IBM 128-bit\n+   floating point) is the 128-bit floating point type with the highest\n+   precision (128 bits).  This so that machine independent parts of the\n+   compiler do not try to widen IFmode to TFmode on ISA 3.0 (power9) that has\n+   hardware support for IEEE 128-bit.  We set TFmode (long double mode) in\n+   between, and KFmode (explicit __float128) below it.\n+\n+   Previously, IFmode and KFmode were defined to be fractional modes and TFmode\n+   was the standard mode.  Since IFmode does not define the normal arithmetic\n+   insns (other than neg/abs), on a ISA 3.0 system, the machine independent\n+   parts of the compiler would see that TFmode has the necessary hardware\n+   support, and widen the operation from IFmode to TFmode.  However, IEEE\n+   128-bit is not strictly a super-set of IBM extended double and the\n+   conversion to/from IEEE 128-bit was a function call.\n+\n+   We now make IFmode the highest fractional mode, which means its values are\n+   not considered for widening.  Since we don't define insns for IFmode, the\n+   IEEE 128-bit modes would not widen to IFmode.  */\n+\n+#ifndef RS6000_MODES_H\n+#include \"config/rs6000/rs6000-modes.h\"\n+#endif\n+\n+/* IBM 128-bit floating point.  */\n+FRACTIONAL_FLOAT_MODE (IF, FLOAT_PRECISION_IFmode, 16, ibm_extended_format);\n \n /* Explicit IEEE 128-bit floating point.  */\n-FRACTIONAL_FLOAT_MODE (KF, 113, 16, ieee_quad_format);\n+FRACTIONAL_FLOAT_MODE (KF, FLOAT_PRECISION_KFmode, 16, ieee_quad_format);\n \n-/* 128-bit floating point.  ABI_V4 uses IEEE quad, AIX/Darwin\n-   adjust this in rs6000_option_override_internal.  */\n-FLOAT_MODE (TF, 16, ieee_quad_format);\n+/* 128-bit floating point, either IBM 128-bit or IEEE 128-bit.  This is\n+   adjusted in rs6000_option_override_internal to be the appropriate floating\n+   point type.  */\n+FRACTIONAL_FLOAT_MODE (TF, FLOAT_PRECISION_TFmode, 16, ieee_quad_format);\n \n /* Add any extra modes needed to represent the condition code.\n "}, {"sha": "b65a5fa0cd6bf15eb2aa6cd353a23fa66530ba79", "filename": "gcc/config/rs6000/rs6000-modes.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2Fconfig%2Frs6000%2Frs6000-modes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2Fconfig%2Frs6000%2Frs6000-modes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-modes.h?ref=6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "patch": "@@ -0,0 +1,36 @@\n+/* Definitions 128-bit floating point precisions used by PowerPC.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+   Contributed by Michael Meissner (meissner@linux.ibm.com)\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published\n+   by the Free Software Foundation; either version 3, or (at your\n+   option) any later version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public\n+   License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* We order the 3 128-bit floating point types so that IFmode (IBM 128-bit\n+   floating point) is the 128-bit floating point type with the highest\n+   precision (128 bits).  This so that machine independent parts of the\n+   compiler do not try to widen IFmode to TFmode on ISA 3.0 (power9) that has\n+   hardware support for IEEE 128-bit.  We set TFmode (long double mode) in\n+   between, and KFmode (explicit __float128) below it.\n+\n+   We won't encounter conversion from IEEE 128-bit to IBM 128-bit because we\n+   don't have insns to support the IBM 128-bit aritmetic operations.  */\n+\n+#ifndef RS6000_MODES_H\n+#define RS6000_MODES_H\t\t1\n+#define FLOAT_PRECISION_IFmode\t128\n+#define FLOAT_PRECISION_TFmode\t127\n+#define FLOAT_PRECISION_KFmode\t126\n+#endif\t/* RS6000_MODES_H */"}, {"sha": "31c5bcff50d3f27f777f943b8bad8021b06a5cd2", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "patch": "@@ -2887,7 +2887,7 @@ rs6000_debug_reg_global (void)\n   fprintf (stderr, DEBUG_FMT_D, \"tls_size\", rs6000_tls_size);\n   fprintf (stderr, DEBUG_FMT_D, \"long_double_size\",\n \t   rs6000_long_double_type_size);\n-  if (rs6000_long_double_type_size == 128)\n+  if (rs6000_long_double_type_size > 64)\n     {\n       fprintf (stderr, DEBUG_FMT_S, \"long double type\",\n \t       TARGET_IEEEQUAD ? \"IEEE\" : \"IBM\");\n@@ -4558,16 +4558,25 @@ rs6000_option_override_internal (bool global_init_p)\n \t}\n     }\n \n+  /* Use long double size to select the appropriate long double.  We use\n+     TYPE_PRECISION to differentiate the 3 different long double types.  We map\n+     128 into the precision used for TFmode.  */\n+  int default_long_double_size = (RS6000_DEFAULT_LONG_DOUBLE_SIZE == 64\n+\t\t\t\t  ? 64\n+\t\t\t\t  : FLOAT_PRECISION_TFmode);\n+\n   /* Set long double size before the IEEE 128-bit tests.  */\n   if (!global_options_set.x_rs6000_long_double_type_size)\n     {\n       if (main_target_opt != NULL\n \t  && (main_target_opt->x_rs6000_long_double_type_size\n-\t      != RS6000_DEFAULT_LONG_DOUBLE_SIZE))\n+\t      != default_long_double_size))\n \terror (\"target attribute or pragma changes long double size\");\n       else\n-\trs6000_long_double_type_size = RS6000_DEFAULT_LONG_DOUBLE_SIZE;\n+\trs6000_long_double_type_size = default_long_double_size;\n     }\n+  else if (rs6000_long_double_type_size == 128)\n+    rs6000_long_double_type_size = FLOAT_PRECISION_TFmode;\n \n   /* Set -mabi=ieeelongdouble on some old targets.  In the future, power server\n      systems will also set long double to be IEEE 128-bit.  AIX and Darwin"}, {"sha": "455b03ed83294e739b7d251e32efe07b97faae1c", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "patch": "@@ -30,6 +30,11 @@\n #include \"config/rs6000/rs6000-opts.h\"\n #endif\n \n+/* 128-bit floating point precision values.  */\n+#ifndef RS6000_MODES_H\n+#include \"config/rs6000/rs6000-modes.h\"\n+#endif\n+\n /* Definitions for the object file format.  These are set at\n    compile-time.  */\n \n@@ -539,7 +544,9 @@ extern int rs6000_vector_align[];\n #define TARGET_ALIGN_NATURAL 0\n #endif\n \n-#define TARGET_LONG_DOUBLE_128 (rs6000_long_double_type_size == 128)\n+/* We use values 126..128 to pick the appropriate long double type (IFmode,\n+   KFmode, TFmode).  */\n+#define TARGET_LONG_DOUBLE_128 (rs6000_long_double_type_size > 64)\n #define TARGET_IEEEQUAD rs6000_ieeequad\n #define TARGET_ALTIVEC_ABI rs6000_altivec_abi\n #define TARGET_LDBRX (TARGET_POPCNTD || rs6000_cpu == PROCESSOR_CELL)\n@@ -865,9 +872,8 @@ extern unsigned char rs6000_recip_bits[];\n    words.  */\n #define DOUBLE_TYPE_SIZE 64\n \n-/* A C expression for the size in bits of the type `long double' on\n-   the target machine.  If you don't define this, the default is two\n-   words.  */\n+/* A C expression for the size in bits of the type `long double' on the target\n+   machine.  If you don't define this, the default is two words.  */\n #define LONG_DOUBLE_TYPE_SIZE rs6000_long_double_type_size\n \n /* Work around rs6000_long_double_type_size dependency in ada/targtyps.c.  */"}, {"sha": "e5c4cf176ea0f8f5e820fc3a5d29e45f77899089", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "patch": "@@ -8159,17 +8159,17 @@\n })\n \n (define_expand \"trunciftf2\"\n-  [(set (match_operand:IF 0 \"gpc_reg_operand\")\n-\t(float_truncate:IF (match_operand:TF 1 \"gpc_reg_operand\")))]\n+  [(set (match_operand:TF 0 \"gpc_reg_operand\")\n+\t(float_truncate:TF (match_operand:IF 1 \"gpc_reg_operand\")))]\n   \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n   DONE;\n })\n \n (define_expand \"truncifkf2\"\n-  [(set (match_operand:IF 0 \"gpc_reg_operand\")\n-\t(float_truncate:IF (match_operand:KF 1 \"gpc_reg_operand\")))]\n+  [(set (match_operand:KF 0 \"gpc_reg_operand\")\n+\t(float_truncate:KF (match_operand:IF 1 \"gpc_reg_operand\")))]\n   \"TARGET_FLOAT128_TYPE\"\n {\n   rs6000_expand_float128_convert (operands[0], operands[1], false);\n@@ -14102,11 +14102,8 @@\n     emit_insn (gen_copysign<mode>3_hard (operands[0], operands[1],\n \t\t\t\t\t operands[2]));\n   else\n-    {\n-      rtx tmp = gen_reg_rtx (<MODE>mode);\n-      emit_insn (gen_copysign<mode>3_soft (operands[0], operands[1],\n-\t\t\t\t\t   operands[2], tmp));\n-    }\n+    emit_insn (gen_copysign<mode>3_soft (operands[0], operands[1],\n+\t\t\t\t\t operands[2]));\n   DONE;\n })\n \n@@ -14125,9 +14122,9 @@\n   [(set (match_operand:IEEE128 0 \"altivec_register_operand\" \"=v\")\n \t(unspec:IEEE128\n \t [(match_operand:IEEE128 1 \"altivec_register_operand\" \"v\")\n-\t  (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")\n-\t  (match_operand:IEEE128 3 \"altivec_register_operand\" \"+v\")]\n-\t UNSPEC_COPYSIGN))]\n+\t  (match_operand:IEEE128 2 \"altivec_register_operand\" \"v\")]\n+\t UNSPEC_COPYSIGN))\n+   (clobber (match_scratch:IEEE128 3 \"=&v\"))]\n   \"!TARGET_FLOAT128_HW && FLOAT128_IEEE_P (<MODE>mode)\"\n    \"xscpsgndp %x3,%x2,%x1\\;xxpermdi %x0,%x3,%x1,1\"\n   [(set_attr \"type\" \"veccomplex\")"}, {"sha": "65efe170755c1678ddc38e0a86d9ebefe6544012", "filename": "libgcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/libgcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/libgcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2FChangeLog?ref=6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "patch": "@@ -1,3 +1,9 @@\n+2018-06-18  Michael Meissner  <meissner@linux.ibm.com>\n+\n+\t* config/rs6000/t-float128 (FP128_CFLAGS_SW): Compile float128\n+\tsupport modules with -mno-gnu-attribute.\n+\t* config/rs6000/t-float128-hw (FP128_CFLAGS_HW): Likewise.\n+\n 2018-06-07  Olivier Hainque  <hainque@adacore.com>\n \n \t* config/t-vxworks (LIBGCC_INCLUDES): Add"}, {"sha": "d541344518902cbcf200a454c5efdf2fbe200d22", "filename": "libgcc/config/rs6000/t-float128", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/libgcc%2Fconfig%2Frs6000%2Ft-float128", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/libgcc%2Fconfig%2Frs6000%2Ft-float128", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ft-float128?ref=6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "patch": "@@ -59,7 +59,7 @@ fp128_includes\t\t= $(srcdir)/soft-fp/double.h \\\n \n # Build the emulator without ISA 3.0 hardware support.\n FP128_CFLAGS_SW\t\t = -Wno-type-limits -mvsx -mfloat128 \\\n-\t\t\t   -mno-float128-hardware \\\n+\t\t\t   -mno-float128-hardware -mno-gnu-attribute \\\n \t\t\t   -I$(srcdir)/soft-fp \\\n \t\t\t   -I$(srcdir)/config/rs6000 \\\n \t\t\t   $(FLOAT128_HW_INSNS)"}, {"sha": "d64ca4dd69438bb1a01cef65ee2a8de534c71aba", "filename": "libgcc/config/rs6000/t-float128-hw", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/libgcc%2Fconfig%2Frs6000%2Ft-float128-hw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a8886e45f7eb6684f4e27b9d823ea3d02df787c/libgcc%2Fconfig%2Frs6000%2Ft-float128-hw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig%2Frs6000%2Ft-float128-hw?ref=6a8886e45f7eb6684f4e27b9d823ea3d02df787c", "patch": "@@ -25,7 +25,7 @@ fp128_sed_hw\t\t= -hw\n # Build the hardware support functions with appropriate hardware support\n FP128_CFLAGS_HW\t\t = -Wno-type-limits -mvsx -mfloat128 \\\n \t\t\t   -mpower8-vector -mpower9-vector \\\n-\t\t\t   -mfloat128-hardware \\\n+\t\t\t   -mfloat128-hardware -mno-gnu-attribute \\\n \t\t\t   -I$(srcdir)/soft-fp \\\n \t\t\t   -I$(srcdir)/config/rs6000 \\\n \t\t\t   $(FLOAT128_HW_INSNS)"}]}