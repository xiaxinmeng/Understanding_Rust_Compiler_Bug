{"sha": "351e7c3b5fbd45bde3efb601f7fee9a31c4f2063", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzUxZTdjM2I1ZmJkNDViZGUzZWZiNjAxZjdmZWU5YTMxYzRmMjA2Mw==", "commit": {"author": {"name": "Feng Xue", "email": "fxue@os.amperecomputing.com", "date": "2019-09-17T12:30:08Z"}, "committer": {"name": "Feng Xue", "email": "fxue@gcc.gnu.org", "date": "2019-09-17T12:30:08Z"}, "message": "PR ipa/91089 - Setup predicate for switch default case in IPA\n\n2019-09-17  Feng Xue  <fxue@os.amperecomputing.com>\n\n        PR ipa/91089\n        * doc/invoke.texi (ipa-max-switch-predicate-bounds): Document new\n        option.\n        * params.def (PARAM_IPA_MAX_SWITCH_PREDICATE_BOUNDS): New.\n        * ipa-fnsummary.c (set_switch_stmt_execution_predicate): Add predicate\n        for switch default case using range analysis information.\n\n2019-09-17  Feng Xue  <fxue@os.amperecomputing.com>\n\n        PR ipa/91089\n        * gcc.dg/ipa/pr91089.c: New test.\n\nFrom-SVN: r275802", "tree": {"sha": "a8c77dee290a445c6d2f16f5b66fa8ea260824b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8c77dee290a445c6d2f16f5b66fa8ea260824b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/comments", "author": {"login": "feng-xue-ampere", "id": 95893536, "node_id": "U_kgDOBbc4IA", "avatar_url": "https://avatars.githubusercontent.com/u/95893536?v=4", "gravatar_id": "", "url": "https://api.github.com/users/feng-xue-ampere", "html_url": "https://github.com/feng-xue-ampere", "followers_url": "https://api.github.com/users/feng-xue-ampere/followers", "following_url": "https://api.github.com/users/feng-xue-ampere/following{/other_user}", "gists_url": "https://api.github.com/users/feng-xue-ampere/gists{/gist_id}", "starred_url": "https://api.github.com/users/feng-xue-ampere/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/feng-xue-ampere/subscriptions", "organizations_url": "https://api.github.com/users/feng-xue-ampere/orgs", "repos_url": "https://api.github.com/users/feng-xue-ampere/repos", "events_url": "https://api.github.com/users/feng-xue-ampere/events{/privacy}", "received_events_url": "https://api.github.com/users/feng-xue-ampere/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c4ccdc0e63150d1cab2686a16dafeb7520315cb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4ccdc0e63150d1cab2686a16dafeb7520315cb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4ccdc0e63150d1cab2686a16dafeb7520315cb2"}], "stats": {"total": 211, "additions": 204, "deletions": 7}, "files": [{"sha": "0cbb512bb1d75c757987a262845760f271bda4df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=351e7c3b5fbd45bde3efb601f7fee9a31c4f2063", "patch": "@@ -1,3 +1,12 @@\n+2019-09-17  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/91089\n+\t* doc/invoke.texi (ipa-max-switch-predicate-bounds): Document new\n+\toption.\n+\t* params.def (PARAM_IPA_MAX_SWITCH_PREDICATE_BOUNDS): New.\n+\t* ipa-fnsummary.c (set_switch_stmt_execution_predicate): Add predicate\n+\tfor switch default case using range analysis information.\n+\n 2019-09-17  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \tPR target/91749"}, {"sha": "0e3693598e7b3d64b9a231679923fe9e7c068e13", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=351e7c3b5fbd45bde3efb601f7fee9a31c4f2063", "patch": "@@ -11937,6 +11937,12 @@ not spend too much time analyzing huge functions, it gives up and\n consider all memory clobbered after examining\n @option{ipa-max-aa-steps} statements modifying memory.\n \n+@item ipa-max-switch-predicate-bounds\n+Maximal number of boundary endpoints of case ranges of switch statement.\n+For switch exceeding this limit, IPA-CP will not construct cloning cost\n+predicate, which is used to estimate cloning benefit, for default case\n+of the switch statement.\n+\n @item lto-partitions\n Specify desired number of partitions produced during WHOPR compilation.\n The number of partitions should exceed the number of CPUs used for compilation."}, {"sha": "1bf1806eaf8e6fe9de5e4fa45a86247c798dafdf", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 116, "deletions": 7, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=351e7c3b5fbd45bde3efb601f7fee9a31c4f2063", "patch": "@@ -1269,13 +1269,21 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n   if (!unmodified_parm_or_parm_agg_item (fbi, last, op, &index, &size, &aggpos))\n     return;\n \n+  auto_vec<std::pair<tree, tree> > ranges;\n+  tree type = TREE_TYPE (op);\n+  int bound_limit = PARAM_VALUE (PARAM_IPA_MAX_SWITCH_PREDICATE_BOUNDS);\n+  int bound_count = 0;\n+  wide_int vr_wmin, vr_wmax;\n+  value_range_kind vr_type = get_range_info (op, &vr_wmin, &vr_wmax);\n+\n   FOR_EACH_EDGE (e, ei, bb->succs)\n     {\n       e->aux = edge_predicate_pool.allocate ();\n       *(predicate *) e->aux = false;\n     }\n+\n   n = gimple_switch_num_labels (last);\n-  for (case_idx = 0; case_idx < n; ++case_idx)\n+  for (case_idx = 1; case_idx < n; ++case_idx)\n     {\n       tree cl = gimple_switch_label (last, case_idx);\n       tree min, max;\n@@ -1285,12 +1293,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       min = CASE_LOW (cl);\n       max = CASE_HIGH (cl);\n \n-      /* For default we might want to construct predicate that none\n-         of cases is met, but it is bit hard to do not having negations\n-         of conditionals handy.  */\n-      if (!min && !max)\n-\tp = true;\n-      else if (!max)\n+      if (!max)\n \tp = add_condition (summary, index, size, &aggpos, EQ_EXPR,\n \t\t\t   unshare_expr_without_location (min));\n       else\n@@ -1304,7 +1307,113 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t}\n       *(class predicate *) e->aux\n \t= p.or_with (summary->conds, *(class predicate *) e->aux);\n+\n+      /* If there are too many disjoint case ranges, predicate for default\n+\t case might become too complicated.  So add a limit here.  */\n+      if (bound_count > bound_limit)\n+\tcontinue;\n+\n+      bool new_range = true;\n+\n+      if (!ranges.is_empty ())\n+\t{\n+\t  wide_int curr_wmin = wi::to_wide (min);\n+\t  wide_int last_wmax = wi::to_wide (ranges.last ().second);\n+\n+\t  /* Merge case ranges if they are continuous.  */\n+\t  if (curr_wmin == last_wmax + 1)\n+\t    new_range = false;\n+\t  else if (vr_type == VR_ANTI_RANGE)\n+\t    {\n+\t      /* If two disjoint case ranges can be connected by anti-range\n+\t\t of switch index, combine them to one range.  */\n+\t      if (wi::lt_p (vr_wmax, curr_wmin - 1, TYPE_SIGN (type)))\n+\t\tvr_type = VR_UNDEFINED;\n+\t      else if (wi::le_p (vr_wmin, last_wmax + 1, TYPE_SIGN (type)))\n+\t\tnew_range = false;\n+\t    }\n+\t}\n+\n+      if (!max)\n+\tmax = min;\n+\n+      /* Create/extend a case range.  And we count endpoints of range set,\n+\t this number nearly equals to number of conditions that we will create\n+\t for predicate of default case.  */\n+      if (new_range)\n+\t{\n+\t  bound_count += (min == max) ? 1 : 2;\n+\t  ranges.safe_push (std::make_pair (min, max));\n+\t}\n+      else\n+\t{\n+\t  bound_count += (ranges.last ().first == ranges.last ().second);\n+\t  ranges.last ().second = max;\n+\t}\n+    }\n+\n+  e = gimple_switch_edge (cfun, last, 0);\n+  if (bound_count > bound_limit)\n+    {\n+      *(class predicate *) e->aux = true;\n+      return;\n     }\n+\n+  predicate p_seg = true;\n+  predicate p_all = false;\n+\n+  if (vr_type != VR_RANGE)\n+    {\n+      vr_wmin = wi::to_wide (TYPE_MIN_VALUE (type));\n+      vr_wmax = wi::to_wide (TYPE_MAX_VALUE (type));\n+    }\n+\n+  /* Construct predicate to represent default range set that is negation of\n+     all case ranges.  Case range is classified as containing single/non-single\n+     values.  Suppose a piece of case ranges in the following.\n+\n+                [D1...D2]  [S1] ... [Sn]  [D3...D4]\n+\n+     To represent default case's range sets between two non-single value\n+     case ranges (From D2 to D3), we construct predicate as:\n+\n+              D2 < x < D3 && x != S1 && ... && x != Sn\n+   */\n+  for (size_t i = 0; i < ranges.length (); i++)\n+    {\n+      tree min = ranges[i].first;\n+      tree max = ranges[i].second;\n+\n+      if (min == max)\n+\tp_seg &= add_condition (summary, index, size, &aggpos, NE_EXPR,\n+\t\t\t\tunshare_expr_without_location (min));\n+      else\n+\t{\n+\t  /* Do not create sub-predicate for range that is beyond low bound\n+\t     of switch index.  */\n+\t  if (wi::lt_p (vr_wmin, wi::to_wide (min), TYPE_SIGN (type)))\n+\t    {\n+\t      p_seg &= add_condition (summary, index, size, &aggpos, LT_EXPR,\n+\t\t\t\t      unshare_expr_without_location (min));\n+\t      p_all = p_all.or_with (summary->conds, p_seg);\n+\t    }\n+\n+\t  /* Do not create sub-predicate for range that is beyond up bound\n+\t     of switch index.  */\n+\t  if (wi::le_p (vr_wmax, wi::to_wide (max), TYPE_SIGN (type)))\n+\t    {\n+\t      p_seg = false;\n+\t      break;\n+\t    }\n+\n+\t  p_seg = add_condition (summary, index, size, &aggpos, GT_EXPR,\n+\t\t\t\t unshare_expr_without_location (max));\n+\t}\n+    }\n+\n+  p_all = p_all.or_with (summary->conds, p_seg);\n+  *(class predicate *) e->aux\n+    = p_all.or_with (summary->conds, *(class predicate *) e->aux);\n }\n \n "}, {"sha": "5fe33976b37bb0763986040f66a9c28681363535", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=351e7c3b5fbd45bde3efb601f7fee9a31c4f2063", "patch": "@@ -1123,6 +1123,12 @@ DEFPARAM (PARAM_IPA_MAX_AA_STEPS,\n \t  \"parameter analysis based on alias analysis in any given function.\",\n \t  25000, 0, 0)\n \n+DEFPARAM (PARAM_IPA_MAX_SWITCH_PREDICATE_BOUNDS,\n+\t  \"ipa-max-switch-predicate-bounds\",\n+\t  \"Maximal number of boundary endpoints of case ranges of switch \"\n+\t  \"statement used during IPA functoin summary generation.\",\n+\t  5, 0, 0)\n+\n /* WHOPR partitioning configuration.  */\n \n DEFPARAM (PARAM_LTO_PARTITIONS,"}, {"sha": "1afad7897f7a53198c20f8c5ee3ea563c58d6c84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=351e7c3b5fbd45bde3efb601f7fee9a31c4f2063", "patch": "@@ -1,3 +1,8 @@\n+2019-09-17  Feng Xue  <fxue@os.amperecomputing.com>\n+\n+\tPR ipa/91089\n+\t* gcc.dg/ipa/pr91089.c: New test.\n+\n 2019-09-17  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/91588"}, {"sha": "e9e206fc24d9ed89bd3f5bf55ba4f1fbe7e2a748", "filename": "gcc/testsuite/gcc.dg/ipa/pr91089.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91089.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/351e7c3b5fbd45bde3efb601f7fee9a31c4f2063/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91089.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fpr91089.c?ref=351e7c3b5fbd45bde3efb601f7fee9a31c4f2063", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-cp-details -fdump-ipa-fnsummary-details --param ipa-max-switch-predicate-bounds=10 -fno-inline\" } */\n+\n+int fn ();\n+\n+int data;\n+\n+int callee (int i)\n+{\n+  switch (i)\n+    {\n+      case -126:  return i + 13;\n+      case -127:  return i + 5;\n+      case -8:    return i * i;\n+      case 0:     return i % 9;\n+      case 5:\n+      case 7:\n+      case 6:     return 3;\n+      default:\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+\tfn ();\n+     }\n+\n+  return data += i;\n+}\n+\n+int caller ()\n+{\n+  return callee (-127) +\n+\t callee (-126) +\n+\t callee (-8) +\n+\t callee (0) +\n+\t callee (5) +\n+\t callee (6) +\n+\t callee (7) +\n+\t callee (100);\n+}\n+ \n+/* { dg-final { scan-ipa-dump-times \"Creating a specialized node of callee\" 7 \"cp\" } } */\n+/* { dg-final { scan-ipa-dump \"op0 < -127\" \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump \"op0 > -126\" \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump \"op0 != -8\"  \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump \"op0 != 0\"   \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump \"op0 < 5\"    \"fnsummary\" } } */\n+/* { dg-final { scan-ipa-dump \"op0 > 7\"    \"fnsummary\" } } */"}]}