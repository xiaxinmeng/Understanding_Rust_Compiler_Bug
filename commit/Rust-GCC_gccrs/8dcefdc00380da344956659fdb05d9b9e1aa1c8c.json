{"sha": "8dcefdc00380da344956659fdb05d9b9e1aa1c8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRjZWZkYzAwMzgwZGEzNDQ5NTY2NTlmZGIwNWQ5YjllMWFhMWM4Yw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2018-10-09T15:05:49Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2018-10-09T15:05:49Z"}, "message": "[Ada] Remove spurious -Wuninitialized warning for small array at -O2\n\n2018-10-09  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* gcc-interface/decl.c (type_requires_init_of_formal): New\n\tpredicate.\n\t(gnat_to_gnu_param): Use it to determine whether a PARM_DECL\n\tmust be created for an Out parameter passed by copy.\n\nFrom-SVN: r264971", "tree": {"sha": "c586194cd8a6240074fa1d71e0fa4a39b7d10c02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c586194cd8a6240074fa1d71e0fa4a39b7d10c02"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dcefdc00380da344956659fdb05d9b9e1aa1c8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dcefdc00380da344956659fdb05d9b9e1aa1c8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dcefdc00380da344956659fdb05d9b9e1aa1c8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dcefdc00380da344956659fdb05d9b9e1aa1c8c/comments", "author": null, "committer": null, "parents": [{"sha": "da5f6eb46bcd67d6d3e15c0f43205f70e0d91c2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da5f6eb46bcd67d6d3e15c0f43205f70e0d91c2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da5f6eb46bcd67d6d3e15c0f43205f70e0d91c2d"}], "stats": {"total": 78, "additions": 51, "deletions": 27}, "files": [{"sha": "7f068b7e41e9113e57207c00d2bdcd6bd21d9f17", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcefdc00380da344956659fdb05d9b9e1aa1c8c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcefdc00380da344956659fdb05d9b9e1aa1c8c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8dcefdc00380da344956659fdb05d9b9e1aa1c8c", "patch": "@@ -1,3 +1,10 @@\n+2018-10-09  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/decl.c (type_requires_init_of_formal): New\n+\tpredicate.\n+\t(gnat_to_gnu_param): Use it to determine whether a PARM_DECL\n+\tmust be created for an Out parameter passed by copy.\n+\n 2018-10-09  Arnaud Charlet  <charlet@adacore.com>\n \n \t* libgnat/a-coboho.ads (Storage_Element): Fix a typo."}, {"sha": "ff87529790a060246636b125cdf6699088403f90", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dcefdc00380da344956659fdb05d9b9e1aa1c8c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dcefdc00380da344956659fdb05d9b9e1aa1c8c/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=8dcefdc00380da344956659fdb05d9b9e1aa1c8c", "patch": "@@ -5129,6 +5129,43 @@ gnat_to_gnu_component_type (Entity_Id gnat_array, bool definition,\n   return gnu_type;\n }\n \n+/* Return whether TYPE requires that formal parameters of TYPE be initialized\n+   when they are Out parameters passed by copy.\n+\n+   This just implements the set of conditions listed in RM 6.4.1(12).  */\n+\n+static bool\n+type_requires_init_of_formal (Entity_Id type)\n+{\n+  type = Underlying_Type (type);\n+\n+  if (Is_Access_Type (type))\n+    return true;\n+\n+  if (Is_Scalar_Type (type))\n+    return Has_Default_Aspect (type);\n+\n+  if (Is_Array_Type (type))\n+    return Has_Default_Aspect (type)\n+\t   || type_requires_init_of_formal (Component_Type (type));\n+\n+  if (Is_Record_Type (type))\n+    for (Entity_Id field = First_Entity (type);\n+\t Present (field);\n+\t field = Next_Entity (field))\n+      {\n+\tif (Ekind (field) == E_Discriminant)\n+\t  return true;\n+\n+\tif (Ekind (field) == E_Component\n+\t    && (Present (Expression (Parent (field)))\n+\t\t|| type_requires_init_of_formal (Etype (field))))\n+\t  return true;\n+      }\n+\n+  return false;\n+}\n+\n /* Return a GCC tree for a parameter corresponding to GNAT_PARAM, to be placed\n    in the parameter list of GNAT_SUBPROG.  GNU_PARAM_TYPE is the GCC tree for\n    the type of the parameter.  FIRST is true if this is the first parameter in\n@@ -5143,7 +5180,6 @@ static tree\n gnat_to_gnu_param (Entity_Id gnat_param, tree gnu_param_type, bool first,\n \t\t   Entity_Id gnat_subprog, bool *cico)\n {\n-  Entity_Id gnat_param_type = Etype (gnat_param);\n   Mechanism_Type mech = Mechanism (gnat_param);\n   tree gnu_param_name = get_entity_name (gnat_param);\n   bool foreign = Has_Foreign_Convention (gnat_subprog);\n@@ -5295,34 +5331,15 @@ gnat_to_gnu_param (Entity_Id gnat_param, tree gnu_param_type, bool first,\n   if (mech == By_Copy && (by_ref || by_component_ptr))\n     post_error (\"?cannot pass & by copy\", gnat_param);\n \n-  /* If this is an Out parameter that isn't passed by reference and isn't\n-     a pointer or aggregate, we don't make a PARM_DECL for it.  Instead,\n-     it will be a VAR_DECL created when we process the procedure, so just\n-     return its type.  For the special parameter of a valued procedure,\n-     never pass it in.\n-\n-     An exception is made to cover the RM-6.4.1 rule requiring \"by copy\"\n-     Out parameters with discriminants or implicit initial values to be\n-     handled like In Out parameters.  These type are normally built as\n-     aggregates, hence passed by reference, except for some packed arrays\n-     which end up encoded in special integer types.  Note that scalars can\n-     be given implicit initial values using the Default_Value aspect.\n-\n-     The exception we need to make is then for packed arrays of records\n-     with discriminants or implicit initial values.  We have no light/easy\n-     way to check for the latter case, so we merely check for packed arrays\n-     of records.  This may lead to useless copy-in operations, but in very\n-     rare cases only, as these would be exceptions in a set of already\n-     exceptional situations.  */\n+  /* If this is an Out parameter that isn't passed by reference and whose\n+     type doesn't require the initialization of formals, we don't make a\n+     PARM_DECL for it.  Instead, it will be a VAR_DECL created when we\n+     process the procedure, so just return its type here.  Likewise for\n+     the special parameter of a valued procedure, never pass it in.  */\n   if (Ekind (gnat_param) == E_Out_Parameter\n       && !by_ref\n-      && (by_return\n-\t  || (!POINTER_TYPE_P (gnu_param_type)\n-\t      && !AGGREGATE_TYPE_P (gnu_param_type)\n-\t      && !Has_Default_Aspect (gnat_param_type)))\n-      && !(Is_Array_Type (gnat_param_type)\n-\t   && Is_Packed (gnat_param_type)\n-\t   && Is_Composite_Type (Component_Type (gnat_param_type))))\n+      && !by_component_ptr\n+      && (!type_requires_init_of_formal (Etype (gnat_param)) || by_return))\n     return gnu_param_type;\n \n   gnu_param = create_param_decl (gnu_param_name, gnu_param_type);"}]}