{"sha": "5e18f6d629b6956b5e669921073fe951f93d1fac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWUxOGY2ZDYyOWI2OTU2YjVlNjY5OTIxMDczZmU5NTFmOTNkMWZhYw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "2000-11-23T06:04:16Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-11-23T06:04:16Z"}, "message": "parse.y (build_outer_field_access): New local `decl_ctx', use it.\n\n2000-11-22  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (build_outer_field_access): New local `decl_ctx', use\n\tit. Check for field's context and current class immediate outer\n\tcontext inheritance.\n\t(outer_field_access_p): Consider fields inherited from the last\n\tenclosing context.\n\t(build_access_to_thisn): Stop at the last enclosing context if\n\tnecessary.\n\tFixes gcj/367.\n\n(http://gcc.gnu.org/ml/gcc-patches/2000-11/msg01335.html)\n\nFrom-SVN: r37689", "tree": {"sha": "3c74edddfbfa61e4f31307fd8dda94eae1d5cea2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c74edddfbfa61e4f31307fd8dda94eae1d5cea2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e18f6d629b6956b5e669921073fe951f93d1fac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e18f6d629b6956b5e669921073fe951f93d1fac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e18f6d629b6956b5e669921073fe951f93d1fac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e18f6d629b6956b5e669921073fe951f93d1fac/comments", "author": null, "committer": null, "parents": [{"sha": "54214152bd83582233b1179ea9a6d924cd817499", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54214152bd83582233b1179ea9a6d924cd817499", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54214152bd83582233b1179ea9a6d924cd817499"}], "stats": {"total": 43, "additions": 34, "deletions": 9}, "files": [{"sha": "02b70d01ad689a2c632b5695d86f8bb2aab9d97d", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e18f6d629b6956b5e669921073fe951f93d1fac/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e18f6d629b6956b5e669921073fe951f93d1fac/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5e18f6d629b6956b5e669921073fe951f93d1fac", "patch": "@@ -1,3 +1,14 @@\n+2000-11-22  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (build_outer_field_access): New local `decl_ctx', use\n+\tit. Check for field's context and current class immediate outer\n+\tcontext inheritance.\n+\t(outer_field_access_p): Consider fields inherited from the last\n+\tenclosing context.\n+\t(build_access_to_thisn): Stop at the last enclosing context if\n+\tnecessary.\n+\tFixes gcj/367.\n+\n Thu Nov 23 02:19:14 2000  J\"orn Rennecke <amylaar@redhat.com>\n \n \t* Make-lang.in (jvspec.o): Depend on $(CONFIG_H)."}, {"sha": "c411054b789c9ca1496136c40bfefe7413ab9b8a", "filename": "gcc/java/parse.y", "status": "modified", "additions": 23, "deletions": 9, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e18f6d629b6956b5e669921073fe951f93d1fac/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e18f6d629b6956b5e669921073fe951f93d1fac/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=5e18f6d629b6956b5e669921073fe951f93d1fac", "patch": "@@ -7837,11 +7837,13 @@ build_outer_field_access (id, decl)\n {\n   tree access = NULL_TREE;\n   tree ctx = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (current_class)));\n+  tree decl_ctx = DECL_CONTEXT (decl);\n \n-  /* If decl's class is the direct outer class of the current_class,\n-     build the access as `this$<n>.<field>'. Note that we will break\n-     the `private' barrier if we're not emitting bytecodes. */\n-  if (ctx == DECL_CONTEXT (decl) \n+  /* If the immediate enclosing context of the current class is the\n+     field decl's class or inherits from it; build the access as\n+     `this$<n>.<field>'. Note that we will break the `private' barrier\n+     if we're not emitting bytecodes. */\n+  if ((ctx == decl_ctx || inherits_from_p (ctx, decl_ctx))\n       && (!FIELD_PRIVATE (decl) || !flag_emit_class_files ))\n     {\n       tree thisn = build_current_thisn (current_class);\n@@ -7857,14 +7859,14 @@ build_outer_field_access (id, decl)\n       /* Now we chain the required number of calls to the access$0 to\n \t get a hold to the enclosing instance we need, and then we\n \t build the field access. */\n-      access = build_access_to_thisn (current_class, DECL_CONTEXT (decl), lc);\n+      access = build_access_to_thisn (current_class, decl_ctx, lc);\n \n       /* If the field is private and we're generating bytecode, then\n          we generate an access method */\n       if (FIELD_PRIVATE (decl) && flag_emit_class_files )\n \t{\n \t  tree name = build_outer_field_access_methods (decl);\n-\t  access = build_outer_field_access_expr (lc, DECL_CONTEXT (decl),\n+\t  access = build_outer_field_access_expr (lc, decl_ctx,\n \t\t\t\t\t\t  name, access, NULL_TREE);\n \t}\n       /* Otherwise we use `access$(this$<j>). ... access$(this$<i>).<field>'.\n@@ -7898,8 +7900,15 @@ outer_field_access_p (type, decl)\n     {\n       if (type == DECL_CONTEXT (decl))\n \treturn 1;\n+\n       if (!DECL_CONTEXT (TYPE_NAME (type)))\n-\tbreak;\n+\t{\n+\t  /* Before we give up, see whether the field is inherited from\n+\t     the enclosing context we're considering. */\n+\t  if (inherits_from_p (type, DECL_CONTEXT (decl)))\n+\t    return 1;\n+\t  break;\n+\t}\n     }\n \n   return 0;\n@@ -8221,8 +8230,13 @@ build_access_to_thisn (from, to, lc)\n \t  access = build_method_invocation (access0_wfl, access);\n \t  access = make_qualified_primary (cn, access, lc);\n \t}\n-      \n-      from = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (from)));\n+\n+      /* if FROM isn't an inter class, that's fine, we've done\n+         enough. What we're looking for can be accessed from there. */\n+      from = DECL_CONTEXT (TYPE_NAME (from));\n+      if (!from)\n+\tbreak;\n+      from = TREE_TYPE (from);\n     }\n   return access;\n }"}]}