{"sha": "724256083eea3833f018ae2c2cc7b00209b788b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI0MjU2MDgzZWVhMzgzM2YwMThhZTJjMmNjN2IwMDIwOWI3ODhiNQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "ook@ucw.cz", "date": "2008-03-27T10:25:36Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-03-27T10:25:36Z"}, "message": "tree-affine.h (aff_combination_expand): Declare.\n\n2008-03-27  Zdenek Dvorak  <ook@ucw.cz>\n\n\t* tree-affine.h (aff_combination_expand): Declare.\n\t(get_inner_reference_aff): Likewise.\n\t* tree-affine.c\t(aff_combination_expand): Split out from\n\ttree_to_aff_combination_expand.\n\t(get_inner_reference_aff): New function.\n\t* tree-parloops.c (loop_parallel_p): Free vectorizer info.\n        * tree-ssa-loop-im.c: Include tree-affine.h and pointer-set.h.\n        (struct lim_aux_data): sm_done field removed.\n        (mem_ref_loc_p, mem_ref_locs_p): New types.\n        (struct mem_ref): Added id, stored, accesses_in_loop,\n        indep_loop, dep_loop, indep_ref, dep_ref fields.\n        Removed is_stored, locs and next fields.\n        (memory_accesses): New variable.\n        (movement_possibility): Do not allow moving statements\n        that store to memory.\n        (outermost_indep_loop, simple_mem_ref_in_stmt, mem_ref_in_stmt):\n        New functions.\n        (determine_max_movement): For statements with memory references,\n        find the outermost loop in that the reference is independent.\n        (move_computations_stmt): Mark the virtual operands for\n        renaming.\n        (memref_free, mem_ref_alloc, mem_ref_locs_alloc, mark_ref_stored,\n        gather_mem_refs_stmt, gather_mem_refs_in_loops, vtoe_hash, vtoe_eq,\n        vtoe_free, record_vop_access, get_vop_accesses, get_vop_stores,\n        add_vop_ref_mapping, create_vop_ref_mapping_loop,\n        create_vop_ref_mapping, analyze_memory_references,\n        cannot_overlap_p, mem_refs_may_alias_p, rewrite_mem_ref_loc,\n        get_all_locs_in_loop, ref_always_accessed_p,\n        refs_independent_p, record_indep_loop, ref_indep_loop_p_1,\n        ref_indep_loop_p, can_sm_ref_p, find_refs_for_sm,\n        store_motion_loop, store_motion): New functions.\n        (struct vop_to_refs_elt): New type.\n        (record_mem_ref_loc, free_mem_ref_locs, rewrite_mem_refs,\n        memref_hash, memref_eq, hoist_memory_references): Rewritten.\n        (schedule_sm): Replaced by...\n        (execute_sm): ... this.\n        (determine_lsm_ref, hoist_memory_references,\n        loop_suitable_for_sm, gather_mem_refs_stmt, gather_mem_refs,\n        find_more_ref_vops, free_mem_ref, free_mem_refs,\n        determine_lsm_loop, determine_lsm): Removed.\n        (tree_ssa_lim_finalize): Free data structures used by store\n        motion.\n        (tree_ssa_lim): Call analyze_memory_references.  Use\n        store_motion instead of determine_lsm.\n\n\t* gcc.dg/tree-ssa/loop-32.c: New testcase.\n\t* gcc.dg/tree-ssa/loop-33.c: Likewise.\n\nFrom-SVN: r133637", "tree": {"sha": "560c55a0e9adf79080f4d7db57c4c387d850d3e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/560c55a0e9adf79080f4d7db57c4c387d850d3e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/724256083eea3833f018ae2c2cc7b00209b788b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/724256083eea3833f018ae2c2cc7b00209b788b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/724256083eea3833f018ae2c2cc7b00209b788b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/724256083eea3833f018ae2c2cc7b00209b788b5/comments", "author": {"login": "rakdver", "id": 20416833, "node_id": "MDQ6VXNlcjIwNDE2ODMz", "avatar_url": "https://avatars.githubusercontent.com/u/20416833?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rakdver", "html_url": "https://github.com/rakdver", "followers_url": "https://api.github.com/users/rakdver/followers", "following_url": "https://api.github.com/users/rakdver/following{/other_user}", "gists_url": "https://api.github.com/users/rakdver/gists{/gist_id}", "starred_url": "https://api.github.com/users/rakdver/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rakdver/subscriptions", "organizations_url": "https://api.github.com/users/rakdver/orgs", "repos_url": "https://api.github.com/users/rakdver/repos", "events_url": "https://api.github.com/users/rakdver/events{/privacy}", "received_events_url": "https://api.github.com/users/rakdver/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a929bc2878b1b19fc4fb45bcbccf3af79bc8c24a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a929bc2878b1b19fc4fb45bcbccf3af79bc8c24a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a929bc2878b1b19fc4fb45bcbccf3af79bc8c24a"}], "stats": {"total": 1472, "additions": 1157, "deletions": 315}, "files": [{"sha": "337716a73569f90135bd08397dd72f52ab8b7b3c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=724256083eea3833f018ae2c2cc7b00209b788b5", "patch": "@@ -1,3 +1,50 @@\n+2008-03-27  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\t* tree-affine.h (aff_combination_expand): Declare.\n+\t(get_inner_reference_aff): Likewise.\n+\t* tree-affine.c\t(aff_combination_expand): Split out from\n+\ttree_to_aff_combination_expand.\n+\t(get_inner_reference_aff): New function.\n+\t* tree-parloops.c (loop_parallel_p): Free vectorizer info.\n+        * tree-ssa-loop-im.c: Include tree-affine.h and pointer-set.h.\n+        (struct lim_aux_data): sm_done field removed.\n+        (mem_ref_loc_p, mem_ref_locs_p): New types.\n+        (struct mem_ref): Added id, stored, accesses_in_loop,\n+        indep_loop, dep_loop, indep_ref, dep_ref fields.\n+        Removed is_stored, locs and next fields.\n+        (memory_accesses): New variable.\n+        (movement_possibility): Do not allow moving statements\n+        that store to memory.\n+        (outermost_indep_loop, simple_mem_ref_in_stmt, mem_ref_in_stmt):\n+        New functions.\n+        (determine_max_movement): For statements with memory references,\n+        find the outermost loop in that the reference is independent.\n+        (move_computations_stmt): Mark the virtual operands for\n+        renaming.\n+        (memref_free, mem_ref_alloc, mem_ref_locs_alloc, mark_ref_stored,\n+        gather_mem_refs_stmt, gather_mem_refs_in_loops, vtoe_hash, vtoe_eq,\n+        vtoe_free, record_vop_access, get_vop_accesses, get_vop_stores,\n+        add_vop_ref_mapping, create_vop_ref_mapping_loop,\n+        create_vop_ref_mapping, analyze_memory_references,\n+        cannot_overlap_p, mem_refs_may_alias_p, rewrite_mem_ref_loc,\n+        get_all_locs_in_loop, ref_always_accessed_p,\n+        refs_independent_p, record_indep_loop, ref_indep_loop_p_1,\n+        ref_indep_loop_p, can_sm_ref_p, find_refs_for_sm,\n+        store_motion_loop, store_motion): New functions.\n+        (struct vop_to_refs_elt): New type.\n+        (record_mem_ref_loc, free_mem_ref_locs, rewrite_mem_refs,\n+        memref_hash, memref_eq, hoist_memory_references): Rewritten.\n+        (schedule_sm): Replaced by...\n+        (execute_sm): ... this.\n+        (determine_lsm_ref, hoist_memory_references,\n+        loop_suitable_for_sm, gather_mem_refs_stmt, gather_mem_refs,\n+        find_more_ref_vops, free_mem_ref, free_mem_refs,\n+        determine_lsm_loop, determine_lsm): Removed.\n+        (tree_ssa_lim_finalize): Free data structures used by store\n+        motion.\n+        (tree_ssa_lim): Call analyze_memory_references.  Use\n+        store_motion instead of determine_lsm.\n+\n 2008-03-27  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* config.cc (m68hc11, m6811, m68hc12, m6812): Add usegas.h,"}, {"sha": "2a130ae11d1481cac58b5c2cadc737b73f6519c7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=724256083eea3833f018ae2c2cc7b00209b788b5", "patch": "@@ -1,3 +1,8 @@\n+2008-03-27  Zdenek Dvorak  <ook@ucw.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-32.c: New testcase.\n+\t* gcc.dg/tree-ssa/loop-33.c: Likewise.\n+\n 2008-03-27  Richard Guenther  <rguenther@suse.de>\n \n \t* gcc.dg/fold-addr-1.c: New testcase."}, {"sha": "945ee2fcb8e82e7a16a51a69be885e2b8ef3f2ab", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-32.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-32.c?ref=724256083eea3833f018ae2c2cc7b00209b788b5", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-lim-details\" } */\n+\n+int x;\n+int a[100];\n+\n+struct a\n+{\n+  int X;\n+  int Y;\n+};\n+\n+void bla(void);\n+\n+void test1(void)\n+{\n+  unsigned i;\n+\n+  /* We should perform store motion here.  */\n+  for (x = 0; x < 100; x++)\n+    a[x] = x;\n+}\n+\n+void test2(void)\n+{\n+  unsigned i;\n+\n+  /* But not here.  */\n+  for (x = 0; x < 100; x++)\n+    bla ();\n+}\n+\n+void test3(struct a *A)\n+{\n+  unsigned i;\n+\n+  /* But we should here (using base + offset analysis).  */\n+  for (i = 0; i < 100; i++)\n+    {\n+      A[5].X += i;\n+      A[5].Y += i;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Executing store motion of\" 3 \"lim\" } } */\n+/* { dg-final { cleanup-tree-dump \"lim\" } } */"}, {"sha": "6b9b67f3e33d50f38e3729b424db978486010673", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-33.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-33.c?ref=724256083eea3833f018ae2c2cc7b00209b788b5", "patch": "@@ -0,0 +1,40 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-lim-details\" } */\n+\n+int x;\n+int a[100];\n+\n+struct a\n+{\n+  int X;\n+  int Y;\n+};\n+\n+struct a arr[100];\n+\n+void test4(unsigned b)\n+{\n+  unsigned i;\n+\n+  /* And here.  */\n+  for (i = 0; i < 100; i++)\n+    {\n+      arr[b+8].X += i;\n+      arr[b+9].X += i;\n+    }\n+}\n+\n+void test5(struct a *A, unsigned b)\n+{\n+  unsigned i;\n+\n+  /* And here as well.  */\n+  for (i = 0; i < 100; i++)\n+    {\n+      A[b].X += i;\n+      A[b+1].Y += i;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Executing store motion of\" 4 \"lim\" { xfail lp64 } } } */\n+/* { dg-final { cleanup-tree-dump \"lim\" } } */"}, {"sha": "54f36b98135812ed640c9d7121029b81581ec38e", "filename": "gcc/tree-affine.c", "status": "modified", "additions": 57, "deletions": 15, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftree-affine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftree-affine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.c?ref=724256083eea3833f018ae2c2cc7b00209b788b5", "patch": "@@ -562,19 +562,11 @@ struct name_expansion\n   unsigned in_progress : 1;\n };\n \n-/* Similar to tree_to_aff_combination, but follows SSA name definitions\n-   and expands them recursively.  CACHE is used to cache the expansions\n-   of the ssa names, to avoid exponential time complexity for cases\n-   like\n- \n-   a1 = a0 + a0;\n-   a2 = a1 + a1;\n-   a3 = a2 + a2;\n-   ...  */\n+/* Expands SSA names in COMB recursively.  CACHE is used to cache the\n+   results.  */\n \n void\n-tree_to_aff_combination_expand (tree expr, tree type, aff_tree *comb,\n-\t\t\t\tstruct pointer_map_t **cache)\n+aff_combination_expand (aff_tree *comb, struct pointer_map_t **cache)\n {\n   unsigned i;\n   aff_tree to_add, current, curre;\n@@ -583,8 +575,7 @@ tree_to_aff_combination_expand (tree expr, tree type, aff_tree *comb,\n   void **slot;\n   struct name_expansion *exp;\n \n-  tree_to_aff_combination (expr, type, comb);\n-  aff_combination_zero (&to_add, type);\n+  aff_combination_zero (&to_add, comb->type);\n   for (i = 0; i < comb->n; i++)\n     {\n       e = comb->elts[i].val;\n@@ -616,7 +607,7 @@ tree_to_aff_combination_expand (tree expr, tree type, aff_tree *comb,\n \t  exp = XNEW (struct name_expansion);\n \t  exp->in_progress = 1;\n \t  *slot = exp;\n-\t  tree_to_aff_combination_expand (rhs, type, &current, cache);\n+\t  tree_to_aff_combination_expand (rhs, comb->type, &current, cache);\n \t  exp->expansion = current;\n \t  exp->in_progress = 0;\n \t}\n@@ -632,7 +623,7 @@ tree_to_aff_combination_expand (tree expr, tree type, aff_tree *comb,\n \t COMB while traversing it; include the term -coef * E, to remove\n          it from COMB.  */\n       scale = comb->elts[i].coef;\n-      aff_combination_zero (&curre, type);\n+      aff_combination_zero (&curre, comb->type);\n       aff_combination_add_elt (&curre, e, double_int_neg (scale));\n       aff_combination_scale (&current, scale);\n       aff_combination_add (&to_add, &current);\n@@ -641,6 +632,24 @@ tree_to_aff_combination_expand (tree expr, tree type, aff_tree *comb,\n   aff_combination_add (comb, &to_add);\n }\n \n+/* Similar to tree_to_aff_combination, but follows SSA name definitions\n+   and expands them recursively.  CACHE is used to cache the expansions\n+   of the ssa names, to avoid exponential time complexity for cases\n+   like\n+\n+   a1 = a0 + a0;\n+   a2 = a1 + a1;\n+   a3 = a2 + a2;\n+   ...  */\n+\n+void\n+tree_to_aff_combination_expand (tree expr, tree type, aff_tree *comb,\n+\t\t\t\tstruct pointer_map_t **cache)\n+{\n+  tree_to_aff_combination (expr, type, comb);\n+  aff_combination_expand (comb, cache);\n+}\n+\n /* Frees memory occupied by struct name_expansion in *VALUE.  Callback for\n    pointer_map_traverse.  */\n \n@@ -783,3 +792,36 @@ debug_aff (aff_tree *val)\n   print_aff (stderr, val);\n   fprintf (stderr, \"\\n\");\n }\n+\n+/* Returns address of the reference REF in ADDR.  The size of the accessed\n+   location is stored to SIZE.  */\n+\n+void\n+get_inner_reference_aff (tree ref, aff_tree *addr, double_int *size)\n+{\n+  HOST_WIDE_INT bitsize, bitpos;\n+  tree toff;\n+  enum machine_mode mode;\n+  int uns, vol;\n+  aff_tree tmp;\n+  tree base = get_inner_reference (ref, &bitsize, &bitpos, &toff, &mode,\n+\t\t\t\t   &uns, &vol, false);\n+  tree base_addr = build_fold_addr_expr (base);\n+\n+  /* ADDR = &BASE + TOFF + BITPOS / BITS_PER_UNIT.  */\n+\n+  tree_to_aff_combination (base_addr, sizetype, addr);\n+\n+  if (toff)\n+    {\n+      tree_to_aff_combination (toff, sizetype, &tmp);\n+      aff_combination_add (addr, &tmp);\n+    }\n+\n+  aff_combination_const (&tmp, sizetype,\n+\t\t\t shwi_to_double_int (bitpos / BITS_PER_UNIT));\n+  aff_combination_add (addr, &tmp);\n+\n+  *size = shwi_to_double_int ((bitsize + BITS_PER_UNIT - 1) / BITS_PER_UNIT);\n+}\n+"}, {"sha": "775a384bfff14e55a63637b8257a45b0df7c660e", "filename": "gcc/tree-affine.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftree-affine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftree-affine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-affine.h?ref=724256083eea3833f018ae2c2cc7b00209b788b5", "patch": "@@ -71,8 +71,10 @@ void tree_to_aff_combination (tree, tree, aff_tree *);\n tree aff_combination_to_tree (aff_tree *);\n void unshare_aff_combination (aff_tree *);\n bool aff_combination_constant_multiple_p (aff_tree *, aff_tree *, double_int *);\n+void aff_combination_expand (aff_tree *, struct pointer_map_t **);\n void tree_to_aff_combination_expand (tree, tree, aff_tree *,\n \t\t\t\t     struct pointer_map_t **);\n+void get_inner_reference_aff (tree, aff_tree *, double_int *);\n void free_affine_expand_cache (struct pointer_map_t **);\n \n /* Debugging functions.  */"}, {"sha": "4f3c13e23959fcf75c9f75f7bf2a9c265233bc3c", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=724256083eea3833f018ae2c2cc7b00209b788b5", "patch": "@@ -317,6 +317,9 @@ loop_parallel_p (struct loop *loop, htab_t reduction_list, struct tree_niter_des\n \t}\n     }\n \n+  /* Get rid of the information created by the vectorizer functions.  */\n+  destroy_loop_vec_info (simple_loop_info, true);\n+\n   for (phi = phi_nodes (exit->dest); phi; phi = PHI_CHAIN (phi))\n     {\n       struct reduction_info *red;"}, {"sha": "6402a8e62443527c14e7909e93338929a017a1a4", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 957, "deletions": 300, "changes": 1257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/724256083eea3833f018ae2c2cc7b00209b788b5/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=724256083eea3833f018ae2c2cc7b00209b788b5", "patch": "@@ -38,6 +38,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"real.h\"\n #include \"hashtab.h\"\n+#include \"tree-affine.h\"\n+#include \"pointer-set.h\"\n \n /* TODO:  Support for predicated code motion.  I.e.\n \n@@ -85,10 +87,6 @@ struct lim_aux_data\n \t\t\t\t   the statement is executed if the loop\n \t\t\t\t   is entered.  */\n \n-  bool sm_done;\t\t\t/* True iff the store motion for a memory\n-\t\t\t\t   reference in the statement has already\n-\t\t\t\t   been executed.  */\n-\n   unsigned cost;\t\t/* Cost of the computation performed by the\n \t\t\t\t   statement.  */\n \n@@ -103,34 +101,98 @@ struct lim_aux_data\n \t\t\t? NULL \\\n \t\t\t: (struct lim_aux_data *) (stmt_ann (STMT)->common.aux))\n \n-/* Description of a memory reference location for store motion.  */\n+/* Description of a memory reference location.  */\n \n-struct mem_ref_loc\n+typedef struct mem_ref_loc\n {\n   tree *ref;\t\t\t/* The reference itself.  */\n   tree stmt;\t\t\t/* The statement in that it occurs.  */\n-  struct mem_ref_loc *next;\t/* Next use in the chain.  */\n-};\n+} *mem_ref_loc_p;\n+\n+DEF_VEC_P(mem_ref_loc_p);\n+DEF_VEC_ALLOC_P(mem_ref_loc_p, heap);\n+\n+/* The list of memory reference locations in a loop.  */\n \n-/* Description of a memory reference for store motion.  */\n+typedef struct mem_ref_locs\n+{\n+  VEC (mem_ref_loc_p, heap) *locs;\n+} *mem_ref_locs_p;\n+\n+DEF_VEC_P(mem_ref_locs_p);\n+DEF_VEC_ALLOC_P(mem_ref_locs_p, heap);\n \n-struct mem_ref\n+/* Description of a memory reference.  */\n+\n+typedef struct mem_ref\n {\n   tree mem;\t\t\t/* The memory itself.  */\n+  unsigned id;\t\t\t/* ID assigned to the memory reference\n+\t\t\t\t   (its index in memory_accesses.refs_list)  */\n   hashval_t hash;\t\t/* Its hash value.  */\n-  bool is_stored;\t\t/* True if there is a store to the location\n-\t\t\t\t   in the loop.  */\n-  struct mem_ref_loc *locs;\t/* The locations where it is found.  */\n+  bitmap stored;\t\t/* The set of loops in that this memory locatio\n+\t\t\t\t   is stored to.  */\n+  VEC (mem_ref_locs_p, heap) *accesses_in_loop;\n+\t\t\t\t/* The locations of the accesses.  Vector\n+\t\t\t\t   indexed by the loop number.  */\n   bitmap vops;\t\t\t/* Vops corresponding to this memory\n \t\t\t\t   location.  */\n-  struct mem_ref *next;\t\t/* Next memory reference in the list.\n-\t\t\t\t   Memory references are stored in a hash\n-\t\t\t\t   table, but the hash function depends\n-\t\t\t\t   on values of pointers. Thus we cannot use\n-\t\t\t\t   htab_traverse, since then we would get\n-\t\t\t\t   miscompares during bootstrap (although the\n-\t\t\t\t   produced code would be correct).  */\n-};\n+\n+  /* The following sets are computed on demand.  We keep both set and\n+     its complement, so that we know whether the information was\n+     already computed or not.  */\n+  bitmap indep_loop;\t\t/* The set of loops in that the memory\n+\t\t\t\t   reference is independent, meaning:\n+\t\t\t\t   If it is stored in the loop, this store\n+\t\t\t\t     is independent on all other loads and\n+\t\t\t\t     stores.\n+\t\t\t\t   If it is only loaded, then it is independent\n+\t\t\t\t     on all stores in the loop.  */\n+  bitmap dep_loop;\t\t/* The complement of INDEP_LOOP.  */\n+\n+  bitmap indep_ref;\t\t/* The set of memory references on that\n+\t\t\t\t   this reference is independent.  */\n+  bitmap dep_ref;\t\t/* The complement of DEP_REF.  */\n+} *mem_ref_p;\n+\n+DEF_VEC_P(mem_ref_p);\n+DEF_VEC_ALLOC_P(mem_ref_p, heap);\n+\n+DEF_VEC_P(bitmap);\n+DEF_VEC_ALLOC_P(bitmap, heap);\n+\n+DEF_VEC_P(htab_t);\n+DEF_VEC_ALLOC_P(htab_t, heap);\n+\n+/* Description of memory accesses in loops.  */\n+\n+static struct\n+{\n+  /* The hash table of memory references accessed in loops.  */\n+  htab_t refs;\n+\n+  /* The list of memory references.  */\n+  VEC (mem_ref_p, heap) *refs_list;\n+\n+  /* The set of memory references accessed in each loop.  */\n+  VEC (bitmap, heap) *refs_in_loop;\n+\n+  /* The set of memory references accessed in each loop, including\n+     subloops.  */\n+  VEC (bitmap, heap) *all_refs_in_loop;\n+\n+  /* The set of virtual operands clobbered in a given loop.  */\n+  VEC (bitmap, heap) *clobbered_vops;\n+\n+  /* Map from the pair (loop, virtual operand) to the set of refs that\n+     touch the virtual operand in the loop.  */\n+  VEC (htab_t, heap) *vop_ref_map;\n+\n+  /* Cache for expanding memory addresses.  */\n+  struct pointer_map_t *ttae_cache;\n+} memory_accesses;\n+\n+static bool ref_indep_loop_p (struct loop *, mem_ref_p);\n \n /* Minimum cost of an expensive expression.  */\n #define LIM_EXPENSIVE ((unsigned) PARAM_VALUE (PARAM_LIM_EXPENSIVE))\n@@ -252,6 +314,9 @@ movement_possibility (tree stmt)\n   if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n     return MOVE_IMPOSSIBLE;\n \n+  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_DEFS))\n+    return MOVE_IMPOSSIBLE;\n+\n   if (stmt_ends_bb_p (stmt))\n     return MOVE_IMPOSSIBLE;\n \n@@ -478,6 +543,86 @@ stmt_cost (tree stmt)\n   return cost;\n }\n \n+/* Finds the outermost loop between OUTER and LOOP in that the memory reference\n+   REF is independent.  If REF is not independent in LOOP, NULL is returned\n+   instead.  */\n+\n+static struct loop *\n+outermost_indep_loop (struct loop *outer, struct loop *loop, mem_ref_p ref)\n+{\n+  struct loop *aloop;\n+\n+  if (bitmap_bit_p (ref->stored, loop->num))\n+    return NULL;\n+\n+  for (aloop = outer;\n+       aloop != loop;\n+       aloop = superloop_at_depth (loop, loop_depth (aloop) + 1))\n+    if (!bitmap_bit_p (ref->stored, aloop->num)\n+\t&& ref_indep_loop_p (aloop, ref))\n+      return aloop;\n+\n+  if (ref_indep_loop_p (loop, ref))\n+    return loop;\n+  else\n+    return NULL;\n+}\n+\n+/* If there is a simple load or store to a memory reference in STMT, returns\n+   the location of the memory reference, and sets IS_STORE accoring to whether\n+   it is a store or load.  Otherwise, returns NULL.  */\n+\n+static tree *\n+simple_mem_ref_in_stmt (tree stmt, bool *is_store)\n+{\n+  tree *lhs, *rhs;\n+\n+  /* Recognize MEM = (SSA_NAME | invariant) and SSA_NAME = MEM patterns.  */\n+  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n+    return NULL;\n+\n+  lhs = &GIMPLE_STMT_OPERAND (stmt, 0);\n+  rhs = &GIMPLE_STMT_OPERAND (stmt, 1);\n+\n+  if (TREE_CODE (*lhs) == SSA_NAME)\n+    {\n+      if (!is_gimple_addressable (*rhs))\n+\treturn NULL;\n+\n+      *is_store = false;\n+      return rhs;\n+    }\n+  else if (TREE_CODE (*rhs) == SSA_NAME\n+\t   || is_gimple_min_invariant (*rhs))\n+    {\n+      *is_store = true;\n+      return lhs;\n+    }\n+  else\n+    return NULL;\n+}\n+\n+/* Returns the memory reference contained in STMT.  */\n+\n+static mem_ref_p\n+mem_ref_in_stmt (tree stmt)\n+{\n+  bool store;\n+  tree *mem = simple_mem_ref_in_stmt (stmt, &store);\n+  hashval_t hash;\n+  mem_ref_p ref;\n+\n+  if (!mem)\n+    return NULL;\n+  gcc_assert (!store);\n+\n+  hash = iterative_hash_expr (*mem, 0);\n+  ref = htab_find_with_hash (memory_accesses.refs, *mem, hash);\n+\n+  gcc_assert (ref != NULL);\n+  return ref;\n+}\n+\n /* Determine the outermost loop to that it is possible to hoist a statement\n    STMT and store it to LIM_DATA (STMT)->max_loop.  To do this we determine\n    the outermost loop in that the value computed by STMT is invariant.\n@@ -508,9 +653,26 @@ determine_max_movement (tree stmt, bool must_preserve_exec)\n     if (!add_dependency (val, lim_data, loop, true))\n       return false;\n \n-  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_VIRTUAL_USES)\n-    if (!add_dependency (val, lim_data, loop, false))\n-      return false;\n+  if (!ZERO_SSA_OPERANDS (stmt, SSA_OP_VIRTUAL_USES))\n+    {\n+      mem_ref_p ref = mem_ref_in_stmt (stmt);\n+\n+      if (ref)\n+\t{\n+\t  lim_data->max_loop\n+\t\t  = outermost_indep_loop (lim_data->max_loop, loop, ref);\n+\t  if (!lim_data->max_loop)\n+\t    return false;\n+\t}\n+      else\n+\t{\n+\t  FOR_EACH_SSA_TREE_OPERAND (val, stmt, iter, SSA_OP_VIRTUAL_USES)\n+\t    {\n+\t      if (!add_dependency (val, lim_data, loop, false))\n+\t\treturn false;\n+\t    }\n+\t}\n+    }\n \n   lim_data->cost += stmt_cost (stmt);\n \n@@ -862,6 +1024,8 @@ move_computations_stmt (struct dom_walk_data *dw_data ATTRIBUTE_UNUSED,\n \t  fprintf (dump_file, \"(cost %u) out of loop %d.\\n\\n\",\n \t\t   cost, level->num);\n \t}\n+\n+      mark_virtual_ops_for_renaming (stmt);\n       bsi_insert_on_edge (loop_preheader_edge (level), stmt);\n       bsi_remove (&bsi, false);\n     }\n@@ -987,52 +1151,569 @@ force_move_till (tree ref, tree *index, void *data)\n   return true;\n }\n \n-/* Records memory reference location *REF to the list MEM_REFS.  The reference\n-   occurs in statement STMT.  */\n+/* A hash function for struct mem_ref object OBJ.  */\n+\n+static hashval_t\n+memref_hash (const void *obj)\n+{\n+  const struct mem_ref *mem = obj;\n+\n+  return mem->hash;\n+}\n+\n+/* An equality function for struct mem_ref object OBJ1 with\n+   memory reference OBJ2.  */\n+\n+static int\n+memref_eq (const void *obj1, const void *obj2)\n+{\n+  const struct mem_ref *mem1 = obj1;\n+\n+  return operand_equal_p (mem1->mem, (tree) obj2, 0);\n+}\n+\n+/* Releases list of memory reference locations ACCS.  */\n+\n+static void\n+free_mem_ref_locs (mem_ref_locs_p accs)\n+{\n+  unsigned i;\n+  mem_ref_loc_p loc;\n+\n+  if (!accs)\n+    return;\n+\n+  for (i = 0; VEC_iterate (mem_ref_loc_p, accs->locs, i, loc); i++)\n+    free (loc);\n+  VEC_free (mem_ref_loc_p, heap, accs->locs);\n+  free (accs);\n+}\n+\n+/* A function to free the mem_ref object OBJ.  */\n+\n+static void\n+memref_free (void *obj)\n+{\n+  struct mem_ref *mem = obj;\n+  unsigned i;\n+  mem_ref_locs_p accs;\n+\n+  BITMAP_FREE (mem->stored);\n+  BITMAP_FREE (mem->indep_loop);\n+  BITMAP_FREE (mem->dep_loop);\n+  BITMAP_FREE (mem->indep_ref);\n+  BITMAP_FREE (mem->dep_ref);\n+\n+  for (i = 0; VEC_iterate (mem_ref_locs_p, mem->accesses_in_loop, i, accs); i++)\n+    free_mem_ref_locs (accs);\n+  VEC_free (mem_ref_locs_p, heap, mem->accesses_in_loop);\n+\n+  BITMAP_FREE (mem->vops);\n+  free (mem);\n+}\n+\n+/* Allocates and returns a memory reference description for MEM whose hash\n+   value is HASH and id is ID.  */\n+\n+static mem_ref_p\n+mem_ref_alloc (tree mem, unsigned hash, unsigned id)\n+{\n+  mem_ref_p ref = XNEW (struct mem_ref);\n+  ref->mem = mem;\n+  ref->id = id;\n+  ref->hash = hash;\n+  ref->stored = BITMAP_ALLOC (NULL);\n+  ref->indep_loop = BITMAP_ALLOC (NULL);\n+  ref->dep_loop = BITMAP_ALLOC (NULL);\n+  ref->indep_ref = BITMAP_ALLOC (NULL);\n+  ref->dep_ref = BITMAP_ALLOC (NULL);\n+  ref->accesses_in_loop = NULL;\n+  ref->vops = BITMAP_ALLOC (NULL);\n+\n+  return ref;\n+}\n+\n+/* Allocates and returns the new list of locations.  */\n+\n+static mem_ref_locs_p\n+mem_ref_locs_alloc (void)\n+{\n+  mem_ref_locs_p accs = XNEW (struct mem_ref_locs);\n+  accs->locs = NULL;\n+  return accs;\n+}\n+\n+/* Records memory reference location *LOC in LOOP to the memory reference\n+   description REF.  The reference occurs in statement STMT.  */\n \n static void\n-record_mem_ref_loc (struct mem_ref_loc **mem_refs, tree stmt, tree *ref)\n+record_mem_ref_loc (mem_ref_p ref, struct loop *loop, tree stmt, tree *loc)\n {\n-  struct mem_ref_loc *aref = XNEW (struct mem_ref_loc);\n+  mem_ref_loc_p aref = XNEW (struct mem_ref_loc);\n+  mem_ref_locs_p accs;\n+  bitmap ril = VEC_index (bitmap, memory_accesses.refs_in_loop, loop->num);\n+\n+  if (VEC_length (mem_ref_locs_p, ref->accesses_in_loop)\n+      <= (unsigned) loop->num)\n+    VEC_safe_grow_cleared (mem_ref_locs_p, heap, ref->accesses_in_loop,\n+\t\t\t   loop->num + 1);\n+  accs = VEC_index (mem_ref_locs_p, ref->accesses_in_loop, loop->num);\n+  if (!accs)\n+    {\n+      accs = mem_ref_locs_alloc ();\n+      VEC_replace (mem_ref_locs_p, ref->accesses_in_loop, loop->num, accs);\n+    }\n \n   aref->stmt = stmt;\n-  aref->ref = ref;\n+  aref->ref = loc;\n \n-  aref->next = *mem_refs;\n-  *mem_refs = aref;\n+  VEC_safe_push (mem_ref_loc_p, heap, accs->locs, aref);\n+  bitmap_set_bit (ril, ref->id);\n }\n \n-/* Releases list of memory reference locations MEM_REFS.  */\n+/* Marks reference REF as stored in LOOP.  */\n \n static void\n-free_mem_ref_locs (struct mem_ref_loc *mem_refs)\n+mark_ref_stored (mem_ref_p ref, struct loop *loop)\n {\n-  struct mem_ref_loc *act;\n+  for (;\n+       loop != current_loops->tree_root\n+       && !bitmap_bit_p (ref->stored, loop->num);\n+       loop = loop_outer (loop))\n+    bitmap_set_bit (ref->stored, loop->num);\n+}\n+\n+/* Gathers memory references in statement STMT in LOOP, storing the\n+   information about them in the memory_accesses structure.  Marks\n+   the vops accessed through unrecognized statements there as\n+   well.  */\n+\n+static void\n+gather_mem_refs_stmt (struct loop *loop, tree stmt)\n+{\n+  tree *mem = NULL;\n+  hashval_t hash;\n+  PTR *slot;\n+  mem_ref_p ref;\n+  ssa_op_iter oi;\n+  tree vname;\n+  bool is_stored;\n+  bitmap clvops;\n+  unsigned id;\n \n-  while (mem_refs)\n+  if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n+    return;\n+\n+  mem = simple_mem_ref_in_stmt (stmt, &is_stored);\n+  if (!mem)\n+    goto fail;\n+\n+  hash = iterative_hash_expr (*mem, 0);\n+  slot = htab_find_slot_with_hash (memory_accesses.refs, *mem, hash, INSERT);\n+\n+  if (*slot)\n+    {\n+      ref = *slot;\n+      id = ref->id;\n+    }\n+  else\n     {\n-      act = mem_refs;\n-      mem_refs = mem_refs->next;\n-      free (act);\n+      id = VEC_length (mem_ref_p, memory_accesses.refs_list);\n+      ref = mem_ref_alloc (*mem, hash, id);\n+      VEC_safe_push (mem_ref_p, heap, memory_accesses.refs_list, ref);\n+      *slot = ref;\n+\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"Memory reference %u: \", id);\n+\t  print_generic_expr (dump_file, ref->mem, TDF_SLIM);\n+\t  fprintf (dump_file, \"\\n\");\n+\t}\n     }\n+  if (is_stored)\n+    mark_ref_stored (ref, loop);\n+\n+  FOR_EACH_SSA_TREE_OPERAND (vname, stmt, oi, SSA_OP_VIRTUAL_USES)\n+    bitmap_set_bit (ref->vops, DECL_UID (SSA_NAME_VAR (vname)));\n+  record_mem_ref_loc (ref, loop, stmt, mem);\n+  return;\n+\n+fail:\n+  clvops = VEC_index (bitmap, memory_accesses.clobbered_vops, loop->num);\n+  FOR_EACH_SSA_TREE_OPERAND (vname, stmt, oi, SSA_OP_VIRTUAL_USES)\n+    bitmap_set_bit (clvops, DECL_UID (SSA_NAME_VAR (vname)));\n }\n \n-/* Rewrites memory references in list MEM_REFS by variable TMP_VAR.  */\n+/* Gathers memory references in loops.  */\n \n static void\n-rewrite_mem_refs (tree tmp_var, struct mem_ref_loc *mem_refs)\n+gather_mem_refs_in_loops (void)\n {\n-  tree var;\n-  ssa_op_iter iter;\n+  block_stmt_iterator bsi;\n+  basic_block bb;\n+  struct loop *loop;\n+  loop_iterator li;\n+  bitmap clvo, clvi;\n+  bitmap lrefs, alrefs, alrefso;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      loop = bb->loop_father;\n+      if (loop == current_loops->tree_root)\n+\tcontinue;\n+\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\tgather_mem_refs_stmt (loop, bsi_stmt (bsi));\n+    }\n+\n+  /* Propagate the information about clobbered vops and accessed memory\n+     references up the loop hierarchy.  */\n+  FOR_EACH_LOOP (li, loop, LI_FROM_INNERMOST)\n+    {\n+      lrefs = VEC_index (bitmap, memory_accesses.refs_in_loop, loop->num);\n+      alrefs = VEC_index (bitmap, memory_accesses.all_refs_in_loop, loop->num);\n+      bitmap_ior_into (alrefs, lrefs);\n+\n+      if (loop_outer (loop) == current_loops->tree_root)\n+\tcontinue;\n+\n+      clvi = VEC_index (bitmap, memory_accesses.clobbered_vops, loop->num);\n+      clvo = VEC_index (bitmap, memory_accesses.clobbered_vops,\n+\t\t\tloop_outer (loop)->num);\n+      bitmap_ior_into (clvo, clvi);\n+\n+      alrefso = VEC_index (bitmap, memory_accesses.all_refs_in_loop,\n+\t\t\t   loop_outer (loop)->num);\n+      bitmap_ior_into (alrefso, alrefs);\n+    }\n+}\n+\n+/* Element of the hash table that maps vops to memory references.  */\n+\n+struct vop_to_refs_elt\n+{\n+  /* DECL_UID of the vop.  */\n+  unsigned uid;\n+\n+  /* List of the all references.  */\n+  bitmap refs_all;\n+\n+  /* List of stored references.  */\n+  bitmap refs_stored;\n+};\n+\n+/* A hash function for struct vop_to_refs_elt object OBJ.  */\n+\n+static hashval_t\n+vtoe_hash (const void *obj)\n+{\n+  const struct vop_to_refs_elt *vtoe = obj;\n+\n+  return vtoe->uid;\n+}\n+\n+/* An equality function for struct vop_to_refs_elt object OBJ1 with\n+   uid of a vop OBJ2.  */\n+\n+static int\n+vtoe_eq (const void *obj1, const void *obj2)\n+{\n+  const struct vop_to_refs_elt *vtoe = obj1;\n+  const unsigned *uid = obj2;\n+\n+  return vtoe->uid == *uid;\n+}\n+\n+/* A function to free the struct vop_to_refs_elt object.  */\n+\n+static void\n+vtoe_free (void *obj)\n+{\n+  struct vop_to_refs_elt *vtoe = obj;\n+\n+  BITMAP_FREE (vtoe->refs_all);\n+  BITMAP_FREE (vtoe->refs_stored);\n+  free (vtoe);\n+}\n+\n+/* Records REF to hashtable VOP_TO_REFS for the index VOP.  STORED is true\n+   if the reference REF is stored.  */\n+\n+static void\n+record_vop_access (htab_t vop_to_refs, unsigned vop, unsigned ref, bool stored)\n+{\n+  void **slot = htab_find_slot_with_hash (vop_to_refs, &vop, vop, INSERT);\n+  struct vop_to_refs_elt *vtoe;\n+\n+  if (!*slot)\n+    {\n+      vtoe = XNEW (struct vop_to_refs_elt);\n+      vtoe->uid = vop;\n+      vtoe->refs_all = BITMAP_ALLOC (NULL);\n+      vtoe->refs_stored = BITMAP_ALLOC (NULL);\n+      *slot = vtoe;\n+    }\n+  else\n+    vtoe = *slot;\n+\n+  bitmap_set_bit (vtoe->refs_all, ref);\n+  if (stored)\n+    bitmap_set_bit (vtoe->refs_stored, ref);\n+}\n+\n+/* Returns the set of references that access VOP according to the table\n+   VOP_TO_REFS.  */\n+\n+static bitmap\n+get_vop_accesses (htab_t vop_to_refs, unsigned vop)\n+{\n+  struct vop_to_refs_elt *vtoe = htab_find_with_hash (vop_to_refs, &vop, vop);\n+  return vtoe->refs_all;\n+}\n+\n+/* Returns the set of stores that access VOP according to the table\n+   VOP_TO_REFS.  */\n+\n+static bitmap\n+get_vop_stores (htab_t vop_to_refs, unsigned vop)\n+{\n+  struct vop_to_refs_elt *vtoe = htab_find_with_hash (vop_to_refs, &vop, vop);\n+  return vtoe->refs_stored;\n+}\n+\n+/* Adds REF to mapping from virtual operands to references in LOOP.  */\n+\n+static void\n+add_vop_ref_mapping (struct loop *loop, mem_ref_p ref)\n+{\n+  htab_t map = VEC_index (htab_t, memory_accesses.vop_ref_map, loop->num);\n+  bool stored = bitmap_bit_p (ref->stored, loop->num);\n+  bitmap clobbers = VEC_index (bitmap, memory_accesses.clobbered_vops,\n+\t\t\t       loop->num);\n+  bitmap_iterator bi;\n+  unsigned vop;\n+\n+  EXECUTE_IF_AND_COMPL_IN_BITMAP (ref->vops, clobbers, 0, vop, bi)\n+    {\n+      record_vop_access (map, vop, ref->id, stored);\n+    }\n+}\n+\n+/* Create a mapping from virtual operands to references that touch them\n+   in LOOP.  */\n+\n+static void\n+create_vop_ref_mapping_loop (struct loop *loop)\n+{\n+  bitmap refs = VEC_index (bitmap, memory_accesses.refs_in_loop, loop->num);\n+  struct loop *sloop;\n+  bitmap_iterator bi;\n+  unsigned i;\n+  mem_ref_p ref;\n+\n+  EXECUTE_IF_SET_IN_BITMAP (refs, 0, i, bi)\n+    {\n+      ref = VEC_index (mem_ref_p, memory_accesses.refs_list, i);\n+      for (sloop = loop; sloop != current_loops->tree_root; sloop = loop_outer (sloop))\n+\tadd_vop_ref_mapping (sloop, ref);\n+    }\n+}\n+\n+/* For each non-clobbered virtual operand and each loop, record the memory\n+   references in this loop that touch the operand.  */\n+\n+static void\n+create_vop_ref_mapping (void)\n+{\n+  loop_iterator li;\n+  struct loop *loop;\n+\n+  FOR_EACH_LOOP (li, loop, 0)\n+    {\n+      create_vop_ref_mapping_loop (loop);\n+    }\n+}\n+\n+/* Gathers information about memory accesses in the loops.  */\n+\n+static void\n+analyze_memory_references (void)\n+{\n+  unsigned i;\n+  bitmap empty;\n+  htab_t hempty;\n+\n+  memory_accesses.refs\n+\t  = htab_create (100, memref_hash, memref_eq, memref_free);\n+  memory_accesses.refs_list = NULL;\n+  memory_accesses.refs_in_loop = VEC_alloc (bitmap, heap,\n+\t\t\t\t\t    number_of_loops ());\n+  memory_accesses.all_refs_in_loop = VEC_alloc (bitmap, heap,\n+\t\t\t\t\t\tnumber_of_loops ());\n+  memory_accesses.clobbered_vops = VEC_alloc (bitmap, heap,\n+\t\t\t\t\t      number_of_loops ());\n+  memory_accesses.vop_ref_map = VEC_alloc (htab_t, heap,\n+\t\t\t\t\t   number_of_loops ());\n+\n+  for (i = 0; i < number_of_loops (); i++)\n+    {\n+      empty = BITMAP_ALLOC (NULL);\n+      VEC_quick_push (bitmap, memory_accesses.refs_in_loop, empty);\n+      empty = BITMAP_ALLOC (NULL);\n+      VEC_quick_push (bitmap, memory_accesses.all_refs_in_loop, empty);\n+      empty = BITMAP_ALLOC (NULL);\n+      VEC_quick_push (bitmap, memory_accesses.clobbered_vops, empty);\n+      hempty = htab_create (10, vtoe_hash, vtoe_eq, vtoe_free);\n+      VEC_quick_push (htab_t, memory_accesses.vop_ref_map, hempty);\n+    }\n+\n+  memory_accesses.ttae_cache = NULL;\n+\n+  gather_mem_refs_in_loops ();\n+  create_vop_ref_mapping ();\n+}\n+\n+/* Returns true if a region of size SIZE1 at position 0 and a region of\n+   size SIZE2 at position DIFF cannot overlap.  */\n \n-  for (; mem_refs; mem_refs = mem_refs->next)\n+static bool\n+cannot_overlap_p (aff_tree *diff, double_int size1, double_int size2)\n+{\n+  double_int d, bound;\n+\n+  /* Unless the difference is a constant, we fail.  */\n+  if (diff->n != 0)\n+    return false;\n+\n+  d = diff->offset;\n+  if (double_int_negative_p (d))\n+    {\n+      /* The second object is before the first one, we succeed if the last\n+\t element of the second object is before the start of the first one.  */\n+      bound = double_int_add (d, double_int_add (size2, double_int_minus_one));\n+      return double_int_negative_p (bound);\n+    }\n+  else\n     {\n-      FOR_EACH_SSA_TREE_OPERAND (var, mem_refs->stmt, iter, SSA_OP_ALL_VIRTUALS)\n-\tmark_sym_for_renaming (SSA_NAME_VAR (var));\n+      /* We succeed if the second object starts after the first one ends.  */\n+      return double_int_scmp (size1, d) <= 0;\n+    }\n+}\n+\n+/* Returns true if MEM1 and MEM2 may alias.  TTAE_CACHE is used as a cache in\n+   tree_to_aff_combination_expand.  */\n+\n+static bool\n+mem_refs_may_alias_p (tree mem1, tree mem2, struct pointer_map_t **ttae_cache)\n+{\n+  /* Perform BASE + OFFSET analysis -- if MEM1 and MEM2 are based on the same\n+     object and their offset differ in such a way that the locations cannot\n+     overlap, then they cannot alias.  */\n+  aff_tree off1, off2;\n+  double_int size1, size2;\n+  tree base1, base2;\n+\n+  /* If MEM1 and MEM2 are based on different variables, they cannot alias.  */\n+  base1 = get_base_address (mem1);\n+  base2 = get_base_address (mem2);\n+\n+  if (base1\n+      && !INDIRECT_REF_P (base1)\n+      && base2\n+      && !INDIRECT_REF_P (base2)\n+      && !operand_equal_p (base1, base2, 0))\n+    return false;\n \n-      *mem_refs->ref = tmp_var;\n-      update_stmt (mem_refs->stmt);\n+  /* With strict aliasing, it is impossible to access a scalar variable through\n+     anything but a pointer dereference or through a union (gcc extension).  */\n+  if (flag_strict_aliasing)\n+    {\n+      if (!INDIRECT_REF_P (mem1)\n+\t  && base1\n+\t  && TREE_CODE (TREE_TYPE (base1)) != UNION_TYPE\n+\t  && SSA_VAR_P (mem2)\n+\t  && !AGGREGATE_TYPE_P (TREE_TYPE (mem2)))\n+\treturn false;\n+      if (!INDIRECT_REF_P (mem2)\n+\t  && base2\n+\t  && TREE_CODE (TREE_TYPE (base2)) != UNION_TYPE\n+\t  && SSA_VAR_P (mem1)\n+\t  && !AGGREGATE_TYPE_P (TREE_TYPE (mem1)))\n+\treturn false;\n     }\n+\n+  /* The expansion of addresses may be a bit expensive, thus we only do\n+     the check at -O2 and higher optimization levels.  */\n+  if (optimize < 2)\n+    return true;\n+\n+  get_inner_reference_aff (mem1, &off1, &size1);\n+  get_inner_reference_aff (mem2, &off2, &size2);\n+  aff_combination_expand (&off1, ttae_cache);\n+  aff_combination_expand (&off2, ttae_cache);\n+  aff_combination_scale (&off1, double_int_minus_one);\n+  aff_combination_add (&off2, &off1);\n+\n+  if (cannot_overlap_p (&off2, size1, size2))\n+    return false;\n+\n+  return true;\n+}\n+\n+/* Rewrites location LOC by TMP_VAR.  */\n+\n+static void\n+rewrite_mem_ref_loc (mem_ref_loc_p loc, tree tmp_var)\n+{\n+  mark_virtual_ops_for_renaming (loc->stmt);\n+  *loc->ref = tmp_var;\n+  update_stmt (loc->stmt);\n+}\n+\n+/* Adds all locations of REF in LOOP and its subloops to LOCS.  */\n+\n+static void\n+get_all_locs_in_loop (struct loop *loop, mem_ref_p ref,\n+\t\t      VEC (mem_ref_loc_p, heap) **locs)\n+{\n+  mem_ref_locs_p accs;\n+  unsigned i;\n+  mem_ref_loc_p loc;\n+  bitmap refs = VEC_index (bitmap, memory_accesses.all_refs_in_loop,\n+\t\t\t   loop->num);\n+  struct loop *subloop;\n+\n+  if (!bitmap_bit_p (refs, ref->id))\n+    return;\n+\n+  if (VEC_length (mem_ref_locs_p, ref->accesses_in_loop)\n+      > (unsigned) loop->num)\n+    {\n+      accs = VEC_index (mem_ref_locs_p, ref->accesses_in_loop, loop->num);\n+      if (accs)\n+\t{\n+\t  for (i = 0; VEC_iterate (mem_ref_loc_p, accs->locs, i, loc); i++)\n+\t    VEC_safe_push (mem_ref_loc_p, heap, *locs, loc);\n+\t}\n+    }\n+\n+  for (subloop = loop->inner; subloop != NULL; subloop = subloop->next)\n+    get_all_locs_in_loop (subloop, ref, locs);\n+}\n+\n+/* Rewrites all references to REF in LOOP by variable TMP_VAR.  */\n+\n+static void\n+rewrite_mem_refs (struct loop *loop, mem_ref_p ref, tree tmp_var)\n+{\n+  unsigned i;\n+  mem_ref_loc_p loc;\n+  VEC (mem_ref_loc_p, heap) *locs = NULL;\n+\n+  get_all_locs_in_loop (loop, ref, &locs);\n+  for (i = 0; VEC_iterate (mem_ref_loc_p, locs, i, loc); i++)\n+    rewrite_mem_ref_loc (loc, tmp_var);\n+  VEC_free (mem_ref_loc_p, heap, locs);\n }\n \n /* The name and the length of the currently generated variable\n@@ -1147,18 +1828,14 @@ get_lsm_tmp_name (tree ref, unsigned n)\n   return lsm_tmp_name;\n }\n \n-/* Records request for store motion of memory reference REF from LOOP.\n-   MEM_REFS is the list of occurrences of the reference REF inside LOOP;\n-   these references are rewritten by a new temporary variable.\n+/* Executes store motion of memory reference REF from LOOP.\n    Exits from the LOOP are stored in EXITS.  The initialization of the\n    temporary variable is put to the preheader of the loop, and assignments\n    to the reference from the temporary variable are emitted to exits.  */\n \n static void\n-schedule_sm (struct loop *loop, VEC (edge, heap) *exits, tree ref,\n-\t     struct mem_ref_loc *mem_refs)\n+execute_sm (struct loop *loop, VEC (edge, heap) *exits, mem_ref_p ref)\n {\n-  struct mem_ref_loc *aref;\n   tree tmp_var;\n   unsigned i;\n   tree load, store;\n@@ -1168,24 +1845,21 @@ schedule_sm (struct loop *loop, VEC (edge, heap) *exits, tree ref,\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n       fprintf (dump_file, \"Executing store motion of \");\n-      print_generic_expr (dump_file, ref, 0);\n+      print_generic_expr (dump_file, ref->mem, 0);\n       fprintf (dump_file, \" from loop %d\\n\", loop->num);\n     }\n \n-  tmp_var = make_rename_temp (TREE_TYPE (ref),\n-\t\t\t      get_lsm_tmp_name (ref, ~0));\n+  tmp_var = make_rename_temp (TREE_TYPE (ref->mem),\n+\t\t\t      get_lsm_tmp_name (ref->mem, ~0));\n \n   fmt_data.loop = loop;\n   fmt_data.orig_loop = loop;\n-  for_each_index (&ref, force_move_till, &fmt_data);\n+  for_each_index (&ref->mem, force_move_till, &fmt_data);\n \n-  rewrite_mem_refs (tmp_var, mem_refs);\n-  for (aref = mem_refs; aref; aref = aref->next)\n-    if (LIM_DATA (aref->stmt))\n-      LIM_DATA (aref->stmt)->sm_done = true;\n+  rewrite_mem_refs (loop, ref, tmp_var);\n \n   /* Emit the load & stores.  */\n-  load = build_gimple_modify_stmt (tmp_var, ref);\n+  load = build_gimple_modify_stmt (tmp_var, unshare_expr (ref->mem));\n   get_stmt_ann (load)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n   LIM_DATA (load)->max_loop = loop;\n   LIM_DATA (load)->tgt_loop = loop;\n@@ -1196,327 +1870,283 @@ schedule_sm (struct loop *loop, VEC (edge, heap) *exits, tree ref,\n \n   for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n     {\n-      store = build_gimple_modify_stmt (unshare_expr (ref), tmp_var);\n+      store = build_gimple_modify_stmt (unshare_expr (ref->mem), tmp_var);\n       bsi_insert_on_edge (ex, store);\n     }\n }\n \n-/* Check whether memory reference REF can be hoisted out of the LOOP.  If this\n-   is true, prepare the statements that load the value of the memory reference\n-   to a temporary variable in the loop preheader, store it back on the loop\n-   exits, and replace all the references inside LOOP by this temporary variable.\n-   EXITS is the list of exits of LOOP.  CLOBBERED_VOPS is the bitmap of virtual\n-   operands that are clobbered by a call or accessed through multiple references\n-   in loop.  */\n+/* Hoists memory references MEM_REFS out of LOOP.  EXITS is the list of exit\n+   edges of the LOOP.  */\n \n static void\n-determine_lsm_ref (struct loop *loop, VEC (edge, heap) *exits,\n-\t\t   bitmap clobbered_vops, struct mem_ref *ref)\n+hoist_memory_references (struct loop *loop, bitmap mem_refs,\n+\t\t\t VEC (edge, heap) *exits)\n {\n-  struct mem_ref_loc *aref;\n-  struct loop *must_exec;\n+  mem_ref_p ref;\n+  unsigned  i;\n+  bitmap_iterator bi;\n \n-  /* In case the memory is not stored to, there is nothing for SM to do.  */\n-  if (!ref->is_stored)\n-    return;\n-\n-  /* If the reference is aliased with any different ref, or killed by call\n-     in function, then fail.  */\n-  if (bitmap_intersect_p (ref->vops, clobbered_vops))\n-    return;\n-\n-  if (tree_could_trap_p (ref->mem))\n+  EXECUTE_IF_SET_IN_BITMAP (mem_refs, 0, i, bi)\n     {\n-      /* If the memory access is unsafe (i.e. it might trap), ensure that some\n-\t of the statements in that it occurs is always executed when the loop\n-\t is entered.  This way we know that by moving the load from the\n-\t reference out of the loop we will not cause the error that would not\n-\t occur otherwise.\n-\n-\t TODO -- in fact we would like to check for anticipability of the\n-\t reference, i.e. that on each path from loop entry to loop exit at\n-\t least one of the statements containing the memory reference is\n-\t executed.  */\n-\n-      for (aref = ref->locs; aref; aref = aref->next)\n-\t{\n-\t  if (!LIM_DATA (aref->stmt))\n-\t    continue;\n-\n-\t  must_exec = LIM_DATA (aref->stmt)->always_executed_in;\n-\t  if (!must_exec)\n-\t    continue;\n-\n-\t  if (must_exec == loop\n-\t      || flow_loop_nested_p (must_exec, loop))\n-\t    break;\n-\t}\n-\n-      if (!aref)\n-\treturn;\n+      ref = VEC_index (mem_ref_p, memory_accesses.refs_list, i);\n+      execute_sm (loop, exits, ref);\n     }\n-\n-  schedule_sm (loop, exits, ref->mem, ref->locs);\n }\n \n-/* Hoists memory references MEM_REFS out of LOOP.  CLOBBERED_VOPS is the list\n-   of vops clobbered by call in loop or accessed by multiple memory references.\n-   EXITS is the list of exit edges of the LOOP.  */\n-\n-static void\n-hoist_memory_references (struct loop *loop, struct mem_ref *mem_refs,\n-\t\t\t bitmap clobbered_vops, VEC (edge, heap) *exits)\n-{\n-  struct mem_ref *ref;\n-\n-  for (ref = mem_refs; ref; ref = ref->next)\n-    determine_lsm_ref (loop, exits, clobbered_vops, ref);\n-}\n-\n-/* Checks whether LOOP (with exits stored in EXITS array) is suitable\n-   for a store motion optimization (i.e. whether we can insert statement\n-   on its exits).  */\n+/* Returns true if REF is always accessed in LOOP.  */\n \n static bool\n-loop_suitable_for_sm (struct loop *loop ATTRIBUTE_UNUSED,\n-\t\t      VEC (edge, heap) *exits)\n+ref_always_accessed_p (struct loop *loop, mem_ref_p ref)\n {\n+  VEC (mem_ref_loc_p, heap) *locs = NULL;\n   unsigned i;\n-  edge ex;\n+  mem_ref_loc_p loc;\n+  bool ret = false;\n+  struct loop *must_exec;\n \n-  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n-    if (ex->flags & EDGE_ABNORMAL)\n-      return false;\n+  get_all_locs_in_loop (loop, ref, &locs);\n+  for (i = 0; VEC_iterate (mem_ref_loc_p, locs, i, loc); i++)\n+    {\n+      if (!LIM_DATA (loc->stmt))\n+\tcontinue;\n \n-  return true;\n-}\n+      must_exec = LIM_DATA (loc->stmt)->always_executed_in;\n+      if (!must_exec)\n+\tcontinue;\n \n-/* A hash function for struct mem_ref object OBJ.  */\n+      if (must_exec == loop\n+\t  || flow_loop_nested_p (must_exec, loop))\n+\t{\n+\t  ret = true;\n+\t  break;\n+\t}\n+    }\n+  VEC_free (mem_ref_loc_p, heap, locs);\n \n-static hashval_t\n-memref_hash (const void *obj)\n-{\n-  return ((const struct mem_ref *) obj)->hash;\n+  return ret;\n }\n \n-/* An equality function for struct mem_ref object OBJ1 with\n-   memory reference OBJ2.  */\n+/* Returns true if REF1 and REF2 are independent.  */\n \n-static int\n-memref_eq (const void *obj1, const void *obj2)\n+static bool\n+refs_independent_p (mem_ref_p ref1, mem_ref_p ref2)\n {\n-  const struct mem_ref *const mem1 = (const struct mem_ref *) obj1;\n+  if (ref1 == ref2\n+      || bitmap_bit_p (ref1->indep_ref, ref2->id))\n+    return true;\n+  if (bitmap_bit_p (ref1->dep_ref, ref2->id))\n+    return false;\n \n-  return operand_equal_p (mem1->mem, (const_tree) obj2, 0);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Querying dependency of refs %u and %u: \",\n+\t     ref1->id, ref2->id);\n+\n+  if (mem_refs_may_alias_p (ref1->mem, ref2->mem,\n+\t\t\t    &memory_accesses.ttae_cache))\n+    {\n+      bitmap_set_bit (ref1->dep_ref, ref2->id);\n+      bitmap_set_bit (ref2->dep_ref, ref1->id);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"dependent.\\n\");\n+      return false;\n+    }\n+  else\n+    {\n+      bitmap_set_bit (ref1->indep_ref, ref2->id);\n+      bitmap_set_bit (ref2->indep_ref, ref1->id);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \"independent.\\n\");\n+      return true;\n+    }\n }\n \n-/* Gathers memory references in statement STMT in LOOP, storing the\n-   information about them in MEM_REFS hash table.  Note vops accessed through\n-   unrecognized statements in CLOBBERED_VOPS.  The newly created references\n-   are also stored to MEM_REF_LIST.  */\n+/* Records the information whether REF is independent in LOOP (according\n+   to INDEP).  */\n \n static void\n-gather_mem_refs_stmt (struct loop *loop, htab_t mem_refs,\n-\t\t      bitmap clobbered_vops, tree stmt,\n-\t\t      struct mem_ref **mem_ref_list)\n+record_indep_loop (struct loop *loop, mem_ref_p ref, bool indep)\n {\n-  tree *lhs, *rhs, *mem = NULL;\n-  hashval_t hash;\n-  PTR *slot;\n-  struct mem_ref *ref = NULL;\n-  ssa_op_iter oi;\n-  tree vname;\n-  bool is_stored;\n+  if (indep)\n+    bitmap_set_bit (ref->indep_loop, loop->num);\n+  else\n+    bitmap_set_bit (ref->dep_loop, loop->num);\n+}\n \n-  if (ZERO_SSA_OPERANDS (stmt, SSA_OP_ALL_VIRTUALS))\n-    return;\n+/* Returns true if REF is independent on all other memory references in\n+   LOOP.  */\n \n-  /* Recognize MEM = (SSA_NAME | invariant) and SSA_NAME = MEM patterns.  */\n-  if (TREE_CODE (stmt) != GIMPLE_MODIFY_STMT)\n-    goto fail;\n+static bool\n+ref_indep_loop_p_1 (struct loop *loop, mem_ref_p ref)\n+{\n+  bitmap clobbers, refs_to_check, refs;\n+  unsigned i;\n+  bitmap_iterator bi;\n+  bool ret = true, stored = bitmap_bit_p (ref->stored, loop->num);\n+  htab_t map;\n+  mem_ref_p aref;\n+\n+  /* If the reference is clobbered, it is not independent.  */\n+  clobbers = VEC_index (bitmap, memory_accesses.clobbered_vops, loop->num);\n+  if (bitmap_intersect_p (ref->vops, clobbers))\n+    return false;\n \n-  lhs = &GIMPLE_STMT_OPERAND (stmt, 0);\n-  rhs = &GIMPLE_STMT_OPERAND (stmt, 1);\n+  refs_to_check = BITMAP_ALLOC (NULL);\n \n-  if (TREE_CODE (*lhs) == SSA_NAME)\n+  map = VEC_index (htab_t, memory_accesses.vop_ref_map, loop->num);\n+  EXECUTE_IF_AND_COMPL_IN_BITMAP (ref->vops, clobbers, 0, i, bi)\n     {\n-      if (!is_gimple_addressable (*rhs))\n-\tgoto fail;\n+      if (stored)\n+\trefs = get_vop_accesses (map, i);\n+      else\n+\trefs = get_vop_stores (map, i);\n \n-      mem = rhs;\n-      is_stored = false;\n+      bitmap_ior_into (refs_to_check, refs);\n     }\n-  else if (TREE_CODE (*rhs) == SSA_NAME\n-\t   || is_gimple_min_invariant (*rhs))\n-    {\n-      mem = lhs;\n-      is_stored = true;\n-    }\n-  else\n-    goto fail;\n-\n-  /* If we cannot create an SSA name for the result, give up.  */\n-  if (!is_gimple_reg_type (TREE_TYPE (*mem))\n-      || TREE_THIS_VOLATILE (*mem))\n-    goto fail;\n-\n-  /* If we cannot move the reference out of the loop, fail.  */\n-  if (!for_each_index (mem, may_move_till, loop))\n-    goto fail;\n-\n-  hash = iterative_hash_expr (*mem, 0);\n-  slot = htab_find_slot_with_hash (mem_refs, *mem, hash, INSERT);\n \n-  if (*slot)\n-    ref = (struct mem_ref *) *slot;\n-  else\n+  EXECUTE_IF_SET_IN_BITMAP (refs_to_check, 0, i, bi)\n     {\n-      ref = XNEW (struct mem_ref);\n-      ref->mem = *mem;\n-      ref->hash = hash;\n-      ref->locs = NULL;\n-      ref->is_stored = false;\n-      ref->vops = BITMAP_ALLOC (NULL);\n-      ref->next = *mem_ref_list;\n-      *mem_ref_list = ref;\n-      *slot = ref;\n+      aref = VEC_index (mem_ref_p, memory_accesses.refs_list, i);\n+      if (!refs_independent_p (ref, aref))\n+\t{\n+\t  ret = false;\n+\t  record_indep_loop (loop, aref, false);\n+\t  break;\n+\t}\n     }\n-  ref->is_stored |= is_stored;\n \n-  FOR_EACH_SSA_TREE_OPERAND (vname, stmt, oi, SSA_OP_VIRTUAL_USES)\n-    bitmap_set_bit (ref->vops, DECL_UID (SSA_NAME_VAR (vname)));\n-  record_mem_ref_loc (&ref->locs, stmt, mem);\n-  return;\n-\n-fail:\n-  FOR_EACH_SSA_TREE_OPERAND (vname, stmt, oi, SSA_OP_VIRTUAL_USES)\n-    bitmap_set_bit (clobbered_vops, DECL_UID (SSA_NAME_VAR (vname)));\n+  BITMAP_FREE (refs_to_check);\n+  return ret;\n }\n \n-/* Gathers memory references in LOOP.  Notes vops accessed through unrecognized\n-   statements in CLOBBERED_VOPS.  The list of the references found by\n-   the function is returned.  */\n+/* Returns true if REF is independent on all other memory references in\n+   LOOP.  Wrapper over ref_indep_loop_p_1, caching its results.  */\n \n-static struct mem_ref *\n-gather_mem_refs (struct loop *loop, bitmap clobbered_vops)\n+static bool\n+ref_indep_loop_p (struct loop *loop, mem_ref_p ref)\n {\n-  basic_block *body = get_loop_body (loop);\n-  block_stmt_iterator bsi;\n-  unsigned i;\n-  struct mem_ref *mem_ref_list = NULL;\n-  htab_t mem_refs = htab_create (100, memref_hash, memref_eq, NULL);\n+  bool ret;\n \n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      for (bsi = bsi_start (body[i]); !bsi_end_p (bsi); bsi_next (&bsi))\n-\tgather_mem_refs_stmt (loop, mem_refs, clobbered_vops, bsi_stmt (bsi),\n-\t\t\t      &mem_ref_list);\n-    }\n+  if (bitmap_bit_p (ref->indep_loop, loop->num))\n+    return true;\n+  if (bitmap_bit_p (ref->dep_loop, loop->num))\n+    return false;\n \n-  free (body);\n+  ret = ref_indep_loop_p_1 (loop, ref);\n \n-  htab_delete (mem_refs);\n-  return mem_ref_list;\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"Querying dependencies of ref %u in loop %d: %s\\n\",\n+\t     ref->id, loop->num, ret ? \"independent\" : \"dependent\");\n+\n+  record_indep_loop (loop, ref, ret);\n+\n+  return ret;\n }\n \n-/* Finds the vops accessed by more than one of the memory references described\n-   in MEM_REFS and marks them in CLOBBERED_VOPS.  */\n+/* Returns true if we can perform store motion of REF from LOOP.  */\n \n-static void\n-find_more_ref_vops (struct mem_ref *mem_refs, bitmap clobbered_vops)\n+static bool\n+can_sm_ref_p (struct loop *loop, mem_ref_p ref)\n {\n-  bitmap_head tmp, all_vops;\n-  struct mem_ref *ref;\n+  /* Unless the reference is stored in the loop, there is nothing to do.  */\n+  if (!bitmap_bit_p (ref->stored, loop->num))\n+    return false;\n \n-  bitmap_initialize (&tmp, &bitmap_default_obstack);\n-  bitmap_initialize (&all_vops, &bitmap_default_obstack);\n+  /* It should be movable.  */\n+  if (!is_gimple_reg_type (TREE_TYPE (ref->mem))\n+      || TREE_THIS_VOLATILE (ref->mem)\n+      || !for_each_index (&ref->mem, may_move_till, loop))\n+    return false;\n \n-  for (ref = mem_refs; ref; ref = ref->next)\n-    {\n-      /* The vops that are already in all_vops are accessed by more than\n-\t one memory reference.  */\n-      bitmap_and (&tmp, &all_vops, ref->vops);\n-      bitmap_ior_into (clobbered_vops, &tmp);\n-      bitmap_clear (&tmp);\n+  /* If it can trap, it must be always executed in LOOP.  */\n+  if (tree_could_trap_p (ref->mem)\n+      && !ref_always_accessed_p (loop, ref))\n+    return false;\n \n-      bitmap_ior_into (&all_vops, ref->vops);\n-    }\n+  /* And it must be independent on all other memory references\n+     in LOOP.  */\n+  if (!ref_indep_loop_p (loop, ref))\n+    return false;\n \n-  bitmap_clear (&all_vops);\n+  return true;\n }\n \n-/* Releases the memory occupied by REF.  */\n+/* Marks the references in LOOP for that store motion should be performed\n+   in REFS_TO_SM.  SM_EXECUTED is the set of references for that store\n+   motion was performed in one of the outer loops.  */\n \n static void\n-free_mem_ref (struct mem_ref *ref)\n+find_refs_for_sm (struct loop *loop, bitmap sm_executed, bitmap refs_to_sm)\n {\n-  free_mem_ref_locs (ref->locs);\n-  BITMAP_FREE (ref->vops);\n-  free (ref);\n+  bitmap refs = VEC_index (bitmap, memory_accesses.all_refs_in_loop,\n+\t\t\t   loop->num);\n+  unsigned i;\n+  bitmap_iterator bi;\n+  mem_ref_p ref;\n+\n+  EXECUTE_IF_AND_COMPL_IN_BITMAP (refs, sm_executed, 0, i, bi)\n+    {\n+      ref = VEC_index (mem_ref_p, memory_accesses.refs_list, i);\n+      if (can_sm_ref_p (loop, ref))\n+\tbitmap_set_bit (refs_to_sm, i);\n+    }\n }\n \n-/* Releases the memory occupied by REFS.  */\n+/* Checks whether LOOP (with exits stored in EXITS array) is suitable\n+   for a store motion optimization (i.e. whether we can insert statement\n+   on its exits).  */\n \n-static void\n-free_mem_refs (struct mem_ref *refs)\n+static bool\n+loop_suitable_for_sm (struct loop *loop ATTRIBUTE_UNUSED,\n+\t\t      VEC (edge, heap) *exits)\n {\n-  struct mem_ref *ref, *next;\n+  unsigned i;\n+  edge ex;\n \n-  for (ref = refs; ref; ref = next)\n-    {\n-      next = ref->next;\n-      free_mem_ref (ref);\n-    }\n+  for (i = 0; VEC_iterate (edge, exits, i, ex); i++)\n+    if (ex->flags & EDGE_ABNORMAL)\n+      return false;\n+\n+  return true;\n }\n \n /* Try to perform store motion for all memory references modified inside\n-   LOOP.  */\n+   LOOP.  SM_EXECUTED is the bitmap of the memory references for that\n+   store motion was executed in one of the outer loops.  */\n \n static void\n-determine_lsm_loop (struct loop *loop)\n+store_motion_loop (struct loop *loop, bitmap sm_executed)\n {\n   VEC (edge, heap) *exits = get_loop_exit_edges (loop);\n-  bitmap clobbered_vops;\n-  struct mem_ref *mem_refs;\n+  struct loop *subloop;\n+  bitmap sm_in_loop = BITMAP_ALLOC (NULL);\n \n-  if (!loop_suitable_for_sm (loop, exits))\n+  if (loop_suitable_for_sm (loop, exits))\n     {\n-      VEC_free (edge, heap, exits);\n-      return;\n+      find_refs_for_sm (loop, sm_executed, sm_in_loop);\n+      hoist_memory_references (loop, sm_in_loop, exits);\n     }\n-\n-  /* Find the memory references in LOOP.  */\n-  clobbered_vops = BITMAP_ALLOC (NULL);\n-  mem_refs = gather_mem_refs (loop, clobbered_vops);\n-\n-  /* Find the vops that are used for more than one reference.  */\n-  find_more_ref_vops (mem_refs, clobbered_vops);\n-\n-  /* Hoist all suitable memory references.  */\n-  hoist_memory_references (loop, mem_refs, clobbered_vops, exits);\n-\n-  free_mem_refs (mem_refs);\n   VEC_free (edge, heap, exits);\n-  BITMAP_FREE (clobbered_vops);\n+\n+  bitmap_ior_into (sm_executed, sm_in_loop);\n+  for (subloop = loop->inner; subloop != NULL; subloop = subloop->next)\n+    store_motion_loop (subloop, sm_executed);\n+  bitmap_and_compl_into (sm_executed, sm_in_loop);\n+  BITMAP_FREE (sm_in_loop);\n }\n \n /* Try to perform store motion for all memory references modified inside\n    loops.  */\n \n static void\n-determine_lsm (void)\n+store_motion (void)\n {\n   struct loop *loop;\n-  loop_iterator li;\n+  bitmap sm_executed = BITMAP_ALLOC (NULL);\n \n-  /* Pass the loops from the outermost and perform the store motion as\n-     suitable.  */\n-\n-  FOR_EACH_LOOP (li, loop, 0)\n-    {\n-      determine_lsm_loop (loop);\n-    }\n+  for (loop = current_loops->tree_root->inner; loop != NULL; loop = loop->next)\n+    store_motion_loop (loop, sm_executed);\n \n+  BITMAP_FREE (sm_executed);\n   bsi_commit_edge_inserts ();\n }\n \n@@ -1623,11 +2253,36 @@ static void\n tree_ssa_lim_finalize (void)\n {\n   basic_block bb;\n+  unsigned i;\n+  bitmap b;\n+  htab_t h;\n \n   FOR_EACH_BB (bb)\n     {\n       bb->aux = NULL;\n     }\n+\n+  VEC_free (mem_ref_p, heap, memory_accesses.refs_list);\n+  htab_delete (memory_accesses.refs);\n+\n+  for (i = 0; VEC_iterate (bitmap, memory_accesses.refs_in_loop, i, b); i++)\n+    BITMAP_FREE (b);\n+  VEC_free (bitmap, heap, memory_accesses.refs_in_loop);\n+\n+  for (i = 0; VEC_iterate (bitmap, memory_accesses.all_refs_in_loop, i, b); i++)\n+    BITMAP_FREE (b);\n+  VEC_free (bitmap, heap, memory_accesses.all_refs_in_loop);\n+\n+  for (i = 0; VEC_iterate (bitmap, memory_accesses.clobbered_vops, i, b); i++)\n+    BITMAP_FREE (b);\n+  VEC_free (bitmap, heap, memory_accesses.clobbered_vops);\n+\n+  for (i = 0; VEC_iterate (htab_t, memory_accesses.vop_ref_map, i, h); i++)\n+    htab_delete (h);\n+  VEC_free (htab_t, heap, memory_accesses.vop_ref_map);\n+\n+  if (memory_accesses.ttae_cache)\n+    pointer_map_destroy (memory_accesses.ttae_cache);\n }\n \n /* Moves invariants from loops.  Only \"expensive\" invariants are moved out --\n@@ -1638,14 +2293,16 @@ tree_ssa_lim (void)\n {\n   tree_ssa_lim_initialize ();\n \n+  /* Gathers information about memory accesses in the loops.  */\n+  analyze_memory_references ();\n+\n   /* For each statement determine the outermost loop in that it is\n      invariant and cost for computing the invariant.  */\n   determine_invariantness ();\n \n-  /* For each memory reference determine whether it is possible to hoist it\n-     out of the loop.  Force the necessary invariants to be moved out of the\n-     loops as well.  */\n-  determine_lsm ();\n+  /* Execute store motion.  Force the necessary invariants to be moved\n+     out of the loops as well.  */\n+  store_motion ();\n \n   /* Move the expressions that are expensive enough.  */\n   move_computations ();"}]}