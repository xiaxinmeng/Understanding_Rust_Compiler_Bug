{"sha": "ebe75517d4ffdb7045a607c6c5426306dbf662ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWJlNzU1MTdkNGZmZGI3MDQ1YTYwN2M2YzU0MjYzMDZkYmY2NjJlZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-08-23T21:18:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-08-23T21:18:58Z"}, "message": "re PR c/11369 (too relaxed checking with -Wstrict-prototypes)\n\n\n\tPR target/11369\n\t* i386.c (ix86_expand_carry_flag_compare): Validate operand.\n\n\tPR target/11031\n\t* i386.c (const_0_to_3_operand, const_0_to_7_operand,\n\tconst_0_to_15_operand, const_0_to_255_operand): New predicates.\n\t* i386.h (PREDICATE_CODES): Add these.\n\t* i386.c (pinsrw and pextrw patterns): Use them.\n\n\tPR target/10984\n\t* i386.c (ix86_expand_binop_builtin): Behave sanely for VOIDmodes.\n\n\tPR target/8869\n\t* expr.c (convert_modes): Deal properly with integer to vector\n\tconstant conversion.\n\n\tPR target/8871\n\t* i386.md (zero_extendsidi2*): Add MMX and SSE alternatives.\n\nFrom-SVN: r70751", "tree": {"sha": "ef23e0b47fa47061a7aed684f7759a059e614a6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef23e0b47fa47061a7aed684f7759a059e614a6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ebe75517d4ffdb7045a607c6c5426306dbf662ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebe75517d4ffdb7045a607c6c5426306dbf662ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ebe75517d4ffdb7045a607c6c5426306dbf662ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ebe75517d4ffdb7045a607c6c5426306dbf662ee/comments", "author": null, "committer": null, "parents": [{"sha": "066ec9c97beec87ae5763b7cd541d3302f81ebce", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/066ec9c97beec87ae5763b7cd541d3302f81ebce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/066ec9c97beec87ae5763b7cd541d3302f81ebce"}], "stats": {"total": 150, "additions": 124, "deletions": 26}, "files": [{"sha": "f329133f142aa198f3d64f069081f1c271d920b4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe75517d4ffdb7045a607c6c5426306dbf662ee/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe75517d4ffdb7045a607c6c5426306dbf662ee/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ebe75517d4ffdb7045a607c6c5426306dbf662ee", "patch": "@@ -1,3 +1,24 @@\n+Wed Aug 20 12:08:55 CEST 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR target/11369\n+\t* i386.c (ix86_expand_carry_flag_compare): Validate operand.\n+\n+\tPR target/11031\n+\t* i386.c (const_0_to_3_operand, const_0_to_7_operand,\n+\tconst_0_to_15_operand, const_0_to_255_operand): New predicates.\n+\t* i386.h (PREDICATE_CODES): Add these.\n+\t* i386.c (pinsrw and pextrw patterns): Use them.\n+\n+\tPR target/10984\n+\t* i386.c (ix86_expand_binop_builtin): Behave sanely for VOIDmodes.\n+\n+\tPR target/8869\n+\t* expr.c (convert_modes): Deal properly with integer to vector\n+\tconstant conversion.\n+\n+\tPR target/8871\n+\t* i386.md (zero_extendsidi2*): Add MMX and SSE alternatives.\n+\n 2003-08-23  Ulrich Weigand  <uweigand@de.ibm.com>\n \n \t* config/s390/s390.h (LOAD_EXTEND_OP): Remove."}, {"sha": "1609b7481144a2ddceec793b71e7d52d761a5311", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 39, "deletions": 10, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe75517d4ffdb7045a607c6c5426306dbf662ee/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe75517d4ffdb7045a607c6c5426306dbf662ee/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=ebe75517d4ffdb7045a607c6c5426306dbf662ee", "patch": "@@ -3596,6 +3596,32 @@ const248_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n \t  && (INTVAL (op) == 2 || INTVAL (op) == 4 || INTVAL (op) == 8));\n }\n \n+int\n+const_0_to_3_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 4);\n+}\n+\n+int\n+const_0_to_7_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 8);\n+}\n+\n+int\n+const_0_to_15_operand (register rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 16);\n+}\n+\n+int\n+const_0_to_255_operand (register rtx op,\n+\t\t\tenum machine_mode mode ATTRIBUTE_UNUSED)\n+{\n+  return (GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 256);\n+}\n+\n+\n /* True if this is a constant appropriate for an increment or decrement.  */\n \n int\n@@ -9400,11 +9426,6 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n \t    return false;\n \t  code = (code == GTU ? GEU : LTU);\n \t}\n-      else if (!nonimmediate_operand (op1, mode)\n-\t       || !general_operand (op0, mode))\n-\t/* Swapping operands in this case would generate an\n-\t   unrecognizable insn.  */\n-\treturn false;\n       else\n \t{\n \t  rtx tmp = op1;\n@@ -9433,6 +9454,13 @@ ix86_expand_carry_flag_compare (enum rtx_code code, rtx op0, rtx op1, rtx *pop)\n     default:\n       return false;\n     }\n+  /* Swapping operands may cause constant to appear as first operand.  */\n+  if (!nonimmediate_operand (op0, VOIDmode))\n+    {\n+      if (no_new_pseudos)\n+\treturn false;\n+      op0 = force_reg (mode, op0);\n+    }\n   ix86_compare_op0 = op0;\n   ix86_compare_op1 = op1;\n   *pop = ix86_expand_compare (code, NULL, NULL);\n@@ -13508,7 +13536,8 @@ ix86_expand_binop_builtin (enum insn_code icode, tree arglist, rtx target)\n \n   /* In case the insn wants input operands in modes different from\n      the result, abort.  */\n-  if (GET_MODE (op0) != mode0 || GET_MODE (op1) != mode1)\n+  if ((GET_MODE (op0) != mode0 && GET_MODE (op0) != VOIDmode)\n+      || (GET_MODE (op1) != mode1 && GET_MODE (op1) != VOIDmode))\n     abort ();\n \n   if (! (*insn_data[icode].operand[1].predicate) (op0, mode0))\n@@ -13773,8 +13802,8 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \top0 = copy_to_mode_reg (mode0, op0);\n       if (! (*insn_data[icode].operand[2].predicate) (op1, mode1))\n \t{\n-\t  /* @@@ better error message */\n-\t  error (\"selector must be an immediate\");\n+\t  error (\"selector must be an integer constant in the range 0..%i\",\n+\t\t  fcode == IX86_BUILTIN_PEXTRW ? 3:7);\n \t  return gen_reg_rtx (tmode);\n \t}\n       if (target == 0\n@@ -13809,8 +13838,8 @@ ix86_expand_builtin (tree exp, rtx target, rtx subtarget ATTRIBUTE_UNUSED,\n \top1 = copy_to_mode_reg (mode1, op1);\n       if (! (*insn_data[icode].operand[3].predicate) (op2, mode2))\n \t{\n-\t  /* @@@ better error message */\n-\t  error (\"selector must be an immediate\");\n+\t  error (\"selector must be an integer constant in the range 0..%i\",\n+\t\t  fcode == IX86_BUILTIN_PINSRW ? 15:255);\n \t  return const0_rtx;\n \t}\n       if (target == 0"}, {"sha": "718c52530e2aaccd5593699343dd85ee53b63566", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe75517d4ffdb7045a607c6c5426306dbf662ee/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe75517d4ffdb7045a607c6c5426306dbf662ee/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=ebe75517d4ffdb7045a607c6c5426306dbf662ee", "patch": "@@ -3018,6 +3018,10 @@ do {\t\t\t\t\t\t\\\n   {\"const0_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n   {\"const1_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"const248_operand\", {CONST_INT}},\t\t\t\t\t\\\n+  {\"const_0_to_3_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"const_0_to_7_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"const_0_to_15_operand\", {CONST_INT}},\t\t\t\t\\\n+  {\"const_0_to_255_operand\", {CONST_INT}},\t\t\t\t\\\n   {\"incdec_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"mmx_reg_operand\", {REG}},\t\t\t\t\t\t\\\n   {\"reg_no_sp_operand\", {SUBREG, REG}},\t\t\t\t\t\\"}, {"sha": "6fa1650f7d773b19c6ee6345ddfb23c12a6eaa45", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 51, "deletions": 16, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe75517d4ffdb7045a607c6c5426306dbf662ee/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe75517d4ffdb7045a607c6c5426306dbf662ee/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ebe75517d4ffdb7045a607c6c5426306dbf662ee", "patch": "@@ -3278,22 +3278,56 @@\n   \")\n \n (define_insn \"zero_extendsidi2_32\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,?r,?*o\")\n-\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"0,rm,r\")))\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,?r,?*o,!?y,!?Y\")\n+\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"0,rm,r,m,m\")))\n    (clobber (reg:CC 17))]\n-  \"!TARGET_64BIT\"\n-  \"#\"\n-  [(set_attr \"mode\" \"SI\")])\n+  \"!TARGET_64BIT && !TARGET_INTER_UNIT_MOVES\"\n+  \"@\n+   #\n+   #\n+   #\n+   movd\\t{%1, %0|%0, %1}\n+   movd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"mode\" \"SI,SI,SI,DI,TI\")\n+   (set_attr \"type\" \"multi,multi,multi,mmxmov,ssemov\")])\n+\n+(define_insn \"*zero_extendsidi2_32_1\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,?r,?*o,!?y,!?Y\")\n+\t(zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"0,rm,r,rm,rm\")))\n+   (clobber (reg:CC 17))]\n+  \"!TARGET_64BIT && TARGET_INTER_UNIT_MOVES\"\n+  \"@\n+   #\n+   #\n+   #\n+   movd\\t{%1, %0|%0, %1}\n+   movd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"mode\" \"SI,SI,SI,DI,TI\")\n+   (set_attr \"type\" \"multi,multi,multi,mmxmov,ssemov\")])\n \n (define_insn \"zero_extendsidi2_rex64\"\n-  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o\")\n-     (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"rm,0\")))]\n-  \"TARGET_64BIT\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,!?y,!?Y\")\n+     (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"rm,0,m,m\")))]\n+  \"TARGET_64BIT && !TARGET_INTER_UNIT_MOVES\"\n   \"@\n    mov\\t{%k1, %k0|%k0, %k1}\n-   #\"\n-  [(set_attr \"type\" \"imovx,imov\")\n-   (set_attr \"mode\" \"SI,DI\")])\n+   #\n+   movd\\t{%1, %0|%0, %1}\n+   movd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"imovx,imov,mmxmov,ssemov\")\n+   (set_attr \"mode\" \"SI,DI,DI,TI\")])\n+\n+(define_insn \"*zero_extendsidi2_rex64_1\"\n+  [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,o,!?y,!*?\")\n+     (zero_extend:DI (match_operand:SI 1 \"nonimmediate_operand\" \"rm,0,rm,rm\")))]\n+  \"TARGET_64BIT && TARGET_INTER_UNIT_MOVES\"\n+  \"@\n+   mov\\t{%k1, %k0|%k0, %k1}\n+   #\n+   movd\\t{%1, %0|%0, %1}\n+   movd\\t{%1, %0|%0, %1}\"\n+  [(set_attr \"type\" \"imovx,imov,mmxmov,ssemov\")\n+   (set_attr \"mode\" \"SI,DI,SI,SI\")])\n \n (define_split\n   [(set (match_operand:DI 0 \"memory_operand\" \"\")\n@@ -3315,7 +3349,8 @@\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n \t(zero_extend:DI (match_operand:SI 1 \"general_operand\" \"\")))\n    (clobber (reg:CC 17))]\n-  \"!TARGET_64BIT && reload_completed\"\n+  \"!TARGET_64BIT && reload_completed\n+   && !SSE_REG_P (operands[0]) && !MMX_REG_P (operands[0])\"\n   [(set (match_dup 3) (match_dup 1))\n    (set (match_dup 4) (const_int 0))]\n   \"split_di (&operands[0], 1, &operands[3], &operands[4]);\")\n@@ -21228,7 +21263,7 @@\n         (vec_merge:V4HI (match_operand:V4HI 1 \"register_operand\" \"0\")\n \t\t\t(vec_duplicate:V4HI\n \t\t\t (truncate:HI (match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))\n-\t\t\t(match_operand:SI 3 \"immediate_operand\" \"i\")))]\n+\t\t\t(match_operand:SI 3 \"const_0_to_15_operand\" \"N\")))]\n   \"TARGET_SSE || TARGET_3DNOW_A\"\n   \"pinsrw\\t{%3, %2, %0|%0, %2, %3}\"\n   [(set_attr \"type\" \"mmxcvt\")\n@@ -21238,7 +21273,7 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n         (zero_extend:SI (vec_select:HI (match_operand:V4HI 1 \"register_operand\" \"y\")\n \t\t\t\t       (parallel\n-\t\t\t\t\t[(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n+\t\t\t\t\t[(match_operand:SI 2 \"const_0_to_3_operand\" \"N\")]))))]\n   \"TARGET_SSE || TARGET_3DNOW_A\"\n   \"pextrw\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"mmxcvt\")\n@@ -22924,7 +22959,7 @@\n \t\t\t(vec_duplicate:V8HI\n \t\t\t (truncate:HI\n \t\t\t   (match_operand:SI 2 \"nonimmediate_operand\" \"rm\")))\n-\t\t\t(match_operand:SI 3 \"immediate_operand\" \"i\")))]\n+\t\t\t(match_operand:SI 3 \"const_0_to_255_operand\" \"N\")))]\n   \"TARGET_SSE2\"\n   \"pinsrw\\t{%3, %2, %0|%0, %2, %3}\"\n   [(set_attr \"type\" \"ssecvt\")\n@@ -22935,7 +22970,7 @@\n         (zero_extend:SI\n \t  (vec_select:HI (match_operand:V8HI 1 \"register_operand\" \"x\")\n \t\t\t (parallel\n-\t\t\t  [(match_operand:SI 2 \"immediate_operand\" \"i\")]))))]\n+\t\t\t  [(match_operand:SI 2 \"const_0_to_7_operand\" \"N\")]))))]\n   \"TARGET_SSE2\"\n   \"pextrw\\t{%2, %1, %0|%0, %1, %2}\"\n   [(set_attr \"type\" \"ssecvt\")"}, {"sha": "b7f71c627ba0f4dfa892a2f5d3f886424ce3bff9", "filename": "gcc/expr.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ebe75517d4ffdb7045a607c6c5426306dbf662ee/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ebe75517d4ffdb7045a607c6c5426306dbf662ee/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=ebe75517d4ffdb7045a607c6c5426306dbf662ee", "patch": "@@ -1419,6 +1419,15 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n       return gen_lowpart (mode, x);\n     }\n \n+  /* Converting from integer constant into mode is always equivalent to an\n+     subreg operation.  */\n+  if (VECTOR_MODE_P (mode) && GET_MODE (x) == VOIDmode)\n+    {\n+      if (GET_MODE_BITSIZE (mode) != GET_MODE_BITSIZE (oldmode))\n+\tabort ();\n+      return simplify_gen_subreg (mode, x, oldmode, 0);\n+    }\n+\n   temp = gen_reg_rtx (mode);\n   convert_move (temp, x, unsignedp);\n   return temp;"}]}