{"sha": "75fe7b2f406d638fa6de89c44e0a862ab04a0b5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVmZTdiMmY0MDZkNjM4ZmE2ZGU4OWM0NGUwYTg2MmFiMDRhMGI1ZQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2005-06-01T14:52:16Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2005-06-01T14:52:16Z"}, "message": "* arm.md (bunordered, bordered, bungt, bunlt, bunge, bunle, buneq)\n\t(bltgt, arm_buneq, arm_bltgt, sunordered, sordered, sungt, sunge)\n\t(sunlt, sunle): Enable patterns on VFP.\n\n\t* arm.md (attribute 'type'): Add new types - f_loads floadd, f_stores,\n\tf_stored, f_flag, f_cvt.\n\t(generic_sched): No-longer used for the arm1020e and arm1022e cores.\n\tInclude arm1020e.md.\n\t* vfp.md (fmstat): New cpu unit.  Add an exclusion set between it and\n\tthe ds and fmac pipelines.  Re-work all load and store patterns and\n\tall conversion patterns to use new attributes.  Adjust reservation\n\tdescriptions accordingly.\n\t* arm1020e.md: New file.\n\t* t-arm: Add dependency.\n\nFrom-SVN: r100452", "tree": {"sha": "41357aecea421c99362e795520bdc767e1a30cb5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/41357aecea421c99362e795520bdc767e1a30cb5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e/comments", "author": null, "committer": null, "parents": [{"sha": "f7f7ac5a61e2748e2382fc4558fe6dddece5e412", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7f7ac5a61e2748e2382fc4558fe6dddece5e412", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7f7ac5a61e2748e2382fc4558fe6dddece5e412"}], "stats": {"total": 528, "additions": 478, "deletions": 50}, "files": [{"sha": "66269506c54416d3e71903bb135705c818800289", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75fe7b2f406d638fa6de89c44e0a862ab04a0b5e", "patch": "@@ -1,3 +1,20 @@\n+2005-06-01  Richard Earnshaw  <richard.earnshaw@arm.com>\n+\n+\t* arm.md (bunordered, bordered, bungt, bunlt, bunge, bunle, buneq)\n+\t(bltgt, arm_buneq, arm_bltgt, sunordered, sordered, sungt, sunge)\n+\t(sunlt, sunle): Enable patterns on VFP.\n+\n+\t* arm.md (attribute 'type'): Add new types - f_loads floadd, f_stores,\n+\tf_stored, f_flag, f_cvt.\n+\t(generic_sched): No-longer used for the arm1020e and arm1022e cores.\n+\tInclude arm1020e.md.\n+\t* vfp.md (fmstat): New cpu unit.  Add an exclusion set between it and\n+\tthe ds and fmac pipelines.  Re-work all load and store patterns and\n+\tall conversion patterns to use new attributes.  Adjust reservation\n+\tdescriptions accordingly.\n+\t* arm1020e.md: New file.\n+\t* t-arm: Add dependency.\n+\n 2005-06-01  Jan Hubicka  <jh@suse.cz>\n \n \t* except.c (struct eh_region): Kill unused fields."}, {"sha": "eee28a00785b881797b52947ca4a3cb79da35bc8", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=75fe7b2f406d638fa6de89c44e0a862ab04a0b5e", "patch": "@@ -202,10 +202,14 @@\n ;\t\teven on a machine with an fpa.\n ; f_load\ta floating point load from memory\n ; f_store\ta floating point store to memory\n+; f_load[sd]\tsingle/double load from memeory\n+; f_store[sd]\tsingle/double store to memeory\n+; f_flag\ta transfer of co-processor flags to the CPSR\n ; f_mem_r\ta transfer of a floating point register to a real reg via mem\n ; r_mem_f\tthe reverse of f_mem_r\n ; f_2_r\t\tfast transfer float to arm (no memory needed)\n ; r_2_f\t\tfast transfer arm to float\n+; f_cvt\t\tconvert floating<->integral\n ; branch\ta branch\n ; call\t\ta subroutine call\n ; load_byte\tload byte(s) from memory to arm registers\n@@ -222,7 +226,7 @@\n ; mav_dmult\tDouble multiplies (7 cycle)\n ;\n (define_attr \"type\"\n-\t\"alu,alu_shift,alu_shift_reg,mult,block,float,fdivx,fdivd,fdivs,fmul,ffmul,farith,ffarith,float_em,f_load,f_store,f_mem_r,r_mem_f,f_2_r,r_2_f,branch,call,load_byte,load1,load2,load3,load4,store1,store2,store3,store4,mav_farith,mav_dmult\" \n+\t\"alu,alu_shift,alu_shift_reg,mult,block,float,fdivx,fdivd,fdivs,fmul,ffmul,farith,ffarith,f_flag,float_em,f_load,f_store,f_loads,f_loadd,f_stores,f_stored,f_mem_r,r_mem_f,f_2_r,r_2_f,f_cvt,branch,call,load_byte,load1,load2,load3,load4,store1,store2,store3,store4,mav_farith,mav_dmult\" \n \t(if_then_else \n \t (eq_attr \"insn\" \"smulxy,smlaxy,smlalxy,smulwy,smlawx,mul,muls,mla,mlas,umull,umulls,umlal,umlals,smull,smulls,smlal,smlals\")\n \t (const_string \"mult\")\n@@ -313,12 +317,20 @@\n \n (define_attr \"generic_sched\" \"yes,no\"\n   (const (if_then_else \n-          (eq_attr \"tune\" \"arm926ejs,arm1026ejs,arm1136js,arm1136jfs\") \n+          (eq_attr \"tune\" \"arm926ejs,arm1020e,arm1026ejs,arm1136js,arm1136jfs\") \n           (const_string \"no\")\n           (const_string \"yes\"))))\n \n+(define_attr \"generic_vfp\" \"yes,no\"\n+  (const (if_then_else\n+\t  (and (eq_attr \"fpu\" \"vfp\")\n+\t       (eq_attr \"tune\" \"!arm1020e,arm1022e\"))\n+\t  (const_string \"yes\")\n+\t  (const_string \"no\"))))\n+\n (include \"arm-generic.md\")\n (include \"arm926ejs.md\")\n+(include \"arm1020e.md\")\n (include \"arm1026ejs.md\")\n (include \"arm1136jfs.md\")\n \n@@ -6963,7 +6975,7 @@\n \t(if_then_else (unordered (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (UNORDERED, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n@@ -6973,7 +6985,7 @@\n \t(if_then_else (ordered (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (ORDERED, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n@@ -6983,7 +6995,7 @@\n \t(if_then_else (ungt (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (UNGT, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -6992,7 +7004,7 @@\n \t(if_then_else (unlt (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (UNLT, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -7001,7 +7013,7 @@\n \t(if_then_else (unge (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (UNGE, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -7010,7 +7022,7 @@\n \t(if_then_else (unle (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (UNLE, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -7021,7 +7033,7 @@\n \t(if_then_else (uneq (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (UNEQ, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -7030,7 +7042,7 @@\n \t(if_then_else (ltgt (match_dup 1) (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (LTGT, arm_compare_op0, arm_compare_op1);\"\n )\n \n@@ -7044,7 +7056,7 @@\n \t(if_then_else (uneq (match_operand 1 \"cc_register\" \"\") (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"*\n   gcc_assert (!arm_ccfsm_state);\n \n@@ -7060,7 +7072,7 @@\n \t(if_then_else (ltgt (match_operand 1 \"cc_register\" \"\") (const_int 0))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"*\n   gcc_assert (!arm_ccfsm_state);\n \n@@ -7095,7 +7107,7 @@\n \t(if_then_else (uneq (match_operand 1 \"cc_register\" \"\") (const_int 0))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"*\n   gcc_assert (!arm_ccfsm_state);\n \n@@ -7111,7 +7123,7 @@\n \t(if_then_else (ltgt (match_operand 1 \"cc_register\" \"\") (const_int 0))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"*\n   gcc_assert (!arm_ccfsm_state);\n \n@@ -7217,47 +7229,47 @@\n (define_expand \"sunordered\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(unordered:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (UNORDERED, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n \n (define_expand \"sordered\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(ordered:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (ORDERED, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n \n (define_expand \"sungt\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(ungt:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (UNGT, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n \n (define_expand \"sunge\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(unge:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (UNGE, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n \n (define_expand \"sunlt\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(unlt:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (UNLT, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n \n (define_expand \"sunle\"\n   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n \t(unle:SI (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+  \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n   \"operands[1] = arm_gen_compare_reg (UNLE, arm_compare_op0,\n \t\t\t\t      arm_compare_op1);\"\n )\n@@ -7268,14 +7280,14 @@\n ; (define_expand \"suneq\"\n ;   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n ; \t(uneq:SI (match_dup 1) (const_int 0)))]\n-;   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+;   \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n ;   \"gcc_unreachable ();\"\n ; )\n ;\n ; (define_expand \"sltgt\"\n ;   [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n ; \t(ltgt:SI (match_dup 1) (const_int 0)))]\n-;   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_FPA\"\n+;   \"TARGET_ARM && TARGET_HARD_FLOAT && (TARGET_FPA || TARGET_VFP)\"\n ;   \"gcc_unreachable ();\"\n ; )\n "}, {"sha": "e0360157c8aed0af135557295502f02a7efd47fa", "filename": "gcc/config/arm/arm1020e.md", "status": "added", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e/gcc%2Fconfig%2Farm%2Farm1020e.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e/gcc%2Fconfig%2Farm%2Farm1020e.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm1020e.md?ref=75fe7b2f406d638fa6de89c44e0a862ab04a0b5e", "patch": "@@ -0,0 +1,388 @@\n+;; ARM 1020E & ARM 1022E Pipeline Description\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;; Contributed by Richard Earnshaw (richard.earnshaw@arm.com)\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify it\n+;; under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful, but\n+;; WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+;; General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to the Free\n+;; Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+;; 02111-1307, USA.  */\n+\n+;; These descriptions are based on the information contained in the\n+;; ARM1020E Technical Reference Manual, Copyright (c) 2003 ARM\n+;; Limited.\n+;;\n+\n+;; This automaton provides a pipeline description for the ARM\n+;; 1020E core.\n+;;\n+;; The model given here assumes that the condition for all conditional\n+;; instructions is \"true\", i.e., that all of the instructions are\n+;; actually executed.\n+\n+(define_automaton \"arm1020e\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Pipelines\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; There are two pipelines:\n+;; \n+;; - An Arithmetic Logic Unit (ALU) pipeline.\n+;;\n+;;   The ALU pipeline has fetch, issue, decode, execute, memory, and\n+;;   write stages. We only need to model the execute, memory and write\n+;;   stages.\n+;;\n+;; - A Load-Store Unit (LSU) pipeline.\n+;;\n+;;   The LSU pipeline has decode, execute, memory, and write stages.\n+;;   We only model the execute, memory and write stages.\n+\n+(define_cpu_unit \"1020a_e,1020a_m,1020a_w\" \"arm1020e\")\n+(define_cpu_unit \"1020l_e,1020l_m,1020l_w\" \"arm1020e\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; ALU Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; ALU instructions require three cycles to execute, and use the ALU\n+;; pipeline in each of the three stages.  The results are available\n+;; after the execute stage stage has finished.\n+;;\n+;; If the destination register is the PC, the pipelines are stalled\n+;; for several cycles.  That case is not modeled here.\n+\n+;; ALU operations with no shifted operand\n+(define_insn_reservation \"1020alu_op\" 1 \n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"type\" \"alu\"))\n+ \"1020a_e,1020a_m,1020a_w\")\n+\n+;; ALU operations with a shift-by-constant operand\n+(define_insn_reservation \"1020alu_shift_op\" 1 \n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"type\" \"alu_shift\"))\n+ \"1020a_e,1020a_m,1020a_w\")\n+\n+;; ALU operations with a shift-by-register operand\n+;; These really stall in the decoder, in order to read\n+;; the shift value in a second cycle. Pretend we take two cycles in\n+;; the execute stage.\n+(define_insn_reservation \"1020alu_shift_reg_op\" 2 \n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"type\" \"alu_shift_reg\"))\n+ \"1020a_e*2,1020a_m,1020a_w\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Multiplication Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Multiplication instructions loop in the execute stage until the\n+;; instruction has been passed through the multiplier array enough\n+;; times.\n+\n+;; The result of the \"smul\" and \"smulw\" instructions is not available\n+;; until after the memory stage.\n+(define_insn_reservation \"1020mult1\" 2\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"insn\" \"smulxy,smulwy\"))\n+ \"1020a_e,1020a_m,1020a_w\")\n+\n+;; The \"smlaxy\" and \"smlawx\" instructions require two iterations through\n+;; the execute stage; the result is available immediately following\n+;; the execute stage.\n+(define_insn_reservation \"1020mult2\" 2\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"insn\" \"smlaxy,smlalxy,smlawx\"))\n+ \"1020a_e*2,1020a_m,1020a_w\")\n+\n+;; The \"smlalxy\", \"mul\", and \"mla\" instructions require two iterations\n+;; through the execute stage; the result is not available until after\n+;; the memory stage.\n+(define_insn_reservation \"1020mult3\" 3\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"insn\" \"smlalxy,mul,mla\"))\n+ \"1020a_e*2,1020a_m,1020a_w\")\n+\n+;; The \"muls\" and \"mlas\" instructions loop in the execute stage for\n+;; four iterations in order to set the flags.  The value result is\n+;; available after three iterations.\n+(define_insn_reservation \"1020mult4\" 3\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"insn\" \"muls,mlas\"))\n+ \"1020a_e*4,1020a_m,1020a_w\")\n+\n+;; Long multiply instructions that produce two registers of\n+;; output (such as umull) make their results available in two cycles;\n+;; the least significant word is available before the most significant\n+;; word.  That fact is not modeled; instead, the instructions are\n+;; described.as if the entire result was available at the end of the\n+;; cycle in which both words are available.\n+\n+;; The \"umull\", \"umlal\", \"smull\", and \"smlal\" instructions all take\n+;; three iterations through the execute cycle, and make their results\n+;; available after the memory cycle.\n+(define_insn_reservation \"1020mult5\" 4\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"insn\" \"umull,umlal,smull,smlal\"))\n+ \"1020a_e*3,1020a_m,1020a_w\")\n+\n+;; The \"umulls\", \"umlals\", \"smulls\", and \"smlals\" instructions loop in\n+;; the execute stage for five iterations in order to set the flags.\n+;; The value result is available after four iterations.\n+(define_insn_reservation \"1020mult6\" 4\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"insn\" \"umulls,umlals,smulls,smlals\"))\n+ \"1020a_e*5,1020a_m,1020a_w\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Load/Store Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; The models for load/store instructions do not accurately describe\n+;; the difference between operations with a base register writeback\n+;; (such as \"ldm!\").  These models assume that all memory references\n+;; hit in dcache.\n+\n+;; LSU instructions require six cycles to execute.  They use the ALU\n+;; pipeline in all but the 5th cycle, and the LSU pipeline in cycles\n+;; three through six.\n+;; Loads and stores which use a scaled register offset or scaled\n+;; register pre-indexed addressing mode take three cycles EXCEPT for\n+;; those that are base + offset with LSL of 0 or 2, or base - offset\n+;; with LSL of zero.  The remainder take 1 cycle to execute.\n+;; For 4byte loads there is a bypass from the load stage\n+\n+(define_insn_reservation \"1020load1_op\" 2\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"type\" \"load_byte,load1\"))\n+ \"1020a_e+1020l_e,1020l_m,1020l_w\")\n+\n+(define_insn_reservation \"1020store1_op\" 0\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"type\" \"store1\"))\n+ \"1020a_e+1020l_e,1020l_m,1020l_w\")\n+\n+;; A load's result can be stored by an immediately following store\n+(define_bypass 1 \"1020load1_op\" \"1020store1_op\" \"arm_no_early_store_addr_dep\")\n+\n+;; On a LDM/STM operation, the LSU pipeline iterates until all of the\n+;; registers have been processed.\n+;;\n+;; The time it takes to load the data depends on whether or not the\n+;; base address is 64-bit aligned; if it is not, an additional cycle\n+;; is required.  This model assumes that the address is always 64-bit\n+;; aligned.  Because the processor can load two registers per cycle,\n+;; that assumption means that we use the same instruction reservations\n+;; for loading 2k and 2k - 1 registers.\n+;;\n+;; The ALU pipeline is decoupled after the first cycle unless there is\n+;; a register dependency; the depency is cleared as soon as the LDM/STM\n+;; has dealt with the corresponding register.  So for exmple,\n+;;  stmia sp, {r0-r3}\n+;;  add\tr0, r0, #4\n+;; will have one fewer stalls than\n+;;  stmia sp, {r0-r3}\n+;;  add r3, r3, #4\n+;;\n+;; As with ALU operations, if one of the destination registers is the\n+;; PC, there are additional stalls; that is not modeled.\n+\n+(define_insn_reservation \"1020load2_op\" 2\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"type\" \"load2\"))\n+ \"1020a_e+1020l_e,1020l_m,1020l_w\")\n+\n+(define_insn_reservation \"1020store2_op\" 0\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"type\" \"store2\"))\n+ \"1020a_e+1020l_e,1020l_m,1020l_w\")\n+\n+(define_insn_reservation \"1020load34_op\" 3\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"type\" \"load3,load4\"))\n+ \"1020a_e+1020l_e,1020l_e+1020l_m,1020l_m,1020l_w\")\n+\n+(define_insn_reservation \"1020store34_op\" 0\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"type\" \"store3,store4\"))\n+ \"1020a_e+1020l_e,1020l_e+1020l_m,1020l_m,1020l_w\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; Branch and Call Instructions\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+;; Branch instructions are difficult to model accurately.  The ARM\n+;; core can predict most branches.  If the branch is predicted\n+;; correctly, and predicted early enough, the branch can be completely\n+;; eliminated from the instruction stream.  Some branches can\n+;; therefore appear to require zero cycles to execute.  We assume that\n+;; all branches are predicted correctly, and that the latency is\n+;; therefore the minimum value.\n+\n+(define_insn_reservation \"1020branch_op\" 0\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"type\" \"branch\"))\n+ \"1020a_e\")\n+\n+;; The latency for a call is not predictable.  Therefore, we use 32 as\n+;; roughly equivalent to positive infinity.\n+\n+(define_insn_reservation \"1020call_op\" 32\n+ (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+      (eq_attr \"type\" \"call\"))\n+ \"1020a_e*32\")\n+\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+;; VFP\n+;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n+\n+(define_cpu_unit \"v10_fmac\" \"arm1020e\")\n+\n+(define_cpu_unit \"v10_ds\" \"arm1020e\")\n+\n+(define_cpu_unit \"v10_fmstat\" \"arm1020e\")\n+\n+(define_cpu_unit \"v10_ls1,v10_ls2,v10_ls3\" \"arm1020e\")\n+\n+;; fmstat is a serializing instruction.  It will stall the core until\n+;; the mac and ds units have completed.\n+(exclusion_set \"v10_fmac,v10_ds\" \"v10_fmstat\")\n+\n+(define_attr \"vfp10\" \"yes,no\" \n+  (const (if_then_else (and (eq_attr \"tune\" \"arm1020e,arm1022e\")\n+\t\t\t    (eq_attr \"fpu\" \"vfp\"))\n+\t\t       (const_string \"yes\") (const_string \"no\"))))\n+\n+;; The VFP \"type\" attributes differ from those used in the FPA model.\n+;; ffarith\tFast floating point insns, e.g. abs, neg, cpy, cmp.\n+;; farith\tMost arithmetic insns.\n+;; fmul\t\tDouble precision multiply.\n+;; fdivs\tSingle precision sqrt or division.\n+;; fdivd\tDouble precision sqrt or division.\n+;; f_flag\tfmstat operation\n+;; f_load\tFloating point load from memory.\n+;; f_store\tFloating point store to memory.\n+;; f_2_r\tTransfer vfp to arm reg.\n+;; r_2_f\tTransfer arm to vfp reg.\n+\n+;; Note, no instruction can issue to the VFP if the core is stalled in the\n+;; first execute state.  We model this by using 1020a_e in the first cycle.\n+(define_insn_reservation \"v10_ffarith\" 5\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"ffarith\"))\n+ \"1020a_e+v10_fmac\")\n+\n+(define_insn_reservation \"v10_farith\" 5\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"farith\"))\n+ \"1020a_e+v10_fmac\")\n+\n+(define_insn_reservation \"v10_cvt\" 5\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"f_cvt\"))\n+ \"1020a_e+v10_fmac\")\n+\n+(define_insn_reservation \"v10_fmul\" 6\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"fmul\"))\n+ \"1020a_e+v10_fmac*2\")\n+\n+(define_insn_reservation \"v10_fdivs\" 18\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"fdivs\"))\n+ \"1020a_e+v10_ds*14\")\n+\n+(define_insn_reservation \"v10_fdivd\" 32\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"fdivd\"))\n+ \"1020a_e+v10_fmac+v10_ds*28\")\n+\n+(define_insn_reservation \"v10_floads\" 4\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"f_loads\"))\n+ \"1020a_e+1020l_e+v10_ls1,v10_ls2\")\n+\n+;; We model a load of a double as needing all the vfp ls* stage in cycle 1.\n+;; This gives the correct mix between single-and double loads where a flds\n+;; followed by and fldd will stall for one cycle, but two back-to-back fldd\n+;; insns stall for two cycles.\n+(define_insn_reservation \"v10_floadd\" 5\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"f_loadd\"))\n+ \"1020a_e+1020l_e+v10_ls1+v10_ls2+v10_ls3,v10_ls2+v10_ls3,v10_ls3\")\n+ \n+;; Moves to/from arm regs also use the load/store pipeline.\n+\n+(define_insn_reservation \"v10_c2v\" 4\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"r_2_f\"))\n+ \"1020a_e+1020l_e+v10_ls1,v10_ls2\")\n+\n+(define_insn_reservation \"v10_fstores\" 1\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"f_stores\"))\n+ \"1020a_e+1020l_e+v10_ls1,v10_ls2\")\n+\n+(define_insn_reservation \"v10_fstored\" 1\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"f_stored\"))\n+ \"1020a_e+1020l_e+v10_ls1+v10_ls2+v10_ls3,v10_ls2+v10_ls3,v10_ls3\")\n+\n+(define_insn_reservation \"v10_v2c\" 1\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"f_2_r\"))\n+ \"1020a_e+1020l_e,1020l_m,1020l_w\")\n+\n+(define_insn_reservation \"v10_to_cpsr\" 2\n+ (and (eq_attr \"vfp10\" \"yes\")\n+      (eq_attr \"type\" \"f_flag\"))\n+ \"1020a_e+v10_fmstat,1020a_e+1020l_e,1020l_m,1020l_w\")\n+\n+;; VFP bypasses\n+\n+;; There are bypasses for most operations other than store\n+\n+(define_bypass 3\n+ \"v10_c2v,v10_floads\"\n+ \"v10_ffarith,v10_farith,v10_fmul,v10_fdivs,v10_fdivd,v10_cvt\")\n+\n+(define_bypass 4\n+ \"v10_floadd\"\n+ \"v10_ffarith,v10_farith,v10_fmul,v10_fdivs,v10_fdivd\")\n+\n+;; Arithmetic to other arithmetic saves a cycle due to forwarding\n+(define_bypass 4\n+ \"v10_ffarith,v10_farith\"\n+ \"v10_ffarith,v10_farith,v10_fmul,v10_fdivs,v10_fdivd\")\n+\n+(define_bypass 5\n+ \"v10_fmul\"\n+ \"v10_ffarith,v10_farith,v10_fmul,v10_fdivs,v10_fdivd\")\n+\n+(define_bypass 17\n+ \"v10_fdivs\"\n+ \"v10_ffarith,v10_farith,v10_fmul,v10_fdivs,v10_fdivd\")\n+\n+(define_bypass 31\n+ \"v10_fdivd\"\n+ \"v10_ffarith,v10_farith,v10_fmul,v10_fdivs,v10_fdivd\")\n+\n+;; VFP anti-dependencies.\n+\n+;; There is one anti-dependence in the following case (not yet modelled):\n+;; - After a store: one extra cycle for both fsts and fstd\n+;; Note, back-to-back fstd instructions will overload the load/store datapath \n+;; causing a two-cycle stall."}, {"sha": "9fcd187865addc7ef005f34ee5cc083f6707cab1", "filename": "gcc/config/arm/t-arm", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e/gcc%2Fconfig%2Farm%2Ft-arm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e/gcc%2Fconfig%2Farm%2Ft-arm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ft-arm?ref=75fe7b2f406d638fa6de89c44e0a862ab04a0b5e", "patch": "@@ -3,6 +3,7 @@\n MD_INCLUDES= \t$(srcdir)/config/arm/arm-tune.md \\\n \t\t$(srcdir)/config/arm/predicates.md \\\n \t\t$(srcdir)/config/arm/arm-generic.md \\\n+\t\t$(srcdir)/config/arm/arm1020e.md \\\n \t\t$(srcdir)/config/arm/arm1026ejs.md \\\n \t\t$(srcdir)/config/arm/arm1136jfs.md \\\n \t\t$(srcdir)/config/arm/arm926ejs.md \\"}, {"sha": "443562b629e62a2d72c2a86e16edec633903ef2b", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 38, "deletions": 28, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75fe7b2f406d638fa6de89c44e0a862ab04a0b5e/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=75fe7b2f406d638fa6de89c44e0a862ab04a0b5e", "patch": "@@ -55,53 +55,63 @@\n \n (define_cpu_unit \"vfp_ls\" \"vfp11\")\n \n+(define_cpu_unit \"fmstat\" \"vfp11\")\n+\n+(exclusion_set \"fmac,ds\" \"fmstat\")\n+\n ;; The VFP \"type\" attributes differ from those used in the FPA model.\n ;; ffarith\tFast floating point insns, e.g. abs, neg, cpy, cmp.\n ;; farith\tMost arithmetic insns.\n ;; fmul\t\tDouble precision multiply.\n ;; fdivs\tSingle precision sqrt or division.\n ;; fdivd\tDouble precision sqrt or division.\n-;; f_load\tFloating point load from memory.\n-;; f_store\tFloating point store to memory.\n+;; f_flag\tfmstat operation\n+;; f_load[sd]\tFloating point load from memory.\n+;; f_store[sd]\tFloating point store to memory.\n ;; f_2_r\tTransfer vfp to arm reg.\n ;; r_2_f\tTransfer arm to vfp reg.\n+;; f_cvt\tConvert floating<->integral\n \n (define_insn_reservation \"vfp_ffarith\" 4\n- (and (eq_attr \"fpu\" \"vfp\")\n+ (and (eq_attr \"generic_vfp\" \"yes\")\n       (eq_attr \"type\" \"ffarith\"))\n  \"fmac\")\n \n (define_insn_reservation \"vfp_farith\" 8\n- (and (eq_attr \"fpu\" \"vfp\")\n-      (eq_attr \"type\" \"farith\"))\n+ (and (eq_attr \"generic_vfp\" \"yes\")\n+      (eq_attr \"type\" \"farith,f_cvt\"))\n  \"fmac\")\n \n (define_insn_reservation \"vfp_fmul\" 9\n- (and (eq_attr \"fpu\" \"vfp\")\n+ (and (eq_attr \"generic_vfp\" \"yes\")\n       (eq_attr \"type\" \"fmul\"))\n  \"fmac*2\")\n \n (define_insn_reservation \"vfp_fdivs\" 19\n- (and (eq_attr \"fpu\" \"vfp\")\n+ (and (eq_attr \"generic_vfp\" \"yes\")\n       (eq_attr \"type\" \"fdivs\"))\n  \"ds*15\")\n \n (define_insn_reservation \"vfp_fdivd\" 33\n- (and (eq_attr \"fpu\" \"vfp\")\n+ (and (eq_attr \"generic_vfp\" \"yes\")\n       (eq_attr \"type\" \"fdivd\"))\n  \"fmac+ds*29\")\n \n ;; Moves to/from arm regs also use the load/store pipeline.\n (define_insn_reservation \"vfp_fload\" 4\n- (and (eq_attr \"fpu\" \"vfp\")\n-      (eq_attr \"type\" \"f_load,r_2_f\"))\n+ (and (eq_attr \"generic_vfp\" \"yes\")\n+      (eq_attr \"type\" \"f_loads,f_loadd,r_2_f\"))\n  \"vfp_ls\")\n \n (define_insn_reservation \"vfp_fstore\" 4\n- (and (eq_attr \"fpu\" \"vfp\")\n-      (eq_attr \"type\" \"f_load,f_2_r\"))\n+ (and (eq_attr \"generic_vfp\" \"yes\")\n+      (eq_attr \"type\" \"f_stores,f_stored,f_2_r\"))\n  \"vfp_ls\")\n \n+(define_insn_reservation \"vfp_to_cpsr\" 4\n+ (and (eq_attr \"generic_vfp\" \"yes\")\n+      (eq_attr \"type\" \"f_flag\"))\n+ \"fmstat,vfp_ls*3\")\n \n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n ;; Insn pattern\n@@ -127,7 +137,7 @@\n   flds%?\\\\t%0, %1\\\\t%@ int\n   fsts%?\\\\t%1, %0\\\\t%@ int\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"*,*,load1,store1,r_2_f,f_2_r,ffarith,f_load,f_store\")\n+   (set_attr \"type\" \"*,*,load1,store1,r_2_f,f_2_r,ffarith,f_loads,f_stores\")\n    (set_attr \"pool_range\"     \"*,*,4096,*,*,*,*,1020,*\")\n    (set_attr \"neg_pool_range\" \"*,*,4084,*,*,*,*,1008,*\")]\n )\n@@ -161,7 +171,7 @@\n       gcc_unreachable ();\n     }\n   \"\n-  [(set_attr \"type\" \"*,load2,store2,r_2_f,f_2_r,ffarith,f_load,f_store\")\n+  [(set_attr \"type\" \"*,load2,store2,r_2_f,f_2_r,ffarith,f_loadd,f_stored\")\n    (set_attr \"length\" \"8,8,8,4,4,4,4,4\")\n    (set_attr \"pool_range\"     \"*,1020,*,*,*,*,1020,*\")\n    (set_attr \"neg_pool_range\" \"*,1008,*,*,*,*,1008,*\")]\n@@ -186,7 +196,7 @@\n   fcpys%?\\\\t%0, %1\n   mov%?\\\\t%0, %1\\\\t%@ float\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"r_2_f,f_2_r,ffarith,*,f_load,f_store,load1,store1\")\n+   (set_attr \"type\" \"r_2_f,f_2_r,ffarith,*,f_loads,f_stores,load1,store1\")\n    (set_attr \"pool_range\" \"*,*,1020,*,4096,*,*,*\")\n    (set_attr \"neg_pool_range\" \"*,*,1008,*,4080,*,*,*\")]\n )\n@@ -221,7 +231,7 @@\n       }\n     }\n   \"\n-  [(set_attr \"type\" \"r_2_f,f_2_r,ffarith,*,load2,store2,f_load,f_store\")\n+  [(set_attr \"type\" \"r_2_f,f_2_r,ffarith,*,load2,store2,f_loadd,f_stored\")\n    (set_attr \"length\" \"4,4,8,8,4,4,4,8\")\n    (set_attr \"pool_range\" \"*,*,1020,*,1020,*,*,*\")\n    (set_attr \"neg_pool_range\" \"*,*,1008,*,1008,*,*,*\")]\n@@ -572,7 +582,7 @@\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fcvtds%?\\\\t%P0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"farith\")]\n+   (set_attr \"type\" \"f_cvt\")]\n )\n \n (define_insn \"*truncdfsf2_vfp\"\n@@ -581,7 +591,7 @@\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fcvtsd%?\\\\t%0, %P1\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"farith\")]\n+   (set_attr \"type\" \"f_cvt\")]\n )\n \n (define_insn \"*truncsisf2_vfp\"\n@@ -590,7 +600,7 @@\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"ftosizs%?\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"farith\")]\n+   (set_attr \"type\" \"f_cvt\")]\n )\n \n (define_insn \"*truncsidf2_vfp\"\n@@ -599,7 +609,7 @@\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"ftosizd%?\\\\t%0, %P1\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"farith\")]\n+   (set_attr \"type\" \"f_cvt\")]\n )\n \n \n@@ -609,7 +619,7 @@\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"ftouizs%?\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"farith\")]\n+   (set_attr \"type\" \"f_cvt\")]\n )\n \n (define_insn \"fixuns_truncdfsi2\"\n@@ -618,7 +628,7 @@\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"ftouizd%?\\\\t%0, %P1\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"farith\")]\n+   (set_attr \"type\" \"f_cvt\")]\n )\n \n \n@@ -628,7 +638,7 @@\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fsitos%?\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"farith\")]\n+   (set_attr \"type\" \"f_cvt\")]\n )\n \n (define_insn \"*floatsidf2_vfp\"\n@@ -637,7 +647,7 @@\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fsitod%?\\\\t%P0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"farith\")]\n+   (set_attr \"type\" \"f_cvt\")]\n )\n \n \n@@ -647,7 +657,7 @@\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fuitos%?\\\\t%0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"farith\")]\n+   (set_attr \"type\" \"f_cvt\")]\n )\n \n (define_insn \"floatunssidf2\"\n@@ -656,7 +666,7 @@\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fuitod%?\\\\t%P0, %1\"\n   [(set_attr \"predicable\" \"yes\")\n-   (set_attr \"type\" \"farith\")]\n+   (set_attr \"type\" \"f_cvt\")]\n )\n \n \n@@ -689,7 +699,7 @@\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"fmstat%?\"\n   [(set_attr \"conds\" \"set\")\n-   (set_attr \"type\" \"ffarith\")]\n+   (set_attr \"type\" \"f_flag\")]\n )\n \n (define_insn_and_split \"*cmpsf_split_vfp\"\n@@ -813,7 +823,7 @@\n \t\t      UNSPEC_PUSH_MULT))])]\n   \"TARGET_ARM && TARGET_HARD_FLOAT && TARGET_VFP\"\n   \"* return vfp_output_fstmx (operands);\"\n-  [(set_attr \"type\" \"f_store\")]\n+  [(set_attr \"type\" \"f_stored\")]\n )\n \n "}]}