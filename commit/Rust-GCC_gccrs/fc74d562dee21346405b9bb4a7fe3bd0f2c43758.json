{"sha": "fc74d562dee21346405b9bb4a7fe3bd0f2c43758", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmM3NGQ1NjJkZWUyMTM0NjQwNWI5YmI0YTdmZTNiZDBmMmM0Mzc1OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-11-27T20:07:15Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-11-27T20:07:15Z"}, "message": "compiler: change expression importing to use Import_expression\n    \n    Change expression importing to use a new abstract interface class\n    Import_expression, so that we can more easily import expressions from\n    inlinable function bodies.  This is a refactoring with no affect on\n    compiler behavior.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/150065\n\nFrom-SVN: r266526", "tree": {"sha": "35d3a10f8cc71c587e964eea8bb12bb2e4c8ebe2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/35d3a10f8cc71c587e964eea8bb12bb2e4c8ebe2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc74d562dee21346405b9bb4a7fe3bd0f2c43758", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc74d562dee21346405b9bb4a7fe3bd0f2c43758", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc74d562dee21346405b9bb4a7fe3bd0f2c43758", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/comments", "author": null, "committer": null, "parents": [{"sha": "593570593e0401d2c8cb34ced3efd0cd50e2638e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/593570593e0401d2c8cb34ced3efd0cd50e2638e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/593570593e0401d2c8cb34ced3efd0cd50e2638e"}], "stats": {"total": 365, "additions": 296, "deletions": 69}, "files": [{"sha": "7aebeb10333f668ea5a7de4a012d395a1dcf85b7", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=fc74d562dee21346405b9bb4a7fe3bd0f2c43758", "patch": "@@ -1,4 +1,4 @@\n-75d48ff977a2865d12b03857362ea48016a4b885\n+6e0974fc6c9aa6ef19f72fbb5698e4b3734a4220\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "9292b5c4d2f471245326763d95933ec4221dcd45", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=fc74d562dee21346405b9bb4a7fe3bd0f2c43758", "patch": "@@ -1583,7 +1583,7 @@ class Boolean_expression : public Expression\n   { }\n \n   static Expression*\n-  do_import(Import*, Location);\n+  do_import(Import_expression*, Location);\n \n  protected:\n   bool\n@@ -1649,7 +1649,7 @@ Boolean_expression::do_determine_type(const Type_context* context)\n // Import a boolean constant.\n \n Expression*\n-Boolean_expression::do_import(Import* imp, Location loc)\n+Boolean_expression::do_import(Import_expression* imp, Location loc)\n {\n   if (imp->peek_char() == 't')\n     {\n@@ -1768,7 +1768,7 @@ String_expression::do_export(Export_function_body* efb) const\n // Import a string expression.\n \n Expression*\n-String_expression::do_import(Import* imp, Location loc)\n+String_expression::do_import(Import_expression* imp, Location loc)\n {\n   imp->require_c_string(\"\\\"\");\n   std::string val;\n@@ -1944,7 +1944,7 @@ class Integer_expression : public Expression\n   { mpz_init_set(this->val_, *val); }\n \n   static Expression*\n-  do_import(Import*, Location);\n+  do_import(Import_expression*, Location);\n \n   // Write VAL to string dump.\n   static void\n@@ -2151,7 +2151,7 @@ Integer_expression::do_export(Export_function_body* efb) const\n // all these types because they all start with digits.\n \n Expression*\n-Integer_expression::do_import(Import* imp, Location loc)\n+Integer_expression::do_import(Import_expression* imp, Location loc)\n {\n   std::string num = imp->read_identifier();\n   imp->require_c_string(\" \");\n@@ -3133,7 +3133,7 @@ class Nil_expression : public Expression\n   { }\n \n   static Expression*\n-  do_import(Import*, Location);\n+  do_import(Import_expression*, Location);\n \n  protected:\n   bool\n@@ -3172,7 +3172,7 @@ class Nil_expression : public Expression\n // Import a nil expression.\n \n Expression*\n-Nil_expression::do_import(Import* imp, Location loc)\n+Nil_expression::do_import(Import_expression* imp, Location loc)\n {\n   imp->require_c_string(\"nil\");\n   return Expression::make_nil(loc);\n@@ -3623,7 +3623,7 @@ Type_conversion_expression::do_export(Export_function_body* efb) const\n // Import a type conversion or a struct construction.\n \n Expression*\n-Type_conversion_expression::do_import(Import* imp, Location loc)\n+Type_conversion_expression::do_import(Import_expression* imp, Location loc)\n {\n   imp->require_c_string(\"convert(\");\n   Type* type = imp->read_type();\n@@ -4634,7 +4634,7 @@ Unary_expression::do_export(Export_function_body* efb) const\n // Import a unary expression.\n \n Expression*\n-Unary_expression::do_import(Import* imp, Location loc)\n+Unary_expression::do_import(Import_expression* imp, Location loc)\n {\n   Operator op;\n   switch (imp->get_char())\n@@ -6403,7 +6403,7 @@ Binary_expression::do_export(Export_function_body* efb) const\n // Import a binary expression.\n \n Expression*\n-Binary_expression::do_import(Import* imp, Location loc)\n+Binary_expression::do_import(Import_expression* imp, Location loc)\n {\n   imp->require_c_string(\"(\");\n \n@@ -16138,7 +16138,7 @@ Expression::make_backend(Bexpression* bexpr, Type* type, Location location)\n // various class definitions.\n \n Expression*\n-Expression::import_expression(Import* imp, Location loc)\n+Expression::import_expression(Import_expression* imp, Location loc)\n {\n   int c = imp->peek_char();\n   if (imp->match_c_string(\"- \")"}, {"sha": "70616571922582e35ce86d99078db76aa023b6b3", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=fc74d562dee21346405b9bb4a7fe3bd0f2c43758", "patch": "@@ -66,7 +66,7 @@ class Compound_expression;\n class Numeric_constant;\n class Named_object;\n class Export_function_body;\n-class Import;\n+class Import_expression;\n class Temporary_statement;\n class Label;\n class Ast_dump_context;\n@@ -1018,7 +1018,7 @@ class Expression\n   // returned expression.  Errors should be reported using the\n   // Import's location method.\n   static Expression*\n-  import_expression(Import*, Location);\n+  import_expression(Import_expression*, Location);\n \n   // Return an expression which checks that VAL, of arbitrary integer type,\n   // is non-negative and is not more than the maximum integer value.\n@@ -1567,7 +1567,7 @@ class String_expression : public Expression\n   { return this->val_; }\n \n   static Expression*\n-  do_import(Import*, Location);\n+  do_import(Import_expression*, Location);\n \n  protected:\n   bool\n@@ -1646,7 +1646,7 @@ class Type_conversion_expression : public Expression\n \n   // Import a type conversion expression.\n   static Expression*\n-  do_import(Import*, Location);\n+  do_import(Import_expression*, Location);\n \n  protected:\n   int\n@@ -1817,7 +1817,7 @@ class Unary_expression : public Expression\n \t\tLocation, Numeric_constant* nc, bool *issued_error);\n \n   static Expression*\n-  do_import(Import*, Location);\n+  do_import(Import_expression*, Location);\n \n   // Declare that this deref does or does not require an explicit nil check.\n   void\n@@ -1966,7 +1966,7 @@ class Binary_expression : public Expression\n \t\t   bool* result);\n \n   static Expression*\n-  do_import(Import*, Location);\n+  do_import(Import_expression*, Location);\n \n   // Report an error if OP can not be applied to TYPE.  Return whether\n   // it can.  OTYPE is the type of the other operand."}, {"sha": "eb0297bc2db379ee96af9c4405647eedc3c9eb00", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=fc74d562dee21346405b9bb4a7fe3bd0f2c43758", "patch": "@@ -527,9 +527,9 @@ Gogo::import_package(const std::string& filename,\n       return;\n     }\n \n-  Import imp(stream, location);\n-  imp.register_builtin_types(this);\n-  Package* package = imp.import(this, local_name, is_local_name_exported);\n+  Import* imp = new Import(stream, location);\n+  imp->register_builtin_types(this);\n+  Package* package = imp->import(this, local_name, is_local_name_exported);\n   if (package != NULL)\n     {\n       if (package->pkgpath() == this->pkgpath())\n@@ -540,7 +540,10 @@ Gogo::import_package(const std::string& filename,\n       this->imports_.insert(std::make_pair(filename, package));\n     }\n \n+  imp->clear_stream();\n   delete stream;\n+\n+  // FIXME: we never delete imp; we may need it for inlinable functions.\n }\n \n Import_init *\n@@ -6763,8 +6766,6 @@ Function_declaration::import_function_body(Gogo* gogo, Named_object* no)\n   const std::string& body(this->imported_body_);\n   go_assert(!body.empty());\n \n-  Location orig_loc = no->location();\n-\n   // Read the \"//FILE:LINE\" comment starts the export data.\n \n   size_t indent = 1;\n@@ -6877,7 +6878,7 @@ Function_declaration::import_function_body(Gogo* gogo, Named_object* no)\n       no = rtype->add_method(no->name(), fn);\n     }\n \n-  Import_function_body ifb(gogo, orig_loc, no, body, nl + 1, outer, indent);\n+  Import_function_body ifb(gogo, this->imp_, no, body, nl + 1, outer, indent);\n \n   if (!Block::import_block(outer, &ifb, start_loc))\n     return;"}, {"sha": "8ca567ca13c1a0cb7727a32122e1cb5bc55d3acd", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=fc74d562dee21346405b9bb4a7fe3bd0f2c43758", "patch": "@@ -1691,8 +1691,11 @@ class Function_declaration\n \n   // Record the imported body of this function.\n   void\n-  set_imported_body(const std::string& imported_body)\n-  { this->imported_body_ = imported_body; }\n+  set_imported_body(Import* imp, const std::string& imported_body)\n+  {\n+    this->imp_ = imp;\n+    this->imported_body_ = imported_body;\n+  }\n \n   // Whether this declaration is on the list of inlinable functions.\n   bool\n@@ -1756,6 +1759,8 @@ class Function_declaration\n   Bfunction* fndecl_;\n   // Pragmas for this function.  This is a set of GOPRAGMA bits.\n   unsigned int pragmas_;\n+  // Importer for function body if imported from a different package.\n+  Import* imp_;\n   // Export data for function body if imported from a different package.\n   std::string imported_body_;\n   // Whether this declaration is already on the list of inlinable functions."}, {"sha": "524e739f21c3c3b3085ef9ecc421214e74bb2725", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 128, "deletions": 36, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=fc74d562dee21346405b9bb4a7fe3bd0f2c43758", "patch": "@@ -790,7 +790,7 @@ Import::import_func(Package* package)\n   if (nointerface)\n     no->func_declaration_value()->set_nointerface();\n   if (!body.empty() && !no->func_declaration_value()->has_imported_body())\n-    no->func_declaration_value()->set_imported_body(body);\n+    no->func_declaration_value()->set_imported_body(this, body);\n \n   return no;\n }\n@@ -886,41 +886,7 @@ Import::read_type()\n   if (c == '>')\n     {\n       // A reference to a type defined earlier.\n-\n-      if (index >= 0 && !this->type_data_.empty())\n-\t{\n-\t  if (static_cast<size_t>(index) >= this->type_offsets_.size())\n-\t    {\n-\t      go_error_at(this->location_,\n-\t\t\t  (\"error in import data at %d: \"\n-\t\t\t   \"bad type index %d >= %d\"),\n-\t\t\t  stream->pos(), index,\n-\t\t\t  static_cast<int>(this->type_offsets_.size()));\n-\t      stream->set_saw_error();\n-\t      return Type::make_error_type();\n-\t    }\n-\n-\t  if (this->types_[index] == NULL)\n-\t    {\n-\t      if (!this->parse_type(index))\n-\t\treturn Type::make_error_type();\n-\t    }\n-\t}\n-\n-      if (index < 0\n-\t  ? (static_cast<size_t>(- index) >= this->builtin_types_.size()\n-\t     || this->builtin_types_[- index] == NULL)\n-\t  : (static_cast<size_t>(index) >= this->types_.size()\n-\t     || this->types_[index] == NULL))\n-\t{\n-\t  go_error_at(this->location_,\n-\t\t      \"error in import data at %d: bad type index %d\",\n-\t\t      stream->pos(), index);\n-\t  stream->set_saw_error();\n-\t  return Type::make_error_type();\n-\t}\n-\n-      return index < 0 ? this->builtin_types_[- index] : this->types_[index];\n+      return this->type_for_index(index, \"import data\", stream->pos());\n     }\n \n   if (this->version_ >= EXPORT_FORMAT_V3)\n@@ -1126,6 +1092,47 @@ Import::read_named_type(int index)\n   return type;\n }\n \n+// Return the type given an index.\n+\n+Type*\n+Import::type_for_index(int index, const std::string& input_name,\n+\t\t       size_t input_offset)\n+{\n+  if (index >= 0 && !this->type_data_.empty())\n+    {\n+      if (static_cast<size_t>(index) >= this->type_offsets_.size())\n+\t{\n+\t  go_error_at(this->location_,\n+\t\t      \"error in %s at %lu: bad type index %d >= %d\",\n+\t\t      input_name.c_str(),\n+\t\t      static_cast<unsigned long>(input_offset),\n+\t\t      index, static_cast<int>(this->type_offsets_.size()));\n+\t  return Type::make_error_type();\n+\t}\n+\n+      if (this->types_[index] == NULL)\n+\t{\n+\t  if (!this->parse_type(index))\n+\t    return Type::make_error_type();\n+\t}\n+    }\n+\n+  if (index < 0\n+      ? (static_cast<size_t>(- index) >= this->builtin_types_.size()\n+\t || this->builtin_types_[- index] == NULL)\n+      : (static_cast<size_t>(index) >= this->types_.size()\n+\t || this->types_[index] == NULL))\n+    {\n+      go_error_at(this->location_,\n+\t\t  \"error in %s at %lu: bad type index %d\",\n+\t\t  input_name.c_str(),\n+\t\t  static_cast<unsigned long>(input_offset), index);\n+      return Type::make_error_type();\n+    }\n+\n+  return index < 0 ? this->builtin_types_[- index] : this->types_[index];\n+}\n+\n // Read an escape note.\n \n std::string\n@@ -1408,3 +1415,88 @@ Import_function_body::name() const\n {\n   return this->named_object_->name();\n }\n+\n+// Class Import_function_body.\n+\n+// Require that the next bytes match STR, issuing an error if not.\n+// Advance past the string.\n+\n+void\n+Import_function_body::require_c_string(const char* str)\n+{\n+  if (!this->match_c_string(str))\n+    {\n+      if (!this->saw_error_)\n+\tgo_error_at(this->location(),\n+\t\t    \"invalid export data for %qs: expected %qs at %lu\",\n+\t\t    this->name().c_str(), str,\n+\t\t    static_cast<unsigned long>(this->off_));\n+      this->saw_error_ = true;\n+      return;\n+    }\n+  this->advance(strlen(str));\n+}\n+\n+// Read an identifier.\n+\n+std::string\n+Import_function_body::read_identifier()\n+{\n+  size_t start = this->off_;\n+  for (size_t i = start; i < this->body_.length(); i++)\n+    {\n+      int c = static_cast<unsigned char>(this->body_[i]);\n+      if (c == ' ' || c == '\\n' || c == ';')\n+\t{\n+\t  this->off_ = i;\n+\t  return this->body_.substr(start, i - start);\n+\t}\n+    }\n+  this->off_ = this->body_.length();\n+  return this->body_.substr(start);\n+}\n+\n+// Read a type.\n+\n+Type*\n+Import_function_body::read_type()\n+{\n+  this->require_c_string(\"<type \");\n+  size_t start = this->off_;\n+  size_t i;\n+  int c = '\\0';\n+  for (i = start; i < this->body_.length(); ++i)\n+    {\n+      c = static_cast<unsigned char>(this->body_[i]);\n+      if (c != '-' && (c < '0' || c > '9'))\n+\tbreak;\n+    }\n+  this->off_ = i + 1;\n+\n+  char *end;\n+  long val = strtol(this->body_.substr(start, i - start).c_str(), &end, 10);\n+  if (*end != '\\0' || i > 0x7fffffff)\n+    {\n+      if (!this->saw_error_)\n+\tgo_error_at(this->location(),\n+\t\t    \"invalid export data for %qs: expected integer at %lu\",\n+\t\t    this->name().c_str(),\n+\t\t    static_cast<unsigned long>(start));\n+      this->saw_error_ = true;\n+      return Type::make_error_type();\n+    }\n+\n+  if (c != '>')\n+    {\n+      if (!this->saw_error_)\n+\tgo_error_at(this->location(),\n+\t\t    \"invalid export data for %qs: expected %<>%> at %lu\",\n+\t\t    this->name().c_str(),\n+\t\t    static_cast<unsigned long>(i));\n+      this->saw_error_ = true;\n+      return Type::make_error_type();\n+    }\n+\n+  return this->imp_->type_for_index(static_cast<int>(val), this->name(),\n+\t\t\t\t    static_cast<unsigned long>(start));\n+}"}, {"sha": "c2120c9afd294f23573f5e8abb2956efb878dad9", "filename": "gcc/go/gofrontend/import.h", "status": "modified", "additions": 136, "deletions": 7, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc74d562dee21346405b9bb4a7fe3bd0f2c43758/gcc%2Fgo%2Fgofrontend%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.h?ref=fc74d562dee21346405b9bb4a7fe3bd0f2c43758", "patch": "@@ -17,10 +17,65 @@ class Type;\n class Named_object;\n class Named_type;\n class Expression;\n+class Import_function_body;\n+\n+// Expressions can be imported either directly from import data (for\n+// simple constant expressions that can appear in a const declaration\n+// or as an array length in a type definition) or from an exported\n+// function body (for an inlinable function).  These two cases happen\n+// at different points in the compilation and have different\n+// requirements, so it's not easy to unify them.  Import_expression is\n+// an abstract interface that permits the expression import code to\n+// work at either point.  When importing expressions that only occur\n+// for an inlinable function, the ifb method is available to get the\n+// full Import_function_body.\n+\n+class Import_expression\n+{\n+ public:\n+  // Return the import function body.  This should only be called for\n+  // expressions that can not appear outside of an inlinable function\n+  // body.\n+  virtual Import_function_body*\n+  ifb() = 0;\n+\n+  // The location to report in an error message.\n+  virtual Location\n+  location() const = 0;\n+\n+  // Peek at the next character in the input, returning a value from 0\n+  // to 0xff.  Returns -1 at end of stream.\n+  virtual int\n+  peek_char() = 0;\n+\n+  // Return the next character and advance.\n+  virtual int\n+  get_char() = 0;\n+\n+  // Return true if the next bytes match STR.\n+  virtual bool\n+  match_c_string(const char* str) = 0;\n+\n+  // Require that the next bytes match STR.\n+  virtual void\n+  require_c_string(const char* str) = 0;\n+\n+  // Advance the stream SKIP bytes.\n+  virtual void\n+  advance(size_t skip) = 0;\n+\n+  // Read an identifier.\n+  virtual std::string\n+  read_identifier() = 0;\n+\n+  // Read a type.\n+  virtual Type*\n+  read_type() = 0;\n+};\n \n // This class manages importing Go declarations.\n \n-class Import\n+class Import : public Import_expression\n {\n  public:\n   // The Stream class is an interface used to read the data.  The\n@@ -138,6 +193,9 @@ class Import\n   // Constructor.\n   Import(Stream*, Location);\n \n+  virtual ~Import()\n+  {}\n+\n   // Register the builtin types.\n   void\n   register_builtin_types(Gogo*);\n@@ -217,10 +275,26 @@ class Import\n   Type*\n   read_type();\n \n+  // Return the type for a type index.  INPUT_NAME and INPUT_OFFSET\n+  // are only for error reporting.\n+  Type*\n+  type_for_index(int index, const std::string& input_name,\n+\t\t size_t input_offset);\n+\n   // Read an escape note.\n   std::string\n   read_escape();\n \n+  // Clear the stream when it is no longer accessible.\n+  void\n+  clear_stream()\n+  { this->stream_ = NULL; }\n+\n+  // Just so that Import implements Import_expression.\n+  Import_function_body*\n+  ifb()\n+  { return NULL; }\n+\n  private:\n   static Stream*\n   try_package_in_directory(const std::string&, Location);\n@@ -468,13 +542,13 @@ class Stream_from_string_ref : public Import::Stream\n // Class to manage importing a function body.  This is passed around\n // to Statements and Expressions.  It parses the function into the IR.\n \n-class Import_function_body\n+class Import_function_body : public Import_expression\n {\n  public:\n-  Import_function_body(Gogo* gogo, Location loc, Named_object* named_object,\n+  Import_function_body(Gogo* gogo, Import* imp, Named_object* named_object,\n \t\t       const std::string& body, size_t off, Block* block,\n \t\t       int indent)\n-    : gogo_(gogo), loc_(loc), named_object_(named_object), body_(body),\n+    : gogo_(gogo), imp_(imp), named_object_(named_object), body_(body),\n       off_(off), block_(block), indent_(indent)\n   { }\n \n@@ -486,7 +560,7 @@ class Import_function_body\n   // The location to report in an error message.\n   Location\n   location() const\n-  { return this->loc_; }\n+  { return this->imp_->location(); }\n \n   // A reference to the body we are reading.\n   const std::string&\n@@ -503,6 +577,11 @@ class Import_function_body\n   set_off(size_t off)\n   { this->off_ = off; }\n \n+  // Advance the offset by SKIP bytes.\n+  void\n+  advance(size_t skip)\n+  { this->off_ += skip; }\n+\n   // The current block.\n   Block*\n   block()\n@@ -517,11 +596,58 @@ class Import_function_body\n   const std::string&\n   name() const;\n \n+  // Return the next character in the input stream, or -1 at the end.\n+  int\n+  peek_char()\n+  {\n+    if (this->body_.length() <= this->off_)\n+      return -1;\n+    return static_cast<unsigned char>(this->body_[this->off_]);\n+  }\n+\n+  // Return the next character and advance.\n+  int\n+  get_char()\n+  {\n+    if (this->body_.length() <= this->off_)\n+      return -1;\n+    int c = static_cast<unsigned char>(this->body_[this->off_]);\n+    this->off_++;\n+    return c;\n+  }\n+\n+  // Return whether the C string matches the current body position.\n+  bool\n+  match_c_string(const char* str)\n+  {\n+    size_t len = strlen(str);\n+    return (this->body_.length() >= this->off_ + len\n+\t    && this->body_.compare(this->off_, len, str) == 0);\n+  }\n+\n+  // Give an error if the next bytes do not match STR.  Advance the\n+  // offset by the length of STR.\n+  void\n+  require_c_string(const char* str);\n+\n+  // Read an identifier.\n+  std::string\n+  read_identifier();\n+\n+  // Read a type.\n+  Type*\n+  read_type();\n+\n+  // Implement Import_expression.\n+  Import_function_body*\n+  ifb()\n+  { return this; }\n+\n  private:\n   // The IR.\n   Gogo* gogo_;\n-  // The location to report in an error message.\n-  Location loc_;\n+  // The importer.\n+  Import* imp_;\n   // The function we are parsing.\n   Named_object* named_object_;\n   // The exported data we are parsing.  Note that this is a reference;\n@@ -533,6 +659,9 @@ class Import_function_body\n   Block* block_;\n   // Current expected indentation level.\n   int indent_;\n+  // Whether we've seen an error.  Used to avoid reporting excess\n+  // errors.\n+  bool saw_error_;\n };\n \n #endif // !defined(GO_IMPORT_H)"}]}