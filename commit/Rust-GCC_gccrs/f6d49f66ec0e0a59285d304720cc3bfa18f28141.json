{"sha": "f6d49f66ec0e0a59285d304720cc3bfa18f28141", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZkNDlmNjZlYzBlMGE1OTI4NWQzMDQ3MjBjYzNiZmExOGYyODE0MQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2004-04-20T13:05:10Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-04-20T13:05:10Z"}, "message": "Authenticator.java, [...]: Fixed javadocs, coding style and argument names all over.\n\n2004-04-20  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/Authenticator.java,\n\tjava/net/BindException.java,\n\tjava/net/ConnectException.java,\n\tjava/net/ContentHandler.java,\n\tjava/net/ContentHandlerFactory.java,\n\tjava/net/DatagramPacket.java,\n\tjava/net/DatagramSocket.java,\n\tjava/net/DatagramSocketImpl.java,\n\tjava/net/DatagramSocketImplFactory.java,\n\tjava/net/FileNameMap.java,\n\tjava/net/HttpURLConnection.java,\n\tjava/net/Inet4Address.java,\n\tjava/net/Inet6Address.java,\n\tjava/net/InetAddress.java,\n\tjava/net/InetSocketAddress.java,\n\tjava/net/JarURLConnection.java,\n\tjava/net/MalformedURLException.java,\n\tjava/net/MulticastSocket.java,\n\tjava/net/NetPermission.java,\n\tjava/net/NetworkInterface.java,\n\tjava/net/NoRouteToHostException.java,\n\tjava/net/PasswordAuthentication.java,\n\tjava/net/PortUnreachableException.java,\n\tjava/net/ProtocolException.java,\n\tjava/net/ServerSocket.java,\n\tjava/net/Socket.java,\n\tjava/net/SocketAddress.java,\n\tjava/net/SocketException.java,\n\tjava/net/SocketImpl.java,\n\tjava/net/SocketImplFactory.java,\n\tjava/net/SocketOptions.java,\n\tjava/net/SocketPermission.java,\n\tjava/net/SocketTimeoutException.java,\n\tjava/net/URI.java,\n\tjava/net/URISyntaxException.java,\n\tjava/net/URL.java,\n\tjava/net/URLClassLoader.java,\n\tjava/net/URLConnection.java,\n\tjava/net/URLDecoder.java,\n\tjava/net/URLEncoder.java,\n\tjava/net/URLStreamHandler.java,\n\tjava/net/URLStreamHandlerFactory.java,\n\tjava/net/UnknownHostException.java,\n\tjava/net/UnknownServiceException.java:\n\tFixed javadocs, coding style and argument names all over.\n\nFrom-SVN: r80900", "tree": {"sha": "61e0c356000f77339048c144863ae045f79523eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/61e0c356000f77339048c144863ae045f79523eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6d49f66ec0e0a59285d304720cc3bfa18f28141", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6d49f66ec0e0a59285d304720cc3bfa18f28141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6d49f66ec0e0a59285d304720cc3bfa18f28141", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6d49f66ec0e0a59285d304720cc3bfa18f28141/comments", "author": null, "committer": null, "parents": [{"sha": "cf6f7d55897e0c6b1badbcfc241e512a4bb154b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf6f7d55897e0c6b1badbcfc241e512a4bb154b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf6f7d55897e0c6b1badbcfc241e512a4bb154b8"}], "stats": {"total": 3888, "additions": 1981, "deletions": 1907}, "files": [{"sha": "b64d0c119c6546ea6484b880cf471538aa5c4f24", "filename": "libjava/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -1,3 +1,51 @@\n+2004-04-20  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/Authenticator.java,\n+\tjava/net/BindException.java,\n+\tjava/net/ConnectException.java,\n+\tjava/net/ContentHandler.java,\n+\tjava/net/ContentHandlerFactory.java,\n+\tjava/net/DatagramPacket.java,\n+\tjava/net/DatagramSocket.java,\n+\tjava/net/DatagramSocketImpl.java,\n+\tjava/net/DatagramSocketImplFactory.java,\n+\tjava/net/FileNameMap.java,\n+\tjava/net/HttpURLConnection.java,\n+\tjava/net/Inet4Address.java,\n+\tjava/net/Inet6Address.java,\n+\tjava/net/InetAddress.java,\n+\tjava/net/InetSocketAddress.java,\n+\tjava/net/JarURLConnection.java,\n+\tjava/net/MalformedURLException.java,\n+\tjava/net/MulticastSocket.java,\n+\tjava/net/NetPermission.java,\n+\tjava/net/NetworkInterface.java,\n+\tjava/net/NoRouteToHostException.java,\n+\tjava/net/PasswordAuthentication.java,\n+\tjava/net/PortUnreachableException.java,\n+\tjava/net/ProtocolException.java,\n+\tjava/net/ServerSocket.java,\n+\tjava/net/Socket.java,\n+\tjava/net/SocketAddress.java,\n+\tjava/net/SocketException.java,\n+\tjava/net/SocketImpl.java,\n+\tjava/net/SocketImplFactory.java,\n+\tjava/net/SocketOptions.java,\n+\tjava/net/SocketPermission.java,\n+\tjava/net/SocketTimeoutException.java,\n+\tjava/net/URI.java,\n+\tjava/net/URISyntaxException.java,\n+\tjava/net/URL.java,\n+\tjava/net/URLClassLoader.java,\n+\tjava/net/URLConnection.java,\n+\tjava/net/URLDecoder.java,\n+\tjava/net/URLEncoder.java,\n+\tjava/net/URLStreamHandler.java,\n+\tjava/net/URLStreamHandlerFactory.java,\n+\tjava/net/UnknownHostException.java,\n+\tjava/net/UnknownServiceException.java:\n+\tFixed javadocs, coding style and argument names all over.\n+\n 2004-04-20  Michael Koch  <konqueror@gmx.de>\n \n \t* java/lang/Byte.java,"}, {"sha": "8a951cb2dfd3c9cb993d19d6de4dcc0382b3ff7a", "filename": "libjava/java/net/Authenticator.java", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FAuthenticator.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FAuthenticator.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FAuthenticator.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -37,18 +37,19 @@\n \n package java.net;\n \n+\n /**\n   * This abstract class provides a model for obtaining authentication\n   * information (in the form of a username and password) required by\n   * some network operations (such as hitting a password protected\n   * web site).\n   * <p>\n-  * To make use of this feature, a programmer must create a subclass \n+  * To make use of this feature, a programmer must create a subclass\n   * that knows how to obtain the necessary info.  An example\n-  * would be a class that popped up a dialog box to prompt the user.  \n-  * After creating an instance of that subclass, the static \n-  * <code>setDefault</code> method of this class is called to set up \n-  * that instance as the object to use on subsequent calls to obtain \n+  * would be a class that popped up a dialog box to prompt the user.\n+  * After creating an instance of that subclass, the static\n+  * <code>setDefault</code> method of this class is called to set up\n+  * that instance as the object to use on subsequent calls to obtain\n   * authorization.\n   *\n   * @since 1.2\n@@ -106,57 +107,59 @@\n    */\n \n   /**\n-    * This method sets the default <code>Authenticator</code> object (an \n-    * instance of a subclass of <code>Authenticator</code>) to use when \n+    * This method sets the default <code>Authenticator</code> object (an\n+    * instance of a subclass of <code>Authenticator</code>) to use when\n     * prompting the user for\n     * information.  Note that this method checks to see if the caller is\n     * allowed to set this value (the \"setDefaultAuthenticator\" permission)\n     * and throws a <code>SecurityException</code> if it is not.\n     *\n     * @param defAuth The new default <code>Authenticator</code> object to use\n     *\n-    * @exception SecurityException If the caller does not have permission \n+    * @exception SecurityException If the caller does not have permission\n     * to perform this operation\n-    */ \n+    */\n   public static void setDefault(Authenticator defAuth)\n   {\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       sm.checkPermission(new NetPermission(\"setDefaultAuthenticator\"));\n \n     defaultAuthenticator = defAuth;\n-  } \n+  }\n \n   /**\n     * This method is called whenever a username and password for a given\n     * network operation is required.  First, a security check is made to see\n     * if the caller has the \"requestPasswordAuthentication\"\n     * permission.  If not, the method thows an exception.  If there is no\n-    * default <code>Authenticator</code> object, the method then returns \n-    * <code>null</code>.  Otherwise, the default authenticators's instance \n+    * default <code>Authenticator</code> object, the method then returns\n+    * <code>null</code>.  Otherwise, the default authenticators's instance\n     * variables are initialized and it's <code>getPasswordAuthentication</code>\n     * method is called to get the actual authentication information to return.\n     *\n     * @param addr The address requesting authentication\n     * @param port The port requesting authentication\n     * @param protocol The protocol requesting authentication\n-    * @param prompt The prompt to display to the user when requesting \n+    * @param prompt The prompt to display to the user when requesting\n     *        authentication info\n     * @param scheme The authentication scheme in use\n-    * \n-    * @return A <code>PasswordAuthentication</code> object with the user's \n+    *\n+    * @return A <code>PasswordAuthentication</code> object with the user's\n     *         authentication info.\n     *\n-    * @exception SecurityException If the caller does not have permission to \n+    * @exception SecurityException If the caller does not have permission to\n     *         perform this operation\n-    */ \n-  public static PasswordAuthentication \n-    requestPasswordAuthentication(InetAddress addr, int port, String protocol,\n-      String prompt, String scheme) \n+    */\n+  public static PasswordAuthentication requestPasswordAuthentication(InetAddress addr,\n+                                                                     int port,\n+                                                                     String protocol,\n+                                                                     String prompt,\n+                                                                     String scheme)\n     throws SecurityException\n   {\n-    return(requestPasswordAuthentication (null, addr, port, protocol,\n-  \t\t\t\t\tprompt, scheme));\n+    return requestPasswordAuthentication(null, addr, port, protocol, prompt,\n+                                         scheme);\n   }\n \n   /**\n@@ -175,29 +178,32 @@ public static void setDefault(Authenticator defAuth)\n     * @param addr The address requesting authentication\n     * @param port The port requesting authentication\n     * @param protocol The protocol requesting authentication\n-    * @param prompt The prompt to display to the user when requesting \n+    * @param prompt The prompt to display to the user when requesting\n     *        authentication info\n     * @param scheme The authentication scheme in use\n     *\n-    * @return A <code>PasswordAuthentication</code> object with the user's \n+    * @return A <code>PasswordAuthentication</code> object with the user's\n     *         authentication info.\n     *\n-    * @exception SecurityException If the caller does not have permission to \n+    * @exception SecurityException If the caller does not have permission to\n     *         perform this operation\n     *\n     * @since 1.4\n     */\n-  public static PasswordAuthentication\n-    requestPasswordAuthentication(String host, InetAddress addr, int port,\n-        String protocol, String prompt, String scheme)\n+  public static PasswordAuthentication requestPasswordAuthentication(String host,\n+                                                                     InetAddress addr,\n+                                                                     int port,\n+                                                                     String protocol,\n+                                                                     String prompt,\n+                                                                     String scheme)\n     throws SecurityException\n   {\n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       sm.checkPermission(new NetPermission(\"requestPasswordAuthentication\"));\n \n     if (defaultAuthenticator == null)\n-      return(null);\n+      return null;\n \n     defaultAuthenticator.host = host;\n     defaultAuthenticator.addr = addr;\n@@ -206,7 +212,7 @@ public static void setDefault(Authenticator defAuth)\n     defaultAuthenticator.prompt = prompt;\n     defaultAuthenticator.scheme = scheme;\n \n-    return(defaultAuthenticator.getPasswordAuthentication());\n+    return defaultAuthenticator.getPasswordAuthentication();\n   }\n \n   /*\n@@ -232,32 +238,32 @@ public Authenticator()\n     */\n   protected final InetAddress getRequestingSite()\n   {\n-    return(addr);\n+    return addr;\n   }\n \n   /**\n    * Returns the hostname of the host or proxy requesting authorization,\n    * or <code>null</code> if not available.\n    *\n    * @return The name of the host requesting authentication, or\n-   * </code>null</code> if it is not available.\n+   * <code>null</code> if it is not available.\n    *\n    * @since 1.4\n    */\n   protected final String getRequestingHost()\n   {\n-    return(host);\n+    return host;\n   }\n \n   /**\n-    * This method returns the port of the site that is requesting \n+    * This method returns the port of the site that is requesting\n     * authentication.\n     *\n     * @return The requesting port\n     */\n   protected final int getRequestingPort()\n   {\n-    return(port);\n+    return port;\n   }\n \n   /**\n@@ -268,18 +274,18 @@ protected final int getRequestingPort()\n     */\n   protected final String getRequestingProtocol()\n   {\n-    return(protocol);\n+    return protocol;\n   }\n \n   /**\n-    * Returns the prompt that should be used when requesting authentication \n+    * Returns the prompt that should be used when requesting authentication\n     * information from the user\n-    * \n+    *\n     * @return The user prompt\n     */\n   protected final String getRequestingPrompt()\n   {\n-    return(prompt);\n+    return prompt;\n   }\n \n   /**\n@@ -289,7 +295,7 @@ protected final String getRequestingPrompt()\n     */\n   protected final String getRequestingScheme()\n   {\n-    return(scheme);\n+    return scheme;\n   }\n \n   /**\n@@ -302,8 +308,6 @@ protected final String getRequestingScheme()\n     */\n   protected PasswordAuthentication getPasswordAuthentication()\n   {\n-    return(null);\n+    return null;\n   }\n-\n } // class Authenticator\n-"}, {"sha": "00885e8f21c7015c3138c3690a15c01037e1ddd0", "filename": "libjava/java/net/BindException.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FBindException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FBindException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FBindException.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -37,6 +37,7 @@\n \n package java.net;\n \n+\n /**\n  * This exception indicates that an error occurred while attempting to bind\n  * socket to a particular port."}, {"sha": "2dd35e72d0fb68b437db203d68c37bbd4552eab9", "filename": "libjava/java/net/ConnectException.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FConnectException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FConnectException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FConnectException.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -35,9 +35,9 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n+\n /**\n  * This exception indicates that an error occurred while attempting to\n  * connect to a remote host.  Often this indicates that the remote host"}, {"sha": "5e3de23d4dcddbccf229874e171185251df22758", "filename": "libjava/java/net/ContentHandler.java", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FContentHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FContentHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FContentHandler.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -47,11 +47,11 @@\n \n /**\n   * This is an abstract class that is the superclass for classes that read\n-  * objects from URL's.  Calling the <code>getContent()</code> method in the \n-  * <code>URL</code> class or the <code>URLConnection</code> class will cause \n-  * an instance of a subclass of <code>ContentHandler</code> to be created for \n-  * the MIME type of the object being downloaded from the URL.  Thus, this \n-  * class is seldom needed by applications/applets directly, but only \n+  * objects from URL's.  Calling the <code>getContent()</code> method in the\n+  * <code>URL</code> class or the <code>URLConnection</code> class will cause\n+  * an instance of a subclass of <code>ContentHandler</code> to be created for\n+  * the MIME type of the object being downloaded from the URL.  Thus, this\n+  * class is seldom needed by applications/applets directly, but only\n   * indirectly through methods in other classes.\n   *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n@@ -66,19 +66,19 @@\n   /**\n     * Default, no-argument constructor.\n     */\n-  public ContentHandler() \n-  { \n+  public ContentHandler()\n+  {\n   }\n \n   /*\n    * Instance Methods\n    */\n \n   /**\n-    * This method reads from the <code>InputStream</code> of the passed in URL \n-    * connection and uses the data downloaded to create an <code>Object</code> \n-    * represening the content.  For example, if the URL is pointing to a GIF \n-    * file, this method might return an <code>Image</code> object.  This method \n+    * This method reads from the <code>InputStream</code> of the passed in URL\n+    * connection and uses the data downloaded to create an <code>Object</code>\n+    * represening the content.  For example, if the URL is pointing to a GIF\n+    * file, this method might return an <code>Image</code> object.  This method\n     * must be implemented by subclasses.\n     *\n     * @param urlc A <code>URLConnection</code> object to read data from.\n@@ -87,16 +87,16 @@ public ContentHandler()\n     *\n     * @exception IOException If an error occurs\n     */\n-  public abstract Object getContent(URLConnection urlc) \n+  public abstract Object getContent(URLConnection urlc)\n     throws IOException;\n \n   /**\n     * This method reads from the <code>InputStream</code> of the passed in URL\n     * connection and uses the data downloaded to create an <code>Object</code>\n-    * represening the content.  For example, if the URL is pointing to a GIF \n-    * file, this method might return an <code>Image</code> object.  This method \n+    * represening the content.  For example, if the URL is pointing to a GIF\n+    * file, this method might return an <code>Image</code> object.  This method\n     * must be implemented by subclasses.  This method uses the list of\n-    * supplied classes as candidate types.  If the data read doesn't match \n+    * supplied classes as candidate types.  If the data read doesn't match\n     * any of the supplied type, <code>null</code> is returned.\n     *\n     * @param urlc A <code>URLConnection</code> object to read data from.\n@@ -113,15 +113,14 @@ public abstract Object getContent(URLConnection urlc)\n   public Object getContent(URLConnection urlc, Class[] classes)\n     throws IOException\n   {\n-    Object obj = getContent (urlc);\n+    Object obj = getContent(urlc);\n \n     for (int i = 0; i < classes.length; i++)\n       {\n-        if (classes [i].isInstance (obj))\n-          return obj;\n+\tif (classes[i].isInstance(obj))\n+\t  return obj;\n       }\n \n     return null;\n   }\n-\n } // class ContentHandler"}, {"sha": "cdfbca285d3c365a7551c81b91a9d97713ebb18c", "filename": "libjava/java/net/ContentHandlerFactory.java", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FContentHandlerFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FContentHandlerFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FContentHandlerFactory.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,18 +35,17 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n+\n /**\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n  */\n-\n /**\n-  * This interface maps MIME types to <code>ContentHandler</code> objects.  \n-  * It consists of one method that, when passed a MIME type, returns a \n+  * This interface maps MIME types to <code>ContentHandler</code> objects.\n+  * It consists of one method that, when passed a MIME type, returns a\n   * handler for that type.\n   *\n   * @author Aaron M. Renn (arenn@urbanophile.com)\n@@ -63,6 +62,4 @@\n     * @return The <code>ContentHandler</code> for the passed in MIME type\n     */\n   ContentHandler createContentHandler(String mimeType);\n-\n } // interface ContentHandlerFactory\n-"}, {"sha": "8ff64435c2bb9f9edb0abe3bb229f2b484dc097c", "filename": "libjava/java/net/DatagramPacket.java", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FDatagramPacket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FDatagramPacket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramPacket.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -37,6 +37,7 @@\n \n package java.net;\n \n+\n /*\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n@@ -86,7 +87,7 @@\n    * The maximal length of the buffer.\n    */\n   int maxlen;\n-  \n+\n   /**\n    * The address to which the packet should be sent or from which it\n    * was received.\n@@ -134,14 +135,14 @@ public DatagramPacket(byte[] buf, int length)\n    *\n    * @param buf A buffer containing the data to send\n    * @param offset The offset into the buffer to start writing from.\n-   * @param len The length of the buffer (must be &lt;= buf.length)\n-   * @param addr The address to send to\n+   * @param length The length of the buffer (must be &lt;= buf.length)\n+   * @param address The address to send to\n    * @param port The port to send to\n    *\n    * @since 1.2\n    */\n   public DatagramPacket(byte[] buf, int offset, int length,\n-\tInetAddress address, int port)\n+                        InetAddress address, int port)\n   {\n     setData(buf, offset, length);\n     setAddress(address);\n@@ -177,8 +178,7 @@ public DatagramPacket(byte[] buf, int length, InetAddress address, int port)\n    * @since 1.4\n    */\n   public DatagramPacket(byte[] buf, int offset, int length,\n-\t\t        SocketAddress address)\n-     throws SocketException\n+                        SocketAddress address) throws SocketException\n   {\n     if (! (address instanceof InetSocketAddress))\n       throw new IllegalArgumentException(\"unsupported address type\");\n@@ -272,16 +272,16 @@ public synchronized int getLength()\n   /**\n    * This sets the address to which the data packet will be transmitted.\n    *\n-   * @param addr The destination address\n+   * @param address The destination address\n    *\n    * @since 1.1\n    */\n-  public synchronized void setAddress(InetAddress iaddr)\n+  public synchronized void setAddress(InetAddress address)\n   {\n-    if (iaddr == null)\n+    if (address == null)\n       throw new NullPointerException(\"Null address\");\n \n-    address = iaddr;\n+    this.address = address;\n   }\n \n   /**\n@@ -291,12 +291,12 @@ public synchronized void setAddress(InetAddress iaddr)\n    *\n    * @since 1.1\n    */\n-  public synchronized void setPort(int iport)\n+  public synchronized void setPort(int port)\n   {\n-    if (iport < 0 || iport > 65535)\n-      throw new IllegalArgumentException(\"Invalid port: \" + iport);\n+    if (port < 0 || port > 65535)\n+      throw new IllegalArgumentException(\"Invalid port: \" + port);\n \n-    port = iport;\n+    this.port = port;\n   }\n \n   /**\n@@ -324,12 +324,12 @@ public void setSocketAddress(SocketAddress address)\n    * will be sent to/is coming from\n    *\n    * @return The socket address of the remote host\n-   * \n+   *\n    * @since 1.4\n    */\n   public SocketAddress getSocketAddress()\n   {\n-    return new InetSocketAddress (address, port);\n+    return new InetSocketAddress(address, port);\n   }\n \n   /**\n@@ -360,7 +360,6 @@ public void setData(byte[] buf)\n   public synchronized void setData(byte[] buf, int offset, int length)\n   {\n     // This form of setData must be used if offset is to be changed.\n-\n     if (buf == null)\n       throw new NullPointerException(\"Null buffer\");\n     if (offset < 0)\n@@ -372,7 +371,7 @@ public synchronized void setData(byte[] buf, int offset, int length)\n   }\n \n   /**\n-   * Sets the length of the data in the buffer. \n+   * Sets the length of the data in the buffer.\n    *\n    * @param length The new length.  (Where len &lt;= buf.length)\n    *\n@@ -387,7 +386,7 @@ public synchronized void setLength(int length)\n       throw new IllegalArgumentException(\"Invalid length: \" + length);\n     if (offset + length > buffer.length)\n       throw new IllegalArgumentException(\"Potential buffer overflow - offset: \"\n-\t\t\t+ offset + \" length: \" + length);\n+                                         + offset + \" length: \" + length);\n \n     this.length = length;\n     this.maxlen = length;"}, {"sha": "2808d82428b5876792cb58f3e8f4cb68f03b24d0", "filename": "libjava/java/net/DatagramSocket.java", "status": "modified", "additions": 130, "deletions": 136, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,7 +35,6 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n import gnu.java.net.PlainDatagramSocketImpl;\n@@ -44,32 +43,31 @@\n import java.nio.channels.DatagramChannel;\n import java.nio.channels.IllegalBlockingModeException;\n \n+\n /**\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n  */\n-\n /**\n- * This class models a connectionless datagram socket that sends \n+ * This class models a connectionless datagram socket that sends\n  * individual packets of data across the network.  In the TCP/IP world,\n  * this means UDP.  Datagram packets do not have guaranteed delivery,\n  * or any guarantee about the order the data will be received on the\n  * remote host.\n- * \n+ *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Warren Levy (warrenl@cygnus.com)\n  * @date May 3, 1999.\n  */\n-\n public class DatagramSocket\n {\n   /**\n    * This is the user DatagramSocketImplFactory for this class.  If this\n    * variable is null, a default factory is used.\n    */\n   private static DatagramSocketImplFactory factory;\n-\t  \n+\n   /**\n    * This is the implementation object used by this socket.\n    */\n@@ -96,15 +94,15 @@\n   private boolean bound;\n \n   /**\n-   * Creates a <code>DatagramSocket</code> from a specified \n+   * Creates a <code>DatagramSocket</code> from a specified\n    * <code>DatagramSocketImpl</code> instance\n    *\n-   * @param impl The <code>DatagramSocketImpl</code> the socket will be \n+   * @param impl The <code>DatagramSocketImpl</code> the socket will be\n    * created from\n-   * \n+   *\n    * @since 1.4\n    */\n-  protected DatagramSocket (DatagramSocketImpl impl)\n+  protected DatagramSocket(DatagramSocketImpl impl)\n   {\n     if (impl == null)\n       throw new NullPointerException(\"impl may not be null\");\n@@ -115,7 +113,7 @@ protected DatagramSocket (DatagramSocketImpl impl)\n   }\n \n   /**\n-   * Initializes a new instance of <code>DatagramSocket</code> that binds to \n+   * Initializes a new instance of <code>DatagramSocket</code> that binds to\n    * a random port and every address on the local machine.\n    *\n    * @exception SocketException If an error occurs.\n@@ -128,7 +126,7 @@ public DatagramSocket() throws SocketException\n   }\n \n   /**\n-   * Initializes a new instance of <code>DatagramSocket</code> that binds to \n+   * Initializes a new instance of <code>DatagramSocket</code> that binds to\n    * the specified port and every address on the local machine.\n    *\n    * @param port The local port number to bind to.\n@@ -143,7 +141,7 @@ public DatagramSocket(int port) throws SocketException\n   }\n \n   /**\n-   * Initializes a new instance of <code>DatagramSocket</code> that binds to \n+   * Initializes a new instance of <code>DatagramSocket</code> that binds to\n    * the specified local port and address.\n    *\n    * @param port The local port number to bind to.\n@@ -159,7 +157,7 @@ public DatagramSocket(int port, InetAddress addr) throws SocketException\n   }\n \n   /**\n-   * Initializes a new instance of <code>DatagramSocket</code> that binds to \n+   * Initializes a new instance of <code>DatagramSocket</code> that binds to\n    * the specified local port and address.\n    *\n    * @param address The local address and port number to bind to.\n@@ -170,35 +168,36 @@ public DatagramSocket(int port, InetAddress addr) throws SocketException\n    *\n    * @since 1.4\n    */\n-  public DatagramSocket (SocketAddress address) throws SocketException\n+  public DatagramSocket(SocketAddress address) throws SocketException\n   {\n     String propVal = System.getProperty(\"impl.prefix\");\n     if (propVal == null || propVal.equals(\"\"))\n       impl = new PlainDatagramSocketImpl();\n     else\n       try\n-\t{\n-          impl = (DatagramSocketImpl) Class.forName\n-            (\"java.net.\" + propVal + \"DatagramSocketImpl\").newInstance();\n-\t}\n+        {\n+\t  impl =\n+\t    (DatagramSocketImpl) Class.forName(\"java.net.\" + propVal\n+\t                                       + \"DatagramSocketImpl\")\n+\t                              .newInstance();\n+        }\n       catch (Exception e)\n-\t{\n-\t  System.err.println(\"Could not instantiate class: java.net.\" +\n-\t    propVal + \"DatagramSocketImpl\");\n+        {\n+\t  System.err.println(\"Could not instantiate class: java.net.\"\n+\t                     + propVal + \"DatagramSocketImpl\");\n \t  impl = new PlainDatagramSocketImpl();\n-\t}\n+        }\n \n     if (address != null)\n       bind(address);\n   }\n-  \n+\n   // This needs to be accessible from java.net.MulticastSocket\n-  DatagramSocketImpl getImpl()\n-    throws SocketException\n+  DatagramSocketImpl getImpl() throws SocketException\n   {\n     try\n       {\n-\tif (!implCreated)\n+\tif (! implCreated)\n \t  {\n \t    impl.create();\n \t    implCreated = true;\n@@ -211,15 +210,15 @@ DatagramSocketImpl getImpl()\n \tthrow new SocketException(e.getMessage());\n       }\n   }\n-  \n+\n   /**\n    * Closes this datagram socket.\n    */\n   public void close()\n   {\n     if (isClosed())\n       return;\n-    \n+\n     try\n       {\n \tgetImpl().close();\n@@ -247,10 +246,10 @@ public void close()\n   }\n \n   /**\n-   * This method returns the remote address to which this socket is \n+   * This method returns the remote address to which this socket is\n    * connected.  If this socket is not connected, then this method will\n    * return <code>null</code>.\n-   * \n+   *\n    * @return The remote address.\n    *\n    * @since 1.2\n@@ -264,7 +263,7 @@ public InetAddress getInetAddress()\n    * This method returns the remote port to which this socket is\n    * connected.  If this socket is not connected, then this method will\n    * return -1.\n-   * \n+   *\n    * @return The remote port.\n    *\n    * @since 1.2\n@@ -276,7 +275,7 @@ public int getPort()\n \n   /**\n    * Returns the local address this datagram socket is bound to.\n-   * \n+   *\n    * @return The local address is the socket is bound or null\n    *\n    * @since 1.1\n@@ -285,16 +284,17 @@ public InetAddress getLocalAddress()\n   {\n     if (isClosed())\n       return null;\n-    \n+\n     InetAddress localAddr;\n-    \n+\n     try\n       {\n-\tlocalAddr = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);\n+\tlocalAddr =\n+\t  (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);\n \n \tSecurityManager s = System.getSecurityManager();\n \tif (s != null)\n-\t  s.checkConnect (localAddr.getHostName(), -1);\n+\t  s.checkConnect(localAddr.getHostName(), -1);\n       }\n     catch (SecurityException e)\n       {\n@@ -303,7 +303,7 @@ public InetAddress getLocalAddress()\n     catch (SocketException e)\n       {\n \t// This cannot happen as we are bound.\n-        return null;\n+\treturn null;\n       }\n \n     return localAddr;\n@@ -318,7 +318,7 @@ public int getLocalPort()\n   {\n     if (isClosed())\n       return -1;\n-\t      \n+\n     try\n       {\n \treturn getImpl().getLocalPort();\n@@ -337,7 +337,7 @@ public int getLocalPort()\n    * @return The current timeout in milliseconds.\n    *\n    * @exception SocketException If an error occurs.\n-   * \n+   *\n    * @since 1.1\n    */\n   public synchronized int getSoTimeout() throws SocketException\n@@ -347,7 +347,7 @@ public synchronized int getSoTimeout() throws SocketException\n \n     Object buf = getImpl().getOption(SocketOptions.SO_TIMEOUT);\n \n-    if (buf instanceof Integer) \n+    if (buf instanceof Integer)\n       return ((Integer) buf).intValue();\n \n     throw new SocketException(\"unexpected type\");\n@@ -368,7 +368,7 @@ public synchronized void setSoTimeout(int timeout) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     if (timeout < 0)\n       throw new IllegalArgumentException(\"Invalid timeout: \" + timeout);\n \n@@ -390,7 +390,7 @@ public int getSendBufferSize() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     Object buf = getImpl().getOption(SocketOptions.SO_SNDBUF);\n \n     if (buf instanceof Integer)\n@@ -415,10 +415,10 @@ public void setSendBufferSize(int size) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     if (size < 0)\n       throw new IllegalArgumentException(\"Buffer size is less than 0\");\n-  \n+\n     getImpl().setOption(SocketOptions.SO_SNDBUF, new Integer(size));\n   }\n \n@@ -439,7 +439,7 @@ public int getReceiveBufferSize() throws SocketException\n       throw new SocketException(\"socket is closed\");\n \n     Object buf = getImpl().getOption(SocketOptions.SO_RCVBUF);\n-  \n+\n     if (buf instanceof Integer)\n       return ((Integer) buf).intValue();\n \n@@ -455,7 +455,7 @@ public int getReceiveBufferSize() throws SocketException\n    *\n    * @exception SocketException If an error occurs.\n    * @exception IllegalArgumentException If size is 0 or negative.\n-   * \n+   *\n    * @since 1.2\n    */\n   public void setReceiveBufferSize(int size) throws SocketException\n@@ -474,7 +474,7 @@ public void setReceiveBufferSize(int size) throws SocketException\n    * When a datagram socket is connected, it will only send or receive\n    * packets to and from the host to which it is connected. A multicast\n    * socket that is connected may only send and not receive packets.\n-   * \n+   *\n    * @param address The address to connect this socket to.\n    * @param port The port to connect this socket to.\n    *\n@@ -488,37 +488,37 @@ public void setReceiveBufferSize(int size) throws SocketException\n   public void connect(InetAddress address, int port)\n   {\n     if (address == null)\n-      throw new IllegalArgumentException (\"Connect address may not be null\");\n+      throw new IllegalArgumentException(\"Connect address may not be null\");\n \n     if ((port < 1) || (port > 65535))\n-      throw new IllegalArgumentException (\"Port number is illegal: \" + port);\n+      throw new IllegalArgumentException(\"Port number is illegal: \" + port);\n \n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n       sm.checkConnect(address.getHostName(), port);\n \n     try\n       {\n-        getImpl().connect (address, port);\n-        remoteAddress = address;\n-        remotePort = port;\n+\tgetImpl().connect(address, port);\n+\tremoteAddress = address;\n+\tremotePort = port;\n       }\n     catch (SocketException e)\n       {\n-        // This means simply not connected or connect not implemented.\n+\t// This means simply not connected or connect not implemented.\n       }\n   }\n \n   /**\n    * This method disconnects this socket from the address/port it was\n    * connected to.  If the socket was not connected in the first place,\n    * this method does nothing.\n-   * \n+   *\n    * @since 1.2\n    */\n   public void disconnect()\n   {\n-    if (!isConnected())\n+    if (! isConnected())\n       return;\n \n     try\n@@ -559,22 +559,20 @@ public synchronized void receive(DatagramPacket p) throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n-    if (remoteAddress != null\n-        && remoteAddress.isMulticastAddress())\n+\n+    if (remoteAddress != null && remoteAddress.isMulticastAddress())\n       throw new IOException\n-        (\"Socket connected to a multicast address my not receive\");\n+\t(\"Socket connected to a multicast address my not receive\");\n \n-    if (getChannel() != null\n-        && !getChannel().isBlocking ()\n-        && !((DatagramChannelImpl) getChannel()).isInChannelOperation())\n-      throw new IllegalBlockingModeException ();\n+    if (getChannel() != null && ! getChannel().isBlocking()\n+        && ! ((DatagramChannelImpl) getChannel()).isInChannelOperation())\n+      throw new IllegalBlockingModeException();\n \n     getImpl().receive(p);\n \n     SecurityManager s = System.getSecurityManager();\n-    if (s != null && isConnected ())\n-      s.checkAccept (p.getAddress().getHostName (), p.getPort ());\n+    if (s != null && isConnected())\n+      s.checkAccept(p.getAddress().getHostName(), p.getPort());\n   }\n \n   /**\n@@ -596,33 +594,31 @@ public void send(DatagramPacket p) throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     // JDK1.2: Don't do security checks if socket is connected; see jdk1.2 api.\n     SecurityManager s = System.getSecurityManager();\n-    if (s != null && !isConnected ())\n+    if (s != null && ! isConnected())\n       {\n-        InetAddress addr = p.getAddress();\n-        if (addr.isMulticastAddress())\n-          s.checkMulticast(addr);\n-        else\n-          s.checkConnect(addr.getHostAddress(), p.getPort());\n+\tInetAddress addr = p.getAddress();\n+\tif (addr.isMulticastAddress())\n+\t  s.checkMulticast(addr);\n+\telse\n+\t  s.checkConnect(addr.getHostAddress(), p.getPort());\n       }\n \n-    if (isConnected ())\n+    if (isConnected())\n       {\n-        if (p.getAddress () != null && (remoteAddress != p.getAddress () ||\n-                                        remotePort != p.getPort ()))\n-          throw new IllegalArgumentException (\n-            \"DatagramPacket address does not match remote address\" );\n+\tif (p.getAddress() != null\n+\t    && (remoteAddress != p.getAddress() || remotePort != p.getPort()))\n+\t  throw new IllegalArgumentException\n+\t    (\"DatagramPacket address does not match remote address\");\n       }\n-\t    \n+\n     // FIXME: if this is a subclass of MulticastSocket,\n     // use getTimeToLive for TTL val.\n-\n-    if (getChannel() != null\n-        && !getChannel().isBlocking ()\n-        && !((DatagramChannelImpl) getChannel()).isInChannelOperation())\n-      throw new IllegalBlockingModeException ();\n+    if (getChannel() != null && ! getChannel().isBlocking()\n+        && ! ((DatagramChannelImpl) getChannel()).isInChannelOperation())\n+      throw new IllegalBlockingModeException();\n \n     getImpl().send(p);\n   }\n@@ -639,12 +635,11 @@ public void send(DatagramPacket p) throws IOException\n    *\n    * @since 1.4\n    */\n-  public void bind (SocketAddress address)\n-    throws SocketException\n+  public void bind(SocketAddress address) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     if (! (address instanceof InetSocketAddress))\n       throw new IllegalArgumentException(\"unsupported address type\");\n \n@@ -654,40 +649,40 @@ public void bind (SocketAddress address)\n     if (port < 0 || port > 65535)\n       throw new IllegalArgumentException(\"Invalid port: \" + port);\n \n-    SecurityManager s = System.getSecurityManager ();\n+    SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       s.checkListen(port);\n \n     if (addr == null)\n       addr = InetAddress.ANY_IF;\n-    \n+\n     try\n       {\n-        getImpl().bind(port, addr);\n+\tgetImpl().bind(port, addr);\n \tbound = true;\n       }\n     catch (SocketException exception)\n       {\n-        getImpl().close();\n-        throw exception;\n+\tgetImpl().close();\n+\tthrow exception;\n       }\n     catch (RuntimeException exception)\n       {\n-        getImpl().close();\n-        throw exception;\n+\tgetImpl().close();\n+\tthrow exception;\n       }\n     catch (Error error)\n       {\n-        getImpl().close();\n-        throw error;\n+\tgetImpl().close();\n+\tthrow error;\n       }\n   }\n \n   /**\n    * Checks if the datagram socket is closed.\n    *\n    * @return True if socket is closed, false otherwise.\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean isClosed()\n@@ -697,9 +692,9 @@ public boolean isClosed()\n \n   /**\n    * Returns the datagram channel assoziated with this datagram socket.\n-   * \n+   *\n    * @return The associated <code>DatagramChannel</code> object or null\n-   * \n+   *\n    * @since 1.4\n    */\n   public DatagramChannel getChannel()\n@@ -717,23 +712,23 @@ public DatagramChannel getChannel()\n    *\n    * @since 1.4\n    */\n-  public void connect (SocketAddress address) throws SocketException\n+  public void connect(SocketAddress address) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n-    if ( !(address instanceof InetSocketAddress) )\n+\n+    if (! (address instanceof InetSocketAddress))\n       throw new IllegalArgumentException(\"unsupported address type\");\n \n     InetSocketAddress tmp = (InetSocketAddress) address;\n     connect(tmp.getAddress(), tmp.getPort());\n   }\n-  \n+\n   /**\n    * Returns the binding state of the socket.\n-   * \n+   *\n    * @return True if socket bound, false otherwise.\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean isBound()\n@@ -743,9 +738,9 @@ public boolean isBound()\n \n   /**\n    * Returns the connection state of the socket.\n-   * \n+   *\n    * @return True if socket is connected, false otherwise.\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean isConnected()\n@@ -756,32 +751,32 @@ public boolean isConnected()\n   /**\n    * Returns the SocketAddress of the host this socket is conneted to\n    * or null if this socket is not connected.\n-   * \n+   *\n    * @return The socket address of the remote host if connected or null\n-   * \n+   *\n    * @since 1.4\n    */\n   public SocketAddress getRemoteSocketAddress()\n   {\n-    if (!isConnected ())\n+    if (! isConnected())\n       return null;\n \n-    return new InetSocketAddress (remoteAddress, remotePort);\n+    return new InetSocketAddress(remoteAddress, remotePort);\n   }\n \n   /**\n    * Returns the local SocketAddress this socket is bound to.\n    *\n    * @return The local SocketAddress or null if the socket is not bound.\n-   * \n+   *\n    * @since 1.4\n    */\n   public SocketAddress getLocalSocketAddress()\n   {\n-    if (!isBound())\n+    if (! isBound())\n       return null;\n-    \n-    return new InetSocketAddress (getLocalAddress(), getLocalPort());\n+\n+    return new InetSocketAddress(getLocalAddress(), getLocalPort());\n   }\n \n   /**\n@@ -798,7 +793,7 @@ public void setReuseAddress(boolean on) throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    getImpl().setOption (SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));\n+    getImpl().setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));\n   }\n \n   /**\n@@ -807,16 +802,16 @@ public void setReuseAddress(boolean on) throws SocketException\n    * @return True if SO_REUSEADDR is set on the socket, false otherwise.\n    *\n    * @exception SocketException If an error occurs.\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean getReuseAddress() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    Object buf = getImpl().getOption (SocketOptions.SO_REUSEADDR);\n-  \n+    Object buf = getImpl().getOption(SocketOptions.SO_REUSEADDR);\n+\n     if (buf instanceof Boolean)\n       return ((Boolean) buf).booleanValue();\n \n@@ -825,7 +820,7 @@ public boolean getReuseAddress() throws SocketException\n \n   /**\n    * Enables/Disables SO_BROADCAST\n-   * \n+   *\n    * @param enable True if SO_BROADCAST should be enabled, false otherwise.\n    *\n    * @exception SocketException If an error occurs\n@@ -842,11 +837,11 @@ public void setBroadcast(boolean enable) throws SocketException\n \n   /**\n    * Checks if SO_BROADCAST is enabled\n-   * \n+   *\n    * @return Whether SO_BROADCAST is set\n    *\n    * @exception SocketException If an error occurs\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean getBroadcast() throws SocketException\n@@ -855,7 +850,7 @@ public boolean getBroadcast() throws SocketException\n       throw new SocketException(\"socket is closed\");\n \n     Object buf = getImpl().getOption(SocketOptions.SO_BROADCAST);\n-  \n+\n     if (buf instanceof Boolean)\n       return ((Boolean) buf).booleanValue();\n \n@@ -871,45 +866,44 @@ public boolean getBroadcast() throws SocketException\n    * @exception IllegalArgumentException If tc value is illegal\n    *\n    * @see DatagramSocket#getTrafficClass()\n-   * \n+   *\n    * @since 1.4\n    */\n-  public void setTrafficClass(int tc)\n-    throws SocketException\n+  public void setTrafficClass(int tc) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n     if (tc < 0 || tc > 255)\n       throw new IllegalArgumentException();\n \n-    getImpl().setOption (SocketOptions.IP_TOS, new Integer (tc));\n+    getImpl().setOption(SocketOptions.IP_TOS, new Integer(tc));\n   }\n-  \n+\n   /**\n    * Returns the current traffic class\n-   * \n+   *\n    * @return The current traffic class.\n    *\n    * @see DatagramSocket#setTrafficClass(int tc)\n    *\n    * @exception SocketException If an error occurs\n-   * \n+   *\n    * @since 1.4\n    */\n   public int getTrafficClass() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     Object buf = getImpl().getOption(SocketOptions.IP_TOS);\n \n     if (buf instanceof Integer)\n       return ((Integer) buf).intValue();\n \n     throw new SocketException(\"unexpected type\");\n   }\n-  \n+\n   /**\n    * Sets the datagram socket implementation factory for the application\n    *\n@@ -920,11 +914,11 @@ public int getTrafficClass() throws SocketException\n    * @exception SecurityException If a security manager exists and its\n    * checkSetFactory method doesn't allow the operation\n    */\n-  public static void setDatagramSocketImplFactory\n-    (DatagramSocketImplFactory fac) throws IOException\n+  public static void setDatagramSocketImplFactory(DatagramSocketImplFactory fac)\n+    throws IOException\n   {\n     if (factory != null)\n-      throw new SocketException (\"DatagramSocketImplFactory already defined\");\n+      throw new SocketException(\"DatagramSocketImplFactory already defined\");\n \n     SecurityManager sm = System.getSecurityManager();\n     if (sm != null)"}, {"sha": "0c21e2410d8936da3fca8b22a17e89a9a3109282", "filename": "libjava/java/net/DatagramSocketImpl.java", "status": "modified", "additions": 32, "deletions": 23, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocketImpl.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -1,5 +1,5 @@\n /* DatagramSocketImpl.java -- Abstract class for UDP socket implementations\n-   Copyright (C) 1998, 1999 2000, 2001, \n+   Copyright (C) 1998, 1999 2000, 2001,\n                  2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -36,11 +36,11 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n-import java.io.IOException;\n import java.io.FileDescriptor;\n+import java.io.IOException;\n+\n \n /**\n  * This abstract class models a datagram socket implementation.  An\n@@ -58,7 +58,6 @@\n  */\n public abstract class DatagramSocketImpl implements SocketOptions\n {\n-\n   /**\n    * The local port to which this socket is bound\n    */\n@@ -103,7 +102,7 @@ protected abstract void bind(int lport, InetAddress laddr)\n    * Takes a peek at the next packet received in order to retrieve the\n    * address of the sender\n    *\n-   * @param i The <code>InetAddress</code> to fill in with the information \n+   * @param i The <code>InetAddress</code> to fill in with the information\n    *          about the sender if the next packet\n    *\n    * @return The port number of the sender of the packet\n@@ -118,19 +117,19 @@ protected abstract void bind(int lport, InetAddress laddr)\n   /**\n    * Takes a peek at the next packet received.  This packet is not consumed.\n    * With the next peekData/receive operation this packet will be read again.\n-   * \n+   *\n    * @param p The <code>DatagramPacket</code> to fill in with the data sent.\n    *\n    * @return The port number of the sender of the packet.\n-   * \n+   *\n    * @exception IOException If an error occurs\n    * @exception PortUnreachableException May be thrown if the socket is\n    * connected to a currently unreachable destination. Note, there is no\n    * guarantee that the exception will be thrown.\n-   * \n+   *\n    * @since 1.4\n    */\n-  protected abstract int peekData (DatagramPacket p) throws IOException;\n+  protected abstract int peekData(DatagramPacket p) throws IOException;\n \n   /**\n    * Transmits the specified packet of data to the network.  The destination\n@@ -169,17 +168,18 @@ protected abstract void bind(int lport, InetAddress laddr)\n    *\n    * @since 1.4\n    */\n-  protected void connect (InetAddress address, int port) throws SocketException\n+  protected void connect(InetAddress address, int port)\n+    throws SocketException\n   {\n     // This method has to be overwritten by real implementations\n   }\n \n   /**\n    * Disconnects the socket.\n-   * \n+   *\n    * @since 1.4\n    */\n-  protected void disconnect ()\n+  protected void disconnect()\n   {\n     // This method has to be overwritten by real implementations\n   }\n@@ -199,8 +199,11 @@ protected void disconnect ()\n    * This method returns the current Time to Live (TTL) setting on this\n    * socket.  <b>Use <code>getTimeToLive()</code></b> instead.\n    *\n+   * @return the current time-to-live\n+   * \n    * @exception IOException If an error occurs\n-   * @deprecated\n+   * \n+   * @deprecated // FIXME: when ?\n    */\n   protected abstract byte getTTL() throws IOException;\n \n@@ -218,6 +221,8 @@ protected void disconnect ()\n    * This method returns the current Time to Live (TTL) setting on this\n    * socket.\n    *\n+   * @return the current time-to-live\n+   * \n    * @exception IOException If an error occurs\n    */\n   protected abstract int getTimeToLive() throws IOException;\n@@ -242,35 +247,37 @@ protected void disconnect ()\n \n   /**\n    * Causes this socket to join the specified multicast group on a specified\n-   * device \n-   * \n+   * device\n+   *\n    * @param mcastaddr The address to leave\n    * @param netIf The specified network interface to join the group at\n    *\n    * @exception IOException If an error occurs\n-   * \n+   *\n    * @since 1.4\n    */\n-  protected abstract void joinGroup (SocketAddress mcastaddr,\n-\t\t                     NetworkInterface netIf)\n+  protected abstract void joinGroup(SocketAddress mcastaddr,\n+                                    NetworkInterface netIf)\n     throws IOException;\n \n   /**\n    * Leaves a multicast group\n-   * \n+   *\n    * @param mcastaddr The address to join\n    * @param netIf The specified network interface to leave the group at\n    *\n    * @exception IOException If an error occurs\n-   * \n+   *\n    * @since 1.4\n    */\n-  protected abstract void leaveGroup (SocketAddress mcastaddr,\n-\t\t                      NetworkInterface netIf)\n+  protected abstract void leaveGroup(SocketAddress mcastaddr,\n+                                     NetworkInterface netIf)\n     throws IOException;\n-  \n+\n   /**\n    * Returns the FileDescriptor for this socket\n+   * \n+   * @return the file descriptor associated with this socket\n    */\n   protected FileDescriptor getFileDescriptor()\n   {\n@@ -279,6 +286,8 @@ protected FileDescriptor getFileDescriptor()\n \n   /**\n    * Returns the local port this socket is bound to\n+   *\n+   * @return the local port\n    */\n   protected int getLocalPort()\n   {"}, {"sha": "16a0a2ec1aa26cc1cf05efffa1c98b2a1278699f", "filename": "libjava/java/net/DatagramSocketImplFactory.java", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FDatagramSocketImplFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FDatagramSocketImplFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocketImplFactory.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -37,12 +37,12 @@\n \n package java.net;\n \n+\n /** Written using on-line Java Platform 1.4 API Specification.\n   * Status: Believed complete and correct.\n   */\n-\n /**\n-  * This interface defines one method which returns a \n+  * This interface defines one method which returns a\n   * <code>DatagramSocketImpl</code> object.\n   * This should not be needed by ordinary applications.\n   *\n@@ -57,5 +57,4 @@\n    * @return A DatagramSocketImpl object\n    */\n   DatagramSocketImpl createDatagramSocketImpl();\n-\n } // interface DatagramSocketImplFactory"}, {"sha": "fbc6059c564fc6e9b2016a09fd6ba8f57879c0be", "filename": "libjava/java/net/FileNameMap.java", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FFileNameMap.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FFileNameMap.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FFileNameMap.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,15 +35,14 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n+\n /**\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n  */\n-\n /**\n   * This interface has one method which, when passed a filename, returns\n   * the MIME type associated with that filename.\n@@ -63,6 +62,4 @@\n     * @return The MIME type for the filename passed in.\n     */\n   String getContentTypeFor(String filename);\n-\n } // interface FileNameMap\n-"}, {"sha": "e603d2b929d62cd4756a8af9787f354c0f18c520", "filename": "libjava/java/net/HttpURLConnection.java", "status": "modified", "additions": 89, "deletions": 80, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FHttpURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FHttpURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FHttpURLConnection.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -8,7 +8,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -17,7 +17,7 @@\n You should have received a copy of the GNU General Public License\n along with GNU Classpath; see the file COPYING.  If not, write to the\n Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n-02111-1307 USA. \n+02111-1307 USA.\n \n Linking this library statically or dynamically with other modules is\n making a combined work based on this library.  Thus, the terms and\n@@ -36,27 +36,27 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n-import java.io.InputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.io.PushbackInputStream;\n import java.security.Permission;\n \n+\n /*\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n  */\n \n /**\n- * This class provides a common abstract implementation for those \n+ * This class provides a common abstract implementation for those\n  * URL connection classes that will connect using the HTTP protocol.\n  * In addition to the functionality provided by the URLConnection\n  * class, it defines constants for HTTP return code values and\n  * methods for setting the HTTP request method and determining whether\n- * or not to follow redirects. \n+ * or not to follow redirects.\n  *\n  * @since 1.1\n  *\n@@ -73,27 +73,27 @@ public abstract class HttpURLConnection extends URLConnection\n    * beware of using this value\n    */\n   static final int HTTP_CONTINUE = 100;\n-  \n+\n   /**\n    * Indicates the request succeeded.\n    */\n-  public static final int HTTP_OK\t\t= 200;\n+  public static final int HTTP_OK = 200;\n \n   /**\n    * The requested resource has been created.\n    */\n-  public static final int HTTP_CREATED\t\t= 201;\n+  public static final int HTTP_CREATED = 201;\n \n   /**\n    * The request has been accepted for processing but has not completed.\n    * There is no guarantee that the requested action will actually ever\n    * be completed succesfully, but everything is ok so far.\n    */\n-  public static final int HTTP_ACCEPTED \t= 202;\n+  public static final int HTTP_ACCEPTED = 202;\n \n   /**\n    * The meta-information returned in the header is not the actual data\n-   * from the original server, but may be from a local or other copy. \n+   * from the original server, but may be from a local or other copy.\n    * Normally this still indicates a successful completion.\n    */\n   public static final int HTTP_NOT_AUTHORITATIVE = 203;\n@@ -102,43 +102,42 @@ public abstract class HttpURLConnection extends URLConnection\n    * The server performed the request, but there is no data to send\n    * back.  This indicates that the user's display should not be changed.\n    */\n-  public static final int HTTP_NO_CONTENT\t= 204;\n+  public static final int HTTP_NO_CONTENT = 204;\n \n   /**\n    * The server performed the request, but there is no data to sent back,\n    * however, the user's display should be \"reset\" to clear out any form\n    * fields entered.\n    */\n-  public static final int HTTP_RESET\t\t= 205;\n+  public static final int HTTP_RESET = 205;\n \n   /**\n    * The server completed the partial GET request for the resource.\n    */\n-  public static final int HTTP_PARTIAL\t\t= 206;\n-\n+  public static final int HTTP_PARTIAL = 206;\n \n   /* HTTP Redirection Response Codes */\n \n   /**\n    * There is a list of choices available for the requested resource.\n    */\n   public static final int HTTP_MULT_CHOICE = 300;\n-  \n+\n   /**\n    * The resource has been permanently moved to a new location.\n    */\n   public static final int HTTP_MOVED_PERM = 301;\n-  \n+\n   /**\n    * The resource requested has been temporarily moved to a new location.\n    */\n   public static final int HTTP_MOVED_TEMP = 302;\n-  \n+\n   /**\n    * The response to the request issued is available at another location.\n    */\n   public static final int HTTP_SEE_OTHER = 303;\n-  \n+\n   /**\n    * The document has not been modified since the criteria specified in\n    * a conditional GET.\n@@ -149,64 +148,63 @@ public abstract class HttpURLConnection extends URLConnection\n    * The requested resource needs to be accessed through a proxy.\n    */\n   public static final int HTTP_USE_PROXY = 305;\n-  \n-  \n+\n   /* HTTP Client Error Response Codes */\n \n   /**\n    * The request was misformed or could not be understood.\n    */\n   public static final int HTTP_BAD_REQUEST = 400;\n-  \n+\n   /**\n    * The request made requires user authorization.  Try again with\n    * a correct authentication header.\n    */\n   public static final int HTTP_UNAUTHORIZED = 401;\n-  \n+\n   /**\n    * Code reserved for future use - I hope way in the future.\n    */\n   public static final int HTTP_PAYMENT_REQUIRED = 402;\n-  \n+\n   /**\n    * There is no permission to access the requested resource.\n    */\n   public static final int HTTP_FORBIDDEN = 403;\n-  \n+\n   /**\n    * The requested resource was not found.\n    */\n   public static final int HTTP_NOT_FOUND = 404;\n-  \n+\n   /**\n    * The specified request method is not allowed for this resource.\n    */\n   public static final int HTTP_BAD_METHOD = 405;\n-  \n+\n   /**\n    * Based on the input headers sent, the resource returned in response\n    * to the request would not be acceptable to the client.\n    */\n   public static final int HTTP_NOT_ACCEPTABLE = 406;\n-  \n+\n   /**\n    * The client must authenticate with a proxy prior to attempting this\n    * request.\n    */\n   public static final int HTTP_PROXY_AUTH = 407;\n-  \n+\n   /**\n    * The request timed out.\n    */\n   public static final int HTTP_CLIENT_TIMEOUT = 408;\n-  \n+\n   /**\n    * There is a conflict between the current state of the resource and the\n    * requested action.\n    */\n   public static final int HTTP_CONFLICT = 409;\n-  \n+\n   /**\n    * The requested resource is no longer available.  This ususally indicates\n    * a permanent condition.\n@@ -218,45 +216,44 @@ public abstract class HttpURLConnection extends URLConnection\n    * supplied.\n    */\n   public static final int HTTP_LENGTH_REQUIRED = 411;\n-  \n+\n   /**\n    * A client specified pre-condition was not met on the server.\n    */\n   public static final int HTTP_PRECON_FAILED = 412;\n-  \n+\n   /**\n    * The request sent was too large for the server to handle.\n    */\n   public static final int HTTP_ENTITY_TOO_LARGE = 413;\n-  \n+\n   /**\n    * The name of the resource specified was too long.\n    */\n   public static final int HTTP_REQ_TOO_LONG = 414;\n-  \n+\n   /**\n    * The request is in a format not supported by the requested resource.\n    */\n   public static final int HTTP_UNSUPPORTED_TYPE = 415;\n \n-\n   /* HTTP Server Error Response Codes */\n \n   /**\n    * This error code indicates that some sort of server error occurred.\n    *\n    * @deprecated\n    */\n-  public static final int HTTP_SERVER_ERROR    = 500;\n+  public static final int HTTP_SERVER_ERROR = 500;\n \n   /**\n    * The server encountered an unexpected error (such as a CGI script crash)\n    * that prevents the request from being fulfilled.\n    */\n-  public static final int HTTP_INTERNAL_ERROR   = 500;\n+  public static final int HTTP_INTERNAL_ERROR = 500;\n \n   /**\n-   * The server does not support the requested functionality.  \n+   * The server does not support the requested functionality.\n    * @since 1.3\n    */\n   public static final int HTTP_NOT_IMPLEMENTED = 501;\n@@ -294,8 +291,8 @@ public abstract class HttpURLConnection extends URLConnection\n   /**\n    * This is a list of valid request methods, separated by \"|\" characters.\n    */\n-  private static String valid_methods\n-      = \"|GET|POST|HEAD|OPTIONS|PUT|DELETE|TRACE|\";\n+  private static String valid_methods =\n+    \"|GET|POST|HEAD|OPTIONS|PUT|DELETE|TRACE|\";\n \n   // Instance Variables\n \n@@ -312,7 +309,7 @@ public abstract class HttpURLConnection extends URLConnection\n   /**\n    * The response message string received from the server.\n    */\n-  protected String responseMessage = null;\n+  protected String responseMessage;\n \n   /**\n    * If this instance should follow redirect requests.\n@@ -324,7 +321,7 @@ public abstract class HttpURLConnection extends URLConnection\n    * Used by <code>getResponseCode()</code> and\n    * <code>getResponseMessage()</code>.\n    */\n-  private boolean gotResponseVals = false;\n+  private boolean gotResponseVals;\n \n   /**\n    * Create an HttpURLConnection for the specified URL\n@@ -335,16 +332,16 @@ protected HttpURLConnection(URL url)\n   {\n     super(url);\n   }\n-  \n-  /**   \n+\n+  /**\n    * Closes the connection to the server.\n    */\n   public abstract void disconnect();\n \n-  /** \n+  /**\n    * Returns a boolean indicating whether or not this connection is going\n    * through a proxy\n-   * \n+   *\n    * @return true if through a proxy, false otherwise\n    */\n   public abstract boolean usingProxy();\n@@ -370,7 +367,7 @@ public static void setFollowRedirects(boolean set)\n   }\n \n   /**\n-   * Returns a boolean indicating whether or not HTTP redirects will \n+   * Returns a boolean indicating whether or not HTTP redirects will\n    * automatically be followed or not.\n    *\n    * @return true if redirects will be followed, false otherwise\n@@ -383,16 +380,20 @@ public static boolean getFollowRedirects()\n   /**\n    * Returns the value of this HttpURLConnection's instanceFollowRedirects\n    * field\n+   * \n+   * @return true if following redirects is enabled, false otherwise\n    */\n-  public boolean getInstanceFollowRedirects ()\n+  public boolean getInstanceFollowRedirects()\n   {\n     return instanceFollowRedirects;\n   }\n \n   /**\n    * Sets the value of this HttpURLConnection's instanceFollowRedirects field\n+   *\n+   * @param follow true to enable following redirects, false otherwise\n    */\n-  public void setInstanceFollowRedirects (boolean follow)\n+  public void setInstanceFollowRedirects(boolean follow)\n   {\n     instanceFollowRedirects = follow;\n   }\n@@ -401,6 +402,8 @@ public void setInstanceFollowRedirects (boolean follow)\n    * Set the method for the URL request, one of:\n    * GET POST HEAD OPTIONS PUT DELETE TRACE are legal\n    *\n+   * @param method the method to use\n+   *\n    * @exception ProtocolException If the method cannot be reset or if the\n    * requested method isn't valid for HTTP\n    */\n@@ -414,7 +417,6 @@ public void setRequestMethod(String method) throws ProtocolException\n       this.method = method;\n     else\n       throw new ProtocolException(\"Invalid HTTP request method: \" + method);\n-\n   }\n \n   /**\n@@ -439,7 +441,7 @@ public String getRequestMethod()\n    */\n   public int getResponseCode() throws IOException\n   {\n-    if (!gotResponseVals)\n+    if (! gotResponseVals)\n       getResponseVals();\n     return responseCode;\n   }\n@@ -455,7 +457,7 @@ public int getResponseCode() throws IOException\n    */\n   public String getResponseMessage() throws IOException\n   {\n-    if (!gotResponseVals)\n+    if (! gotResponseVals)\n       getResponseVals();\n     return responseMessage;\n   }\n@@ -464,17 +466,17 @@ private void getResponseVals() throws IOException\n   {\n     // getHeaderField() will connect for us, but do it here first in\n     // order to pick up IOExceptions.\n-    if (!connected)\n+    if (! connected)\n       connect();\n-      \n+\n     gotResponseVals = true;\n \n     // If responseCode not yet explicitly set by subclass\n     if (responseCode == -1)\n       {\n \t// Response is the first header received from the connection.\n \tString respField = getHeaderField(0);\n-\t\n+\n \tif (respField == null || ! respField.startsWith(\"HTTP/\"))\n \t  {\n \t    // Set to default values on failure.\n@@ -483,7 +485,8 @@ private void getResponseVals() throws IOException\n \t    return;\n \t  }\n \n-\tint firstSpc, nextSpc;\n+\tint firstSpc;\n+\tint nextSpc;\n \tfirstSpc = respField.indexOf(' ');\n \tnextSpc = respField.indexOf(' ', firstSpc + 1);\n \tresponseMessage = respField.substring(nextSpc + 1);\n@@ -505,6 +508,8 @@ private void getResponseVals() throws IOException\n    * Returns a permission object representing the permission necessary to make\n    * the connection represented by this object\n    *\n+   * @return the permission necessary for this connection\n+   *\n    * @exception IOException If an error occurs\n    */\n   public Permission getPermission() throws IOException\n@@ -514,9 +519,9 @@ public Permission getPermission() throws IOException\n     int port = url.getPort();\n     if (port == -1)\n       port = 80;\n-    \n+\n     host = host + \":\" + port;\n-    \n+\n     return new SocketPermission(host, \"connect\");\n   }\n \n@@ -529,52 +534,56 @@ public Permission getPermission() throws IOException\n    *\n    * @return An <code>InputStream</code> for reading error data.\n    */\n-  public InputStream getErrorStream ()\n+  public InputStream getErrorStream()\n   {\n-    if (!connected)\n-      return(null);\n-    \n+    if (! connected)\n+      return (null);\n+\n     int code;\n-    try \n+    try\n       {\n \tcode = getResponseCode();\n       }\n-    catch(IOException e)\n+    catch (IOException e)\n       {\n \tcode = -1;\n       }\n-    \n+\n     if (code == -1)\n-      return(null);\n-    \n-    if (((code/100) != 4) || ((code/100) != 5))\n-      return(null); \n-    \n+      return (null);\n+\n+    if (((code / 100) != 4) || ((code / 100) != 5))\n+      return (null);\n+\n     try\n       {\n \tPushbackInputStream pbis = new PushbackInputStream(getInputStream());\n-\t\n+\n \tint i = pbis.read();\n \tif (i == -1)\n-\t  return(null);\n-\t\n+\t  return (null);\n+\n \tpbis.unread(i);\n-\treturn(pbis);\n+\treturn (pbis);\n       }\n-    catch(IOException e)\n+    catch (IOException e)\n       {\n-\treturn(null);\n+\treturn (null);\n       }\n   }\n \n   /**\n    * Returns the value of the named field parsed as date\n+   *\n+   * @param key the key of the header field\n+   * @param value the default value if the header field is not present\n+   *\n+   * @return the value of the header field\n    */\n-  public long getHeaderFieldDate (String key, long value)\n+  public long getHeaderFieldDate(String key, long value)\n   {\n     // FIXME: implement this correctly\n     // http://www.w3.org/Protocols/HTTP-NG/ng-notes.txt\n-    \n-    return super.getHeaderFieldDate (key, value);\n+    return super.getHeaderFieldDate(key, value);\n   }\n }"}, {"sha": "0a583efc9c6de0bd8fe52308f5194a59c7d1f7d0", "filename": "libjava/java/net/Inet4Address.java", "status": "modified", "additions": 68, "deletions": 71, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FInet4Address.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FInet4Address.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInet4Address.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,12 +35,12 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n import java.io.ObjectStreamException;\n import java.util.Arrays;\n \n+\n /**\n  * @author Michael Koch\n  * @date August 3, 2002.\n@@ -53,224 +53,221 @@\n  * RFC 2365 (http://www.ietf.org/rfc/rfc2365.txt)\n  * Status: Believed complete and correct.\n  */\n-\n public final class Inet4Address extends InetAddress\n {\n   static final long serialVersionUID = 3286316764910316507L;\n \n   /**\n    * needed for serialization\n    */\n-  private Object writeReplace () throws ObjectStreamException\n+  private Object writeReplace() throws ObjectStreamException\n   {\n-    return new InetAddress (addr, hostName);\n+    return new InetAddress(addr, hostName);\n   }\n \n   /**\n    * Creates a Inet4Address\n-   * \n+   *\n    * @param addr The IP address\n    * @param host The Hostname\n    */\n   Inet4Address(byte[] addr, String host)\n   {\n-    super (addr, host);\n+    super(addr, host);\n   }\n \n   /**\n    * Checks if the address is a multicast address\n    *\n    * @since 1.1\n    */\n-  public boolean isMulticastAddress ()\n+  public boolean isMulticastAddress()\n   {\n-    return (addr [0] & 0xF0) == 0xE0;\n+    return (addr[0] & 0xF0) == 0xE0;\n   }\n-  \n+\n   /**\n    * Checks if this address is a loopback address\n    */\n-  public boolean isLoopbackAddress ()\n+  public boolean isLoopbackAddress()\n   {\n-    return addr [0] == 0x7F;\n+    return addr[0] == 0x7F;\n   }\n- \n+\n   /**\n    * Checks if this address is a wildcard address\n    *\n    * @since 1.4\n    */\n-  public boolean isAnyLocalAddress ()\n+  public boolean isAnyLocalAddress()\n   {\n     byte[] anylocal = { 0, 0, 0, 0 };\n-    \n+\n     return Arrays.equals(addr, anylocal);\n   }\n \n   /**\n    * Checks if this address is a link local address\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isLinkLocalAddress ()\n+  public boolean isLinkLocalAddress()\n   {\n     // XXX: This seems to not exist with IPv4 addresses\n     return false;\n   }\n \n   /**\n    * Checks if this address is a site local address\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isSiteLocalAddress ()\n+  public boolean isSiteLocalAddress()\n   {\n     // 10.0.0.0/8\n-    if (addr [0] == 0x0A)\n+    if (addr[0] == 0x0A)\n       return true;\n \n     // XXX: Suns JDK 1.4.1 (on Linux) seems to have a bug here:\n     // it says 172.16.0.0 - 172.255.255.255 are site local addresses\n     //\n     // 172.16.0.0/12\n-    if (addr [0] == 0xAC && (addr [1] & 0xF0) == 0x01)\n+    if (addr[0] == 0xAC && (addr[1] & 0xF0) == 0x01)\n       return true;\n \n     // 192.168.0.0/16\n-    if (addr [0] == 0xC0 && addr [1] == 0xA8)\n+    if (addr[0] == 0xC0 && addr[1] == 0xA8)\n       return true;\n-   \n+\n     // XXX: Do we need to check more addresses here ?\n     return false;\n   }\n \n   /**\n    * Checks if this multicast address has global scope\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isMCGlobal ()\n+  public boolean isMCGlobal()\n   {\n     // XXX: This seems to net exist with IPv4 addresses\n     return false;\n   }\n \n   /**\n    * Checks if this multicast address has node scope\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isMCNodeLocal ()\n+  public boolean isMCNodeLocal()\n   {\n     // XXX: This seems to net exist with IPv4 addresses\n     return false;\n   }\n-  \n+\n   /**\n    * Checks if this multicast address has link scope\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isMCLinkLocal ()\n+  public boolean isMCLinkLocal()\n   {\n-    if (!isMulticastAddress ())\n+    if (! isMulticastAddress())\n       return false;\n-    \n-    return (addr [0] == 0xE0)\n-\t   && (addr [1] == 0x00)\n-\t   && (addr [2] == 0x00);\n+\n+    return (addr[0] == 0xE0) && (addr[1] == 0x00) && (addr[2] == 0x00);\n   }\n-  \n+\n   /**\n    * Checks if this multicast address has site scope\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isMCSiteLocal ()\n+  public boolean isMCSiteLocal()\n   {\n     // XXX: This seems to net exist with IPv4 addresses\n     return false;\n   }\n-  \n+\n   /**\n    * Checks if this multicast address has organization scope\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isMCOrgLocal ()\n+  public boolean isMCOrgLocal()\n   {\n     // XXX: This seems to net exist with IPv4 addresses\n     return false;\n   }\n-  \n+\n   /**\n    * Returns the address of the current instance\n    */\n-  public byte[] getAddress ()\n+  public byte[] getAddress()\n   {\n     return addr;\n   }\n-  \n+\n   /**\n    * Returns the address as string\n-   * \n+   *\n    * @since 1.0.2\n    */\n-  public String getHostAddress ()\n+  public String getHostAddress()\n   {\n-    StringBuffer sbuf = new StringBuffer (40);\n+    StringBuffer sbuf = new StringBuffer(40);\n     int len = addr.length;\n     int i = 0;\n-    \n-    for ( ;  ; )\n+\n+    for (;;)\n       {\n-\tsbuf.append (addr [i] & 0xFF);\n+\tsbuf.append(addr[i] & 0xFF);\n \ti++;\n-\t\n+\n \tif (i == len)\n \t  break;\n-\t\n-\tsbuf.append ('.');\n+\n+\tsbuf.append('.');\n       }\n-    \n-    return sbuf.toString ();\n+\n+    return sbuf.toString();\n   }\n-  \n+\n   /**\n    * Computes the hashcode of the instance\n    */\n-  public int hashCode ()\n+  public int hashCode()\n   {\n     int hash = 0;\n     int len = addr.length;\n     int i = len > 4 ? len - 4 : 0;\n-    \n-    for ( ; i < len;  i++)\n-      hash = (hash << 8) | (addr [i] & 0xFF);\n-    \n+\n+    for (; i < len; i++)\n+      hash = (hash << 8) | (addr[i] & 0xFF);\n+\n     return hash;\n   }\n- \n+\n   /**\n    * Compare the current Inet4Address instance with obj\n-   * \n+   *\n    * @param obj Object to compare with\n    */\n-  public boolean equals (Object obj)\n+  public boolean equals(Object obj)\n   {\n     if (! (obj instanceof InetAddress))\n       return false;\n-    \n+\n     byte[] addr1 = addr;\n     byte[] addr2 = ((InetAddress) obj).addr;\n-    \n+\n     if (addr1.length != addr2.length)\n       return false;\n-    \n-    for (int i = addr1.length;  --i >= 0; )\n-      if (addr1 [i] != addr2 [i])\n-        return false;\n-    \n+\n+    for (int i = addr1.length; --i >= 0;)\n+      if (addr1[i] != addr2[i])\n+\treturn false;\n+\n     return true;\n   }\n } // class Inet4Address"}, {"sha": "5d527359980518855e8e24e84a4c7d27ec2a68e7", "filename": "libjava/java/net/Inet6Address.java", "status": "modified", "additions": 82, "deletions": 86, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FInet6Address.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FInet6Address.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInet6Address.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,11 +35,11 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n import java.util.Arrays;\n \n+\n /**\n  * @author Michael Koch\n  * @date August 3, 2002.\n@@ -50,7 +50,6 @@\n  * RFC 1884 (http://www.ietf.org/rfc/rfc1884.txt)\n  * Status: Believed complete and correct.\n  */\n-\n public final class Inet6Address extends InetAddress\n {\n   static final long serialVersionUID = 6880410070516793377L;\n@@ -59,213 +58,210 @@ public final class Inet6Address extends InetAddress\n    * Needed for serialization\n    */\n   byte[] ipaddress;\n-  \n+\n   /**\n    * Create an Inet6Address object\n    *\n    * @param addr The IP address\n    * @param host The hostname\n    */\n-  Inet6Address (byte[] addr, String host)\n+  Inet6Address(byte[] addr, String host)\n   {\n-    super (addr, host);\n+    super(addr, host);\n     this.ipaddress = addr;\n   }\n \n   /**\n    * Utility routine to check if the InetAddress is an IP multicast address\n-   * \n+   *\n    * @since 1.1\n    */\n-  public boolean isMulticastAddress ()\n+  public boolean isMulticastAddress()\n   {\n-    return ipaddress [0] == 0xFF;\n+    return ipaddress[0] == 0xFF;\n   }\n- \n+\n   /**\n    * Utility routine to check if the InetAddress in a wildcard address\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isAnyLocalAddress ()\n+  public boolean isAnyLocalAddress()\n   {\n-    byte[] anylocal = { 0, 0, 0, 0, 0, 0, 0, 0,\n-\t                0, 0, 0, 0, 0, 0, 0, 0 };\n-    \n+    byte[] anylocal = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+\n     return Arrays.equals(ipaddress, anylocal);\n   }\n-\t  \n+\n   /**\n    * Utility routine to check if the InetAddress is a loopback address\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isLoopbackAddress ()\n+  public boolean isLoopbackAddress()\n   {\n-    byte[] loopback = { 0, 0, 0, 0, 0, 0, 0, 0,\n-\t                0, 0, 0, 0, 0, 0, 0, 1 };\n-    \n+    byte[] loopback = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };\n+\n     return Arrays.equals(ipaddress, loopback);\n   }\n \n   /**\n    * Utility routine to check if the InetAddress is an link local address\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isLinkLocalAddress ()\n+  public boolean isLinkLocalAddress()\n   {\n-    return ipaddress [0] == 0xFA;\n+    return ipaddress[0] == 0xFA;\n   }\n \n   /**\n    * Utility routine to check if the InetAddress is a site local address\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isSiteLocalAddress ()\n+  public boolean isSiteLocalAddress()\n   {\n-    return ipaddress [0] == 0xFB;\n+    return ipaddress[0] == 0xFB;\n   }\n \n   /**\n    * Utility routine to check if the multicast address has global scope\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isMCGlobal ()\n+  public boolean isMCGlobal()\n   {\n-    if (!isMulticastAddress ())\n+    if (! isMulticastAddress())\n       return false;\n-    \n-    return (ipaddress [1] & 0x0F) == 0xE;\n+\n+    return (ipaddress[1] & 0x0F) == 0xE;\n   }\n \n   /**\n    * Utility routine to check if the multicast address has node scope\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isMCNodeLocal ()\n+  public boolean isMCNodeLocal()\n   {\n-    if (!isMulticastAddress ())\n+    if (! isMulticastAddress())\n       return false;\n-    \n-    return (ipaddress [1] & 0x0F) == 0x1;\n+\n+    return (ipaddress[1] & 0x0F) == 0x1;\n   }\n \n   /**\n    * Utility routine to check if the multicast address has link scope\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isMCLinkLocal ()\n+  public boolean isMCLinkLocal()\n   {\n-    if (!isMulticastAddress ())\n+    if (! isMulticastAddress())\n       return false;\n-    \n-    return (ipaddress [1] & 0x0F) == 0x2;\n+\n+    return (ipaddress[1] & 0x0F) == 0x2;\n   }\n \n   /**\n    * Utility routine to check if the multicast address has site scope\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isMCSiteLocal ()\n+  public boolean isMCSiteLocal()\n   {\n-    if (!isMulticastAddress ())\n+    if (! isMulticastAddress())\n       return false;\n-    \n-    return (ipaddress [1] & 0x0F) == 0x5;\n+\n+    return (ipaddress[1] & 0x0F) == 0x5;\n   }\n \n   /**\n    * Utility routine to check if the multicast address has organization scope\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isMCOrgLocal ()\n+  public boolean isMCOrgLocal()\n   {\n-    if (!isMulticastAddress ())\n+    if (! isMulticastAddress())\n       return false;\n-    \n-    return (ipaddress [1] & 0x0F) == 0x8;\n+\n+    return (ipaddress[1] & 0x0F) == 0x8;\n   }\n-  \n+\n   /**\n    * Returns the raw IP address of this InetAddress object. The result is in\n    * network byte order: the highest order byte of the address is i\n    * n getAddress()[0]\n    */\n-  public byte[] getAddress ()\n+  public byte[] getAddress()\n   {\n     return ipaddress;\n   }\n-  \n+\n   /**\n    * Returns the IP address string in textual presentation\n    */\n-  public String getHostAddress ()\n+  public String getHostAddress()\n   {\n-    StringBuffer sbuf = new StringBuffer (40);\n+    StringBuffer sbuf = new StringBuffer(40);\n \n     for (int i = 0; i < 16; i += 2)\n       {\n-        int x = ((ipaddress [i] & 0xFF) << 8) | (ipaddress [i + 1] & 0xFF);\n-        boolean empty = sbuf.length () == 0;\n-\t\n-        if (empty)\n-          {\n-            if (i > 0)\n-              sbuf.append (\"::\");\n-          }\n-        else\n-          sbuf.append (':');\n-\n-        if (x != 0 || i >= 14)\n-          sbuf.append (Integer.toHexString (x));\n+\tint x = ((ipaddress[i] & 0xFF) << 8) | (ipaddress[i + 1] & 0xFF);\n+\tboolean empty = sbuf.length() == 0;\n+\n+\tif (empty)\n+\t  {\n+\t    if (i > 0)\n+\t      sbuf.append(\"::\");\n+\t  }\n+\telse\n+\t  sbuf.append(':');\n+\n+\tif (x != 0 || i >= 14)\n+\t  sbuf.append(Integer.toHexString(x));\n       }\n-   \n-    return sbuf.toString ();\n+\n+    return sbuf.toString();\n   }\n \n   /**\n    * Returns a hashcode for this IP address\n    */\n-  public int hashCode ()\n+  public int hashCode()\n   {\n-    return super.hashCode ();\n+    return super.hashCode();\n   }\n- \n+\n   /**\n    * Compares this object against the specified object\n    */\n-  public boolean equals (Object obj)\n+  public boolean equals(Object obj)\n   {\n     if (! (obj instanceof Inet6Address))\n       return false;\n \n     Inet6Address tmp = (Inet6Address) obj;\n \n-    return super.equals (tmp)\n-           && this.ipaddress == tmp.ipaddress;\n+    return super.equals(tmp) && this.ipaddress == tmp.ipaddress;\n   }\n-  \n+\n   /**\n    * Utility routine to check if the InetAddress is an\n    * IPv4 compatible IPv6 address\n    *\n    * @since 1.4\n    */\n-  public boolean isIPv4CompatibleAddress ()\n+  public boolean isIPv4CompatibleAddress()\n   {\n-    if (ipaddress [0] != 0x00 || ipaddress [1] != 0x00 ||\n-        ipaddress [2] != 0x00 || ipaddress [3] != 0x00 ||\n-\tipaddress [4] != 0x00 || ipaddress [5] != 0x00 ||\n-\tipaddress [6] != 0x00 || ipaddress [7] != 0x00 ||\n-\tipaddress [8] != 0x00 || ipaddress [9] != 0x00 ||\n-\tipaddress [10] != 0x00 || ipaddress [11] != 0x00)\n+    if (ipaddress[0] != 0x00 || ipaddress[1] != 0x00 || ipaddress[2] != 0x00\n+        || ipaddress[3] != 0x00 || ipaddress[4] != 0x00\n+        || ipaddress[5] != 0x00 || ipaddress[6] != 0x00\n+        || ipaddress[7] != 0x00 || ipaddress[8] != 0x00\n+        || ipaddress[9] != 0x00 || ipaddress[10] != 0x00\n+        || ipaddress[11] != 0x00)\n       return false;\n \n     return true;"}, {"sha": "6d57566a1b3ab8875262b00add9520f0004531de", "filename": "libjava/java/net/InetAddress.java", "status": "modified", "additions": 69, "deletions": 82, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FInetAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FInetAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetAddress.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,7 +35,6 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n import gnu.classpath.Configuration;\n@@ -63,7 +62,7 @@\n public class InetAddress implements Serializable\n {\n   private static final long serialVersionUID = 3286316764910316507L;\n-  \n+\n   /**\n    * Dummy InetAddress, used to bind socket to any (all) network interfaces.\n    */\n@@ -101,7 +100,7 @@ public class InetAddress implements Serializable\n    * The name of the host for this address.\n    */\n   String hostName;\n-  \n+\n   /**\n    * The field 'family' seems to be the AF_ value.\n    * FIXME: Much of the code in the other java.net classes does not make\n@@ -118,7 +117,7 @@ public class InetAddress implements Serializable\n    *\n    * @param ipaddr The IP number of this address as an array of bytes\n    */\n-  InetAddress (byte[] address)\n+  InetAddress(byte[] address)\n   {\n     this (address, null);\n   }\n@@ -131,7 +130,7 @@ public class InetAddress implements Serializable\n    * @param ipaddr The IP number of this address as an array of bytes\n    * @param hostname The hostname of this IP address.\n    */\n-  InetAddress (byte[] address, String hostname)\n+  InetAddress(byte[] address, String hostname)\n   {\n     addr = address;\n     hostName = hostname;\n@@ -153,8 +152,8 @@ public boolean isMulticastAddress()\n   {\n     // Mask against high order bits of 1110\n     if (addr.length == 4)\n-      return (addr [0] & 0xF0) == 0xE0;\n-    \n+      return (addr[0] & 0xF0) == 0xE0;\n+\n     // Mask against high order bits of 11111111\n     if (addr.length == 16)\n       return addr [0] == (byte) 0xFF;\n@@ -164,68 +163,62 @@ public boolean isMulticastAddress()\n \n   /**\n    * Utility routine to check if the InetAddress in a wildcard address\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean isAnyLocalAddress()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n-    return equals (ANY_IF);\n+    return equals(ANY_IF);\n   }\n \n   /**\n    * Utility routine to check if the InetAddress is a loopback address\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean isLoopbackAddress()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n-    \n-    return addr [0] == 0x7F;\n+    return addr[0] == 0x7F;\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a link local address\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean isLinkLocalAddress()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n-\n     // XXX: This seems to not exist with IPv4 addresses\n     return false;\n   }\n \n   /**\n    * Utility routine to check if InetAddress is a site local address\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean isSiteLocalAddress()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n-\n     // 10.0.0.0/8\n-    if (addr [0] == 0x0A)\n+    if (addr[0] == 0x0A)\n       return true;\n \n     // XXX: Suns JDK 1.4.1 (on Linux) seems to have a bug here:\n     // it says 172.16.0.0 - 172.255.255.255 are site local addresses\n-\n     // 172.16.0.0/12\n-    if (addr [0] == 0xAC\n-        && (addr [1] & 0xF0) == 0x01)\n+    if (addr[0] == 0xAC && (addr[1] & 0xF0) == 0x01)\n       return true;\n \n     // 192.168.0.0/16\n-    if (addr [0] == 0xC0\n-        && addr [1] == 0xA8)\n+    if (addr[0] == 0xC0 && addr[1] == 0xA8)\n       return true;\n \n     // XXX: Do we need to check more addresses here ?\n@@ -234,48 +227,43 @@ public boolean isSiteLocalAddress()\n \n   /**\n    * Utility routine to check if InetAddress is a global multicast address\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean isMCGlobal()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n-\n     // XXX: This seems to not exist with IPv4 addresses\n     return false;\n   }\n \n   /**\n    * Utility reoutine to check if InetAddress is a node local multicast address\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean isMCNodeLocal()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n-\n     // XXX: This seems to not exist with IPv4 addresses\n     return false;\n   }\n \n   /**\n    * Utility reoutine to check if InetAddress is a link local multicast address\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean isMCLinkLocal()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n-    \n-    if (!isMulticastAddress())\n+    if (! isMulticastAddress())\n       return false;\n \n-    return (addr [0] == 0xE0\n-\t    && addr [1] == 0x00\n-\t    && addr [2] == 0x00);\n+    return (addr[0] == 0xE0 && addr[1] == 0x00 && addr[2] == 0x00);\n   }\n \n   /**\n@@ -287,22 +275,20 @@ public boolean isMCSiteLocal()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n-\n     // XXX: This seems to not exist with IPv4 addresses\n     return false;\n   }\n \n   /**\n    * Utility reoutine to check if InetAddress is a organization local\n    * multicast address\n-   * \n+   *\n    * @since 1.4\n    */\n   public boolean isMCOrgLocal()\n   {\n     // This is the IPv4 implementation.\n     // Any class derived from InetAddress should override this.\n-\n     // XXX: This seems to not exist with IPv4 addresses\n     return false;\n   }\n@@ -384,7 +370,7 @@ private static SecurityException checkConnect (String hostname)\n   }\n \n   /**\n-   * Returns the IP address of this object as a String.  The address is in \n+   * Returns the IP address of this object as a String.  The address is in\n    * the dotted octet notation, for example, \"127.0.0.1\".\n    *\n    * @return The IP address of this object in String form\n@@ -393,7 +379,8 @@ private static SecurityException checkConnect (String hostname)\n    */\n   public String getHostAddress()\n   {\n-    StringBuffer sb = new StringBuffer (40);\n+    StringBuffer sb = new StringBuffer(40);\n+\n     int len = addr.length;\n     int i = 0;\n     \n@@ -440,7 +427,7 @@ else if (i > 0)\n \t\n \tsb.append ('.');\n       }\n-    \n+\n     return sb.toString();\n   }\n \n@@ -457,10 +444,10 @@ public int hashCode()\n     int hash = 0;\n     int len = addr.length;\n     int i = len > 4 ? len - 4 : 0;\n-    \n-    for ( ; i < len;  i++)\n+\n+    for (; i < len; i++)\n       hash = (hash << 8) | (addr[i] & 0xFF);\n-    \n+\n     return hash;\n   }\n \n@@ -474,26 +461,26 @@ public int hashCode()\n    * @return true if the passed in object's address is equal to this one's,\n    * false otherwise\n    */\n-  public boolean equals (Object obj)\n+  public boolean equals(Object obj)\n   {\n     if (! (obj instanceof InetAddress))\n       return false;\n-    \n+\n     // \"The Java Class Libraries\" 2nd edition says \"If a machine has\n     // multiple names instances of InetAddress for different name of\n     // that same machine are not equal.  This is because they have\n     // different host names.\"  This violates the description in the\n     // JDK 1.2 API documentation.  A little experimentation\n     // shows that the latter is correct.\n     byte[] addr2 = ((InetAddress) obj).addr;\n-    \n+\n     if (addr.length != addr2.length)\n       return false;\n-    \n+\n     for (int i = 0; i < addr.length; i++)\n-      if (addr [i] != addr2 [i])\n+      if (addr[i] != addr2[i])\n \treturn false;\n-    \n+\n     return true;\n   }\n \n@@ -508,12 +495,12 @@ public String toString()\n   {\n     String host;\n     String address = getHostAddress();\n-    \n+\n     if (hostName != null)\n       host = hostName;\n     else\n       host = address;\n-    \n+\n     return host + \"/\" + address;\n   }\n \n@@ -529,10 +516,10 @@ public String toString()\n    *\n    * @since 1.4\n    */\n-  public static InetAddress getByAddress (byte[] addr)\n+  public static InetAddress getByAddress(byte[] addr)\n     throws UnknownHostException\n   {\n-    return getByAddress (null, addr);\n+    return getByAddress(null, addr);\n   }\n \n   /**\n@@ -546,18 +533,18 @@ public static InetAddress getByAddress (byte[] addr)\n    *\n    * @since 1.4\n    */\n-  public static InetAddress getByAddress (String host, byte[] addr)\n+  public static InetAddress getByAddress(String host, byte[] addr)\n     throws UnknownHostException\n   {\n     if (addr.length == 4)\n-      return new Inet4Address (addr, host);\n+      return new Inet4Address(addr, host);\n \n     if (addr.length == 16)\n-      return new Inet6Address (addr, host);\n-    \n-    throw new UnknownHostException (\"IP address has illegal length\");\n+      return new Inet6Address(addr, host);\n+\n+    throw new UnknownHostException(\"IP address has illegal length\");\n   }\n-  \n+\n   /**\n    * If host is a valid numeric IP address, return the numeric address.\n    * Otherwise, return null.\n@@ -578,27 +565,27 @@ private static native InetAddress[] lookup (String hostname,\n    * the InetAddress array returned from GetAllByName.\n    *\n    * @param hostname The name of the desired host, or null for the local machine.\n-   * \n+   *\n    * @return The address of the host as an InetAddress object.\n    *\n    * @exception UnknownHostException If no IP address for the host could\n    * be found\n    * @exception SecurityException If a security manager exists and its\n    * checkConnect method doesn't allow the operation\n    */\n-  public static InetAddress getByName (String hostname)\n+  public static InetAddress getByName(String hostname)\n     throws UnknownHostException\n   {\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n-      s.checkConnect (hostname, -1);\n-   \n+      s.checkConnect(hostname, -1);\n+\n     // Default to current host if necessary\n     if (hostname == null || hostname.length() == 0)\n       return getLocalHost();\n \n     // Assume that the host string is an IP address\n-    byte[] address = aton (hostname);\n+    byte[] address = aton(hostname);\n     if (address != null)\n       {\n         if (address.length == 4)\n@@ -619,10 +606,10 @@ else if (address.length == 16)\n \telse\n           throw new UnknownHostException (\"Address has invalid length\");\n       }\n-   \n+\n     // Try to resolve the host by DNS\n-    InetAddress[] addresses = getAllByName (hostname);\n-    return addresses [0];\n+    InetAddress[] addresses = getAllByName(hostname);\n+    return addresses[0];\n   }\n \n   /**\n@@ -632,22 +619,22 @@ else if (address.length == 16)\n    * dotted decimal format such as \"127.0.0.1\".  If the value is null, the\n    * hostname of the local machine is supplied by default.\n    *\n-   * @param @param hostname The name of the desired host, or null for the\n+   * @param hostname The name of the desired host, or null for the\n    * local machine.\n    *\n    * @return All addresses of the host as an array of InetAddress objects.\n-   * \n+   *\n    * @exception UnknownHostException If no IP address for the host could\n    * be found\n    * @exception SecurityException If a security manager exists and its\n    * checkConnect method doesn't allow the operation\n    */\n-  public static InetAddress[] getAllByName (String hostname)\n+  public static InetAddress[] getAllByName(String hostname)\n     throws UnknownHostException\n   {\n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n-      s.checkConnect (hostname, -1);\n+      s.checkConnect(hostname, -1);\n \n     // Check if hostname is an IP address\n     byte[] address = aton (hostname);\n@@ -657,7 +644,7 @@ public static InetAddress[] getAllByName (String hostname)\n \tresult [0] = new InetAddress (address, null);\n \treturn result;\n       }\n-   \n+\n     // Try to resolve the hostname by DNS\n     return lookup (hostname, null, true);\n   }\n@@ -747,17 +734,17 @@ private void readResolve() throws ObjectStreamException\n   {\n     // FIXME: implement this\n   }\n-\t  \n-  private void readObject (ObjectInputStream ois)\n+\n+  private void readObject(ObjectInputStream ois)\n     throws IOException, ClassNotFoundException\n   {\n     ois.defaultReadObject();\n-    addr = new byte [4];\n-    addr [3] = (byte) address;\n-    \n+    addr = new byte[4];\n+    addr[3] = (byte) address;\n+\n     for (int i = 2; i >= 0; --i)\n-      addr [i] = (byte) (address >>= 8);\n-    \n+      addr[i] = (byte) (address >>= 8);\n+\n     // Ignore family from serialized data.  Since the saved address is 32 bits\n     // the deserialized object will have an IPv4 address i.e. AF_INET family.\n     // FIXME: An alternative is to call the aton method on the deserialized\n@@ -766,16 +753,16 @@ private void readObject (ObjectInputStream ois)\n     family = getFamily (addr);\n   }\n \n-  private void writeObject (ObjectOutputStream oos) throws IOException\n+  private void writeObject(ObjectOutputStream oos) throws IOException\n   {\n     // Build a 32 bit address from the last 4 bytes of a 4 byte IPv4 address\n     // or a 16 byte IPv6 address.\n     int len = addr.length;\n     int i = len - 4;\n-    \n+\n     for (; i < len; i++)\n-      address = address << 8 | (((int) addr [i]) & 0xFF);\n-    \n+      address = address << 8 | (((int) addr[i]) & 0xFF);\n+\n     oos.defaultWriteObject();\n   }\n }"}, {"sha": "5dc63dcd0db8c1306a591dcab2a42a0d1a97c82c", "filename": "libjava/java/net/InetSocketAddress.java", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FInetSocketAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FInetSocketAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetSocketAddress.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -1,4 +1,4 @@\n-/* InetSocketAddress.java -- \n+/* InetSocketAddress.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -37,21 +37,21 @@\n \n package java.net;\n \n-/** \n+\n+/**\n  * InetSocketAddress instances represent socket addresses\n  * in the java.nio package. They encapsulate a InetAddress and\n  * a port number.\n  *\n  * @since 1.4\n  */\n-\n public class InetSocketAddress extends SocketAddress\n {\n   /**\n    * Compatible with JDK 1.4+\n    */\n   private static final long serialVersionUID = 5076001401234631237L;\n-  \n+\n   /**\n    * Name of host.\n    */\n@@ -66,10 +66,10 @@ public class InetSocketAddress extends SocketAddress\n    * Port of host.\n    */\n   private int port;\n-    \n+\n   /**\n    * Constructs an InetSocketAddress instance.\n-   * \n+   *\n    * @param addr Address of the socket\n    * @param port Port if the socket\n    *\n@@ -79,84 +79,82 @@ public InetSocketAddress(InetAddress addr, int port)\n     throws IllegalArgumentException\n   {\n     if (port < 0 || port > 65535)\n-      throw new IllegalArgumentException (\"Bad port number: \" + port);\n+      throw new IllegalArgumentException(\"Bad port number: \" + port);\n \n     if (addr == null)\n       addr = InetAddress.ANY_IF;\n-  \n+\n     this.addr = addr;\n     this.port = port;\n-    this.hostname = addr.getHostName ();\n+    this.hostname = addr.getHostName();\n   }\n \n   /**\n    * Constructs an InetSocketAddress instance.\n-   * \n+   *\n    * @param port Port if the socket\n    *\n    * @exception IllegalArgumentException If the port number is illegal\n    */\n-  public InetSocketAddress(int port)\n-    throws IllegalArgumentException\n+  public InetSocketAddress(int port) throws IllegalArgumentException\n   {\n-    this ((InetAddress) null, port);\n+    this((InetAddress) null, port);\n   }\n \n   /**\n    * Constructs an InetSocketAddress instance.\n    *\n-   * @param addr Address of the socket\n-   * @param port Port if the socket\n+   * @param hostname The hostname for the socket address\n+   * @param port The port for the socket address\n    *\n    * @exception IllegalArgumentException If the port number is illegal\n    */\n   public InetSocketAddress(String hostname, int port)\n     throws IllegalArgumentException\n   {\n     if (hostname == null)\n-      throw new IllegalArgumentException (\"Null host name value\");\n-    \n+      throw new IllegalArgumentException(\"Null host name value\");\n+\n     if (port < 0 || port > 65535)\n-      throw new IllegalArgumentException (\"Bad port number: \" + port);\n+      throw new IllegalArgumentException(\"Bad port number: \" + port);\n \n     this.port = port;\n     this.hostname = hostname;\n \n     try\n       {\n-        this.addr = InetAddress.getByName(hostname);\n+\tthis.addr = InetAddress.getByName(hostname);\n       }\n     catch (Exception e) // UnknownHostException, SecurityException\n       {\n-        this.addr = null;\n+\tthis.addr = null;\n       }\n   }\n- \n-  /** \n+\n+  /**\n    * Test if obj is a <code>InetSocketAddress</code> and\n    * has the same address and port\n    *\n    * @param obj The obj to compare this address with.\n    *\n-   * @return True if obj is equal.   \n+   * @return True if obj is equal.\n    */\n-  public final boolean equals (Object obj)\n+  public final boolean equals(Object obj)\n   {\n     // InetSocketAddress objects are equal when addr and port are equal.\n     // The hostname may differ.\n-\n     if (obj instanceof InetSocketAddress)\n       {\n-        InetSocketAddress sa = (InetSocketAddress) obj;\n-\t\n-        if (addr == null && sa.addr != null)\n-          return false;\n-        else if (addr == null && sa.addr == null)\n-          return hostname.equals (sa.hostname) && sa.port == port;\n-        else\n-          return addr.equals (sa.addr) && sa.port == port;\n+\tInetSocketAddress sa = (InetSocketAddress) obj;\n+\n+\tif (addr == null && sa.addr != null)\n+\t  return false;\n+\telse if (addr == null && sa.addr == null)\n+\t  return hostname.equals(sa.hostname) && sa.port == port;\n+\telse\n+\t  return addr.equals(sa.addr) && sa.port == port;\n       }\n-    \n+\n     return false;\n   }\n \n@@ -190,7 +188,7 @@ public final int getPort()\n   {\n     return port;\n   }\n-    \n+\n   /**\n    * Returns the hashcode of the <code>InetSocketAddress</code>\n    *\n@@ -210,7 +208,7 @@ public final boolean isUnresolved()\n   {\n     return addr == null;\n   }\n-    \n+\n   /**\n    * Returns the <code>InetSocketAddress</code> as string\n    *"}, {"sha": "96f214da8ac5359724c78f68c3fb2132c47fa09d", "filename": "libjava/java/net/JarURLConnection.java", "status": "modified", "additions": 25, "deletions": 26, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FJarURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FJarURLConnection.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,24 +35,24 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n import java.io.IOException;\n+import java.security.cert.Certificate;\n import java.util.jar.Attributes;\n import java.util.jar.JarEntry;\n import java.util.jar.JarFile;\n import java.util.jar.JarInputStream;\n import java.util.jar.Manifest;\n import java.util.zip.ZipEntry;\n-import java.security.cert.Certificate;\n+\n \n /**\n  * This abstract class represents a common superclass for implementations\n  * of jar URL's.  A jar URL is a special type of URL that allows JAR\n  * files on remote systems to be accessed.  It has the form:\n  * <p>\n- * jar:<standard URL pointing to jar file>!/file/within/jarfile\n+ * jar:&lt;standard URL pointing to jar filei&gt;!/file/within/jarfile\n  * <p> for example:\n  * <p>\n  * jar:http://www.urbanophile.com/java/foo.jar!/com/urbanophile/bar.class\n@@ -96,30 +96,29 @@ public abstract class JarURLConnection extends URLConnection\n   /**\n    * Creates a JarURLConnection from an URL object\n    *\n-   * @param URL url The URL object for this connection.\n+   * @param url The URL object for this connection.\n    *\n    * @exception MalformedURLException If url is invalid\n    *\n    * @specnote This constructor is protected since JDK 1.4\n    */\n-  protected JarURLConnection (URL url)\n-    throws MalformedURLException\n+  protected JarURLConnection(URL url) throws MalformedURLException\n   {\n-    super (url);\n+    super(url);\n \n-    if (!url.getProtocol().equals (\"jar\"))\n-      throw new MalformedURLException (url + \": Not jar protocol.\");\n+    if (! url.getProtocol().equals(\"jar\"))\n+      throw new MalformedURLException(url + \": Not jar protocol.\");\n \n     String spec = url.getFile();\n-    int bang = spec.indexOf (\"!/\");\n+    int bang = spec.indexOf(\"!/\");\n     if (bang == -1)\n-      throw new MalformedURLException (url + \": No `!/' in spec.\");\n+      throw new MalformedURLException(url + \": No `!/' in spec.\");\n \n     // Extract the url for the jar itself.\n-    jarFileURL = new URL (spec.substring (0, bang));\n+    jarFileURL = new URL(spec.substring(0, bang));\n \n     // Get the name of the entry, if any.\n-    entryName = spec.length() == (bang + 2) ? null : spec.substring (bang + 2);\n+    entryName = spec.length() == (bang + 2) ? null : spec.substring(bang + 2);\n   }\n \n   /**\n@@ -128,7 +127,7 @@ protected JarURLConnection (URL url)\n    *\n    * @return The remote URL\n    */\n-  public URL getJarFileURL ()\n+  public URL getJarFileURL()\n   {\n     return jarFileURL;\n   }\n@@ -140,19 +139,19 @@ public URL getJarFileURL ()\n    *\n    * @return The entry name.\n    */\n-  public String getEntryName ()\n+  public String getEntryName()\n   {\n     return entryName;\n   }\n \n   /**\n-   * Returns the entry in this jar file specified by the URL.  \n-   * \n+   * Returns the entry in this jar file specified by the URL.\n+   *\n    * @return The jar entry\n    *\n    * @exception IOException If an error occurs\n    */\n-  public JarEntry getJarEntry () throws IOException\n+  public JarEntry getJarEntry() throws IOException\n   {\n     JarFile jarfile = null;\n \n@@ -203,7 +202,7 @@ public JarEntry getJarEntry () throws IOException\n    *\n    * @exception IOException If an error occurs\n    */\n-  public abstract JarFile getJarFile () throws IOException;\n+  public abstract JarFile getJarFile() throws IOException;\n \n   /**\n    * Returns an array of Certificate objects for the jar file entry specified\n@@ -213,10 +212,10 @@ public JarEntry getJarEntry () throws IOException\n    *\n    * @exception IOException If an error occurs\n    */\n-  public Certificate[] getCertificates () throws IOException\n+  public Certificate[] getCertificates() throws IOException\n   {\n     JarEntry entry = getJarEntry();\n-    \n+\n     return entry != null ? entry.getCertificates() : null;\n   }\n \n@@ -228,10 +227,10 @@ public Certificate[] getCertificates () throws IOException\n    *\n    * @exception IOException If an error occurs\n    */\n-  public Attributes getMainAttributes () throws IOException\n+  public Attributes getMainAttributes() throws IOException\n   {\n     Manifest manifest = getManifest();\n-    \n+\n     return manifest != null ? manifest.getMainAttributes() : null;\n   }\n \n@@ -244,7 +243,7 @@ public Attributes getMainAttributes () throws IOException\n    *\n    * @exception IOException If an error occurs\n    */\n-  public Attributes getAttributes () throws IOException\n+  public Attributes getAttributes() throws IOException\n   {\n     JarEntry entry = getJarEntry();\n \n@@ -259,7 +258,7 @@ public Attributes getAttributes () throws IOException\n    *\n    * @exception IOException If an error occurs\n    */\n-  public Manifest getManifest () throws IOException\n+  public Manifest getManifest() throws IOException\n   {\n     JarFile file = getJarFile();\n "}, {"sha": "c9a50fa8650280527311fc4358ba137d58ba411d", "filename": "libjava/java/net/MalformedURLException.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FMalformedURLException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FMalformedURLException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FMalformedURLException.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -39,6 +39,7 @@\n \n import java.io.IOException;\n \n+\n /**\n  * This exception indicates that a URL passed to an object was not in a\n  * valid format."}, {"sha": "c177531f22f30e0a2d577f0b419a708869f0652b", "filename": "libjava/java/net/MulticastSocket.java", "status": "modified", "additions": 64, "deletions": 61, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FMulticastSocket.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -8,7 +8,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -41,21 +41,21 @@\n import java.io.IOException;\n import java.util.Enumeration;\n \n+\n /**\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n  */\n-\n /**\n  * This class models a multicast UDP socket.  A multicast address is a\n- * class D internet address (one whose most significant bits are 1110).  \n+ * class D internet address (one whose most significant bits are 1110).\n  * A multicast group consists of a multicast address and a well known\n  * port number.  All members of the group listening on that address and\n  * port will receive all the broadcasts to the group.\n  * <p>\n- * Please note that applets are not allowed to use multicast sockets \n- * \n+ * Please note that applets are not allowed to use multicast sockets\n+ *\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n@@ -111,10 +111,10 @@ public MulticastSocket(SocketAddress address) throws IOException\n     if (address != null)\n       bind(address);\n   }\n-  \n+\n   /**\n    * Returns the interface being used for multicast packets\n-   * \n+   *\n    * @return The multicast interface\n    *\n    * @exception SocketException If an error occurs\n@@ -131,7 +131,7 @@ public InetAddress getInterface() throws SocketException\n    * Returns the current value of the \"Time to Live\" option.  This is the\n    * number of hops a packet can make before it \"expires\".   This method id\n    * deprecated.  Use <code>getTimeToLive</code> instead.\n-   * \n+   *\n    * @return The TTL value\n    *\n    * @exception IOException If an error occurs\n@@ -153,8 +153,8 @@ public byte getTTL() throws IOException\n \n   /**\n    * Returns the current value of the \"Time to Live\" option.  This is the\n-   * number of hops a packet can make before it \"expires\". \n-   * \n+   * number of hops a packet can make before it \"expires\".\n+   *\n    * @return The TTL value\n    *\n    * @exception IOException If an error occurs\n@@ -189,12 +189,12 @@ public void setInterface(InetAddress addr) throws SocketException\n   /**\n    * Sets the local network interface used to send multicast messages\n    *\n-   * @param netIF The local network interface used to send multicast messages\n-   * \n+   * @param netIf The local network interface used to send multicast messages\n+   *\n    * @exception SocketException If an error occurs\n-   * \n+   *\n    * @see MulticastSocket#getNetworkInterface()\n-   * \n+   *\n    * @since 1.4\n    */\n   public void setNetworkInterface(NetworkInterface netIf)\n@@ -203,13 +203,13 @@ public void setNetworkInterface(NetworkInterface netIf)\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    Enumeration e = netIf.getInetAddresses ();\n+    Enumeration e = netIf.getInetAddresses();\n \n-    if (!e.hasMoreElements ())\n+    if (! e.hasMoreElements())\n       throw new SocketException(\"no network devices found\");\n \n-    InetAddress address = (InetAddress) e.nextElement ();\n-    getImpl().setOption (SocketOptions.IP_MULTICAST_IF, address);\n+    InetAddress address = (InetAddress) e.nextElement();\n+    getImpl().setOption(SocketOptions.IP_MULTICAST_IF, address);\n   }\n \n   /**\n@@ -220,26 +220,25 @@ public void setNetworkInterface(NetworkInterface netIf)\n    * @exception SocketException If an error occurs\n    *\n    * @see MulticastSocket#setNetworkInterface(NetworkInterface netIf)\n-   * \n+   *\n    * @since 1.4\n    */\n-  public NetworkInterface getNetworkInterface()\n-    throws SocketException\n+  public NetworkInterface getNetworkInterface() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n     InetAddress address =\n-      (InetAddress) getImpl().getOption (SocketOptions.IP_MULTICAST_IF);\n-    NetworkInterface netIf = NetworkInterface.getByInetAddress (address);\n+      (InetAddress) getImpl().getOption(SocketOptions.IP_MULTICAST_IF);\n+    NetworkInterface netIf = NetworkInterface.getByInetAddress(address);\n \n     return netIf;\n   }\n \n   /**\n    * Disable/Enable local loopback of multicast packets.  The option is used by\n    * the platform's networking code as a hint for setting whether multicast\n-   * data will be looped back to the local socket. \n+   * data will be looped back to the local socket.\n    *\n    * Because this option is a hint, applications that want to verify what\n    * loopback mode is set to should call #getLoopbackMode\n@@ -255,12 +254,15 @@ public void setLoopbackMode(boolean disable) throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    getImpl().setOption (SocketOptions.IP_MULTICAST_LOOP, Boolean.valueOf(disable));\n+    getImpl().setOption(SocketOptions.IP_MULTICAST_LOOP,\n+                        Boolean.valueOf(disable));\n   }\n \n   /**\n-   * Checks if local loopback mode is enabled or not\n+   * Checks if local loopback mode is enabled\n    *\n+   * @return true if loopback mode is enabled, false otherwise\n+   * \n    * @exception SocketException If an error occurs\n    *\n    * @since 1.4\n@@ -270,11 +272,11 @@ public boolean getLoopbackMode() throws SocketException\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n-    Object buf = getImpl().getOption (SocketOptions.IP_MULTICAST_LOOP);\n+    Object buf = getImpl().getOption(SocketOptions.IP_MULTICAST_LOOP);\n \n     if (buf instanceof Boolean)\n       return ((Boolean) buf).booleanValue();\n-    \n+\n     throw new SocketException(\"unexpected type\");\n   }\n \n@@ -303,12 +305,12 @@ public void setTTL(byte ttl) throws IOException\n \n   /**\n    * Sets the \"Time to Live\" value for a socket.  The value must be between\n-   * 1 and 255.  \n+   * 1 and 255.\n    *\n    * @param ttl The new TTL value\n    *\n    * @exception IOException If an error occurs\n-   * \n+   *\n    * @since 1.2\n    */\n   public void setTimeToLive(int ttl) throws IOException\n@@ -323,10 +325,10 @@ public void setTimeToLive(int ttl) throws IOException\n   }\n \n   /**\n-   * Joins the specified mulitcast group.\n+   * Joins the specified multicast group.\n+   *\n+   * @param mcastaddr The address of the group to join\n    *\n-   * @param addr The address of the group to join\n-   * \n    * @exception IOException If an error occurs\n    * @exception SecurityException If a security manager exists and its\n    * checkMulticast method doesn't allow the operation\n@@ -349,7 +351,7 @@ public void joinGroup(InetAddress mcastaddr) throws IOException\n   /**\n    * Leaves the specified multicast group\n    *\n-   * @param addr The address of the group to leave\n+   * @param mcastaddr The address of the group to leave\n    *\n    * @exception IOException If an error occurs\n    * @exception SecurityException If a security manager exists and its\n@@ -377,7 +379,7 @@ public void leaveGroup(InetAddress mcastaddr) throws IOException\n    * @param netIf The local network interface to receive the multicast\n    * messages on or null to defer the interface set by #setInterface or\n    * #setNetworkInterface\n-   * \n+   *\n    * @exception IOException If an error occurs\n    * @exception IllegalArgumentException If address type is not supported\n    * @exception SecurityException If a security manager exists and its\n@@ -395,26 +397,26 @@ public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n       throw new SocketException(\"socket is closed\");\n \n     if (! (mcastaddr instanceof InetSocketAddress))\n-      throw new IllegalArgumentException (\"SocketAddress type not supported\");\n+      throw new IllegalArgumentException(\"SocketAddress type not supported\");\n \n     InetSocketAddress tmp = (InetSocketAddress) mcastaddr;\n-    \n-    if (! tmp.getAddress ().isMulticastAddress ())\n-      throw new IOException (\"Not a Multicast address\");\n \n-    SecurityManager s = System.getSecurityManager ();\n+    if (! tmp.getAddress().isMulticastAddress())\n+      throw new IOException(\"Not a Multicast address\");\n+\n+    SecurityManager s = System.getSecurityManager();\n     if (s != null)\n-      s.checkMulticast (tmp.getAddress ());\n+      s.checkMulticast(tmp.getAddress());\n \n-    getImpl().joinGroup (mcastaddr, netIf);\n+    getImpl().joinGroup(mcastaddr, netIf);\n   }\n-  \n+\n   /**\n    * Leaves the specified mulitcast group on a specified interface.\n    *\n    * @param mcastaddr The multicast address to leave\n    * @param netIf The local networki interface or null to defer to the\n-   * interface set by setInterface or setNetworkInterface \n+   * interface set by setInterface or setNetworkInterface\n    *\n    * @exception IOException If an error occurs\n    * @exception IllegalArgumentException If address type is not supported\n@@ -433,17 +435,17 @@ public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n       throw new SocketException(\"socket is closed\");\n \n     InetSocketAddress tmp = (InetSocketAddress) mcastaddr;\n-    \n-    if (! tmp.getAddress ().isMulticastAddress ())\n-      throw new IOException (\"Not a Multicast address\");\n \n-    SecurityManager s = System.getSecurityManager ();\n+    if (! tmp.getAddress().isMulticastAddress())\n+      throw new IOException(\"Not a Multicast address\");\n+\n+    SecurityManager s = System.getSecurityManager();\n     if (s != null)\n-      s.checkMulticast (tmp.getAddress ());\n+      s.checkMulticast(tmp.getAddress());\n \n-    getImpl().leaveGroup (mcastaddr, netIf);\n+    getImpl().leaveGroup(mcastaddr, netIf);\n   }\n-  \n+\n   /**\n    * Sends a packet of data to a multicast address with a TTL that is\n    * different from the default TTL on this socket.  The default TTL for\n@@ -458,26 +460,27 @@ public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n    *\n    * @deprecated\n    */\n-  public synchronized void send(DatagramPacket p, byte ttl) throws IOException\n+  public synchronized void send(DatagramPacket packet, byte ttl)\n+    throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n     SecurityManager s = System.getSecurityManager();\n     if (s != null)\n       {\n-        InetAddress addr = p.getAddress();\n-        if (addr.isMulticastAddress())\n-          s.checkPermission (new SocketPermission\n-                             (addr.getHostName () + p.getPort (),\n-                              \"accept,connect\"));\n-        else\n-          s.checkConnect(addr.getHostAddress(), p.getPort());\n+\tInetAddress addr = packet.getAddress();\n+\tif (addr.isMulticastAddress())\n+\t  s.checkPermission(new SocketPermission(addr.getHostName()\n+\t                                         + packet.getPort(),\n+\t                                         \"accept,connect\"));\n+\telse\n+\t  s.checkConnect(addr.getHostAddress(), packet.getPort());\n       }\n \n     int oldttl = getImpl().getTimeToLive();\n     getImpl().setTimeToLive(((int) ttl) & 0xFF);\n-    getImpl().send(p);\n+    getImpl().send(packet);\n     getImpl().setTimeToLive(oldttl);\n   }\n-} // class MulticastSocket\n+}"}, {"sha": "38a15c48ab7a012d8e1057015962d2c16db58bd8", "filename": "libjava/java/net/NetPermission.java", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FNetPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FNetPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FNetPermission.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -39,22 +39,23 @@\n \n import java.security.BasicPermission;\n \n+\n /**\n  * This class is used to model miscellaneous network permissions.  It is\n- * a subclass of <code>BasicPermission</code>.  This means that it models a \n- * \"boolean\" permission.  One that you either have or do not have.  Thus \n- * there is no permitted action list associated with this object. \n+ * a subclass of <code>BasicPermission</code>.  This means that it models a\n+ * \"boolean\" permission.  One that you either have or do not have.  Thus\n+ * there is no permitted action list associated with this object.\n  *\n  * The following permission names are defined for this class:\n- * \n+ *\n  * <ul>\n  * <li>setDefaultAuthenticator - Grants the ability to install a facility\n- * to collect username and password information when requested by a \n- * web site or proxy server.\n+ * to collect username and password information when requested by a\n+ * web site or proxy server.</li>\n  * <li>requestPasswordAuthentication - Grants the ability to ask the\n- * authentication facility for the user's password.\n- * <li>specifyStreamHandler - Grants the permission to specify the \n- * stream handler class used when loading from a URL.\n+ * authentication facility for the user's password.</li>\n+ * <li>specifyStreamHandler - Grants the permission to specify the\n+ * stream handler class used when loading from a URL.</li>\n  * </ul>\n  *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n@@ -75,8 +76,8 @@ public NetPermission(String name)\n   }\n \n   /**\n-   * Initializes a new instance of <code>NetPermission</code> with the \n-   * specified name and perms.  Note that the perms field is irrelevant and is \n+   * Initializes a new instance of <code>NetPermission</code> with the\n+   * specified name and perms.  Note that the perms field is irrelevant and is\n    * ignored.  This constructor should never need to be used.\n    *\n    * @param name The name of this permission"}, {"sha": "e7f7290febcce735cd330e4e92e0b1015dfd25b9", "filename": "libjava/java/net/NetworkInterface.java", "status": "modified", "additions": 64, "deletions": 70, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FNetworkInterface.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FNetworkInterface.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FNetworkInterface.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -41,6 +41,7 @@\n import java.util.Enumeration;\n import java.util.Vector;\n \n+\n /**\n  * This class models a network interface on the host computer.  A network\n  * interface contains a name (typically associated with a specific\n@@ -54,79 +55,76 @@\n public final class NetworkInterface\n {\n   static\n-  {\n-    if (Configuration.INIT_LOAD_LIBRARY)\n-      {\n-\tSystem.loadLibrary (\"javanet\");\n-      }\n-  }\n+    {\n+      if (Configuration.INIT_LOAD_LIBRARY)\n+\tSystem.loadLibrary(\"javanet\");\n+    }\n \n   private String name;\n-  \n   private Vector inetAddresses;\n \n-  private NetworkInterface (String name, InetAddress address)\n+  private NetworkInterface(String name, InetAddress address)\n   {\n     this.name = name;\n-    this.inetAddresses = new Vector (1, 1);\n-    this.inetAddresses.add (address);\n+    this.inetAddresses = new Vector(1, 1);\n+    this.inetAddresses.add(address);\n   }\n \n-  private native static Vector getRealNetworkInterfaces ()\n+  private static native Vector getRealNetworkInterfaces()\n     throws SocketException;\n \n   /**\n    * Returns the name of the network interface\n    *\n    * @return The name of the interface.\n    */\n-  public String getName ()\n+  public String getName()\n   {\n     return name;\n   }\n \n   /**\n    *  Returns all available addresses of the network interface\n-   *  \n+   *\n    *  If a @see SecurityManager is available all addresses are checked\n    *  with @see SecurityManager::checkConnect() if they are available.\n-   *  Only <code>InetAddresses</code> are returned where the security manager \n+   *  Only <code>InetAddresses</code> are returned where the security manager\n    *  doesn't throw an exception.\n-   *  \n+   *\n    *  @return An enumeration of all addresses.\n    */\n-  public Enumeration getInetAddresses ()\n+  public Enumeration getInetAddresses()\n   {\n-    SecurityManager s = System.getSecurityManager ();\n+    SecurityManager s = System.getSecurityManager();\n \n     if (s == null)\n-      return inetAddresses.elements ();\n+      return inetAddresses.elements();\n \n-    Vector tmpInetAddresses = new Vector (1, 1);\n+    Vector tmpInetAddresses = new Vector(1, 1);\n \n-    for (Enumeration addresses = inetAddresses.elements ();\n-\t addresses.hasMoreElements (); )\n+    for (Enumeration addresses = inetAddresses.elements();\n+         addresses.hasMoreElements();)\n       {\n-\tInetAddress addr = (InetAddress) addresses.nextElement ();\n+\tInetAddress addr = (InetAddress) addresses.nextElement();\n \ttry\n \t  {\n-\t    s.checkConnect (addr.getHostAddress (), 58000);\n-\t    tmpInetAddresses.add (addr);\n+\t    s.checkConnect(addr.getHostAddress(), 58000);\n+\t    tmpInetAddresses.add(addr);\n \t  }\n \tcatch (SecurityException e)\n \t  {\n \t  }\n-    }\n+      }\n \n-    return tmpInetAddresses.elements ();\n+    return tmpInetAddresses.elements();\n   }\n \n   /**\n    *  Returns the display name of the interface\n    *\n    *  @return The display name of the interface\n    */\n-  public String getDisplayName ()\n+  public String getDisplayName()\n   {\n     return name;\n   }\n@@ -139,21 +137,20 @@ public String getDisplayName ()\n    *  @exception SocketException If an error occurs\n    *  @exception NullPointerException If the specified name is null\n    */\n-  public static NetworkInterface getByName (String name)\n+  public static NetworkInterface getByName(String name)\n     throws SocketException\n   {\n-    Vector networkInterfaces = getRealNetworkInterfaces ();\n+    Vector networkInterfaces = getRealNetworkInterfaces();\n \n-    for (Enumeration e = networkInterfaces.elements ();\n-         e.hasMoreElements (); )\n+    for (Enumeration e = networkInterfaces.elements(); e.hasMoreElements();)\n       {\n-        NetworkInterface tmp = (NetworkInterface) e.nextElement ();\n-      \n-        if (name.equals (tmp.getName ()))\n-          return tmp;\n+\tNetworkInterface tmp = (NetworkInterface) e.nextElement();\n+\n+\tif (name.equals(tmp.getName()))\n+\t  return tmp;\n       }\n \n-    throw new SocketException (\"no network interface with this name exists\");\n+    throw new SocketException(\"no network interface with this name exists\");\n   }\n \n   /**\n@@ -164,35 +161,33 @@ public static NetworkInterface getByName (String name)\n    *  @exception SocketException If an error occurs\n    *  @exception NullPointerException If the specified addess is null\n    */\n-  public static NetworkInterface getByInetAddress (InetAddress addr)\n+  public static NetworkInterface getByInetAddress(InetAddress addr)\n     throws SocketException\n   {\n-    Vector networkInterfaces = getRealNetworkInterfaces ();\n-    \n-    for (Enumeration interfaces = networkInterfaces.elements ();\n-         interfaces.hasMoreElements (); )\n+    Vector networkInterfaces = getRealNetworkInterfaces();\n+\n+    for (Enumeration interfaces = networkInterfaces.elements();\n+         interfaces.hasMoreElements();)\n       {\n-        NetworkInterface tmp = (NetworkInterface) interfaces.nextElement ();\n-      \n-        for (Enumeration addresses = tmp.inetAddresses.elements ();\n-             addresses.hasMoreElements (); )\n-          {\n-            if (addr.equals ((InetAddress) addresses.nextElement ()))\n-              return tmp;\n-          }\n+\tNetworkInterface tmp = (NetworkInterface) interfaces.nextElement();\n+\n+\tfor (Enumeration addresses = tmp.inetAddresses.elements();\n+\t     addresses.hasMoreElements();)\n+\t  {\n+\t    if (addr.equals((InetAddress) addresses.nextElement()))\n+\t      return tmp;\n+\t  }\n       }\n \n-    throw new SocketException (\n-      \"no network interface is bound to such an IP address\");\n+    throw new SocketException(\"no network interface is bound to such an IP address\");\n   }\n \n   /**\n    *  Return an <code>Enumeration</code> of all available network interfaces\n    *\n    *  @exception SocketException If an error occurs\n    */\n-  public static Enumeration getNetworkInterfaces ()\n-    throws SocketException\n+  public static Enumeration getNetworkInterfaces() throws SocketException\n   {\n     Vector networkInterfaces = getRealNetworkInterfaces();\n \n@@ -206,44 +201,43 @@ public static Enumeration getNetworkInterfaces ()\n    *  Checks if the current instance is equal to obj\n    *\n    *  @param obj The object to compare with\n-   */ \n-  public boolean equals (Object obj)\n+   */\n+  public boolean equals(Object obj)\n   {\n-    if (!(obj instanceof NetworkInterface))\n+    if (! (obj instanceof NetworkInterface))\n       return false;\n-   \n+\n     NetworkInterface tmp = (NetworkInterface) obj;\n \n-    return (name.equals (tmp.name)\n-            && inetAddresses.equals (tmp.inetAddresses));\n+    return (name.equals(tmp.name) && inetAddresses.equals(tmp.inetAddresses));\n   }\n \n   /**\n    *  Returns the hashcode of the current instance\n    */\n-  public int hashCode ()\n+  public int hashCode()\n   {\n     // FIXME: hash correctly\n-    return name.hashCode () + inetAddresses.hashCode ();\n+    return name.hashCode() + inetAddresses.hashCode();\n   }\n \n   /**\n    *  Returns a string representation of the interface\n    */\n-  public String toString ()\n+  public String toString()\n   {\n     // FIXME: check if this is correct\n     String result;\n-    String separator = System.getProperty (\"line.separator\");\n+    String separator = System.getProperty(\"line.separator\");\n \n-    result = \"name: \" + getDisplayName () + \" (\" + getName () +\n-\t     \") addresses:\" + separator;\n+    result =\n+      \"name: \" + getDisplayName() + \" (\" + getName() + \") addresses:\"\n+      + separator;\n \n-    for (Enumeration e = inetAddresses.elements ();\n-         e.hasMoreElements (); )\n+    for (Enumeration e = inetAddresses.elements(); e.hasMoreElements();)\n       {\n-        InetAddress address = (InetAddress) e.nextElement ();\n-        result += address.toString () + \";\" + separator;\n+\tInetAddress address = (InetAddress) e.nextElement();\n+\tresult += address.toString() + \";\" + separator;\n       }\n \n     return result;"}, {"sha": "d13389386591324c1842e378f9635d55d0e2b0b6", "filename": "libjava/java/net/NoRouteToHostException.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FNoRouteToHostException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FNoRouteToHostException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FNoRouteToHostException.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -35,9 +35,9 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n+\n /**\n   * This exception indicates that there is no TCP/IP route to the requested\n   * host.  This is often due to a misconfigured routing table."}, {"sha": "910803a8f3a505d9f5215235af9f5f14e0d4a1ea", "filename": "libjava/java/net/PasswordAuthentication.java", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FPasswordAuthentication.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FPasswordAuthentication.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPasswordAuthentication.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -37,6 +37,7 @@\n \n package java.net;\n \n+\n /**\n   * This class serves a container for username/password pairs.\n   *\n@@ -50,7 +51,7 @@\n    */\n \n   /**\n-    * The username \n+    * The username\n     */\n   private String username;\n \n@@ -66,7 +67,7 @@\n    */\n \n   /**\n-    * Creates a new <code>PasswordAuthentication</code> object from the \n+    * Creates a new <code>PasswordAuthentication</code> object from the\n     * specified username and password.\n     *\n     * @param username The username for this object\n@@ -91,18 +92,16 @@ public PasswordAuthentication(String username, char[] password)\n     */\n   public String getUserName()\n   {\n-    return(username);\n+    return (username);\n   }\n-   \n+\n   /**\n     * Returns the password associated with this object\n     *\n     * @return The password\n     */\n   public char[] getPassword()\n   {\n-    return(password);\n+    return (password);\n   }\n-\n } // class PasswordAuthentication\n-"}, {"sha": "def02636e58c68fdacb772eddfe5c5bc93081b40", "filename": "libjava/java/net/PortUnreachableException.java", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FPortUnreachableException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FPortUnreachableException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FPortUnreachableException.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -37,6 +37,7 @@\n \n package java.net;\n \n+\n /**\n  * This exception signals that an ICMP port unreachable datagram has been\n  * received.\n@@ -69,4 +70,3 @@ public PortUnreachableException(String message)\n     super(message);\n   }\n } // class PortUnreachableException\n-"}, {"sha": "d058113495e8f49184ae95c7778eccbc07ee0be2", "filename": "libjava/java/net/ProtocolException.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FProtocolException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FProtocolException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FProtocolException.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -39,6 +39,7 @@\n \n import java.io.IOException;\n \n+\n /**\n  * This exception indicates that some sort of low level protocol\n  * exception occurred.  Look in the descriptive message (if any) for"}, {"sha": "037421d682a56fb3c4d19c326ba5a2e328ab741c", "filename": "libjava/java/net/ServerSocket.java", "status": "modified", "additions": 114, "deletions": 103, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FServerSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FServerSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FServerSocket.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -8,7 +8,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,14 +36,14 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n import gnu.java.net.PlainSocketImpl;\n import java.io.IOException;\n import java.nio.channels.IllegalBlockingModeException;\n import java.nio.channels.ServerSocketChannel;\n \n+\n /* Written using on-line Java Platform 1.2 API Specification.\n  * Status:  I believe all methods are implemented.\n  */\n@@ -55,7 +55,7 @@\n  * server sockets are ready to communicate with one another utilizing\n  * whatever application layer protocol they desire.\n  *\n- * As with the <code>Socket</code> class, most instance methods of this class \n+ * As with the <code>Socket</code> class, most instance methods of this class\n  * simply redirect their calls to an implementation class.\n  *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n@@ -78,13 +78,14 @@\n    * True if socket is bound.\n    */\n   private boolean bound;\n-  \n+\n   /*\n    * This constructor is only used by java.nio.\n    */\n+\n   // FIXME: Workaround a bug in gcj.\n   //ServerSocket (PlainSocketImpl impl) throws IOException\n-  ServerSocket (SocketImpl impl) throws IOException\n+  ServerSocket(SocketImpl impl) throws IOException\n   {\n     if (impl == null)\n       throw new NullPointerException(\"impl may not be null\");\n@@ -96,16 +97,17 @@\n   /*\n    * This method is only used by java.nio.\n    */\n+\n   // FIXME: Workaround a bug in gcj.\n   //PlainSocketImpl getImpl()\n   SocketImpl getImpl()\n   {\n     return impl;\n   }\n-  \n+\n   /**\n    * Constructor that simply sets the implementation.\n-   * \n+   *\n    * @exception IOException If an error occurs\n    *\n    * @specnote This constructor is public since JDK 1.4\n@@ -126,13 +128,12 @@ public ServerSocket() throws IOException\n    * connection queue on this socket will be set to 50.\n    *\n    * @param port The port number to bind to\n-   * \n+   *\n    * @exception IOException If an error occurs\n    * @exception SecurityException If a security manager exists and its\n    * checkListen method doesn't allow the operation\n    */\n-  public ServerSocket (int port)\n-    throws IOException\n+  public ServerSocket(int port) throws IOException\n   {\n     this(port, 50);\n   }\n@@ -150,8 +151,7 @@ public ServerSocket (int port)\n    * @exception SecurityException If a security manager exists and its\n    * checkListen method doesn't allow the operation\n    */\n-  public ServerSocket (int port, int backlog)\n-    throws IOException\n+  public ServerSocket(int port, int backlog) throws IOException\n   {\n     this(port, backlog, null);\n   }\n@@ -173,13 +173,13 @@ public ServerSocket (int port, int backlog)\n    *\n    * @since 1.1\n    */\n-  public ServerSocket (int port, int backlog, InetAddress bindAddr)\n+  public ServerSocket(int port, int backlog, InetAddress bindAddr)\n     throws IOException\n   {\n     this();\n \n     // bind/listen socket\n-    bind (new InetSocketAddress (bindAddr, port), backlog);\n+    bind(new InetSocketAddress(bindAddr, port), backlog);\n   }\n \n   /**\n@@ -191,48 +191,48 @@ public ServerSocket (int port, int backlog, InetAddress bindAddr)\n    * @exception IllegalArgumentException If address type is not supported\n    * @exception SecurityException If a security manager exists and its\n    * checkListen method doesn't allow the operation\n-   * \n+   *\n    * @since 1.4\n    */\n-  public void bind (SocketAddress endpoint)\n-    throws IOException\n+  public void bind(SocketAddress endpoint) throws IOException\n   {\n-    bind (endpoint, 50);\n+    bind(endpoint, 50);\n   }\n- \n+\n   /**\n    * Binds the server socket to a specified socket address\n    *\n    * @param endpoint The socket address to bind to\n    * @param backlog The length of the pending connection queue\n-   * \n+   *\n    * @exception IOException If an error occurs\n    * @exception IllegalArgumentException If address type is not supported\n    * @exception SecurityException If a security manager exists and its\n    * checkListen method doesn't allow the operation\n    *\n    * @since 1.4\n    */\n-  public void bind (SocketAddress endpoint, int backlog) throws IOException\n+  public void bind(SocketAddress endpoint, int backlog)\n+    throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"ServerSocket is closed\");\n-    \n+\n     if (! (endpoint instanceof InetSocketAddress))\n-      throw new IllegalArgumentException (\"Address type not supported\");\n+      throw new IllegalArgumentException(\"Address type not supported\");\n \n     InetSocketAddress tmp = (InetSocketAddress) endpoint;\n \n-    SecurityManager s = System.getSecurityManager ();\n+    SecurityManager s = System.getSecurityManager();\n     if (s != null)\n-      s.checkListen (tmp.getPort ());\n+      s.checkListen(tmp.getPort());\n \n     InetAddress addr = tmp.getAddress();\n-    \n+\n     // Initialize addr with 0.0.0.0.\n     if (addr == null)\n       addr = InetAddress.ANY_IF;\n-    \n+\n     try\n       {\n \timpl.bind(addr, tmp.getPort());\n@@ -241,39 +241,39 @@ public void bind (SocketAddress endpoint, int backlog) throws IOException\n       }\n     catch (IOException exception)\n       {\n-        close();\n-        throw exception;\n+\tclose();\n+\tthrow exception;\n       }\n     catch (RuntimeException exception)\n       {\n-        close();\n-        throw exception;\n+\tclose();\n+\tthrow exception;\n       }\n     catch (Error error)\n       {\n-        close();\n-        throw error;\n+\tclose();\n+\tthrow error;\n       }\n   }\n-  \n+\n   /**\n    * This method returns the local address to which this socket is bound\n    *\n    * @return The socket's local address\n    */\n   public InetAddress getInetAddress()\n   {\n-    if (!isBound())\n+    if (! isBound())\n       return null;\n-    \n+\n     try\n       {\n-        return (InetAddress) impl.getOption (SocketOptions.SO_BINDADDR);\n+\treturn (InetAddress) impl.getOption(SocketOptions.SO_BINDADDR);\n       }\n     catch (SocketException e)\n       {\n-        // This never happens as we are bound.\n-        return null;\n+\t// This never happens as we are bound.\n+\treturn null;\n       }\n   }\n \n@@ -284,30 +284,34 @@ public InetAddress getInetAddress()\n    */\n   public int getLocalPort()\n   {\n-    if (!isBound())\n+    if (! isBound())\n       return -1;\n-    \n+\n     return impl.getLocalPort();\n   }\n \n   /**\n    * Returns the local socket address\n    *\n+   * @return the local socket address, null if not bound\n+   * \n    * @since 1.4\n    */\n   public SocketAddress getLocalSocketAddress()\n   {\n-    if (!isBound())\n+    if (! isBound())\n       return null;\n-    \n+\n     return new InetSocketAddress(getInetAddress(), getLocalPort());\n   }\n \n   /**\n-   * Accepts a new connection and returns a connected <code>Socket</code> \n-   * instance representing that connection.  This method will block until a \n+   * Accepts a new connection and returns a connected <code>Socket</code>\n+   * instance representing that connection.  This method will block until a\n    * connection is available.\n    *\n+   * @return socket object for the just accepted connection\n+   *\n    * @exception IOException If an error occurs\n    * @exception SecurityException If a security manager exists and its\n    * checkListen method doesn't allow the operation\n@@ -316,17 +320,17 @@ public SocketAddress getLocalSocketAddress()\n    * @exception SocketTimeoutException If a timeout was previously set with\n    * setSoTimeout and the timeout has been reached\n    */\n-  public Socket accept () throws IOException\n+  public Socket accept() throws IOException\n   {\n-    SecurityManager sm = System.getSecurityManager ();\n+    SecurityManager sm = System.getSecurityManager();\n     if (sm != null)\n-      sm.checkListen (impl.getLocalPort ());\n+      sm.checkListen(impl.getLocalPort());\n \n     Socket socket = new Socket();\n-    \n+\n     try\n       {\n-        implAccept(socket);\n+\timplAccept(socket);\n       }\n     catch (IOException e)\n       {\n@@ -337,15 +341,15 @@ public Socket accept () throws IOException\n \tcatch (IOException e2)\n \t  {\n \t  }\n-\t\n+\n \tthrow e;\n       }\n-    \n+\n     return socket;\n   }\n \n   /**\n-   * This protected method is used to help subclasses override \n+   * This protected method is used to help subclasses override\n    * <code>ServerSocket.accept()</code>.  The passed in socket will be\n    * connected when this method returns.\n    *\n@@ -357,12 +361,11 @@ public Socket accept () throws IOException\n    *\n    * @since 1.1\n    */\n-  protected final void implAccept (Socket socket)\n-    throws IOException\n+  protected final void implAccept(Socket socket) throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"ServerSocket is closed\");\n-    \n+\n     // The Sun spec says that if we have an associated channel and\n     // it is in non-blocking mode, we throw an IllegalBlockingModeException.\n     // However, in our implementation if the channel itself initiated this\n@@ -380,11 +383,11 @@ protected final void implAccept (Socket socket)\n    *\n    * @exception IOException If an error occurs\n    */\n-  public void close () throws IOException\n+  public void close() throws IOException\n   {\n     if (isClosed())\n       return;\n-    \n+\n     impl.close();\n     impl = null;\n     bound = false;\n@@ -399,6 +402,8 @@ public void close () throws IOException\n    *\n    * The socket only has a ServerSocketChannel if its created\n    * by ServerSocketChannel.open.\n+   *\n+   * @return the associated socket channel, null if none exists\n    * \n    * @since 1.4\n    */\n@@ -409,6 +414,8 @@ public ServerSocketChannel getChannel()\n \n   /**\n    * Returns true when the socket is bound, otherwise false\n+   *\n+   * @return true if socket is bound, false otherwise\n    * \n    * @since 1.4\n    */\n@@ -419,6 +426,8 @@ public boolean isBound()\n \n   /**\n    * Returns true if the socket is closed, otherwise false\n+   *\n+   * @return true if socket is closed, false otherwise\n    * \n    * @since 1.4\n    */\n@@ -429,7 +438,7 @@ public boolean isClosed()\n \n   /**\n    * Sets the value of SO_TIMEOUT.  A value of 0 implies that SO_TIMEOUT is\n-   * disabled (ie, operations never time out).  This is the number of \n+   * disabled (ie, operations never time out).  This is the number of\n    * milliseconds a socket operation can block before an\n    * InterruptedIOException is thrown.\n    *\n@@ -439,11 +448,11 @@ public boolean isClosed()\n    *\n    * @since 1.1\n    */\n-  public void setSoTimeout (int timeout) throws SocketException\n+  public void setSoTimeout(int timeout) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"ServerSocket is closed\");\n-    \n+\n     if (timeout < 0)\n       throw new IllegalArgumentException(\"SO_TIMEOUT value must be >= 0\");\n \n@@ -462,113 +471,113 @@ public void setSoTimeout (int timeout) throws SocketException\n    *\n    * @since 1.1\n    */\n-  public int getSoTimeout () throws IOException\n+  public int getSoTimeout() throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"ServerSocket is closed\");\n-    \n+\n     Object timeout = impl.getOption(SocketOptions.SO_TIMEOUT);\n \n-    if (!(timeout instanceof Integer))\n+    if (! (timeout instanceof Integer))\n       throw new IOException(\"Internal Error\");\n \n-    return ((Integer)timeout).intValue();\n+    return ((Integer) timeout).intValue();\n   }\n \n   /**\n    * Enables/Disables the SO_REUSEADDR option\n+   *\n+   * @param on true if SO_REUSEADDR should be enabled, false otherwise\n    * \n    * @exception SocketException If an error occurs\n-   * \n+   *\n    * @since 1.4\n    */\n-  public void setReuseAddress (boolean on)\n-    throws SocketException\n+  public void setReuseAddress(boolean on) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"ServerSocket is closed\");\n-    \n-    impl.setOption (SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));\n+\n+    impl.setOption(SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));\n   }\n \n   /**\n    * Checks if the SO_REUSEADDR option is enabled\n-   * \n+   *\n+   * @return true if SO_REUSEADDR is set, false otherwise\n+   *\n    * @exception SocketException If an error occurs\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean getReuseAddress()\n-    throws SocketException\n+  public boolean getReuseAddress() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"ServerSocket is closed\");\n-    \n-    Object reuseaddr = impl.getOption (SocketOptions.SO_REUSEADDR);\n \n-    if (!(reuseaddr instanceof Boolean))\n-      throw new SocketException (\"Internal Error\");\n-    \n-    return ((Boolean) reuseaddr).booleanValue ();\n+    Object reuseaddr = impl.getOption(SocketOptions.SO_REUSEADDR);\n+\n+    if (! (reuseaddr instanceof Boolean))\n+      throw new SocketException(\"Internal Error\");\n+\n+    return ((Boolean) reuseaddr).booleanValue();\n   }\n \n   /**\n    * This method sets the value for the system level socket option\n    * SO_RCVBUF to the specified value.  Note that valid values for this\n    * option are specific to a given operating system.\n-   * \n+   *\n    * @param size The new receive buffer size.\n-   * \n+   *\n    * @exception SocketException If an error occurs or Socket is not connected\n    * @exception IllegalArgumentException If size is 0 or negative\n    *\n    * @since 1.4\n    */\n-  public void setReceiveBufferSize (int size)\n-    throws SocketException\n+  public void setReceiveBufferSize(int size) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"ServerSocket is closed\");\n-    \n+\n     if (size <= 0)\n-      throw new IllegalArgumentException (\"SO_RCVBUF value must be > 0\");\n+      throw new IllegalArgumentException(\"SO_RCVBUF value must be > 0\");\n \n-    impl.setOption (SocketOptions.SO_RCVBUF, new Integer (size));\n+    impl.setOption(SocketOptions.SO_RCVBUF, new Integer(size));\n   }\n \n   /**\n    * This method returns the value of the system level socket option\n    * SO_RCVBUF, which is used by the operating system to tune buffer\n    * sizes for data transfers.\n-   * \n+   *\n    * @return The receive buffer size.\n-   *             \n+   *\n    * @exception SocketException If an error occurs or Socket is not connected\n-   * \n+   *\n    * @since 1.4\n    */\n-  public int getReceiveBufferSize ()\n-    throws SocketException\n+  public int getReceiveBufferSize() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"ServerSocket is closed\");\n-    \n-    Object buf = impl.getOption (SocketOptions.SO_RCVBUF);\n \n-    if (!(buf instanceof Integer))\n-      throw new SocketException (\"Internal Error: Unexpected type\");\n-    \n-    return ((Integer) buf).intValue ();\n+    Object buf = impl.getOption(SocketOptions.SO_RCVBUF);\n+\n+    if (! (buf instanceof Integer))\n+      throw new SocketException(\"Internal Error: Unexpected type\");\n+\n+    return ((Integer) buf).intValue();\n   }\n \n   /**\n-   * Returns the value of this socket as a <code>String</code>. \n+   * Returns the value of this socket as a <code>String</code>.\n    *\n    * @return This socket represented as a <code>String</code>.\n    */\n-  public String toString ()\n+  public String toString()\n   {\n-    if (!isBound())\n+    if (! isBound())\n       return \"ServerSocket[unbound]\";\n     \n     return (\"ServerSocket[addr=\" + getInetAddress()\n@@ -578,19 +587,21 @@ public String toString ()\n   }\n \n   /**\n-   * Sets the <code>SocketImplFactory</code> for all \n+   * Sets the <code>SocketImplFactory</code> for all\n    * <code>ServerSocket</code>'s.  This may only be done\n    * once per virtual machine.  Subsequent attempts will generate an\n    * exception.  Note that a <code>SecurityManager</code> check is made prior\n    * to setting the factory.  If insufficient privileges exist to set the\n    * factory, an exception will be thrown\n    *\n+   * @param fac the factory to set\n+   *\n    * @exception SecurityException If this operation is not allowed by the\n    * <code>SecurityManager</code>.\n    * @exception SocketException If the factory object is already defined\n    * @exception IOException If any other error occurs\n    */\n-  public static synchronized void setSocketFactory (SocketImplFactory fac)\n+  public static synchronized void setSocketFactory(SocketImplFactory fac)\n     throws IOException\n   {\n     factory = fac;"}, {"sha": "789e4061662041d5e5fbdb12b508bc3773830f4d", "filename": "libjava/java/net/Socket.java", "status": "modified", "additions": 225, "deletions": 221, "changes": 446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -8,7 +8,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -36,15 +36,15 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n import gnu.java.net.PlainSocketImpl;\n-import java.io.InputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.io.OutputStream;\n-import java.nio.channels.SocketChannel;\n import java.nio.channels.IllegalBlockingModeException;\n+import java.nio.channels.SocketChannel;\n+\n \n /* Written using on-line Java Platform 1.2 API Specification.\n  * Status:  I believe all methods are implemented.\n@@ -56,11 +56,11 @@\n  * <p>\n  * This class does not actually do any work.  Instead, it redirects all of\n  * its calls to a socket implementation object which implements the\n- * <code>SocketImpl</code> interface.  The implementation class is \n- * instantiated by factory class that implements the \n+ * <code>SocketImpl</code> interface.  The implementation class is\n+ * instantiated by factory class that implements the\n  * <code>SocketImplFactory interface</code>.  A default\n  * factory is provided, however the factory may be set by a call to\n- * the <code>setSocketImplFactory</code> method.  Note that this may only be \n+ * the <code>setSocketImplFactory</code> method.  Note that this may only be\n  * done once per virtual machine.  If a subsequent attempt is made to set the\n  * factory, a <code>SocketException</code> will be thrown.\n  *\n@@ -81,7 +81,8 @@\n   private SocketImpl impl;\n \n   /**\n-   * True if socket implementation was created by calling their create() method.\n+   * True if socket implementation was created by calling their\n+   * create() method.\n    */\n   private boolean implCreated;\n \n@@ -101,14 +102,14 @@\n   private boolean outputShutdown;\n \n   /**\n-   * Initializes a new instance of <code>Socket</code> object without \n-   * connecting to a remote host.  This useful for subclasses of socket that \n+   * Initializes a new instance of <code>Socket</code> object without\n+   * connecting to a remote host.  This useful for subclasses of socket that\n    * might want this behavior.\n    *\n    * @specnote This constructor is public since JDK 1.4\n    * @since 1.1\n    */\n-  public Socket ()\n+  public Socket()\n   {\n     if (factory != null)\n       impl = factory.createSocketImpl();\n@@ -119,7 +120,7 @@ public Socket ()\n   /**\n    * Initializes a new instance of <code>Socket</code> object without\n    * connecting to a remote host.  This is useful for subclasses of socket\n-   * that might want this behavior.  \n+   * that might want this behavior.\n    * <p>\n    * Additionally, this socket will be created using the supplied\n    * implementation class instead the default class or one returned by a\n@@ -133,7 +134,7 @@ public Socket ()\n    *\n    * @since 1.1\n    */\n-  protected Socket (SocketImpl impl) throws SocketException\n+  protected Socket(SocketImpl impl) throws SocketException\n   {\n     if (impl == null)\n       this.impl = new PlainSocketImpl();\n@@ -142,7 +143,7 @@ protected Socket (SocketImpl impl) throws SocketException\n   }\n \n   /**\n-   * Initializes a new instance of <code>Socket</code> and connects to the \n+   * Initializes a new instance of <code>Socket</code> and connects to the\n    * hostname and port specified as arguments.\n    *\n    * @param host The name of the host to connect to\n@@ -154,14 +155,14 @@ protected Socket (SocketImpl impl) throws SocketException\n    * @exception SecurityException If a security manager exists and its\n    * checkConnect method doesn't allow the operation\n    */\n-  public Socket (String host, int port)\n+  public Socket(String host, int port)\n     throws UnknownHostException, IOException\n   {\n     this(InetAddress.getByName(host), port, null, 0, true);\n   }\n \n   /**\n-   * Initializes a new instance of <code>Socket</code> and connects to the \n+   * Initializes a new instance of <code>Socket</code> and connects to the\n    * address and port number specified as arguments.\n    *\n    * @param address The address to connect to\n@@ -171,15 +172,14 @@ public Socket (String host, int port)\n    * @exception SecurityException If a security manager exists and its\n    * checkConnect method doesn't allow the operation\n    */\n-  public Socket (InetAddress address, int port)\n-    throws IOException \n+  public Socket(InetAddress address, int port) throws IOException\n   {\n     this(address, port, null, 0, true);\n   }\n \n   /**\n-   * Initializes a new instance of <code>Socket</code> that connects to the \n-   * named host on the specified port and binds to the specified local address \n+   * Initializes a new instance of <code>Socket</code> that connects to the\n+   * named host on the specified port and binds to the specified local address\n    * and port.\n    *\n    * @param host The name of the remote host to connect to.\n@@ -194,15 +194,15 @@ public Socket (InetAddress address, int port)\n    *\n    * @since 1.1\n    */\n-  public Socket (String host, int port,\n-\t\t InetAddress localAddr, int localPort) throws IOException\n+  public Socket(String host, int port, InetAddress localAddr, int localPort)\n+    throws IOException\n   {\n     this(InetAddress.getByName(host), port, localAddr, localPort, true);\n   }\n \n   /**\n-   * Initializes a new instance of <code>Socket</code> and connects to the \n-   * address and port number specified as arguments, plus binds to the \n+   * Initializes a new instance of <code>Socket</code> and connects to the\n+   * address and port number specified as arguments, plus binds to the\n    * specified local address and port.\n    *\n    * @param address The remote address to connect to\n@@ -216,16 +216,16 @@ public Socket (String host, int port,\n    *\n    * @since 1.1\n    */\n-  public Socket (InetAddress address, int port,\n-\t\t InetAddress localAddr, int localPort) throws IOException\n+  public Socket(InetAddress address, int port, InetAddress localAddr,\n+                int localPort) throws IOException\n   {\n     this(address, port, localAddr, localPort, true);\n   }\n \n   /**\n-   * Initializes a new instance of <code>Socket</code> and connects to the \n-   * hostname and port specified as arguments.  If the stream argument is set \n-   * to <code>true</code>, then a stream socket is created.  If it is \n+   * Initializes a new instance of <code>Socket</code> and connects to the\n+   * hostname and port specified as arguments.  If the stream argument is set\n+   * to <code>true</code>, then a stream socket is created.  If it is\n    * <code>false</code>, a datagram socket is created.\n    *\n    * @param host The name of the host to connect to\n@@ -240,20 +240,21 @@ public Socket (InetAddress address, int port,\n    * @deprecated Use the <code>DatagramSocket</code> class to create\n    * datagram oriented sockets.\n    */\n-  public Socket (String host, int port, boolean stream) throws IOException\n+  public Socket(String host, int port, boolean stream)\n+    throws IOException\n   {\n     this(InetAddress.getByName(host), port, null, 0, stream);\n   }\n \n   /**\n-   * Initializes a new instance of <code>Socket</code> and connects to the \n-   * address and port number specified as arguments.  If the stream param is \n-   * <code>true</code>, a stream socket will be created, otherwise a datagram \n+   * Initializes a new instance of <code>Socket</code> and connects to the\n+   * address and port number specified as arguments.  If the stream param is\n+   * <code>true</code>, a stream socket will be created, otherwise a datagram\n    * socket is created.\n    *\n    * @param host The address to connect to\n    * @param port The port number to connect to\n-   * @param stream <code>true</code> to create a stream socket, \n+   * @param stream <code>true</code> to create a stream socket,\n    * <code>false</code> to create a datagram socket.\n    *\n    * @exception IOException If an error occurs\n@@ -263,7 +264,8 @@ public Socket (String host, int port, boolean stream) throws IOException\n    * @deprecated Use the <code>DatagramSocket</code> class to create\n    * datagram oriented sockets.\n    */\n-  public Socket (InetAddress host, int port, boolean stream) throws IOException\n+  public Socket(InetAddress host, int port, boolean stream)\n+    throws IOException\n   {\n     this(host, port, null, 0, stream);\n   }\n@@ -296,24 +298,23 @@ private Socket(InetAddress raddr, int rport, InetAddress laddr, int lport,\n \n     // bind socket\n     SocketAddress bindaddr =\n-      laddr == null ? null : new InetSocketAddress (laddr, lport);\n-    bind (bindaddr);\n-    \n+      laddr == null ? null : new InetSocketAddress(laddr, lport);\n+    bind(bindaddr);\n+\n     // connect socket\n-    connect (new InetSocketAddress (raddr, rport));\n+    connect(new InetSocketAddress(raddr, rport));\n \n     // FIXME: JCL p. 1586 says if localPort is unspecified, bind to any port,\n     // i.e. '0' and if localAddr is unspecified, use getLocalAddress() as\n     // that default.  JDK 1.2 doc infers not to do a bind.\n   }\n \n   // This has to be accessible from java.net.ServerSocket.\n-  SocketImpl getImpl()\n-    throws SocketException\n+  SocketImpl getImpl() throws SocketException\n   {\n     try\n       {\n-\tif (!implCreated)\n+\tif (! implCreated)\n \t  {\n \t    impl.create(true);\n \t    implCreated = true;\n@@ -336,47 +337,47 @@ SocketImpl getImpl()\n    * @exception SecurityException If a security manager exists and its\n    * checkConnect method doesn't allow the operation\n    * @exception IllegalArgumentException If the address type is not supported\n-   * \n+   *\n    * @since 1.4\n    */\n-  public void bind (SocketAddress bindpoint) throws IOException\n+  public void bind(SocketAddress bindpoint) throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n \n     // XXX: JDK 1.4.1 API documentation says that if bindpoint is null the\n     // socket will be bound to an ephemeral port and a valid local address.\n     if (bindpoint == null)\n-      bindpoint = new InetSocketAddress (InetAddress.ANY_IF, 0);\n-    \n-    if ( !(bindpoint instanceof InetSocketAddress))\n-      throw new IllegalArgumentException ();\n+      bindpoint = new InetSocketAddress(InetAddress.ANY_IF, 0);\n+\n+    if (! (bindpoint instanceof InetSocketAddress))\n+      throw new IllegalArgumentException();\n \n     InetSocketAddress tmp = (InetSocketAddress) bindpoint;\n-    \n+\n     // bind to address/port\n     try\n       {\n-        getImpl().bind (tmp.getAddress(), tmp.getPort());\n+\tgetImpl().bind(tmp.getAddress(), tmp.getPort());\n \tbound = true;\n       }\n     catch (IOException exception)\n       {\n-        close ();\n-        throw exception;\n+\tclose();\n+\tthrow exception;\n       }\n     catch (RuntimeException exception)\n       {\n-        close ();\n-        throw exception;\n+\tclose();\n+\tthrow exception;\n       }\n     catch (Error error)\n       {\n-        close ();\n-        throw error;\n+\tclose();\n+\tthrow error;\n       }\n   }\n-  \n+\n   /**\n    * Connects the socket with a remote address.\n    *\n@@ -386,13 +387,12 @@ public void bind (SocketAddress bindpoint) throws IOException\n    * @exception IllegalArgumentException If the addess type is not supported\n    * @exception IllegalBlockingModeException If this socket has an associated\n    * channel, and the channel is in non-blocking mode\n-   * \n+   *\n    * @since 1.4\n    */\n-  public void connect (SocketAddress endpoint)\n-    throws IOException\n+  public void connect(SocketAddress endpoint) throws IOException\n   {\n-    connect (endpoint, 0);\n+    connect(endpoint, 0);\n   }\n \n   /**\n@@ -401,56 +401,55 @@ public void connect (SocketAddress endpoint)\n    * until established or an error occurs.\n    *\n    * @param endpoint The address to connect to\n-   * @param timeout The length of the timeout in milliseconds, or \n+   * @param timeout The length of the timeout in milliseconds, or\n    * 0 to indicate no timeout.\n    *\n    * @exception IOException If an error occurs\n    * @exception IllegalArgumentException If the address type is not supported\n    * @exception IllegalBlockingModeException If this socket has an associated\n    * channel, and the channel is in non-blocking mode\n    * @exception SocketTimeoutException If the timeout is reached\n-   * \n+   *\n    * @since 1.4\n    */\n-  public void connect (SocketAddress endpoint, int timeout)\n+  public void connect(SocketAddress endpoint, int timeout)\n     throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     if (! (endpoint instanceof InetSocketAddress))\n       throw new IllegalArgumentException(\"unsupported address type\");\n \n     // The Sun spec says that if we have an associated channel and\n     // it is in non-blocking mode, we throw an IllegalBlockingModeException.\n     // However, in our implementation if the channel itself initiated this\n     // operation, then we must honor it regardless of its blocking mode.\n-    if (getChannel() != null\n-        && !getChannel().isBlocking ()\n-        && !((PlainSocketImpl) getImpl()).isInChannelOperation())\n-      throw new IllegalBlockingModeException ();\n-  \n-    if (!isBound ())\n-      bind (null);\n+    if (getChannel() != null && ! getChannel().isBlocking()\n+        && ! ((PlainSocketImpl) getImpl()).isInChannelOperation())\n+      throw new IllegalBlockingModeException();\n+\n+    if (! isBound())\n+      bind(null);\n \n     try\n       {\n-        getImpl().connect (endpoint, timeout);\n+\tgetImpl().connect(endpoint, timeout);\n       }\n     catch (IOException exception)\n       {\n-        close ();\n-        throw exception;\n+\tclose();\n+\tthrow exception;\n       }\n     catch (RuntimeException exception)\n       {\n-        close ();\n-        throw exception;\n+\tclose();\n+\tthrow exception;\n       }\n     catch (Error error)\n       {\n-        close ();\n-        throw error;\n+\tclose();\n+\tthrow error;\n       }\n   }\n \n@@ -460,9 +459,9 @@ public void connect (SocketAddress endpoint, int timeout)\n    *\n    * @return The remote address this socket is connected to\n    */\n-  public InetAddress getInetAddress ()\n+  public InetAddress getInetAddress()\n   {\n-    if (!isConnected())\n+    if (! isConnected())\n       return null;\n \n     try\n@@ -485,20 +484,20 @@ public InetAddress getInetAddress ()\n    *\n    * @since 1.1\n    */\n-  public InetAddress getLocalAddress ()\n+  public InetAddress getLocalAddress()\n   {\n     InetAddress addr = null;\n-    \n+\n     try\n       {\n-        addr = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);\n+\taddr = (InetAddress) getImpl().getOption(SocketOptions.SO_BINDADDR);\n       }\n-    catch(SocketException e)\n+    catch (SocketException e)\n       {\n-        // (hopefully) shouldn't happen\n-        // throw new java.lang.InternalError\n-        //      (\"Error in PlainSocketImpl.getOption\");\n-        return null;\n+\t// (hopefully) shouldn't happen\n+\t// throw new java.lang.InternalError\n+\t//      (\"Error in PlainSocketImpl.getOption\");\n+\treturn null;\n       }\n \n     // FIXME: According to libgcj, checkConnect() is supposed to be called\n@@ -519,9 +518,9 @@ public InetAddress getLocalAddress ()\n    *\n    * @return The remote port this socket is connected to\n    */\n-  public int getPort ()\n+  public int getPort()\n   {\n-    if (!isConnected())\n+    if (! isConnected())\n       return 0;\n \n     try\n@@ -543,11 +542,11 @@ public int getPort ()\n    *\n    * @return The local port\n    */\n-  public int getLocalPort ()\n+  public int getLocalPort()\n   {\n-    if (!isBound())\n+    if (! isBound())\n       return -1;\n-    \n+\n     try\n       {\n \tif (getImpl() != null)\n@@ -562,21 +561,22 @@ public int getLocalPort ()\n   }\n \n   /**\n-   * If the socket is already bound this returns the local SocketAddress,\n-   * otherwise null\n+   * Returns local socket address.\n+   *\n+   * @return the local socket address, null if not bound\n    *\n    * @since 1.4\n    */\n   public SocketAddress getLocalSocketAddress()\n   {\n-    if (!isBound())\n+    if (! isBound())\n       return null;\n-    \n-    InetAddress addr = getLocalAddress ();\n+\n+    InetAddress addr = getLocalAddress();\n \n     try\n       {\n-\treturn new InetSocketAddress (addr, getImpl().getLocalPort());\n+\treturn new InetSocketAddress(addr, getImpl().getLocalPort());\n       }\n     catch (SocketException e)\n       {\n@@ -586,19 +586,21 @@ public SocketAddress getLocalSocketAddress()\n   }\n \n   /**\n-   * If the socket is already connected this returns the remote SocketAddress,\n-   * otherwise null\n+   * Returns the remote socket address.\n+   *\n+   * @return the remote socket address, null of not connected\n    *\n    * @since 1.4\n    */\n   public SocketAddress getRemoteSocketAddress()\n   {\n-    if (!isConnected ())\n+    if (! isConnected())\n       return null;\n \n     try\n       {\n-\treturn new InetSocketAddress (getImpl().getInetAddress (), getImpl().getPort ());\n+\treturn new InetSocketAddress(getImpl().getInetAddress(),\n+\t                             getImpl().getPort());\n       }\n     catch (SocketException e)\n       {\n@@ -614,14 +616,14 @@ public SocketAddress getRemoteSocketAddress()\n    *\n    * @exception IOException If an error occurs or Socket is not connected\n    */\n-  public InputStream getInputStream () throws IOException\n+  public InputStream getInputStream() throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n-    if (!isConnected())\n+\n+    if (! isConnected())\n       throw new IOException(\"not connected\");\n-\t    \n+\n     return getImpl().getInputStream();\n   }\n \n@@ -632,42 +634,42 @@ public InputStream getInputStream () throws IOException\n    *\n    * @exception IOException If an error occurs or Socket is not connected\n    */\n-  public OutputStream getOutputStream () throws IOException\n+  public OutputStream getOutputStream() throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n-    if (!isConnected())\n+\n+    if (! isConnected())\n       throw new IOException(\"not connected\");\n-    \n+\n     return getImpl().getOutputStream();\n   }\n \n   /**\n-   * Sets the TCP_NODELAY option on the socket. \n+   * Sets the TCP_NODELAY option on the socket.\n    *\n    * @param on true to enable, false to disable\n-   * \n+   *\n    * @exception SocketException If an error occurs or Socket is not connected\n    *\n    * @since 1.1\n    */\n-  public void setTcpNoDelay (boolean on)  throws SocketException\n+  public void setTcpNoDelay(boolean on) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     getImpl().setOption(SocketOptions.TCP_NODELAY, Boolean.valueOf(on));\n   }\n \n   /**\n-   * Tests whether or not the TCP_NODELAY option is set on the socket. \n+   * Tests whether or not the TCP_NODELAY option is set on the socket.\n    * Returns true if enabled, false if disabled. When on it disables the\n    * Nagle algorithm which means that packets are always send immediatly and\n    * never merged together to reduce network trafic.\n    *\n    * @return Whether or not TCP_NODELAY is set\n-   * \n+   *\n    * @exception SocketException If an error occurs or Socket not connected\n    *\n    * @since 1.1\n@@ -676,25 +678,25 @@ public boolean getTcpNoDelay() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     Object on = getImpl().getOption(SocketOptions.TCP_NODELAY);\n-  \n+\n     if (on instanceof Boolean)\n-      return(((Boolean)on).booleanValue());\n+      return (((Boolean) on).booleanValue());\n     else\n       throw new SocketException(\"Internal Error\");\n   }\n \n   /**\n-   * Sets the value of the SO_LINGER option on the socket.  If the \n+   * Sets the value of the SO_LINGER option on the socket.  If the\n    * SO_LINGER option is set on a socket and there is still data waiting to\n    * be sent when the socket is closed, then the close operation will block\n    * until either that data is delivered or until the timeout period\n    * expires.  The linger interval is specified in hundreths of a second\n    * (platform specific?)\n    *\n    * @param on true to enable SO_LINGER, false to disable\n-   * @param linger The SO_LINGER timeout in hundreths of a second or -1 if \n+   * @param linger The SO_LINGER timeout in hundreths of a second or -1 if\n    * SO_LINGER not set.\n    *\n    * @exception SocketException If an error occurs or Socket not connected\n@@ -706,33 +708,31 @@ public void setSoLinger(boolean on, int linger) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n-    if (on == true)\n+\n+    if (on)\n       {\n-        if (linger < 0)\n-          throw new IllegalArgumentException(\"SO_LINGER must be >= 0\");\n+\tif (linger < 0)\n+\t  throw new IllegalArgumentException(\"SO_LINGER must be >= 0\");\n \n-        if (linger > 65535)\n-          linger = 65535;\n+\tif (linger > 65535)\n+\t  linger = 65535;\n \n-        getImpl().setOption(SocketOptions.SO_LINGER, new Integer(linger));\n+\tgetImpl().setOption(SocketOptions.SO_LINGER, new Integer(linger));\n       }\n     else\n-      {\n-        getImpl().setOption(SocketOptions.SO_LINGER, Boolean.valueOf(false));\n-      }\n+      getImpl().setOption(SocketOptions.SO_LINGER, Boolean.valueOf(false));\n   }\n \n   /**\n-   * Returns the value of the SO_LINGER option on the socket.  If the \n+   * Returns the value of the SO_LINGER option on the socket.  If the\n    * SO_LINGER option is set on a socket and there is still data waiting to\n    * be sent when the socket is closed, then the close operation will block\n    * until either that data is delivered or until the timeout period\n    * expires.  This method either returns the timeouts (in hundredths of\n    * of a second (platform specific?)) if SO_LINGER is set, or -1 if\n    * SO_LINGER is not set.\n    *\n-   * @return The SO_LINGER timeout in hundreths of a second or -1 \n+   * @return The SO_LINGER timeout in hundreths of a second or -1\n    * if SO_LINGER not set\n    *\n    * @exception SocketException If an error occurs or Socket is not connected\n@@ -743,11 +743,11 @@ public int getSoLinger() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     Object linger = getImpl().getOption(SocketOptions.SO_LINGER);\n \n     if (linger instanceof Integer)\n-      return(((Integer)linger).intValue());\n+      return (((Integer) linger).intValue());\n     else\n       return -1;\n   }\n@@ -762,78 +762,78 @@ public int getSoLinger() throws SocketException\n    *\n    * @since 1.4\n    */\n-  public void sendUrgentData (int data) throws IOException\n+  public void sendUrgentData(int data) throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n-    getImpl().sendUrgentData (data);\n+\n+    getImpl().sendUrgentData(data);\n   }\n \n   /**\n    * Enables/disables the SO_OOBINLINE option\n-   * \n-   * @param on True if SO_OOBLINE should be enabled \n-   * \n+   *\n+   * @param on True if SO_OOBLINE should be enabled\n+   *\n    * @exception SocketException If an error occurs\n-   * \n+   *\n    * @since 1.4\n    */\n-  public void setOOBInline (boolean on) throws SocketException\n+  public void setOOBInline(boolean on) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     getImpl().setOption(SocketOptions.SO_OOBINLINE, Boolean.valueOf(on));\n   }\n \n   /**\n    * Returns the current setting of the SO_OOBINLINE option for this socket\n-   * \n+   *\n    * @return True if SO_OOBINLINE is set, false otherwise.\n    *\n    * @exception SocketException If an error occurs\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean getOOBInline () throws SocketException\n+  public boolean getOOBInline() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     Object buf = getImpl().getOption(SocketOptions.SO_OOBINLINE);\n \n     if (buf instanceof Boolean)\n-      return(((Boolean)buf).booleanValue());\n+      return (((Boolean) buf).booleanValue());\n     else\n       throw new SocketException(\"Internal Error: Unexpected type\");\n   }\n-  \n+\n   /**\n    * Sets the value of the SO_TIMEOUT option on the socket.  If this value\n    * is set, and an read/write is performed that does not complete within\n    * the timeout period, a short count is returned (or an EWOULDBLOCK signal\n    * would be sent in Unix if no data had been read).  A value of 0 for\n-   * this option implies that there is no timeout (ie, operations will \n+   * this option implies that there is no timeout (ie, operations will\n    * block forever).  On systems that have separate read and write timeout\n    * values, this method returns the read timeout.  This\n    * value is in milliseconds.\n    *\n-   * @param timeout The length of the timeout in milliseconds, or \n+   * @param timeout The length of the timeout in milliseconds, or\n    * 0 to indicate no timeout.\n    *\n    * @exception SocketException If an error occurs or Socket not connected\n    *\n    * @since 1.1\n    */\n-  public synchronized void setSoTimeout (int timeout) throws SocketException\n+  public synchronized void setSoTimeout(int timeout) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     if (timeout < 0)\n       throw new IllegalArgumentException(\"SO_TIMEOUT value must be >= 0\");\n-      \n+\n     getImpl().setOption(SocketOptions.SO_TIMEOUT, new Integer(timeout));\n   }\n \n@@ -842,26 +842,26 @@ public synchronized void setSoTimeout (int timeout) throws SocketException\n    * is set, and an read/write is performed that does not complete within\n    * the timeout period, a short count is returned (or an EWOULDBLOCK signal\n    * would be sent in Unix if no data had been read).  A value of 0 for\n-   * this option implies that there is no timeout (ie, operations will \n+   * this option implies that there is no timeout (ie, operations will\n    * block forever).  On systems that have separate read and write timeout\n    * values, this method returns the read timeout.  This\n    * value is in thousandths of a second (implementation specific?).\n    *\n-   * @return The length of the timeout in thousandth's of a second or 0 \n+   * @return The length of the timeout in thousandth's of a second or 0\n    * if not set\n    *\n    * @exception SocketException If an error occurs or Socket not connected\n    *\n    * @since 1.1\n    */\n-  public synchronized int getSoTimeout () throws SocketException\n+  public synchronized int getSoTimeout() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     Object timeout = getImpl().getOption(SocketOptions.SO_TIMEOUT);\n     if (timeout instanceof Integer)\n-      return(((Integer)timeout).intValue());\n+      return (((Integer) timeout).intValue());\n     else\n       return 0;\n   }\n@@ -878,14 +878,14 @@ public synchronized int getSoTimeout () throws SocketException\n    *\n    * @since 1.2\n    */\n-  public void setSendBufferSize (int size) throws SocketException\n+  public void setSendBufferSize(int size) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     if (size <= 0)\n       throw new IllegalArgumentException(\"SO_SNDBUF value must be > 0\");\n-    \n+\n     getImpl().setOption(SocketOptions.SO_SNDBUF, new Integer(size));\n   }\n \n@@ -900,15 +900,15 @@ public void setSendBufferSize (int size) throws SocketException\n    *\n    * @since 1.2\n    */\n-  public int getSendBufferSize () throws SocketException\n+  public int getSendBufferSize() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     Object buf = getImpl().getOption(SocketOptions.SO_SNDBUF);\n \n     if (buf instanceof Integer)\n-      return(((Integer)buf).intValue());\n+      return (((Integer) buf).intValue());\n     else\n       throw new SocketException(\"Internal Error: Unexpected type\");\n   }\n@@ -925,14 +925,14 @@ public int getSendBufferSize () throws SocketException\n    *\n    * @since 1.2\n    */\n-  public void setReceiveBufferSize (int size) throws SocketException\n+  public void setReceiveBufferSize(int size) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     if (size <= 0)\n       throw new IllegalArgumentException(\"SO_RCVBUF value must be > 0\");\n-      \n+\n     getImpl().setOption(SocketOptions.SO_RCVBUF, new Integer(size));\n   }\n \n@@ -947,15 +947,15 @@ public void setReceiveBufferSize (int size) throws SocketException\n    *\n    * @since 1.2\n    */\n-  public int getReceiveBufferSize () throws SocketException\n+  public int getReceiveBufferSize() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     Object buf = getImpl().getOption(SocketOptions.SO_RCVBUF);\n \n     if (buf instanceof Integer)\n-      return(((Integer)buf).intValue());\n+      return (((Integer) buf).intValue());\n     else\n       throw new SocketException(\"Internal Error: Unexpected type\");\n   }\n@@ -970,11 +970,11 @@ public int getReceiveBufferSize () throws SocketException\n    *\n    * @since 1.3\n    */\n-  public void setKeepAlive (boolean on) throws SocketException\n+  public void setKeepAlive(boolean on) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     getImpl().setOption(SocketOptions.SO_KEEPALIVE, Boolean.valueOf(on));\n   }\n \n@@ -988,15 +988,15 @@ public void setKeepAlive (boolean on) throws SocketException\n    *\n    * @since 1.3\n    */\n-  public boolean getKeepAlive () throws SocketException\n+  public boolean getKeepAlive() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     Object buf = getImpl().getOption(SocketOptions.SO_KEEPALIVE);\n \n     if (buf instanceof Boolean)\n-      return(((Boolean)buf).booleanValue());\n+      return (((Boolean) buf).booleanValue());\n     else\n       throw new SocketException(\"Internal Error: Unexpected type\");\n   }\n@@ -1006,11 +1006,11 @@ public boolean getKeepAlive () throws SocketException\n    *\n    * @exception IOException If an error occurs\n    */\n-  public synchronized void close ()  throws IOException\n+  public synchronized void close() throws IOException\n   {\n     if (isClosed())\n       return;\n-    \n+\n     getImpl().close();\n     impl = null;\n     bound = false;\n@@ -1024,15 +1024,14 @@ public synchronized void close ()  throws IOException\n    *\n    * @return The <code>String</code> representation of this <code>Socket</code>\n    */\n-  public String toString ()\n+  public String toString()\n   {\n     try\n       {\n \tif (isConnected())\n-\t  return (\"Socket[addr=\" + getImpl().getInetAddress()\n-\t\t  + \",port=\" + getImpl().getPort()\n-\t\t  + \",localport=\" + getImpl().getLocalPort()\n-\t\t  + \"]\");\n+\t  return (\"Socket[addr=\" + getImpl().getInetAddress() + \",port=\"\n+\t         + getImpl().getPort() + \",localport=\"\n+\t         + getImpl().getLocalPort() + \"]\");\n       }\n     catch (SocketException e)\n       {\n@@ -1043,19 +1042,21 @@ public String toString ()\n   }\n \n   /**\n-   * Sets the <code>SocketImplFactory</code>.  This may be done only once per \n-   * virtual machine.  Subsequent attempts will generate a \n+   * Sets the <code>SocketImplFactory</code>.  This may be done only once per\n+   * virtual machine.  Subsequent attempts will generate a\n    * <code>SocketException</code>.  Note that a <code>SecurityManager</code>\n-   * check is made prior to setting the factory.  If \n-   * insufficient privileges exist to set the factory, then an \n+   * check is made prior to setting the factory.  If\n+   * insufficient privileges exist to set the factory, then an\n    * <code>IOException</code> will be thrown.\n    *\n+   * @param fac the factory to set\n+   *\n    * @exception SecurityException If the <code>SecurityManager</code> does\n    * not allow this operation.\n    * @exception SocketException If the SocketImplFactory is already defined\n    * @exception IOException If any other error occurs\n    */\n-  public static synchronized void setSocketImplFactory (SocketImplFactory fac)\n+  public static synchronized void setSocketImplFactory(SocketImplFactory fac)\n     throws IOException\n   {\n     // See if already set\n@@ -1084,7 +1085,7 @@ public void shutdownInput() throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     getImpl().shutdownInput();\n     inputShutdown = true;\n   }\n@@ -1100,15 +1101,16 @@ public void shutdownOutput() throws IOException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     getImpl().shutdownOutput();\n     outputShutdown = true;\n   }\n \n   /**\n    * Returns the socket channel associated with this socket.\n    *\n-   * It returns null if no associated socket exists.\n+   * @return the associated socket channel,\n+   * null if no associated channel exists\n    *\n    * @since 1.4\n    */\n@@ -1126,55 +1128,57 @@ public SocketChannel getChannel()\n    *\n    * @since 1.4\n    */\n-  public boolean getReuseAddress () throws SocketException\n+  public boolean getReuseAddress() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n-    Object reuseaddr = getImpl().getOption (SocketOptions.SO_REUSEADDR);\n \n-    if (!(reuseaddr instanceof Boolean))\n-      throw new SocketException (\"Internal Error\");\n+    Object reuseaddr = getImpl().getOption(SocketOptions.SO_REUSEADDR);\n \n-    return ((Boolean) reuseaddr).booleanValue ();\n+    if (! (reuseaddr instanceof Boolean))\n+      throw new SocketException(\"Internal Error\");\n+\n+    return ((Boolean) reuseaddr).booleanValue();\n   }\n \n   /**\n    * Enables/Disables the SO_REUSEADDR option\n    *\n-   * @param reuseAddress True if SO_REUSEADDR should be set.\n-   * \n+   * @param reuseAddress true if SO_REUSEADDR should be enabled,\n+   * false otherwise\n+   *\n    * @exception SocketException If an error occurs\n    *\n    * @since 1.4\n    */\n-  public void setReuseAddress (boolean on) throws SocketException\n+  public void setReuseAddress(boolean reuseAddress) throws SocketException\n   {\n-    getImpl().setOption (SocketOptions.SO_REUSEADDR, Boolean.valueOf(on));\n+    getImpl().setOption(SocketOptions.SO_REUSEADDR,\n+                        Boolean.valueOf(reuseAddress));\n   }\n \n   /**\n    * Returns the current traffic class\n    *\n    * @return The current traffic class.\n-   * \n+   *\n    * @exception SocketException If an error occurs\n    *\n    * @see Socket#setTrafficClass(int tc)\n    *\n    * @since 1.4\n    */\n-  public int getTrafficClass () throws SocketException\n+  public int getTrafficClass() throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     Object obj = getImpl().getOption(SocketOptions.IP_TOS);\n \n     if (obj instanceof Integer)\n-      return ((Integer) obj).intValue ();\n+      return ((Integer) obj).intValue();\n     else\n-      throw new SocketException (\"Unexpected type\");\n+      throw new SocketException(\"Unexpected type\");\n   }\n \n   /**\n@@ -1189,15 +1193,15 @@ public int getTrafficClass () throws SocketException\n    *\n    * @since 1.4\n    */\n-  public void setTrafficClass (int tc) throws SocketException\n+  public void setTrafficClass(int tc) throws SocketException\n   {\n     if (isClosed())\n       throw new SocketException(\"socket is closed\");\n-    \n+\n     if (tc < 0 || tc > 255)\n       throw new IllegalArgumentException();\n \n-    getImpl().setOption (SocketOptions.IP_TOS, new Integer (tc));\n+    getImpl().setOption(SocketOptions.IP_TOS, new Integer(tc));\n   }\n \n   /**\n@@ -1207,11 +1211,11 @@ public void setTrafficClass (int tc) throws SocketException\n    *\n    * @since 1.4\n    */\n-  public boolean isConnected ()\n+  public boolean isConnected()\n   {\n     try\n       {\n-\treturn getImpl().getInetAddress () != null;\n+\treturn getImpl().getInetAddress() != null;\n       }\n     catch (SocketException e)\n       {\n@@ -1226,19 +1230,19 @@ public boolean isConnected ()\n    *\n    * @since 1.4\n    */\n-  public boolean isBound ()\n+  public boolean isBound()\n   {\n     return bound;\n   }\n \n   /**\n    * Checks if the socket is closed.\n-   * \n+   *\n    * @return True if socket is closed, false otherwise.\n    *\n    * @since 1.4\n    */\n-  public boolean isClosed ()\n+  public boolean isClosed()\n   {\n     return impl == null;\n   }\n@@ -1247,10 +1251,10 @@ public boolean isClosed ()\n    * Checks if the socket's input stream is shutdown\n    *\n    * @return True if input is shut down.\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isInputShutdown ()\n+  public boolean isInputShutdown()\n   {\n     return inputShutdown;\n   }\n@@ -1259,10 +1263,10 @@ public boolean isInputShutdown ()\n    * Checks if the socket's output stream is shutdown\n    *\n    * @return True if output is shut down.\n-   * \n+   *\n    * @since 1.4\n    */\n-  public boolean isOutputShutdown ()\n+  public boolean isOutputShutdown()\n   {\n     return outputShutdown;\n   }"}, {"sha": "d8239a416955c8fc9eecf2b686ff4cea9161aa79", "filename": "libjava/java/net/SocketAddress.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketAddress.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -1,4 +1,4 @@\n-/* SocketAddress.java -- \n+/* SocketAddress.java --\n    Copyright (C) 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -39,7 +39,8 @@\n \n import java.io.Serializable;\n \n-/** \n+\n+/**\n  * Abstract base class for InetSocketAddress.\n  * InetSocketAddress is to my knowledge the only derived\n  * class. [Ronald]"}, {"sha": "6b863606630d7a7a704ff5e2dcc1663988efdec1", "filename": "libjava/java/net/SocketException.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketException.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -39,6 +39,7 @@\n \n import java.io.IOException;\n \n+\n /**\n  * This exception indicates that a generic error occurred related to an\n  * operation on a socket.  Check the descriptive message (if any) for"}, {"sha": "8cfb9ef5a1d2a2490db32beca11afee885ac5daa", "filename": "libjava/java/net/SocketImpl.java", "status": "modified", "additions": 35, "deletions": 20, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketImpl.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -36,14 +36,14 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n import java.io.FileDescriptor;\n-import java.io.InputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.io.OutputStream;\n \n+\n /* Written using on-line Java Platform 1.2 API Specification.\n  * Believed complete and correct.\n  */\n@@ -113,7 +113,8 @@ public SocketImpl()\n    *\n    * @exception IOException If an error occurs\n    */\n-  protected abstract void connect(String host, int port) throws IOException;\n+  protected abstract void connect(String host, int port)\n+    throws IOException;\n \n   /**\n    * Connects to the remote address and port specified as arguments.\n@@ -153,7 +154,8 @@ protected abstract void connect(SocketAddress address, int timeout)\n    *\n    * @exception IOException If an error occurs\n    */\n-  protected abstract void bind(InetAddress host, int port) throws IOException;\n+  protected abstract void bind(InetAddress host, int port)\n+    throws IOException;\n \n   /**\n    * Starts listening for connections on a socket. The backlog parameter\n@@ -220,26 +222,38 @@ protected abstract void connect(SocketAddress address, int timeout)\n    *\n    * @return A FileDescriptor for this socket.\n    */\n-  protected FileDescriptor getFileDescriptor() { return fd; }\n+  protected FileDescriptor getFileDescriptor()\n+  {\n+    return fd;\n+  }\n \n   /**\n    * Returns the remote address this socket is connected to\n    *\n    * @return The remote address\n    */\n-  protected InetAddress getInetAddress() { return address; }\n+  protected InetAddress getInetAddress()\n+  {\n+    return address;\n+  }\n \n   /**\n    * Returns the remote port this socket is connected to\n    *\n    * @return The remote port\n    */\n-  protected int getPort() { return port; }\n+  protected int getPort()\n+  {\n+    return port;\n+  }\n \n   /**\n    * Returns true or false when this socket supports sending urgent data\n    * or not.\n    *\n+   * @return true if the socket implementation supports sending urgent data,\n+   * false otherwise\n+   *\n    * @since 1.4\n    */\n   protected boolean supportsUrgentData()\n@@ -248,7 +262,7 @@ protected boolean supportsUrgentData()\n     // sending urgend data.\n     return false;\n   }\n-  \n+\n   /**\n    * Sends one byte of urgent data to the socket.\n    *\n@@ -258,15 +272,17 @@ protected boolean supportsUrgentData()\n    *\n    * @since 1.4\n    */\n-  protected abstract void sendUrgentData(int data)\n-    throws IOException;\n-  \n+  protected abstract void sendUrgentData(int data) throws IOException;\n+\n   /**\n    * Returns the local port this socket is bound to\n    *\n    * @return The local port\n    */\n-  protected int getLocalPort() { return localport; }\n+  protected int getLocalPort()\n+  {\n+    return localport;\n+  }\n \n   /**\n    * Returns a <code>String</code> representing the remote host and port of\n@@ -276,10 +292,9 @@ protected abstract void sendUrgentData(int data)\n    */\n   public String toString()\n   {\n-    return \"[addr=\" + ((address == null) ? \"0.0.0.0/0.0.0.0\" :\n- \t\t       address.toString())\n-\t    + \",port=\" + port\n-\t    + \",localport=\" + localport + \"]\";\n+    return \"[addr=\"\n+           + ((address == null) ? \"0.0.0.0/0.0.0.0\" : address.toString())\n+           + \",port=\" + port + \",localport=\" + localport + \"]\";\n   }\n \n   /**\n@@ -288,9 +303,9 @@ public String toString()\n    *\n    * @exception IOException if an error occurs\n    */\n-  protected void shutdownInput () throws IOException\n+  protected void shutdownInput() throws IOException\n   {\n-    throw new IOException (\"Not implemented in this socket class\");\n+    throw new IOException(\"Not implemented in this socket class\");\n   }\n \n   /**\n@@ -299,8 +314,8 @@ protected void shutdownInput () throws IOException\n    *\n    * @exception IOException if an error occurs\n    */\n-  protected void shutdownOutput () throws IOException\n+  protected void shutdownOutput() throws IOException\n   {\n-    throw new IOException (\"Not implemented in this socket class\");\n+    throw new IOException(\"Not implemented in this socket class\");\n   }\n }"}, {"sha": "84e92a521f16da8b43dbbf0128f5b132a28e5b23", "filename": "libjava/java/net/SocketImplFactory.java", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketImplFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketImplFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketImplFactory.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,13 +35,12 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n+\n /** Written using on-line Java Platform 1.2 API Specification.\n   * Status:  Believed complete and correct.\n   */\n-\n /**\n   * This interface defines one method which returns a <code>SocketImpl</code>\n   * object.  This should not be needed by ordinary applications.\n@@ -57,6 +56,4 @@\n     * @return A <code>SocketImpl</code> object\n     */\n   SocketImpl createSocketImpl();\n-\n } // interface SocketImplFactory\n-"}, {"sha": "7ccd887cc6811b714534f776bfd93d3782bd57d2", "filename": "libjava/java/net/SocketOptions.java", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketOptions.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketOptions.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketOptions.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -1,5 +1,5 @@\n /* SocketOptions.java -- Implements options for sockets (duh!)\n-   Copyright (C) 1998, 1999, 2000, 2001, \n+   Copyright (C) 1998, 1999, 2000, 2001,\n                  2002, 2003 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -8,7 +8,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -38,15 +38,15 @@\n \n package java.net;\n \n+\n /**\n  * Written using on-line Java Platform 1.2 API Specification.\n  * Status:  Believed complete and correct.\n  */\n-\n /**\n- * This interface is used by <code>SocketImpl</code> and \n+ * This interface is used by <code>SocketImpl</code> and\n  * <code>DatagramSocketImpl</code> to implement options\n- * on sockets.  \n+ * on sockets.\n  *\n  * @since 1.2\n  *\n@@ -163,6 +163,4 @@\n    * @exception SocketException If an error occurs\n    */\n   Object getOption(int optionId) throws SocketException;\n-\n } // interface SocketOptions\n-"}, {"sha": "e9d1402a7d420c8e9200afeedf18ebadc92e92c9", "filename": "libjava/java/net/SocketPermission.java", "status": "modified", "additions": 113, "deletions": 96, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketPermission.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketPermission.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketPermission.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -1,5 +1,5 @@\n /* SocketPermission.java -- Class modeling permissions for socket operations\n-   Copyright (C) 1998, 2000, 2001, 2002 Free Software Foundation, Inc.\n+   Copyright (C) 1998, 2000, 2001, 2002, 2004  Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n@@ -41,6 +41,7 @@\n import java.security.Permission;\n import java.security.PermissionCollection;\n \n+\n /**\n  * This class models a specific set of permssions for connecting to a\n  * host.  There are two elements to this, the host/port combination and\n@@ -64,18 +65,20 @@\n  * value for a port (respectively) is used by default.  Here are some\n  * examples:\n  * <p><ul>\n- * <li>8080 - Represents port 8080 only\n- * <li>2000-3000 - Represents ports 2000 through 3000 inclusive\n- * <li>-4000 - Represents ports 0 through 4000 inclusive\n- * <li>1024- - Represents ports 1024 through 65535 inclusive\n+ * <li>8080 - Represents port 8080 only</li>\n+ * <li>2000-3000 - Represents ports 2000 through 3000 inclusive</li>\n+ * <li>-4000 - Represents ports 0 through 4000 inclusive</li>\n+ * <li>1024- - Represents ports 1024 through 65535 inclusive</li>\n  * </ul><p>\n  * The permission list is a comma separated list of individual permissions.\n  * These individual permissions are:\n  * <p>\n- * accept<br>\n- * connect<br>\n- * listen<br>\n- * resolve<br>\n+ * <pre>\n+ * accept\n+ * connect\n+ * listen\n+ * resolve\n+ * </pre>\n  * <p>\n  * The \"listen\" permission is only relevant if the host is localhost.  If\n  * any permission at all is specified, then resolve permission is implied to\n@@ -103,12 +106,12 @@\n  *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n  */\n-public final class SocketPermission extends Permission\n-  implements Serializable\n+public final class SocketPermission extends Permission implements Serializable\n {\n   static final long serialVersionUID = -7204263841984476862L;\n \n // FIXME: Needs serialization work, including readObject/writeObject methods.\n+\n   /**\n    * A hostname/port combination as described above\n    */\n@@ -120,7 +123,7 @@ public final class SocketPermission extends Permission\n   private String actions;\n \n   /**\n-   * Initializes a new instance of <code>SocketPermission</code> with the \n+   * Initializes a new instance of <code>SocketPermission</code> with the\n    * specified host/port combination and actions string.\n    *\n    * @param hostport The hostname/port number combination\n@@ -136,18 +139,18 @@ public SocketPermission(String hostport, String actions)\n \n   /**\n    * Tests this object for equality against another.  This will be true if\n-   * and only if the passed object is an instance of \n-   * <code>SocketPermission</code> and both its hostname/port combination \n+   * and only if the passed object is an instance of\n+   * <code>SocketPermission</code> and both its hostname/port combination\n    * and permissions string are identical.\n    *\n    * @param obj The object to test against for equality\n    *\n-   * @return <code>true</code> if object is equal to this object, \n+   * @return <code>true</code> if object is equal to this object,\n    *         <code>false</code> otherwise.\n    */\n   public boolean equals(Object obj)\n   {\n-    if (!(obj instanceof SocketPermission))\n+    if (! (obj instanceof SocketPermission))\n       return (false);\n \n     if (((SocketPermission) obj).hostport.equals(hostport))\n@@ -158,7 +161,7 @@ public boolean equals(Object obj)\n   }\n \n   /**\n-   * Returns a hash code value for this object.  Overrides the \n+   * Returns a hash code value for this object.  Overrides the\n    * <code>Permission.hashCode()</code>.\n    *\n    * @return A hash code\n@@ -192,21 +195,21 @@ public String getActions()\n \n     if (actions.indexOf(\"listen\") != -1)\n       if (found)\n-\t  sb.append(\",listen\");\n+\tsb.append(\",listen\");\n       else\n-\t{\n+        {\n \t  sb.append(\"listen\");\n \t  found = true;\n-\t}\n+        }\n \n     if (actions.indexOf(\"accept\") != -1)\n       if (found)\n \tsb.append(\",accept\");\n       else\n-\t{\n+        {\n \t  sb.append(\"accept\");\n \t  found = true;\n-\t}\n+        }\n \n     if (found)\n       sb.append(\",resolve\");\n@@ -231,25 +234,27 @@ public PermissionCollection newPermissionCollection()\n \n   /**\n    * Returns true if the permission object passed it is implied by the\n-   * this permission.  This will be true if \n-   * <p><ul>\n-   * <li>The argument is of type <code>SocketPermission</code>\n-   * <li>The actions list of the argument are in this object's actions\n-   * <li>The port range of the argument is within this objects port range\n-   * <li>The hostname is equal to or a subset of this objects hostname\n+   * this permission.  This will be true if:\n+   * \n+   * <ul>\n+   * <li>The argument is of type <code>SocketPermission</code></li>\n+   * <li>The actions list of the argument are in this object's actions</li>\n+   * <li>The port range of the argument is within this objects port range</li>\n+   * <li>The hostname is equal to or a subset of this objects hostname</li>\n    * </ul>\n-   * <p>\n-   * The argument's hostname will be a subset of this object's hostname if:\n-   * <p><ul>\n-   * <li>The argument's hostname or IP address is equal to this object's.\n-   * <li>The argument's canonical hostname is equal to this object's.\n+   *\n+   * <p>The argument's hostname will be a subset of this object's hostname if:</p>\n+   * \n+   * <ul>\n+   * <li>The argument's hostname or IP address is equal to this object's.</li>\n+   * <li>The argument's canonical hostname is equal to this object's.</li>\n    * <li>The argument's canonical name matches this domains hostname with\n-   * wildcards\n+   * wildcards</li>\n    * </ul>\n    *\n    * @param perm The <code>Permission</code> to check against\n    *\n-   * @return <code>true</code> if the <code>Permission</code> is implied by \n+   * @return <code>true</code> if the <code>Permission</code> is implied by\n    * this object, <code>false</code> otherwise.\n    */\n   public boolean implies(Permission perm)\n@@ -266,80 +271,89 @@ public boolean implies(Permission perm)\n     String ourlist = getActions();\n     String theirlist = p.getActions();\n \n-    if (!ourlist.startsWith(theirlist))\n+    if (! ourlist.startsWith(theirlist))\n       return (false);\n \n     // Now check ports\n-    int ourfirstport = 0, ourlastport = 0, theirfirstport = 0, theirlastport =\n-      0;\n+    int ourfirstport = 0;\n+\n+    // Now check ports\n+    int ourlastport = 0;\n+\n+    // Now check ports\n+    int theirfirstport = 0;\n+\n+    // Now check ports\n+    int theirlastport = 0;\n \n     // Get ours\n     if (hostport.indexOf(\":\") == -1)\n       {\n-        ourfirstport = 0;\n-        ourlastport = 65535;\n+\tourfirstport = 0;\n+\tourlastport = 65535;\n       }\n     else\n       {\n-        // FIXME:  Needs bulletproofing.\n-        // This will dump if hostport if all sorts of bad data was passed to\n-        // the constructor\n-        String range = hostport.substring(hostport.indexOf(\":\") + 1);\n-        if (range.startsWith(\"-\"))\n-          ourfirstport = 0;\n-        else if (range.indexOf(\"-\") == -1)\n-          ourfirstport = Integer.parseInt(range);\n-        else\n-          ourfirstport =\n-            Integer.parseInt(range.substring(0, range.indexOf(\"-\")));\n-\n-        if (range.endsWith(\"-\"))\n-          ourlastport = 65535;\n-        else if (range.indexOf(\"-\") == -1)\n-          ourlastport = Integer.parseInt(range);\n-        else\n-          ourlastport =\n-            Integer.parseInt(range.\n-                             substring(range.indexOf(\"-\") + 1,\n-                                       range.length()));\n+\t// FIXME:  Needs bulletproofing.\n+\t// This will dump if hostport if all sorts of bad data was passed to\n+\t// the constructor\n+\tString range = hostport.substring(hostport.indexOf(\":\") + 1);\n+\tif (range.startsWith(\"-\"))\n+\t  ourfirstport = 0;\n+\telse if (range.indexOf(\"-\") == -1)\n+\t  ourfirstport = Integer.parseInt(range);\n+\telse\n+\t  ourfirstport =\n+\t    Integer.parseInt(range.substring(0, range.indexOf(\"-\")));\n+\n+\tif (range.endsWith(\"-\"))\n+\t  ourlastport = 65535;\n+\telse if (range.indexOf(\"-\") == -1)\n+\t  ourlastport = Integer.parseInt(range);\n+\telse\n+\t  ourlastport =\n+\t    Integer.parseInt(range.substring(range.indexOf(\"-\") + 1,\n+\t                                     range.length()));\n       }\n \n     // Get theirs\n     if (p.hostport.indexOf(\":\") == -1)\n       {\n-        theirfirstport = 0;\n-        ourlastport = 65535;\n+\ttheirfirstport = 0;\n+\tourlastport = 65535;\n       }\n     else\n       {\n-        // This will dump if hostport if all sorts of bad data was passed to\n-        // the constructor\n-        String range = p.hostport.substring(hostport.indexOf(\":\") + 1);\n-        if (range.startsWith(\"-\"))\n-          theirfirstport = 0;\n-        else if (range.indexOf(\"-\") == -1)\n-          theirfirstport = Integer.parseInt(range);\n-        else\n-          theirfirstport =\n-            Integer.parseInt(range.substring(0, range.indexOf(\"-\")));\n-\n-        if (range.endsWith(\"-\"))\n-          theirlastport = 65535;\n-        else if (range.indexOf(\"-\") == -1)\n-          theirlastport = Integer.parseInt(range);\n-        else\n-          theirlastport =\n-            Integer.parseInt(range.\n-                             substring(range.indexOf(\"-\") + 1,\n-                                       range.length()));\n+\t// This will dump if hostport if all sorts of bad data was passed to\n+\t// the constructor\n+\tString range = p.hostport.substring(hostport.indexOf(\":\") + 1);\n+\tif (range.startsWith(\"-\"))\n+\t  theirfirstport = 0;\n+\telse if (range.indexOf(\"-\") == -1)\n+\t  theirfirstport = Integer.parseInt(range);\n+\telse\n+\t  theirfirstport =\n+\t    Integer.parseInt(range.substring(0, range.indexOf(\"-\")));\n+\n+\tif (range.endsWith(\"-\"))\n+\t  theirlastport = 65535;\n+\telse if (range.indexOf(\"-\") == -1)\n+\t  theirlastport = Integer.parseInt(range);\n+\telse\n+\t  theirlastport =\n+\t    Integer.parseInt(range.substring(range.indexOf(\"-\") + 1,\n+\t                                     range.length()));\n       }\n \n     // Now check them\n     if ((theirfirstport < ourfirstport) || (theirlastport > ourlastport))\n       return (false);\n \n     // Finally we can check the hosts\n-    String ourhost, theirhost;\n+    String ourhost;\n+\n+    // Finally we can check the hosts\n+    String theirhost;\n \n     // Get ours\n     if (hostport.indexOf(\":\") == -1)\n@@ -358,20 +372,23 @@ else if (range.indexOf(\"-\") == -1)\n       return (true);\n \n     // Try the canonical names\n-    String ourcanonical = null, theircanonical = null;\n+    String ourcanonical = null;\n+\n+    // Try the canonical names\n+    String theircanonical = null;\n     try\n       {\n-        ourcanonical = InetAddress.getByName(ourhost).getHostName();\n-        theircanonical = InetAddress.getByName(theirhost).getHostName();\n+\tourcanonical = InetAddress.getByName(ourhost).getHostName();\n+\ttheircanonical = InetAddress.getByName(theirhost).getHostName();\n       }\n     catch (UnknownHostException e)\n       {\n-        // Who didn't resolve?  Just assume current address is canonical enough\n-        // Is this ok to do?\n-        if (ourcanonical == null)\n-          ourcanonical = ourhost;\n-        if (theircanonical == null)\n-          theircanonical = theirhost;\n+\t// Who didn't resolve?  Just assume current address is canonical enough\n+\t// Is this ok to do?\n+\tif (ourcanonical == null)\n+\t  ourcanonical = ourhost;\n+\tif (theircanonical == null)\n+\t  theircanonical = theirhost;\n       }\n \n     if (ourcanonical.equals(theircanonical))\n@@ -380,9 +397,9 @@ else if (range.indexOf(\"-\") == -1)\n     // Well, last chance.  Try for a wildcard\n     if (ourhost.indexOf(\"*.\") != -1)\n       {\n-        String wild_domain = ourhost.substring(ourhost.indexOf(\"*\" + 1));\n-        if (theircanonical.endsWith(wild_domain))\n-          return (true);\n+\tString wild_domain = ourhost.substring(ourhost.indexOf(\"*\" + 1));\n+\tif (theircanonical.endsWith(wild_domain))\n+\t  return (true);\n       }\n \n     // Didn't make it"}, {"sha": "e375065b3448c8d77aba06730d45aba772f6784b", "filename": "libjava/java/net/SocketTimeoutException.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketTimeoutException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FSocketTimeoutException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocketTimeoutException.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -39,6 +39,7 @@\n \n import java.io.InterruptedIOException;\n \n+\n /**\n  * This exception signals that a socket read or accept timed out.\n  *"}, {"sha": "b456f71d2ddca8e39b3e7534f74f3adccc059f83", "filename": "libjava/java/net/URI.java", "status": "modified", "additions": 161, "deletions": 156, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURI.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURI.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURI.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -44,14 +44,14 @@\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n+\n /**\n  * @author Ito Kazumitsu (ito.kazumitsu@hitachi-cable.co.jp)\n  * @author Dalibor Topic (robilad@kaffe.org)\n  * @author Michael Koch (konqueror@gmx.de)\n  * @since 1.4\n  */\n-public final class URI\n-  implements Comparable, Serializable\n+public final class URI implements Comparable, Serializable\n {\n   static final long serialVersionUID = -6052424284110960213L;\n \n@@ -70,11 +70,14 @@\n   private static final String RFC2396_DIGIT = \"0123456789\";\n   private static final String RFC2396_LOWALPHA = \"abcdefghijklmnopqrstuvwxyz\";\n   private static final String RFC2396_UPALPHA = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n-  private static final String RFC2396_ALPHA = RFC2396_LOWALPHA + RFC2396_UPALPHA;\n+  private static final String RFC2396_ALPHA =\n+    RFC2396_LOWALPHA + RFC2396_UPALPHA;\n   private static final String RFC2396_ALPHANUM = RFC2396_DIGIT + RFC2396_ALPHA;\n   private static final String RFC2396_MARK = \"-_.!~*'()\";\n-  private static final String RFC2396_UNRESERVED = RFC2396_ALPHANUM + RFC2396_MARK;\n-  private static final String RFC2396_REG_NAME = RFC2396_UNRESERVED + \"$,;:@&=+\";\n+  private static final String RFC2396_UNRESERVED =\n+    RFC2396_ALPHANUM + RFC2396_MARK;\n+  private static final String RFC2396_REG_NAME =\n+    RFC2396_UNRESERVED + \"$,;:@&=+\";\n   private static final String RFC2396_PCHAR = RFC2396_UNRESERVED + \":@&=+$,\";\n   private static final String RFC2396_SEGMENT = RFC2396_PCHAR + \";\";\n   private static final String RFC2396_PATH_SEGMENTS = RFC2396_SEGMENT + \"/\";\n@@ -108,7 +111,6 @@\n    * Index of fragment component in parsed URI.\n    */\n   private static final int FRAGMENT_GROUP = 10;\n-\n   private String scheme;\n   private String rawSchemeSpecificPart;\n   private String schemeSpecificPart;\n@@ -126,17 +128,17 @@\n   private String rawFragment;\n   private String fragment;\n \n-  private void readObject (ObjectInputStream is)\n+  private void readObject(ObjectInputStream is)\n     throws ClassNotFoundException, IOException\n   {\n   }\n \n-  private void writeObject (ObjectOutputStream is)\n-    throws IOException\n+  private void writeObject(ObjectOutputStream is) throws IOException\n   {\n   }\n \n-  private static String getURIGroup (Matcher match, int group) {\n+  private static String getURIGroup(Matcher match, int group)\n+  {\n     String matched = match.group(group);\n     return matched.length() == 0 ? null : matched;\n   }\n@@ -148,23 +150,22 @@ private static String getURIGroup (Matcher match, int group) {\n    *\n    * @exception URISyntaxException If the given string violates RFC 2396\n    */\n-  private void parseURI (String str)\n-    throws URISyntaxException\n+  private void parseURI(String str) throws URISyntaxException\n   {\n     Pattern pattern = Pattern.compile(URI_REGEXP);\n     Matcher matcher = pattern.matcher(str);\n     if (matcher.matches())\n       {\n \tscheme = getURIGroup(matcher, SCHEME_GROUP);\n-\trawSchemeSpecificPart = getURIGroup(matcher, SCHEME_SPEC_PART_GROUP); \n+\trawSchemeSpecificPart = getURIGroup(matcher, SCHEME_SPEC_PART_GROUP);\n \trawAuthority = getURIGroup(matcher, AUTHORITY_GROUP);\n \trawPath = getURIGroup(matcher, PATH_GROUP);\n \trawQuery = getURIGroup(matcher, QUERY_GROUP);\n \trawFragment = getURIGroup(matcher, FRAGMENT_GROUP);\n       }\n     else\n-      throw new URISyntaxException(str,\n-\t\t\t\t   \"doesn't match URI regular expression\");\n+      throw new URISyntaxException(str, \"doesn't match URI regular expression\");\n+\n     // We must eagerly unquote the parts, because this is the only time\n     // we may throw an exception.\n     schemeSpecificPart = unquote(rawSchemeSpecificPart);\n@@ -184,35 +185,39 @@ private void parseURI (String str)\n    * @exception URISyntaxException If the given string contains invalid\n    * escape sequences.\n    */\n-  private static String unquote (String str)\n-    throws URISyntaxException\n+  private static String unquote(String str) throws URISyntaxException\n   {\n     if (str == null)\n       return null;\n     byte[] buf = new byte[str.length()];\n     int pos = 0;\n-    for (int i = 0; i < str.length(); i++) {\n-      char c = str.charAt(i);\n-      if (c > 127)\n+    for (int i = 0; i < str.length(); i++)\n+      {\n+\tchar c = str.charAt(i);\n+\tif (c > 127)\n \t  throw new URISyntaxException(str, \"Invalid character\");\n-      if (c == '%') {\n-        if (i + 2 >= str.length())\n-\t  throw new URISyntaxException(str, \"Invalid quoted character\");\n-\tString hex = \"0123456789ABCDEF\";\n-        int hi = hex.indexOf(str.charAt(++i));\n-        int lo = hex.indexOf(str.charAt(++i));\n-        if (lo < 0 || hi < 0)\n-\t  throw new URISyntaxException(str, \"Invalid quoted character\");\n-\tbuf[pos++] = (byte)(hi * 16 + lo);\n-      } else {\n-\tbuf[pos++] = (byte)c;\n+\tif (c == '%')\n+\t  {\n+\t    if (i + 2 >= str.length())\n+\t      throw new URISyntaxException(str, \"Invalid quoted character\");\n+\t    String hex = \"0123456789ABCDEF\";\n+\t    int hi = hex.indexOf(str.charAt(++i));\n+\t    int lo = hex.indexOf(str.charAt(++i));\n+\t    if (lo < 0 || hi < 0)\n+\t      throw new URISyntaxException(str, \"Invalid quoted character\");\n+\t    buf[pos++] = (byte) (hi * 16 + lo);\n+\t  }\n+\telse\n+\t  buf[pos++] = (byte) c;\n+      }\n+    try\n+      {\n+\treturn new String(buf, 0, pos, \"utf-8\");\n+      }\n+    catch (java.io.UnsupportedEncodingException x2)\n+      {\n+\tthrow (Error) new InternalError().initCause(x2);\n       }\n-    }\n-    try {\n-      return new String(buf, 0, pos, \"utf-8\");\n-    } catch (java.io.UnsupportedEncodingException x2) {\n-      throw (Error)new InternalError().initCause(x2);\n-    }\n   }\n \n   /**\n@@ -223,10 +228,11 @@ private static String unquote (String str)\n    * UTF-8 character.\n    *\n    * @param str The string to quote\n-   * \n+   *\n    * @return The quoted string.\n    */\n-  private static String quote (String str) {\n+  private static String quote(String str)\n+  {\n     // FIXME: unimplemented.\n     return str;\n   }\n@@ -239,10 +245,11 @@ private static String quote (String str) {\n    * UTF-8 character.\n    *\n    * @param str The string to quote\n-   * \n+   *\n    * @return The quoted string.\n    */\n-  private static String quoteAuthority (String str) {\n+  private static String quoteAuthority(String str)\n+  {\n     // Technically, we should be using RFC2396_AUTHORITY, but\n     // it contains no additional characters.\n     return quote(str, RFC2396_REG_NAME);\n@@ -257,37 +264,39 @@ private static String quoteAuthority (String str) {\n    *\n    * @param str The string to quote\n    * @param legalCharacters The set of legal characters\n-   * \n+   *\n    * @return The quoted string.\n    */\n-  private static String quote (String str, String legalCharacters)\n+  private static String quote(String str, String legalCharacters)\n   {\n     StringBuffer sb = new StringBuffer(str.length());\n-    for (int i = 0; i < str.length(); i++) {\n-      char c = str.charAt(i);\n-      if (legalCharacters.indexOf(c) == -1) {\n-\tString hex = \"0123456789ABCDEF\";\n-\tif (c <= 127) {\n-\t  sb.append('%')\n-\t    .append(hex.charAt(c / 16))\n-\t    .append(hex.charAt(c % 16));\n-\t} else {\n-\t  try {\n-\t    // this is far from optimal, but it works\n-\t    byte[] utf8 = str.substring(i, i + 1).getBytes(\"utf-8\");\n-\t    for (int j = 0; j < utf8.length; j++) {\n-\t\tsb.append('%')\n-\t\t.append(hex.charAt((utf8[j] & 0xff) / 16))\n-\t\t.append(hex.charAt((utf8[j] & 0xff) % 16));\n-\t    }\n-\t  } catch (java.io.UnsupportedEncodingException x) {\n-\t    throw (Error)new InternalError().initCause(x);\n+    for (int i = 0; i < str.length(); i++)\n+      {\n+\tchar c = str.charAt(i);\n+\tif (legalCharacters.indexOf(c) == -1)\n+\t  {\n+\t    String hex = \"0123456789ABCDEF\";\n+\t    if (c <= 127)\n+\t      sb.append('%').append(hex.charAt(c / 16)).append(hex.charAt(c % 16));\n+\t    else\n+\t      {\n+\t\ttry\n+\t\t  {\n+\t\t    // this is far from optimal, but it works\n+\t\t    byte[] utf8 = str.substring(i, i + 1).getBytes(\"utf-8\");\n+\t\t    for (int j = 0; j < utf8.length; j++)\n+\t\t      sb.append('%').append(hex.charAt((utf8[j] & 0xff) / 16))\n+\t\t        .append(hex.charAt((utf8[j] & 0xff) % 16));\n+\t\t  }\n+\t\tcatch (java.io.UnsupportedEncodingException x)\n+\t\t  {\n+\t\t    throw (Error) new InternalError().initCause(x);\n+\t\t  }\n+\t      }\n \t  }\n-\t}\n-      } else {\n-\tsb.append(c);\n+\telse\n+\t  sb.append(c);\n       }\n-    }\n     return sb.toString();\n   }\n \n@@ -299,10 +308,11 @@ private static String quote (String str, String legalCharacters)\n    * UTF-8 character.\n    *\n    * @param str The string to quote\n-   * \n+   *\n    * @return The quoted string.\n    */\n-  private static String quoteHost (String str) {\n+  private static String quoteHost(String str)\n+  {\n     // FIXME: unimplemented.\n     return str;\n   }\n@@ -315,10 +325,11 @@ private static String quoteHost (String str) {\n    * UTF-8 character.\n    *\n    * @param str The string to quote\n-   * \n+   *\n    * @return The quoted string.\n    */\n-  private static String quotePath (String str) {\n+  private static String quotePath(String str)\n+  {\n     // Technically, we should be using RFC2396_PATH, but\n     // it contains no additional characters.\n     return quote(str, RFC2396_PATH_SEGMENTS);\n@@ -332,10 +343,11 @@ private static String quotePath (String str) {\n    * UTF-8 character.\n    *\n    * @param str The string to quote\n-   * \n+   *\n    * @return The quoted string.\n    */\n-  private static String quoteUserInfo (String str) {\n+  private static String quoteUserInfo(String str)\n+  {\n     // FIXME: unimplemented.\n     return str;\n   }\n@@ -348,12 +360,11 @@ private static String quoteUserInfo (String str) {\n    * @exception URISyntaxException If the given string violates RFC 2396\n    * @exception NullPointerException If str is null\n    */\n-  public URI (String str)\n-    throws URISyntaxException\n+  public URI(String str) throws URISyntaxException\n   {\n     parseURI(str);\n   }\n- \n+\n   /**\n    * Create an URI from the given components\n    *\n@@ -367,19 +378,19 @@ public URI (String str)\n    *\n    * @exception URISyntaxException If the given string violates RFC 2396\n    */\n-  public URI (String scheme, String userInfo, String host, int port,\n-\t     String path, String query, String fragment)\n+  public URI(String scheme, String userInfo, String host, int port,\n+             String path, String query, String fragment)\n     throws URISyntaxException\n   {\n-    this((scheme == null ? \"\" : scheme + \":\" )\n-\t + (userInfo == null && host == null && port == -1 ? \"\" : \"//\")\n-\t + (userInfo == null ? \"\" : quoteUserInfo(userInfo) + \"@\")\n-\t + (host == null ? \"\" : quoteHost(host))\n-\t + (port == -1 ? \"\" : \":\" + String.valueOf(port))\n-\t + (path == null ? \"\" : quotePath(path))\n-\t + (query == null ? \"\" : \"?\" + quote(query))\n-\t + (fragment == null ? \"\" : \"#\" + quote(fragment)));\n-    \n+    this((scheme == null ? \"\" : scheme + \":\")\n+         + (userInfo == null && host == null && port == -1 ? \"\" : \"//\")\n+         + (userInfo == null ? \"\" : quoteUserInfo(userInfo) + \"@\")\n+         + (host == null ? \"\" : quoteHost(host))\n+         + (port == -1 ? \"\" : \":\" + String.valueOf(port))\n+         + (path == null ? \"\" : quotePath(path))\n+         + (query == null ? \"\" : \"?\" + quote(query))\n+         + (fragment == null ? \"\" : \"#\" + quote(fragment)));\n+\n     parseServerAuthority();\n   }\n \n@@ -394,15 +405,14 @@ public URI (String scheme, String userInfo, String host, int port,\n    *\n    * @exception URISyntaxException If the given string violates RFC 2396\n    */\n-  public URI (String scheme, String authority, String path, String query,\n-\t     String fragment)\n-    throws URISyntaxException\n+  public URI(String scheme, String authority, String path, String query,\n+             String fragment) throws URISyntaxException\n   {\n     this((scheme == null ? \"\" : scheme + \":\")\n-\t + (authority == null ? \"\" : \"//\" + quoteAuthority(authority))\n-\t + (path == null ? \"\" : quotePath(path))\n-\t + (query == null ? \"\" : \"?\" + quote(query))\n-\t + (fragment == null ? \"\" : \"#\" + quote(fragment)));\n+         + (authority == null ? \"\" : \"//\" + quoteAuthority(authority))\n+         + (path == null ? \"\" : quotePath(path))\n+         + (query == null ? \"\" : \"?\" + quote(query))\n+         + (fragment == null ? \"\" : \"#\" + quote(fragment)));\n   }\n \n   /**\n@@ -415,7 +425,7 @@ public URI (String scheme, String authority, String path, String query,\n    *\n    * @exception URISyntaxException If the given string violates RFC 2396\n    */\n-  public URI (String scheme, String host, String path, String fragment)\n+  public URI(String scheme, String host, String path, String fragment)\n     throws URISyntaxException\n   {\n     this(scheme, null, host, -1, path, null, fragment);\n@@ -430,12 +440,12 @@ public URI (String scheme, String host, String path, String fragment)\n    *\n    * @exception URISyntaxException If the given string violates RFC 2396\n    */\n-  public URI (String scheme, String ssp, String fragment)\n+  public URI(String scheme, String ssp, String fragment)\n     throws URISyntaxException\n   {\n     this((scheme == null ? \"\" : scheme + \":\")\n-\t + (ssp == null ? \"\" : quote(ssp))\n-\t + (fragment == null ? \"\" : \"#\" + quote(fragment)));\n+         + (ssp == null ? \"\" : quote(ssp))\n+         + (fragment == null ? \"\" : \"#\" + quote(fragment)));\n   }\n \n   /**\n@@ -446,16 +456,16 @@ public URI (String scheme, String ssp, String fragment)\n    * @exception IllegalArgumentException If the given string violates RFC 2396\n    * @exception NullPointerException If str is null\n    */\n-  public static URI create (String str)\n+  public static URI create(String str)\n   {\n     try\n       {\n \treturn new URI(str);\n       }\n-    catch(URISyntaxException e)\n+    catch (URISyntaxException e)\n       {\n-\tthrow (IllegalArgumentException)\n-\t  new IllegalArgumentException().initCause(e);\n+\tthrow (IllegalArgumentException) new IllegalArgumentException()\n+\t      .initCause(e);\n       }\n   }\n \n@@ -465,16 +475,15 @@ public static URI create (String str)\n    *\n    * @exception URISyntaxException If the given string violates RFC 2396\n    */\n-  public URI parseServerAuthority ()\n-     throws URISyntaxException\n+  public URI parseServerAuthority() throws URISyntaxException\n   {\n     return null;\n   }\n \n   /**\n    * Returns a normalizes versions of the URI\n    */\n-  public URI normalize ()\n+  public URI normalize()\n   {\n     return null;\n   }\n@@ -489,8 +498,8 @@ public URI normalize ()\n    *\n    * @exception NullPointerException If uri is null\n    */\n-  public URI resolve (URI uri)\n-  { \n+  public URI resolve(URI uri)\n+  {\n     if (uri.isAbsolute())\n       return uri;\n     if (uri.isOpaque())\n@@ -505,35 +514,34 @@ public URI resolve (URI uri)\n \n     try\n       {\n-        if (fragment != null &&\n-            path != null && path.equals(\"\") &&\n-            scheme == null && authority == null && query == null)\n+\tif (fragment != null && path != null && path.equals(\"\")\n+\t    && scheme == null && authority == null && query == null)\n \t  return new URI(this.scheme, this.schemeSpecificPart, fragment);\n \n-        if (authority == null)\n+\tif (authority == null)\n \t  {\n-            authority = this.authority;\n-            if (path == null)\n+\t    authority = this.authority;\n+\t    if (path == null)\n \t      path = \"\";\n-            if (!(path.startsWith(\"/\")))\n+\t    if (! (path.startsWith(\"/\")))\n \t      {\n-                StringBuffer basepath = new StringBuffer(this.path);\n-                int i = this.path.lastIndexOf('/');\n+\t\tStringBuffer basepath = new StringBuffer(this.path);\n+\t\tint i = this.path.lastIndexOf('/');\n \n-                if (i >= 0)\n-\t\t  basepath.delete(i+1, basepath.length());\n+\t\tif (i >= 0)\n+\t\t  basepath.delete(i + 1, basepath.length());\n \n-                basepath.append(path);\n-                path = basepath.toString();\n-                //  FIXME We must normalize the path here.\n-                //  Normalization process omitted.\n+\t\tbasepath.append(path);\n+\t\tpath = basepath.toString();\n+\t\t//  FIXME We must normalize the path here.\n+\t\t//  Normalization process omitted.\n \t      }\n \t  }\n-        return new URI(this.scheme, authority, path, query, fragment);\n+\treturn new URI(this.scheme, authority, path, query, fragment);\n       }\n     catch (URISyntaxException e)\n       {\n-        return null;\n+\treturn null;\n       }\n   }\n \n@@ -548,8 +556,7 @@ public URI resolve (URI uri)\n    * violates RFC 2396\n    * @exception NullPointerException If uri is null\n    */\n-  public URI resolve (String str)\n-    throws IllegalArgumentException\n+  public URI resolve(String str) throws IllegalArgumentException\n   {\n     return resolve(create(str));\n   }\n@@ -563,7 +570,7 @@ public URI resolve (String str)\n    *\n    * @exception NullPointerException If uri is null\n    */\n-  public URI relativize (URI uri)\n+  public URI relativize(URI uri)\n   {\n     return null;\n   }\n@@ -575,8 +582,7 @@ public URI relativize (URI uri)\n    * not be found, or if some other error occurred while constructing the URL\n    * @exception IllegalArgumentException If the URI is not absolute\n    */\n-  public URL toURL ()\n-    throws IllegalArgumentException, MalformedURLException\n+  public URL toURL() throws IllegalArgumentException, MalformedURLException\n   {\n     if (isAbsolute())\n       return new URL(this.toString());\n@@ -587,136 +593,136 @@ public URL toURL ()\n   /**\n    * Returns the scheme of the URI\n    */\n-  public String getScheme ()\n+  public String getScheme()\n   {\n     return scheme;\n   }\n \n   /**\n    * Tells whether this URI is absolute or not\n    */\n-  public boolean isAbsolute ()\n+  public boolean isAbsolute()\n   {\n     return (scheme != null);\n   }\n \n   /**\n    * Tell whether this URI is opaque or not\n    */\n-  public boolean isOpaque ()\n+  public boolean isOpaque()\n   {\n-    return ((scheme != null) && !(schemeSpecificPart.startsWith(\"/\")));\n+    return ((scheme != null) && ! (schemeSpecificPart.startsWith(\"/\")));\n   }\n \n   /**\n    * Returns the raw scheme specific part of this URI.\n    * The scheme-specific part is never undefined, though it may be empty\n    */\n-  public String getRawSchemeSpecificPart ()\n+  public String getRawSchemeSpecificPart()\n   {\n     return rawSchemeSpecificPart;\n   }\n \n   /**\n    * Returns the decoded scheme specific part of this URI.\n    */\n-  public String getSchemeSpecificPart ()\n+  public String getSchemeSpecificPart()\n   {\n     return schemeSpecificPart;\n   }\n \n   /**\n    * Returns the rae authority part of this URI\n    */\n-  public String getRawAuthority ()\n+  public String getRawAuthority()\n   {\n     return rawAuthority;\n   }\n \n   /**\n    * Returns the decoded authority part of this URI\n    */\n-  public String getAuthority ()\n+  public String getAuthority()\n   {\n     return authority;\n   }\n \n   /**\n    * Returns the raw user info part of this URI\n    */\n-  public String getRawUserInfo ()\n+  public String getRawUserInfo()\n   {\n     return rawUserInfo;\n   }\n \n   /**\n    * Returns the decoded user info part of this URI\n    */\n-  public String getUserInfo ()\n+  public String getUserInfo()\n   {\n     return userInfo;\n   }\n \n   /**\n    * Returns the hostname of the URI\n    */\n-  public String getHost ()\n+  public String getHost()\n   {\n     return host;\n   }\n \n   /**\n    * Returns the port number of the URI\n    */\n-  public int getPort ()\n+  public int getPort()\n   {\n     return port;\n   }\n \n   /**\n    * Returns the raw path part of this URI\n    */\n-  public String getRawPath ()\n+  public String getRawPath()\n   {\n     return rawPath;\n   }\n \n   /**\n    * Returns the path of the URI\n    */\n-  public String getPath ()\n+  public String getPath()\n   {\n     return path;\n   }\n \n   /**\n    * Returns the raw query part of this URI\n    */\n-  public String getRawQuery ()\n+  public String getRawQuery()\n   {\n     return rawQuery;\n   }\n \n   /**\n    * Returns the query of the URI\n    */\n-  public String getQuery ()\n+  public String getQuery()\n   {\n     return query;\n   }\n \n   /**\n    * Return the raw fragment part of this URI\n    */\n-  public String getRawFragment ()\n+  public String getRawFragment()\n   {\n     return rawFragment;\n   }\n \n   /**\n    * Returns the fragment of the URI\n    */\n-  public String getFragment ()\n+  public String getFragment()\n   {\n     return fragment;\n   }\n@@ -734,7 +740,7 @@ public boolean equals(Object obj)\n   /**\n    * Computes the hascode of the URI\n    */\n-  public int hashCode ()\n+  public int hashCode()\n   {\n     return 0;\n   }\n@@ -746,28 +752,27 @@ public int hashCode ()\n    *\n    * @exception ClassCastException If given object ist not an URI\n    */\n-  public int compareTo (Object obj)\n-    throws ClassCastException\n+  public int compareTo(Object obj) throws ClassCastException\n   {\n     return 0;\n   }\n \n   /**\n    * Returns the URI as string\n    */\n-  public String toString ()\n+  public String toString()\n   {\n     return (getScheme() == null ? \"\" : getScheme() + \":\")\n-      + (getRawAuthority() == null ? \"\" : \"//\" + getRawAuthority())\n-      + (getRawPath() == null ? \"\" : getRawPath())\n-      + (getRawQuery() == null ? \"\" : \"?\" + getRawQuery())\n-      + (getRawFragment() == null ? \"\" : \"#\" + getRawFragment());\n+           + (getRawAuthority() == null ? \"\" : \"//\" + getRawAuthority())\n+           + (getRawPath() == null ? \"\" : getRawPath())\n+           + (getRawQuery() == null ? \"\" : \"?\" + getRawQuery())\n+           + (getRawFragment() == null ? \"\" : \"#\" + getRawFragment());\n   }\n \n   /**\n    * Returns the URI as US-ASCII string\n    */\n-  public String toASCIIString ()\n+  public String toASCIIString()\n   {\n     return \"\";\n   }"}, {"sha": "89a0be69823da033dbdb878b91b1ddb38dc4f77d", "filename": "libjava/java/net/URISyntaxException.java", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURISyntaxException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURISyntaxException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURISyntaxException.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -37,6 +37,7 @@\n \n package java.net;\n \n+\n /**\n  * This exception is thrown when a String cannot be parsed as a URI.\n  *\n@@ -137,7 +138,7 @@ public int getIndex()\n    */\n   public String getMessage()\n   {\n-    return super.getMessage() + (index >= 0 ? \" at index \" + index : \"\")\n-      + \": \" + input;\n+    return (super.getMessage() + (index >= 0 ? \" at index \" + index : \"\")\n+           + \": \" + input);\n   }\n }"}, {"sha": "d9bf0ab054cec06ff2b6a6952bc4133ac0d83e50", "filename": "libjava/java/net/URL.java", "status": "modified", "additions": 90, "deletions": 96, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURL.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURL.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURL.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,18 +35,18 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n import gnu.java.net.URLParseError;\n-import java.io.InputStream;\n import java.io.IOException;\n-import java.io.Serializable;\n+import java.io.InputStream;\n import java.io.ObjectInputStream;\n import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n import java.util.HashMap;\n import java.util.StringTokenizer;\n \n+\n /*\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n@@ -56,7 +56,7 @@\n /**\n   * This final class represents an Internet Uniform Resource Locator (URL).\n   * For details on the syntax of URL's and what they can be used for,\n-  * refer to RFC 1738, available from <a \n+  * refer to RFC 1738, available from <a\n   * href=\"http://ds.internic.net/rfcs/rfc1738.txt\">\n   * http://ds.internic.net/rfcs/rfc1738.txt</a>\n   * <p>\n@@ -74,7 +74,7 @@\n   * This chaining is done via the system property java.protocol.handler.pkgs\n   * If this property is set, it is assumed to be a \"|\" separated list of\n   * package names in which to attempt locating protocol handlers.  The\n-  * protocol handler is searched for by appending the string \n+  * protocol handler is searched for by appending the string\n   * \".&lt;protocol&gt;.Handler\" to each packed in the list until a hander is\n   * found. If a protocol handler is not found in this list of packages, or if\n   * the property does not exist, then the default protocol handler of\n@@ -87,7 +87,7 @@\n   * <p>\n   * Here is an example of how URL searches for protocol handlers.  Assume\n   * the value of java.protocol.handler.pkgs is \"com.foo|com.bar\" and the\n-  * URL is \"news://comp.lang.java.programmer\".  URL would looking the \n+  * URL is \"news://comp.lang.java.programmer\".  URL would looking the\n   * following places for protocol handlers:\n   * <p><pre>\n   * com.foo.news.Handler\n@@ -122,7 +122,7 @@ public final class URL implements Serializable\n {\n   private static final String DEFAULT_SEARCH_PATH =\n     \"gnu.java.net.protocol|sun.net.www.protocol\";\n-  \n+\n   /**\n    * The name of the protocol for this URL.\n    * The protocol is always stored in lower case.\n@@ -144,7 +144,7 @@ public final class URL implements Serializable\n    * The port number of this protocol or -1 if the port number used is\n    * the default for this protocol.\n    */\n-  private int port = -1;\t// Initialize for constructor using context.\n+  private int port = -1; // Initialize for constructor using context.\n \n   /**\n    * The \"file\" portion of the URL. It is defined as <code>path[?query]</code>.\n@@ -171,7 +171,6 @@ public final class URL implements Serializable\n    * where we keep track of it.\n    */\n   private static URLStreamHandlerFactory factory;\n-\n   private static final long serialVersionUID = -7627629688361524110L;\n \n   /**\n@@ -187,18 +186,18 @@ public final class URL implements Serializable\n \n   static\n     {\n-      String s = System.getProperty (\"gnu.java.net.nocache_protocol_handlers\");\n-      \n+      String s = System.getProperty(\"gnu.java.net.nocache_protocol_handlers\");\n+\n       if (s == null)\n-        cache_handlers = true;\n+\tcache_handlers = true;\n       else\n-        cache_handlers = false;\n+\tcache_handlers = false;\n     }\n \n   /**\n    * Constructs a URL and loads a protocol handler for the values passed as\n    * arguments.\n-   * \n+   *\n    * @param protocol The protocol for this URL (\"http\", \"ftp\", etc)\n    * @param host The hostname or IP address to connect to\n    * @param port The port number to use, or -1 to use the protocol's\n@@ -231,11 +230,10 @@ public URL(String protocol, String host, String file)\n     this(protocol, host, -1, file, null);\n   }\n \n-\n   /**\n    * This method initializes a new instance of <code>URL</code> with the\n    * specified protocol, host, port, and file.  Additionally, this method\n-   * allows the caller to specify a protocol handler to use instead of \n+   * allows the caller to specify a protocol handler to use instead of\n    * the default.  If this handler is specified, the caller must have\n    * the \"specifyStreamHandler\" permission (see <code>NetPermission</code>)\n    * or a <code>SecurityException</code> will be thrown.\n@@ -254,9 +252,8 @@ public URL(String protocol, String host, String file)\n    *\n    * @since 1.2\n    */\n-  public URL (String protocol, String host, int port, String file,\n-\t      URLStreamHandler ph)\n-    throws MalformedURLException\n+  public URL(String protocol, String host, int port, String file,\n+             URLStreamHandler ph) throws MalformedURLException\n   {\n     if (protocol == null)\n       throw new MalformedURLException(\"null protocol\");\n@@ -266,16 +263,16 @@ public URL (String protocol, String host, int port, String file,\n       {\n \tSecurityManager s = System.getSecurityManager();\n \tif (s != null)\n-\t  s.checkPermission (new NetPermission (\"specifyStreamHandler\"));\n+\t  s.checkPermission(new NetPermission(\"specifyStreamHandler\"));\n \n-        this.ph = ph;\n+\tthis.ph = ph;\n       }\n     else\n       this.ph = getURLStreamHandler(protocol);\n \n     if (this.ph == null)\n-      throw new MalformedURLException (\n-\t\t      \"Protocol handler not found: \" + protocol);\n+      throw new MalformedURLException(\"Protocol handler not found: \"\n+                                      + protocol);\n \n     this.host = host;\n     this.port = port;\n@@ -292,7 +289,7 @@ public URL (String protocol, String host, int port, String file,\n \tthis.file = file.substring(0, hashAt);\n \tthis.ref = file.substring(hashAt + 1);\n       }\n-    hashCode = hashCode();\t\t\t// Used for serialization.\n+    hashCode = hashCode(); // Used for serialization.\n   }\n \n   /**\n@@ -325,7 +322,7 @@ public URL(String spec) throws MalformedURLException\n    * @param context The context on which to parse the specification\n    * @param spec The string to parse an URL\n    *\n-   * @exception MalformedURLException If a protocol handler cannot be found \n+   * @exception MalformedURLException If a protocol handler cannot be found\n    * for the URL cannot be parsed\n    */\n   public URL(URL context, String spec) throws MalformedURLException\n@@ -340,7 +337,7 @@ public URL(URL context, String spec) throws MalformedURLException\n    * not present the URL are inheritied from the context URL.  This allows\n    * relative URL's to be easily constructed.  If the context argument is\n    * null, then a complete URL must be specified in the URL string.\n-   * If the protocol parsed out of the URL is different \n+   * If the protocol parsed out of the URL is different\n    * from the context URL's protocol, then then URL String is also\n    * expected to be a complete URL.\n    * <p>\n@@ -372,21 +369,21 @@ public URL(URL context, String spec, URLStreamHandler ph)\n      * The relative URL need not specify all the components of a URL.\n      * If the protocol, host name, or port number is missing, the value\n      * is inherited from the context.  A bare file component is appended\n-     * to the context's file.  The optional anchor is not inherited. \n+     * to the context's file.  The optional anchor is not inherited.\n      */\n \n     // If this is an absolute URL, then ignore context completely.\n     // An absolute URL must have chars prior to \"://\" but cannot have a colon\n     // right after the \"://\".  The second colon is for an optional port value\n     // and implies that the host from the context is used if available.\n     int colon;\n-    if ((colon = spec.indexOf(\"://\", 1)) > 0 &&\n-\t! spec.regionMatches(colon, \"://:\", 0, 4))\n+    if ((colon = spec.indexOf(\"://\", 1)) > 0\n+        && ! spec.regionMatches(colon, \"://:\", 0, 4))\n       context = null;\n \n     int slash;\n-    if ((colon = spec.indexOf(':')) > 0 &&\n-\t(colon < (slash = spec.indexOf('/')) || slash < 0))\n+    if ((colon = spec.indexOf(':')) > 0\n+        && (colon < (slash = spec.indexOf('/')) || slash < 0))\n       {\n \t// Protocol specified in spec string.\n \tprotocol = spec.substring(0, colon).toLowerCase();\n@@ -412,26 +409,27 @@ else if (context != null)\n \tfile = context.file;\n \tif (file == null || file.length() == 0)\n \t  file = \"/\";\n-        authority = context.authority;\n+\tauthority = context.authority;\n       }\n-    else\t// Protocol NOT specified in spec. and no context available.\n-      throw new\n-\t  MalformedURLException(\"Absolute URL required with null context\");\n+    else // Protocol NOT specified in spec. and no context available.\n+\n+\n+      throw new MalformedURLException(\"Absolute URL required with null context\");\n \n     if (ph != null)\n       {\n-\tSecurityManager s = System.getSecurityManager ();\n+\tSecurityManager s = System.getSecurityManager();\n \tif (s != null)\n-\t  s.checkPermission (new NetPermission (\"specifyStreamHandler\"));\n+\t  s.checkPermission(new NetPermission(\"specifyStreamHandler\"));\n \n-        this.ph = ph;\n+\tthis.ph = ph;\n       }\n     else\n       this.ph = getURLStreamHandler(protocol);\n \n     if (this.ph == null)\n       throw new MalformedURLException(\"Protocol handler not found: \"\n-\t\t\t\t      + protocol);\n+                                      + protocol);\n \n     // JDK 1.2 doc for parseURL specifically states that any '#' ref\n     // is to be excluded by passing the 'limit' as the indexOf the '#'\n@@ -441,35 +439,35 @@ else if (context != null)\n     try\n       {\n \tthis.ph.parseURL(this, spec, colon + 1,\n-\t\t\t hashAt < 0 ? spec.length() : hashAt);\n+\t                 hashAt < 0 ? spec.length() : hashAt);\n       }\n     catch (URLParseError e)\n       {\n \tthrow new MalformedURLException(e.getMessage());\n       }\n-    \n+\n     if (hashAt >= 0)\n       ref = spec.substring(hashAt + 1);\n \n-    hashCode = hashCode();\t\t\t// Used for serialization.\n+    hashCode = hashCode(); // Used for serialization.\n   }\n \n   /**\n    * Test another URL for equality with this one.  This will be true only if\n-   * the argument is non-null and all of the fields in the URL's match \n+   * the argument is non-null and all of the fields in the URL's match\n    * exactly (ie, protocol, host, port, file, and ref).  Overrides\n    * Object.equals(), implemented by calling the equals method of the handler.\n    *\n-   * @param url The URL to compare with\n+   * @param obj The URL to compare with\n    *\n    * @return true if the URL is equal, false otherwise\n    */\n-  public boolean equals (Object obj)\n+  public boolean equals(Object obj)\n   {\n     if (! (obj instanceof URL))\n       return false;\n \n-    return ph.equals (this, (URL) obj);\n+    return ph.equals(this, (URL) obj);\n   }\n \n   /**\n@@ -519,7 +517,7 @@ public String getFile()\n    * character.\n    *\n    * @return The path specified in this URL.\n-   * \n+   *\n    * @since 1.3\n    */\n   public String getPath()\n@@ -532,7 +530,7 @@ public String getPath()\n    * Returns the authority of the URL\n    *\n    * @return The authority specified in this URL.\n-   * \n+   *\n    * @since 1.3\n    */\n   public String getAuthority()\n@@ -602,7 +600,7 @@ public String getRef()\n    *\n    * @return the user at a particular host or null when no user defined.\n    */\n-  public String getUserInfo ()\n+  public String getUserInfo()\n   {\n     int at = (host == null) ? -1 : host.indexOf('@');\n     return at < 0 ? null : host.substring(0, at);\n@@ -614,7 +612,7 @@ public String getUserInfo ()\n    *\n    * @return the query part of the file, or null when there is no query part.\n    */\n-  public String getQuery ()\n+  public String getQuery()\n   {\n     int quest = (file == null) ? -1 : file.indexOf('?');\n     return quest < 0 ? null : file.substring(quest + 1, file.length());\n@@ -628,9 +626,9 @@ public String getQuery ()\n   public int hashCode()\n   {\n     if (hashCode != 0)\n-      return hashCode;\t\t// Use cached value if available.\n+      return hashCode; // Use cached value if available.\n     else\n-      return ph.hashCode (this);\n+      return ph.hashCode(this);\n   }\n \n   /**\n@@ -652,7 +650,7 @@ public URLConnection openConnection() throws IOException\n    * from that connection\n    *\n    * @return An <code>InputStream</code> for this URL.\n-   * \n+   *\n    * @exception IOException If an error occurs\n    */\n   public final InputStream openStream() throws IOException\n@@ -670,9 +668,9 @@ public final InputStream openStream() throws IOException\n    *\n    * @return true if URL matches this URL's file, false otherwise\n    */\n-  public boolean sameFile(URL other)\n+  public boolean sameFile(URL url)\n   {\n-    return ph.sameFile(this, other);\n+    return ph.sameFile(this, url);\n   }\n \n   /**\n@@ -688,7 +686,7 @@ public boolean sameFile(URL other)\n    * @param ref The anchor portion of this URL.\n    */\n   protected void set(String protocol, String host, int port, String file,\n-\t\t     String ref)\n+                     String ref)\n   {\n     // TBD: Theoretically, a poorly written StreamHandler could pass an\n     // invalid protocol.  It will cause the handler to be set to null\n@@ -701,7 +699,7 @@ protected void set(String protocol, String host, int port, String file,\n     this.host = host;\n     this.file = file;\n     this.ref = ref;\n-    hashCode = hashCode();\t\t\t// Used for serialization.\n+    hashCode = hashCode(); // Used for serialization.\n   }\n \n   /**\n@@ -720,9 +718,8 @@ protected void set(String protocol, String host, int port, String file,\n    *\n    * @since 1.3\n    */\n-  protected void set(String protocol, String host, int port,\n-\t\t     String authority, String userInfo,\n-\t\t     String path, String query, String ref)\n+  protected void set(String protocol, String host, int port, String authority,\n+                     String userInfo, String path, String query, String ref)\n   {\n     // TBD: Theoretically, a poorly written StreamHandler could pass an\n     // invalid protocol.  It will cause the handler to be set to null\n@@ -740,7 +737,7 @@ protected void set(String protocol, String host, int port,\n     else\n       this.file = path + \"?\" + query;\n     this.ref = ref;\n-    hashCode = hashCode();\t\t\t// Used for serialization.\n+    hashCode = hashCode(); // Used for serialization.\n   }\n \n   /**\n@@ -754,8 +751,7 @@ protected void set(String protocol, String host, int port,\n    * @exception SecurityException If a security manager exists and its\n    * checkSetFactory method doesn't allow the operation\n    */\n-  public static synchronized void\n-\tsetURLStreamHandlerFactory(URLStreamHandlerFactory fac)\n+  public static synchronized void setURLStreamHandlerFactory(URLStreamHandlerFactory fac)\n   {\n     if (factory != null)\n       throw new Error(\"URLStreamHandlerFactory already set\");\n@@ -782,7 +778,7 @@ public String toExternalForm()\n \n   /**\n    * Returns a String representing this URL.  Identical to toExternalForm().\n-   * The value returned is created by the protocol handler's \n+   * The value returned is created by the protocol handler's\n    * toExternalForm method.  Overrides Object.toString()\n    *\n    * @return A string for this URL\n@@ -801,16 +797,15 @@ public String toString()\n    *\n    * @return A URLStreamHandler for this protocol, or null when not found.\n    */\n-  private static synchronized URLStreamHandler\n-    getURLStreamHandler (String protocol)\n+  private static synchronized URLStreamHandler getURLStreamHandler(String protocol)\n   {\n     URLStreamHandler ph = null;\n \n     // First, see if a protocol handler is in our cache.\n     if (cache_handlers)\n       {\n-        if ((ph = (URLStreamHandler) ph_cache.get (protocol)) != null)\n-          return ph;\n+\tif ((ph = (URLStreamHandler) ph_cache.get(protocol)) != null)\n+\t  return ph;\n       }\n \n     // If a non-default factory has been set, use it to find the protocol.\n@@ -850,42 +845,41 @@ else if (protocol.equals (\"file\"))\n \n \t// Tack our default package on at the ends.\n \tif (ph_search_path != null)\n-          ph_search_path += \"|\" + DEFAULT_SEARCH_PATH;\n+\t  ph_search_path += \"|\" + DEFAULT_SEARCH_PATH;\n \telse\n-          ph_search_path = DEFAULT_SEARCH_PATH;\n+\t  ph_search_path = DEFAULT_SEARCH_PATH;\n \n \t// Finally loop through our search path looking for a match.\n-\tStringTokenizer pkgPrefix = new StringTokenizer (ph_search_path, \"|\");\n-        \n+\tStringTokenizer pkgPrefix = new StringTokenizer(ph_search_path, \"|\");\n+\n \tdo\n-          {\n-            String clsName = (pkgPrefix.nextToken() + \".\"\n-\t\t\t      + protocol + \".Handler\");\n-         \n-            try\n-              {\n-                Object obj = Class.forName (clsName).newInstance();\n-\t    \n-                if (!(obj instanceof URLStreamHandler))\n-                  continue;\n-                else\n-                  ph = (URLStreamHandler) obj;\n-              }\n-            catch (Exception e)\n-              {\n-                // Can't instantiate; handler still null,\n+\t  {\n+\t    String clsName =\n+\t      (pkgPrefix.nextToken() + \".\" + protocol + \".Handler\");\n+\n+\t    try\n+\t      {\n+\t\tObject obj = Class.forName(clsName).newInstance();\n+\n+\t\tif (! (obj instanceof URLStreamHandler))\n+\t\t  continue;\n+\t\telse\n+\t\t  ph = (URLStreamHandler) obj;\n+\t      }\n+\t    catch (Exception e)\n+\t      {\n+\t\t// Can't instantiate; handler still null,\n \t\t// go on to next element.\n-              }\n-          }\n-\twhile ((! (ph instanceof URLStreamHandler))\n-               && pkgPrefix.hasMoreTokens());\n+\t      }\n+\t  }\n+\t while ((! (ph instanceof URLStreamHandler))\n+\t        && pkgPrefix.hasMoreTokens());\n       }\n \n     // Update the hashtable with the new protocol handler.\n-    if (ph != null\n-        && cache_handlers)\n+    if (ph != null && cache_handlers)\n       if (ph instanceof URLStreamHandler)\n-\tph_cache.put (protocol, ph);\n+\tph_cache.put(protocol, ph);\n       else\n \tph = null;\n "}, {"sha": "064114989fd61ad8d8c3e11950dfb43348520ea7", "filename": "libjava/java/net/URLClassLoader.java", "status": "modified", "additions": 126, "deletions": 136, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLClassLoader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLClassLoader.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,32 +35,32 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n import java.io.ByteArrayOutputStream;\n import java.io.EOFException;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FilePermission;\n-import java.io.InputStream;\n import java.io.IOException;\n-import java.security.AccessController;\n+import java.io.InputStream;\n import java.security.AccessControlContext;\n+import java.security.AccessController;\n import java.security.CodeSource;\n-import java.security.SecureClassLoader;\n-import java.security.PrivilegedAction;\n import java.security.PermissionCollection;\n+import java.security.PrivilegedAction;\n+import java.security.SecureClassLoader;\n import java.security.cert.Certificate;\n import java.util.Enumeration;\n-import java.util.Vector;\n import java.util.HashMap;\n+import java.util.Vector;\n import java.util.jar.Attributes;\n import java.util.jar.JarEntry;\n import java.util.jar.JarFile;\n import java.util.jar.Manifest;\n import gnu.gcj.runtime.SharedLibHelper;\n \n+\n /**\n  * A secure class loader that can load classes and resources from\n  * multiple locations.  Given an array of <code>URL</code>s this class\n@@ -118,7 +118,6 @@\n  * @author Mark Wielaard (mark@klomp.org)\n  * @author Wu Gansha (gansha.wu@intel.com)\n  */\n- \n public class URLClassLoader extends SecureClassLoader\n {\n   // Class Variables\n@@ -130,7 +129,7 @@ public class URLClassLoader extends SecureClassLoader\n    * XXX - Keeps these loaders forever which prevents garbage collection.\n    */\n   private static HashMap urlloaders = new HashMap();\n-    \n+\n   /**\n    * A cache to store mappings between handler factory and its\n    * private protocol handler cache (also a HashMap), so we can avoid\n@@ -144,12 +143,12 @@ public class URLClassLoader extends SecureClassLoader\n   private final Vector urls = new Vector();\n \n   /**\n-   * Store pre-parsed information for each url into this vector \n-   * each element is a URL loader, corresponding to the URL of \n+   * Store pre-parsed information for each url into this vector\n+   * each element is a URL loader, corresponding to the URL of\n    * the same index in \"urls\"\n    */\n   private final Vector urlinfos = new Vector();\n-    \n+\n   /** Factory used to get the protocol handlers of the URLs */\n   private final URLStreamHandlerFactory factory;\n \n@@ -161,12 +160,12 @@ public class URLClassLoader extends SecureClassLoader\n   private final AccessControlContext securityContext;\n \n   // Helper classes\n- \n-  /** \n+\n+  /**\n    * A <code>URLLoader</code> contains all logic to load resources from a\n    * given base <code>URL</code>.\n    */\n-  static abstract class URLLoader\n+  abstract static class URLLoader\n   {\n     /**\n      * Our classloader to get info from if needed.\n@@ -223,14 +222,14 @@ Manifest getManifest()\n     }\n   }\n \n-  /** \n+  /**\n    * A <code>Resource</code> represents a resource in some\n    * <code>URLLoader</code>. It also contains all information (e.g.,\n    * <code>URL</code>, <code>CodeSource</code>, <code>Manifest</code> and\n    * <code>InputStream</code>) that is necessary for loading resources\n    * and creating classes from a <code>URL</code>.\n    */\n-  static abstract class Resource\n+  abstract static class Resource\n   {\n     final URLLoader loader;\n     final String name;\n@@ -285,10 +284,10 @@ Certificate[] getCertificates()\n    * A <code>JarURLLoader</code> is a type of <code>URLLoader</code>\n    * only loading from jar url.\n    */\n-  final static class JarURLLoader extends URLLoader\n+  static final class JarURLLoader extends URLLoader\n   {\n     final JarFile jarfile; // The jar file for this url\n-    final URL baseJarURL;  // Base jar: url for all resources loaded from jar\n+    final URL baseJarURL; // Base jar: url for all resources loaded from jar\n \n     public JarURLLoader(URLClassLoader classloader, URL baseURL)\n     {\n@@ -305,13 +304,17 @@ public JarURLLoader(URLClassLoader classloader, URL baseURL)\n       URL baseJarURL = null;\n       JarFile jarfile = null;\n       try\n-\t{\n-\t  baseJarURL\n-\t    = new URL(null, jarURL, classloader.getURLStreamHandler(\"jar\"));\n-\t  jarfile\n-\t    = ((JarURLConnection) baseJarURL.openConnection()).getJarFile();\n-\t}\n-      catch (IOException ioe) { /* ignored */ }\n+        {\n+\t  baseJarURL =\n+\t    new URL(null, jarURL, classloader.getURLStreamHandler(\"jar\"));\n+\n+\t  jarfile =\n+\t    ((JarURLConnection) baseJarURL.openConnection()).getJarFile();\n+        }\n+      catch (IOException ioe)\n+        {\n+\t  /* ignored */\n+        }\n \n       this.baseJarURL = baseJarURL;\n       this.jarfile = jarfile;\n@@ -324,10 +327,10 @@ Resource getResource(String name)\n \treturn null;\n \n       if (name.startsWith(\"/\"))\n-        name = name.substring(1);\n+\tname = name.substring(1);\n \n       JarEntry je = jarfile.getJarEntry(name);\n-      if(je != null)\n+      if (je != null)\n \treturn new JarURLResource(this, name, je);\n       else\n \treturn null;\n@@ -336,17 +339,17 @@ Resource getResource(String name)\n     Manifest getManifest()\n     {\n       try\n-\t{\n+        {\n \t  return (jarfile == null) ? null : jarfile.getManifest();\n-\t}\n+        }\n       catch (IOException ioe)\n-\t{\n+        {\n \t  return null;\n-\t}\n+        }\n     }\n   }\n \n-  final static class JarURLResource extends Resource\n+  static final class JarURLResource extends Resource\n   {\n     private final JarEntry entry;\n \n@@ -358,12 +361,12 @@ final static class JarURLResource extends Resource\n \n     InputStream getInputStream() throws IOException\n     {\n-      return ((JarURLLoader)loader).jarfile.getInputStream(entry);\n+      return ((JarURLLoader) loader).jarfile.getInputStream(entry);\n     }\n \n     int getLength()\n     {\n-      return (int)entry.getSize();\n+      return (int) entry.getSize();\n     }\n \n     Certificate[] getCertificates()\n@@ -374,25 +377,25 @@ Certificate[] getCertificates()\n     URL getURL()\n     {\n       try\n-\t{\n-\t  return new URL(((JarURLLoader)loader).baseJarURL, name,\n-\t\t\t loader.classloader.getURLStreamHandler(\"jar\"));\n-\t}\n-      catch(MalformedURLException e)\n-\t{\n+        {\n+\t  return new URL(((JarURLLoader) loader).baseJarURL, name,\n+\t                 loader.classloader.getURLStreamHandler(\"jar\"));\n+        }\n+      catch (MalformedURLException e)\n+        {\n \t  InternalError ie = new InternalError();\n \t  ie.initCause(e);\n \t  throw ie;\n-\t}\n+        }\n     }\n   }\n \n   /**\n    * Loader for remote directories.\n    */\n-  final static class RemoteURLLoader extends URLLoader\n+  static final class RemoteURLLoader extends URLLoader\n   {\n-    final private String protocol;\n+    private final String protocol;\n \n     RemoteURLLoader(URLClassLoader classloader, URL url)\n     {\n@@ -407,9 +410,9 @@ final static class RemoteURLLoader extends URLLoader\n     Resource getResource(String name)\n     {\n       try\n-\t{\n-\t  URL url = new URL(baseURL, name,\n-\t\t\t    classloader.getURLStreamHandler(protocol));\n+        {\n+\t  URL url =\n+\t    new URL(baseURL, name, classloader.getURLStreamHandler(protocol));\n \t  URLConnection connection = url.openConnection();\n \n \t  // Open the connection and check the stream\n@@ -420,35 +423,35 @@ Resource getResource(String name)\n \t  // We can do some extra checking if it is a http request\n \t  if (connection instanceof HttpURLConnection)\n \t    {\n-\t      int response\n-\t\t= ((HttpURLConnection)connection).getResponseCode();\n-\t      if (response/100 != 2)\n+\t      int response =\n+\t\t((HttpURLConnection) connection).getResponseCode();\n+\t      if (response / 100 != 2)\n \t\treturn null;\n \t    }\n \n \t  if (stream != null)\n \t    return new RemoteResource(this, name, url, stream, length);\n \t  else\n \t    return null;\n-\t}\n+        }\n       catch (IOException ioe)\n-\t{\n+        {\n \t  return null;\n-\t}\n+        }\n     }\n   }\n \n   /**\n    * A resource from some remote location.\n    */\n-  final static class RemoteResource extends Resource\n+  static final class RemoteResource extends Resource\n   {\n-    final private URL url;\n-    final private InputStream stream;\n-    final private int length;\n+    private final URL url;\n+    private final InputStream stream;\n+    private final int length;\n \n     RemoteResource(RemoteURLLoader loader, String name, URL url,\n-\t\t   InputStream stream, int length)\n+                   InputStream stream, int length)\n     {\n       super(loader, name);\n       this.url = url;\n@@ -533,9 +536,9 @@ public URL getURL ()\n    * A <code>FileURLLoader</code> is a type of <code>URLLoader</code>\n    * only loading from file url.\n    */\n-  final static class FileURLLoader extends URLLoader\n+  static final class FileURLLoader extends URLLoader\n   {\n-    File dir;   //the file for this file url\n+    File dir; //the file for this file url\n \n     FileURLLoader(URLClassLoader classloader, URL url)\n     {\n@@ -547,13 +550,13 @@ final static class FileURLLoader extends URLLoader\n     Resource getResource(String name)\n     {\n       File file = new File(dir, name);\n-      if (file.exists() && !file.isDirectory())\n+      if (file.exists() && ! file.isDirectory())\n \treturn new FileResource(this, name, file);\n       return null;\n     }\n   }\n \n-  final static class FileResource extends Resource\n+  static final class FileResource extends Resource\n   {\n     final File file;\n \n@@ -567,28 +570,28 @@ InputStream getInputStream() throws IOException\n     {\n       return new FileInputStream(file);\n     }\n-                        \n+\n     public int getLength()\n     {\n-      return (int)file.length();\n+      return (int) file.length();\n     }\n \n     public URL getURL()\n     {\n       try\n-\t{\n+        {\n \t  return new URL(loader.baseURL, name,\n-\t\t\t loader.classloader.getURLStreamHandler(\"file\"));\n-\t}\n-      catch(MalformedURLException e)\n-\t{\n+\t                 loader.classloader.getURLStreamHandler(\"file\"));\n+        }\n+      catch (MalformedURLException e)\n+        {\n \t  InternalError ie = new InternalError();\n \t  ie.initCause(e);\n \t  throw ie;\n-\t}\n+        }\n     }\n   }\n-    \n+\n   // Constructors\n \n   /**\n@@ -642,7 +645,7 @@ private URLClassLoader(AccessControlContext securityContext)\n    * load classes and resources (after using the supplied parent ClassLoader).\n    * @exception SecurityException if the SecurityManager disallows the\n    * creation of a ClassLoader.\n-   * @exception SecurityException \n+   * @exception SecurityException\n    * @param urls Locations that should be searched by this ClassLoader when\n    * resolving Classes or Resources.\n    * @param parent The parent class loader used before trying this class\n@@ -672,7 +675,7 @@ public URLClassLoader(URL[] urls, ClassLoader parent)\n    * @param securityContext the security context of the unprivileged code.\n    */\n   private URLClassLoader(ClassLoader parent,\n-\t\t\t AccessControlContext securityContext)\n+                         AccessControlContext securityContext)\n   {\n     super(parent);\n     this.factory = null;\n@@ -690,17 +693,16 @@ private URLClassLoader(ClassLoader parent,\n    * protocol handlers of the supplied URLs.\n    * @exception SecurityException if the SecurityManager disallows the\n    * creation of a ClassLoader.\n-   * @exception SecurityException \n+   * @exception SecurityException\n    * @param urls Locations that should be searched by this ClassLoader when\n    * resolving Classes or Resources.\n    * @param parent The parent class loader used before trying this class\n    * loader.\n    * @param factory Used to get the protocol handler for the URLs.\n    * @see SecureClassLoader\n    */\n-  public URLClassLoader(URL[] urls,\n-\t\t\tClassLoader parent,\n-\t\t\tURLStreamHandlerFactory factory)\n+  public URLClassLoader(URL[] urls, ClassLoader parent,\n+                        URLStreamHandlerFactory factory)\n     throws SecurityException\n   {\n     super(parent);\n@@ -711,7 +713,7 @@ public URLClassLoader(URL[] urls,\n     // If this factory is still not in factoryCache, add it,\n     //   since we only support three protocols so far, 5 is enough \n     //   for cache initial size\n-    synchronized(factoryCache)\n+    synchronized (factoryCache)\n       {\n \tif (factory != null && factoryCache.get(factory) == null)\n \t  factoryCache.put(factory, new HashMap(5));\n@@ -731,14 +733,14 @@ protected void addURL(URL newUrl)\n \n   private void addURLImpl(URL newUrl)\n   {\n-    synchronized(urlloaders)\n+    synchronized (urlloaders)\n       {\n \tif (newUrl == null)\n \t  return; // Silently ignore...\n-        \n+\n \t// Check global cache to see if there're already url loader\n \t// for this url.\n-\tURLLoader loader = (URLLoader)urlloaders.get(newUrl);\n+\tURLLoader loader = (URLLoader) urlloaders.get(newUrl);\n \tif (loader == null)\n \t  {\n \t    String file = newUrl.getFile();\n@@ -769,12 +771,10 @@ else if (\"file\".equals(protocol))\n   private void addURLs(URL[] newUrls)\n   {\n     for (int i = 0; i < newUrls.length; i++)\n-    {\n       addURLImpl(newUrls[i]);\n-    }\n   }\n \n-  /** \n+  /**\n    * Defines a Package based on the given name and the supplied manifest\n    * information. The manifest indicates the tile, version and\n    * vendor information of the specification and implementation and wheter the\n@@ -789,22 +789,16 @@ private void addURLs(URL[] newUrls)\n    * @param url the code source url to seal the package\n    * @return the defined Package\n    */\n-  protected Package definePackage(String name, Manifest manifest, URL url) \n+  protected Package definePackage(String name, Manifest manifest, URL url)\n     throws IllegalArgumentException\n   {\n     Attributes attr = manifest.getMainAttributes();\n-    String specTitle =\n-      attr.getValue(Attributes.Name.SPECIFICATION_TITLE); \n-    String specVersion =\n-      attr.getValue(Attributes.Name.SPECIFICATION_VERSION); \n-    String specVendor =\n-      attr.getValue(Attributes.Name.SPECIFICATION_VENDOR); \n-    String implTitle =\n-      attr.getValue(Attributes.Name.IMPLEMENTATION_TITLE); \n-    String implVersion =\n-      attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION); \n-    String implVendor =\n-      attr.getValue(Attributes.Name.IMPLEMENTATION_VENDOR);\n+    String specTitle = attr.getValue(Attributes.Name.SPECIFICATION_TITLE);\n+    String specVersion = attr.getValue(Attributes.Name.SPECIFICATION_VERSION);\n+    String specVendor = attr.getValue(Attributes.Name.SPECIFICATION_VENDOR);\n+    String implTitle = attr.getValue(Attributes.Name.IMPLEMENTATION_TITLE);\n+    String implVersion = attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION);\n+    String implVendor = attr.getValue(Attributes.Name.IMPLEMENTATION_VENDOR);\n \n     // Look if the Manifest indicates that this package is sealed\n     // XXX - most likely not completely correct!\n@@ -813,13 +807,11 @@ protected Package definePackage(String name, Manifest manifest, URL url)\n     // But how do we get that jar manifest here?\n     String sealed = attr.getValue(Attributes.Name.SEALED);\n     if (\"false\".equals(sealed))\n-    {\n       // make sure that the URL is null so the package is not sealed\n       url = null;\n-    }\n \n-    return definePackage(name, specTitle, specVersion, specVendor,\n-\t\t\t implTitle, implVersion, implVendor, url);\n+    return definePackage(name, specTitle, specVersion, specVendor, implTitle,\n+                         implVersion, implVendor, url);\n   }\n \n   /**\n@@ -857,7 +849,7 @@ protected Class findClass(final String className)\n     // construct the class (and watch out for those nasty IOExceptions)\n     try\n       {\n-\tbyte [] data;\n+\tbyte[] data;\n \tInputStream in = resource.getInputStream();\n \tint length = resource.getLength();\n \tif (length != -1)\n@@ -894,24 +886,24 @@ protected Class findClass(final String className)\n \n \t// Now get the CodeSource\n \tfinal CodeSource source = resource.getCodeSource();\n-\t\n+\n \t// Find out package name\n \tString packageName = null;\n \tint lastDot = className.lastIndexOf('.');\n \tif (lastDot != -1)\n \t  packageName = className.substring(0, lastDot);\n-\t\n+\n \tif (packageName != null && getPackage(packageName) == null)\n \t  {\n \t    // define the package\n \t    Manifest manifest = resource.loader.getManifest();\n \t    if (manifest == null)\n-\t      definePackage(packageName,\n-\t\t\t    null, null, null, null, null, null, null);\n+\t      definePackage(packageName, null, null, null, null, null, null,\n+\t                    null);\n \t    else\n \t      definePackage(packageName, manifest, resource.loader.baseURL);\n \t  }\n-\t\n+\n \t// And finally construct the class!\n \tSecurityManager sm = System.getSecurityManager();\n \tif (sm != null && securityContext != null)\n@@ -928,9 +920,7 @@ public Object run()\n \t\t}, securityContext);\n \t  }\n \telse\n-\t  return defineClass(className, classData,\n-\t\t\t     0, classData.length,\n-\t\t\t     source);\n+\t  return defineClass(className, classData, 0, classData.length, source);\n       }\n     catch (IOException ioe)\n       {\n@@ -950,10 +940,10 @@ private Resource findURLResource(String resourceName)\n     int max = urls.size();\n     for (int i = 0; i < max; i++)\n       {\n-\tURLLoader loader = (URLLoader)urlinfos.elementAt(i);\n+\tURLLoader loader = (URLLoader) urlinfos.elementAt(i);\n \tif (loader == null)\n \t  continue;\n-\t\n+\n \tResource resource = loader.getResource(resourceName);\n \tif (resource != null)\n \t  return resource;\n@@ -972,7 +962,7 @@ public URL findResource(String resourceName)\n     Resource resource = findURLResource(resourceName);\n     if (resource != null)\n       return resource.getURL();\n-    \n+\n     // Resource not found\n     return null;\n   }\n@@ -993,9 +983,9 @@ URLStreamHandler getURLStreamHandler(String protocol)\n     synchronized (factoryCache)\n       {\n \t// Check if there're handler for the same protocol in cache.\n-\tHashMap cache = (HashMap)factoryCache.get(factory);\n-\thandler = (URLStreamHandler)cache.get(protocol);\n-\tif(handler == null)\n+\tHashMap cache = (HashMap) factoryCache.get(factory);\n+\thandler = (URLStreamHandler) cache.get(protocol);\n+\tif (handler == null)\n \t  {\n \t    // Add it to cache.\n \t    handler = factory.createURLStreamHandler(protocol);\n@@ -1014,13 +1004,14 @@ URLStreamHandler getURLStreamHandler(String protocol)\n    * @return a (possible empty) enumeration of URLs where the resource can be\n    * found\n    */\n-  public Enumeration findResources(String resourceName) throws IOException\n+  public Enumeration findResources(String resourceName)\n+    throws IOException\n   {\n     Vector resources = new Vector();\n     int max = urls.size();\n     for (int i = 0; i < max; i++)\n       {\n-\tURLLoader loader = (URLLoader)urlinfos.elementAt(i);\n+\tURLLoader loader = (URLLoader) urlinfos.elementAt(i);\n \tResource resource = loader.getResource(resourceName);\n \tif (resource != null)\n \t  resources.add(resource.getURL());\n@@ -1052,16 +1043,16 @@ protected PermissionCollection getPermissions(CodeSource source)\n   {\n     // XXX - This implementation does exactly as the Javadoc describes.\n     // But maybe we should/could use URLConnection.getPermissions()?\n-\n     // First get the permissions that would normally be granted\n     PermissionCollection permissions = super.getPermissions(source);\n-        \n+\n     // Now add any extra permissions depending on the URL location.\n     URL url = source.getLocation();\n     String protocol = url.getProtocol();\n     if (protocol.equals(\"file\"))\n       {\n \tString file = url.getFile();\n+\n \t// If the file end in / it must be an directory.\n \tif (file.endsWith(\"/\") || file.endsWith(File.separator))\n \t  {\n@@ -1086,7 +1077,7 @@ protected PermissionCollection getPermissions(CodeSource source)\n \n     return permissions;\n   }\n-    \n+\n   /**\n    * Returns all the locations that this class loader currently uses the\n    * resolve classes and resource. This includes both the initially supplied\n@@ -1109,7 +1100,7 @@ public URL[] getURLs()\n    * @exception SecurityException when the calling code does not have\n    * permission to access the given <code>URL</code>s\n    */\n-  public static URLClassLoader newInstance(URL urls[])\n+  public static URLClassLoader newInstance(URL[] urls)\n     throws SecurityException\n   {\n     return newInstance(urls, null);\n@@ -1127,8 +1118,7 @@ public static URLClassLoader newInstance(URL urls[])\n    * @exception SecurityException when the calling code does not have\n    * permission to access the given <code>URL</code>s\n    */\n-  public static URLClassLoader newInstance(URL urls[],\n-\t\t\t\t\t   final ClassLoader parent)\n+  public static URLClassLoader newInstance(URL[] urls, final ClassLoader parent)\n     throws SecurityException\n   {\n     SecurityManager sm = System.getSecurityManager();\n@@ -1137,21 +1127,21 @@ public static URLClassLoader newInstance(URL urls[],\n     else\n       {\n \tfinal Object securityContext = sm.getSecurityContext();\n+\n \t// XXX - What to do with anything else then an AccessControlContext?\n-\tif (!(securityContext instanceof AccessControlContext))\n-\t  throw new SecurityException\n-\t    (\"securityContext must be AccessControlContext: \"\n-\t     + securityContext);\n-\t\n+\tif (! (securityContext instanceof AccessControlContext))\n+\t  throw new SecurityException(\"securityContext must be AccessControlContext: \"\n+\t                              + securityContext);\n+\n \tURLClassLoader loader =\n-\t  (URLClassLoader)AccessController.doPrivileged(new PrivilegedAction()\n-\t    {\n-\t      public Object run()\n+\t  (URLClassLoader) AccessController.doPrivileged(new PrivilegedAction()\n \t      {\n-\t\treturn new URLClassLoader\n-\t\t  (parent, (AccessControlContext)securityContext);\n-\t      }\n-\t    });\n+\t\tpublic Object run()\n+\t\t{\n+\t\t  return new URLClassLoader(parent,\n+\t\t                            (AccessControlContext) securityContext);\n+\t\t}\n+\t      });\n \tloader.addURLs(urls);\n \treturn loader;\n       }"}, {"sha": "6b125680cacae448053d841971fd0cbde6f533df", "filename": "libjava/java/net/URLConnection.java", "status": "modified", "additions": 75, "deletions": 71, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLConnection.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLConnection.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLConnection.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,11 +35,10 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n-import java.io.InputStream;\n import java.io.IOException;\n+import java.io.InputStream;\n import java.io.OutputStream;\n import java.security.AllPermission;\n import java.security.Permission;\n@@ -53,13 +52,13 @@\n import java.util.StringTokenizer;\n import gnu.gcj.io.MimeTypes;\n \n+\n /**\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  One guessContentTypeFrom... methods not implemented.\n  *    getContent method assumes content type from response; see comment there.\n  */\n-\n /**\n  * This class models a connection that retrieves the information pointed\n  * to by a URL object.  This is typically a connection to a remote node\n@@ -99,18 +98,18 @@\n    * instance and store it here.\n    */\n   private static FileNameMap fileNameMap;\n- \n+\n   /**\n    * This is the ContentHandlerFactory set by the caller, if any\n    */\n   private static ContentHandlerFactory factory;\n-  \n+\n   /**\n    * This is the default value that will be used to determine whether or\n    * not user interaction should be allowed.\n    */\n   private static boolean defaultAllowUserInteraction = false;\n-  \n+\n   /**\n    * This is the default flag indicating whether or not to use caches to\n    * store the data returned from a server\n@@ -128,17 +127,17 @@\n    * destination specified in the URL\n    */\n   protected boolean connected = false;\n-  \n+\n   /**\n    * Indicates whether or not input can be read from this URL\n    */\n   protected boolean doInput = true;\n-  \n+\n   /**\n    * Indicates whether or not output can be sent to this URL\n    */\n   protected boolean doOutput = false;\n-  \n+\n   /**\n    * If this flag is set, the protocol is allowed to cache data whenever\n    * it can (caching is not guaranteed). If it is not set, the protocol\n@@ -188,6 +187,8 @@ protected URLConnection(URL url)\n   /**\n    * Establishes the actual connection to the URL associated with this\n    * connection object\n+   *\n+   * @exception IOException if an error occurs\n    */\n   public abstract void connect() throws IOException;\n \n@@ -230,7 +231,7 @@ public String getContentType()\n   /**\n    * Returns the value of the content-encoding field or null if it is not\n    * known or not present.\n-   * \n+   *\n    * @return The content-encoding field\n    */\n   public String getContentEncoding()\n@@ -295,7 +296,7 @@ public String getHeaderField(int index)\n    * Returns a String representing the value of the header field having\n    * the named key.  Returns null if the header field does not exist.\n    *\n-   * @param The key of the header field\n+   * @param name The key of the header field\n    *\n    * @return The value of the header field as a String\n    */\n@@ -307,7 +308,9 @@ public String getHeaderField(String name)\n \n   /**\n    * Returns a map of all sent header fields\n-   * \n+   *\n+   * @return all header fields\n+   *\n    * @since 1.4\n    */\n   public Map getHeaderFields()\n@@ -330,18 +333,18 @@ public Map getHeaderFields()\n    */\n   public int getHeaderFieldInt(String name, int defaultValue)\n   {\n-    String value = getHeaderField (name);\n-    \n+    String value = getHeaderField(name);\n+\n     if (value == null)\n       return defaultValue;\n \n     try\n       {\n-        return Integer.parseInt (value);\n+\treturn Integer.parseInt(value);\n       }\n-    catch (NumberFormatException e) \n-      { \n-        return defaultValue;\n+    catch (NumberFormatException e)\n+      {\n+\treturn defaultValue;\n       }\n   }\n \n@@ -357,25 +360,25 @@ public int getHeaderFieldInt(String name, int defaultValue)\n    * @return Returns the date value of the header filed or the default value\n    * if the field is missing or malformed\n    */\n-  public long getHeaderFieldDate (String name, long defaultValue)\n+  public long getHeaderFieldDate(String name, long defaultValue)\n   {\n     if (! dateformats_initialized)\n-      initializeDateFormats ();\n-    \n+      initializeDateFormats();\n+\n     long result = defaultValue;\n-    String str = getHeaderField (name);\n-    \n+    String str = getHeaderField(name);\n+\n     if (str != null)\n       {\n \tDate date;\n-\tif ((date = dateFormat1.parse (str, new ParsePosition (0))) != null)\n-\t  result = date.getTime ();\n-\telse if ((date = dateFormat2.parse (str, new ParsePosition (0))) != null)\n-\t  result = date.getTime ();\n-\telse if ((date = dateFormat3.parse (str, new ParsePosition (0))) != null)\n-\t  result = date.getTime ();\n+\tif ((date = dateFormat1.parse(str, new ParsePosition(0))) != null)\n+\t  result = date.getTime();\n+\telse if ((date = dateFormat2.parse(str, new ParsePosition(0))) != null)\n+\t  result = date.getTime();\n+\telse if ((date = dateFormat3.parse(str, new ParsePosition(0))) != null)\n+\t  result = date.getTime();\n       }\n-    \n+\n     return result;\n   }\n \n@@ -385,12 +388,12 @@ else if ((date = dateFormat3.parse (str, new ParsePosition (0))) != null)\n    * getHeaderField(int) method allows access to the corresponding value for\n    * this tag.\n    *\n-   * @param index The index into the header field list to retrieve the key for. \n+   * @param index The index into the header field list to retrieve the key for.\n    *\n    * @return The header field key or null if index is past the end\n    * of the headers.\n    */\n-  public String getHeaderFieldKey (int index)\n+  public String getHeaderFieldKey(int index)\n   {\n     // Subclasses for specific protocols override this.\n     return null;\n@@ -407,7 +410,7 @@ public String getHeaderFieldKey (int index)\n    * This class first determines the MIME type of the content, then creates\n    * a ContentHandler object to process the input.  If the ContentHandlerFactory\n    * is set, then that object is called to load a content handler, otherwise\n-   * a class called gnu.java.net.content.<content_type> is tried.\n+   * a class called gnu.java.net.content.&lt;content_type&gt; is tried.\n    * The default class will also be used if the content handler factory returns\n    * a null content handler.\n    *\n@@ -436,14 +439,16 @@ public Object getContent() throws IOException\n   /**\n    * Retrieves the content of this URLConnection\n    *\n+   * @param classes The allowed classes for the content\n+   *\n    * @exception IOException If an error occurs\n    * @exception UnknownServiceException If the protocol does not support the\n    * content type\n    */\n   public Object getContent(Class[] classes) throws IOException\n   {\n     // FIXME: implement this\n-    return getContent ();\n+    return getContent();\n   }\n \n   /**\n@@ -480,8 +485,8 @@ public Permission getPermission() throws IOException\n   public InputStream getInputStream() throws IOException\n   {\n     // Subclasses for specific protocols override this.\n-    throw new UnknownServiceException(\"Protocol \" + url.getProtocol() +\n-\t\t\t\" does not support input.\");\n+    throw new UnknownServiceException(\"Protocol \" + url.getProtocol()\n+                                      + \" does not support input.\");\n   }\n \n   /**\n@@ -496,14 +501,14 @@ public InputStream getInputStream() throws IOException\n   public OutputStream getOutputStream() throws IOException\n   {\n     // Subclasses for specific protocols override this.\n-    throw new UnknownServiceException(\"Protocol \" + url.getProtocol() +\n-\t\t\t\" does not support output.\");\n+    throw new UnknownServiceException(\"Protocol \" + url.getProtocol()\n+                                      + \" does not support output.\");\n   }\n \n   /**\n    * The methods prints the value of this object as a String by calling the\n    * toString() method of its associated URL.  Overrides Object.toString()\n-   * \n+   *\n    * @return A String representation of this object\n    */\n   public String toString()\n@@ -515,7 +520,7 @@ public String toString()\n    * Returns the value of a flag indicating whether or not input is going\n    * to be done for this connection.  This default to true unless the\n    * doOutput flag is set to false, in which case this defaults to false.\n-   * \n+   *\n    * @param input <code>true</code> if input is to be done,\n    * <code>false</code> otherwise\n    *\n@@ -524,7 +529,7 @@ public String toString()\n   public void setDoInput(boolean input)\n   {\n     if (connected)\n-      throw new IllegalStateException (\"Already connected\");\n+      throw new IllegalStateException(\"Already connected\");\n \n     doInput = input;\n   }\n@@ -553,7 +558,7 @@ public boolean getDoInput()\n   public void setDoOutput(boolean output)\n   {\n     if (connected)\n-      throw new IllegalStateException (\"Already connected\");\n+      throw new IllegalStateException(\"Already connected\");\n \n     doOutput = output;\n   }\n@@ -628,7 +633,7 @@ public static boolean getDefaultAllowUserInteraction()\n   public void setUseCaches(boolean usecaches)\n   {\n     if (connected)\n-      throw new IllegalStateException (\"Already connected\");\n+      throw new IllegalStateException(\"Already connected\");\n \n     useCaches = usecaches;\n   }\n@@ -659,7 +664,7 @@ public boolean getUseCaches()\n   public void setIfModifiedSince(long ifmodifiedsince)\n   {\n     if (connected)\n-      throw new IllegalStateException (\"Already connected\");\n+      throw new IllegalStateException(\"Already connected\");\n \n     ifModifiedSince = ifmodifiedsince;\n   }\n@@ -695,33 +700,33 @@ public boolean getDefaultUseCaches()\n    *\n    * @param use true to use caches if possible by default, false otherwise\n    */\n-  public void setDefaultUseCaches(boolean defaultusecaches)\n+  public void setDefaultUseCaches(boolean use)\n   {\n-    defaultUseCaches = defaultusecaches;\n+    defaultUseCaches = use;\n   }\n \n   /**\n    * Sets the value of the named request property\n    *\n    * @param key The name of the property\n    * @param value The value of the property\n-   * \n+   *\n    * @exception IllegalStateException If already connected\n    * @exception NullPointerException If key is null\n    *\n    * @see URLConnection#getRequestProperty(String key)\n    * @see URLConnection#addRequestProperty(String key, String value)\n-   * \n+   *\n    * @since 1.4\n    */\n   public void setRequestProperty(String key, String value)\n   {\n     if (connected)\n-      throw new IllegalStateException (\"Already connected\");\n+      throw new IllegalStateException(\"Already connected\");\n \n     if (key == null)\n-      throw new NullPointerException (\"key is null\");\n-    \n+      throw new NullPointerException(\"key is null\");\n+\n     // Do nothing unless overridden by subclasses that support setting\n     // header fields in the request.\n   }\n@@ -735,20 +740,20 @@ public void setRequestProperty(String key, String value)\n    *\n    * @exception IllegalStateException If already connected\n    * @exception NullPointerException If key is null\n-   * \n+   *\n    * @see URLConnection#getRequestProperty(String key)\n    * @see URLConnection#setRequestProperty(String key, String value)\n-   * \n+   *\n    * @since 1.4\n    */\n   public void addRequestProperty(String key, String value)\n   {\n     if (connected)\n-      throw new IllegalStateException (\"Already connected\");\n+      throw new IllegalStateException(\"Already connected\");\n \n     if (key == null)\n-      throw new NullPointerException (\"key is null\");\n-    \n+      throw new NullPointerException(\"key is null\");\n+\n     // Do nothing unless overridden by subclasses that support adding\n     // header fields in the request.\n   }\n@@ -768,7 +773,7 @@ public void addRequestProperty(String key, String value)\n   public String getRequestProperty(String key)\n   {\n     if (connected)\n-      throw new IllegalStateException (\"Already connected\");\n+      throw new IllegalStateException(\"Already connected\");\n \n     // Overridden by subclasses that support reading header fields from the\n     // request.\n@@ -787,7 +792,7 @@ public String getRequestProperty(String key)\n   public Map getRequestProperties()\n   {\n     if (connected)\n-      throw new IllegalStateException (\"Already connected\");\n+      throw new IllegalStateException(\"Already connected\");\n \n     // Overridden by subclasses that support reading header fields from the\n     // request.\n@@ -807,7 +812,7 @@ public Map getRequestProperties()\n    *\n    * @see URLConnection#setRequestProperty(String key, String value)\n    */\n-  public static void setDefaultRequestProperty (String key, String value)\n+  public static void setDefaultRequestProperty(String key, String value)\n   {\n     // This method does nothing since JDK 1.3.\n   }\n@@ -820,7 +825,7 @@ public static void setDefaultRequestProperty (String key, String value)\n    * @param key The request property to return the default value of\n    *\n    * @return The value of the default property or null if not available\n-   * \n+   *\n    * @deprecated 1.3 The method getRequestProperty should be used instead.\n    * This method does nothing now.\n    *\n@@ -844,10 +849,9 @@ public static String getDefaultRequestProperty(String key)\n    * @exception SecurityException If a security manager exists and its\n    * checkSetFactory method doesn't allow the operation\n    */\n-  public static synchronized void setContentHandlerFactory\n-                                    (ContentHandlerFactory fac)\n+  public static synchronized void setContentHandlerFactory(ContentHandlerFactory factory)\n   {\n-    if (factory != null)\n+    if (URLConnection.factory != null)\n       throw new Error(\"ContentHandlerFactory already set\");\n \n     // Throw an exception if an extant security mgr precludes\n@@ -856,7 +860,7 @@ public static String getDefaultRequestProperty(String key)\n     if (s != null)\n       s.checkSetFactory();\n \n-    factory = fac;\n+    URLConnection.factory = factory;\n   }\n \n   /**\n@@ -895,7 +899,7 @@ public static String guessContentTypeFromName(String filename)\n    * Returns the MIME type of a stream based on the first few characters\n    * at the beginning of the stream.  This routine can be used to determine\n    * the MIME type if a server is believed to be returning an incorrect\n-   * MIME type.  This method returns \"application/octet-stream\" if it \n+   * MIME type.  This method returns \"application/octet-stream\" if it\n    * cannot determine the MIME type.\n    * <p>\n    * NOTE: Overriding MIME types sent from the server can be obnoxious\n@@ -937,7 +941,7 @@ public static FileNameMap getFileNameMap()\n    *\n    * @exception SecurityException If a security manager exists and its\n    * checkSetFactory method doesn't allow the operation\n-   * \n+   *\n    * @since 1.2\n    */\n   public static void setFileNameMap(FileNameMap map)\n@@ -1040,10 +1044,10 @@ private synchronized void initializeDateFormats()\n       return;\n \n     Locale locale = new Locale(\"En\", \"Us\", \"Unix\");\n-    dateFormat1 = new SimpleDateFormat(\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", \n-                                       locale);\n-    dateFormat2 = new SimpleDateFormat(\"EEEE, dd-MMM-yy hh:mm:ss 'GMT'\", \n-                                       locale);\n+    dateFormat1 =\n+      new SimpleDateFormat(\"EEE, dd MMM yyyy hh:mm:ss 'GMT'\", locale);\n+    dateFormat2 =\n+      new SimpleDateFormat(\"EEEE, dd-MMM-yy hh:mm:ss 'GMT'\", locale);\n     dateFormat3 = new SimpleDateFormat(\"EEE MMM d hh:mm:ss yyyy\", locale);\n     dateformats_initialized = true;\n   }"}, {"sha": "d2c403a585f9bd7818c059187952cb241b76b86b", "filename": "libjava/java/net/URLDecoder.java", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLDecoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLDecoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLDecoder.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -39,8 +39,9 @@\n \n import java.io.UnsupportedEncodingException;\n \n+\n /**\n- * This utility class contains static methods that converts a \n+ * This utility class contains static methods that converts a\n  * string encoded in the x-www-form-urlencoded format to the original\n  * text.  The x-www-form-urlencoded format replaces certain disallowed\n  * characters with encoded equivalents.  All upper case and lower case\n@@ -65,7 +66,7 @@\n   /**\n    * Public contructor. Note that this class has only static methods.\n    */\n-  public URLDecoder ()\n+  public URLDecoder()\n   {\n   }\n \n@@ -84,12 +85,12 @@ public static String decode(String s)\n   {\n     try\n       {\n-        return decode(s, \"UTF-8\");\n+\treturn decode(s, \"UTF-8\");\n       }\n     catch (UnsupportedEncodingException uee)\n       {\n-        // Should never happen since UTF-8 encoding should always be supported\n-        return s;\n+\t// Should never happen since UTF-8 encoding should always be supported\n+\treturn s;\n       }\n   }\n \n@@ -120,7 +121,7 @@ public static String decode(String s, String encoding)\n   {\n     // First convert all '+' characters to spaces.\n     String str = s.replace('+', ' ');\n-    \n+\n     // Then go through the whole string looking for byte encoded characters\n     int i;\n     int start = 0;\n@@ -134,20 +135,20 @@ public static String decode(String s, String encoding)\n \tstart = i;\n \n \t// Get all consecutive encoded bytes\n-\twhile ((i+2 < length) && (str.charAt(i) == '%'))\n+\twhile ((i + 2 < length) && (str.charAt(i) == '%'))\n \t  i += 3;\n \n \t// Decode all these bytes\n-\tif ((bytes == null) || (bytes.length < ((i-start)/3)))\n-\t  bytes = new byte[((i-start)/3)];\n+\tif ((bytes == null) || (bytes.length < ((i - start) / 3)))\n+\t  bytes = new byte[((i - start) / 3)];\n \n \tint index = 0;\n \ttry\n \t  {\n \t    while (start < i)\n \t      {\n \t\tString sub = str.substring(start + 1, start + 3);\n-\t\tbytes[index] = (byte)Integer.parseInt(sub, 16);\n+\t\tbytes[index] = (byte) Integer.parseInt(sub, 16);\n \t\tindex++;\n \t\tstart += 3;\n \t      }\n@@ -176,5 +177,4 @@ public static String decode(String s, String encoding)\n \n     return result.toString();\n   }\n-\n } // class URLDecoder"}, {"sha": "fbabb0f89b8532fd4dd62b9ebb3a0aa9ce45550b", "filename": "libjava/java/net/URLEncoder.java", "status": "modified", "additions": 62, "deletions": 60, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLEncoder.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLEncoder.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLEncoder.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -39,29 +39,30 @@\n \n import java.io.UnsupportedEncodingException;\n \n+\n /*\n  * Written using on-line Java Platform 1.2/1.4 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n  */\n \n- /**\n-  * This utility class contains static methods that converts a \n-  * string into a fully encoded URL string in x-www-form-urlencoded\n-  * format.  This format replaces certain disallowed characters with\n-  * encoded equivalents.  All upper case and lower case letters in the\n-  * US alphabet remain as is, the space character (' ') is replaced with\n-  * '+' sign, and all other characters are converted to a \"%XX\" format\n-  * where XX is the hexadecimal representation of that character in a\n-  * certain encoding (by default, the platform encoding, though the\n-  * standard is \"UTF-8\").\n-  * <p>\n-  * This method is very useful for encoding strings to be sent to CGI scripts\n-  *\n-  * @author Aaron M. Renn (arenn@urbanophile.com)\n-  * @author Warren Levy <warrenl@cygnus.com>\n-  * @author Mark Wielaard (mark@klomp.org)\n-  */\n+/**\n+ * This utility class contains static methods that converts a\n+ * string into a fully encoded URL string in x-www-form-urlencoded\n+ * format.  This format replaces certain disallowed characters with\n+ * encoded equivalents.  All upper case and lower case letters in the\n+ * US alphabet remain as is, the space character (' ') is replaced with\n+ * '+' sign, and all other characters are converted to a \"%XX\" format\n+ * where XX is the hexadecimal representation of that character in a\n+ * certain encoding (by default, the platform encoding, though the\n+ * standard is \"UTF-8\").\n+ * <p>\n+ * This method is very useful for encoding strings to be sent to CGI scripts\n+ *\n+ * @author Aaron M. Renn (arenn@urbanophile.com)\n+ * @author Warren Levy <warrenl@cygnus.com>\n+ * @author Mark Wielaard (mark@klomp.org)\n+ */\n public class URLEncoder\n {\n   /**\n@@ -82,11 +83,11 @@ public static String encode(String s)\n       {\n \t// We default to 8859_1 for compatibility with the same\n \t// default elsewhere in the library.\n-        return encode(s, System.getProperty(\"file.encoding\", \"8859_1\"));\n+\treturn encode(s, System.getProperty(\"file.encoding\", \"8859_1\"));\n       }\n     catch (UnsupportedEncodingException uee)\n       {\n-        // Should never happen since default should always be supported\n+\t// Should never happen since default should always be supported\n \treturn s;\n       }\n   }\n@@ -114,42 +115,42 @@ public static String encode(String s, String encoding)\n \n     StringBuffer result = new StringBuffer(length);\n     while (true)\n-    {\n-      while ( i < length && isSafe(s.charAt(i)) )\n-\ti++;\n-\n-      // Safe character can just be added\n-      result.append(s.substring(start, i));\n-\n-      // Are we done?\n-      if (i >= length)\n-\treturn result.toString();\n-      else if (s.charAt(i) == ' ')\n-        {\n-\t  result.append('+');  // Replace space char with plus symbol.\n+      {\n+\twhile (i < length && isSafe(s.charAt(i)))\n \t  i++;\n-\t}\n-      else\n-\t{\n-\t  // Get all unsafe characters\n-\t  start = i;\n-\t  char c;\n-\t  while ( i < length && (c = s.charAt(i)) != ' ' && !isSafe(c) )\n-\t    i++;\n \n-\t  // Convert them to %XY encoded strings\n-\t  String unsafe = s.substring(start,i);\n-\t  byte bytes[] = unsafe.getBytes(encoding);\n-\t  for (int j = 0; j < bytes.length; j++)\n-\t    {\n-\t      result.append('%');\n-\t      int val = bytes[j];\n-\t      result.append(hex.charAt((val & 0xf0) >> 4));\n-\t      result.append(hex.charAt(val & 0x0f));\n-\t    }\n-\t}\n-      start = i;\n-    }\n+\t// Safe character can just be added\n+\tresult.append(s.substring(start, i));\n+\n+\t// Are we done?\n+\tif (i >= length)\n+\t  return result.toString();\n+\telse if (s.charAt(i) == ' ')\n+\t  {\n+\t    result.append('+'); // Replace space char with plus symbol.\n+\t    i++;\n+\t  }\n+\telse\n+\t  {\n+\t    // Get all unsafe characters\n+\t    start = i;\n+\t    char c;\n+\t    while (i < length && (c = s.charAt(i)) != ' ' && ! isSafe(c))\n+\t      i++;\n+\n+\t    // Convert them to %XY encoded strings\n+\t    String unsafe = s.substring(start, i);\n+\t    byte[] bytes = unsafe.getBytes(encoding);\n+\t    for (int j = 0; j < bytes.length; j++)\n+\t      {\n+\t\tresult.append('%');\n+\t\tint val = bytes[j];\n+\t\tresult.append(hex.charAt((val & 0xf0) >> 4));\n+\t\tresult.append(hex.charAt(val & 0x0f));\n+\t      }\n+\t  }\n+\tstart = i;\n+      }\n   }\n \n   /**\n@@ -160,17 +161,18 @@ else if (s.charAt(i) == ' ')\n    */\n   private static boolean isSafe(char c)\n   {\n-    return  ((c >= 'a' && c <= 'z') ||\n-\t     (c >= 'A' && c <= 'Z') ||\n-\t     (c >= '0' && c <= '9') ||\n-\t     c == '-' || c == '_' || c == '.' || c == '*');\n+    return ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')\n+           || (c >= '0' && c <= '9') || c == '-' || c == '_' || c == '.'\n+           || c == '*');\n   }\n \n   /**\n    * Private constructor that does nothing. Included to avoid a default\n    * public constructor being created by the compiler.\n    */\n-  private URLEncoder() { }\n+  private URLEncoder()\n+  {\n+  }\n \n   /**\n    * Used to convert to hex.  We don't use Integer.toHexString, since\n@@ -179,4 +181,4 @@ private URLEncoder() { }\n    * leading 0.\n    */\n   private static final String hex = \"0123456789ABCDEF\";\n-} // class URLEncoder\n+}"}, {"sha": "0e2f0c2b0781bb2c1305341b34d5887e9107bab3", "filename": "libjava/java/net/URLStreamHandler.java", "status": "modified", "additions": 121, "deletions": 120, "changes": 241, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLStreamHandler.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -35,11 +35,11 @@\n obligated to do so.  If you do not wish to do so, delete this\n exception statement from your version. */\n \n-\n package java.net;\n \n-import java.io.IOException;\n import java.io.File;\n+import java.io.IOException;\n+\n \n /*\n  * Written using on-line Java Platform 1.2 API Specification, as well\n@@ -57,7 +57,7 @@\n  * A protocol handler implementation should override the openConnection()\n  * method, and optionally override the parseURL() and toExternalForm()\n  * methods if necessary. (The default implementations will parse/write all\n- * URL's in the same form as http URL's).  A protocol  specific subclass \n+ * URL's in the same form as http URL's).  A protocol  specific subclass\n  * of URLConnection will most likely need to be created as well.\n  * <p>\n  * Note that the instance methods in this class are called as if they\n@@ -71,15 +71,15 @@\n  *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n  * @author Warren Levy (warrenl@cygnus.com)\n- * \n+ *\n  * @see URL\n  */\n public abstract class URLStreamHandler\n {\n   /**\n    * Creates a URLStreamHander\n    */\n-  public URLStreamHandler ()\n+  public URLStreamHandler()\n   {\n   }\n \n@@ -96,7 +96,7 @@ public URLStreamHandler ()\n    *\n    * @exception IOException If an error occurs\n    */\n-  protected abstract URLConnection openConnection(URL u)\n+  protected abstract URLConnection openConnection(URL url)\n     throws IOException;\n \n   /**\n@@ -109,8 +109,8 @@ protected abstract URLConnection openConnection(URL u)\n    * position of the \"#\" character, which separates the \"file\" portion of\n    * the URL from the \"anchor\" portion.\n    * <p>\n-   * This method assumes URL's are formatted like http protocol URL's, so \n-   * subclasses that implement protocols with URL's the follow a different \n+   * This method assumes URL's are formatted like http protocol URL's, so\n+   * subclasses that implement protocols with URL's the follow a different\n    * syntax should override this method.  The lone exception is that if\n    * the protocol name set in the URL is \"file\", this method will accept\n    * an empty hostname (i.e., \"file:///\"), which is legal for that protocol\n@@ -126,28 +126,29 @@ protected void parseURL(URL url, String spec, int start, int end)\n     int port = url.getPort();\n     String file = url.getFile();\n     String ref = url.getRef();\n-    \n-    if (spec.regionMatches (start, \"//\", 0, 2))\n+\n+    if (spec.regionMatches(start, \"//\", 0, 2))\n       {\n \tString genuineHost;\n \tint hostEnd;\n-\tint colon, at_host;\n+\tint colon;\n+\tint at_host;\n \n \tstart += 2;\n-\tint slash = spec.indexOf ('/', start);\n-\tif (slash >= 0) \n+\tint slash = spec.indexOf('/', start);\n+\tif (slash >= 0)\n \t  hostEnd = slash;\n-        else\n+\telse\n \t  hostEnd = end;\n \n-\thost = spec.substring (start, hostEnd);\n-\t\n+\thost = spec.substring(start, hostEnd);\n+\n \t// We first need a genuine host name (with userinfo).\n \t// So we check for '@': if it's present check the port in the\n \t// section after '@' in the other case check it in the full string.\n \t// P.S.: We don't care having '@' at the beginning of the string.\n-\tif ((at_host = host.indexOf ('@')) >= 0)\n-\t  genuineHost = host.substring (at_host);\n+\tif ((at_host = host.indexOf('@')) >= 0)\n+\t  genuineHost = host.substring(at_host);\n \telse\n \t  genuineHost = host;\n \n@@ -157,70 +158,70 @@ protected void parseURL(URL url, String spec, int start, int end)\n \t// this is undocumented and likely an unintended side effect in 1.2\n \t// so we'll be simple here and stick with \"\". Note that\n \t// \"http://\" or \"http:///\" produce a \"\" host in JDK 1.2.\n-\tif ((colon = genuineHost.indexOf (':')) >= 0)\n+\tif ((colon = genuineHost.indexOf(':')) >= 0)\n \t  {\n \t    try\n \t      {\n-\t\tport = Integer.parseInt (genuineHost.substring (colon + 1));\n+\t\tport = Integer.parseInt(genuineHost.substring(colon + 1));\n \t      }\n \t    catch (NumberFormatException e)\n \t      {\n \t\t; // Ignore invalid port values; port is already set to u's\n \t\t  // port.\n \t      }\n+\n \t    // Now we must cut the port number in the original string.\n \t    if (at_host >= 0)\n-\t      host = host.substring (0, at_host + colon);\n+\t      host = host.substring(0, at_host + colon);\n \t    else\n-\t      host = host.substring (0, colon);\n+\t      host = host.substring(0, colon);\n \t  }\n \tfile = null;\n \tstart = hostEnd;\n-      } \n-    else if (host == null) \n+      }\n+    else if (host == null)\n       host = \"\";\n \n     if (file == null || file.length() == 0\n-\t|| (start < end && spec.charAt(start) == '/')) \n+        || (start < end && spec.charAt(start) == '/'))\n       {\n \t// No file context available; just spec for file.\n \t// Or this is an absolute path name; ignore any file context.\n \tfile = spec.substring(start, end);\n \tref = null;\n-      } \n+      }\n     else if (start < end)\n       {\n-        // Context is available, but only override it if there is a new file.\n-        char sepChar = '/';\n-        int lastSlash = file.lastIndexOf (sepChar);\n-        if (lastSlash < 0 && File.separatorChar != sepChar\n-            && url.getProtocol ().equals (\"file\"))\n-          {\n-            // On Windows, even '\\' is allowed in a \"file\" URL.\n-            sepChar = File.separatorChar;\n-            lastSlash = file.lastIndexOf (sepChar);\n-          }\n-        \n-        file = file.substring(0, lastSlash)\n-                + sepChar + spec.substring (start, end);\n-\n-        if (url.getProtocol ().equals (\"file\"))\n-          {\n-            // For \"file\" URLs constructed relative to a context, we\n-            // need to canonicalise the file path.\n-            try\n-              {\n+\t// Context is available, but only override it if there is a new file.\n+\tchar sepChar = '/';\n+\tint lastSlash = file.lastIndexOf(sepChar);\n+\tif (lastSlash < 0 && File.separatorChar != sepChar\n+\t    && url.getProtocol().equals(\"file\"))\n+\t  {\n+\t    // On Windows, even '\\' is allowed in a \"file\" URL.\n+\t    sepChar = File.separatorChar;\n+\t    lastSlash = file.lastIndexOf(sepChar);\n+\t  }\n+\n+\tfile =\n+\t  file.substring(0, lastSlash) + sepChar + spec.substring(start, end);\n+\n+\tif (url.getProtocol().equals(\"file\"))\n+\t  {\n+\t    // For \"file\" URLs constructed relative to a context, we\n+\t    // need to canonicalise the file path.\n+\t    try\n+\t      {\n \t\tboolean endsWithSlash = file.charAt(file.length() - 1) == '/';\n-                file = new File (file).getCanonicalPath ();\n-\t\tif (endsWithSlash\n-\t\t    && file.charAt(file.length() - 1) != '/')\n+\t\tfile = new File(file).getCanonicalPath();\n+\t\tif (endsWithSlash && file.charAt(file.length() - 1) != '/')\n \t\t  file += '/';\n-              }\n-            catch (IOException e)\n-              {\n+\t      }\n+\t    catch (IOException e)\n+\t      {\n \t\t// Do nothing.\n-              }\n-          }\n+\t      }\n+\t  }\n \n \tref = null;\n       }\n@@ -240,18 +241,16 @@ else if (start < end)\n     // XXX - Classpath used to call PlatformHelper.toCanonicalForm() on\n     // the file part. It seems like overhead, but supposedly there is some\n     // benefit in windows based systems (it also lowercased the string).\n-\n     setURL(url, url.getProtocol(), host, port, file, ref);\n   }\n-  \n+\n   /*\n    * Canonicalize a filename.\n    */\n   private static String canonicalizeFilename(String file)\n   {\n     // XXX - GNU Classpath has an implementation that might be more appropriate\n     // for Windows based systems (gnu.java.io.PlatformHelper.toCanonicalForm)\n-\n     int index;\n \n     // Replace \"/./\" with \"/\".  This probably isn't very efficient in\n@@ -270,15 +269,15 @@ private static String canonicalizeFilename(String file)\n \telse\n \t  break;\n       }\n-    return file; \n+    return file;\n   }\n \n   /**\n    * Compares two URLs, excluding the fragment component\n    *\n    * @param url1 The first url\n    * @param url2 The second url to compare with the first\n-   * \n+   *\n    * @return True if both URLs point to the same file, false otherwise.\n    *\n    * @specnote Now protected\n@@ -287,19 +286,21 @@ protected boolean sameFile(URL url1, URL url2)\n   {\n     if (url1 == url2)\n       return true;\n+\n     // This comparison is very conservative.  It assumes that any\n     // field can be null.\n     if (url1 == null || url2 == null)\n       return false;\n-    int p1 = url1.getPort ();\n+    int p1 = url1.getPort();\n     if (p1 == -1)\n-      p1 = url1.ph.getDefaultPort ();\n-    int p2 = url2.getPort ();\n+      p1 = url1.ph.getDefaultPort();\n+    int p2 = url2.getPort();\n     if (p2 == -1)\n-      p2 = url2.ph.getDefaultPort ();\n+      p2 = url2.ph.getDefaultPort();\n     if (p1 != p2)\n       return false;\n-    String s1, s2;\n+    String s1;\n+    String s2;\n     s1 = url1.getProtocol();\n     s2 = url2.getProtocol();\n     if (s1 != s2 && (s1 == null || ! s1.equals(s2)))\n@@ -333,7 +334,7 @@ protected boolean sameFile(URL url1, URL url2)\n    * #setURL(URL,String,String,int,String,String,String,String);\n    */\n   protected void setURL(URL u, String protocol, String host, int port,\n-\t\t\tString file, String ref)\n+                        String file, String ref)\n   {\n     u.set(protocol, host, port, file, ref);\n   }\n@@ -355,8 +356,8 @@ protected void setURL(URL u, String protocol, String host, int port,\n    * different from this one\n    */\n   protected void setURL(URL u, String protocol, String host, int port,\n-\t\t\tString authority, String userInfo, String path,\n-\t\t\tString query, String ref)\n+                        String authority, String userInfo, String path,\n+                        String query, String ref)\n   {\n     u.set(protocol, host, port, authority, userInfo, path, query, ref);\n   }\n@@ -372,32 +373,29 @@ protected void setURL(URL u, String protocol, String host, int port,\n    *\n    * @return True if both given URLs are equal, false otherwise.\n    */\n-  protected boolean equals (URL url1, URL url2)\n+  protected boolean equals(URL url1, URL url2)\n   {\n     // This comparison is very conservative.  It assumes that any\n     // field can be null.\n-    return (url1.getPort () == url2.getPort ()\n-\t    && ((url1.getProtocol () == null && url2.getProtocol () == null)\n-\t\t|| (url1.getProtocol () != null\n-\t\t\t&& url1.getProtocol ().equals (url2.getProtocol ())))\n-\t    && ((url1.getUserInfo () == null && url2.getUserInfo () == null)\n-                || (url1.getUserInfo () != null\n-\t\t\t&& url1.getUserInfo ().equals(url2.getUserInfo ())))\n-\t    && ((url1.getAuthority () == null && url2.getAuthority () == null)\n-                || (url1.getAuthority () != null\n-\t\t\t&& url1.getAuthority ().equals(url2.getAuthority ())))\n-\t    && ((url1.getHost () == null && url2.getHost () == null)\n-\t\t|| (url1.getHost () != null\n-\t\t\t&& url1.getHost ().equals(url2.getHost ())))\n-\t    && ((url1.getPath () == null && url2.getPath () == null)\n-\t\t|| (url1.getPath () != null\n-\t\t\t&& url1.getPath ().equals (url2.getPath ())))\n-\t    && ((url1.getQuery () == null && url2.getQuery () == null)\n-                || (url1.getQuery () != null\n-\t\t\t&& url1.getQuery ().equals(url2.getQuery ())))\n-\t    && ((url1.getRef () == null && url2.getRef () == null)\n-\t\t|| (url1.getRef () != null\n-\t\t\t&& url1.getRef ().equals(url2.getRef ()))));\n+    return (url1.getPort() == url2.getPort()\n+           && ((url1.getProtocol() == null && url2.getProtocol() == null)\n+           || (url1.getProtocol() != null\n+           && url1.getProtocol().equals(url2.getProtocol())))\n+           && ((url1.getUserInfo() == null && url2.getUserInfo() == null)\n+           || (url1.getUserInfo() != null\n+           && url1.getUserInfo().equals(url2.getUserInfo())))\n+           && ((url1.getAuthority() == null && url2.getAuthority() == null)\n+           || (url1.getAuthority() != null\n+           && url1.getAuthority().equals(url2.getAuthority())))\n+           && ((url1.getHost() == null && url2.getHost() == null)\n+           || (url1.getHost() != null && url1.getHost().equals(url2.getHost())))\n+           && ((url1.getPath() == null && url2.getPath() == null)\n+           || (url1.getPath() != null && url1.getPath().equals(url2.getPath())))\n+           && ((url1.getQuery() == null && url2.getQuery() == null)\n+           || (url1.getQuery() != null\n+           && url1.getQuery().equals(url2.getQuery())))\n+           && ((url1.getRef() == null && url2.getRef() == null)\n+           || (url1.getRef() != null && url1.getRef().equals(url2.getRef()))));\n   }\n \n   /**\n@@ -410,19 +408,19 @@ protected boolean equals (URL url1, URL url2)\n    *\n    * @exception UnknownHostException If an unknown host is found\n    */\n-  protected boolean hostsEqual (URL url1, URL url2)\n+  protected boolean hostsEqual(URL url1, URL url2)\n   {\n-    InetAddress addr1 = getHostAddress (url1);\n-    InetAddress addr2 = getHostAddress (url2);\n+    InetAddress addr1 = getHostAddress(url1);\n+    InetAddress addr2 = getHostAddress(url2);\n \n     if (addr1 != null && addr2 != null)\n-      return addr1.equals (addr2);\n+      return addr1.equals(addr2);\n \n     String host1 = url1.getHost();\n     String host2 = url2.getHost();\n-    \n+\n     if (host1 != null && host2 != null)\n-      return host1.equalsIgnoreCase (host2);\n+      return host1.equalsIgnoreCase(host2);\n \n     return host1 == null && host2 == null;\n   }\n@@ -435,16 +433,16 @@ protected boolean hostsEqual (URL url1, URL url2)\n    *\n    * @return The address of the hostname in url.\n    */\n-  protected InetAddress getHostAddress (URL url)\n+  protected InetAddress getHostAddress(URL url)\n   {\n-    String hostname = url.getHost ();\n+    String hostname = url.getHost();\n \n     if (hostname.equals(\"\"))\n       return null;\n-    \n+\n     try\n       {\n-        return InetAddress.getByName (hostname);\n+\treturn InetAddress.getByName(hostname);\n       }\n     catch (UnknownHostException e)\n       {\n@@ -458,7 +456,7 @@ protected InetAddress getHostAddress (URL url)\n    *\n    * @return The default port number.\n    */\n-  protected int getDefaultPort ()\n+  protected int getDefaultPort()\n   {\n     return -1;\n   }\n@@ -468,15 +466,14 @@ protected int getDefaultPort ()\n    * other protocols that have different requirements for hashCode calculation.\n    *\n    * @param url The URL to calc the hashcode for.\n-   * \n+   *\n    * @return The hashcode for the given URL.\n    */\n-  protected int hashCode (URL url)\n+  protected int hashCode(URL url)\n   {\n-    return url.getProtocol ().hashCode () +\n-           ((url.getHost () == null) ? 0 : url.getHost ().hashCode ()) +\n-\t   url.getFile ().hashCode() +\n-\t   url.getPort ();\n+    return url.getProtocol().hashCode()\n+           + ((url.getHost() == null) ? 0 : url.getHost().hashCode())\n+           + url.getFile().hashCode() + url.getPort();\n   }\n \n   /**\n@@ -488,23 +485,27 @@ protected int hashCode (URL url)\n    *\n    * @return A string representation of the url\n    */\n-  protected String toExternalForm(URL u)\n+  protected String toExternalForm(URL url)\n   {\n-    String protocol, host, file, ref, user;\n+    String protocol;\n+    String host;\n+    String file;\n+    String ref;\n+    String user;\n     int port;\n \n-    protocol = u.getProtocol();\n+    protocol = url.getProtocol();\n \n     // JDK 1.2 online doc infers that host could be null because it\n     // explicitly states that file cannot be null, but is silent on host.\n-    host = u.getHost();\n+    host = url.getHost();\n     if (host == null)\n       host = \"\";\n \n-    port = u.getPort();\n-    file = u.getFile();\n-    ref = u.getRef();\n-    user = u.getUserInfo();\n+    port = url.getPort();\n+    file = url.getFile();\n+    ref = url.getRef();\n+    user = url.getUserInfo();\n \n     // Guess a reasonable size for the string buffer so we have to resize\n     // at most once.\n@@ -520,13 +521,13 @@ protected String toExternalForm(URL u)\n     if (host.length() != 0)\n       {\n \tsb.append(\"//\");\n-\tif (user != null && !\"\".equals(user))\n+\tif (user != null && ! \"\".equals(user))\n \t  sb.append(user).append('@');\n \tsb.append(host);\n \n-        // Append port if port was in URL spec.\n-        if (port >= 0)\n-          sb.append(':').append(port);\n+\t// Append port if port was in URL spec.\n+\tif (port >= 0)\n+\t  sb.append(':').append(port);\n       }\n \n     sb.append(file);"}, {"sha": "f43828cc5e943b850c1d6871c2354fd981ccdf9f", "filename": "libjava/java/net/URLStreamHandlerFactory.java", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLStreamHandlerFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FURLStreamHandlerFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLStreamHandlerFactory.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -7,7 +7,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -37,15 +37,15 @@\n \n package java.net;\n \n+\n /**\n  * Written using on-line Java Platform 1.2 API Specification, as well\n  * as \"The Java Class Libraries\", 2nd edition (Addison-Wesley, 1998).\n  * Status:  Believed complete and correct.\n  */\n-\n /**\n  * This interface contains one method which maps the protocol portion of\n- * a URL (eg, \"http\" in \"http://www.urbanophile.com/arenn/\") to a \n+ * a URL (eg, \"http\" in \"http://www.urbanophile.com/arenn/\") to a\n  * <code>URLStreamHandler</code> object.\n  *\n  * @author Aaron M. Renn (arenn@urbanophile.com)\n@@ -54,14 +54,12 @@\n public interface URLStreamHandlerFactory\n {\n   /**\n-    * This method maps the protocol portion of a URL to a \n+    * This method maps the protocol portion of a URL to a\n     * <code>URLStreamHandler</code> object.\n     *\n     * @param protocol The protocol name to map (\"http\", \"ftp\", etc).\n     *\n     * @return The <code>URLStreamHandler</code> for the specified protocol\n     */\n-  URLStreamHandler createURLStreamHandler (String protocol);\n-\n+  URLStreamHandler createURLStreamHandler(String protocol);\n } // interface URLStreamHandlerFactory\n-"}, {"sha": "fefdadcd50fd5d02239e793909a2f45807ed7b49", "filename": "libjava/java/net/UnknownHostException.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FUnknownHostException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FUnknownHostException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FUnknownHostException.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -39,6 +39,7 @@\n \n import java.io.IOException;\n \n+\n /**\n  * This exception indicates that an attempt was made to reference a hostname\n  * or IP address that is not valid.  This could possibly indicate that a"}, {"sha": "8cf1909f774b5cd62e0ddfb97eeeb0528d5053b1", "filename": "libjava/java/net/UnknownServiceException.java", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FUnknownServiceException.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6d49f66ec0e0a59285d304720cc3bfa18f28141/libjava%2Fjava%2Fnet%2FUnknownServiceException.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FUnknownServiceException.java?ref=f6d49f66ec0e0a59285d304720cc3bfa18f28141", "patch": "@@ -39,6 +39,7 @@\n \n import java.io.IOException;\n \n+\n /**\n  * Contrary to what you might think, this does not indicate that the\n  * TCP/IP service name specified was invalid.  Instead it indicates that"}]}