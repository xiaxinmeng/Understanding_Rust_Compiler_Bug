{"sha": "8d8369f85bd2552ed29dbc083c9b5f9e9566008f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ4MzY5Zjg1YmQyNTUyZWQyOWRiYzA4M2M5YjVmOWU5NTY2MDA4Zg==", "commit": {"author": {"name": "Andreas Tobler", "email": "a.tobler@schweiz.ch", "date": "2003-09-18T19:35:46Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2003-09-18T19:35:46Z"}, "message": "darwin.S: Cleanup whitespaces, comment formatting.\n\n2003-09-18  Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* src/powerpc/darwin.S: Cleanup whitespaces, comment formatting.\n\t* src/powerpc/darwin_closure.S: Likewise.\n\t* src/powerpc/ffi_darwin.c: Likewise.\n\nFrom-SVN: r71533", "tree": {"sha": "5e99e2ab686ecfd7d281ea9410fce3a4914d28ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e99e2ab686ecfd7d281ea9410fce3a4914d28ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d8369f85bd2552ed29dbc083c9b5f9e9566008f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d8369f85bd2552ed29dbc083c9b5f9e9566008f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d8369f85bd2552ed29dbc083c9b5f9e9566008f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d8369f85bd2552ed29dbc083c9b5f9e9566008f/comments", "author": null, "committer": null, "parents": [{"sha": "a6a0f876237d5c12b446cb6754b908ebb508cd1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a0f876237d5c12b446cb6754b908ebb508cd1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a0f876237d5c12b446cb6754b908ebb508cd1c"}], "stats": {"total": 449, "additions": 225, "deletions": 224}, "files": [{"sha": "9a002168004bbb11fd3302f4d890a456e1ff437e", "filename": "libffi/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8369f85bd2552ed29dbc083c9b5f9e9566008f/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8369f85bd2552ed29dbc083c9b5f9e9566008f/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=8d8369f85bd2552ed29dbc083c9b5f9e9566008f", "patch": "@@ -1,3 +1,9 @@\n+2003-09-18  Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* src/powerpc/darwin.S: Cleanup whitespaces, comment formatting.\n+\t* src/powerpc/darwin_closure.S: Likewise.\n+\t* src/powerpc/ffi_darwin.c: Likewise.\n+\n 2003-09-18  Andreas Tobler  <a.tobler@schweiz.ch>\n \t    David Edelsohn  <edelsohn@gnu.org>\n "}, {"sha": "712252666fd29da191227f47222f920bd95a13f2", "filename": "libffi/src/powerpc/darwin.S", "status": "modified", "additions": 41, "deletions": 42, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8369f85bd2552ed29dbc083c9b5f9e9566008f/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8369f85bd2552ed29dbc083c9b5f9e9566008f/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin.S?ref=8d8369f85bd2552ed29dbc083c9b5f9e9566008f", "patch": "@@ -1,6 +1,6 @@\n /* -----------------------------------------------------------------------\n    darwin.S - Copyright (c) 2000 John Hornkvist\n-   \n+\n    PowerPC Assembly glue.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -23,7 +23,7 @@\n    OTHER DEALINGS IN THE SOFTWARE.\n    ----------------------------------------------------------------------- */\n \n-#define LIBFFI_ASM\t\n+#define LIBFFI_ASM\n #include <ffi.h>\n #define JUMPTARGET(name) name\n #define L(x) x\n@@ -37,59 +37,59 @@\n .text\n \t.align 2\n _ffi_call_DARWIN:\n-LFB0:\t\n+LFB0:\n \tmr      r12,r8\t\t/* We only need r12 until the call,\n-\t\t\t\tso it doesn't have to be saved...  */\n-LFB1:\t\n+\t\t\t\t   so it doesn't have to be saved...  */\n+LFB1:\n \t/* Save the old stack pointer as AP.  */\n \tmr\tr8,r1\n-LCFI0:\t\n+LCFI0:\n \t/* Allocate the stack space we need.  */\n-\tstwux\tr1,r1,r4\t\n-\t\n+\tstwux\tr1,r1,r4\n+\n \t/* Save registers we use.  */\n \tmflr\tr9\n \n-\tstw\tr28,-16(r8)\t\n+\tstw\tr28,-16(r8)\n \tstw\tr29,-12(r8)\n \tstw\tr30, -8(r8)\n \tstw\tr31, -4(r8)\n \n-\tstw\tr9,  8(r8)\t\n+\tstw\tr9,  8(r8)\n \tstw\tr2, 20(r1)\n-LCFI1:\t\n+LCFI1:\n \n \t/* Save arguments over call...  */\n \tmr\tr31,r5\t/* flags,  */\n \tmr\tr30,r6\t/* rvalue,  */\n \tmr\tr29,r7\t/* function address,  */\n \tmr\tr28,r8\t/* our AP.  */\n-LCFI2:\t\t\n+LCFI2:\n \t/* Call ffi_prep_args.  */\n \tmr\tr4,r1\n \tli\tr9,0\n-\t\n+\n \tmtctr\tr12 // r12 holds address of _ffi_prep_args\n-\tbctrl \n+\tbctrl\n \tlwz     r2,20(r1)\n \n-\t/* Now do the call.  */\n-\t/* Set up cr1 with bits 4-7 of the flags.  */\n+\t/* Now do the call.\n+\t   Set up cr1 with bits 4-7 of the flags.  */\n \tmtcrf\t0x40,r31\n \t/* Get the address to call into CTR.  */\n \tmtctr\tr29\n-\t/* Load all those argument registers.  */\n-        // We have set up a nice stack frame, just load it into registers.\n-        lwz     r3, 20+(1*4)(r1)\n-        lwz     r4, 20+(2*4)(r1)\n-        lwz     r5, 20+(3*4)(r1)\n-        lwz     r6, 20+(4*4)(r1)\n-        nop\n+\t/* Load all those argument registers.\n+\t   We have set up a nice stack frame, just load it into registers.  */\n+\tlwz     r3, 20+(1*4)(r1)\n+\tlwz     r4, 20+(2*4)(r1)\n+\tlwz     r5, 20+(3*4)(r1)\n+\tlwz     r6, 20+(4*4)(r1)\n+\tnop\n \tlwz     r7, 20+(5*4)(r1)\n-        lwz     r8, 20+(6*4)(r1)\n-        lwz     r9, 20+(7*4)(r1)\n-        lwz     r10,20+(8*4)(r1)\n-\t\t\n+\tlwz     r8, 20+(6*4)(r1)\n+\tlwz     r9, 20+(7*4)(r1)\n+\tlwz     r10,20+(8*4)(r1)\n+\n L1:\n \t/* Load all the FP registers.  */\n \tbf\t6,L2 // 2f + 0x18\n@@ -104,20 +104,20 @@ L1:\n \tlfd\tf8,-16-(6*8)(r28)\n \tnop\n \tlfd     f9,-16-(5*8)(r28)\n-        lfd     f10,-16-(4*8)(r28)\n+\tlfd     f10,-16-(4*8)(r28)\n \tlfd     f11,-16-(3*8)(r28)\n \tlfd     f12,-16-(2*8)(r28)\n \tnop\n \tlfd     f13,-16-(1*8)(r28)\n \n-L2:\t\n-\tmr\tr12,r29 // Put the target address in r12 as specified.\n+L2:\n+\tmr\tr12,r29 /* Put the target address in r12 as specified.  */\n \tmtctr  r12\n \tnop\n \tnop\n \t/* Make the call.  */\n \tbctrl\n-        \n+\n \t/* Now, deal with the return value.  */\n \tmtcrf\t0x01,r31\n \n@@ -147,7 +147,7 @@ L(fp_return_value):\n L(float_return_value):\n \tstfs\tf1,0(r30)\n \tb\tL(done_return_value)\n-LFE1:\t\n+LFE1:\n /* END(_ffi_call_DARWIN)  */\n \n /* Provide a null definition of _ffi_call_AIX.  */\n@@ -193,26 +193,25 @@ LASFDE1:\n \t.set\tL$set$4,LCFI0-LFB1\n \t.long\tL$set$4\n \t.byte\t0xd\t; DW_CFA_def_cfa_register\n-\t.byte\t0x08\t; uleb128 0x08 \n+\t.byte\t0x08\t; uleb128 0x08\n \t.byte\t0x4\t; DW_CFA_advance_loc4\n \t.set\tL$set$5,LCFI1-LCFI0\n \t.long\tL$set$5\n \t.byte   0x11    ; DW_CFA_offset_extended_sf\n \t.byte\t0x41\t; uleb128 0x41\n \t.byte   0x7e    ; sleb128 -2\n-\t.byte\t0x9f\t; DW_CFA_offset, column 0x1f \n-\t.byte\t0x1\t; uleb128 0x1 \n+\t.byte\t0x9f\t; DW_CFA_offset, column 0x1f\n+\t.byte\t0x1\t; uleb128 0x1\n \t.byte\t0x9e\t; DW_CFA_offset, column 0x1e\n \t.byte\t0x2\t; uleb128 0x2\n-\t.byte\t0x9d\t; DW_CFA_offset, column 0x1d \n-\t.byte\t0x3\t; uleb128 0x3 \n-\t.byte\t0x9c\t; DW_CFA_offset, column 0x1c \n+\t.byte\t0x9d\t; DW_CFA_offset, column 0x1d\n+\t.byte\t0x3\t; uleb128 0x3\n+\t.byte\t0x9c\t; DW_CFA_offset, column 0x1c\n \t.byte\t0x4\t; uleb128 0x4\n-\t.byte\t0x4\t; DW_CFA_advance_loc4 \n+\t.byte\t0x4\t; DW_CFA_advance_loc4\n \t.set\tL$set$6,LCFI2-LCFI1\n \t.long\tL$set$6\n-\t.byte\t0xd\t; DW_CFA_def_cfa_register \n-\t.byte\t0x1c\t; uleb128 0x1c \n+\t.byte\t0xd\t; DW_CFA_def_cfa_register\n+\t.byte\t0x1c\t; uleb128 0x1c\n \t.align 2\n LEFDE1:\n-\t"}, {"sha": "d8612a85445f2448f0ca99b6d4b15b1ae131b8b3", "filename": "libffi/src/powerpc/darwin_closure.S", "status": "modified", "additions": 65, "deletions": 65, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8369f85bd2552ed29dbc083c9b5f9e9566008f/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8369f85bd2552ed29dbc083c9b5f9e9566008f/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fdarwin_closure.S?ref=8d8369f85bd2552ed29dbc083c9b5f9e9566008f", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------------\n-   darwin_closure.S - Copyright (c) 2002 2003 Free Software Foundation, \n+   darwin_closure.S - Copyright (c) 2002 2003 Free Software Foundation,\n    Inc. based on ppc_closure.S\n- \n+\n    PowerPC Assembly glue.\n \n    Permission is hereby granted, free of charge, to any person obtaining\n@@ -29,40 +29,40 @@\n \n \t.file\t\"darwin_closure.S\"\n .text\n-\t.align 2\t\n+\t.align 2\n .globl _ffi_closure_ASM\n \n .text\n \t.align 2\n _ffi_closure_ASM:\n-LFB1:\t\t\n+LFB1:\n \tmflr\tr0\t\t\t/* extract return address  */\n \tstw\tr0, 8(r1)\t\t/* save the return address  */\n-LCFI0:\t\n+LCFI0:\n \t/* 24 Bytes (Linkage Area)\n \t   32 Bytes (outgoing parameter area, always reserved)\n-\t   104 Bytes (13*8 from FPR)\t\n+\t   104 Bytes (13*8 from FPR)\n \t   8 Bytes (result)\n \t   168 Bytes  */\n \n \tstwu\tr1,-176(r1)\t/* skip over caller save area\n-\t\t\t\tkeep stack aligned to 16  */\n-LCFI1:\t\t\n-\t/* we want to build up an area for the parameters passed\n-\tin registers (both floating point and integer)  */\n+\t\t\t\tkeep stack aligned to 16.  */\n+LCFI1:\n+\t/* We want to build up an area for the parameters passed\n+\t   in registers. (both floating point and integer)  */\n \n-\t/* we store gpr 3 to gpr 10 (aligned to 4)\n-\tin the parents outgoing area  */\n+\t/* We store gpr 3 to gpr 10 (aligned to 4)\n+\t   in the parents outgoing area.  */\n \tstw   r3, 200(r1)\n \tstw   r4, 204(r1)\n-\tstw   r5, 208(r1) \n+\tstw   r5, 208(r1)\n \tstw   r6, 212(r1)\n \tstw   r7, 216(r1)\n-\tstw   r8, 220(r1) \n+\tstw   r8, 220(r1)\n \tstw   r9, 224(r1)\n \tstw   r10, 228(r1)\n \n-\t/* we save fpr 1 to fpr 13 (aligned to 8) */\n+\t/* We save fpr 1 to fpr 13. (aligned to 8)  */\n \tstfd  f1, 56(r1)\n \tstfd  f2, 64(r1)\n \tstfd  f3, 72(r1)\n@@ -71,45 +71,45 @@ LCFI1:\n \tstfd  f6, 96(r1)\n \tstfd  f7, 104(r1)\n \tstfd  f8, 112(r1)\n-\tstfd  f9, 120(r1) \n-\tstfd  f10, 128(r1) \n-\tstfd  f11, 136(r1) \n-\tstfd  f12, 144(r1) \n-\tstfd  f13, 152(r1) \n-\n-\t/* set up registers for the routine that actually does the work */\n-\t/* get the context pointer from the trampoline */\n+\tstfd  f9, 120(r1)\n+\tstfd  f10, 128(r1)\n+\tstfd  f11, 136(r1)\n+\tstfd  f12, 144(r1)\n+\tstfd  f13, 152(r1)\n+\n+\t/* Set up registers for the routine that actually does the work\n+\t   get the context pointer from the trampoline.  */\n \tmr r3,r11\n \n-\t/* now load up the pointer to the result storage */\n+\t/* Now load up the pointer to the result storage.  */\n \taddi r4,r1,160\n \n-\t/* now load up the pointer to the saved gpr registers  */\n+\t/* Now load up the pointer to the saved gpr registers.  */\n \taddi r5,r1,200\n \n-\t/* now load up the pointer to the saved fpr registers */\n+\t/* Now load up the pointer to the saved fpr registers.  */\n \taddi r6,r1,56\n \n-\t/* make the call */\n+\t/* Make the call.  */\n \tbl\tLffi_closure_helper_DARWIN$stub\n \n-\t/* now r3 contains the return type */\n-\t/* so use it to look up in a table */\n-\t/* so we know how to deal with each type */\n-\n-\t/* look up the proper starting point in table  */\n-\t/* by using return type as offset */\n-\taddi  r5,r1,160\t\t  /* get pointer to results area */\n-\tbl    Lget_ret_type0_addr /* get pointer to Lret_type0 into LR  */\n-\tmflr  r4\t\t  /* move to r4  */\n-\tslwi  r3,r3,4\t\t  /* now multiply return type by 16  */\n-\tadd   r3,r3,r4\t\t  /* add contents of table to table address */\n+\t/* Now r3 contains the return type\n+\t   so use it to look up in a table\n+\t   so we know how to deal with each type.  */\n+\n+\t/* Look up the proper starting point in table\n+\t   by using return type as offset.  */\n+\taddi  r5,r1,160\t\t  /* Get pointer to results area.  */\n+\tbl    Lget_ret_type0_addr /* Get pointer to Lret_type0 into LR.  */\n+\tmflr  r4\t\t  /* Move to r4.  */\n+\tslwi  r3,r3,4\t\t  /* Now multiply return type by 16.  */\n+\tadd   r3,r3,r4\t\t  /* Add contents of table to table address.  */\n \tmtctr r3\n-\tbctr\t\t\t  /* jump to it  */\n+\tbctr\t\t\t  /* Jump to it.  */\n LFE1:\n-/* Each of the ret_typeX code fragments has to be exactly 16 bytes long  */\n-/* (4 instructions). For cache effectiveness we align to a 16 byte boundary  */\n-/* first.  */\n+/* Each of the ret_typeX code fragments has to be exactly 16 bytes long\n+   (4 instructions). For cache effectiveness we align to a 16 byte boundary\n+   first.  */\n \n \t.align 4\n \n@@ -142,21 +142,21 @@ Lret_type2:\n \n /* case FFI_TYPE_DOUBLE  */\n Lret_type3:\n-        lfd\tf1,0(r5)\n+\tlfd\tf1,0(r5)\n \tb\tLfinish\n \tnop\n \tnop\n \n /* case FFI_TYPE_LONGDOUBLE  */\n Lret_type4:\n-        lfd\tf1,0(r5)\n+\tlfd\tf1,0(r5)\n \tb\tLfinish\n \tnop\n \tnop\n \n /* case FFI_TYPE_UINT8  */\n Lret_type5:\n-        lbz\tr3,3(r5)\n+\tlbz\tr3,3(r5)\n \tb\tLfinish\n \tnop\n \tnop\n@@ -210,7 +210,7 @@ Lret_type12:\n \tb\tLfinish\n \tnop\n \n-/* case FFI_TYPE_STRUCT */\n+/* case FFI_TYPE_STRUCT  */\n Lret_type13:\n \tb\tLfinish\n \tnop\n@@ -224,14 +224,14 @@ Lret_type14:\n \tnop\n \tnop\n \n-/* case done  */\t\n-Lfinish:\t\n-\taddi\tr1,r1,176\t\t/* restore stack pointer  */\n-\tlwz\tr0,8(r1)\t\t/* get return address  */\n-\tmtlr\tr0\t\t\t/* reset link register  */\n+/* case done  */\n+Lfinish:\n+\taddi\tr1,r1,176\t\t/* Restore stack pointer.  */\n+\tlwz\tr0,8(r1)\t\t/* Get return address.  */\n+\tmtlr\tr0\t\t\t/* Reset link register.  */\n \tblr\n-\t\n-/* END(ffi_closure_ASM)  */\t\n+\n+/* END(ffi_closure_ASM)  */\n \n .data\n .section __TEXT,__eh_frame\n@@ -267,7 +267,7 @@ LASFDE1:\n \t.set\tL$set$3,LCFI1-LCFI0\n \t.long\tL$set$3\n \t.byte\t0xe\t; DW_CFA_def_cfa_offset\n- \t.byte\t176,1\t; uleb128 176\n+\t.byte\t176,1\t; uleb128 176\n \t.byte\t0x4\t; DW_CFA_advance_loc4\n \t.set\tL$set$4,LCFI0-LFB1\n \t.long\tL$set$4\n@@ -281,19 +281,19 @@ LEFDE1:\n LDFCM0:\n .section __TEXT,__picsymbolstub1,symbol_stubs,pure_instructions,32\n \t.align\t2\n-Lffi_closure_helper_DARWIN$stub: \n-\t.indirect_symbol _ffi_closure_helper_DARWIN       \n-\tmflr\tr0         \n-\tbcl\t20,31,LO$ffi_closure_helper_DARWIN \n+Lffi_closure_helper_DARWIN$stub:\n+\t.indirect_symbol _ffi_closure_helper_DARWIN\n+\tmflr\tr0\n+\tbcl\t20,31,LO$ffi_closure_helper_DARWIN\n LO$ffi_closure_helper_DARWIN:\n-\tmflr\tr11                 \n+\tmflr\tr11\n \taddis\tr11,r11,ha16(L_ffi_closure_helper_DARWIN$lazy_ptr - LO$ffi_closure_helper_DARWIN)\n-\tmtlr\tr0 \n-\tlwzu\tr12,lo16(L_ffi_closure_helper_DARWIN$lazy_ptr - LO$ffi_closure_helper_DARWIN)(r11)         \n-\tmtctr\tr12                \n-\tbctr    \n+\tmtlr\tr0\n+\tlwzu\tr12,lo16(L_ffi_closure_helper_DARWIN$lazy_ptr - LO$ffi_closure_helper_DARWIN)(r11)\n+\tmtctr\tr12\n+\tbctr\n .data\n-.lazy_symbol_pointer \n-L_ffi_closure_helper_DARWIN$lazy_ptr:         \n+.lazy_symbol_pointer\n+L_ffi_closure_helper_DARWIN$lazy_ptr:\n \t.indirect_symbol _ffi_closure_helper_DARWIN\n \t.long   dyld_stub_binding_helper"}, {"sha": "73653cd43c60a023e1607ddf4f4eab103d6d564b", "filename": "libffi/src/powerpc/ffi_darwin.c", "status": "modified", "additions": 113, "deletions": 117, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d8369f85bd2552ed29dbc083c9b5f9e9566008f/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d8369f85bd2552ed29dbc083c9b5f9e9566008f/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fsrc%2Fpowerpc%2Fffi_darwin.c?ref=8d8369f85bd2552ed29dbc083c9b5f9e9566008f", "patch": "@@ -1,7 +1,7 @@\n /* -----------------------------------------------------------------------\n    ffi.c - Copyright (c) 1998 Geoffrey Keating\n-   \n-   PowerPC Foreign Function Interface \n+\n+   PowerPC Foreign Function Interface\n \n    Darwin ABI support (c) 2001 John Hornkvist\n    AIX ABI support (c) 2002 Free Software Foundation, Inc.\n@@ -34,12 +34,12 @@ extern void ffi_closure_ASM(void);\n \n enum {\n   /* The assembly depends on these exact flags.  */\n-  FLAG_RETURNS_NOTHING  = 1 << (31-30), /* These go in cr7 */\n+  FLAG_RETURNS_NOTHING  = 1 << (31-30), /* These go in cr7  */\n   FLAG_RETURNS_FP       = 1 << (31-29),\n   FLAG_RETURNS_64BITS   = 1 << (31-28),\n \n   FLAG_ARG_NEEDS_COPY   = 1 << (31- 7),\n-  FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI */\n+  FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI  */\n   FLAG_4_GPR_ARGUMENTS  = 1 << (31- 5),\n   FLAG_RETVAL_REFERENCE = 1 << (31- 4)\n };\n@@ -58,7 +58,7 @@ enum { ASM_NEEDS_REGISTERS = 4 };\n \n    |   Return address from ffi_call_DARWIN      |\thigher addresses\n    |--------------------------------------------|\n-   |   Previous backchain pointer\t4\t| \tstack pointer here\n+   |   Previous backchain pointer\t4\t|\tstack pointer here\n    |--------------------------------------------|<+ <<<\ton entry to\n    |   Saved r28-r31\t\t\t4*4\t| |\tffi_call_DARWIN\n    |--------------------------------------------| |\n@@ -69,7 +69,7 @@ enum { ASM_NEEDS_REGISTERS = 4 };\n    |   Reserved                       2*4       | |\tgrows\t|\n    |--------------------------------------------| |\tdown\tV\n    |   Space for callee's LR\t\t4\t| |\n-   |--------------------------------------------| |\tlower addresses\t\n+   |--------------------------------------------| |\tlower addresses\n    |   Saved CR                         4       | |\n    |--------------------------------------------| |     stack pointer here\n    |   Current backchain pointer\t4\t|-/\tduring\n@@ -93,7 +93,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \n \n   /* 'next_arg' grows up as we put parameters in it.  */\n-  unsigned *next_arg = stack + 6; // 6 reserved posistions. \n+  unsigned *next_arg = stack + 6; /* 6 reserved posistions.  */\n \n   int i = ecif->cif->nargs;\n   double double_tmp;\n@@ -108,9 +108,10 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n   FFI_ASSERT(((unsigned)(char *)stacktop & 0xF) == 0);\n   FFI_ASSERT((bytes & 0xF) == 0);\n \n-  /* Deal with return values that are actually pass-by-reference.  */\n-  // Rule:\n-  // Return values are referenced by r3, so r4 is the first parameter.\n+  /* Deal with return values that are actually pass-by-reference.\n+     Rule:\n+     Return values are referenced by r3, so r4 is the first parameter.  */\n+\n   if (flags & FLAG_RETVAL_REFERENCE)\n     *next_arg++ = (unsigned)(char *)ecif->rvalue;\n \n@@ -127,28 +128,28 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \tcase FFI_TYPE_FLOAT:\n \t  double_tmp = *(float *)*p_argv;\n \t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n-            *(double *)next_arg = double_tmp;\n+\t    *(double *)next_arg = double_tmp;\n \t  else\n-            *fpr_base++ = double_tmp;\n-          next_arg++;\n+\t    *fpr_base++ = double_tmp;\n+\t  next_arg++;\n \t  fparg_count++;\n \t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \tcase FFI_TYPE_DOUBLE:\n \t  double_tmp = *(double *)*p_argv;\n \t  if (fparg_count >= NUM_FPR_ARG_REGISTERS)\n-            *(double *)next_arg = double_tmp;\n+\t    *(double *)next_arg = double_tmp;\n \t  else\n-            *fpr_base++ = double_tmp;\n-          next_arg += 2;\n+\t    *fpr_base++ = double_tmp;\n+\t  next_arg += 2;\n \t  fparg_count++;\n \t  FFI_ASSERT(flags & FLAG_FP_ARGUMENTS);\n \t  break;\n \n \tcase FFI_TYPE_UINT64:\n \tcase FFI_TYPE_SINT64:\n-          *(long long *)next_arg = *(long long *)*p_argv;\n-          next_arg+=2;\n+\t  *(long long *)next_arg = *(long long *)*p_argv;\n+\t  next_arg+=2;\n \t  break;\n \tcase FFI_TYPE_UINT8:\n \t  gprvalue = *(unsigned char *)*p_argv;\n@@ -187,7 +188,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n \t  break;\n \n \tcase FFI_TYPE_INT:\n-   \tcase FFI_TYPE_UINT32:\n+\tcase FFI_TYPE_UINT32:\n \tcase FFI_TYPE_SINT32:\n \tcase FFI_TYPE_POINTER:\n \t  gprvalue = *(unsigned *)*p_argv;\n@@ -206,7 +207,7 @@ void ffi_prep_args(extended_cif *ecif, unsigned *const stack)\n   //FFI_ASSERT(flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);\n }\n \n-/* Perform machine dependent cif processing */\n+/* Perform machine dependent cif processing.  */\n ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n {\n   /* All this is for the DARWIN ABI.  */\n@@ -220,7 +221,7 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n   /* All the machine-independent calculation of cif->bytes will be wrong.\n      Redo the calculation for DARWIN.  */\n \n-  /* Space for the frame pointer, callee's LR, CR, etc, and for \n+  /* Space for the frame pointer, callee's LR, CR, etc, and for\n      the asm's temp regs.  */\n \n   bytes = (6 + ASM_NEEDS_REGISTERS) * sizeof(long);\n@@ -343,33 +344,33 @@ ffi_status ffi_prep_cif_machdep(ffi_cif *cif)\n \n /*@-declundef@*/\n /*@-exportheader@*/\n-extern void ffi_call_AIX(/*@out@*/ extended_cif *, \n-\t\t\t unsigned, unsigned, \n-\t\t\t /*@out@*/ unsigned *, \n+extern void ffi_call_AIX(/*@out@*/ extended_cif *,\n+\t\t\t unsigned, unsigned,\n+\t\t\t /*@out@*/ unsigned *,\n \t\t\t void (*fn)(),\n \t\t\t void (*fn2)());\n-extern void ffi_call_DARWIN(/*@out@*/ extended_cif *, \n-\t\t\t    unsigned, unsigned, \n-\t\t\t    /*@out@*/ unsigned *, \n+extern void ffi_call_DARWIN(/*@out@*/ extended_cif *,\n+\t\t\t    unsigned, unsigned,\n+\t\t\t    /*@out@*/ unsigned *,\n \t\t\t    void (*fn)(),\n \t\t\t    void (*fn2)());\n /*@=declundef@*/\n /*@=exportheader@*/\n \n-void ffi_call(/*@dependent@*/ ffi_cif *cif, \n-\t      void (*fn)(), \n-\t      /*@out@*/ void *rvalue, \n+void ffi_call(/*@dependent@*/ ffi_cif *cif,\n+\t      void (*fn)(),\n+\t      /*@out@*/ void *rvalue,\n \t      /*@dependent@*/ void **avalue)\n {\n   extended_cif ecif;\n \n   ecif.cif = cif;\n   ecif.avalue = avalue;\n \n-  /* If the return value is a struct and we don't have a return\t*/\n-  /* value address then we need to make one\t\t        */\n+  /* If the return value is a struct and we don't have a return\n+     value address then we need to make one.  */\n \n-  if ((rvalue == NULL) && \n+  if ((rvalue == NULL) &&\n       (cif->rtype->type == FFI_TYPE_STRUCT))\n     {\n       /*@-sysunrecog@*/\n@@ -379,17 +380,17 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n   else\n     ecif.rvalue = rvalue;\n \n-  switch (cif->abi) \n+  switch (cif->abi)\n     {\n     case FFI_AIX:\n       /*@-usedef@*/\n-      ffi_call_AIX(&ecif, -cif->bytes, \n+      ffi_call_AIX(&ecif, -cif->bytes,\n \t\t   cif->flags, ecif.rvalue, fn, ffi_prep_args);\n       /*@=usedef@*/\n       break;\n     case FFI_DARWIN:\n       /*@-usedef@*/\n-      ffi_call_DARWIN(&ecif, -cif->bytes, \n+      ffi_call_DARWIN(&ecif, -cif->bytes,\n \t\t      cif->flags, ecif.rvalue, fn, ffi_prep_args);\n       /*@=usedef@*/\n       break;\n@@ -402,79 +403,79 @@ void ffi_call(/*@dependent@*/ ffi_cif *cif,\n static void flush_icache(char *);\n static void flush_range(char *, int);\n \n-/* The layout of a function descriptor.  A C function pointer really    */\n-/* points to one of these.                                              */\n+/* The layout of a function descriptor.  A C function pointer really\n+   points to one of these.  */\n \n typedef struct aix_fd_struct {\n     void *code_pointer;\n     void *toc;\n } aix_fd;\n \n /* here I'd like to add the stack frame layout we use in darwin_closure.S\n- * and aix_clsoure.S\n- *\n- * SP previous -> +---------------------------------------+ <--- child frame\n-                  | back chain to caller 4                | \n-                  +---------------------------------------+ 4\n-                  | saved CR 4                            | \n-                  +---------------------------------------+ 8 \n-                  | saved LR 4                            | \n-                  +---------------------------------------+ 12\n-                  | reserved for compilers 4              | \n-                  +---------------------------------------+ 16\n-                  | reserved for binders 4                | \n-                  +---------------------------------------+ 20\n-                  | saved TOC pointer 4                   | \n-                  +---------------------------------------+ 24\n-                  | always reserved 8*4=32 (previous GPRs)| \n-                  | according to the linkage convention   |\n-                  | from AIX                              |\n-                  +---------------------------------------+ 56\n-                  | our FPR area 13*8=104                 |\n-                  | f1                                    |\n-                  | .                                     |\n-                  | f13                                   | \n-                  +---------------------------------------+ 160\n-                  | result area 8                         |\n-                  +---------------------------------------+ 168\n-                  | alignement to the next multiple of 16 |\n+   and aix_clsoure.S\n+\n+   SP previous -> +---------------------------------------+ <--- child frame\n+\t\t  | back chain to caller 4                |\n+\t\t  +---------------------------------------+ 4\n+\t\t  | saved CR 4                            |\n+\t\t  +---------------------------------------+ 8\n+\t\t  | saved LR 4                            |\n+\t\t  +---------------------------------------+ 12\n+\t\t  | reserved for compilers 4              |\n+\t\t  +---------------------------------------+ 16\n+\t\t  | reserved for binders 4                |\n+\t\t  +---------------------------------------+ 20\n+\t\t  | saved TOC pointer 4                   |\n+\t\t  +---------------------------------------+ 24\n+\t\t  | always reserved 8*4=32 (previous GPRs)|\n+\t\t  | according to the linkage convention   |\n+\t\t  | from AIX                              |\n+\t\t  +---------------------------------------+ 56\n+\t\t  | our FPR area 13*8=104                 |\n+\t\t  | f1                                    |\n+\t\t  | .                                     |\n+\t\t  | f13                                   |\n+\t\t  +---------------------------------------+ 160\n+\t\t  | result area 8                         |\n+\t\t  +---------------------------------------+ 168\n+\t\t  | alignement to the next multiple of 16 |\n SP current -->    +---------------------------------------+ 176 <- parent frame\n-                  | back chain to caller 4                | \n-                  +---------------------------------------+ 180\n-                  | saved CR 4                            | \n-                  +---------------------------------------+ 184\n-                  | saved LR 4                            | \n-                  +---------------------------------------+ 188\n-                  | reserved for compilers 4              | \n-                  +---------------------------------------+ 192\n-                  | reserved for binders 4                | \n-                  +---------------------------------------+ 196\n-                  | saved TOC pointer 4                   | \n-                  +---------------------------------------+ 200\n-                  | always reserved 8*4=32  we store our  |\n-                  | GPRs here                             |\n-                  | r3                                    |\n-                  | .                                     |\n-                  | r10                                   |\n-                  +---------------------------------------+ 232\n-                  | overflow part                         | \n-                  +---------------------------------------+ xxx\n-                  | ????                                  | \n-                  +---------------------------------------+ xxx\n+\t\t  | back chain to caller 4                |\n+\t\t  +---------------------------------------+ 180\n+\t\t  | saved CR 4                            |\n+\t\t  +---------------------------------------+ 184\n+\t\t  | saved LR 4                            |\n+\t\t  +---------------------------------------+ 188\n+\t\t  | reserved for compilers 4              |\n+\t\t  +---------------------------------------+ 192\n+\t\t  | reserved for binders 4                |\n+\t\t  +---------------------------------------+ 196\n+\t\t  | saved TOC pointer 4                   |\n+\t\t  +---------------------------------------+ 200\n+\t\t  | always reserved 8*4=32  we store our  |\n+\t\t  | GPRs here                             |\n+\t\t  | r3                                    |\n+\t\t  | .                                     |\n+\t\t  | r10                                   |\n+\t\t  +---------------------------------------+ 232\n+\t\t  | overflow part                         |\n+\t\t  +---------------------------------------+ xxx\n+\t\t  | ????                                  |\n+\t\t  +---------------------------------------+ xxx\n \n */\n ffi_status\n-ffi_prep_closure (ffi_closure* closure,    \n-                  ffi_cif* cif,\n-                  void (*fun)(ffi_cif*, void*, void**, void*),\n-                  void *user_data)\n+ffi_prep_closure (ffi_closure* closure,\n+\t\t  ffi_cif* cif,\n+\t\t  void (*fun)(ffi_cif*, void*, void**, void*),\n+\t\t  void *user_data)\n {\n   unsigned int *tramp;\n   struct ffi_aix_trampoline_struct *tramp_aix;\n   aix_fd *fd;\n \n   switch (cif->abi)\n-    {  \n+    {\n     case FFI_DARWIN:\n \n       FFI_ASSERT (cif->abi == FFI_DARWIN);\n@@ -527,12 +528,12 @@ flush_icache(char *addr)\n {\n #ifndef _AIX\n   __asm__ volatile (\n-                \"dcbf 0,%0;\"\n-                \"sync;\"\n-                \"icbi 0,%0;\"\n-                \"sync;\"\n-                \"isync;\"\n-                : : \"r\"(addr) : \"memory\");\n+\t\t\"dcbf 0,%0;\"\n+\t\t\"sync;\"\n+\t\t\"icbi 0,%0;\"\n+\t\t\"sync;\"\n+\t\t\"isync;\"\n+\t\t: : \"r\"(addr) : \"memory\");\n #endif\n }\n \n@@ -556,12 +557,11 @@ int ffi_closure_helper_DARWIN (ffi_closure*, void*,\n \t\t\t       unsigned long*, ffi_dblfl*);\n \n /* Basically the trampoline invokes ffi_closure_ASM, and on\n- * entry, r11 holds the address of the closure.\n- * After storing the registers that could possibly contain\n- * parameters to be passed into the stack frame and setting\n- * up space for a return value, ffi_closure_ASM invokes the\n- * following helper function to do most of the work\n- */\n+   entry, r11 holds the address of the closure.\n+   After storing the registers that could possibly contain\n+   parameters to be passed into the stack frame and setting\n+   up space for a return value, ffi_closure_ASM invokes the\n+   following helper function to do most of the work.  */\n \n int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t\t\t       unsigned long * pgr, ffi_dblfl * pfr)\n@@ -574,8 +574,8 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n   void **          avalue;\n   ffi_type **      arg_types;\n   long             i, avn;\n-  long             nf;   /* number of floating registers already used */\n-  long             ng;   /* number of general registers already used */\n+  long             nf;   /* number of floating registers already used.  */\n+  long             ng;   /* number of general registers already used.  */\n   ffi_cif *        cif;\n   double           temp;\n   unsigned         size_al;\n@@ -652,10 +652,8 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t  break;\n \n \tcase FFI_TYPE_FLOAT:\n-\t  /* a float value consumes a GPR\n-\t   *\n-\t   * here are 13 64bit floating point registers.\n-\t   */\n+\t  /* A float value consumes a GPR.\n+\t     There are 13 64bit floating point registers.  */\n \t  if (nf < NUM_FPR_ARG_REGISTERS)\n \t    {\n \t      temp = pfr->d;\n@@ -673,10 +671,8 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t  break;\n \n \tcase FFI_TYPE_DOUBLE:\n-\t  /* a double value consumes two GPRs\n-\t   *\n-\t   * There are 13 64bit floating point registers.\n-\t   */\n+\t  /* A double value consumes two GPRs.\n+\t     There are 13 64bit floating point registers.  */\n \t  if (nf < NUM_FPR_ARG_REGISTERS)\n \t    {\n \t      avalue[i] = pfr;\n@@ -691,9 +687,9 @@ int ffi_closure_helper_DARWIN (ffi_closure* closure, void * rvalue,\n \t  pgr += 2;\n \t  break;\n \n-        default:\n-          FFI_ASSERT(0);\n-        }\n+\tdefault:\n+\t  FFI_ASSERT(0);\n+\t}\n       i++;\n     }\n "}]}