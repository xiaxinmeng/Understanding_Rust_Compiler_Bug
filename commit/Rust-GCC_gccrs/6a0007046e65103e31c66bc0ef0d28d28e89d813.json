{"sha": "6a0007046e65103e31c66bc0ef0d28d28e89d813", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmEwMDA3MDQ2ZTY1MTAzZTMxYzY2YmMwZWYwZDI4ZDI4ZTg5ZDgxMw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-08-11T09:23:57Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2005-08-11T09:23:57Z"}, "message": "re PR c++/23219 (ICE: Segmentation fault in decl_namespace_context)\n\ncp:\n\tPR c++/23219\n\t* name-lookup.c (pushtag): Process the template type before\n\taltering the identifier lookup fields.  Remove unreachable code\n\tcreating an empty stub decl.\ntestsuite:\n\tPR c++/23219\n\t* g++.dg/parse/crash28.C: New.\n\nFrom-SVN: r102982", "tree": {"sha": "4c03d748fb74ca597e759c18eab345d5d1958165", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4c03d748fb74ca597e759c18eab345d5d1958165"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6a0007046e65103e31c66bc0ef0d28d28e89d813", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a0007046e65103e31c66bc0ef0d28d28e89d813", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a0007046e65103e31c66bc0ef0d28d28e89d813", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a0007046e65103e31c66bc0ef0d28d28e89d813/comments", "author": null, "committer": null, "parents": [{"sha": "cac329963a81d95f7f04ece46bbc07786e954e40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cac329963a81d95f7f04ece46bbc07786e954e40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cac329963a81d95f7f04ece46bbc07786e954e40"}], "stats": {"total": 208, "additions": 112, "deletions": 96}, "files": [{"sha": "e9048213b06872fb7e6a1f6ba9ff85cb8e42b6e5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0007046e65103e31c66bc0ef0d28d28e89d813/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0007046e65103e31c66bc0ef0d28d28e89d813/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6a0007046e65103e31c66bc0ef0d28d28e89d813", "patch": "@@ -1,3 +1,10 @@\n+2005-08-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/23219\n+\t* name-lookup.c (pushtag): Process the template type before\n+\taltering the identifier lookup fields.  Remove unreachable code\n+\tcreating an empty stub decl.\n+\n 2005-08-10  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \tPR c++/20646"}, {"sha": "79a6552619e2344249b4466d7034baed1e9e8061", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 86, "deletions": 96, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0007046e65103e31c66bc0ef0d28d28e89d813/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0007046e65103e31c66bc0ef0d28d28e89d813/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=6a0007046e65103e31c66bc0ef0d28d28e89d813", "patch": "@@ -4626,6 +4626,7 @@ tree\n pushtag (tree name, tree type, tag_scope scope)\n {\n   struct cp_binding_level *b;\n+  tree decl;\n \n   timevar_push (TV_NAME_LOOKUP);\n   b = current_binding_level;\n@@ -4647,114 +4648,103 @@ pushtag (tree name, tree type, tag_scope scope)\n \t\t || COMPLETE_TYPE_P (b->this_entity))))\n     b = b->level_chain;\n \n-  if (name)\n+  gcc_assert (TREE_CODE (name) == IDENTIFIER_NODE);\n+  \n+  /* Do C++ gratuitous typedefing.  */\n+  if (IDENTIFIER_TYPE_VALUE (name) != type)\n     {\n-      /* Do C++ gratuitous typedefing.  */\n-      if (IDENTIFIER_TYPE_VALUE (name) != type)\n-\t{\n-\t  tree d = NULL_TREE;\n-\t  int in_class = 0;\n-\t  tree context = TYPE_CONTEXT (type);\n-\n-\t  if (! context)\n-\t    {\n-\t      tree cs = current_scope ();\n-\n-\t      if (scope == ts_current)\n-\t\tcontext = cs;\n-\t      else if (cs != NULL_TREE && TYPE_P (cs))\n-\t\t/* When declaring a friend class of a local class, we want\n-\t\t   to inject the newly named class into the scope\n-\t\t   containing the local class, not the namespace scope.  */\n-\t\tcontext = decl_function_context (get_type_decl (cs));\n-\t    }\n-\t  if (!context)\n-\t    context = current_namespace;\n-\n-\t  if (b->kind == sk_class\n-\t      || (b->kind == sk_template_parms\n-\t\t  && b->level_chain->kind == sk_class))\n-\t    in_class = 1;\n+      tree tdef;\n+      int in_class = 0;\n+      tree context = TYPE_CONTEXT (type);\n \n-\t  if (current_lang_name == lang_name_java)\n-\t    TYPE_FOR_JAVA (type) = 1;\n+      if (! context)\n+\t{\n+\t  tree cs = current_scope ();\n+\t  \n+\t  if (scope == ts_current)\n+\t    context = cs;\n+\t  else if (cs != NULL_TREE && TYPE_P (cs))\n+\t    /* When declaring a friend class of a local class, we want\n+\t       to inject the newly named class into the scope\n+\t       containing the local class, not the namespace\n+\t       scope.  */\n+\t    context = decl_function_context (get_type_decl (cs));\n+\t}\n+      if (!context)\n+\tcontext = current_namespace;\n \n-\t  d = create_implicit_typedef (name, type);\n-\t  DECL_CONTEXT (d) = FROB_CONTEXT (context);\n-\t  if (scope == ts_within_enclosing_non_class)\n-\t    {\n-\t      /* This is a friend.  Make this TYPE_DECL node hidden from\n-\t\t ordinary name lookup.  Its corresponding TEMPLATE_DECL\n-\t\t will be marked in push_template_decl_real.  */\n-\t      retrofit_lang_decl (d);\n-\t      DECL_ANTICIPATED (d) = 1;\n-\t      DECL_FRIEND_P (d) = 1;\n-\t    }\n+      if (b->kind == sk_class\n+\t  || (b->kind == sk_template_parms\n+\t      && b->level_chain->kind == sk_class))\n+\tin_class = 1;\n \n-\t  if (! in_class)\n-\t    set_identifier_type_value_with_scope (name, d, b);\n+      if (current_lang_name == lang_name_java)\n+\tTYPE_FOR_JAVA (type) = 1;\n \n-\t  d = maybe_process_template_type_declaration\n-\t\t(type, scope == ts_within_enclosing_non_class, b);\n-\t  if (d == error_mark_node)\n-\t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, error_mark_node);\n-\n-\t  if (b->kind == sk_class)\n-\t    {\n-\t      if (!PROCESSING_REAL_TEMPLATE_DECL_P ())\n-\t\t/* Put this TYPE_DECL on the TYPE_FIELDS list for the\n-\t\t   class.  But if it's a member template class, we\n-\t\t   want the TEMPLATE_DECL, not the TYPE_DECL, so this\n-\t\t   is done later.  */\n-\t\tfinish_member_declaration (d);\n-\t      else\n-\t\tpushdecl_class_level (d);\n-\t    }\n-\t  else if (b->kind != sk_template_parms)\n-\t    d = pushdecl_with_scope (d, b);\n-\n-\t  TYPE_CONTEXT (type) = DECL_CONTEXT (d);\n-\n-\t  /* If this is a local class, keep track of it.  We need this\n-\t     information for name-mangling, and so that it is possible to find\n-\t     all function definitions in a translation unit in a convenient\n-\t     way.  (It's otherwise tricky to find a member function definition\n-\t     it's only pointed to from within a local class.)  */\n-\t  if (TYPE_CONTEXT (type)\n-\t      && TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL)\n-\t    VEC_safe_push (tree, gc, local_classes, type);\n-\t}\n-      if (b->kind == sk_class\n-\t  && !COMPLETE_TYPE_P (current_class_type))\n+      tdef = create_implicit_typedef (name, type);\n+      DECL_CONTEXT (tdef) = FROB_CONTEXT (context);\n+      if (scope == ts_within_enclosing_non_class)\n \t{\n-\t  maybe_add_class_template_decl_list (current_class_type,\n-\t\t\t\t\t      type, /*friend_p=*/0);\n+\t  /* This is a friend.  Make this TYPE_DECL node hidden from\n+\t     ordinary name lookup.  Its corresponding TEMPLATE_DECL\n+\t     will be marked in push_template_decl_real.  */\n+\t  retrofit_lang_decl (tdef);\n+\t  DECL_ANTICIPATED (tdef) = 1;\n+\t  DECL_FRIEND_P (tdef) = 1;\n+\t}\n \n-\t  if (CLASSTYPE_NESTED_UTDS (current_class_type) == NULL)\n-\t    CLASSTYPE_NESTED_UTDS (current_class_type)\n-\t      = binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n+      decl = maybe_process_template_type_declaration\n+\t(type, scope == ts_within_enclosing_non_class, b);\n+      if (decl == error_mark_node)\n+\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, decl);\n+\t  \n+      if (! in_class)\n+\tset_identifier_type_value_with_scope (name, tdef, b);\n \n-\t  binding_table_insert\n-\t    (CLASSTYPE_NESTED_UTDS (current_class_type), name, type);\n+      if (b->kind == sk_class)\n+\t{\n+\t  if (!PROCESSING_REAL_TEMPLATE_DECL_P ())\n+\t    /* Put this TYPE_DECL on the TYPE_FIELDS list for the\n+\t       class.  But if it's a member template class, we want\n+\t       the TEMPLATE_DECL, not the TYPE_DECL, so this is done\n+\t       later.  */\n+\t    finish_member_declaration (decl);\n+\t  else\n+\t    pushdecl_class_level (decl);\n \t}\n+      else if (b->kind != sk_template_parms)\n+\tdecl = pushdecl_with_scope (decl, b);\n+\n+      TYPE_CONTEXT (type) = DECL_CONTEXT (decl);\n+\n+      /* If this is a local class, keep track of it.  We need this\n+\t information for name-mangling, and so that it is possible to\n+\t find all function definitions in a translation unit in a\n+\t convenient way.  (It's otherwise tricky to find a member\n+\t function definition it's only pointed to from within a local\n+\t class.)  */\n+      if (TYPE_CONTEXT (type)\n+\t  && TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL)\n+\tVEC_safe_push (tree, gc, local_classes, type);\n     }\n-\n-  if (TREE_CODE (TYPE_NAME (type)) == TYPE_DECL)\n-    /* Use the canonical TYPE_DECL for this node.  */\n-    TYPE_STUB_DECL (type) = TYPE_NAME (type);\n-  else\n+  if (b->kind == sk_class\n+      && !COMPLETE_TYPE_P (current_class_type))\n     {\n-      /* Create a fake NULL-named TYPE_DECL node whose TREE_TYPE\n-\t will be the tagged type we just added to the current\n-\t binding level.  This fake NULL-named TYPE_DECL node helps\n-\t dwarfout.c to know when it needs to output a\n-\t representation of a tagged type, and it also gives us a\n-\t convenient place to record the \"scope start\" address for\n-\t the tagged type.  */\n-\n-      tree d = build_decl (TYPE_DECL, NULL_TREE, type);\n-      TYPE_STUB_DECL (type) = pushdecl_with_scope (d, b);\n+      maybe_add_class_template_decl_list (current_class_type,\n+\t\t\t\t\t  type, /*friend_p=*/0);\n+      \n+      if (CLASSTYPE_NESTED_UTDS (current_class_type) == NULL)\n+\tCLASSTYPE_NESTED_UTDS (current_class_type)\n+\t  = binding_table_new (SCOPE_DEFAULT_HT_SIZE);\n+      \n+      binding_table_insert\n+\t(CLASSTYPE_NESTED_UTDS (current_class_type), name, type);\n     }\n+\n+  decl = TYPE_NAME (type);\n+  gcc_assert (TREE_CODE (decl) == TYPE_DECL);\n+  TYPE_STUB_DECL (type) = decl;\n+\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, type);\n }\n \f"}, {"sha": "558456df05877519253034b9b61959be2e584521", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0007046e65103e31c66bc0ef0d28d28e89d813/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0007046e65103e31c66bc0ef0d28d28e89d813/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6a0007046e65103e31c66bc0ef0d28d28e89d813", "patch": "@@ -1,3 +1,8 @@\n+2005-08-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/23219\n+\t* g++.dg/parse/crash28.C: New.\n+\n 2005-08-11  Richard Guenther  <rguenther@suse.de>\n \n \tPR target/23289"}, {"sha": "9c38f89ba425cf1cdd8a5f85f984e488dfca4469", "filename": "gcc/testsuite/g++.dg/parse/crash28.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6a0007046e65103e31c66bc0ef0d28d28e89d813/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash28.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6a0007046e65103e31c66bc0ef0d28d28e89d813/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash28.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fcrash28.C?ref=6a0007046e65103e31c66bc0ef0d28d28e89d813", "patch": "@@ -0,0 +1,14 @@\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 10 Aug 2005 <nathan@codesourcery.com>\n+\n+// PR 23219, ICE\n+// Origin:Andrew Pinski <pinskia@gcc.gnu.org>\n+//        Volker Reichelt <reichelt@gcc.gnu.org>\n+\n+template <class _Tp> class insert_iterator<slist<_Tp> > {}; // { dg-error \"not a template|not declared in this scope|expected unqualified-id|extra\" }\n+template <class _Value> class insert_iterator<int > { // { dg-error \"template parameters not used|_Value\" }\n+  hash_set<_Value>; // { dg-error \"no type|expected\" }\n+};\n+\n+template<int> struct A<X<> > {}; // { dg-error \"not a template|not declared in this scope|expected unqualified-id|extra\" }\n+struct A {}; // { dg-error \"template argument required\" }"}]}