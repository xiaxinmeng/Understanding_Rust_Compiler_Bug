{"sha": "92fb2d32d5e8ff33855ab277581cd088c36cffa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJmYjJkMzJkNWU4ZmYzMzg1NWFiMjc3NTgxY2QwODhjMzZjZmZhNQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-03-02T16:04:50Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-03-02T16:04:50Z"}, "message": "PR middle-end/18029 and PR middle-end/18030\n\n\tPR middle-end/18029 and PR middle-end/18030\n\t* expr.c (optimize_bitfield_assignment_op): Add a special case\n\tto handle BIT_IOR_EXPR and BIT_XOR_EXPR.\n\nFrom-SVN: r95782", "tree": {"sha": "9dcbe9e572ba553267b04d23cba26ed6a5d2503f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9dcbe9e572ba553267b04d23cba26ed6a5d2503f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92fb2d32d5e8ff33855ab277581cd088c36cffa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92fb2d32d5e8ff33855ab277581cd088c36cffa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92fb2d32d5e8ff33855ab277581cd088c36cffa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92fb2d32d5e8ff33855ab277581cd088c36cffa5/comments", "author": null, "committer": null, "parents": [{"sha": "613c5cd0c61e7a93867db827b8570af26b2fe002", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/613c5cd0c61e7a93867db827b8570af26b2fe002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/613c5cd0c61e7a93867db827b8570af26b2fe002"}], "stats": {"total": 39, "additions": 39, "deletions": 0}, "files": [{"sha": "fccfa7e3606d91151e0ceb811ce1857a4eff3df6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fb2d32d5e8ff33855ab277581cd088c36cffa5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fb2d32d5e8ff33855ab277581cd088c36cffa5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92fb2d32d5e8ff33855ab277581cd088c36cffa5", "patch": "@@ -6,6 +6,10 @@\n \tconfig/rs6000/rs6000-protos.h, doc/contrib.texi,\n \tdoc/include/gcc-common.texi: Update copyright.\n \n+\tPR middle-end/18029 and PR middle-end/18030\n+\t* expr.c (optimize_bitfield_assignment_op): Add a special case\n+\tto handle BIT_IOR_EXPR and BIT_XOR_EXPR.\n+\n 2005-03-02  Richard Guenther  <rguenth@gcc.gnu.org>\n \n \t* cgraph.h (struct cgraph_edge): Add prev_caller and"}, {"sha": "c2c9ffe10b06418b6633d4a837adb93acb62fff5", "filename": "gcc/expr.c", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fb2d32d5e8ff33855ab277581cd088c36cffa5/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fb2d32d5e8ff33855ab277581cd088c36cffa5/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=92fb2d32d5e8ff33855ab277581cd088c36cffa5", "patch": "@@ -3755,6 +3755,41 @@ optimize_bitfield_assignment_op (unsigned HOST_WIDE_INT bitsize,\n \temit_move_insn (str_rtx, result);\n       return true;\n \n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+      if (TREE_CODE (op1) != INTEGER_CST)\n+\tbreak;\n+      value = expand_expr (op1, NULL_RTX, GET_MODE (str_rtx), 0);\n+      value = convert_modes (GET_MODE (str_rtx),\n+\t\t\t     TYPE_MODE (TREE_TYPE (op1)), value,\n+\t\t\t     TYPE_UNSIGNED (TREE_TYPE (op1)));\n+\n+      /* We may be accessing data outside the field, which means\n+\t we can alias adjacent data.  */\n+      if (MEM_P (str_rtx))\n+\t{\n+\t  str_rtx = shallow_copy_rtx (str_rtx);\n+\t  set_mem_alias_set (str_rtx, 0);\n+\t  set_mem_expr (str_rtx, 0);\n+\t}\n+\n+      binop = TREE_CODE (src) == BIT_IOR_EXPR ? ior_optab : xor_optab;\n+      if (bitpos + bitsize != GET_MODE_BITSIZE (GET_MODE (str_rtx)))\n+\t{\n+\t  rtx mask = GEN_INT (((unsigned HOST_WIDE_INT) 1 << bitsize)\n+\t\t\t      - 1);\n+\t  value = expand_and (GET_MODE (str_rtx), value, mask,\n+\t\t\t      NULL_RTX);\n+\t}\n+      value = expand_shift (LSHIFT_EXPR, GET_MODE (str_rtx), value,\n+\t\t\t    build_int_cst (NULL_TREE, bitpos),\n+\t\t\t    NULL_RTX, 1);\n+      result = expand_binop (GET_MODE (str_rtx), binop, str_rtx,\n+\t\t\t     value, str_rtx, 1, OPTAB_WIDEN);\n+      if (result != str_rtx)\n+\temit_move_insn (str_rtx, result);\n+      return true;\n+\n     default:\n       break;\n     }"}]}