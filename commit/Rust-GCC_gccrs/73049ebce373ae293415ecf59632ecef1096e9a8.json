{"sha": "73049ebce373ae293415ecf59632ecef1096e9a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzMwNDllYmNlMzczYWUyOTM0MTVlY2Y1OTYzMmVjZWYxMDk2ZTlhOA==", "commit": {"author": {"name": "Michael Tiemann", "email": "tiemann@holodeck.cygnus.com", "date": "1999-08-25T06:51:15Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-08-25T06:51:15Z"}, "message": "loop.c (strength_reduce): Automatically unroll loops if the unrolled loop size is smaller than the rolled...\n\n        * loop.c (strength_reduce): Automatically unroll loops if the\n        unrolled loop size is smaller than the rolled loop size.\n\nCo-Authored-By: Jeffrey A Law <law@cygnus.com>\n\nFrom-SVN: r28841", "tree": {"sha": "9813a083f751252fafc2a2db258f4a7481e05151", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9813a083f751252fafc2a2db258f4a7481e05151"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/73049ebce373ae293415ecf59632ecef1096e9a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73049ebce373ae293415ecf59632ecef1096e9a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/73049ebce373ae293415ecf59632ecef1096e9a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/73049ebce373ae293415ecf59632ecef1096e9a8/comments", "author": null, "committer": null, "parents": [{"sha": "3ad47811828b57df93c02cae611de9953e9daef4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad47811828b57df93c02cae611de9953e9daef4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ad47811828b57df93c02cae611de9953e9daef4"}], "stats": {"total": 40, "additions": 37, "deletions": 3}, "files": [{"sha": "720b94f6144976c0204836cc45aaabfd7825be31", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049ebce373ae293415ecf59632ecef1096e9a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049ebce373ae293415ecf59632ecef1096e9a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=73049ebce373ae293415ecf59632ecef1096e9a8", "patch": "@@ -4,6 +4,10 @@ Tue Aug 24 23:43:03 1999  Mark Mitchell  <mark@codesourcery.com>\n \tNOTE_INSN_EH_REGION_END correctly.\n \n Tue Aug 24 23:26:44 1999  Michael Tiemann  <tiemann@holodeck.cygnus.com>\n+\t\t\t  Jeff Law <law@cygnus.com>\n+\n+\t* loop.c (strength_reduce): Automatically unroll loops if the\n+\tunrolled loop size is smaller than the rolled loop size.\n \n \t* loop.c (insert_bct): Replace use of sdiv_optab with asr_optab\n \tand delete comment that code should be rewritten."}, {"sha": "931c08318efb8237776ecb301b33ccd0da07fde5", "filename": "gcc/loop.c", "status": "modified", "additions": 33, "deletions": 3, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/73049ebce373ae293415ecf59632ecef1096e9a8/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/73049ebce373ae293415ecf59632ecef1096e9a8/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=73049ebce373ae293415ecf59632ecef1096e9a8", "patch": "@@ -3705,6 +3705,7 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n   int n_extra_increment;\n   struct loop_info loop_iteration_info;\n   struct loop_info *loop_info = &loop_iteration_info;\n+  int unrolled_insn_copies;\n \n   /* If scan_start points to the loop exit test, we have to be wary of\n      subversive use of gotos inside expression statements.  */\n@@ -5133,11 +5134,40 @@ strength_reduce (scan_start, end, loop_top, insn_count,\n \tINSN_CODE (p) = -1;\n       }\n \n+  if (loop_info->n_iterations > 0)\n+    {\n+      /* When we completely unroll a loop we will likely not need the increment\n+\t of the loop BIV and we will not need the conditional branch at the\n+\t end of the loop.  */\n+      unrolled_insn_copies = insn_count - 2;\n+\n+#ifdef HAVE_cc0\n+      /* When we completely unroll a loop on a HAVE_cc0 machine we will not\n+\t need the comparison before the conditional branch at the end of the\n+\t loop.  */\n+      unrolled_insn_copies = insn_count - 2;\n+#endif\n+\n+      /* We'll need one copy for each loop iteration.  */\n+      unrolled_insn_copies *= loop_info->n_iterations;\n+\n+      /* A little slop to account for the ability to remove initialization\n+\t code, better CSE, and other secondary benefits of completely\n+\t unrolling some loops.  */\n+      unrolled_insn_copies -= 1;\n+\n+      /* Clamp the value.  */\n+      if (unrolled_insn_copies < 0)\n+\tunrolled_insn_copies = 0;\n+    }\n+  \n   /* Unroll loops from within strength reduction so that we can use the\n      induction variable information that strength_reduce has already\n-     collected.  */\n-  \n-  if (unroll_p)\n+     collected.  Always unroll loops that would be as small or smaller\n+     unrolled than when rolled.  */\n+  if (unroll_p\n+      || (loop_info->n_iterations > 0\n+\t  && unrolled_insn_copies <= insn_count))\n     unroll_loop (loop_end, insn_count, loop_start, end_insert_before,\n \t\t loop_info, 1);\n "}]}