{"sha": "dcd416e3ac292bbbc299721a38d1a2086aaf10ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGNkNDE2ZTNhYzI5MmJiYmMyOTk3MjFhMzhkMWEyMDg2YWFmMTBiYQ==", "commit": {"author": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2008-04-30T10:01:59Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2008-04-30T10:01:59Z"}, "message": "ipa-cp.c (ipcp_init_stage): Calls ipa_set_called_with_variable_arg instead of setting number of formal...\n\n2008-04-30  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-cp.c (ipcp_init_stage): Calls ipa_set_called_with_variable_arg\n\tinstead of setting number of formal parameters to zero.\n\t(ipcp_init_stage): Do not set the number of actual parameters to zero \n\teither.\n\t(ipcp_propagate_stage): Explicitly skipping all calls to nodes\n\twhich are called with variable number of arguments.\n\t(ipcp_insert_stage): Explicitely skipping all nodes which are\n\tcalled with variable number of arguments.\n\t(ipcp_callsite_param_print): Skipps callsites to nodes with varaible \n\tnumber of parameters.\n\n\t* ipa-prop.h (struct ipa_node_params): Added flag\n\tcalled_with_var_arguments\n\t(ipa_set_param_count): Added.  Changed sole setter to use it.\n\t(ipa_get_param_count): Added.  All readers of param_count\n\tconverted to use it instead.\n\t(ipa_set_called_with_variable_arg): Added.\n\t(ipa_is_called_with_var_arguments): Added.\n\t(ipa_get_ith_param): Added.  All readers of param_decls converted\n\tto use it instead.\n\t(ipa_set_cs_argument_count): Added, sole writer to argument_count \n\tchanged to use it. \n\t(ipa_get_cs_argument_count): Added, all readers of argument_count\n\tchanged to cal it.\n\t(ipa_get_ith_jump_func): Added. Accessors of jump values changed \n\tto use it.\n\t\n\t* ipa-prop.h (struct ipcp_formal): Renamed to ipcp_lattice\n\t(struct ipcp_lattice): Renamed cval_type to type\n\t(struct ipa_node_params): ipcp_cval renamed to ipcp_lattices\n\n\t* ipa-cp.c (ipcp_cval_get_cvalue): Changed return value to tree\n\t(ipcp_cval_set_cvalue): Changed type of parameter value to tree\n\t(ipcp_insert_stage): Changed the type of variable cvalue to tree\n\t(ipcp_replace_map_create): Changed the type of parameter cvalue to tree\n\t(build_const_val): Changed the type of parameter cvalue to tree\n\t(ipcp_propagate_const): Changed the type of parameter cvalue to tree\n\t(ipcp_method_cval_set_cvalue_type): Renamed parameter cval_type1 to type\n\t\n\t* ipa-prop.h (struct ipcp_formal): Replaced cvalue with tree called \n\tconstant \n\n\t* ipa-prop.c (ipa_methodlist_init): Renamed to ipa_init_func_list\n\t(ipa_methodlist_not_empty): Removed, the sole user now checks directly\n\t(ipa_add_method): Renamed to ipa_push_func_to_list\n\t(ipa_remove_method): Renamed to ipa_pop_func_from_list\n\t(ipa_callsite_param_count): Removed.\n\t(ipa_callsite_param_count_set): Removed.\n\t(ipa_callsite_param): Removed.\n\t(ipa_callsite_callee): Removed.\n\t(ipa_callsite_compute_param): Renamed to ipa_compute_jump_functions\n\t(ipa_callsite_compute_count): Renamed to ipa_count_arguments\n\t(ipa_method_formal_count): Removed.\n\t(ipa_method_formal_count_set): Removed.\n\t(ipa_method_get_tree): Removed.\n\t(ipa_method_tree_map_create): Removed.\n\t(ipa_method_compute_tree_map): Renamed to ipa_create_param_decls_array\n\t(ipa_create_param_decls_array): Creates the array itself\n\t(ipa_create_param_decls_array): Temporary variable info instead of \n\ta few dereferences.\n\t(ipa_method_formal_compute_count): Renamed to ipa_count_formal_params\n\t(ipa_method_compute_modify): Renamed to ipa_detect_param_modifications\n\t(get_type): Removed.\n\t(ipa_jf_get_info_type): Removed.\n\t(ipa_node_create): Renamed to ipa_create_node_params\n\t(ipa_free): Renamed to ipa_free_all_node_params\n\t(ipa_nodes_create): Renamed to ipa_create_all_node_params\n\t(ipa_edges_create): Renamed to ipa_create_all_edge_args\n\t(ipa_edges_free): Renamed to ipa_free_all_edge_args\n\t(ipa_nodes_free): Integrated into ipa_free_all_node_params and removed\n\t(ipa_free_all_node_params): Deallocation to jump_functions moved to \n\tipa_free_all_edge_args\n\t(ipa_method_tree_print): Renamed to ipa_print_all_tree_maps\n\t(ipa_method_modify_print): Renamed to ipa_print_all_params_modified\n\t(ipa_create_methodlist_node): Removed.\n\t(ipa_methodlist_method): Removed.\n\t(ipa_methodlist_method_set): Removed.\n\t(ipa_methodlist_next_method): Removed.\n\t(ipa_methodlist_next_method_set): Removed.\n\t(ipa_method_is_modified): Removed.\n\t(ipa_method_modify_create): Removed.\n\t(ipa_method_modify_init): Temporary variable info instead of a few \n\tdereferences.\n\t(ipa_detect_param_modifications): Temporary variable info instead of \n\ta few dereferences.\n\t(ipa_compute_jump_functions): Temporary variable info instead of \n\ta few dereferences.\n\t(ipa_method_modify_set): Removed.\n\t(ipa_method_tree_map): Renamed to ipa_get_param_decl_index\n\t(ipa_get_param_decl_index): Now accepts struct ipa_node_params rather \n\tthan craph_node as the first parameter.\n\t(ipa_method_modify_stmt): Renamed to ipa_check_stmt_modifications\n\t(ipa_method_modify_init): Removed.\n\t(ipa_compute_jump_functions): Added a temp variable instead of \n\trepeatadly dereferencing the cgraph_edge.aux pointer\n\t(ipa_callsite_param_set_type): Removed.\n\t(ipa_compute_jump_functions): i renamed to index and moved to \n\tan inner block\n\t(ipa_callsite_param_set_info_type_formal): Removed.\n\t(ipa_callsite_param_set_info_type): Removed.\n\t(ipa_callsite_param_map_create): Removed.\n\t(ipa_callsite_tree): Removed.\n\t(ipa_callsite_caller): Removed.\n\t(ipa_pop_func_from_list): return_method removed to return_func\n\n\t* ipa-prop.h (enum cvalue_type): Renamed to ipa_lattice_type,\n\tprefixed all values with IPA_. Changed all users.\n\t(enum jump_func_type): Rnamed UNKNOWN_IPATYPE to IPA_UNKNOWN, \n\tCONST_IPATYPE to IPA_CONST, CONST_IPATYPE_REF to IPA_CONST_REF \n\tand FORMAL_IPATYPE IPA_PASS_THROUGH. \n\t(union parameter_info): Renamed to jump_func_value.\n\t(union jump_func_value): Renamed value to constant\n\t(struct ipa_jump_func): Renamed info_type to value\n\t(struct ipa_node): Renamed to ipa_node_params\n\t(struct ipa_node_params): Renamed ipa_arg_num to param_count\n\t(struct ipa_node_params): Renamed ipa_param_tree to param_decls\n\t(struct ipa_node_params): Renamed ipa_mod to modified_flags\n\t(struct ipa_edge): Renamed to ipa_edge_args\n\t(struct ipa_edge_args): Renamed ipa_param_num to argument_count\n\t(struct ipa_edge_args): Renamed ipa_param_map to jump_functions\n\t(struct ipa_methodlist): Renamed to ipa_func_list\n\t(struct ipa_func_list): method_p renamed to node, next_method\n\trenamed to next\n\t(ipa_methodlist_p): Removed, switched all users to struct pointer\n\t(IS_VALID_TREE_MAP_INDEX): Renamed to IS_VALID_JUMP_FUNC_INDEX\n\nFrom-SVN: r134818", "tree": {"sha": "ff058a8b1bda87ec158e8494ef3b7c7ac7a42b4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff058a8b1bda87ec158e8494ef3b7c7ac7a42b4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dcd416e3ac292bbbc299721a38d1a2086aaf10ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcd416e3ac292bbbc299721a38d1a2086aaf10ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcd416e3ac292bbbc299721a38d1a2086aaf10ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcd416e3ac292bbbc299721a38d1a2086aaf10ba/comments", "author": null, "committer": null, "parents": [{"sha": "d79967325b69cd30814a5d69dba300a1b000281e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d79967325b69cd30814a5d69dba300a1b000281e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d79967325b69cd30814a5d69dba300a1b000281e"}], "stats": {"total": 1028, "additions": 440, "deletions": 588}, "files": [{"sha": "b8ae5ca91f8a6cf46482eb6b226a655434246c46", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 153, "deletions": 141, "changes": 294, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcd416e3ac292bbbc299721a38d1a2086aaf10ba/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcd416e3ac292bbbc299721a38d1a2086aaf10ba/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=dcd416e3ac292bbbc299721a38d1a2086aaf10ba", "patch": "@@ -72,7 +72,7 @@ along with GCC; see the file COPYING3.  If not see\n    \n    The jump function info, ipa_jump_func, is defined in ipa_edge\n    structure (defined in ipa_prop.h and pointed to by cgraph_node->aux)\n-   The modify info, ipa_modify, is defined in ipa_node structure\n+   The modify info, modified_flags, is defined in ipa_node_params structure\n    (defined in ipa_prop.h and pointed to by cgraph_edge->aux).\n    \n    -ipcp_init_stage() is the first stage driver.\n@@ -89,7 +89,7 @@ along with GCC; see the file COPYING3.  If not see\n    Cval of formal f will have a constant value if all callsites to this\n    function have the same constant value passed to f.\n    \n-   The cval info, ipcp_formal, is defined in ipa_node structure\n+   The cval info, ipcp_lattice, is defined in ipa_node_params structure\n    (defined in ipa_prop.h and pointed to by cgraph_edge->aux).\n \n    -ipcp_iterate_stage() is the second stage driver.\n@@ -145,7 +145,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dump.h\"\n #include \"tree-inline.h\"\n \n-/* Get orig node field of ipa_node associated with method MT.  */\n+/* Get orig node field of ipa_node_params associated with method MT.  */\n static inline struct cgraph_node *\n ipcp_method_orig_node (struct cgraph_node *mt)\n {\n@@ -173,17 +173,17 @@ static void\n ipcp_cloned_create (struct cgraph_node *orig_node,\n \t\t    struct cgraph_node *new_node)\n {\n-  ipa_node_create (new_node);\n+  ipa_create_node_params (new_node);\n   ipcp_method_set_orig_node (new_node, orig_node);\n-  ipa_method_formal_compute_count (new_node);\n-  ipa_method_compute_tree_map (new_node);\n+  ipa_count_formal_params (new_node);\n+  ipa_create_param_decls_array (new_node);\n }\n \n /* Return cval_type field of CVAL.  */\n-static inline enum cvalue_type\n-ipcp_cval_get_cvalue_type (struct ipcp_formal *cval)\n+static inline enum ipa_lattice_type\n+ipcp_cval_get_cvalue_type (struct ipcp_lattice *cval)\n {\n-  return cval->cval_type;\n+  return cval->type;\n }\n \n /* Return scale for MT.  */\n@@ -202,76 +202,76 @@ ipcp_method_set_scale (struct cgraph_node *node, gcov_type count)\n \n /* Set TYPE as cval_type field of CVAL.  */\n static inline void\n-ipcp_cval_set_cvalue_type (struct ipcp_formal *cval, enum cvalue_type type)\n+ipcp_cval_set_cvalue_type (struct ipcp_lattice *cval, enum jump_func_type type)\n {\n-  cval->cval_type = type;\n+  cval->type = type;\n }\n \n /* Return cvalue field of CVAL.  */\n-static inline union parameter_info *\n-ipcp_cval_get_cvalue (struct ipcp_formal *cval)\n+static inline tree\n+ipcp_cval_get_cvalue (struct ipcp_lattice *cval)\n {\n-  return &(cval->cvalue);\n+  return cval->constant;\n }\n \n /* Set VALUE as cvalue field  CVAL.  */\n static inline void\n-ipcp_cval_set_cvalue (struct ipcp_formal *cval, union parameter_info *value,\n-\t\t      enum cvalue_type type)\n+ipcp_cval_set_cvalue (struct ipcp_lattice *cval, tree value,\n+\t\t      enum ipa_lattice_type type)\n {\n-  if (type == CONST_VALUE || type == CONST_VALUE_REF)\n-    cval->cvalue.value = value->value;\n+  if (type == IPA_CONST_VALUE || type == IPA_CONST_VALUE_REF)\n+    cval->constant = value;\n }\n \n /* Return whether TYPE is a constant type.  */\n static bool\n-ipcp_type_is_const (enum cvalue_type type)\n+ipcp_type_is_const (enum ipa_lattice_type type)\n {\n-  if (type == CONST_VALUE || type == CONST_VALUE_REF)\n+  if (type == IPA_CONST_VALUE || type == IPA_CONST_VALUE_REF)\n     return true;\n   else\n     return false;\n }\n \n /* Return true if CONST_VAL1 and CONST_VAL2 are equal.  */\n static inline bool\n-ipcp_cval_equal_cvalues (union parameter_info *const_val1,\n-\t\t\t union parameter_info *const_val2,\n-\t\t\t enum cvalue_type type1, enum cvalue_type type2)\n+ipcp_cval_equal_cvalues (tree const_val1, tree const_val2,\n+\t\t\t enum ipa_lattice_type type1,\n+\t\t\t enum ipa_lattice_type type2)\n {\n   gcc_assert (ipcp_type_is_const (type1) && ipcp_type_is_const (type2));\n   if (type1 != type2)\n     return false;\n \n-  if (operand_equal_p (const_val1->value, const_val2->value, 0))\n+  if (operand_equal_p (const_val1, const_val2, 0))\n     return true;\n \n   return false;\n }\n \n /* Compute Meet arithmetics:\n-   Meet (BOTTOM, x) = BOTTOM\n-   Meet (TOP,x) = x\n-   Meet (const_a,const_b) = BOTTOM,  if const_a != const_b.  \n+   Meet (IPA_BOTTOM, x) = IPA_BOTTOM\n+   Meet (IPA_TOP,x) = x\n+   Meet (const_a,const_b) = IPA_BOTTOM,  if const_a != const_b.\n    MEET (const_a,const_b) = const_a, if const_a == const_b.*/\n static void\n-ipcp_cval_meet (struct ipcp_formal *cval, struct ipcp_formal *cval1,\n-\t\tstruct ipcp_formal *cval2)\n+ipcp_cval_meet (struct ipcp_lattice *cval, struct ipcp_lattice *cval1,\n+\t\tstruct ipcp_lattice *cval2)\n {\n-  if (ipcp_cval_get_cvalue_type (cval1) == BOTTOM\n-      || ipcp_cval_get_cvalue_type (cval2) == BOTTOM)\n+  if (ipcp_cval_get_cvalue_type (cval1) == IPA_BOTTOM\n+      || ipcp_cval_get_cvalue_type (cval2) == IPA_BOTTOM)\n     {\n-      ipcp_cval_set_cvalue_type (cval, BOTTOM);\n+      ipcp_cval_set_cvalue_type (cval, IPA_BOTTOM);\n       return;\n     }\n-  if (ipcp_cval_get_cvalue_type (cval1) == TOP)\n+  if (ipcp_cval_get_cvalue_type (cval1) == IPA_TOP)\n     {\n       ipcp_cval_set_cvalue_type (cval, ipcp_cval_get_cvalue_type (cval2));\n       ipcp_cval_set_cvalue (cval, ipcp_cval_get_cvalue (cval2),\n \t\t\t    ipcp_cval_get_cvalue_type (cval2));\n       return;\n     }\n-  if (ipcp_cval_get_cvalue_type (cval2) == TOP)\n+  if (ipcp_cval_get_cvalue_type (cval2) == IPA_TOP)\n     {\n       ipcp_cval_set_cvalue_type (cval, ipcp_cval_get_cvalue_type (cval1));\n       ipcp_cval_set_cvalue (cval, ipcp_cval_get_cvalue (cval1),\n@@ -283,7 +283,7 @@ ipcp_cval_meet (struct ipcp_formal *cval, struct ipcp_formal *cval1,\n \t\t\t\tipcp_cval_get_cvalue_type (cval1),\n \t\t\t\tipcp_cval_get_cvalue_type (cval2)))\n     {\n-      ipcp_cval_set_cvalue_type (cval, BOTTOM);\n+      ipcp_cval_set_cvalue_type (cval, IPA_BOTTOM);\n       return;\n     }\n   ipcp_cval_set_cvalue_type (cval, ipcp_cval_get_cvalue_type (cval1));\n@@ -292,34 +292,35 @@ ipcp_cval_meet (struct ipcp_formal *cval, struct ipcp_formal *cval1,\n }\n \n /* Return cval structure for the formal at index INFO_TYPE in MT.  */\n-static inline struct ipcp_formal *\n+static inline struct ipcp_lattice *\n ipcp_method_cval (struct cgraph_node *mt, int info_type)\n {\n-  return &(IPA_NODE_REF (mt)->ipcp_cval[info_type]);\n+  return &(IPA_NODE_REF (mt)->ipcp_lattices[info_type]);\n }\n \n /* Given the jump function (TYPE, INFO_TYPE), compute a new value of CVAL.  \n    If TYPE is FORMAL_IPA_TYPE, the cval of the corresponding formal is \n    drawn from MT.  */\n static void\n-ipcp_cval_compute (struct ipcp_formal *cval, struct cgraph_node *mt,\n-\t\t   enum jump_func_type type, union parameter_info *info_type)\n+ipcp_cval_compute (struct ipcp_lattice *cval, struct cgraph_node *mt,\n+\t\t   enum jump_func_type type,\n+\t\t   union jump_func_value *info_type)\n {\n-  if (type == UNKNOWN_IPATYPE)\n-    ipcp_cval_set_cvalue_type (cval, BOTTOM);\n-  else if (type == CONST_IPATYPE)\n+  if (type == IPA_UNKNOWN)\n+    ipcp_cval_set_cvalue_type (cval, IPA_BOTTOM);\n+  else if (type == IPA_CONST)\n     {\n-      ipcp_cval_set_cvalue_type (cval, CONST_VALUE);\n-      ipcp_cval_set_cvalue (cval, info_type, CONST_VALUE);\n+      ipcp_cval_set_cvalue_type (cval, IPA_CONST_VALUE);\n+      ipcp_cval_set_cvalue (cval, info_type->constant, IPA_CONST_VALUE);\n     }\n-  else if (type == CONST_IPATYPE_REF)\n+  else if (type == IPA_CONST_REF)\n     {\n-      ipcp_cval_set_cvalue_type (cval, CONST_VALUE_REF);\n-      ipcp_cval_set_cvalue (cval, info_type, CONST_VALUE_REF);\n+      ipcp_cval_set_cvalue_type (cval, IPA_CONST_VALUE_REF);\n+      ipcp_cval_set_cvalue (cval, info_type->constant, IPA_CONST_VALUE_REF);\n     }\n-  else if (type == FORMAL_IPATYPE)\n+  else if (type == IPA_PASS_THROUGH)\n     {\n-      enum cvalue_type type =\n+      enum ipa_lattice_type type =\n \tipcp_cval_get_cvalue_type (ipcp_method_cval\n \t\t\t\t   (mt, info_type->formal_id));\n       ipcp_cval_set_cvalue_type (cval, type);\n@@ -332,12 +333,12 @@ ipcp_cval_compute (struct ipcp_formal *cval, struct cgraph_node *mt,\n \n /* True when CVAL1 and CVAL2 values are not the same.  */\n static bool\n-ipcp_cval_changed (struct ipcp_formal *cval1, struct ipcp_formal *cval2)\n+ipcp_cval_changed (struct ipcp_lattice *cval1, struct ipcp_lattice *cval2)\n {\n   if (ipcp_cval_get_cvalue_type (cval1) == ipcp_cval_get_cvalue_type (cval2))\n     {\n-      if (ipcp_cval_get_cvalue_type (cval1) != CONST_VALUE &&\n-\t  ipcp_cval_get_cvalue_type (cval1) != CONST_VALUE_REF)\n+      if (ipcp_cval_get_cvalue_type (cval1) != IPA_CONST_VALUE\n+\t  && ipcp_cval_get_cvalue_type (cval1) != IPA_CONST_VALUE_REF)\n \treturn false;\n       if (ipcp_cval_equal_cvalues (ipcp_cval_get_cvalue (cval1),\n \t\t\t\t   ipcp_cval_get_cvalue (cval2),\n@@ -352,25 +353,33 @@ ipcp_cval_changed (struct ipcp_formal *cval1, struct ipcp_formal *cval2)\n static inline void\n ipcp_formal_create (struct cgraph_node *mt)\n {\n-  IPA_NODE_REF (mt)->ipcp_cval =\n-    XCNEWVEC (struct ipcp_formal, ipa_method_formal_count (mt));\n+  IPA_NODE_REF (mt)->ipcp_lattices =\n+    XCNEWVEC (struct ipcp_lattice, ipa_get_param_count (IPA_NODE_REF (mt)));\n }\n \n /* Set cval structure of I-th formal of MT to CVAL.  */\n static inline void\n-ipcp_method_cval_set (struct cgraph_node *mt, int i, struct ipcp_formal *cval)\n+ipcp_method_cval_set (struct cgraph_node *mt, int i, struct ipcp_lattice *cval)\n {\n-  IPA_NODE_REF (mt)->ipcp_cval[i].cval_type = cval->cval_type;\n+  IPA_NODE_REF (mt)->ipcp_lattices[i].type = cval->type;\n   ipcp_cval_set_cvalue (ipcp_method_cval (mt, i),\n-\t\t\tipcp_cval_get_cvalue (cval), cval->cval_type);\n+\t\t\tipcp_cval_get_cvalue (cval), cval->type);\n }\n \n /* Set type of cval structure of formal I of MT to CVAL_TYPE1.  */\n static inline void\n ipcp_method_cval_set_cvalue_type (struct cgraph_node *mt, int i,\n-\t\t\t\t  enum cvalue_type cval_type1)\n+\t\t\t\t  enum ipa_lattice_type type)\n {\n-  IPA_NODE_REF (mt)->ipcp_cval[i].cval_type = cval_type1;\n+  IPA_NODE_REF (mt)->ipcp_lattices[i].type = type;\n+}\n+\n+/* Set type of cval structure of formal I of MT to CVAL_TYPE1.  */\n+static inline void\n+ipcp_method_cval_set_lattice_type (struct cgraph_node *mt, int i,\n+\t\t\t\t   enum ipa_lattice_type type)\n+{\n+  IPA_NODE_REF (mt)->ipcp_lattices[i].type = type;\n }\n \n /* Print ipcp_cval data structures to F.  */\n@@ -385,51 +394,51 @@ ipcp_method_cval_print (FILE * f)\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       fprintf (f, \"Printing cvals %s:\\n\", cgraph_node_name (node));\n-      count = ipa_method_formal_count (node);\n+      count = ipa_get_param_count (IPA_NODE_REF (node));\n       for (i = 0; i < count; i++)\n \t{\n \t  if (ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i))\n-\t      == CONST_VALUE\n+\t      == IPA_CONST_VALUE\n \t      || ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i)) ==\n-\t      CONST_VALUE_REF)\n+\t      IPA_CONST_VALUE_REF)\n \t    {\n \t      fprintf (f, \" param [%d]: \", i);\n \t      fprintf (f, \"type is CONST \");\n \t      cvalue =\n-\t\tipcp_cval_get_cvalue (ipcp_method_cval (node, i))->value;\n+\t\tipcp_cval_get_cvalue (ipcp_method_cval (node, i));\n \t      print_generic_expr (f, cvalue, 0);\n \t      fprintf (f, \"\\n\");\n \t    }\n-\t  else if (ipcp_method_cval (node, i)->cval_type == TOP)\n+\t  else if (ipcp_method_cval (node, i)->type == IPA_TOP)\n \t    fprintf (f, \"param [%d]: type is TOP  \\n\", i);\n \t  else\n \t    fprintf (f, \"param [%d]: type is BOTTOM  \\n\", i);\n \t}\n     }\n }\n \n-/* Initialize ipcp_cval array of MT with TOP values.\n-   All cvals for a method's formal parameters are initialized to BOTTOM\n+/* Initialize ipcp_cval array of MT with IPA_TOP values.\n+   All cvals for a method's formal parameters are initialized to IPA_BOTTOM\n    The currently supported types are integer types, real types and\n    Fortran constants (i.e. references to constants defined as\n    const_decls). All other types are not analyzed and therefore are\n-   assigned with BOTTOM.  */\n+   assigned with IPA_BOTTOM.  */\n static void\n ipcp_method_cval_init (struct cgraph_node *mt)\n {\n   int i;\n   tree parm_tree;\n \n   ipcp_formal_create (mt);\n-  for (i = 0; i < ipa_method_formal_count (mt); i++)\n+  for (i = 0; i < ipa_get_param_count (IPA_NODE_REF (mt)) ; i++)\n     {\n-      parm_tree = ipa_method_get_tree (mt, i);\n+      parm_tree = ipa_get_ith_param (IPA_NODE_REF (mt), i);\n       if (INTEGRAL_TYPE_P (TREE_TYPE (parm_tree))\n \t  || SCALAR_FLOAT_TYPE_P (TREE_TYPE (parm_tree))\n \t  || POINTER_TYPE_P (TREE_TYPE (parm_tree)))\n-\tipcp_method_cval_set_cvalue_type (mt, i, TOP);\n+\tipcp_method_cval_set_cvalue_type (mt, i, IPA_TOP);\n       else\n-\tipcp_method_cval_set_cvalue_type (mt, i, BOTTOM);\n+\tipcp_method_cval_set_cvalue_type (mt, i, IPA_BOTTOM);\n     }\n }\n \n@@ -456,28 +465,27 @@ constant_val_insert (tree parm1, tree val)\n /* build INTEGER_CST tree with type TREE_TYPE and \n    value according to CVALUE. Return the tree.   */\n static tree\n-build_const_val (union parameter_info *cvalue, enum cvalue_type type,\n-\t\t tree tree_type)\n+build_const_val (tree cvalue, enum ipa_lattice_type type, tree tree_type)\n {\n   tree const_val = NULL;\n \n   gcc_assert (ipcp_type_is_const (type));\n-  const_val = fold_convert (tree_type, cvalue->value);\n+  const_val = fold_convert (tree_type, cvalue);\n   return const_val;\n }\n \n /* Build the tree representing the constant and call \n    constant_val_insert().  */\n static void\n ipcp_propagate_const (struct cgraph_node *mt, int param,\n-\t\t      union parameter_info *cvalue, enum cvalue_type type)\n+\t\t      tree cvalue, enum ipa_lattice_type type)\n {\n   tree const_val;\n   tree parm_tree;\n \n   if (dump_file)\n     fprintf (dump_file, \"propagating const to %s\\n\", cgraph_node_name (mt));\n-  parm_tree = ipa_method_get_tree (mt, param);\n+  parm_tree = ipa_get_ith_param (IPA_NODE_REF (mt), param);\n   const_val = build_const_val (cvalue, type, TREE_TYPE (parm_tree));\n   constant_val_insert (parm_tree, const_val);\n }\n@@ -514,34 +522,33 @@ ipcp_init_stage (void)\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      ipa_method_formal_compute_count (node);\n-      ipa_method_compute_tree_map (node);\n+      ipa_count_formal_params (node);\n+      ipa_create_param_decls_array (node);\n       ipcp_method_cval_init (node);\n-      ipa_method_compute_modify (node);\n+      ipa_detect_param_modifications (node);\n       ipcp_method_compute_scale (node);\n     }\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       /* building jump functions  */\n       for (cs = node->callees; cs; cs = cs->next_callee)\n \t{\n-\t  ipa_callsite_compute_count (cs);\n-\t  if (ipa_callsite_param_count (cs)\n-\t      != ipa_method_formal_count (cs->callee))\n+\t  ipa_count_arguments (cs);\n+\t  if (ipa_get_cs_argument_count (IPA_EDGE_REF (cs))\n+\t      != ipa_get_param_count (IPA_NODE_REF (cs->callee)))\n \t    {\n \t      /* Handle cases of functions with \n \t         a variable number of parameters.  */\n-\t      ipa_callsite_param_count_set (cs, 0);\n-\t      ipa_method_formal_count_set (cs->callee, 0);\n+\t      ipa_set_called_with_variable_arg (IPA_NODE_REF (cs->callee));\n \t    }\n \t  else\n-\t    ipa_callsite_compute_param (cs);\n+\t    ipa_compute_jump_functions (cs);\n \t}\n     }\n }\n \n-/* Return true if there are some formal parameters whose value is TOP.\n-   Change their values to BOTTOM, since they weren't determined.  */\n+/* Return true if there are some formal parameters whose value is IPA_TOP.\n+   Change their values to IPA_BOTTOM, since they weren't determined.  */\n static bool\n ipcp_after_propagate (void)\n {\n@@ -552,12 +559,12 @@ ipcp_after_propagate (void)\n   prop_again = false;\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      count = ipa_method_formal_count (node);\n+      count = ipa_get_param_count (IPA_NODE_REF (node));\n       for (i = 0; i < count; i++)\n-\tif (ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i)) == TOP)\n+\tif (ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i)) == IPA_TOP)\n \t  {\n \t    prop_again = true;\n-\t    ipcp_method_cval_set_cvalue_type (node, i, BOTTOM);\n+\t    ipcp_method_cval_set_cvalue_type (node, i, IPA_BOTTOM);\n \t  }\n     }\n   return prop_again;\n@@ -569,37 +576,39 @@ static void\n ipcp_propagate_stage (void)\n {\n   int i;\n-  struct ipcp_formal cval1 = { BOTTOM, {0} }, cval = { BOTTOM, {0} };\n-  struct ipcp_formal *cval2;\n+  struct ipcp_lattice cval1 = { IPA_BOTTOM, NULL }, cval = { IPA_BOTTOM, NULL };\n+  struct ipcp_lattice *cval2;\n   struct cgraph_node *mt, *callee;\n   struct cgraph_edge *cs;\n   struct ipa_jump_func *jump_func;\n   enum jump_func_type type;\n-  union parameter_info *info_type;\n-  ipa_methodlist_p wl;\n+  union jump_func_value *jf_value;\n+  struct ipa_func_list *wl;\n   int count;\n \n-  /* Initialize worklist to contain all methods.  */\n-  wl = ipa_methodlist_init ();\n-  while (ipa_methodlist_not_empty (wl))\n+  /* Initialize worklist to contain all functions.  */\n+  wl = ipa_init_func_list ();\n+  while (wl)\n     {\n-      mt = ipa_remove_method (&wl);\n+      mt = ipa_pop_func_from_list (&wl);\n       for (cs = mt->callees; cs; cs = cs->next_callee)\n \t{\n-\t  callee = ipa_callsite_callee (cs);\n-\t  count = ipa_callsite_param_count (cs);\n+\t  callee = cs->callee;\n+\t  if (ipa_is_called_with_var_arguments (IPA_NODE_REF (callee)))\n+\t    continue;\n+\t  count = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n \t  for (i = 0; i < count; i++)\n \t    {\n-\t      jump_func = ipa_callsite_param (cs, i);\n-\t      type = get_type (jump_func);\n-\t      info_type = ipa_jf_get_info_type (jump_func);\n-\t      ipcp_cval_compute (&cval1, mt, type, info_type);\n+\t      jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+\t      type = jump_func->type;\n+\t      jf_value = &jump_func->value;\n+\t      ipcp_cval_compute (&cval1, mt, type, jf_value);\n \t      cval2 = ipcp_method_cval (callee, i);\n \t      ipcp_cval_meet (&cval, &cval1, cval2);\n \t      if (ipcp_cval_changed (&cval, cval2))\n \t\t{\n \t\t  ipcp_method_cval_set (callee, i, &cval);\n-\t\t  ipa_add_method (&wl, callee);\n+\t\t  ipa_push_func_to_list (&wl, callee);\n \t\t}\n \t    }\n \t}\n@@ -613,7 +622,7 @@ ipcp_iterate_stage (void)\n {\n   ipcp_propagate_stage ();\n   if (ipcp_after_propagate ())\n-    /* Some cvals have changed from TOP to BOTTOM.  \n+    /* Some cvals have changed from IPA_TOP to IPA_BOTTOM.\n        This change should be propagated.  */\n     ipcp_propagate_stage ();\n }\n@@ -646,27 +655,30 @@ ipcp_callsite_param_print (FILE * f)\n \t{\n \t  fprintf (f, \"callsite  %s \", cgraph_node_name (node));\n \t  fprintf (f, \"-> %s :: \\n\", cgraph_node_name (cs->callee));\n-\t  count = ipa_callsite_param_count (cs);\n+\n+\t  if (ipa_is_called_with_var_arguments (IPA_NODE_REF (cs->callee)))\n+\t    continue;\n+\n+\t  count = ipa_get_cs_argument_count (IPA_EDGE_REF (cs));\n \t  for (i = 0; i < count; i++)\n \t    {\n-\t      jump_func = ipa_callsite_param (cs, i);\n-\t      type = get_type (jump_func);\n+\t      jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+\t      type = jump_func->type;\n \n \t      fprintf (f, \" param %d: \", i);\n-\t      if (type == UNKNOWN_IPATYPE)\n+\t      if (type == IPA_UNKNOWN)\n \t\tfprintf (f, \"UNKNOWN\\n\");\n-\t      else if (type == CONST_IPATYPE || type == CONST_IPATYPE_REF)\n+\t      else if (type == IPA_CONST || type == IPA_CONST_REF)\n \t\t{\n-\t\t  info_type = ipa_jf_get_info_type (jump_func)->value;\n+\t\t  info_type = jump_func->value.constant;\n \t\t  fprintf (f, \"CONST : \");\n \t\t  print_generic_expr (f, info_type, 0);\n \t\t  fprintf (f, \"\\n\");\n \t\t}\n-\t      else if (type == FORMAL_IPATYPE)\n+\t      else if (type == IPA_PASS_THROUGH)\n \t\t{\n-\t\t  fprintf (f, \"FORMAL : \");\n-\t\t  fprintf (f, \"%d\\n\",\n-\t\t\t   ipa_jf_get_info_type (jump_func)->formal_id);\n+\t\t  fprintf (f, \"PASS THROUGH : \");\n+\t\t  fprintf (f, \"%d\\n\", jump_func->value.formal_id);\n \t\t}\n \t    }\n \t}\n@@ -818,8 +830,8 @@ ipcp_structures_print (FILE * f)\n {\n   ipcp_method_cval_print (f);\n   ipcp_method_scale_print (f);\n-  ipa_method_tree_print (f);\n-  ipa_method_modify_print (f);\n+  ipa_print_all_tree_maps (f);\n+  ipa_print_all_params_modified (f);\n   ipcp_callsite_param_print (f);\n }\n \n@@ -842,15 +854,15 @@ ipcp_profile_print (FILE * f)\n    operates according to the flags sent.  PARM_TREE is the \n    formal's tree found to be constant.  CVALUE represents the constant.  */\n static struct ipa_replace_map *\n-ipcp_replace_map_create (struct function *func, enum cvalue_type type,\n-\t\t\t tree parm_tree, union parameter_info *cvalue)\n+ipcp_replace_map_create (struct function *func, enum ipa_lattice_type type,\n+\t\t\t tree parm_tree, tree cvalue)\n {\n   struct ipa_replace_map *replace_map;\n   tree const_val;\n \n   replace_map = XCNEW (struct ipa_replace_map);\n   gcc_assert (ipcp_type_is_const (type));\n-  if (type != CONST_VALUE_REF\n+  if (type != IPA_CONST_VALUE_REF\n       && is_gimple_reg (parm_tree) && gimple_default_def (func, parm_tree)\n \t&& !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (gimple_default_def (func, parm_tree)))\n     {\n@@ -882,21 +894,21 @@ ipcp_redirect (struct cgraph_edge *cs)\n   int i, count;\n   struct ipa_jump_func *jump_func;\n   enum jump_func_type type;\n-  enum cvalue_type cval_type;\n+  enum ipa_lattice_type lattice_type;\n \n   caller = cs->caller;\n   callee = cs->callee;\n   orig_callee = ipcp_method_orig_node (callee);\n-  count = ipa_method_formal_count (orig_callee);\n+  count = ipa_get_param_count (IPA_NODE_REF (orig_callee));\n   for (i = 0; i < count; i++)\n     {\n-      cval_type =\n+      lattice_type =\n \tipcp_cval_get_cvalue_type (ipcp_method_cval (orig_callee, i));\n-      if (ipcp_type_is_const (cval_type))\n+      if (ipcp_type_is_const (lattice_type))\n \t{\n-\t  jump_func = ipa_callsite_param (cs, i);\n-\t  type = get_type (jump_func);\n-\t  if (type != CONST_IPATYPE && type != CONST_IPATYPE_REF)\n+\t  jump_func = ipa_get_ith_jump_func (IPA_EDGE_REF (cs), i);\n+\t  type = jump_func->type;\n+\t  if (type != IPA_CONST && type != IPA_CONST_REF)\n \t    return true;\n \t}\n     }\n@@ -993,23 +1005,24 @@ ipcp_insert_stage (void)\n {\n   struct cgraph_node *node, *node1 = NULL;\n   int i, const_param;\n-  union parameter_info *cvalue;\n+  tree cvalue;\n   VEC (cgraph_edge_p, heap) * redirect_callers;\n   varray_type replace_trees;\n   struct cgraph_edge *cs;\n   int node_callers, count;\n   tree parm_tree;\n-  enum cvalue_type type;\n+  enum ipa_lattice_type type;\n   struct ipa_replace_map *replace_param;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       /* Propagation of the constant is forbidden in \n          certain conditions.  */\n-      if (!node->analyzed || ipcp_method_dont_insert_const (node))\n+      if (!node->analyzed || ipcp_method_dont_insert_const (node)\n+          || ipa_is_called_with_var_arguments (IPA_NODE_REF (node)))\n \tcontinue;\n       const_param = 0;\n-      count = ipa_method_formal_count (node);\n+      count = ipa_get_param_count (IPA_NODE_REF (node));\n       for (i = 0; i < count; i++)\n \t{\n \t  type = ipcp_cval_get_cvalue_type (ipcp_method_cval (node, i));\n@@ -1025,7 +1038,7 @@ ipcp_insert_stage (void)\n \t  if (ipcp_type_is_const (type))\n \t    {\n \t      cvalue = ipcp_cval_get_cvalue (ipcp_method_cval (node, i));\n-\t      parm_tree = ipa_method_get_tree (node, i);\n+\t      parm_tree = ipa_get_ith_param (IPA_NODE_REF (node), i);\n \t      replace_param =\n \t\tipcp_replace_map_create (DECL_STRUCT_FUNCTION (node->decl),\n \t\t\t\t\t type, parm_tree, cvalue);\n@@ -1063,8 +1076,8 @@ ipcp_insert_stage (void)\n \t      if (ipcp_type_is_const (type))\n \t\t{\n \t\t  cvalue = ipcp_cval_get_cvalue (ipcp_method_cval (node, i));\n-\t\t  parm_tree = ipa_method_get_tree (node, i);\n-\t\t  if (type != CONST_VALUE_REF && !is_gimple_reg (parm_tree))\n+\t\t  parm_tree = ipa_get_ith_param (IPA_NODE_REF (node), i);\n+\t\t  if (type != IPA_CONST_VALUE_REF && !is_gimple_reg (parm_tree))\n \t\t    ipcp_propagate_const (node1, i, cvalue, type);\n \t\t}\n \t    }\n@@ -1093,10 +1106,10 @@ ipcp_driver (void)\n {\n   if (dump_file)\n     fprintf (dump_file, \"\\nIPA constant propagation start:\\n\");\n-  ipa_nodes_create ();\n-  ipa_edges_create ();\n+  ipa_create_all_node_params ();\n+  ipa_create_all_edge_args ();\n   /* 1. Call the init stage to initialize \n-     the ipa_node and ipa_edge structures.  */\n+     the ipa_node_params and ipa_edge_args structures.  */\n   ipcp_init_stage ();\n   if (dump_file)\n     {\n@@ -1120,9 +1133,8 @@ ipcp_driver (void)\n       ipcp_profile_print (dump_file);\n     }\n   /* Free all IPCP structures.  */\n-  ipa_free ();\n-  ipa_nodes_free ();\n-  ipa_edges_free ();\n+  ipa_free_all_node_params ();\n+  ipa_free_all_edge_args ();\n   if (dump_file)\n     fprintf (dump_file, \"\\nIPA constant propagation end\\n\");\n   cgraph_remove_unreachable_nodes (true, NULL);"}, {"sha": "f0403634c10001b892ac9d0ad7182f2d53b233fb", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 129, "deletions": 350, "changes": 479, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcd416e3ac292bbbc299721a38d1a2086aaf10ba/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcd416e3ac292bbbc299721a38d1a2086aaf10ba/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=dcd416e3ac292bbbc299721a38d1a2086aaf10ba", "patch": "@@ -31,197 +31,88 @@ along with GCC; see the file COPYING3.  If not see\n #include \"flags.h\"\n #include \"timevar.h\"\n \n-/* This file contains interfaces that can be used for various IPA \n-   optimizations:\n-\n-   - ipa_methodlist interface - It is used to create and handle a temporary \n-   worklist used in  the propagation stage of IPCP. (can be used for more \n-   IPA optimizations).  \n-\n-   - ipa_callsite interface - for each callsite this interface creates and \n-   handles ipa_edge structure associated with it.\n-\n-   - ipa_method interface - for each method this interface creates and \n-   handles ipa_node structure associated with it.  */\n-\n-/* ipa_methodlist interface.  */\n-\n-/* Create a new worklist node.  */\n-static inline ipa_methodlist_p\n-ipa_create_methodlist_node (void)\n-{\n-  return (ipa_methodlist_p) xcalloc (1, sizeof (struct ipa_methodlist));\n-}\n-\n-/* Return true if worklist WL is empty.  */\n-bool\n-ipa_methodlist_not_empty (ipa_methodlist_p wl)\n-{\n-  return (wl != NULL);\n-}\n-\n-/* Return the method in worklist element WL.  */\n-static inline struct cgraph_node *\n-ipa_methodlist_method (ipa_methodlist_p wl)\n-{\n-  return wl->method_p;\n-}\n-\n-/* Make worklist element WL point to method MT in the callgraph.  */\n-static inline void\n-ipa_methodlist_method_set (ipa_methodlist_p wl, struct cgraph_node *mt)\n-{\n-  wl->method_p = mt;\n-}\n-\n-/* Return the next element in the worklist following worklist \n-   element WL.  */\n-static inline ipa_methodlist_p\n-ipa_methodlist_next_method (ipa_methodlist_p wl)\n-{\n-  return wl->next_method;\n-}\n-\n-/* Set worklist element WL1 to point to worklist element WL2.  */\n-static inline void\n-ipa_methodlist_next_method_set (ipa_methodlist_p wl1, ipa_methodlist_p wl2)\n-{\n-  wl1->next_method = wl2;\n-}\n-\n-/* Initialize worklist to contain all methods.  */\n-ipa_methodlist_p\n-ipa_methodlist_init (void)\n+/* Initialize worklist to contain all functions.  */\n+struct ipa_func_list *\n+ipa_init_func_list (void)\n {\n   struct cgraph_node *node;\n-  ipa_methodlist_p wl;\n+  struct ipa_func_list * wl;\n \n   wl = NULL;\n   for (node = cgraph_nodes; node; node = node->next)\n-    ipa_add_method (&wl, node);\n+    ipa_push_func_to_list (&wl, node);\n \n   return wl;\n }\n \n-/* Add method MT to the worklist. Set worklist element WL  \n+/* Add cgraph node MT to the worklist. Set worklist element WL\n    to point to MT.  */\n void\n-ipa_add_method (ipa_methodlist_p * wl, struct cgraph_node *mt)\n+ipa_push_func_to_list (struct ipa_func_list **wl, struct cgraph_node *mt)\n {\n-  ipa_methodlist_p temp;\n+  struct ipa_func_list *temp;\n \n-  temp = ipa_create_methodlist_node ();\n-  ipa_methodlist_method_set (temp, mt);\n-  ipa_methodlist_next_method_set (temp, *wl);\n+  temp = xcalloc (1, sizeof (struct ipa_func_list));\n+  temp->node = mt;\n+  temp->next = *wl;\n   *wl = temp;\n }\n \n-/* Remove a method from the worklist. WL points to the first \n+/* Remove a function from the worklist. WL points to the first\n    element in the list, which is removed.  */\n struct cgraph_node *\n-ipa_remove_method (ipa_methodlist_p * wl)\n+ipa_pop_func_from_list (struct ipa_func_list ** wl)\n {\n-  ipa_methodlist_p first;\n-  struct cgraph_node *return_method;\n+  struct ipa_func_list *first;\n+  struct cgraph_node *return_func;\n \n   first = *wl;\n-  *wl = ipa_methodlist_next_method (*wl);\n-  return_method = ipa_methodlist_method (first);\n+  *wl = (*wl)->next;\n+  return_func = first->node;\n   free (first);\n-  return return_method;\n-}\n-\n-/* ipa_method interface.  */\n-\n-/* Return number of formals of method MT.  */\n-int\n-ipa_method_formal_count (struct cgraph_node *mt)\n-{\n-  return IPA_NODE_REF (mt)->ipa_arg_num;\n-}\n-\n-/* Set number of formals of method MT to I.  */\n-void\n-ipa_method_formal_count_set (struct cgraph_node *mt, int i)\n-{\n-  IPA_NODE_REF (mt)->ipa_arg_num = i;\n-}\n-\n-/* Return whether I-th formal of MT is modified in MT.  */\n-static inline bool\n-ipa_method_is_modified (struct cgraph_node *mt, int i)\n-{\n-  return IPA_NODE_REF (mt)->ipa_mod[i];\n-}\n-\n-/* Return the tree of I-th formal of MT.  */\n-tree\n-ipa_method_get_tree (struct cgraph_node *mt, int i)\n-{\n-  return IPA_NODE_REF (mt)->ipa_param_tree[i];\n+  return return_func;\n }\n \n-/* Create tree map structure for MT.  */\n-static inline void\n-ipa_method_tree_map_create (struct cgraph_node *mt)\n-{\n-  IPA_NODE_REF (mt)->ipa_param_tree =\n-    XCNEWVEC (tree, ipa_method_formal_count (mt));\n-}\n-\n-/* Create modify structure for MT.  */\n-static inline void\n-ipa_method_modify_create (struct cgraph_node *mt)\n-{\n-  ((struct ipa_node *) mt->aux)->ipa_mod =\n-    XCNEWVEC (bool, ipa_method_formal_count (mt));\n-}\n-\n-/* Set modify of I-th formal of MT to VAL.  */\n-static inline void\n-ipa_method_modify_set (struct cgraph_node *mt, int i, bool val)\n-{\n-  IPA_NODE_REF (mt)->ipa_mod[i] = val;\n-}\n-\n-/* Return index of the formal whose tree is PTREE in method MT.  */\n+/* Return index of the formal whose tree is ptree in function which corresponds\n+   to info.  */\n static int\n-ipa_method_tree_map (struct cgraph_node *mt, tree ptree)\n+ipa_get_param_decl_index (struct ipa_node_params *info, tree ptree)\n {\n   int i, count;\n \n-  count = ipa_method_formal_count (mt);\n+  count = ipa_get_param_count (info);\n   for (i = 0; i < count; i++)\n-    if (IPA_NODE_REF (mt)->ipa_param_tree[i] == ptree)\n+    if (ipa_get_ith_param(info, i) == ptree)\n       return i;\n \n   return -1;\n }\n \n-/* Insert the formal trees to the ipa_param_tree array in method MT.  */\n+/* Insert the formal trees to the param_decls array in function MT.  */\n void\n-ipa_method_compute_tree_map (struct cgraph_node *mt)\n+ipa_create_param_decls_array (struct cgraph_node *mt)\n {\n   tree fndecl;\n   tree fnargs;\n   tree parm;\n   int param_num;\n+  struct ipa_node_params *info = IPA_NODE_REF (mt);\n \n-  ipa_method_tree_map_create (mt);\n+  info->param_decls = XCNEWVEC (tree, ipa_get_param_count (info));\n   fndecl = mt->decl;\n   fnargs = DECL_ARGUMENTS (fndecl);\n   param_num = 0;\n   for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n     {\n-      IPA_NODE_REF (mt)->ipa_param_tree[param_num] = parm;\n+      info->param_decls[param_num] = parm;\n       param_num++;\n     }\n }\n \n /* Count number of formals in MT. Insert the result to the \n-   ipa_node.  */\n+   ipa_node_params.  */\n void\n-ipa_method_formal_compute_count (struct cgraph_node *mt)\n+ipa_count_formal_params (struct cgraph_node *mt)\n {\n   tree fndecl;\n   tree fnargs;\n@@ -233,57 +124,48 @@ ipa_method_formal_compute_count (struct cgraph_node *mt)\n   param_num = 0;\n   for (parm = fnargs; parm; parm = TREE_CHAIN (parm))\n     param_num++;\n-  ipa_method_formal_count_set (mt, param_num);\n+  ipa_set_param_count (IPA_NODE_REF (mt), param_num);\n }\n \n-/* Check STMT to detect whether a formal is modified within MT,\n-   the appropriate entry is updated in the ipa_mod array of ipa_node\n-   (associated with MT).  */\n+/* Check STMT to detect whether a formal is modified within MT, the appropriate\n+   entry is updated in the modified_flags array of ipa_node_params (associated\n+   with MT).  */\n static void\n-ipa_method_modify_stmt (struct cgraph_node *mt, tree stmt)\n+ipa_check_stmt_modifications (struct cgraph_node *mt, tree stmt)\n {\n-  int i, j;\n+  int index, j;\n   tree parm_decl;\n+  struct ipa_node_params *info;\n \n   switch (TREE_CODE (stmt))\n     {\n     case GIMPLE_MODIFY_STMT:\n \t  if (TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == PARM_DECL)\n \t{\n+\t  info = IPA_NODE_REF (mt);\n \t  parm_decl = GIMPLE_STMT_OPERAND (stmt, 0);\n-\t  i = ipa_method_tree_map (mt, parm_decl);\n-\t  if (i >= 0)\n-\t    ipa_method_modify_set (mt, i, true);\n+\t  index = ipa_get_param_decl_index (info, parm_decl);\n+\t  if (index >= 0)\n+\t    info->modified_flags[index] = true;\n \t}\n       break;\n     case ASM_EXPR:\n       /* Asm code could modify any of the parameters.  */\n-      for (j = 0; j < ipa_method_formal_count (mt); j++)\n-\tipa_method_modify_set (mt, j, true);\n+      info = IPA_NODE_REF (mt);\n+      for (j = 0; j < ipa_get_param_count (IPA_NODE_REF (mt)); j++)\n+\tinfo->modified_flags[j] = true;\n       break;\n     default:\n       break;\n     }\n }\n \n-/* Initialize ipa_mod array of MT.  */\n-static void\n-ipa_method_modify_init (struct cgraph_node *mt)\n-{\n-  int i, count;\n-\n-  ipa_method_modify_create (mt);\n-  count = ipa_method_formal_count (mt);\n-  for (i = 0; i < count; i++)\n-    ipa_method_modify_set (mt, i, false);\n-}\n-\n /* The modify computation driver for MT. Compute which formal arguments \n-   of method MT are locally modified.  Formals may be modified in MT \n+   of function MT are locally modified.  Formals may be modified in MT\n    if their address is taken, or if\n    they appear on the left hand side of an assignment.  */\n void\n-ipa_method_compute_modify (struct cgraph_node *mt)\n+ipa_detect_param_modifications (struct cgraph_node *mt)\n {\n   tree decl;\n   tree body;\n@@ -292,29 +174,31 @@ ipa_method_compute_modify (struct cgraph_node *mt)\n   struct function *func;\n   block_stmt_iterator bsi;\n   tree stmt, parm_tree;\n+  struct ipa_node_params *info = IPA_NODE_REF (mt);\n \n-  if (ipa_method_formal_count (mt) == 0)\n+  if (ipa_get_param_count (info) == 0)\n     return;\n \n-  ipa_method_modify_init (mt);\n+  count = ipa_get_param_count (info);\n+  info->modified_flags = XCNEWVEC (bool, count);\n   decl = mt->decl;\n-  count = ipa_method_formal_count (mt);\n   /* ??? Handle pending sizes case. Set all parameters \n-     of the method to be modified.  */\n+     of the function to be modified.  */\n \n   if (DECL_UNINLINABLE (decl))\n     {\n       for (j = 0; j < count; j++)\n-\tipa_method_modify_set (mt, j, true);\n+\tinfo->modified_flags[j] = true;\n+\n       return;\n     }\n   /* Formals whose address is taken are considered modified.  */\n   for (j = 0; j < count; j++)\n     {\n-      parm_tree = ipa_method_get_tree (mt, j);\n+      parm_tree = ipa_get_ith_param (info, j);\n       if (!is_gimple_reg (parm_tree) \n \t  && TREE_ADDRESSABLE (parm_tree))\n-\tipa_method_modify_set (mt, j, true);\n+\tinfo->modified_flags[j] = true;\n     }\n   body = DECL_SAVED_TREE (decl);\n   if (body != NULL)\n@@ -325,171 +209,94 @@ ipa_method_compute_modify (struct cgraph_node *mt)\n \tfor (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n \t  {\n \t    stmt = bsi_stmt (bsi);\n-\t    ipa_method_modify_stmt (mt, stmt);\n+\t    ipa_check_stmt_modifications (mt, stmt);\n \t  }\n       }\n     }\n }\n \n-\n-/* ipa_callsite interface.  */\n-\n-/* Return number of arguments in callsite CS.  */\n-int\n-ipa_callsite_param_count (struct cgraph_edge *cs)\n-{\n-  return IPA_EDGE_REF (cs)->ipa_param_num;\n-}\n-\n-/* Set number of arguments in callsite CS to I.  */\n-void\n-ipa_callsite_param_count_set (struct cgraph_edge *cs, int i)\n-{\n-  IPA_EDGE_REF (cs)->ipa_param_num = i;\n-}\n-\n-/* Return the jump function (ipa_jump_func struct) for argument I of \n-   callsite CS.  */\n-struct ipa_jump_func *\n-ipa_callsite_param (struct cgraph_edge *cs, int i)\n-{\n-  return &(IPA_EDGE_REF (cs)->ipa_param_map[i]);\n-}\n-\n-/* return the callee (cgraph_node) of callsite CS.  */\n-struct cgraph_node *\n-ipa_callsite_callee (struct cgraph_edge *cs)\n-{\n-  return cs->callee;\n-}\n-\n-/* Set field 'type' of jump function (ipa_jump_func struct) of argument I \n-   in callsite CS.  */\n-static inline void\n-ipa_callsite_param_set_type (struct cgraph_edge *cs, int i,\n-\t\t\t     enum jump_func_type type1)\n-{\n-  IPA_EDGE_REF (cs)->ipa_param_map[i].type = type1;\n-}\n-\n-/* Set FORMAL as 'info_type' field of jump function (ipa_jump_func struct)\n-   of argument I of callsite CS.  */\n-static inline void\n-ipa_callsite_param_set_info_type_formal (struct cgraph_edge *cs, int i,\n-\t\t\t\t\t unsigned int formal)\n-{\n-  ipa_callsite_param (cs, i)->info_type.formal_id = formal;\n-}\n-\n-/* Set int-valued INFO_TYPE1 as 'info_type' field of \n-   jump function (ipa_jump_func struct) of argument I of callsite CS.  */\n-static inline void\n-ipa_callsite_param_set_info_type (struct cgraph_edge *cs, int i,\n-\t\t\t\t  tree info_type1)\n-{\n-  ipa_callsite_param (cs, i)->info_type.value = info_type1;\n-}\n-\n-/* Allocate space for callsite CS.  */\n-static inline void\n-ipa_callsite_param_map_create (struct cgraph_edge *cs)\n-{\n-  IPA_EDGE_REF (cs)->ipa_param_map =\n-    XCNEWVEC (struct ipa_jump_func, ipa_callsite_param_count (cs));\n-}\n-\n-/* Return the call expr tree related to callsite CS.  */\n-static inline tree\n-ipa_callsite_tree (struct cgraph_edge *cs)\n-{\n-  return cs->call_stmt;\n-}\n-\n-/* Return the caller (cgraph_node) of CS.  */\n-static inline struct cgraph_node *\n-ipa_callsite_caller (struct cgraph_edge *cs)\n-{\n-  return cs->caller;\n-}\n-\n /* Count number of arguments callsite CS has and store it in \n-   ipa_edge structure corresponding to this callsite.  */\n+   ipa_edge_args structure corresponding to this callsite.  */\n void\n-ipa_callsite_compute_count (struct cgraph_edge *cs)\n+ipa_count_arguments (struct cgraph_edge *cs)\n {\n   tree call_tree;\n   int arg_num;\n \n-  call_tree = get_call_expr_in (ipa_callsite_tree (cs));\n+  call_tree = get_call_expr_in (cs->call_stmt);\n   gcc_assert (TREE_CODE (call_tree) == CALL_EXPR);\n   arg_num = call_expr_nargs (call_tree);\n-  ipa_callsite_param_count_set (cs, arg_num);\n+  ipa_set_cs_argument_count (IPA_EDGE_REF (cs), arg_num);\n }\n \n /* Compute jump function for all arguments of callsite CS \n-   and insert the information in the ipa_param_map array \n-   in the ipa_edge corresponding to this callsite. (Explanation \n-   on jump functions is in ipa-prop.h).  */\n+   and insert the information in the jump_functions array\n+   in the ipa_edge_args corresponding to this callsite.  */\n void\n-ipa_callsite_compute_param (struct cgraph_edge *cs)\n+ipa_compute_jump_functions (struct cgraph_edge *cs)\n {\n   tree call_tree;\n   tree arg, cst_decl;\n   int arg_num;\n-  int i;\n   struct cgraph_node *mt;\n   tree parm_decl;\n   struct function *curr_cfun;\n   call_expr_arg_iterator iter;\n+  struct ipa_edge_args *args = IPA_EDGE_REF (cs);\n \n-  if (ipa_callsite_param_count (cs) == 0)\n+  if (ipa_get_cs_argument_count (args) == 0)\n     return;\n-  ipa_callsite_param_map_create (cs);\n-  call_tree = get_call_expr_in (ipa_callsite_tree (cs));\n+  args->jump_functions = XCNEWVEC (struct ipa_jump_func,\n+\t\t\t\t   ipa_get_cs_argument_count (args));\n+  call_tree = get_call_expr_in (cs->call_stmt);\n   gcc_assert (TREE_CODE (call_tree) == CALL_EXPR);\n   arg_num = 0;\n \n   FOR_EACH_CALL_EXPR_ARG (arg, iter, call_tree)\n     {\n       /* If the formal parameter was passed as argument, we store \n-         FORMAL_IPATYPE and its index in the caller as the jump function \n+         IPA_PASS_THROUGH and its index in the caller as the jump function\n          of this argument.  */\n       if ((TREE_CODE (arg) == SSA_NAME\n \t   && TREE_CODE (SSA_NAME_VAR (arg)) == PARM_DECL)\n \t  || TREE_CODE (arg) == PARM_DECL)\n \t{\n-\t  mt = ipa_callsite_caller (cs);\n+\t  struct ipa_node_params *info;\n+\t  int index;\n+\n+\t  mt = cs->caller;\n+\t  info = IPA_NODE_REF (mt);\n \t  parm_decl = TREE_CODE (arg) == PARM_DECL ? arg : SSA_NAME_VAR (arg);\n           \n-\t  i = ipa_method_tree_map (mt, parm_decl);\n-\t  if (TREE_CODE (arg) == SSA_NAME && IS_VALID_TREE_MAP_INDEX (i)) \n+\t  index = ipa_get_param_decl_index (info, parm_decl);\n+\t  if (TREE_CODE (arg) == SSA_NAME && IS_VALID_JUMP_FUNC_INDEX (index))\n \t    {\n \t      curr_cfun = DECL_STRUCT_FUNCTION (mt->decl);\n \t      if (!gimple_default_def (curr_cfun, parm_decl) \n \t          || gimple_default_def (curr_cfun, parm_decl) != arg)\n-\t\t    ipa_method_modify_set (mt, i, true); \n+\t\tinfo->modified_flags[index] = true;\n \t    }\n-\t  if (!IS_VALID_TREE_MAP_INDEX (i) || ipa_method_is_modified (mt, i))\n-\t    ipa_callsite_param_set_type (cs, arg_num, UNKNOWN_IPATYPE);\n+\t  if (!IS_VALID_JUMP_FUNC_INDEX (index) || info->modified_flags[index])\n+\t    args->jump_functions[arg_num].type = IPA_UNKNOWN;\n \t  else\n \t    {\n-\t      ipa_callsite_param_set_type (cs, arg_num, FORMAL_IPATYPE);\n-\t      ipa_callsite_param_set_info_type_formal (cs, arg_num, i);\n+\t      args->jump_functions[arg_num].type = IPA_PASS_THROUGH;\n+\t      args->jump_functions[arg_num].value.formal_id = index;\n \t    }\n \t}\n       /* If a constant value was passed as argument, \n-         we store CONST_IPATYPE and its value as the jump function \n+         we store IPA_CONST and its value as the jump function\n          of this argument.  */\n       else if (TREE_CODE (arg) == INTEGER_CST\n \t       || TREE_CODE (arg) == REAL_CST\n \t       || TREE_CODE (arg) == FIXED_CST)\n \t{\n-\t  ipa_callsite_param_set_type (cs, arg_num, CONST_IPATYPE);\n-\t  ipa_callsite_param_set_info_type (cs, arg_num, arg);\n+\t  args->jump_functions[arg_num].type = IPA_CONST;\n+\t  args->jump_functions[arg_num].value.constant = arg;\n \t}\n       /* This is for the case of Fortran. If the address of a const_decl \n-         was passed as argument then we store \n-         CONST_IPATYPE_REF/CONST_IPATYPE_REF and the constant \n+         was passed as argument then we store\n+         IPA_CONST_REF/IPA_CONST_REF and the constant\n          value as the jump function corresponding to this argument.  */\n       else if (TREE_CODE (arg) == ADDR_EXPR\n \t       && TREE_CODE (TREE_OPERAND (arg, 0)) == CONST_DECL)\n@@ -499,121 +306,90 @@ ipa_callsite_compute_param (struct cgraph_edge *cs)\n \t      || TREE_CODE (DECL_INITIAL (cst_decl)) == REAL_CST\n \t      || TREE_CODE (DECL_INITIAL (cst_decl)) == FIXED_CST)\n \t    {\n-\t      ipa_callsite_param_set_type (cs, arg_num,\n-\t\t\t\t\t   CONST_IPATYPE_REF);\n-\t      ipa_callsite_param_set_info_type (cs, arg_num,\n-\t\t\t\t\t\tDECL_INITIAL (cst_decl));\n+\t      args->jump_functions[arg_num].type = IPA_CONST_REF;\n+\t      args->jump_functions[arg_num].value.constant = cst_decl;\n \t    }\n \t}\n       else\n-\tipa_callsite_param_set_type (cs, arg_num, UNKNOWN_IPATYPE);\n+\targs->jump_functions[arg_num].type = IPA_UNKNOWN;\n       arg_num++;\n     }\n }\n \n-/* Return type of jump function JF.  */\n-enum jump_func_type\n-get_type (struct ipa_jump_func *jf)\n-{\n-  return jf->type;\n-}\n-\n-/* Return info type of jump function JF.  */\n-union parameter_info *\n-ipa_jf_get_info_type (struct ipa_jump_func *jf)\n-{\n-  return &(jf->info_type);\n-}\n-\n-/* Allocate and initialize ipa_node structure.  \n-   cgraph_node NODE points to the new allocated ipa_node.  */\n+/* Allocate and initialize ipa_node_params structure for the given cgraph\n+   node.  */\n void\n-ipa_node_create (struct cgraph_node *node)\n+ipa_create_node_params (struct cgraph_node *node)\n {\n-  node->aux = xcalloc (1, sizeof (struct ipa_node));\n+  node->aux = xcalloc (1, sizeof (struct ipa_node_params));\n }\n \n-/* Allocate and initialize ipa_node structure for all\n+/* Allocate and initialize ipa_node_params structure for all\n    nodes in callgraph.  */\n void\n-ipa_nodes_create (void)\n+ipa_create_all_node_params (void)\n {\n   struct cgraph_node *node;\n \n   for (node = cgraph_nodes; node; node = node->next)\n-    ipa_node_create (node);\n+    ipa_create_node_params (node);\n }\n \n /* Allocate and initialize ipa_edge structure.  */\n void\n-ipa_edges_create (void)\n+ipa_create_all_edge_args (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *cs;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     for (cs = node->callees; cs; cs = cs->next_callee)\n-      cs->aux = xcalloc (1, sizeof (struct ipa_edge));\n-}\n-\n-/* Free ipa_node structure.  */\n-void\n-ipa_nodes_free (void)\n-{\n-  struct cgraph_node *node;\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      free (node->aux);\n-      node->aux = NULL;\n-    }\n+      cs->aux = xcalloc (1, sizeof (struct ipa_edge_args));\n }\n \n /* Free ipa_edge structure.  */\n void\n-ipa_edges_free (void)\n+ipa_free_all_edge_args (void)\n {\n   struct cgraph_node *node;\n   struct cgraph_edge *cs;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     for (cs = node->callees; cs; cs = cs->next_callee)\n-      {\n-\tfree (cs->aux);\n-\tcs->aux = NULL;\n-      }\n+      if (cs->aux)\n+\t{\n+\t  if (IPA_EDGE_REF (cs)->jump_functions)\n+\t    free (IPA_EDGE_REF (cs)->jump_functions);\n+\t  free (cs->aux);\n+\t  cs->aux = NULL;\n+\t}\n }\n \n-/* Free ipa data structures of ipa_node and ipa_edge.  */\n+/* Free ipa data structures of ipa_node_params and ipa_edge_args.  */\n void\n-ipa_free (void)\n+ipa_free_all_node_params (void)\n {\n   struct cgraph_node *node;\n-  struct cgraph_edge *cs;\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       if (node->aux == NULL)\n \tcontinue;\n-      if (IPA_NODE_REF (node)->ipcp_cval)\n-\tfree (IPA_NODE_REF (node)->ipcp_cval);\n-      if (IPA_NODE_REF (node)->ipa_param_tree)\n-\tfree (IPA_NODE_REF (node)->ipa_param_tree);\n-      if (IPA_NODE_REF (node)->ipa_mod)\n-\tfree (IPA_NODE_REF (node)->ipa_mod);\n-      for (cs = node->callees; cs; cs = cs->next_callee)\n-\t{\n-\t  if (cs->aux)\n-\t    if (IPA_EDGE_REF (cs)->ipa_param_map)\n-\t      free (IPA_EDGE_REF (cs)->ipa_param_map);\n-\t}\n+      if (IPA_NODE_REF (node)->ipcp_lattices)\n+\tfree (IPA_NODE_REF (node)->ipcp_lattices);\n+      if (IPA_NODE_REF (node)->param_decls)\n+\tfree (IPA_NODE_REF (node)->param_decls);\n+      if (IPA_NODE_REF (node)->modified_flags)\n+\tfree (IPA_NODE_REF (node)->modified_flags);\n+      free (node->aux);\n+      node->aux = NULL;\n     }\n }\n \n-/* Print ipa_tree_map data structures of all methods in the \n+/* Print ipa_tree_map data structures of all functions in the\n    callgraph to F.  */\n void\n-ipa_method_tree_print (FILE * f)\n+ipa_print_all_tree_maps (FILE * f)\n {\n   int i, count;\n   tree temp;\n@@ -622,11 +398,12 @@ ipa_method_tree_print (FILE * f)\n   fprintf (f, \"\\nPARAM TREE MAP PRINT\\n\");\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      fprintf (f, \"method  %s Trees :: \\n\", cgraph_node_name (node));\n-      count = ipa_method_formal_count (node);\n+      struct ipa_node_params *info = IPA_NODE_REF (node);\n+      fprintf (f, \"function  %s Trees :: \\n\", cgraph_node_name (node));\n+      count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n-\t  temp = ipa_method_get_tree (node, i);\n+\t  temp = ipa_get_ith_param (info, i);\n \t  if (TREE_CODE (temp) == PARM_DECL)\n \t    fprintf (f, \"  param [%d] : %s\\n\", i,\n \t\t     (*lang_hooks.decl_printable_name) (temp, 2));\n@@ -635,10 +412,10 @@ ipa_method_tree_print (FILE * f)\n     }\n }\n \n-/* Print ipa_modify data structures of all methods in the \n+/* Print modified_flags data structures of all functions in the\n    callgraph to F.  */\n void\n-ipa_method_modify_print (FILE * f)\n+ipa_print_all_params_modified (FILE * f)\n {\n   int i, count;\n   bool temp;\n@@ -647,15 +424,17 @@ ipa_method_modify_print (FILE * f)\n   fprintf (f, \"\\nMODIFY PRINT\\n\");\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      fprintf (f, \"method  %s :: \\n\", cgraph_node_name (node));\n-      count = ipa_method_formal_count (node);\n+      struct ipa_node_params *info = IPA_NODE_REF (node);\n+      fprintf (f, \"function  %s :: \\n\", cgraph_node_name (node));\n+      count = ipa_get_param_count (info);\n       for (i = 0; i < count; i++)\n \t{\n-\t  temp = ipa_method_is_modified (node, i);\n+\t  temp = info->modified_flags[i];\n \t  if (temp)\n \t    fprintf (f, \" param [%d] true \\n\", i);\n \t  else\n \t    fprintf (f, \" param [%d] false \\n\", i);\n \t}\n     }\n }\n+"}, {"sha": "3be7502ae8c16c86d4aaa02658cf2117404805ea", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 158, "deletions": 97, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dcd416e3ac292bbbc299721a38d1a2086aaf10ba/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dcd416e3ac292bbbc299721a38d1a2086aaf10ba/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=dcd416e3ac292bbbc299721a38d1a2086aaf10ba", "patch": "@@ -30,43 +30,42 @@ along with GCC; see the file COPYING3.  If not see\n    Formal - the caller's formal parameter is passed as an actual argument.\n    Constant - a constant is passed as an actual argument.\n    Unknown - neither of the above.\n-   Integer and real constants are represented as CONST_IPATYPE and Fortran \n-   constants are represented as CONST_IPATYPE_REF.  */\n+   Integer and real constants are represented as IPA_CONST and Fortran\n+   constants are represented as IPA_CONST_REF.  */\n enum jump_func_type\n {\n-  UNKNOWN_IPATYPE,\n-  CONST_IPATYPE,\n-  CONST_IPATYPE_REF,\n-  FORMAL_IPATYPE\n+  IPA_UNKNOWN,\n+  IPA_CONST,\n+  IPA_CONST_REF,\n+  IPA_PASS_THROUGH\n };\n \n-/* All formal parameters in the program have a cval computed by \n-   the interprocedural stage of IPCP.  \n-   There are three main values of cval :\n+/* All formal parameters in the program have a lattice associated with it\n+   computed by the interprocedural stage of IPCP.\n+   There are three main values of the lattice:\n    TOP - unknown.\n    BOTTOM - non constant.\n    CONSTANT_TYPE - constant value.\n    Cval of formal f will have a constant value if all callsites to this\n    function have the same constant value passed to f.\n-   Integer and real constants are represented as CONST_IPATYPE and Fortran\n-   constants are represented as CONST_IPATYPE_REF.  */\n-enum cvalue_type\n-{\n-  BOTTOM,\n-  CONST_VALUE,\n-  CONST_VALUE_REF,\n-  TOP\n+   Integer and real constants are represented as IPA_CONST and Fortran\n+   constants are represented as IPA_CONST_REF.  */\n+enum ipa_lattice_type\n+{\n+  IPA_BOTTOM,\n+  IPA_CONST_VALUE,\n+  IPA_CONST_VALUE_REF,\n+  IPA_TOP\n };\n \n-/* Represents the value of either jump function or cval.\n+/* Represents a value of a jump function.\n    value represents a constant.\n    formal_id is used only in jump function context and represents \n-   pass-through parameter (the formal of caller is passed \n-   as argument).  */\n-union parameter_info\n+   pass-through parameter (the formal of caller is passed as argument).  */\n+union jump_func_value\n {\n   unsigned int formal_id;\n-  tree value;\n+  tree constant;\n };\n \n /* A jump function for a callsite represents the values passed as actual \n@@ -75,16 +74,16 @@ union parameter_info\n struct ipa_jump_func\n {\n   enum jump_func_type type;\n-  union parameter_info info_type;\n+  union jump_func_value value;\n };\n \n /* All formal parameters in the program have a cval computed by \n-   the interprocedural stage of IPCP. See enum cvalue_type for \n-   the various types of cvals supported */\n-struct ipcp_formal\n+   the interprocedural stage of IPCP. See enum ipa_lattice_type for\n+   the various types of lattices supported */\n+struct ipcp_lattice\n {\n-  enum cvalue_type cval_type;\n-  union parameter_info cvalue;\n+  enum ipa_lattice_type type;\n+  tree constant;\n };\n \n /* Represent which DECL tree (or reference to such tree)\n@@ -102,103 +101,165 @@ struct ipa_replace_map\n };\n \n /* Return the field in cgraph_node/cgraph_edge struct that points\n-   to ipa_node/ipa_edge struct.  */\n-#define IPA_NODE_REF(MT) ((struct ipa_node *)(MT)->aux)\n-#define IPA_EDGE_REF(EDGE) ((struct ipa_edge *)(EDGE)->aux)\n+   to ipa_node_params/ipa_edge_args struct.  */\n+#define IPA_NODE_REF(MT) ((struct ipa_node_params *)(MT)->aux)\n+#define IPA_EDGE_REF(EDGE) ((struct ipa_edge_args *)(EDGE)->aux)\n /* This macro checks validity of index returned by\n-   ipa_method_tree_map function.  */\n-#define IS_VALID_TREE_MAP_INDEX(I) ((I) != -1)\n+   ipa_get_param_decl_index function.  */\n+#define IS_VALID_JUMP_FUNC_INDEX(I) ((I) != -1)\n \n-/* ipa_node stores information related to a method and\n-   its formal parameters. It is pointed to by a field in the\n-   method's corresponding cgraph_node.\n+/* ipa_node_params stores information related to formal parameters of functions\n+   and some other information for interprocedural passes that operate on\n+   parameters (such as ipa-cp).  */\n \n-   ipa_edge stores information related to a callsite and\n-   its arguments. It is pointed to by a field in the\n-   callsite's corresponding cgraph_edge.  */\n-struct ipa_node\n+struct ipa_node_params\n {\n-  /* Number of formal parameters of this method.  When set to 0,\n-     this method's parameters would not be analyzed by the different\n+  /* Number of formal parameters of this function.  When set to 0,\n+     this functions's parameters would not be analyzed by the different\n      stages of IPA CP.  */\n-  int ipa_arg_num;\n-  /* Array of cvals.  */\n-  struct ipcp_formal *ipcp_cval;\n+  int param_count;\n+  /* Array of lattices.  */\n+  struct ipcp_lattice *ipcp_lattices;\n   /* Mapping each parameter to its PARM_DECL tree.  */\n-  tree *ipa_param_tree;\n-  /* Indicating which parameter is modified in its method.  */\n-  bool *ipa_mod;\n+  tree *param_decls;\n+  /* Indicating which parameter is modified in its function.  */\n+  bool *modified_flags;\n   /* Only for versioned nodes this field would not be NULL,\n      it points to the node that IPA cp cloned from.  */\n   struct cgraph_node *ipcp_orig_node;\n-  /* Meaningful only for original methods.  Expresses the \n+  /* Meaningful only for original functions.  Expresses the\n      ratio between the direct calls and sum of all invocations of \n      this function (given by profiling info).  It is used to calculate \n      the profiling information of the original function and the versioned\n      one.  */\n   gcov_type count_scale;\n+\n+  /* Whether this fynction is called with variable number of actual\n+     arguments.  */\n+  unsigned called_with_var_arguments : 1;\n };\n \n-struct ipa_edge\n+/* ipa_node_params access functions.  Please use these to access fields that\n+   are or will be shared among various passes.  */\n+\n+/* Set the number of formal parameters. */\n+static inline void\n+ipa_set_param_count (struct ipa_node_params *info, int count)\n+{\n+  info->param_count = count;\n+}\n+\n+/* Return the number of formal parameters. */\n+static inline int\n+ipa_get_param_count (struct ipa_node_params *info)\n+{\n+  return info->param_count;\n+}\n+\n+/* Returns the declaration of ith param of the corresponding node.  Note there\n+   is no setter function as this array is built just once using\n+   ipa_create_param_decls_array. */\n+static inline tree\n+ipa_get_ith_param (struct ipa_node_params *info, int i)\n+{\n+  return info->param_decls[i];\n+}\n+\n+/* Returns the modification flag corresponding o the ith paramterer.  Note\n+   there is no setter method as the goal is to set all flags when building the\n+   array in ipa_detect_param_modifications.  */\n+static inline bool\n+ipa_is_ith_param_modified (struct ipa_node_params *info, int i)\n+{\n+  return info->modified_flags[i];\n+}\n+\n+/* Flag this node as having callers with variable number of arguments.  */\n+static inline void\n+ipa_set_called_with_variable_arg (struct ipa_node_params *info)\n+{\n+  info->called_with_var_arguments = 1;\n+}\n+\n+/* Have we detected this node was called with variable number of arguments? */\n+static inline bool\n+ipa_is_called_with_var_arguments (struct ipa_node_params *info)\n+{\n+  return info->called_with_var_arguments;\n+}\n+\n+\n+\n+/* ipa_edge_args stores information related to a callsite and particularly\n+   its arguments. It is pointed to by a field in the\n+   callsite's corresponding cgraph_edge.  */\n+struct ipa_edge_args\n {\n   /* Number of actual arguments in this callsite.  When set to 0,\n      this callsite's parameters would not be analyzed by the different\n      stages of IPA CP.  */\n-  int ipa_param_num;\n+  int argument_count;\n   /* Array of the callsite's jump function of each parameter.  */\n-  struct ipa_jump_func *ipa_param_map;\n+  struct ipa_jump_func *jump_functions;\n };\n \n-/* A methodlist element (referred to also as methodlist node). It is used \n-   to create a temporary worklist used in \n-   the propagation stage of IPCP. (can be used for more IPA \n-   optimizations)  */\n-struct ipa_methodlist\n+/* ipa_edge_args access functions.  Please use these to access fields that\n+   are or will be shared among various passes.  */\n+\n+/* Set the number of actual arguments. */\n+static inline void\n+ipa_set_cs_argument_count (struct ipa_edge_args *args, int count)\n {\n-  struct cgraph_node *method_p;\n-  struct ipa_methodlist *next_method;\n+  args->argument_count = count;\n+}\n+\n+/* Return the number of actual arguments. */\n+static inline int\n+ipa_get_cs_argument_count (struct ipa_edge_args *args)\n+{\n+  return args->argument_count;\n+}\n+\n+/* Returns a pointer to the jump function for the ith argument.  Please note\n+   there is no setter function as jump functions are all set up in\n+   ipa_compute_jump_functions. */\n+static inline struct ipa_jump_func *\n+ipa_get_ith_jump_func (struct ipa_edge_args *args, int i)\n+{\n+  return &args->jump_functions[i];\n+}\n+\n+/* A function list element.  It is used to create a temporary worklist used in\n+   the propagation stage of IPCP. (can be used for more IPA optimizations)  */\n+struct ipa_func_list\n+{\n+  struct cgraph_node *node;\n+  struct ipa_func_list *next;\n };\n \n-/* A pointer to a methodlist element.  */\n-typedef struct ipa_methodlist *ipa_methodlist_p;\n-\n-/* ipa_methodlist interface.  */\n-ipa_methodlist_p ipa_methodlist_init (void);\n-bool ipa_methodlist_not_empty (ipa_methodlist_p);\n-void ipa_add_method (ipa_methodlist_p *, struct cgraph_node *);\n-struct cgraph_node *ipa_remove_method (ipa_methodlist_p *);\n-\n-/* ipa_callsite interface.  */\n-int ipa_callsite_param_count (struct cgraph_edge *);\n-void ipa_callsite_param_count_set (struct cgraph_edge *, int);\n-struct ipa_jump_func *ipa_callsite_param (struct cgraph_edge *, int);\n-struct cgraph_node *ipa_callsite_callee (struct cgraph_edge *);\n-void ipa_callsite_compute_param (struct cgraph_edge *);\n-void ipa_callsite_compute_count (struct cgraph_edge *);\n-\n-/* ipa_method interface.  */\n-int ipa_method_formal_count (struct cgraph_node *);\n-void ipa_method_formal_count_set (struct cgraph_node *, int);\n-tree ipa_method_get_tree (struct cgraph_node *, int);\n-void ipa_method_compute_tree_map (struct cgraph_node *);\n-void ipa_method_formal_compute_count (struct cgraph_node *);\n-void ipa_method_compute_modify (struct cgraph_node *);\n-\n-/* jump function interface.  */\n-enum jump_func_type get_type (struct ipa_jump_func *);\n-union parameter_info *ipa_jf_get_info_type (struct ipa_jump_func *);\n-\n-/* ipa_node and ipa_edge interfaces.  */\n-void ipa_node_create (struct cgraph_node *);\n-void ipa_free (void);\n-void ipa_nodes_create (void);\n-void ipa_edges_create (void);\n-void ipa_edges_free (void);\n-void ipa_nodes_free (void);\n+/* ipa_func_list interface.  */\n+struct ipa_func_list *ipa_init_func_list (void);\n+void ipa_push_func_to_list (struct ipa_func_list **, struct cgraph_node *);\n+struct cgraph_node *ipa_pop_func_from_list (struct ipa_func_list **);\n+\n+/* Callsite related calculations.  */\n+void ipa_compute_jump_functions (struct cgraph_edge *);\n+void ipa_count_arguments (struct cgraph_edge *);\n+\n+/* Function parameters related computations.  */\n+void ipa_count_formal_params (struct cgraph_node *);\n+void ipa_create_param_decls_array (struct cgraph_node *);\n+void ipa_detect_param_modifications (struct cgraph_node *);\n \n+/* Creating and freeing ipa_node_params and ipa_edge_args.  */\n+void ipa_create_node_params (struct cgraph_node *);\n+void ipa_free_all_node_params (void);\n+void ipa_create_all_node_params (void);\n+void ipa_create_all_edge_args (void);\n+void ipa_free_all_edge_args (void);\n \n /* Debugging interface.  */\n-void ipa_method_tree_print (FILE *);\n-void ipa_method_modify_print (FILE *);\n+void ipa_print_all_tree_maps (FILE *);\n+void ipa_print_all_params_modified (FILE *);\n \n #endif /* IPA_PROP_H */"}]}