{"sha": "f82eca4d69a0de0717974aa307d57f9afa369410", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjgyZWNhNGQ2OWEwZGUwNzE3OTc0YWEzMDdkNTdmOWFmYTM2OTQxMA==", "commit": {"author": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1993-03-04T18:02:42Z"}, "committer": {"name": "Steve Chamberlain", "email": "sac@gnu.org", "date": "1993-03-04T18:02:42Z"}, "message": "New File.\n\nFrom-SVN: r3630", "tree": {"sha": "be442e3371e45a9d3e6681a1d245791a4f0b51cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/be442e3371e45a9d3e6681a1d245791a4f0b51cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f82eca4d69a0de0717974aa307d57f9afa369410", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82eca4d69a0de0717974aa307d57f9afa369410", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f82eca4d69a0de0717974aa307d57f9afa369410", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f82eca4d69a0de0717974aa307d57f9afa369410/comments", "author": null, "committer": null, "parents": [{"sha": "43517f90eeb10012cc765bfd8759b0d3bb41cacd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43517f90eeb10012cc765bfd8759b0d3bb41cacd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43517f90eeb10012cc765bfd8759b0d3bb41cacd"}], "stats": {"total": 1322, "additions": 1322, "deletions": 0}, "files": [{"sha": "55b4a5ebd5fd9e30a8fe4c4020a4e2bd2c88d7c4", "filename": "gcc/config/h8300/h8300.md", "status": "added", "additions": 1322, "deletions": 0, "changes": 1322, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f82eca4d69a0de0717974aa307d57f9afa369410/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f82eca4d69a0de0717974aa307d57f9afa369410/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=f82eca4d69a0de0717974aa307d57f9afa369410", "patch": "@@ -0,0 +1,1322 @@\n+;;- Machine description for the Hitachi H8/300 for the GNU C compiler\n+;;   Copyright (C) 1992, 1993 Free Software Foundation, Inc.\n+\n+;; This file is part of GNU CC.\n+\n+;; GNU CC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GNU CC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GNU CC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n+\n+\n+;; The original PO technology requires these to be ordered by speed,\n+;; so that assigner will pick the fastest.\n+\n+;; See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n+\n+(define_attr \"type\" \"branch,return,call,arith,move,float,multi\"\n+  (const_string \"arith\"))\n+\n+;; The size of instructions in bytes.\n+\n+(define_attr \"length\" \"\" \n+  (cond [(eq_attr \"type\" \"branch\")\n+\t (if_then_else (and (ge (minus (pc) (match_dup 0))\n+\t\t\t\t(const_int -128))\n+\t\t\t    (le (minus (pc) (match_dup 0))\n+\t\t\t\t(const_int 128)))\n+\t\t       (const_int 2)\n+\t\t       (const_int 6))\n+\t (eq_attr \"type\" \"move\")\t(const_int 4)\n+\t (eq_attr \"type\" \"return\")\t(const_int 2)\n+\t (eq_attr \"type\" \"float\")\t(const_int 12)\n+\t (eq_attr \"type\" \"call\")\t(const_int 4)]\n+\t(const_int 200)))\n+\n+\n+(define_attr \"cc\" \"none,clobber,none_0hit,set,compare,whoops\" \n+  (const_string \"whoops\"))\n+\f\n+;; ----------------------------------------------------------------------\n+;; move instructions\n+;; ----------------------------------------------------------------------\n+\n+;; movhi\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"push_operand\" \"=<\")\n+\t(match_operand:HI 1 \"register_operand\" \"ra\"))]\n+  \"\"\n+  \"mov.w\t%T1,%T0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"movstricthi\"\n+  [(set (strict_low_part (match_operand:HI 0 \"general_operand_dst\" \"=r,r,r,o,<\"))\n+\t(match_operand:HI 1 \"general_operand_src\" \"I,r,io,r,r\"))]\n+  \"\"\n+  \"@\n+   sub.w\t%T0,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"2,2,4,4,2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"general_operand_dst\" \"=ra,ra,ra,o,<\")\n+\t(match_operand:HI 1 \"general_operand_src\" \"I,ra,ion,ra,ra\"))]\n+  \"\"\n+  \"@\n+   sub.w\t%T0,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\n+   mov.w\t%T1,%T0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"2,2,4,4,2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_expand \"movhi\"\n+  [(set (match_operand:HI 0 \"general_operand_dst\" \"\")\n+\t(match_operand:HI 1 \"general_operand_src\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register.  */\n+  if (! register_operand (operand1, HImode)\n+      && ! register_operand (operand0, HImode))\n+    operands[1] = copy_to_mode_reg (HImode, operand1);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&ra\")\n+\t(plus:HI (match_operand:HI 1 \"general_operand_src\" \"g\")\n+\t\t (match_operand:HI 2 \"register_operand\" \"ra\")))]\n+  \"\"\n+  \"mov.w\t%T1,%T0\\;add.w\t%T2,%T0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"set\")])\n+\n+;; movqi\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"push_operand\" \"=<\")\n+\t(match_operand:QI 1 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"mov.w\t%T1,%T0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"movstrictqi\"\n+  [(set (strict_low_part (match_operand:QI 0 \"general_operand_dst\" \"=r,r,r,o,<\"))\n+\t(match_operand:QI 1 \"general_operand_src\" \"I,r,io,r,r\"))]\n+  \"\"\n+  \"@\n+   sub.b\t%X0,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"2,2,4,4,2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:QI 0 \"general_operand_dst\" \"=r,r,r,o,<\")\n+\t(match_operand:QI 1 \"general_operand_src\" \"I,r,io,r,r\"))]\n+  \"\"\n+  \"@\n+   sub.b\t%X0,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\n+   mov.b\t%X1,%X0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"2,2,4,4,2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_expand \"movqi\"\n+  [(set (match_operand:QI 0 \"general_operand_dst\" \"\")\n+\t(match_operand:QI 1 \"general_operand_src\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  /* One of the ops has to be in a register.  */\n+  if (! register_operand (operand0, QImode)\n+      && ! register_operand (operand1, QImode))\n+    operands[1] = copy_to_mode_reg (QImode, operand1);\n+}\")\n+\n+;; movsi\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"general_operand_dst\" \"=l,l,l,o,<\")\n+\t(match_operand:SI 1 \"general_operand_src\" \"I,l,ion,l,l\"))]\n+  \"\"\n+  \"*\n+{\n+  int rn = -1;\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"sub.w\t%e0,%e0\\;sub.w\t%f0,%f0\\\";\n+    case 1:\n+      return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+    case 2:\n+      /* Make sure we don't trample the register we index with.  */\n+    \n+      if (GET_CODE (operands[1]) == MEM) \n+\t{\n+\t  rtx inside = XEXP (operands[1], 0);\n+\t  if (REG_P (inside))\n+\t    rn = REGNO (inside);\n+\t  else if (GET_CODE (inside) == PLUS) \n+\t    {\n+\t      rtx lhs = XEXP (inside, 0);\n+\t      rtx rhs = XEXP (inside, 1);\n+\t      if (REG_P (lhs))\n+\t\trn = REGNO (lhs);\n+\t      if (REG_P (rhs))\n+\t\trn = REGNO (rhs);\n+\t    }\n+\t}\n+      if (rn == REGNO (operands[0]))\n+\t/* Move the second word first.  */\n+\treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n+      else \n+\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+    \n+    case 3:\n+      return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+    case 4:\n+      return \\\"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\\\";\n+    }\n+}\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4,4,8,8,4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"push_operand\" \"=<\")\n+\t(match_operand:SI 1 \"register_operand\" \"l\"))]\n+  \"\"\n+  \"mov.w      %f1,%T0\\;mov.w\t%e1,%T0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand_dst\" \"\")\n+\t(match_operand:SI 1 \"general_operand_src\" \"\"))]\n+  \"\"\t\t\t\t\t\n+  \"if (domovsi (operands)) DONE;\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"general_operand_dst\" \"=l,l,l,o,<\")\n+\t(match_operand:SF 1 \"general_operand_src\" \"I,l,ion,l,l\"))]\n+  \"\"\n+  \"*\n+{\n+  /* This is a copy of the movsi stuff.  */\n+  int rn = -1;\n+  switch (which_alternative)\n+    {\n+    case 0:\n+      return \\\"sub.w\t%e0,%e0\\;sub.w\t%f0,%f0\\\";\n+    case 1:\n+      return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+    case 2:\n+      /* Make sure we don't trample the register we index with.  */\n+    \n+      if (GET_CODE (operands[1]) == MEM) \n+\t{\n+\t  rtx inside = XEXP (operands[1], 0);\n+\t  if (REG_P (inside))\n+\t    rn = REGNO (inside);\n+\t  else if (GET_CODE (inside) == PLUS) \n+\t    {\n+\t      rtx lhs = XEXP (inside, 0);\n+\t      rtx rhs = XEXP (inside, 1);\n+\t      if (REG_P (lhs))\n+\t\trn = REGNO (lhs);\n+\t      if (REG_P (rhs))\n+\t\trn = REGNO (rhs);\n+\t    }\n+\t}\n+      if (rn == REGNO (operands[0]))\n+\t/* Move the second word first.  */\n+\treturn \\\"mov.w\t%f1,%f0\\;mov.w\t%e1,%e0\\\";\n+      else \n+\treturn \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+    \n+    case 3:\n+      return \\\"mov.w\t%e1,%e0\\;mov.w\t%f1,%f0\\\";\n+    case 4:\n+      return \\\"mov.w\t%f1,%T0\\;mov.w\t%e1,%T0\\\";\n+   }\n+}\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4,4,8,8,4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"push_operand\" \"=<\")\n+\t(match_operand:SF 1 \"register_operand\" \"l\"))]\n+  \"\"\n+  \"mov.w      %f1,%T0\\;mov.w\t%e1,%T0\"\n+  [(set_attr \"type\" \"move\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"movsf\"\n+  [(set (match_operand:SF 0 \"general_operand_dst\" \"\")\n+\t(match_operand:SF 1 \"general_operand_src\" \"\"))]\n+  \"\"\t\t\t\t\t\n+  \"if (domovsi (operands)) DONE;\")\n+\n+;; Block move\n+\n+(define_expand \"movstrhi\"\n+  [(parallel [(set (mem:BLK (match_operand:BLK 0 \"general_operand\" \"\"))\n+\t\t   (mem:BLK (match_operand:BLK 1 \"general_operand\" \"\")))\n+\t      (use (match_operand:HI 2 \"general_operand\" \"\"))\n+\t      (use (match_operand:HI 3 \"immediate_operand\" \"\"))\n+\t      (clobber (match_dup 3))\n+\t      ])]\n+  \"\"\n+  \"\n+{\n+  rtx src_ptr = copy_to_mode_reg (Pmode, XEXP (operands[1], 0));\n+  rtx dst_ptr = copy_to_mode_reg (Pmode, XEXP (operands[0], 0));\n+\n+  enum machine_mode mode = INTVAL (operands[3]) >=2 ? HImode : QImode;\n+  rtx tmpreg = gen_reg_rtx (mode);\n+  rtx increment = mode == QImode  ? const1_rtx : const2_rtx;\n+  rtx length = operands[2];\n+  rtx label = gen_label_rtx ();\n+  rtx end_src_ptr = gen_reg_rtx (Pmode);\n+\n+  emit_insn (gen_rtx (SET, VOIDmode, end_src_ptr,\n+\t\t      gen_rtx (PLUS, Pmode, src_ptr, length)));\n+\n+  emit_label (label);\n+  emit_move_insn (tmpreg, gen_rtx (MEM, mode, src_ptr));\n+  emit_move_insn (gen_rtx (MEM, mode, dst_ptr), tmpreg);\n+  emit_insn (gen_rtx (SET, VOIDmode, src_ptr,\n+\t\t      gen_rtx (PLUS, Pmode, src_ptr, increment)));\n+  emit_insn (gen_rtx (SET, VOIDmode, dst_ptr,\n+\t\t      gen_rtx (PLUS, Pmode, dst_ptr, increment)));\n+\n+  emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx,\n+\t\t      gen_rtx (COMPARE, HImode, src_ptr, end_src_ptr)));\n+  emit_jump_insn (gen_bne (label));\n+\n+  DONE;\t\n+}\n+\")\n+\f\n+;; ----------------------------------------------------------------------\n+;; Test instructions\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"tstqi\"\n+  [(set (cc0)\n+\t(match_operand:QI 0 \"register_operand\" \"ra\"))]\n+  \"\"\n+  \"cmp.b\t#0,%X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"tsthi\"\n+  [(set (cc0)\n+\t(match_operand:HI 0 \"register_operand\" \"ra\"))]\n+  \"\"\n+  \"mov.w\t%T0,%T0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"cmphi\"\n+  [(set (cc0)\n+\t(compare:HI (match_operand:HI 0 \"register_operand\" \"ra\")\n+\t\t    (match_operand:HI 1 \"register_operand\" \"ra\")))]\n+  \"\"\n+  \"cmp.w\t%T1,%T0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"compare\")])\n+\n+(define_insn \"cmpqi\"\n+  [(set (cc0)\n+\t(compare:QI (match_operand:QI 0 \"register_operand\" \"ra\")\n+\t\t    (match_operand:QI 1 \"nonmemory_operand\" \"rai\")))]\n+  \"\"\n+  \"cmp.b\t%X1,%X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"compare\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; Add instructions\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=ra,ra,ra,ra,r,ra\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"%0,0,0,0,0,0\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"K,M,L,N,n,ra\")))]\n+  \"\"\n+  \"@\n+   adds\t%T2,%T0\n+   adds\t#2,%T0\\;adds\t%C2,%T0\n+   subs\t%M2,%T0\n+   subs\t#2,%T0\\;subs\t%M2,%T0\n+   add.b\t%s2,%s0\\;addx\t%t2,%t0 \n+   add.w\t%T2,%T0\"\n+  [(set_attr \"type\" \"multi,multi,multi,multi,multi,arith\")\n+   (set_attr \"length\" \"2,4,2,4,4,2\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,none_0hit,none_0hit,clobber,set\")])\n+\n+(define_expand \"addhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(plus:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0] != operands[1])\n+    emit_move_insn (operands[0], operands[1]);\n+}\")\n+\n+(define_insn \"addqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(plus:QI (match_operand:QI 1 \"register_operand\" \"%0\")\n+\t\t (match_operand:QI 2 \"nonmemory_operand\" \"ri\")))]\n+  \"\"\n+  \"add.b\t%X2,%X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"l,n\")))\n+   (clobber (match_operand:HI 3 \"register_operand\" \"=&l,l\"))]\n+  \"\"\n+  \"@\n+     add\t%w2,%w0\\;addx\t%x2,%x0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\n+     add.w\t%f2,%f0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8,6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l,l\")\n+\t(plus:SI (match_operand:SI 1 \"register_operand\" \"%0,0\")\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"n,r\")))]\n+  \"\"\n+  \"@\n+     add\t%w2,%w0\\;addx\t%x2,%x0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\n+     add.w\t%f2,%f0\\;addx\t%y2,%y0\\;addx\t%z2,%z0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"8,6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"addsi3\"\n+  [(set (match_dup 3) (match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (match_dup 3)\n+\t(plus:SI (match_dup 3)\n+\t\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+   (set (match_operand:SI 0 \"register_operand\" \"\") (match_dup 3))]\n+  \"\"\n+  \"\n+{\n+  operands[3] = gen_rtx (REG, SImode, 0);\n+}\")\n+\f\n+;; ----------------------------------------------------------------------;\n+;; Subtract instructions\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=ra,ra,ra,r\")\n+\t(minus:HI (match_operand:HI 1 \"general_operand\" \"0,0,0,0\")\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"K,M,ra,n\")))]\n+  \"\"\n+  \"@\n+   subs\t%T2,%T0\n+   subs\t#2,%T0\\;subs\t%E2,%T0\n+   sub.w\t%T2,%T0\n+   add.b\t%E2,%s0\\;addx\t%F2,%t0 ; -%0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"2,4,2,4\")\n+   (set_attr \"cc\" \"none_0hit,none_0hit,set,clobber\")])\n+\n+(define_insn \"subqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r,r\")\n+\t(minus:QI (match_operand:QI 1 \"register_operand\" \"0,0\")\n+\t\t  (match_operand:QI 2 \"nonmemory_operand\" \"r,i\")))]\n+  \"\"\n+  \"@\n+   sub.b\t%X2,%X0\n+   add.b\t%G2,%X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_expand \"subhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(minus:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t  (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (operands[0] != operands[1])\n+    emit_move_insn (operands[0], operands[1]);\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(minus:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n+\t\t  (match_operand:SI 2 \"register_operand\" \"l\")))]\n+  \"\"\n+  \"sub.w\t%f2,%f0\\;subx\t%y2,%y0\\;subx\t%z2,%z0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"subsi3\"\n+  [(set (match_dup 3) (match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (match_dup 3)\n+\t(minus:SI (match_dup 3)\n+\t\t  (match_operand:SI 2 \"nonmemory_operand\" \"\")))\n+   (set (match_operand:SI 0 \"register_operand\" \"\") (match_dup 3))]\n+  \"\"\n+  \"operands[3] = gen_rtx (REG, SImode, 0);\")\n+\n+;; ----------------------------------------------------------------------\n+;; Multiply instruction\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"umulqihi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(mult:HI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t (match_operand:QI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"mulxu\t%X2,%T0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none_0hit\")])\n+\n+;; ----------------------------------------------------------------------\n+;; Divide instructions\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"udivqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(udiv:QI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t (match_operand:QI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"divxu\t%X2,%T0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"divqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(div:QI (match_operand:HI 1 \"general_operand\" \"0\")\n+\t\t(match_operand:QI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"divxu\t%X2,%T0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"clobber\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; And instructions\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"andqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n+\t(and:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"rn\")))]\n+  \"\"\n+  \"and\t%X2,%X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"andhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(and:HI (match_operand:HI 1 \"register_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"ri\")))]\n+  \"\"\n+  \"and\t%s2,%s0\\;and\t%t2,%t0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; Or instructions\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"iorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r,U\")\n+\t(ior:QI (match_operand:QI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:QI 2 \"general_operand\" \"rn,P\")))]\n+  \"\"\n+  \"@\n+   or\t%X2,%X0\n+   bset\t%V2,%X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"set,none_0hit\")])\n+\n+(define_insn \"iorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r,r\")\n+\t(ior:HI (match_operand:HI 1 \"general_operand\" \"%0,0\")\n+\t\t(match_operand:HI 2 \"general_operand\" \"J,ri\")))]\n+  \"\"\n+  \"@\n+   or\t%s2,%s0\n+   or\t%s2,%s0\\;or\t%t2,%t0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"2,4\")\n+   (set_attr \"cc\" \"clobber,clobber\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; Xor instructions\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"xorqi3\"\n+  [(set (match_operand:QI 0 \"general_operand\" \"=r\")\n+\t(xor:QI (match_operand:QI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:QI 2 \"nonmemory_operand\" \"ri\")))]\n+  \"\"\n+  \"xor\t%X2,%X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"xorhi3\"\n+  [(set (match_operand:HI 0 \"general_operand\" \"=r\")\n+\t(xor:HI (match_operand:HI 1 \"general_operand\" \"%0\")\n+\t\t(match_operand:HI 2 \"nonmemory_operand\" \"ri\")))]\n+  \"\"\n+  \"xor\t%s2,%s0\\;xor\t%t2,%t0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; Negation instructions\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"negqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(neg:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"neg\t%X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_expand \"neghi2\"\n+  [(set (match_dup 2)\n+\t(not:HI (match_operand:HI 1 \"register_operand\" \"r\")))\n+   (set (match_dup 2) (plus:HI (match_dup 2) (const_int 1)))\n+   (set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(match_dup 2))]\n+  \"\"\n+  \"operands[2] = gen_reg_rtx (HImode);\")\n+\n+(define_expand \"negsi2\"\n+  [(set (match_dup 2)\n+\t(not:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n+   (set (match_dup 2) (plus:SI (match_dup 2) (const_int 1)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(match_dup 2))]\n+  \"\"\n+  \"operands[2] = gen_reg_rtx (SImode);\")\n+\f\n+;; ----------------------------------------------------------------------\n+;; Not instructions\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"one_cmplqi2\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(not:QI (match_operand:QI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"not\t%X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"one_cmplhi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(not:HI (match_operand:HI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"not\t%s0\\;not\t%t0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"one_cmplsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(not:SI (match_operand:SI 1 \"general_operand\" \"0\")))]\n+  \"\"\n+  \"not\t%w0\\;not\t%x0\\;not\t%y0\\;not\t%z0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"clobber\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; Conditional branches\n+;; ----------------------------------------------------------------------\n+\n+(define_expand \"ble\"\n+  [(set (pc)\n+\t(if_then_else (le (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bleu\"\n+  [(set (pc)\n+\t(if_then_else (leu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bge\"\n+  [(set (pc)\n+\t(if_then_else (ge (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgeu\"\n+  [(set (pc)\n+\t(if_then_else (geu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"blt\"\n+  [(set (pc)\n+\t(if_then_else (lt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bltu\"\n+  [(set (pc)\n+\t(if_then_else (ltu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgt\"\n+  [(set (pc)\n+\t(if_then_else (gt (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bgtu\"\n+  [(set (pc)\n+\t(if_then_else (gtu (cc0)\n+\t\t\t   (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"beq\"\n+  [(set (pc)\n+\t(if_then_else (eq (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"bne\"\n+  [(set (pc)\n+\t(if_then_else (ne (cc0)\n+\t\t\t  (const_int 0))\n+\t\t      (label_ref (match_operand 0 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else \n+\t (match_operator 1 \"comparison_operator\" [(cc0) (const_int 0)])\n+\t (label_ref (match_operand 0 \"\" \"\"))\n+\t (pc)))]\n+  \"\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2) \n+   return \\\"b%j1\t%l0\\\";\n+  else\n+   return \\\"b%k1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n+}\" \n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else\n+\t (match_operator 1 \"comparison_operator\" [(cc0) (const_int 0)])\n+\t (pc)\n+\t (label_ref (match_operand 0 \"\" \"\"))))]\n+  \"\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2) \n+   return \\\"b%k1\t%l0\\\";\n+  else\n+   return \\\"b%j1\t%L0\\;jmp\t@%l0\\;%L0:\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"none\")])\n+\f\n+;; ----------------------------------------------------------------------\n+;; Unconditional branches\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"jump\"\n+  [(set (pc)\n+\t(label_ref (match_operand 0 \"\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  if (get_attr_length (insn) == 2) \n+   return \\\"bra\t%l0\\\";\n+  else\n+   return \\\"jmp\t@%l0\\\";\n+}\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"none\")])\n+\n+(define_insn \"tablejump\"\n+  [(set (pc) (match_operand:HI 0 \"register_operand\" \"\"))\n+   (use (label_ref (match_operand 1 \"\" \"\")))]\n+  \"\"\n+  \"jmp\t@%0\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"2\")])\n+\n+;; Call subroutine with no return value.\n+\n+(define_insn \"call\"\n+  [(call (match_operand:QI 0 \"memory_operand\" \"o\")\n+\t (match_operand:HI 1 \"general_operand\" \"g\"))]\n+  \"\"\n+  \"jsr\t%0\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"length\" \"4\")])\n+\n+;; Call subroutine, returning value in operand 0\n+;; (which must be a hard register).\n+\n+(define_insn \"call_value\"\n+  [(set (match_operand 0 \"\" \"=r\")\n+\t(call (match_operand:QI 1 \"memory_operand\" \"o\")\n+\t      (match_operand:HI 2 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"jsr\t%1\"\n+  [(set_attr \"type\" \"call\")\n+   (set_attr \"cc\" \"clobber\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"nop\"\n+  [(const_int 0)]\n+  \"\"\n+  \"nop\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"2\")])\n+\n+(define_insn \"indirect_jump\"\n+  [(set (pc) (match_operand:HI 0 \"register_operand\" \"r\"))]\n+  \"\"\n+  \"jmp\t@%0\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"cc\" \"none\")\n+   (set_attr \"length\" \"2\")])\n+\f\n+;; -----------------------------------------------------------------\n+;; Shifts\n+;; -----------------------------------------------------------------\n+\n+;; All H8 shifts go one bit at a time, here they are defined with names\n+;; so can use them in the expands..\n+\n+;; QI BIT SHIFTS\n+\n+(define_insn \"ashlqi3_one\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"shal %X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"ashrqi3_one\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"shar %X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"lshrqi3_one\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"shlr %X0\"\n+  [(set_attr \"type\" \"arith\")\n+   (set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_expand \"ashlqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ashift:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t   (match_operand:QI 2 \"nonmemory_operand\" \"rn\")))]\n+  \"\"\n+  \"\n+{\n+  if (can_shift (ASHIFT, operands, gen_ashlqi3_one, 4, 0))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+(define_expand \"ashrqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"rn\")))]\n+  \"\"\n+  \"\n+{\n+  if (can_shift (ASHIFTRT, operands, gen_ashrqi3_one, 4, 0))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+(define_expand \"lshrqi3\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:QI (match_operand:QI 1 \"register_operand\" \"0\")\n+\t\t     (match_operand:QI 2 \"nonmemory_operand\" \"rn\")))]\n+  \"\"\n+  \"\n+{\n+  if (can_shift (LSHIFTRT, operands, gen_lshrqi3_one, 4, 0))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+;;  HI BIT SHIFTS\n+\n+(define_insn \"ashlhi3_one\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"add.w\t%T1,%T0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_insn \"ashlhi3_eight\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ashift:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t   (const_int 8)))]\n+  \"\"\n+  \"mov.b\t%s1,%t0\\;mov.b\t#0,%s0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"ashlhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ashift:HI\n+\t (match_operand:HI 1 \"general_operand_src\" \"\")\n+\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (can_shift (ASHIFT, operands, gen_ashlhi3_one, 4, gen_ashlhi3_eight)) \n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+(define_insn \"lshrhi3_one\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"shlr\t%t0\\;rotxr\t%s0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"lshlhi3_eight\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 8)))]\n+  \"\"\n+  \"mov.b\t%t1,%s0\\;mov.b\t#0,%t0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"lshrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(lshiftrt:HI\n+\t (match_operand:HI 1 \"general_operand_src\" \"\")\n+\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (can_shift (LSHIFTRT, operands, gen_lshrhi3_one, 4, gen_lshlhi3_eight))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+(define_insn \"ashrhi3_one\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"shar\t%t0\\;rotxr\t%s0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+; signed shift right by 8 bits\n+; fetch the carry bit from the top, copy the byte right, subtract the \n+; top byte from itself - carry.\n+\n+(define_insn \"ashrhi3_eight\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:HI (match_operand:HI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 8)))]\n+  \"\"\n+  \"bld\t#7,%t0\\;mov.b\t%t0,%s0\\;subx\t%t0,%t0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"ashrhi3\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(ashiftrt:HI\n+\t (match_operand:HI 1 \"general_operand_src\" \"\")\n+\t (match_operand:HI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (can_shift (ASHIFTRT, operands, gen_ashrhi3_one, 4, gen_ashrhi3_eight)) \n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+;; SI BIT SHIFTS\n+\n+(define_insn \"ashlsi3_one\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashift:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t   (const_int 1)))]\n+  \"\"\n+  \"add.w\t%f1,%f0\\;addx\t%y1,%y0\\;addx\t%z1,%z0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"ashlsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashift:SI\n+\t (match_operand:SI 1 \"general_operand_src\" \"\")\n+\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (can_shift (ASHIFT, operands, gen_ashlsi3_one, 1, 0))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+(define_insn \"lshrsi3_one\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lshiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"shlr\t%z0\\;rotxr\t%y0\\;rotxr\t%x0\\;rotxr\t%w0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"lshrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(lshiftrt:SI\n+\t (match_operand:SI 1 \"general_operand_src\" \"\")\n+\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (can_shift (LSHIFTRT, operands, gen_lshrsi3_one, 1, 0))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+(define_insn \"ashrsi3_one\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(ashiftrt:SI (match_operand:SI 1 \"register_operand\" \"0\")\n+\t\t     (const_int 1)))]\n+  \"\"\n+  \"shar\t%z0\\;rotxr\t%y0\\;rotxr\t%x0\\;rotxr\t%w0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"16\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"ashrsi3\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ashiftrt:SI\n+\t (match_operand:SI 1 \"general_operand_src\" \"\")\n+\t (match_operand:SI 2 \"nonmemory_operand\" \"\")))]\n+  \"\"\n+  \"\n+{\n+  if (can_shift (ASHIFTRT, operands, gen_ashrsi3_one, 1, 0))\n+    DONE;\n+  else\n+    FAIL;\n+}\")\n+\n+;; ----------------------------------------------------------------------\n+;; BIT FIELDS\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"\"\n+  [(set (zero_extract:HI (match_operand:HI 0 \"register_operand\" \"+r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"g\"))\n+\t(match_operand:HI 3 \"general_operand\" \"r\"))]\n+  \"\"\n+  \"bld\t#0,%3l\\;bst\t%Z2,%0%Y1\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract:HI (match_operand:HI 0 \"register_operand\" \"+r\")\n+\t\t\t (match_operand:HI 1 \"general_operand\" \"g\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"g\"))\n+\t(match_operand:HI 3 \"general_operand\" \"r\"))]\n+  \"\"\n+  \"if (INTVAL (operands[1]) != 1) FAIL;\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n+\t(zero_extract:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 3 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"sub.w\t%T0,%T0\\;bld\t%Z3,%T1%Y1\\;rotxl\t%T0l\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extract:HI (match_operand:HI 1 \"register_operand\" \"r\")\n+\t\t\t (const_int 1)\n+\t\t\t (match_operand:HI 3 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"bld\t%Z3,%1%Y1\\;sub.x\t%0l,%0l\\;mov.b\t%0l,%0h\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"extzv\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(zero_extract:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n+\t\t\t (match_operand:HI 3 \"general_operand\" \"\")))]\n+  \"\"\n+  \"if (INTVAL (operands[2]) != 1) FAIL;\")\n+\n+(define_expand \"extv\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(sign_extract:HI (match_operand:HI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:HI 2 \"general_operand\" \"\")\n+\t\t\t (match_operand:HI 3 \"immediate_operand\" \"\")))]\n+  \"\"\n+  \"if (INTVAL (operands[2]) != 1)  FAIL;\")\n+\f\n+;; ----------------------------------------------------------------------\n+;; Conversions\n+;; ----------------------------------------------------------------------\n+\n+(define_insn \"zero_extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(zero_extend:HI\n+\t (match_operand:QI 1 \"general_operand\" \"g\")))]\n+  \"\"\n+  \"mov.b\t%X1,%s0\\;mov.b\t#0,%t0\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"extendqihi2\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+\t(sign_extend:HI\n+\t (match_operand:QI 1 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"*\n+{\n+  if (REGNO (operands[1]) != REGNO (operands[0]))\n+   return \\\"mov.b\t%X1,%s0\\;bld\t#7,%s0\\;subx\t%t0,%t0\\\";\n+  else\n+   return \\\"bld\t#7,%s0\\;subx\t%t0,%t0\\\";\n+}\"\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_insn \"extendhisi2_one\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n+\t(sign_extend:SI (match_operand:HI 1 \"register_operand\" \"0\")))]\n+  \"\"\n+  \"mov.w\t%T1,%f0\\;bld\t#7,%x0\\;subx\t%y0,%y0\\;subx\t%z0,%z0\"\n+  [(set_attr \"length\" \"10\")\n+   (set_attr \"cc\" \"clobber\")])\n+\n+(define_expand \"extendhisi2\"\n+  [(set (reg:HI 1) (match_operand:HI 1 \"general_operand\" \"\"))\n+   (set (reg:SI 0) (sign_extend:SI (reg:HI 1)))\n+   (set (match_operand:SI 0 \"general_operand\" \"\" ) (reg:SI 0))]\n+  \"\"\n+  \"\")\n+\f\n+;; ----------------------------------------------------------------------\n+;; peepholes\n+;; ----------------------------------------------------------------------\n+\n+;; notice a move which could be predecremented\n+\n+(define_peephole \n+  [(set (match_operand:HI 1 \"register_operand\" \"\")\n+\t(plus:HI (match_dup 1) (const_int -1)))\n+   (set (mem:HI (match_dup 1))\n+\t(match_operand:HI 0 \"register_operand\" \"\"))]\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n+  \"mov.w\t%T0,@-%T1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_peephole \n+  [(set (match_operand:HI 1 \"register_operand\" \"\")\n+\t(plus:HI (match_dup 1) (const_int -1)))\n+   (set (mem:QI (match_dup 1))\n+\t(match_operand:QI 0 \"register_operand\" \"\"))]\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n+  \"mov.b\t%X0,@-%T1\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+;; notice a move which could be post incremented\n+\n+(define_peephole \n+  [(set (match_operand:HI 0 \"register_operand\" \"\")\n+\t(mem:HI (match_operand:HI 1 \"register_operand\" \"\")))\n+   (set (match_dup 1) (plus:HI (match_dup 1) (const_int 2)))]\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n+  \"mov.w\t@%T1+,%T0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_peephole \n+  [(set (match_operand:QI 0 \"register_operand\" \"\")\n+\t(mem:QI (match_operand:HI 1 \"register_operand\" \"\")))\n+   (set (match_dup 1) (plus:HI (match_dup 1) (const_int 1)))]\n+  \"REGNO (operands[1]) != REGNO (operands[0])\"\n+  \"mov.b\t@%T1+,%X0\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"set\")])\n+\n+;; notice when two byte moves in a row could be a word move\n+\n+(define_peephole\n+  [(set (mem:QI (plus:HI (match_operand:HI 1 \"register_operand\" \"ra\")\n+\t\t\t (match_operand:HI 2 \"immediate_operand\" \"n\")))\n+\t(match_operand:QI 0 \"register_operand\" \"r\"))\n+   (set (mem:QI (plus:HI (match_dup 1)\n+\t\t\t (match_operand:HI 4 \"immediate_operand\" \"n\")))\n+\t(match_operand:QI 3 \"register_operand\" \"r\"))]\n+  \"(INTVAL (operands[2]) == INTVAL (operands[4]) + 1) \n+   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\"\n+  \"mov.w\t%T0,@(%u4,%T1)\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"set\")])\n+\n+(define_peephole\n+  [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n+\t(mem:QI (plus:HI (match_operand:HI 1 \"register_operand\" \"ra\")\n+\t\t\t (match_operand:HI 2 \"immediate_operand\" \"n\"))))\n+   (set (match_operand:QI 3 \"register_operand\" \"=r\")\n+\t(mem:QI (plus:HI (match_dup 1)\n+\t\t\t (match_operand:HI 4 \"immediate_operand\" \"n\"))))]\n+  \"(INTVAL (operands[2]) == INTVAL (operands[4]) + 1) \n+   && (REGNO (operands[0]) + 1 == REGNO (operands[3]))\"\n+  \"mov.w\t@(%u4,%T1),%T0\"\n+  [(set_attr \"length\" \"6\")\n+   (set_attr \"cc\" \"set\")])"}]}