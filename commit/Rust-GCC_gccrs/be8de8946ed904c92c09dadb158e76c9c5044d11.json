{"sha": "be8de8946ed904c92c09dadb158e76c9c5044d11", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmU4ZGU4OTQ2ZWQ5MDRjOTJjMDlkYWRiMTU4ZTc2YzljNTA0NGQxMQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-11-12T23:55:11Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-11-12T23:55:11Z"}, "message": "std::shared_ptr atomic operations\n\n\tPR libstdc++/57250\n\t* config/abi/pre/gnu.ver: Export new symbols.\n\t* include/Makefile.am: Add new header.\n\t* include/Makefile.in: Regenerate.\n\t* include/bits/shared_ptr_atomic.h: Define atomic access functions.\n\t* include/std/memory: Include new header.\n\t* src/c++11/shared_ptr.cc (_Sp_locker): Define and use mutex pool.\n\t* testsuite/20_util/shared_ptr/atomic/1.cc: New.\n\t* testsuite/20_util/shared_ptr/atomic/2.cc: New.\n\t* testsuite/20_util/shared_ptr/atomic/3.cc: New.\n\nFrom-SVN: r217452", "tree": {"sha": "7ee9e4d194e27f91eae668a26c02507636c07454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ee9e4d194e27f91eae668a26c02507636c07454"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/be8de8946ed904c92c09dadb158e76c9c5044d11", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be8de8946ed904c92c09dadb158e76c9c5044d11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be8de8946ed904c92c09dadb158e76c9c5044d11", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be8de8946ed904c92c09dadb158e76c9c5044d11/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abb502071166f1eee1869cd5304d30d6763979f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abb502071166f1eee1869cd5304d30d6763979f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abb502071166f1eee1869cd5304d30d6763979f9"}], "stats": {"total": 540, "additions": 540, "deletions": 0}, "files": [{"sha": "d6339c9f6e9185b5c510c20abe4328daa5466d50", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=be8de8946ed904c92c09dadb158e76c9c5044d11", "patch": "@@ -1,3 +1,16 @@\n+2014-11-12  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/57250\n+\t* config/abi/pre/gnu.ver: Export new symbols.\n+\t* include/Makefile.am: Add new header.\n+\t* include/Makefile.in: Regenerate.\n+\t* include/bits/shared_ptr_atomic.h: Define atomic access functions.\n+\t* include/std/memory: Include new header.\n+\t* src/c++11/shared_ptr.cc (_Sp_locker): Define and use mutex pool.\n+\t* testsuite/20_util/shared_ptr/atomic/1.cc: New.\n+\t* testsuite/20_util/shared_ptr/atomic/2.cc: New.\n+\t* testsuite/20_util/shared_ptr/atomic/3.cc: New.\n+\n 2014-11-12  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/shared_ptr.h (weak_ptr): Add move constructor and"}, {"sha": "bd44bcc3ba63db98d26445c5ce4f7c1063d7b8ed", "filename": "libstdc++-v3/config/abi/pre/gnu.ver", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Fabi%2Fpre%2Fgnu.ver?ref=be8de8946ed904c92c09dadb158e76c9c5044d11", "patch": "@@ -1476,6 +1476,9 @@ GLIBCXX_3.4.21 {\n     # std::ctype_base::blank\n     _ZNSt10ctype_base5blankE;\n \n+    # std::_Sp_locker::*\n+    _ZNSt10_Sp_locker[CD]*;\n+\n } GLIBCXX_3.4.20;\n \n "}, {"sha": "e6edc7327792bf331fd8326552a5a2ca07ec5493", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=be8de8946ed904c92c09dadb158e76c9c5044d11", "patch": "@@ -143,6 +143,7 @@ bits_headers = \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/shared_ptr.h \\\n+\t${bits_srcdir}/shared_ptr_atomic.h \\\n \t${bits_srcdir}/shared_ptr_base.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\"}, {"sha": "2ade448de981284a828a1f4dd5dde4e669fa1039", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=be8de8946ed904c92c09dadb158e76c9c5044d11", "patch": "@@ -410,6 +410,7 @@ bits_headers = \\\n \t${bits_srcdir}/stream_iterator.h \\\n \t${bits_srcdir}/streambuf_iterator.h \\\n \t${bits_srcdir}/shared_ptr.h \\\n+\t${bits_srcdir}/shared_ptr_atomic.h \\\n \t${bits_srcdir}/shared_ptr_base.h \\\n \t${bits_srcdir}/slice_array.h \\\n \t${bits_srcdir}/sstream.tcc \\"}, {"sha": "79e35ec3b2df4ecf85482074d5cb9c37df7d3308", "filename": "libstdc++-v3/include/bits/shared_ptr_atomic.h", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_atomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_atomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fshared_ptr_atomic.h?ref=be8de8946ed904c92c09dadb158e76c9c5044d11", "patch": "@@ -0,0 +1,330 @@\n+// shared_ptr atomic access -*- C++ -*-\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// Under Section 7 of GPL version 3, you are granted additional\n+// permissions described in the GCC Runtime Library Exception, version\n+// 3.1, as published by the Free Software Foundation.\n+\n+// You should have received a copy of the GNU General Public License and\n+// a copy of the GCC Runtime Library Exception along with this program;\n+// see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+// <http://www.gnu.org/licenses/>.\n+\n+/** @file bits/shared_ptr_atomic.h\n+ *  This is an internal header file, included by other library headers.\n+ *  Do not attempt to use it directly. @headername{memory}\n+ */\n+\n+#ifndef _SHARED_PTR_ATOMIC_H\n+#define _SHARED_PTR_ATOMIC_H 1\n+\n+#include <bits/atomic_base.h>\n+\n+namespace std _GLIBCXX_VISIBILITY(default)\n+{\n+_GLIBCXX_BEGIN_NAMESPACE_VERSION\n+\n+  /**\n+   * @addtogroup pointer_abstractions\n+   * @{\n+   */\n+\n+  struct _Sp_locker\n+  {\n+    _Sp_locker(const _Sp_locker&) = delete;\n+    _Sp_locker& operator=(const _Sp_locker&) = delete;\n+\n+#ifdef __GTHREADS\n+    explicit\n+    _Sp_locker(const void*) noexcept;\n+    _Sp_locker(const void*, const void*) noexcept;\n+    ~_Sp_locker();\n+\n+  private:\n+    unsigned char _M_key1;\n+    unsigned char _M_key2;\n+#else\n+    explicit _Sp_locker(const void*, const void* = nullptr) { }\n+#endif\n+  };\n+\n+  /**\n+   *  @brief  Report whether shared_ptr atomic operations are lock-free.\n+   *  @param  __p A non-null pointer to a shared_ptr object.\n+   *  @return True if atomic access to @c *__p is lock-free, false otherwise.\n+   *  @{\n+  */\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline bool\n+    atomic_is_lock_free(const __shared_ptr<_Tp, _Lp>* __p)\n+    {\n+#ifdef __GTHREADS\n+      return __gthread_active_p() == 0;\n+#else\n+      return true;\n+#endif\n+    }\n+\n+  template<typename _Tp>\n+    inline bool\n+    atomic_is_lock_free(const shared_ptr<_Tp>* __p)\n+    { return std::atomic_is_lock_free<_Tp, __default_lock_policy>(__p); }\n+\n+  // @}\n+\n+  /**\n+   *  @brief  Atomic load for shared_ptr objects.\n+   *  @param  __p A non-null pointer to a shared_ptr object.\n+   *  @return @c *__p\n+   *\n+   *  The memory order shall not be @c memory_order_release or\n+   *  @c memory_order_acq_rel.\n+   *  @{\n+  */\n+  template<typename _Tp>\n+    inline shared_ptr<_Tp>\n+    atomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n+    {\n+      _Sp_locker __lock{__p};\n+      return *__p;\n+    }\n+\n+  template<typename _Tp>\n+    inline shared_ptr<_Tp>\n+    atomic_load(const shared_ptr<_Tp>* __p)\n+    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n+    atomic_load_explicit(const __shared_ptr<_Tp, _Lp>* __p, memory_order)\n+    {\n+      _Sp_locker __lock{__p};\n+      return *__p;\n+    }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n+    atomic_load(const __shared_ptr<_Tp, _Lp>* __p)\n+    { return std::atomic_load_explicit(__p, memory_order_seq_cst); }\n+  // @}\n+\n+  /**\n+   *  @brief  Atomic store for shared_ptr objects.\n+   *  @param  __p A non-null pointer to a shared_ptr object.\n+   *  @param  __r The value to store.\n+   *\n+   *  The memory order shall not be @c memory_order_acquire or\n+   *  @c memory_order_acq_rel.\n+   *  @{\n+  */\n+  template<typename _Tp>\n+    inline void\n+    atomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,\n+\t\t\t  memory_order)\n+    {\n+      _Sp_locker __lock{__p};\n+      __p->swap(__r); // use swap so that **__p not destroyed while lock held\n+    }\n+\n+  template<typename _Tp>\n+    inline void\n+    atomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n+    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline void\n+    atomic_store_explicit(__shared_ptr<_Tp, _Lp>* __p,\n+\t\t\t  __shared_ptr<_Tp, _Lp> __r,\n+\t\t\t  memory_order)\n+    {\n+      _Sp_locker __lock{__p};\n+      __p->swap(__r); // use swap so that **__p not destroyed while lock held\n+    }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline void\n+    atomic_store(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)\n+    { std::atomic_store_explicit(__p, std::move(__r), memory_order_seq_cst); }\n+  // @}\n+\n+  /**\n+   *  @brief  Atomic exchange for shared_ptr objects.\n+   *  @param  __p A non-null pointer to a shared_ptr object.\n+   *  @param  __r New value to store in @c *__p.\n+   *  @return The original value of @c *__p\n+   *  @{\n+  */\n+  template<typename _Tp>\n+    inline shared_ptr<_Tp>\n+    atomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r,\n+\t\t\t     memory_order)\n+    {\n+      _Sp_locker __lock{__p};\n+      __p->swap(__r);\n+      return __r;\n+    }\n+\n+  template<typename _Tp>\n+    inline shared_ptr<_Tp>\n+    atomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n+    {\n+      return std::atomic_exchange_explicit(__p, std::move(__r),\n+\t\t\t\t\t   memory_order_seq_cst);\n+    }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n+    atomic_exchange_explicit(__shared_ptr<_Tp, _Lp>* __p,\n+\t\t\t     __shared_ptr<_Tp, _Lp> __r,\n+\t\t\t     memory_order)\n+    {\n+      _Sp_locker __lock{__p};\n+      __p->swap(__r);\n+      return __r;\n+    }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline __shared_ptr<_Tp, _Lp>\n+    atomic_exchange(__shared_ptr<_Tp, _Lp>* __p, __shared_ptr<_Tp, _Lp> __r)\n+    {\n+      return std::atomic_exchange_explicit(__p, std::move(__r),\n+\t\t\t\t\t   memory_order_seq_cst);\n+    }\n+  // @}\n+\n+  /**\n+   *  @brief  Atomic compare-and-swap for shared_ptr objects.\n+   *  @param  __p A non-null pointer to a shared_ptr object.\n+   *  @param  __v A non-null pointer to a shared_ptr object.\n+   *  @param  __w A non-null pointer to a shared_ptr object.\n+   *  @return True if @c *__p was equivalent to @c *__v, false otherwise.\n+   *\n+   *  The memory order for failure shall not be @c memory_order_release or\n+   *  @c memory_order_acq_rel, or stronger than the memory order for success.\n+   *  @{\n+  */\n+  template<typename _Tp>\n+    bool\n+    atomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p,\n+\t\t\t\t\t    shared_ptr<_Tp>* __v,\n+\t\t\t\t\t    shared_ptr<_Tp> __w,\n+\t\t\t\t\t    memory_order,\n+\t\t\t\t\t    memory_order)\n+    {\n+      shared_ptr<_Tp> __x; // goes out of scope after __lock\n+      _Sp_locker __lock{__p, __v};\n+      owner_less<shared_ptr<_Tp>> __less;\n+      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))\n+\t{\n+\t  __x = std::move(*__p);\n+\t  *__p = std::move(__w);\n+\t  return true;\n+\t}\n+      __x = std::move(*__v);\n+      *__v = *__p;\n+      return false;\n+    }\n+\n+  template<typename _Tp>\n+    inline bool\n+    atomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n+\t\t\t\t shared_ptr<_Tp> __w)\n+    {\n+      return std::atomic_compare_exchange_strong_explicit(__p, __v,\n+\t  std::move(__w), memory_order_seq_cst, memory_order_seq_cst);\n+    }\n+\n+  template<typename _Tp>\n+    inline bool\n+    atomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p,\n+\t\t\t\t\t  shared_ptr<_Tp>* __v,\n+\t\t\t\t\t  shared_ptr<_Tp> __w,\n+\t\t\t\t\t  memory_order __success,\n+\t\t\t\t\t  memory_order __failure)\n+    {\n+      return std::atomic_compare_exchange_strong_explicit(__p, __v,\n+\t  std::move(__w), __success, __failure);\n+    }\n+\n+  template<typename _Tp>\n+    inline bool\n+    atomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n+\t\t\t\t shared_ptr<_Tp> __w)\n+    {\n+      return std::atomic_compare_exchange_weak_explicit(__p, __v,\n+\t  std::move(__w), memory_order_seq_cst, memory_order_seq_cst);\n+    }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    bool\n+    atomic_compare_exchange_strong_explicit(__shared_ptr<_Tp, _Lp>* __p,\n+\t\t\t\t\t    __shared_ptr<_Tp, _Lp>* __v,\n+\t\t\t\t\t    __shared_ptr<_Tp, _Lp> __w,\n+\t\t\t\t\t    memory_order,\n+\t\t\t\t\t    memory_order)\n+    {\n+      __shared_ptr<_Tp, _Lp> __x; // goes out of scope after __lock\n+      _Sp_locker __lock{__p, __v};\n+      owner_less<__shared_ptr<_Tp, _Lp>> __less;\n+      if (*__p == *__v && !__less(*__p, *__v) && !__less(*__v, *__p))\n+\t{\n+\t  __x = std::move(*__p);\n+\t  *__p = std::move(__w);\n+\t  return true;\n+\t}\n+      __x = std::move(*__v);\n+      *__v = *__p;\n+      return false;\n+    }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline bool\n+    atomic_compare_exchange_strong(__shared_ptr<_Tp, _Lp>* __p,\n+\t\t\t\t   __shared_ptr<_Tp, _Lp>* __v,\n+\t\t\t\t   __shared_ptr<_Tp, _Lp> __w)\n+    {\n+      return std::atomic_compare_exchange_strong_explicit(__p, __v,\n+\t  std::move(__w), memory_order_seq_cst, memory_order_seq_cst);\n+    }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline bool\n+    atomic_compare_exchange_weak_explicit(__shared_ptr<_Tp, _Lp>* __p,\n+\t\t\t\t\t  __shared_ptr<_Tp, _Lp>* __v,\n+\t\t\t\t\t  __shared_ptr<_Tp, _Lp> __w,\n+\t\t\t\t\t  memory_order __success,\n+\t\t\t\t\t  memory_order __failure)\n+    {\n+      return std::atomic_compare_exchange_strong_explicit(__p, __v,\n+\t  std::move(__w), __success, __failure);\n+    }\n+\n+  template<typename _Tp, _Lock_policy _Lp>\n+    inline bool\n+    atomic_compare_exchange_weak(__shared_ptr<_Tp, _Lp>* __p,\n+\t\t\t\t __shared_ptr<_Tp, _Lp>* __v,\n+\t\t\t\t __shared_ptr<_Tp, _Lp> __w)\n+    {\n+      return std::atomic_compare_exchange_weak_explicit(__p, __v,\n+\t  std::move(__w), memory_order_seq_cst, memory_order_seq_cst);\n+    }\n+  // @}\n+\n+  // @} group pointer_abstractions\n+\n+_GLIBCXX_END_NAMESPACE_VERSION\n+} // namespace\n+\n+#endif // _SHARED_PTR_ATOMIC_H"}, {"sha": "3d1c8a9d2e3bd6d7bd49f76f17ac506745c626c1", "filename": "libstdc++-v3/include/std/memory", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmemory?ref=be8de8946ed904c92c09dadb158e76c9c5044d11", "patch": "@@ -80,6 +80,7 @@\n #  include <debug/debug.h>\n #  include <bits/unique_ptr.h>\n #  include <bits/shared_ptr.h>\n+#  include <bits/shared_ptr_atomic.h>\n #  if _GLIBCXX_USE_DEPRECATED\n #    include <backward/auto_ptr.h>\n #  endif"}, {"sha": "924753258ffb152d46b08dd1ab0536337f68622f", "filename": "libstdc++-v3/src/c++11/shared_ptr.cc", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fshared_ptr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fshared_ptr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B11%2Fshared_ptr.cc?ref=be8de8946ed904c92c09dadb158e76c9c5044d11", "patch": "@@ -34,5 +34,63 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   bad_weak_ptr::what() const noexcept\n   { return \"bad_weak_ptr\"; }\n \n+#ifdef __GTHREADS\n+  namespace\n+  {\n+    const unsigned char mask = 0xf;\n+    const unsigned char invalid = mask + 1;\n+\n+    inline unsigned char key(const void* addr)\n+    { return _Hash_impl::hash(addr) & mask; }\n+\n+    /* Returns different instances of __mutex depending on the passed address\n+     * in order to limit contention.\n+     */\n+    __gnu_cxx::__mutex&\n+    get_mutex(unsigned char i)\n+    {\n+      static __gnu_cxx::__mutex m[mask + 1];\n+      return m[i];\n+    }\n+  }\n+\n+  _Sp_locker::_Sp_locker(const void* p)\n+  {\n+    if (__gthread_active_p())\n+      {\n+\t_M_key1 = _M_key2 = key(p);\n+\tget_mutex(_M_key1).lock();\n+      }\n+    else\n+      _M_key1 = _M_key2 = invalid;\n+  }\n+\n+  _Sp_locker::_Sp_locker(const void* p1, const void* p2)\n+  {\n+    if (__gthread_active_p())\n+      {\n+\t_M_key1 = key(p1);\n+\t_M_key2 = key(p2);\n+\tif (_M_key2 < _M_key1)\n+\t  get_mutex(_M_key2).lock();\n+\tget_mutex(_M_key1).lock();\n+\tif (_M_key2 > _M_key1)\n+\t  get_mutex(_M_key2).lock();\n+      }\n+    else\n+      _M_key1 = _M_key2 = invalid;\n+  }\n+\n+  _Sp_locker::~_Sp_locker()\n+  {\n+    if (_M_key1 != invalid)\n+      {\n+\tget_mutex(_M_key1).unlock();\n+\tif (_M_key2 != _M_key1)\n+\t  get_mutex(_M_key2).unlock();\n+      }\n+  }\n+#endif\n+\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace"}, {"sha": "37ab333f28794247d2cb8dcf7231181ad70993ef", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/atomic/1.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2F1.cc?ref=be8de8946ed904c92c09dadb158e76c9c5044d11", "patch": "@@ -0,0 +1,40 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-require-gthreads \"\" }\n+\n+#include <memory>\n+\n+int main()\n+{\n+  using test_type = std::shared_ptr<int>;\n+  bool test __attribute__ ((unused)) = false;\n+  constexpr auto mo = std::memory_order_seq_cst;\n+  const test_type p;\n+  test = std::atomic_is_lock_free(&p);\n+  test_type p2 = std::atomic_load(&p);\n+  test_type p3 = std::atomic_load_explicit(&p, mo);\n+  std::atomic_store(&p2, p);\n+  std::atomic_store_explicit(&p2, p, mo);\n+  test_type p4 = std::atomic_exchange(&p2, p);\n+  p4 = std::atomic_exchange_explicit(&p2, p, mo);\n+  test = std::atomic_compare_exchange_weak(&p2, &p3, p);\n+  test = std::atomic_compare_exchange_strong(&p2, &p3, p);\n+  test = std::atomic_compare_exchange_weak_explicit(&p2, &p3, p, mo, mo);\n+  test = std::atomic_compare_exchange_strong_explicit(&p2, &p3, p, mo, mo);\n+}"}, {"sha": "846a6633784cbef9ef8d9914c712c1c0a5c09b53", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/atomic/2.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2F2.cc?ref=be8de8946ed904c92c09dadb158e76c9c5044d11", "patch": "@@ -0,0 +1,40 @@\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-require-gthreads \"\" }\n+\n+#include <memory>\n+\n+int main()\n+{\n+  using test_type = std::__shared_ptr<int, std::_S_single>;\n+  bool test __attribute__ ((unused)) = false;\n+  constexpr auto mo = std::memory_order_seq_cst;\n+  const test_type p;\n+  test = std::atomic_is_lock_free(&p);\n+  test_type p2 = std::atomic_load(&p);\n+  test_type p3 = std::atomic_load_explicit(&p, mo);\n+  std::atomic_store(&p2, p);\n+  std::atomic_store_explicit(&p2, p, mo);\n+  test_type p4 = std::atomic_exchange(&p2, p);\n+  p4 = std::atomic_exchange_explicit(&p2, p, mo);\n+  test = std::atomic_compare_exchange_weak(&p2, &p3, p);\n+  test = std::atomic_compare_exchange_strong(&p2, &p3, p);\n+  test = std::atomic_compare_exchange_weak_explicit(&p2, &p3, p, mo, mo);\n+  test = std::atomic_compare_exchange_strong_explicit(&p2, &p3, p, mo, mo);\n+}"}, {"sha": "f9648062bd8386d6de90f5bc7cdcfa2887566c8a", "filename": "libstdc++-v3/testsuite/20_util/shared_ptr/atomic/3.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/be8de8946ed904c92c09dadb158e76c9c5044d11/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fshared_ptr%2Fatomic%2F3.cc?ref=be8de8946ed904c92c09dadb158e76c9c5044d11", "patch": "@@ -0,0 +1,53 @@\n+// { dg-do run { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* *-*-solaris* *-*-cygwin *-*-darwin* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthread\" { target *-*-freebsd* *-*-dragonfly* *-*-netbsd* *-*-linux* *-*-gnu* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++11 \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <thread>\n+#include <memory>\n+#include <testsuite_hooks.h>\n+\n+struct leaddock\n+{\n+  ~leaddock();\n+};\n+\n+std::shared_ptr<leaddock> global;\n+\n+leaddock::~leaddock()\n+{\n+  // If this destructor is called \"inside\" an atomic operation on global it\n+  // will deadlock, so this checks that the atomic_store is done atomically.\n+  auto copy = std::atomic_load(&global);\n+  VERIFY( !copy );\n+}\n+\n+void f()\n+{\n+  std::atomic_store(&global, std::make_shared<leaddock>());\n+  std::atomic_store(&global, {});\n+}\n+\n+int main()\n+{\n+  std::thread{ f }.join();\n+}"}]}