{"sha": "5196736e471495a372ba5583c53f16020eea10ca", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE5NjczNmU0NzE0OTVhMzcyYmE1NTgzYzUzZjE2MDIwZWVhMTBjYQ==", "commit": {"author": {"name": "Andreas Jaeger", "email": "aj@suse.de", "date": "2003-11-21T11:24:10Z"}, "committer": {"name": "Andreas Tobler", "email": "andreast@gcc.gnu.org", "date": "2003-11-21T11:24:10Z"}, "message": "acinclude.m4: Add AC_FUNC_MMAP_BLACKLIST.\n\n2003-11-21  Andreas Jaeger  <aj@suse.de>\n\t    Andreas Tobler  <a.tobler@schweiz.ch>\n\n\t* acinclude.m4: Add AC_FUNC_MMAP_BLACKLIST.\n\t* configure.in: Call AC_FUNC_MMAP_BLACKLIST.\n\t* Makefile.in: Rebuilt.\n\t* aclocal.m4: Likewise.\n\t* configure: Likewise.\n\t* fficonfig.h.in: Likewise.\n\t* testsuite/lib/libffi-dg.exp: Add include dir.\n\t* testsuite/libffi.call/ffitest.h: Add MMAP definitions.\n\t* testsuite/libffi.special/ffitestcxx.h: Likewise.\n\t* testsuite/libffi.call/closure_fn0.c: Use MMAP functionality\n\tfor ffi_closure if available.\n\t* testsuite/libffi.call/closure_fn1.c: Likewise.\n\t* testsuite/libffi.call/closure_fn2.c: Likewise.\n\t* testsuite/libffi.call/closure_fn3.c: Likewise.\n\t* testsuite/libffi.call/closure_fn4.c: Likewise.\n\t* testsuite/libffi.call/closure_fn5.c: Likewise.\n\t* testsuite/libffi.call/cls_12byte.c: Likewise.\n\t* testsuite/libffi.call/cls_16byte.c: Likewise.\n\t* testsuite/libffi.call/cls_18byte.c: Likewise.\n\t* testsuite/libffi.call/cls_19byte.c: Likewise.\n\t* testsuite/libffi.call/cls_1_1byte.c: Likewise.\n\t* testsuite/libffi.call/cls_20byte.c: Likewise.\n\t* testsuite/libffi.call/cls_20byte1.c: Likewise.\n\t* testsuite/libffi.call/cls_24byte.c: Likewise.\n\t* testsuite/libffi.call/cls_2byte.c: Likewise.\n\t* testsuite/libffi.call/cls_3_1byte.c: Likewise.\n\t* testsuite/libffi.call/cls_3byte1.c: Likewise.\n\t* testsuite/libffi.call/cls_3byte2.c: Likewise.\n\t* testsuite/libffi.call/cls_4_1byte.c: Likewise.\n\t* testsuite/libffi.call/cls_4byte.c: Likewise.\n\t* testsuite/libffi.call/cls_5byte.c: Likewise.\n\t* testsuite/libffi.call/cls_64byte.c: Likewise.\n\t* testsuite/libffi.call/cls_6byte.c: Likewise.\n\t* testsuite/libffi.call/cls_7byte.c: Likewise.\n\t* testsuite/libffi.call/cls_8byte.c: Likewise.\n\t* testsuite/libffi.call/cls_9byte1.c: Likewise.\n\t* testsuite/libffi.call/cls_9byte2.c: Likewise.\n\t* testsuite/libffi.call/cls_double.c: Likewise.\n\t* testsuite/libffi.call/cls_float.c: Likewise.\n\t* testsuite/libffi.call/cls_schar.c: Likewise.\n\t* testsuite/libffi.call/cls_sint.c: Likewise.\n\t* testsuite/libffi.call/cls_sshort.c: Likewise.\n\t* testsuite/libffi.call/cls_uchar.c: Likewise.\n\t* testsuite/libffi.call/cls_uint.c: Likewise.\n\t* testsuite/libffi.call/cls_ulonglong.c: Likewise.\n\t* testsuite/libffi.call/cls_ushort.c: Likewise.\n\t* testsuite/libffi.call/nested_struct.c: Likewise.\n\t* testsuite/libffi.call/nested_struct1.c: Likewise.\n\t* testsuite/libffi.call/nested_struct2.c: Likewise.\n\t* testsuite/libffi.call/nested_struct3.c: Likewise.\n\t* testsuite/libffi.call/problem1.c: Likewise.\n\t* testsuite/libffi.special/unwindtest.cc: Likewise.\n\nCo-Authored-By: Andreas Tobler <a.tobler@schweiz.ch>\n\nFrom-SVN: r73800", "tree": {"sha": "7adabf51161e3c6039138d3354924de2ffacadcc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7adabf51161e3c6039138d3354924de2ffacadcc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5196736e471495a372ba5583c53f16020eea10ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5196736e471495a372ba5583c53f16020eea10ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5196736e471495a372ba5583c53f16020eea10ca", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5196736e471495a372ba5583c53f16020eea10ca/comments", "author": {"login": "ajaeger", "id": 16867, "node_id": "MDQ6VXNlcjE2ODY3", "avatar_url": "https://avatars.githubusercontent.com/u/16867?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ajaeger", "html_url": "https://github.com/ajaeger", "followers_url": "https://api.github.com/users/ajaeger/followers", "following_url": "https://api.github.com/users/ajaeger/following{/other_user}", "gists_url": "https://api.github.com/users/ajaeger/gists{/gist_id}", "starred_url": "https://api.github.com/users/ajaeger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ajaeger/subscriptions", "organizations_url": "https://api.github.com/users/ajaeger/orgs", "repos_url": "https://api.github.com/users/ajaeger/repos", "events_url": "https://api.github.com/users/ajaeger/events{/privacy}", "received_events_url": "https://api.github.com/users/ajaeger/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4e074bafe630ebae34af074ae1c8b8d2830ccd3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e074bafe630ebae34af074ae1c8b8d2830ccd3d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e074bafe630ebae34af074ae1c8b8d2830ccd3d"}], "stats": {"total": 1242, "additions": 981, "deletions": 261}, "files": [{"sha": "cdcfd4adf3665a8a573d7da2225ba0eb967b1167", "filename": "libffi/ChangeLog", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FChangeLog?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -1,3 +1,59 @@\n+2003-11-21  Andreas Jaeger  <aj@suse.de>\n+\t    Andreas Tobler  <a.tobler@schweiz.ch>\n+\n+\t* acinclude.m4: Add AC_FUNC_MMAP_BLACKLIST.\n+\t* configure.in: Call AC_FUNC_MMAP_BLACKLIST.\n+\t* Makefile.in: Rebuilt.\n+\t* aclocal.m4: Likewise.\n+\t* configure: Likewise.\n+\t* fficonfig.h.in: Likewise.\n+\t* testsuite/lib/libffi-dg.exp: Add include dir.\n+\t* testsuite/libffi.call/ffitest.h: Add MMAP definitions.\n+\t* testsuite/libffi.special/ffitestcxx.h: Likewise.\n+\t* testsuite/libffi.call/closure_fn0.c: Use MMAP functionality\n+\tfor ffi_closure if available.\n+\t* testsuite/libffi.call/closure_fn1.c: Likewise.\n+\t* testsuite/libffi.call/closure_fn2.c: Likewise.\n+\t* testsuite/libffi.call/closure_fn3.c: Likewise.\n+\t* testsuite/libffi.call/closure_fn4.c: Likewise.\n+\t* testsuite/libffi.call/closure_fn5.c: Likewise.\n+\t* testsuite/libffi.call/cls_12byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_16byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_18byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_19byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_1_1byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_20byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_20byte1.c: Likewise.\n+\t* testsuite/libffi.call/cls_24byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_2byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_3_1byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_3byte1.c: Likewise.\n+\t* testsuite/libffi.call/cls_3byte2.c: Likewise.\n+\t* testsuite/libffi.call/cls_4_1byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_4byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_5byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_64byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_6byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_7byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_8byte.c: Likewise.\n+\t* testsuite/libffi.call/cls_9byte1.c: Likewise.\n+\t* testsuite/libffi.call/cls_9byte2.c: Likewise.\n+\t* testsuite/libffi.call/cls_double.c: Likewise.\n+\t* testsuite/libffi.call/cls_float.c: Likewise.\n+\t* testsuite/libffi.call/cls_schar.c: Likewise.\n+\t* testsuite/libffi.call/cls_sint.c: Likewise.\n+\t* testsuite/libffi.call/cls_sshort.c: Likewise.\n+\t* testsuite/libffi.call/cls_uchar.c: Likewise.\n+\t* testsuite/libffi.call/cls_uint.c: Likewise.\n+\t* testsuite/libffi.call/cls_ulonglong.c: Likewise.\n+\t* testsuite/libffi.call/cls_ushort.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct1.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct2.c: Likewise.\n+\t* testsuite/libffi.call/nested_struct3.c: Likewise.\n+\t* testsuite/libffi.call/problem1.c: Likewise.\n+\t* testsuite/libffi.special/unwindtest.cc: Likewise.\n+\n 2003-11-20  Andreas Tobler  <a.tobler@schweiz.ch>\n \n \t* testsuite/lib/libffi-dg.exp: Make the -lgcc_s conditional."}, {"sha": "212fcacd66af95583a05a7f0cc69de85e6fe312b", "filename": "libffi/Makefile.in", "status": "modified", "additions": 68, "deletions": 68, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2FMakefile.in?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -242,113 +242,113 @@ LDFLAGS = @LDFLAGS@\n LIBS = @LIBS@\n libffi_convenience_la_LDFLAGS = \n libffi_convenience_la_LIBADD = \n+@X86_64_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n+@X86_64_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n+@X86_64_TRUE@src/java_raw_api.lo src/x86/ffi64.lo src/x86/unix64.lo \\\n+@X86_64_TRUE@src/x86/ffi.lo src/x86/sysv.lo\n+@POWERPC_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n+@POWERPC_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n+@POWERPC_TRUE@src/java_raw_api.lo src/powerpc/ffi.lo \\\n+@POWERPC_TRUE@src/powerpc/sysv.lo src/powerpc/ppc_closure.lo \\\n+@POWERPC_TRUE@src/powerpc/linux64.lo src/powerpc/linux64_closure.lo\n+@SH_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@SH_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo src/sh/sysv.lo \\\n+@SH_TRUE@src/sh/ffi.lo\n @POWERPC_DARWIN_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n @POWERPC_DARWIN_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @POWERPC_DARWIN_TRUE@src/java_raw_api.lo src/powerpc/ffi_darwin.lo \\\n @POWERPC_DARWIN_TRUE@src/powerpc/darwin.lo \\\n @POWERPC_DARWIN_TRUE@src/powerpc/darwin_closure.lo\n-@S390_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@S390_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@S390_TRUE@src/s390/sysv.lo src/s390/ffi.lo\n-@IA64_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@IA64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@IA64_TRUE@src/ia64/ffi.lo src/ia64/unix.lo\n-@MIPS_IRIX_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n-@MIPS_IRIX_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n-@MIPS_IRIX_TRUE@src/java_raw_api.lo src/mips/ffi.lo src/mips/o32.lo \\\n-@MIPS_IRIX_TRUE@src/mips/n32.lo\n+@M68K_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@M68K_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@M68K_TRUE@src/m68k/ffi.lo src/m68k/sysv.lo\n+@SPARC_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n+@SPARC_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n+@SPARC_TRUE@src/java_raw_api.lo src/sparc/ffi.lo src/sparc/v8.lo \\\n+@SPARC_TRUE@src/sparc/v9.lo\n+@X86_WIN32_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n+@X86_WIN32_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n+@X86_WIN32_TRUE@src/java_raw_api.lo src/x86/ffi.lo src/x86/win32.lo\n+@ARM_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@ARM_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@ARM_TRUE@src/arm/sysv.lo src/arm/ffi.lo\n @ALPHA_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n @ALPHA_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @ALPHA_TRUE@src/java_raw_api.lo src/alpha/ffi.lo src/alpha/osf.lo\n+@S390_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@S390_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@S390_TRUE@src/s390/sysv.lo src/s390/ffi.lo\n @POWERPC_AIX_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n @POWERPC_AIX_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @POWERPC_AIX_TRUE@src/java_raw_api.lo src/powerpc/ffi_darwin.lo \\\n @POWERPC_AIX_TRUE@src/powerpc/aix.lo src/powerpc/aix_closure.lo\n-@X86_WIN32_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n-@X86_WIN32_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n-@X86_WIN32_TRUE@src/java_raw_api.lo src/x86/ffi.lo src/x86/win32.lo\n+@IA64_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@IA64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@IA64_TRUE@src/ia64/ffi.lo src/ia64/unix.lo\n @SH64_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @SH64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @SH64_TRUE@src/sh64/sysv.lo src/sh64/ffi.lo\n-@X86_64_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n-@X86_64_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n-@X86_64_TRUE@src/java_raw_api.lo src/x86/ffi64.lo src/x86/unix64.lo \\\n-@X86_64_TRUE@src/x86/ffi.lo src/x86/sysv.lo\n-@ARM_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@ARM_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@ARM_TRUE@src/arm/sysv.lo src/arm/ffi.lo\n-@SPARC_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n-@SPARC_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n-@SPARC_TRUE@src/java_raw_api.lo src/sparc/ffi.lo src/sparc/v8.lo \\\n-@SPARC_TRUE@src/sparc/v9.lo\n-@M68K_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@M68K_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@M68K_TRUE@src/m68k/ffi.lo src/m68k/sysv.lo\n-@POWERPC_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n-@POWERPC_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n-@POWERPC_TRUE@src/java_raw_api.lo src/powerpc/ffi.lo \\\n-@POWERPC_TRUE@src/powerpc/sysv.lo src/powerpc/ppc_closure.lo \\\n-@POWERPC_TRUE@src/powerpc/linux64.lo src/powerpc/linux64_closure.lo\n+@MIPS_IRIX_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n+@MIPS_IRIX_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n+@MIPS_IRIX_TRUE@src/java_raw_api.lo src/mips/ffi.lo src/mips/o32.lo \\\n+@MIPS_IRIX_TRUE@src/mips/n32.lo\n @MIPS_LINUX_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo \\\n @MIPS_LINUX_TRUE@src/prep_cif.lo src/types.lo src/raw_api.lo \\\n @MIPS_LINUX_TRUE@src/java_raw_api.lo src/mips/ffi.lo src/mips/o32.lo\n-@SH_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@SH_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo src/sh/sysv.lo \\\n-@SH_TRUE@src/sh/ffi.lo\n @X86_TRUE@libffi_convenience_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @X86_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @X86_TRUE@src/x86/ffi.lo src/x86/sysv.lo\n libffi_la_LIBADD = \n+@X86_64_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@X86_64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@X86_64_TRUE@src/x86/ffi64.lo src/x86/unix64.lo src/x86/ffi.lo \\\n+@X86_64_TRUE@src/x86/sysv.lo\n+@POWERPC_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@POWERPC_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@POWERPC_TRUE@src/powerpc/ffi.lo src/powerpc/sysv.lo \\\n+@POWERPC_TRUE@src/powerpc/ppc_closure.lo src/powerpc/linux64.lo \\\n+@POWERPC_TRUE@src/powerpc/linux64_closure.lo\n+@SH_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo src/types.lo \\\n+@SH_TRUE@src/raw_api.lo src/java_raw_api.lo src/sh/sysv.lo \\\n+@SH_TRUE@src/sh/ffi.lo\n @POWERPC_DARWIN_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @POWERPC_DARWIN_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @POWERPC_DARWIN_TRUE@src/powerpc/ffi_darwin.lo src/powerpc/darwin.lo \\\n @POWERPC_DARWIN_TRUE@src/powerpc/darwin_closure.lo\n-@S390_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@S390_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@S390_TRUE@src/s390/sysv.lo src/s390/ffi.lo\n-@IA64_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@IA64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@IA64_TRUE@src/ia64/ffi.lo src/ia64/unix.lo\n-@MIPS_IRIX_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@MIPS_IRIX_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@MIPS_IRIX_TRUE@src/mips/ffi.lo src/mips/o32.lo src/mips/n32.lo\n+@M68K_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@M68K_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@M68K_TRUE@src/m68k/ffi.lo src/m68k/sysv.lo\n+@SPARC_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@SPARC_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@SPARC_TRUE@src/sparc/ffi.lo src/sparc/v8.lo src/sparc/v9.lo\n+@X86_WIN32_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@X86_WIN32_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@X86_WIN32_TRUE@src/x86/ffi.lo src/x86/win32.lo\n+@ARM_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo src/types.lo \\\n+@ARM_TRUE@src/raw_api.lo src/java_raw_api.lo src/arm/sysv.lo \\\n+@ARM_TRUE@src/arm/ffi.lo\n @ALPHA_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @ALPHA_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @ALPHA_TRUE@src/alpha/ffi.lo src/alpha/osf.lo\n+@S390_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@S390_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@S390_TRUE@src/s390/sysv.lo src/s390/ffi.lo\n @POWERPC_AIX_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @POWERPC_AIX_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @POWERPC_AIX_TRUE@src/powerpc/ffi_darwin.lo src/powerpc/aix.lo \\\n @POWERPC_AIX_TRUE@src/powerpc/aix_closure.lo\n-@X86_WIN32_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@X86_WIN32_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@X86_WIN32_TRUE@src/x86/ffi.lo src/x86/win32.lo\n+@IA64_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@IA64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@IA64_TRUE@src/ia64/ffi.lo src/ia64/unix.lo\n @SH64_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @SH64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @SH64_TRUE@src/sh64/sysv.lo src/sh64/ffi.lo\n-@X86_64_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@X86_64_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@X86_64_TRUE@src/x86/ffi64.lo src/x86/unix64.lo src/x86/ffi.lo \\\n-@X86_64_TRUE@src/x86/sysv.lo\n-@ARM_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo src/types.lo \\\n-@ARM_TRUE@src/raw_api.lo src/java_raw_api.lo src/arm/sysv.lo \\\n-@ARM_TRUE@src/arm/ffi.lo\n-@SPARC_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@SPARC_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@SPARC_TRUE@src/sparc/ffi.lo src/sparc/v8.lo src/sparc/v9.lo\n-@M68K_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@M68K_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@M68K_TRUE@src/m68k/ffi.lo src/m68k/sysv.lo\n-@POWERPC_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n-@POWERPC_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n-@POWERPC_TRUE@src/powerpc/ffi.lo src/powerpc/sysv.lo \\\n-@POWERPC_TRUE@src/powerpc/ppc_closure.lo src/powerpc/linux64.lo \\\n-@POWERPC_TRUE@src/powerpc/linux64_closure.lo\n+@MIPS_IRIX_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n+@MIPS_IRIX_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n+@MIPS_IRIX_TRUE@src/mips/ffi.lo src/mips/o32.lo src/mips/n32.lo\n @MIPS_LINUX_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo \\\n @MIPS_LINUX_TRUE@src/types.lo src/raw_api.lo src/java_raw_api.lo \\\n @MIPS_LINUX_TRUE@src/mips/ffi.lo src/mips/o32.lo\n-@SH_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo src/types.lo \\\n-@SH_TRUE@src/raw_api.lo src/java_raw_api.lo src/sh/sysv.lo \\\n-@SH_TRUE@src/sh/ffi.lo\n @X86_TRUE@libffi_la_OBJECTS =  src/debug.lo src/prep_cif.lo src/types.lo \\\n @X86_TRUE@src/raw_api.lo src/java_raw_api.lo src/x86/ffi.lo \\\n @X86_TRUE@src/x86/sysv.lo"}, {"sha": "90896098c70ff370bd61fe1cad43b758f054125c", "filename": "libffi/acinclude.m4", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Facinclude.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Facinclude.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Facinclude.m4?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -8,4 +8,93 @@ AC_DEFUN([AM_PROG_LIBTOOL],)\n AC_SUBST(LIBTOOL)\n ])\n \n+# mmap(2) blacklisting.  Some platforms provide the mmap library routine\n+# but don't support all of the features we need from it.\n+AC_DEFUN([AC_FUNC_MMAP_BLACKLIST],\n+[if test $ac_cv_header_sys_mman_h != yes \\\n+ || test $ac_cv_func_mmap != yes; then\n+   ac_cv_func_mmap_file=no\n+   ac_cv_func_mmap_dev_zero=no\n+   ac_cv_func_mmap_anon=no\n+else\n+   AC_CACHE_CHECK([whether read-only mmap of a plain file works],\n+  ac_cv_func_mmap_file,\n+  [# Add a system to this blacklist if\n+   # mmap(0, stat_size, PROT_READ, MAP_PRIVATE, fd, 0) doesn't return a\n+   # memory area containing the same data that you'd get if you applied\n+   # read() to the same fd.  The only system known to have a problem here\n+   # is VMS, where text files have record structure.\n+   case \"$host_os\" in\n+     vms* | ultrix*)\n+\tac_cv_func_mmap_file=no ;;\n+     *)\n+\tac_cv_func_mmap_file=yes;;\n+   esac])\n+   AC_CACHE_CHECK([whether mmap from /dev/zero works],\n+  ac_cv_func_mmap_dev_zero,\n+  [# Add a system to this blacklist if it has mmap() but /dev/zero\n+   # does not exist, or if mmapping /dev/zero does not give anonymous\n+   # zeroed pages with both the following properties:\n+   # 1. If you map N consecutive pages in with one call, and then\n+   #    unmap any subset of those pages, the pages that were not\n+   #    explicitly unmapped remain accessible.\n+   # 2. If you map two adjacent blocks of memory and then unmap them\n+   #    both at once, they must both go away.\n+   # Systems known to be in this category are Windows (all variants),\n+   # VMS, and Darwin.\n+   case \"$host_os\" in\n+     vms* | cygwin* | pe | mingw* | darwin* | ultrix* | hpux10* | hpux11.00)\n+\tac_cv_func_mmap_dev_zero=no ;;\n+     *)\n+\tac_cv_func_mmap_dev_zero=yes;;\n+   esac])\n+\n+   # Unlike /dev/zero, the MAP_ANON(YMOUS) defines can be probed for.\n+   AC_CACHE_CHECK([for MAP_ANON(YMOUS)], ac_cv_decl_map_anon,\n+    [AC_TRY_COMPILE(\n+[#include <sys/types.h>\n+#include <sys/mman.h>\n+#include <unistd.h>\n+\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+],\n+[int n = MAP_ANONYMOUS;],\n+    ac_cv_decl_map_anon=yes,\n+    ac_cv_decl_map_anon=no)])\n+\n+   if test $ac_cv_decl_map_anon = no; then\n+     ac_cv_func_mmap_anon=no\n+   else\n+     AC_CACHE_CHECK([whether mmap with MAP_ANON(YMOUS) works],\n+     ac_cv_func_mmap_anon,\n+  [# Add a system to this blacklist if it has mmap() and MAP_ANON or\n+   # MAP_ANONYMOUS, but using mmap(..., MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)\n+   # doesn't give anonymous zeroed pages with the same properties listed\n+   # above for use of /dev/zero.\n+   # Systems known to be in this category are Windows, VMS, and SCO Unix.\n+   case \"$host_os\" in\n+     vms* | cygwin* | pe | mingw* | sco* | udk* )\n+\tac_cv_func_mmap_anon=no ;;\n+     *)\n+\tac_cv_func_mmap_anon=yes;;\n+   esac])\n+   fi\n+fi\n+\n+if test $ac_cv_func_mmap_file = yes; then\n+  AC_DEFINE(HAVE_MMAP_FILE, 1,\n+\t    [Define if read-only mmap of a plain file works.])\n+fi\n+if test $ac_cv_func_mmap_dev_zero = yes; then\n+  AC_DEFINE(HAVE_MMAP_DEV_ZERO, 1,\n+\t    [Define if mmap of /dev/zero works.])\n+fi\n+if test $ac_cv_func_mmap_anon = yes; then\n+  AC_DEFINE(HAVE_MMAP_ANON, 1,\n+\t    [Define if mmap with MAP_ANON(YMOUS) works.])\n+fi\n+])\n+\n sinclude(../config/accross.m4)"}, {"sha": "7dabcced86df9e3ab06029172633e0a98e3e4fe9", "filename": "libffi/aclocal.m4", "status": "modified", "additions": 97, "deletions": 8, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Faclocal.m4", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Faclocal.m4", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Faclocal.m4?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -1,6 +1,6 @@\n-dnl aclocal.m4 generated automatically by aclocal 1.4-p5\n+dnl aclocal.m4 generated automatically by aclocal 1.4\n \n-dnl Copyright (C) 1994, 1995-8, 1999, 2001 Free Software Foundation, Inc.\n+dnl Copyright (C) 1994, 1995-8, 1999 Free Software Foundation, Inc.\n dnl This file is free software; the Free Software Foundation\n dnl gives unlimited permission to copy and/or distribute it,\n dnl with or without modifications, as long as this notice is preserved.\n@@ -20,11 +20,100 @@ AC_DEFUN([AM_PROG_LIBTOOL],)\n AC_SUBST(LIBTOOL)\n ])\n \n+# mmap(2) blacklisting.  Some platforms provide the mmap library routine\n+# but don't support all of the features we need from it.\n+AC_DEFUN([AC_FUNC_MMAP_BLACKLIST],\n+[if test $ac_cv_header_sys_mman_h != yes \\\n+ || test $ac_cv_func_mmap != yes; then\n+   ac_cv_func_mmap_file=no\n+   ac_cv_func_mmap_dev_zero=no\n+   ac_cv_func_mmap_anon=no\n+else\n+   AC_CACHE_CHECK([whether read-only mmap of a plain file works],\n+  ac_cv_func_mmap_file,\n+  [# Add a system to this blacklist if\n+   # mmap(0, stat_size, PROT_READ, MAP_PRIVATE, fd, 0) doesn't return a\n+   # memory area containing the same data that you'd get if you applied\n+   # read() to the same fd.  The only system known to have a problem here\n+   # is VMS, where text files have record structure.\n+   case \"$host_os\" in\n+     vms* | ultrix*)\n+\tac_cv_func_mmap_file=no ;;\n+     *)\n+\tac_cv_func_mmap_file=yes;;\n+   esac])\n+   AC_CACHE_CHECK([whether mmap from /dev/zero works],\n+  ac_cv_func_mmap_dev_zero,\n+  [# Add a system to this blacklist if it has mmap() but /dev/zero\n+   # does not exist, or if mmapping /dev/zero does not give anonymous\n+   # zeroed pages with both the following properties:\n+   # 1. If you map N consecutive pages in with one call, and then\n+   #    unmap any subset of those pages, the pages that were not\n+   #    explicitly unmapped remain accessible.\n+   # 2. If you map two adjacent blocks of memory and then unmap them\n+   #    both at once, they must both go away.\n+   # Systems known to be in this category are Windows (all variants),\n+   # VMS, and Darwin.\n+   case \"$host_os\" in\n+     vms* | cygwin* | pe | mingw* | darwin* | ultrix* | hpux10* | hpux11.00)\n+\tac_cv_func_mmap_dev_zero=no ;;\n+     *)\n+\tac_cv_func_mmap_dev_zero=yes;;\n+   esac])\n+\n+   # Unlike /dev/zero, the MAP_ANON(YMOUS) defines can be probed for.\n+   AC_CACHE_CHECK([for MAP_ANON(YMOUS)], ac_cv_decl_map_anon,\n+    [AC_TRY_COMPILE(\n+[#include <sys/types.h>\n+#include <sys/mman.h>\n+#include <unistd.h>\n+\n+#ifndef MAP_ANONYMOUS\n+#define MAP_ANONYMOUS MAP_ANON\n+#endif\n+],\n+[int n = MAP_ANONYMOUS;],\n+    ac_cv_decl_map_anon=yes,\n+    ac_cv_decl_map_anon=no)])\n+\n+   if test $ac_cv_decl_map_anon = no; then\n+     ac_cv_func_mmap_anon=no\n+   else\n+     AC_CACHE_CHECK([whether mmap with MAP_ANON(YMOUS) works],\n+     ac_cv_func_mmap_anon,\n+  [# Add a system to this blacklist if it has mmap() and MAP_ANON or\n+   # MAP_ANONYMOUS, but using mmap(..., MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)\n+   # doesn't give anonymous zeroed pages with the same properties listed\n+   # above for use of /dev/zero.\n+   # Systems known to be in this category are Windows, VMS, and SCO Unix.\n+   case \"$host_os\" in\n+     vms* | cygwin* | pe | mingw* | sco* | udk* )\n+\tac_cv_func_mmap_anon=no ;;\n+     *)\n+\tac_cv_func_mmap_anon=yes;;\n+   esac])\n+   fi\n+fi\n+\n+if test $ac_cv_func_mmap_file = yes; then\n+  AC_DEFINE(HAVE_MMAP_FILE, 1,\n+\t    [Define if read-only mmap of a plain file works.])\n+fi\n+if test $ac_cv_func_mmap_dev_zero = yes; then\n+  AC_DEFINE(HAVE_MMAP_DEV_ZERO, 1,\n+\t    [Define if mmap of /dev/zero works.])\n+fi\n+if test $ac_cv_func_mmap_anon = yes; then\n+  AC_DEFINE(HAVE_MMAP_ANON, 1,\n+\t    [Define if mmap with MAP_ANON(YMOUS) works.])\n+fi\n+])\n+\n sinclude(../config/accross.m4)\n \n # Like AC_CONFIG_HEADER, but automatically create stamp file.\n \n-AC_DEFUN([AM_CONFIG_HEADER],\n+AC_DEFUN(AM_CONFIG_HEADER,\n [AC_PREREQ([2.12])\n AC_CONFIG_HEADER([$1])\n dnl When config.status generates a header, we must update the stamp-h file.\n@@ -54,7 +143,7 @@ changequote([,]))])\n dnl Usage:\n dnl AM_INIT_AUTOMAKE(package,version, [no-define])\n \n-AC_DEFUN([AM_INIT_AUTOMAKE],\n+AC_DEFUN(AM_INIT_AUTOMAKE,\n [AC_REQUIRE([AC_PROG_INSTALL])\n PACKAGE=[$1]\n AC_SUBST(PACKAGE)\n@@ -82,7 +171,7 @@ AC_REQUIRE([AC_PROG_MAKE_SET])])\n # Check to make sure that the build environment is sane.\n #\n \n-AC_DEFUN([AM_SANITY_CHECK],\n+AC_DEFUN(AM_SANITY_CHECK,\n [AC_MSG_CHECKING([whether build environment is sane])\n # Just in case\n sleep 1\n@@ -123,7 +212,7 @@ AC_MSG_RESULT(yes)])\n \n dnl AM_MISSING_PROG(NAME, PROGRAM, DIRECTORY)\n dnl The program must properly implement --version.\n-AC_DEFUN([AM_MISSING_PROG],\n+AC_DEFUN(AM_MISSING_PROG,\n [AC_MSG_CHECKING(for working $2)\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n@@ -142,7 +231,7 @@ AC_SUBST($1)])\n \n # serial 1\n \n-AC_DEFUN([AM_MAINTAINER_MODE],\n+AC_DEFUN(AM_MAINTAINER_MODE,\n [AC_MSG_CHECKING([whether to enable maintainer-specific portions of Makefiles])\n   dnl maintainer-mode is disabled by default\n   AC_ARG_ENABLE(maintainer-mode,\n@@ -159,7 +248,7 @@ AC_DEFUN([AM_MAINTAINER_MODE],\n \n # Define a conditional.\n \n-AC_DEFUN([AM_CONDITIONAL],\n+AC_DEFUN(AM_CONDITIONAL,\n [AC_SUBST($1_TRUE)\n AC_SUBST($1_FALSE)\n if $2; then"}, {"sha": "8e09442d7a859542dd965d30b74912e4eb38e5a4", "filename": "libffi/configure", "status": "modified", "additions": 94, "deletions": 91, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -1250,6 +1250,7 @@ cygwin* | mingw* |pw32*)\n   ;;\n \n darwin* | rhapsody*)\n+  # this will be overwritten by pass_all, but leave it in just in case\n   lt_cv_deplibs_check_method='file_magic Mach-O dynamically linked shared library'\n   lt_cv_file_magic_cmd='/usr/bin/file -L'\n   case \"$host_os\" in\n@@ -1260,6 +1261,7 @@ darwin* | rhapsody*)\n     lt_cv_file_magic_test_file='/usr/lib/libSystem.dylib'\n     ;;\n   esac\n+  lt_cv_deplibs_check_method=pass_all\n   ;;\n \n freebsd* )\n@@ -1384,13 +1386,13 @@ file_magic_cmd=$lt_cv_file_magic_cmd\n deplibs_check_method=$lt_cv_deplibs_check_method\n \n echo $ac_n \"checking for object suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1388: checking for object suffix\" >&5\n+echo \"configure:1390: checking for object suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_objext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   rm -f conftest*\n echo 'int i = 1;' > conftest.$ac_ext\n-if { (eval echo configure:1394: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:1396: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   for ac_file in conftest.*; do\n     case $ac_file in\n     *.c) ;;\n@@ -1410,7 +1412,7 @@ ac_objext=$ac_cv_objext\n \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:1414: checking for executable suffix\" >&5\n+echo \"configure:1416: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1420,7 +1422,7 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:1424: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:1426: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n       *.c | *.o | *.obj) ;;\n@@ -1453,7 +1455,7 @@ case $deplibs_check_method in\n file_magic*)\n   if test \"$file_magic_cmd\" = '$MAGIC_CMD'; then\n     echo $ac_n \"checking for ${ac_tool_prefix}file\"\"... $ac_c\" 1>&6\n-echo \"configure:1457: checking for ${ac_tool_prefix}file\" >&5\n+echo \"configure:1459: checking for ${ac_tool_prefix}file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1515,7 +1517,7 @@ fi\n if test -z \"$lt_cv_path_MAGIC_CMD\"; then\n   if test -n \"$ac_tool_prefix\"; then\n     echo $ac_n \"checking for file\"\"... $ac_c\" 1>&6\n-echo \"configure:1519: checking for file\" >&5\n+echo \"configure:1521: checking for file\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_path_MAGIC_CMD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1586,7 +1588,7 @@ esac\n # Extract the first word of \"${ac_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1590: checking for $ac_word\" >&5\n+echo \"configure:1592: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1618,7 +1620,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1622: checking for $ac_word\" >&5\n+echo \"configure:1624: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1653,7 +1655,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}strip\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1657: checking for $ac_word\" >&5\n+echo \"configure:1659: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1685,7 +1687,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"strip\", so it can be a program name with args.\n set dummy strip; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1689: checking for $ac_word\" >&5\n+echo \"configure:1691: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_STRIP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1752,8 +1754,8 @@ test x\"$pic_mode\" = xno && libtool_flags=\"$libtool_flags --prefer-non-pic\"\n case $host in\n *-*-irix6*)\n   # Find out which ABI we are using.\n-  echo '#line 1756 \"configure\"' > conftest.$ac_ext\n-  if { (eval echo configure:1757: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  echo '#line 1758 \"configure\"' > conftest.$ac_ext\n+  if { (eval echo configure:1759: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n    if test \"$lt_cv_prog_gnu_ld\" = yes; then\n     case `/usr/bin/file conftest.$ac_objext` in\n     *32-bit*)\n@@ -1786,7 +1788,7 @@ case $host in\n ia64-*-hpux*)\n   # Find out which ABI we are using.\n   echo 'int i;' > conftest.$ac_ext\n-  if { (eval echo configure:1790: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  if { (eval echo configure:1792: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n     case \"`/usr/bin/file conftest.o`\" in\n     *ELF-32*)\n       HPUX_IA64_MODE=\"32\"\n@@ -1802,7 +1804,7 @@ ia64-*-hpux*)\n x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*|s390*-*linux*|sparc*-*linux*)\n   # Find out which ABI we are using.\n   echo 'int i;' > conftest.$ac_ext\n-  if { (eval echo configure:1806: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  if { (eval echo configure:1808: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n     case \"`/usr/bin/file conftest.o`\" in\n     *32-bit*)\n       case $host in\n@@ -1846,7 +1848,7 @@ x86_64-*linux*|ppc*-*linux*|powerpc*-*linux*|s390*-*linux*|sparc*-*linux*)\n   SAVE_CFLAGS=\"$CFLAGS\"\n   CFLAGS=\"$CFLAGS -belf\"\n   echo $ac_n \"checking whether the C compiler needs -belf\"\"... $ac_c\" 1>&6\n-echo \"configure:1850: checking whether the C compiler needs -belf\" >&5\n+echo \"configure:1852: checking whether the C compiler needs -belf\" >&5\n if eval \"test \\\"`echo '$''{'lt_cv_cc_needs_belf'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1859,14 +1861,14 @@ ac_link='${CC-cc} -o conftest${ac_exeext} $CFLAGS $CPPFLAGS $LDFLAGS conftest.$a\n cross_compiling=$ac_cv_prog_cc_cross\n \n      cat > conftest.$ac_ext <<EOF\n-#line 1863 \"configure\"\n+#line 1865 \"configure\"\n #include \"confdefs.h\"\n \n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:1870: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:1872: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   lt_cv_cc_needs_belf=yes\n else\n@@ -1994,7 +1996,7 @@ exec 5>>./config.log\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:1998: checking for a BSD compatible install\" >&5\n+echo \"configure:2000: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -2047,7 +2049,7 @@ test -z \"$INSTALL_SCRIPT\" && INSTALL_SCRIPT='${INSTALL_PROGRAM}'\n test -z \"$INSTALL_DATA\" && INSTALL_DATA='${INSTALL} -m 644'\n \n echo $ac_n \"checking whether build environment is sane\"\"... $ac_c\" 1>&6\n-echo \"configure:2051: checking whether build environment is sane\" >&5\n+echo \"configure:2053: checking whether build environment is sane\" >&5\n # Just in case\n sleep 1\n echo timestamp > conftestfile\n@@ -2104,7 +2106,7 @@ test \"$program_suffix\" != NONE &&\n test \"$program_transform_name\" = \"\" && program_transform_name=\"s,x,x,\"\n \n echo $ac_n \"checking whether ${MAKE-make} sets \\${MAKE}\"\"... $ac_c\" 1>&6\n-echo \"configure:2108: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n+echo \"configure:2110: checking whether ${MAKE-make} sets \\${MAKE}\" >&5\n set dummy ${MAKE-make}; ac_make=`echo \"$2\" | sed 'y%./+-%__p_%'`\n if eval \"test \\\"`echo '$''{'ac_cv_prog_make_${ac_make}_set'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -2143,7 +2145,7 @@ fi\n \n missing_dir=`cd $ac_aux_dir && pwd`\n echo $ac_n \"checking for working aclocal\"\"... $ac_c\" 1>&6\n-echo \"configure:2147: checking for working aclocal\" >&5\n+echo \"configure:2149: checking for working aclocal\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -2156,7 +2158,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoconf\"\"... $ac_c\" 1>&6\n-echo \"configure:2160: checking for working autoconf\" >&5\n+echo \"configure:2162: checking for working autoconf\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -2169,7 +2171,7 @@ else\n fi\n \n echo $ac_n \"checking for working automake\"\"... $ac_c\" 1>&6\n-echo \"configure:2173: checking for working automake\" >&5\n+echo \"configure:2175: checking for working automake\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -2182,7 +2184,7 @@ else\n fi\n \n echo $ac_n \"checking for working autoheader\"\"... $ac_c\" 1>&6\n-echo \"configure:2186: checking for working autoheader\" >&5\n+echo \"configure:2188: checking for working autoheader\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -2195,7 +2197,7 @@ else\n fi\n \n echo $ac_n \"checking for working makeinfo\"\"... $ac_c\" 1>&6\n-echo \"configure:2199: checking for working makeinfo\" >&5\n+echo \"configure:2201: checking for working makeinfo\" >&5\n # Run test in a subshell; some versions of sh will print an error if\n # an executable is not found, even if stderr is redirected.\n # Redirect stdin to placate older versions of autoconf.  Sigh.\n@@ -2212,7 +2214,7 @@ fi\n \n \n echo $ac_n \"checking for executable suffix\"\"... $ac_c\" 1>&6\n-echo \"configure:2216: checking for executable suffix\" >&5\n+echo \"configure:2218: checking for executable suffix\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_exeext'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2222,7 +2224,7 @@ else\n   rm -f conftest*\n   echo 'int main () { return 0; }' > conftest.$ac_ext\n   ac_cv_exeext=\n-  if { (eval echo configure:2226: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n+  if { (eval echo configure:2228: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; }; then\n     for file in conftest.*; do\n       case $file in\n       *.c | *.o | *.obj) ;;\n@@ -2243,7 +2245,7 @@ echo \"$ac_t\"\"${ac_cv_exeext}\" 1>&6\n ac_exeext=$EXEEXT\n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:2247: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:2249: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n     # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -2269,7 +2271,7 @@ fi\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2273: checking for $ac_word\" >&5\n+echo \"configure:2275: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2299,7 +2301,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2303: checking for $ac_word\" >&5\n+echo \"configure:2305: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2350,7 +2352,7 @@ fi\n       # Extract the first word of \"cl\", so it can be a program name with args.\n set dummy cl; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2354: checking for $ac_word\" >&5\n+echo \"configure:2356: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2382,7 +2384,7 @@ fi\n fi\n \n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\"\"... $ac_c\" 1>&6\n-echo \"configure:2386: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n+echo \"configure:2388: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n \n ac_ext=c\n # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.\n@@ -2393,12 +2395,12 @@ cross_compiling=$ac_cv_prog_cc_cross\n \n cat > conftest.$ac_ext << EOF\n \n-#line 2397 \"configure\"\n+#line 2399 \"configure\"\n #include \"confdefs.h\"\n \n main(){return(0);}\n EOF\n-if { (eval echo configure:2402: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2404: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   ac_cv_prog_cc_works=yes\n   # If we can't run a trivial program, we are probably using a cross compiler.\n   if (./conftest; exit) 2>/dev/null; then\n@@ -2424,12 +2426,12 @@ if test $ac_cv_prog_cc_works = no; then\n   { echo \"configure: error: installation or configuration problem: C compiler cannot create executables.\" 1>&2; exit 1; }\n fi\n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\"\"... $ac_c\" 1>&6\n-echo \"configure:2428: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n+echo \"configure:2430: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n echo \"$ac_t\"\"$ac_cv_prog_cc_cross\" 1>&6\n cross_compiling=$ac_cv_prog_cc_cross\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:2433: checking whether we are using GNU C\" >&5\n+echo \"configure:2435: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2438,7 +2440,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2442: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2444: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -2457,7 +2459,7 @@ ac_test_CFLAGS=\"${CFLAGS+set}\"\n ac_save_CFLAGS=\"$CFLAGS\"\n CFLAGS=\n echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:2461: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:2463: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2495,6 +2497,8 @@ fi\n \t \n \t \n \n+AC_FUNC_MMAP_BLACKLIST\n+\n \n \n if test -d $srcdir/testsuite; then\n@@ -2697,7 +2701,7 @@ case x$TARGET in\n esac\n \n echo $ac_n \"checking how to run the C preprocessor\"\"... $ac_c\" 1>&6\n-echo \"configure:2701: checking how to run the C preprocessor\" >&5\n+echo \"configure:2705: checking how to run the C preprocessor\" >&5\n # On Suns, sometimes $CPP names a directory.\n if test -n \"$CPP\" && test -d \"$CPP\"; then\n   CPP=\n@@ -2712,13 +2716,13 @@ else\n   # On the NeXT, cc -E runs the code through the compiler's parser,\n   # not just through cpp.\n   cat > conftest.$ac_ext <<EOF\n-#line 2716 \"configure\"\n+#line 2720 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2722: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2726: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2729,13 +2733,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -E -traditional-cpp\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2733 \"configure\"\n+#line 2737 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2739: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2743: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2746,13 +2750,13 @@ else\n   rm -rf conftest*\n   CPP=\"${CC-cc} -nologo -E\"\n   cat > conftest.$ac_ext <<EOF\n-#line 2750 \"configure\"\n+#line 2754 \"configure\"\n #include \"confdefs.h\"\n #include <assert.h>\n Syntax Error\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2756: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2760: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   :\n@@ -2777,20 +2781,20 @@ fi\n echo \"$ac_t\"\"$CPP\" 1>&6\n \n echo $ac_n \"checking for ANSI C header files\"\"... $ac_c\" 1>&6\n-echo \"configure:2781: checking for ANSI C header files\" >&5\n+echo \"configure:2785: checking for ANSI C header files\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_stdc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2786 \"configure\"\n+#line 2790 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n #include <stdarg.h>\n #include <string.h>\n #include <float.h>\n EOF\n ac_try=\"$ac_cpp conftest.$ac_ext >/dev/null 2>conftest.out\"\n-{ (eval echo configure:2794: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n+{ (eval echo configure:2798: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }\n ac_err=`grep -v '^ *+' conftest.out | grep -v \"^conftest.${ac_ext}\\$\"`\n if test -z \"$ac_err\"; then\n   rm -rf conftest*\n@@ -2807,7 +2811,7 @@ rm -f conftest*\n if test $ac_cv_header_stdc = yes; then\n   # SunOS 4.x string.h does not declare mem*, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 2811 \"configure\"\n+#line 2815 \"configure\"\n #include \"confdefs.h\"\n #include <string.h>\n EOF\n@@ -2825,7 +2829,7 @@ fi\n if test $ac_cv_header_stdc = yes; then\n   # ISC 2.0.2 stdlib.h does not declare free, contrary to ANSI.\n cat > conftest.$ac_ext <<EOF\n-#line 2829 \"configure\"\n+#line 2833 \"configure\"\n #include \"confdefs.h\"\n #include <stdlib.h>\n EOF\n@@ -2846,7 +2850,7 @@ if test \"$cross_compiling\" = yes; then\n   :\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2850 \"configure\"\n+#line 2854 \"configure\"\n #include \"confdefs.h\"\n #include <ctype.h>\n #define ISLOWER(c) ('a' <= (c) && (c) <= 'z')\n@@ -2857,7 +2861,7 @@ if (XOR (islower (i), ISLOWER (i)) || toupper (i) != TOUPPER (i)) exit(2);\n exit (0); }\n \n EOF\n-if { (eval echo configure:2861: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:2865: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   :\n else\n@@ -2883,12 +2887,12 @@ fi\n for ac_func in memcpy\n do\n echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:2887: checking for $ac_func\" >&5\n+echo \"configure:2891: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2892 \"configure\"\n+#line 2896 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -2911,7 +2915,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:2915: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2919: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -2938,19 +2942,19 @@ done\n # The Ultrix 4.2 mips builtin alloca declared by alloca.h only works\n # for constant arguments.  Useless!\n echo $ac_n \"checking for working alloca.h\"\"... $ac_c\" 1>&6\n-echo \"configure:2942: checking for working alloca.h\" >&5\n+echo \"configure:2946: checking for working alloca.h\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_header_alloca_h'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2947 \"configure\"\n+#line 2951 \"configure\"\n #include \"confdefs.h\"\n #include <alloca.h>\n int main() {\n char *p = alloca(2 * sizeof(int));\n ; return 0; }\n EOF\n-if { (eval echo configure:2954: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2958: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_header_alloca_h=yes\n else\n@@ -2971,12 +2975,12 @@ EOF\n fi\n \n echo $ac_n \"checking for alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:2975: checking for alloca\" >&5\n+echo \"configure:2979: checking for alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_alloca_works'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 2980 \"configure\"\n+#line 2984 \"configure\"\n #include \"confdefs.h\"\n \n #ifdef __GNUC__\n@@ -3004,7 +3008,7 @@ int main() {\n char *p = (char *) alloca(1);\n ; return 0; }\n EOF\n-if { (eval echo configure:3008: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3012: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   ac_cv_func_alloca_works=yes\n else\n@@ -3036,12 +3040,12 @@ EOF\n \n \n echo $ac_n \"checking whether alloca needs Cray hooks\"\"... $ac_c\" 1>&6\n-echo \"configure:3040: checking whether alloca needs Cray hooks\" >&5\n+echo \"configure:3044: checking whether alloca needs Cray hooks\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_os_cray'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3045 \"configure\"\n+#line 3049 \"configure\"\n #include \"confdefs.h\"\n #if defined(CRAY) && ! defined(CRAY2)\n webecray\n@@ -3066,12 +3070,12 @@ echo \"$ac_t\"\"$ac_cv_os_cray\" 1>&6\n if test $ac_cv_os_cray = yes; then\n for ac_func in _getb67 GETB67 getb67; do\n   echo $ac_n \"checking for $ac_func\"\"... $ac_c\" 1>&6\n-echo \"configure:3070: checking for $ac_func\" >&5\n+echo \"configure:3074: checking for $ac_func\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_func_$ac_func'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3075 \"configure\"\n+#line 3079 \"configure\"\n #include \"confdefs.h\"\n /* System header to define __stub macros and hopefully few prototypes,\n     which can conflict with char $ac_func(); below.  */\n@@ -3094,7 +3098,7 @@ $ac_func();\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3098: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3102: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   eval \"ac_cv_func_$ac_func=yes\"\n else\n@@ -3121,15 +3125,15 @@ done\n fi\n \n echo $ac_n \"checking stack direction for C alloca\"\"... $ac_c\" 1>&6\n-echo \"configure:3125: checking stack direction for C alloca\" >&5\n+echo \"configure:3129: checking stack direction for C alloca\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_stack_direction'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   if test \"$cross_compiling\" = yes; then\n   ac_cv_c_stack_direction=0\n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3133 \"configure\"\n+#line 3137 \"configure\"\n #include \"confdefs.h\"\n find_stack_direction ()\n {\n@@ -3148,7 +3152,7 @@ main ()\n   exit (find_stack_direction() < 0);\n }\n EOF\n-if { (eval echo configure:3152: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:3156: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_stack_direction=1\n else\n@@ -3171,13 +3175,13 @@ fi\n \n \n echo $ac_n \"checking size of double\"\"... $ac_c\" 1>&6\n-echo \"configure:3175: checking size of double\" >&5\n+echo \"configure:3179: checking size of double\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_double'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3181 \"configure\"\n+#line 3185 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3187,7 +3191,7 @@ int main() {\n switch (0) case 0: case (sizeof (double) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3191: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3195: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_double=$ac_size\n else\n@@ -3210,13 +3214,13 @@ EOF\n \n \n echo $ac_n \"checking size of long double\"\"... $ac_c\" 1>&6\n-echo \"configure:3214: checking size of long double\" >&5\n+echo \"configure:3218: checking size of long double\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_sizeof_long_double'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   for ac_size in 4 8 1 2 16 12  ; do # List sizes in rough order of prevalence.\n   cat > conftest.$ac_ext <<EOF\n-#line 3220 \"configure\"\n+#line 3224 \"configure\"\n #include \"confdefs.h\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n@@ -3226,7 +3230,7 @@ int main() {\n switch (0) case 0: case (sizeof (long double) == $ac_size):;\n ; return 0; }\n EOF\n-if { (eval echo configure:3230: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3234: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_sizeof_long_double=$ac_size\n else\n@@ -3263,14 +3267,14 @@ fi\n \n \n echo $ac_n \"checking whether byte ordering is bigendian\"\"... $ac_c\" 1>&6\n-echo \"configure:3267: checking whether byte ordering is bigendian\" >&5\n+echo \"configure:3271: checking whether byte ordering is bigendian\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_c_bigendian'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   ac_cv_c_bigendian=unknown\n # See if sys/param.h defines the BYTE_ORDER macro.\n cat > conftest.$ac_ext <<EOF\n-#line 3274 \"configure\"\n+#line 3278 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/param.h>\n@@ -3281,11 +3285,11 @@ int main() {\n #endif\n ; return 0; }\n EOF\n-if { (eval echo configure:3285: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3289: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   # It does; now see whether it defined to BIG_ENDIAN or not.\n cat > conftest.$ac_ext <<EOF\n-#line 3289 \"configure\"\n+#line 3293 \"configure\"\n #include \"confdefs.h\"\n #include <sys/types.h>\n #include <sys/param.h>\n@@ -3296,7 +3300,7 @@ int main() {\n #endif\n ; return 0; }\n EOF\n-if { (eval echo configure:3300: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3304: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   ac_cv_c_bigendian=yes\n else\n@@ -3316,7 +3320,7 @@ if test \"$cross_compiling\" = yes; then\n    echo $ac_n \"cross-compiling... \" 2>&6 \n else\n   cat > conftest.$ac_ext <<EOF\n-#line 3320 \"configure\"\n+#line 3324 \"configure\"\n #include \"confdefs.h\"\n main () {\n   /* Are we little or big endian?  From Harbison&Steele.  */\n@@ -3329,7 +3333,7 @@ main () {\n   exit (u.c[sizeof (long) - 1] == 1);\n }\n EOF\n-if { (eval echo configure:3333: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n+if { (eval echo configure:3337: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext} && (./conftest; exit) 2>/dev/null\n then\n   ac_cv_c_bigendian=no\n else\n@@ -3347,7 +3351,7 @@ fi\n echo \"$ac_t\"\"$ac_cv_c_bigendian\" 1>&6\n if test $ac_cv_c_bigendian = unknown; then\n echo $ac_n \"checking to probe for byte ordering\"\"... $ac_c\" 1>&6\n-echo \"configure:3351: checking to probe for byte ordering\" >&5\n+echo \"configure:3355: checking to probe for byte ordering\" >&5\n \n cat >conftest.c <<EOF\n short ascii_mm[] = { 0x4249, 0x4765, 0x6E44, 0x6961, 0x6E53, 0x7953, 0 };\n@@ -3401,7 +3405,7 @@ fi\n \n if test x$TARGET = xSPARC; then\n     echo $ac_n \"checking assembler and linker support unaligned pc related relocs\"\"... $ac_c\" 1>&6\n-echo \"configure:3405: checking assembler and linker support unaligned pc related relocs\" >&5\n+echo \"configure:3409: checking assembler and linker support unaligned pc related relocs\" >&5\n if eval \"test \\\"`echo '$''{'libffi_cv_as_sparc_ua_pcrel'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3411,14 +3415,14 @@ else\n \tCFLAGS=\"$CFLAGS -fpic\"\n \tLDFLAGS=\"$LDFLAGS -shared\"\n \tcat > conftest.$ac_ext <<EOF\n-#line 3415 \"configure\"\n+#line 3419 \"configure\"\n #include \"confdefs.h\"\n asm (\".text; foo: nop; .data; .align 4; .byte 0; .uaword %r_disp32(foo); .text\");\n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3422: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:3426: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   rm -rf conftest*\n   libffi_cv_as_sparc_ua_pcrel=yes\n else\n@@ -3441,22 +3445,22 @@ EOF\n     fi\n \n     echo $ac_n \"checking assembler .register pseudo-op support\"\"... $ac_c\" 1>&6\n-echo \"configure:3445: checking assembler .register pseudo-op support\" >&5\n+echo \"configure:3449: checking assembler .register pseudo-op support\" >&5\n if eval \"test \\\"`echo '$''{'libffi_cv_as_register_pseudo_op'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n   \n        libffi_cv_as_register_pseudo_op=unknown\n        # Check if we have .register\n        cat > conftest.$ac_ext <<EOF\n-#line 3453 \"configure\"\n+#line 3457 \"configure\"\n #include \"confdefs.h\"\n asm (\".register %g2, #scratch\");\n int main() {\n \n ; return 0; }\n EOF\n-if { (eval echo configure:3460: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+if { (eval echo configure:3464: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n   rm -rf conftest*\n   libffi_cv_as_register_pseudo_op=yes\n else\n@@ -3479,7 +3483,7 @@ EOF\n fi\n \n echo $ac_n \"checking whether .eh_frame section should be read-only\"\"... $ac_c\" 1>&6\n-echo \"configure:3483: checking whether .eh_frame section should be read-only\" >&5\n+echo \"configure:3487: checking whether .eh_frame section should be read-only\" >&5\n if eval \"test \\\"`echo '$''{'libffi_cv_ro_eh_frame'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4101,4 +4105,3 @@ chmod +x $CONFIG_STATUS\n rm -fr confdefs* $ac_clean_files\n test \"$no_create\" = yes || ${CONFIG_SHELL-/bin/sh} $CONFIG_STATUS || exit 1\n \n-"}, {"sha": "3691c6e1bff65248d4c28699f751a860792b8233", "filename": "libffi/configure.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Fconfigure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Fconfigure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Fconfigure.in?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -46,6 +46,8 @@ AC_PROG_CC\n \n AC_PROG_LIBTOOL\n \n+AC_FUNC_MMAP_BLACKLIST\n+\n dnl The -no-testsuite modules omit the test subdir.\n AM_CONDITIONAL(TESTSUBDIR, test -d $srcdir/testsuite)\n "}, {"sha": "bd6d4866d843b0f5fe1d732efe86325ec81b41b0", "filename": "libffi/fficonfig.h.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ffficonfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ffficonfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ffficonfig.h.in?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -28,6 +28,15 @@\n /* Define if you have the memcpy function.  */\n #undef HAVE_MEMCPY\n \n+/* Define if read-only mmap of a plain file works. */\n+#undef HAVE_MMAP_FILE\n+\n+/* Define if mmap of /dev/zero works. */\n+#undef HAVE_MMAP_DEV_ZERO\n+\n+/* Define if mmap with MAP_ANON(YMOUS) works. */\n+#undef HAVE_MMAP_ANON\n+\n /* The number of bytes in type double */\n #undef SIZEOF_DOUBLE\n "}, {"sha": "95d09c17da6e414533d5b7d80e8a5a9930c52077", "filename": "libffi/testsuite/lib/libffi-dg.exp", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flib%2Flibffi-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flib%2Flibffi-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flib%2Flibffi-dg.exp?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -162,7 +162,7 @@ proc libffi_target_compile { source dest type options } {\n     }\n \n     # search for ffi_mips.h in srcdir, too\n-    lappend options \"additional_flags=-I${libffi_include} -I${srcdir}/../include\"\n+    lappend options \"additional_flags=-I${libffi_include} -I${srcdir}/../include  -I${libffi_include}/..\"\n     lappend options \"additional_flags=${libffi_link_flags}\"\n \n     if { [string match \"powerpc-*-darwin*\" $target_triplet] } {"}, {"sha": "6d9b2cb50edab6b65b2f9cbbf06867ff27ef82a4", "filename": "libffi/testsuite/libffi.call/closure_fn0.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn0.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -45,11 +45,19 @@ typedef int (*closure_test_type0)(unsigned long long, int, unsigned long long,\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[17];\n   int res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cl_arg_types[0] = &ffi_type_uint64;\n   cl_arg_types[1] = &ffi_type_uint;\n   cl_arg_types[2] = &ffi_type_uint64;"}, {"sha": "41818ad9584ac7156721e3691a49e09b84721f36", "filename": "libffi/testsuite/libffi.call/closure_fn1.c", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn1.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -9,6 +9,7 @@\n /* { dg-do run { xfail mips*-*-* arm*-*-* strongarm*-*-* xscale*-*-* } } */\n #include \"ffitest.h\"\n \n+\n static void closure_test_fn1(ffi_cif* cif,void* resp,void** args,\n \t\t\t     void* userdata)\n {\n@@ -40,11 +41,19 @@ typedef int (*closure_test_type1)(float, float, float, float, signed short,\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[17];\n   int res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cl_arg_types[0] = &ffi_type_float;\n   cl_arg_types[1] = &ffi_type_float;\n   cl_arg_types[2] = &ffi_type_float;"}, {"sha": "2a98f962110767c6054504d4a7f00629163b1a5b", "filename": "libffi/testsuite/libffi.call/closure_fn2.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn2.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -41,11 +41,19 @@ typedef int (*closure_test_type2)(double, double, double, double, signed short,\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[17];\n   int res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cl_arg_types[0] = &ffi_type_double;\n   cl_arg_types[1] = &ffi_type_double;\n   cl_arg_types[2] = &ffi_type_double;"}, {"sha": "4f744c8109e83888f2bb96be4c9ee4c3da5b300b", "filename": "libffi/testsuite/libffi.call/closure_fn3.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn3.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -42,11 +42,18 @@ typedef int (*closure_test_type3)(float, float, float, float, float, float,\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[17];\n   int res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n \n   cl_arg_types[0] = &ffi_type_float;\n   cl_arg_types[1] = &ffi_type_float;"}, {"sha": "cbaaf303cb49f01cdd8b38354990165e714298d9", "filename": "libffi/testsuite/libffi.call/closure_fn4.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn4.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -59,11 +59,19 @@ typedef int (*closure_test_type0)(unsigned long long, unsigned long long,\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[17];\n   int i, res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   for (i = 0; i < 15; i++) {\n     cl_arg_types[i] = &ffi_type_uint64;\n   }"}, {"sha": "6a4fc67a6de6823da56733d1c1294b9deb3f27ec", "filename": "libffi/testsuite/libffi.call/closure_fn5.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fclosure_fn5.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -59,10 +59,17 @@ typedef int (*closure_test_type0)(unsigned long long, unsigned long long,\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[17];\n   int i, res;\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n \n   for (i = 0; i < 10; i++) {\n     cl_arg_types[i] = &ffi_type_uint64;"}, {"sha": "f8a87ec8797c40d27ca8e447315742f9d6c75343", "filename": "libffi/testsuite/libffi.call/cls_12byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_12byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -41,13 +41,21 @@ static void cls_struct_12byte_gn(ffi_cif* cif, void* resp, void** args, void* us\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "f8a3b5786a8e3c40391a0a1b5d5b09ab02f7aaa5", "filename": "libffi/testsuite/libffi.call/cls_16byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_16byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -42,13 +42,21 @@ static void cls_struct_16byte_gn(ffi_cif* cif, void* resp, void** args, void* us\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "50ce9ffdae5ae5de14db755f3dda1460d94ac730", "filename": "libffi/testsuite/libffi.call/cls_18byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_18byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -46,13 +46,21 @@ cls_struct_18byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[5];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "3bef9387967589ac00ab61dc732d561af2e2ae50", "filename": "libffi/testsuite/libffi.call/cls_19byte.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_19byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -49,13 +49,21 @@ cls_struct_19byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[6];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;\n@@ -85,7 +93,7 @@ int main (void)\n \n   ffi_call(&cif, FFI_FN(cls_struct_19byte_fn), &res_dbl, args_dbl);\n   /* { dg-output \"1 127 126 3 120 4 125 124 5 119: 5 252 250 8 239\" } */\n-  printf(\"res: %g %d %d %g %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c, \n+  printf(\"res: %g %d %d %g %d\\n\", res_dbl.a, res_dbl.b, res_dbl.c,\n \t res_dbl.d, res_dbl.e);\n   /* { dg-output \"\\nres: 5 252 250 8 239\" } */\n "}, {"sha": "cdf49631275f5df7ca1b95578132f405467d7878", "filename": "libffi/testsuite/libffi.call/cls_1_1byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_1_1byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -40,13 +40,21 @@ cls_struct_1_1byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[2];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "b02b84dc61fd265f93371f3108c6d98161cc8281", "filename": "libffi/testsuite/libffi.call/cls_20byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -42,13 +42,21 @@ cls_struct_20byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "41866fe6b990a71dc64b4155f16df10abeb9f4f3", "filename": "libffi/testsuite/libffi.call/cls_20byte1.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_20byte1.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -42,13 +42,21 @@ cls_struct_20byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "ff0f841b5c56922d72fdbd300f574cfa7d5502cc", "filename": "libffi/testsuite/libffi.call/cls_24byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_24byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -53,13 +53,21 @@ cls_struct_24byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "2e381771ec80b9b2cb6f0212634b7f1ce258c443", "filename": "libffi/testsuite/libffi.call/cls_2byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_2byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -42,13 +42,21 @@ cls_struct_2byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "8e3044f76552e003fccf5ab1f5ee806d38be87b3", "filename": "libffi/testsuite/libffi.call/cls_3_1byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3_1byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -46,13 +46,21 @@ cls_struct_3_1byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "294067faf5eb606dae3ba24e0a36914251b722c3", "filename": "libffi/testsuite/libffi.call/cls_3byte1.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte1.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -42,13 +42,21 @@ cls_struct_3byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "c429958f35e0b39d38dd2c237283529241b75939", "filename": "libffi/testsuite/libffi.call/cls_3byte2.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_3byte2.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -42,13 +42,21 @@ cls_struct_3byte_gn1(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "008e24a71209c57333bf739cd513e54bc7920532", "filename": "libffi/testsuite/libffi.call/cls_4_1byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4_1byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -48,13 +48,21 @@ cls_struct_4_1byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "ecb2ce9dae885f551d7799f1ec078399f8633c65", "filename": "libffi/testsuite/libffi.call/cls_4byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_4byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -42,13 +42,21 @@ cls_struct_4byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "6274a197cad961bd158f4713435752d0905626f2", "filename": "libffi/testsuite/libffi.call/cls_5byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_5byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -45,13 +45,21 @@ cls_struct_5byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "cc1b7714b54db09bb22241f1943396af26c48a01", "filename": "libffi/testsuite/libffi.call/cls_64byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_64byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -58,13 +58,21 @@ cls_struct_64byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[9];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "0c1ab28f0c20f2a7c8c76358146b5d7c4ac6793c", "filename": "libffi/testsuite/libffi.call/cls_6byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_6byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -47,13 +47,21 @@ cls_struct_6byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "a7998ddabb7b6e350b6795d199fd509f0a010f10", "filename": "libffi/testsuite/libffi.call/cls_7byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_7byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -47,13 +47,21 @@ cls_struct_7byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "efa1afc167799d939be414b9eaa8787d1f307bda", "filename": "libffi/testsuite/libffi.call/cls_8byte.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_8byte.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -41,13 +41,21 @@ cls_struct_8byte_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[4];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "69945709f90661d73ee6f478493cd886b8e78357", "filename": "libffi/testsuite/libffi.call/cls_9byte1.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte1.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -43,13 +43,21 @@ static void cls_struct_9byte_gn(ffi_cif* cif, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[3];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "976ed59a0f87acd697cd375bfc2f20c691ad3a81", "filename": "libffi/testsuite/libffi.call/cls_9byte2.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_9byte2.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -43,13 +43,21 @@ static void cls_struct_9byte_gn(ffi_cif* cif, void* resp, void** args,\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[3];\n   ffi_type cls_struct_type;\n   ffi_type* dbl_arg_types[3];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "3df6cf3fcf7c920c9471924edd304d0aee39c97b", "filename": "libffi/testsuite/libffi.call/cls_double.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_double.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -20,11 +20,19 @@ typedef double (*cls_ret_double)(double);\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[2];\n   double res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cl_arg_types[0] = &ffi_type_double;\n   cl_arg_types[1] = NULL;\n "}, {"sha": "ac4ec482b0fa22b38da1d097692001b9c97e4554", "filename": "libffi/testsuite/libffi.call/cls_float.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_float.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -21,11 +21,19 @@ typedef float (*cls_ret_float)(float);\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[2];\n   float res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n \n   cl_arg_types[0] = &ffi_type_float;\n   cl_arg_types[1] = NULL;"}, {"sha": "1e607ab2848d858448ec356f3aa6cbebfcb5bd3f", "filename": "libffi/testsuite/libffi.call/cls_schar.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_schar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_schar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_schar.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -19,11 +19,19 @@ typedef signed char (*cls_ret_schar)(signed char);\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[2];\n   signed char res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cl_arg_types[0] = &ffi_type_schar;\n   cl_arg_types[1] = NULL;\n "}, {"sha": "c85067bf1266b3c74031845fb8f6773006def7a7", "filename": "libffi/testsuite/libffi.call/cls_sint.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sint.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -19,11 +19,19 @@ typedef signed int (*cls_ret_sint)(signed int);\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[2];\n   signed int res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cl_arg_types[0] = &ffi_type_sint32;\n   cl_arg_types[1] = NULL;\n "}, {"sha": "65e687227d8c2fd1192842c37821e8d08466d94a", "filename": "libffi/testsuite/libffi.call/cls_sshort.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sshort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sshort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_sshort.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -19,11 +19,19 @@ typedef signed short (*cls_ret_sshort)(signed short);\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[2];\n   signed short res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cl_arg_types[0] = &ffi_type_sint16;\n   cl_arg_types[1] = NULL;\n "}, {"sha": "6a1e63709daacd5957fb812bb8c1dc7708e2e608", "filename": "libffi/testsuite/libffi.call/cls_uchar.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uchar.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -19,11 +19,19 @@ typedef unsigned char (*cls_ret_uchar)(unsigned char);\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[2];\n   unsigned char res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cl_arg_types[0] = &ffi_type_uchar;\n   cl_arg_types[1] = NULL;\n "}, {"sha": "501e179fd7fa35e0ce4f06cfdfd374bc006d0303", "filename": "libffi/testsuite/libffi.call/cls_uint.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_uint.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -20,11 +20,19 @@ typedef unsigned int (*cls_ret_uint)(unsigned int);\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[2];\n   unsigned int res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cl_arg_types[0] = &ffi_type_uint32;\n   cl_arg_types[1] = NULL;\n "}, {"sha": "072da8c1e500326c45144e0efadfad98cc8bd3b1", "filename": "libffi/testsuite/libffi.call/cls_ulonglong.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ulonglong.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -20,11 +20,19 @@ typedef unsigned long long (*cls_ret_ulonglong)(unsigned long long);\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[2];\n   unsigned long long res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cl_arg_types[0] = &ffi_type_uint64;\n   cl_arg_types[1] = NULL;\n "}, {"sha": "f6626b9c30ca1ac3d08c4037b1fc96a3bdf49379", "filename": "libffi/testsuite/libffi.call/cls_ushort.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fcls_ushort.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -20,11 +20,19 @@ typedef unsigned short (*cls_ret_ushort)(unsigned short);\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[2];\n   unsigned short res;\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cl_arg_types[0] = &ffi_type_ushort;\n   cl_arg_types[1] = NULL;\n "}, {"sha": "2d0df0e7734ddd62702434e60cbb5e0a38b9b213", "filename": "libffi/testsuite/libffi.call/ffitest.h", "status": "modified", "additions": 70, "deletions": 1, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fffitest.h?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -2,8 +2,77 @@\n #include <stdio.h>\n #include <string.h>\n #include <ffi.h>\n+#include \"fficonfig.h\"\n \n #define MAX_ARGS 256\n \n-#define CHECK(x) !(x) ? abort() : 0 \n+#define CHECK(x) !(x) ? abort() : 0\n \n+\n+/* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a\n+   file open.  */\n+#ifdef HAVE_MMAP_ANON\n+# undef HAVE_MMAP_DEV_ZERO\n+\n+# include <sys/mman.h>\n+# ifndef MAP_FAILED\n+#  define MAP_FAILED -1\n+# endif\n+# if !defined (MAP_ANONYMOUS) && defined (MAP_ANON)\n+#  define MAP_ANONYMOUS MAP_ANON\n+# endif\n+# define USING_MMAP\n+\n+#endif\n+\n+#ifdef HAVE_MMAP_DEV_ZERO\n+\n+# include <sys/mman.h>\n+# ifndef MAP_FAILED\n+#  define MAP_FAILED -1\n+# endif\n+# define USING_MMAP\n+\n+#endif\n+\n+#ifdef USING_MMAP\n+static inline void *\n+allocate_mmap (size_t size)\n+{\n+  void *page;\n+#if defined (HAVE_MMAP_DEV_ZERO)\n+  static int dev_zero_fd = -1;\n+#endif\n+\n+#ifdef HAVE_MMAP_DEV_ZERO\n+  if (dev_zero_fd == -1)\n+    {\n+      dev_zero_fd = open (\"/dev/zero\", O_RDONLY);\n+      if (dev_zero_fd == -1)\n+\t{\n+\t  perror (\"open /dev/zero: %m\");\n+\t  exit (1);\n+\t}\n+    }\n+#endif\n+\n+\n+#ifdef HAVE_MMAP_ANON\n+  page = mmap (NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC,\n+\t       MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+#endif\n+#ifdef HAVE_MMAP_DEV_ZERO\n+  page = mmap (NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC,\n+\t       MAP_PRIVATE, dev_zero_fd, 0);\n+#endif\n+\n+  if (page == MAP_FAILED)\n+    {\n+      perror (\"virtual memory exhausted\");\n+      exit (1);\n+    }\n+\n+  return page;\n+}\n+\n+#endif"}, {"sha": "86d685a68a751ae75abfa43e88d9b287d426940b", "filename": "libffi/testsuite/libffi.call/nested_struct.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -67,15 +67,23 @@ cls_struct_combined_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type* cls_struct_fields1[5];\n   ffi_type* cls_struct_fields2[5];\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "1d87945defcad6bb1555adab80a9e4573c86f5a6", "filename": "libffi/testsuite/libffi.call/nested_struct1.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct1.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -71,15 +71,23 @@ cls_struct_combined_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[5];\n   ffi_type* cls_struct_fields[5];\n   ffi_type* cls_struct_fields1[5];\n   ffi_type* cls_struct_fields2[5];\n   ffi_type cls_struct_type, cls_struct_type1, cls_struct_type2;\n   ffi_type* dbl_arg_types[5];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "3572a4c49cce4c302522e4849fb9d17a80a5a173", "filename": "libffi/testsuite/libffi.call/nested_struct2.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct2.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -58,14 +58,22 @@ B_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[3];\n   ffi_type* cls_struct_fields1[3];\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "95cf2f3b44f79661e747abe49baf2ee57cb5e048", "filename": "libffi/testsuite/libffi.call/nested_struct3.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fnested_struct3.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -49,14 +49,22 @@ B_gn(ffi_cif* cif, void* resp, void** args, void* userdata)\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   void* args_dbl[3];\n   ffi_type* cls_struct_fields[3];\n   ffi_type* cls_struct_fields1[3];\n   ffi_type cls_struct_type, cls_struct_type1;\n   ffi_type* dbl_arg_types[3];\n \n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   cls_struct_type.size = 0;\n   cls_struct_type.alignment = 0;\n   cls_struct_type.type = FFI_TYPE_STRUCT;"}, {"sha": "5b6397f4efa8656f23d974ae8a716d38be05a20a", "filename": "libffi/testsuite/libffi.call/problem1.c", "status": "modified", "additions": 58, "deletions": 50, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fproblem1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.call%2Fproblem1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.call%2Fproblem1.c?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -29,61 +29,69 @@ my_ffi_struct callee(struct my_ffi_struct a1, struct my_ffi_struct a2)\n \n void stub(ffi_cif* cif, void* resp, void** args, void* userdata)\n {\n-    struct my_ffi_struct a1;\n-    struct my_ffi_struct a2;\n+  struct my_ffi_struct a1;\n+  struct my_ffi_struct a2;\n \n-    a1 = *(struct my_ffi_struct*)(args[0]);\n-    a2 = *(struct my_ffi_struct*)(args[1]);\n+  a1 = *(struct my_ffi_struct*)(args[0]);\n+  a2 = *(struct my_ffi_struct*)(args[1]);\n \n-    *(my_ffi_struct *)resp = callee(a1, a2);\n+  *(my_ffi_struct *)resp = callee(a1, a2);\n }\n \n \n int main(void)\n {\n-    ffi_type* my_ffi_struct_fields[4];\n-    ffi_type my_ffi_struct_type;\n-    ffi_cif cif;\n-    static ffi_closure cl;\n-    ffi_closure *pcl = &cl;\n-    void* args[4];\n-    ffi_type* arg_types[3];\n-\n-    struct my_ffi_struct g = { 1.0, 2.0, 3.0 };\n-    struct my_ffi_struct f = { 1.0, 2.0, 3.0 };\n-    struct my_ffi_struct res;\n-\n-    my_ffi_struct_type.size = 0;\n-    my_ffi_struct_type.alignment = 0;\n-    my_ffi_struct_type.type = FFI_TYPE_STRUCT;\n-    my_ffi_struct_type.elements = my_ffi_struct_fields;\n-\n-    my_ffi_struct_fields[0] = &ffi_type_double;\n-    my_ffi_struct_fields[1] = &ffi_type_double;\n-    my_ffi_struct_fields[2] = &ffi_type_double;\n-    my_ffi_struct_fields[3] = NULL;\n-\n-    arg_types[0] = &my_ffi_struct_type;\n-    arg_types[1] = &my_ffi_struct_type;\n-    arg_types[2] = NULL;\n-\n-    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &my_ffi_struct_type,\n-\t\t       arg_types) == FFI_OK);\n-\n-    args[0] = &g;\n-    args[1] = &f;\n-    args[2] = NULL;\n-    ffi_call(&cif, FFI_FN(callee), &res, args);\n-    /* { dg-output \"1 2 3 1 2 3: 2 4 6\" } */\n-    printf(\"res: %g %g %g\\n\", res.a, res.b, res.c);\n-    /* { dg-output \"\\nres: 2 4 6\" } */\n-\n-    CHECK(ffi_prep_closure(pcl, &cif, stub, NULL) == FFI_OK);\n-\n-    res = ((my_ffi_struct(*)(struct my_ffi_struct, struct my_ffi_struct))(pcl))(g, f);\n-    /* { dg-output \"\\n1 2 3 1 2 3: 2 4 6\" } */\n-    printf(\"res: %g %g %g\\n\", res.a, res.b, res.c);\n-    /* { dg-output \"\\nres: 2 4 6\" } */\n-\n-    exit(0);;\n+  ffi_type* my_ffi_struct_fields[4];\n+  ffi_type my_ffi_struct_type;\n+  ffi_cif cif;\n+#ifndef USING_MMAP\n+  static ffi_closure cl;\n+#endif\n+  ffi_closure *pcl;\n+  void* args[4];\n+  ffi_type* arg_types[3];\n+\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n+  struct my_ffi_struct g = { 1.0, 2.0, 3.0 };\n+  struct my_ffi_struct f = { 1.0, 2.0, 3.0 };\n+  struct my_ffi_struct res;\n+\n+  my_ffi_struct_type.size = 0;\n+  my_ffi_struct_type.alignment = 0;\n+  my_ffi_struct_type.type = FFI_TYPE_STRUCT;\n+  my_ffi_struct_type.elements = my_ffi_struct_fields;\n+\n+  my_ffi_struct_fields[0] = &ffi_type_double;\n+  my_ffi_struct_fields[1] = &ffi_type_double;\n+  my_ffi_struct_fields[2] = &ffi_type_double;\n+  my_ffi_struct_fields[3] = NULL;\n+\n+  arg_types[0] = &my_ffi_struct_type;\n+  arg_types[1] = &my_ffi_struct_type;\n+  arg_types[2] = NULL;\n+\n+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 2, &my_ffi_struct_type,\n+\t\t     arg_types) == FFI_OK);\n+\n+  args[0] = &g;\n+  args[1] = &f;\n+  args[2] = NULL;\n+  ffi_call(&cif, FFI_FN(callee), &res, args);\n+  /* { dg-output \"1 2 3 1 2 3: 2 4 6\" } */\n+  printf(\"res: %g %g %g\\n\", res.a, res.b, res.c);\n+  /* { dg-output \"\\nres: 2 4 6\" } */\n+\n+  CHECK(ffi_prep_closure(pcl, &cif, stub, NULL) == FFI_OK);\n+\n+  res = ((my_ffi_struct(*)(struct my_ffi_struct, struct my_ffi_struct))(pcl))(g, f);\n+  /* { dg-output \"\\n1 2 3 1 2 3: 2 4 6\" } */\n+  printf(\"res: %g %g %g\\n\", res.a, res.b, res.c);\n+  /* { dg-output \"\\nres: 2 4 6\" } */\n+\n+  exit(0);;\n }"}, {"sha": "ef088820d8a2c26400f383ff2e0fe55db66b379a", "filename": "libffi/testsuite/libffi.special/ffitestcxx.h", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.special%2Fffitestcxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.special%2Fffitestcxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.special%2Fffitestcxx.h?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -1,8 +1,76 @@\n #include <stdlib.h>\n #include <stdio.h>\n #include <ffi.h>\n+#include \"fficonfig.h\"\n \n #define MAX_ARGS 256\n \n #define CHECK(x) (!(x) ? abort() : (void)0)\n \n+/* Prefer MAP_ANON(YMOUS) to /dev/zero, since we don't need to keep a\n+   file open.  */\n+#ifdef HAVE_MMAP_ANON\n+# undef HAVE_MMAP_DEV_ZERO\n+\n+# include <sys/mman.h>\n+# ifndef MAP_FAILED\n+#  define MAP_FAILED -1\n+# endif\n+# if !defined (MAP_ANONYMOUS) && defined (MAP_ANON)\n+#  define MAP_ANONYMOUS MAP_ANON\n+# endif\n+# define USING_MMAP\n+\n+#endif\n+\n+#ifdef HAVE_MMAP_DEV_ZERO\n+\n+# include <sys/mman.h>\n+# ifndef MAP_FAILED\n+#  define MAP_FAILED -1\n+# endif\n+# define USING_MMAP\n+\n+#endif\n+\n+#ifdef USING_MMAP\n+static inline void *\n+allocate_mmap (size_t size)\n+{\n+  void *page;\n+#if defined (HAVE_MMAP_DEV_ZERO)\n+  static int dev_zero_fd = -1;\n+#endif\n+\n+#ifdef HAVE_MMAP_DEV_ZERO\n+  if (dev_zero_fd == -1)\n+    {\n+      dev_zero_fd = open (\"/dev/zero\", O_RDONLY);\n+      if (dev_zero_fd == -1)\n+\t{\n+\t  perror (\"open /dev/zero: %m\");\n+\t  exit (1);\n+\t}\n+    }\n+#endif\n+\n+\n+#ifdef HAVE_MMAP_ANON\n+  page = mmap (NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC,\n+\t       MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n+#endif\n+#ifdef HAVE_MMAP_DEV_ZERO\n+  page = mmap (NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC,\n+\t       MAP_PRIVATE, dev_zero_fd, 0);\n+#endif\n+\n+  if (page == MAP_FAILED)\n+    {\n+      perror (\"virtual memory exhausted\");\n+      exit (1);\n+    }\n+\n+  return page;\n+}\n+\n+#endif"}, {"sha": "7261a0781a49ac81451bb8c113db2dec8976c1aa", "filename": "libffi/testsuite/libffi.special/unwindtest.cc", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5196736e471495a372ba5583c53f16020eea10ca/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libffi%2Ftestsuite%2Flibffi.special%2Funwindtest.cc?ref=5196736e471495a372ba5583c53f16020eea10ca", "patch": "@@ -49,10 +49,18 @@ typedef int (*closure_test_type1)(float, float, float, float, signed short,\n int main (void)\n {\n   ffi_cif cif;\n+#ifndef USING_MMAP\n   static ffi_closure cl;\n-  ffi_closure *pcl = &cl;\n+#endif\n+  ffi_closure *pcl;\n   ffi_type * cl_arg_types[17];\n   int res;\n+#ifdef USING_MMAP\n+  pcl = allocate_mmap (sizeof(ffi_closure));\n+#else\n+  pcl = &cl;\n+#endif\n+\n   {\n     cl_arg_types[1] = NULL;\n "}]}