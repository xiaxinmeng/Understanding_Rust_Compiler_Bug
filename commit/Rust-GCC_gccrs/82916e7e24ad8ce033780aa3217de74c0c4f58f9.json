{"sha": "82916e7e24ad8ce033780aa3217de74c0c4f58f9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODI5MTZlN2UyNGFkOGNlMDMzNzgwYWEzMjE3ZGU3NGMwYzRmNThmOQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2010-09-09T18:36:26Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2010-09-09T18:36:26Z"}, "message": "re PR middle-end/45312 (GCC 4.4.4 miscompiles the Linux kernel)\n\n2010-09-09  Vladimir Makarov  <vmakarov@redhat.com>\n\n\tPR middle-end/45312\n\t* reload1.c (merge_assigned_reloads): Remove.\n\t(reload_as_needed): Don't call it.\n\nFrom-SVN: r164116", "tree": {"sha": "fd97b8fa0cf1c312cb91fafa2e219c81bb30a3f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd97b8fa0cf1c312cb91fafa2e219c81bb30a3f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82916e7e24ad8ce033780aa3217de74c0c4f58f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82916e7e24ad8ce033780aa3217de74c0c4f58f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82916e7e24ad8ce033780aa3217de74c0c4f58f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82916e7e24ad8ce033780aa3217de74c0c4f58f9/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b9be284218ee02515493fd019860c0837b334e39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9be284218ee02515493fd019860c0837b334e39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9be284218ee02515493fd019860c0837b334e39"}], "stats": {"total": 160, "additions": 6, "deletions": 154}, "files": [{"sha": "781d5a1219af4f1555e9a671bccf27fc21ef55d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82916e7e24ad8ce033780aa3217de74c0c4f58f9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82916e7e24ad8ce033780aa3217de74c0c4f58f9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=82916e7e24ad8ce033780aa3217de74c0c4f58f9", "patch": "@@ -1,3 +1,9 @@\n+2010-09-09  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\tPR middle-end/45312\n+\t* reload1.c (merge_assigned_reloads): Remove.\n+\t(reload_as_needed): Don't call it.\n+\n 2010-09-09  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/m32r/m32r.c (m32r_mode_dependent_address_p): New functions."}, {"sha": "38b908355921188c25a46caf852a683a394b15ef", "filename": "gcc/reload1.c", "status": "modified", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82916e7e24ad8ce033780aa3217de74c0c4f58f9/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82916e7e24ad8ce033780aa3217de74c0c4f58f9/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=82916e7e24ad8ce033780aa3217de74c0c4f58f9", "patch": "@@ -435,7 +435,6 @@ static void failed_reload (rtx, int);\n static int set_reload_reg (int, int);\n static void choose_reload_regs_init (struct insn_chain *, rtx *);\n static void choose_reload_regs (struct insn_chain *);\n-static void merge_assigned_reloads (rtx);\n static void emit_input_reload_insns (struct insn_chain *, struct reload *,\n \t\t\t\t     rtx, int);\n static void emit_output_reload_insns (struct insn_chain *, struct reload *,\n@@ -4596,12 +4595,6 @@ reload_as_needed (int live_known)\n \t\t Record the choices of reload reg in reload_reg_rtx.  */\n \t      choose_reload_regs (chain);\n \n-\t      /* Merge any reloads that we didn't combine for fear of\n-\t\t increasing the number of spill registers needed but now\n-\t\t discover can be safely merged.  */\n-\t      if (targetm.small_register_classes_for_mode_p (VOIDmode))\n-\t\tmerge_assigned_reloads (insn);\n-\n \t      /* Generate the insns to reload operands into or out of\n \t\t their reload regs.  */\n \t      emit_reload_insns (chain);\n@@ -6994,153 +6987,6 @@ deallocate_reload_reg (int r)\n   reload_spill_index[r] = -1;\n }\n \f\n-/* If the small_register_classes_for_mode_p target hook returns true for\n-   some machine modes, we may not have merged two reloads of the same item\n-   for fear that we might not have enough reload registers.  However,\n-   normally they will get the same reload register and hence actually need\n-   not be loaded twice.\n-\n-   Here we check for the most common case of this phenomenon: when we have\n-   a number of reloads for the same object, each of which were allocated\n-   the same reload_reg_rtx, that reload_reg_rtx is not used for any other\n-   reload, and is not modified in the insn itself.  If we find such,\n-   merge all the reloads and set the resulting reload to RELOAD_OTHER.\n-   This will not increase the number of spill registers needed and will\n-   prevent redundant code.  */\n-\n-static void\n-merge_assigned_reloads (rtx insn)\n-{\n-  int i, j;\n-\n-  /* Scan all the reloads looking for ones that only load values and\n-     are not already RELOAD_OTHER and ones whose reload_reg_rtx are\n-     assigned and not modified by INSN.  */\n-\n-  for (i = 0; i < n_reloads; i++)\n-    {\n-      int conflicting_input = 0;\n-      int max_input_address_opnum = -1;\n-      int min_conflicting_input_opnum = MAX_RECOG_OPERANDS;\n-\n-      if (rld[i].in == 0 || rld[i].when_needed == RELOAD_OTHER\n-\t  || rld[i].out != 0 || rld[i].reg_rtx == 0\n-\t  || reg_set_p (rld[i].reg_rtx, insn))\n-\tcontinue;\n-\n-      /* Look at all other reloads.  Ensure that the only use of this\n-\t reload_reg_rtx is in a reload that just loads the same value\n-\t as we do.  Note that any secondary reloads must be of the identical\n-\t class since the values, modes, and result registers are the\n-\t same, so we need not do anything with any secondary reloads.  */\n-\n-      for (j = 0; j < n_reloads; j++)\n-\t{\n-\t  if (i == j || rld[j].reg_rtx == 0\n-\t      || ! reg_overlap_mentioned_p (rld[j].reg_rtx,\n-\t\t\t\t\t    rld[i].reg_rtx))\n-\t    continue;\n-\n-\t  if (rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS\n-\t      && rld[j].opnum > max_input_address_opnum)\n-\t    max_input_address_opnum = rld[j].opnum;\n-\n-\t  /* If the reload regs aren't exactly the same (e.g, different modes)\n-\t     or if the values are different, we can't merge this reload.\n-\t     But if it is an input reload, we might still merge\n-\t     RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_OTHER_ADDRESS reloads.  */\n-\n-\t  if (! rtx_equal_p (rld[i].reg_rtx, rld[j].reg_rtx)\n-\t      || rld[j].out != 0 || rld[j].in == 0\n-\t      || ! rtx_equal_p (rld[i].in, rld[j].in))\n-\t    {\n-\t      if (rld[j].when_needed != RELOAD_FOR_INPUT\n-\t\t  || ((rld[i].when_needed != RELOAD_FOR_INPUT_ADDRESS\n-\t\t       || rld[i].opnum > rld[j].opnum)\n-\t\t      && rld[i].when_needed != RELOAD_FOR_OTHER_ADDRESS))\n-\t\tbreak;\n-\t      conflicting_input = 1;\n-\t      if (min_conflicting_input_opnum > rld[j].opnum)\n-\t\tmin_conflicting_input_opnum = rld[j].opnum;\n-\t    }\n-\t}\n-\n-      /* If all is OK, merge the reloads.  Only set this to RELOAD_OTHER if\n-\t we, in fact, found any matching reloads.  */\n-\n-      if (j == n_reloads\n-\t  && max_input_address_opnum <= min_conflicting_input_opnum)\n-\t{\n-\t  gcc_assert (rld[i].when_needed != RELOAD_FOR_OUTPUT);\n-\n-\t  for (j = 0; j < n_reloads; j++)\n-\t    if (i != j && rld[j].reg_rtx != 0\n-\t\t&& rtx_equal_p (rld[i].reg_rtx, rld[j].reg_rtx)\n-\t\t&& (! conflicting_input\n-\t\t    || rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS\n-\t\t    || rld[j].when_needed == RELOAD_FOR_OTHER_ADDRESS))\n-\t      {\n-\t\trld[i].when_needed = RELOAD_OTHER;\n-\t\trld[j].in = 0;\n-\t\treload_spill_index[j] = -1;\n-\t\ttransfer_replacements (i, j);\n-\t      }\n-\n-\t  /* If this is now RELOAD_OTHER, look for any reloads that\n-\t     load parts of this operand and set them to\n-\t     RELOAD_FOR_OTHER_ADDRESS if they were for inputs,\n-\t     RELOAD_OTHER for outputs.  Note that this test is\n-\t     equivalent to looking for reloads for this operand\n-\t     number.\n-\n-\t     We must take special care with RELOAD_FOR_OUTPUT_ADDRESS;\n-\t     it may share registers with a RELOAD_FOR_INPUT, so we can\n-\t     not change it to RELOAD_FOR_OTHER_ADDRESS.  We should\n-\t     never need to, since we do not modify RELOAD_FOR_OUTPUT.\n-\n-\t     It is possible that the RELOAD_FOR_OPERAND_ADDRESS\n-\t     instruction is assigned the same register as the earlier\n-\t     RELOAD_FOR_OTHER_ADDRESS instruction.  Merging these two\n-\t     instructions will cause the RELOAD_FOR_OTHER_ADDRESS\n-\t     instruction to be deleted later on.  */\n-\n-\t  if (rld[i].when_needed == RELOAD_OTHER)\n-\t    for (j = 0; j < n_reloads; j++)\n-\t      if (rld[j].in != 0\n-\t\t  && rld[j].when_needed != RELOAD_OTHER\n-\t\t  && rld[j].when_needed != RELOAD_FOR_OTHER_ADDRESS\n-\t\t  && rld[j].when_needed != RELOAD_FOR_OUTPUT_ADDRESS\n-\t\t  && rld[j].when_needed != RELOAD_FOR_OPERAND_ADDRESS\n-\t\t  && (! conflicting_input\n-\t\t      || rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS\n-\t\t      || rld[j].when_needed == RELOAD_FOR_INPADDR_ADDRESS)\n-\t\t  && reg_overlap_mentioned_for_reload_p (rld[j].in,\n-\t\t\t\t\t\t\t rld[i].in))\n-\t\t{\n-\t\t  int k;\n-\n-\t\t  rld[j].when_needed\n-\t\t    = ((rld[j].when_needed == RELOAD_FOR_INPUT_ADDRESS\n-\t\t\t|| rld[j].when_needed == RELOAD_FOR_INPADDR_ADDRESS)\n-\t\t       ? RELOAD_FOR_OTHER_ADDRESS : RELOAD_OTHER);\n-\n-\t\t  /* Check to see if we accidentally converted two\n-\t\t     reloads that use the same reload register with\n-\t\t     different inputs to the same type.  If so, the\n-\t\t     resulting code won't work.  */\n-\t\t  if (rld[j].reg_rtx)\n-\t\t    for (k = 0; k < j; k++)\n-\t\t      gcc_assert (rld[k].in == 0 || rld[k].reg_rtx == 0\n-\t\t\t\t  || rld[k].when_needed != rld[j].when_needed\n-\t\t\t\t  || !rtx_equal_p (rld[k].reg_rtx,\n-\t\t\t\t\t\t   rld[j].reg_rtx)\n-\t\t\t\t  || rtx_equal_p (rld[k].in,\n-\t\t\t\t\t\t  rld[j].in));\n-\t\t}\n-\t}\n-    }\n-}\n-\f\n /* These arrays are filled by emit_reload_insns and its subroutines.  */\n static rtx input_reload_insns[MAX_RECOG_OPERANDS];\n static rtx other_input_address_reload_insns = 0;"}]}