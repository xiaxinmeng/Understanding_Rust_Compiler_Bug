{"sha": "f60bea11ada835a0b007469816bd1130a2f9a77a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYwYmVhMTFhZGE4MzVhMGIwMDc0Njk4MTZiZDExMzBhMmY5YTc3YQ==", "commit": {"author": {"name": "Than McIntosh", "email": "thanm@google.com", "date": "2017-11-15T01:52:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-11-15T01:52:45Z"}, "message": "compiler: remove LHS/RHS context determination for var exprs\n    \n    Remove the code that determined LHS/RHS context for var expressions\n    (was needed previously for some instances of the back end). LHS/RHS\n    context is computed by the back end in all cases, so no need to have\n    this code in the front end any more.\n    \n    Reviewed-on: https://go-review.googlesource.com/77510\n\n\t* go-gcc.cc (var_expression): Remove Varexpr_context parameter.\n\nFrom-SVN: r254748", "tree": {"sha": "7e8327ba5a0ccf9a4397727a17e2745d7538d747", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7e8327ba5a0ccf9a4397727a17e2745d7538d747"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f60bea11ada835a0b007469816bd1130a2f9a77a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60bea11ada835a0b007469816bd1130a2f9a77a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f60bea11ada835a0b007469816bd1130a2f9a77a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60bea11ada835a0b007469816bd1130a2f9a77a/comments", "author": {"login": "thanm", "id": 12280172, "node_id": "MDQ6VXNlcjEyMjgwMTcy", "avatar_url": "https://avatars.githubusercontent.com/u/12280172?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thanm", "html_url": "https://github.com/thanm", "followers_url": "https://api.github.com/users/thanm/followers", "following_url": "https://api.github.com/users/thanm/following{/other_user}", "gists_url": "https://api.github.com/users/thanm/gists{/gist_id}", "starred_url": "https://api.github.com/users/thanm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thanm/subscriptions", "organizations_url": "https://api.github.com/users/thanm/orgs", "repos_url": "https://api.github.com/users/thanm/repos", "events_url": "https://api.github.com/users/thanm/events{/privacy}", "received_events_url": "https://api.github.com/users/thanm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c2ad9885c01b3c5dd951dd707773de66cd7bb27c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2ad9885c01b3c5dd951dd707773de66cd7bb27c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2ad9885c01b3c5dd951dd707773de66cd7bb27c"}], "stats": {"total": 188, "additions": 34, "deletions": 154}, "files": [{"sha": "947f49cd48bf55ce5ccf953340b71e46c0d05c2f", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=f60bea11ada835a0b007469816bd1130a2f9a77a", "patch": "@@ -1,3 +1,7 @@\n+2017-11-14  Than McIntosh  <thanm@google.com>\n+\n+\t* go-gcc.cc (var_expression): Remove Varexpr_context parameter.\n+\n 2017-10-11  Tony Reix  <tony.reix@atos.net>\n \n \t* go-system.h (__STDC_FORMAT_MACROS): Define before including any"}, {"sha": "a50abdd856b8457b4ccbe4655f04b524fc1d2fbc", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=f60bea11ada835a0b007469816bd1130a2f9a77a", "patch": "@@ -276,7 +276,7 @@ class Gcc_backend : public Backend\n   { return this->make_expression(null_pointer_node); }\n \n   Bexpression*\n-  var_expression(Bvariable* var, Varexpr_context, Location);\n+  var_expression(Bvariable* var, Location);\n \n   Bexpression*\n   indirect_expression(Btype*, Bexpression* expr, bool known_valid, Location);\n@@ -1256,7 +1256,7 @@ Gcc_backend::zero_expression(Btype* btype)\n // An expression that references a variable.\n \n Bexpression*\n-Gcc_backend::var_expression(Bvariable* var, Varexpr_context, Location location)\n+Gcc_backend::var_expression(Bvariable* var, Location location)\n {\n   tree ret = var->get_tree(location);\n   if (ret == error_mark_node)"}, {"sha": "4832c7829465e76057722b3544830327c488dd94", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=f60bea11ada835a0b007469816bd1130a2f9a77a", "patch": "@@ -1,4 +1,4 @@\n-d028451131e92bab5379defb04ead87ca978ed25\n+cb5dc1ce98857884a2215c461dd1d7de530f9f5e\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "48dbe7eb0da6ae8a231f2db6ae13419c8830125c", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=f60bea11ada835a0b007469816bd1130a2f9a77a", "patch": "@@ -254,7 +254,7 @@ class Backend\n \n   // Create a reference to a variable.\n   virtual Bexpression*\n-  var_expression(Bvariable* var, Varexpr_context in_lvalue_pos, Location) = 0;\n+  var_expression(Bvariable* var, Location) = 0;\n \n   // Create an expression that indirects through the pointer expression EXPR\n   // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer"}, {"sha": "7f816110d6264b167bccd90c81221fb9dee3a30c", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=f60bea11ada835a0b007469816bd1130a2f9a77a", "patch": "@@ -771,7 +771,7 @@ Var_expression::do_get_backend(Translate_context* context)\n     go_unreachable();\n \n   Bexpression* ret =\n-      context->backend()->var_expression(bvar, this->in_lvalue_pos_, loc);\n+      context->backend()->var_expression(bvar, loc);\n   if (is_in_heap)\n     ret = context->backend()->indirect_expression(btype, ret, true, loc);\n   return ret;\n@@ -898,10 +898,7 @@ Temporary_reference_expression::do_get_backend(Translate_context* context)\n {\n   Gogo* gogo = context->gogo();\n   Bvariable* bvar = this->statement_->get_backend_variable(context);\n-  Varexpr_context ve_ctxt = (this->is_lvalue_ ? VE_lvalue : VE_rvalue);\n-\n-  Bexpression* ret = gogo->backend()->var_expression(bvar, ve_ctxt,\n-                                                     this->location());\n+  Bexpression* ret = gogo->backend()->var_expression(bvar, this->location());\n \n   // The backend can't always represent the same set of recursive types\n   // that the Go frontend can.  In some cases this means that a\n@@ -972,15 +969,15 @@ Set_and_use_temporary_expression::do_get_backend(Translate_context* context)\n   Location loc = this->location();\n   Gogo* gogo = context->gogo();\n   Bvariable* bvar = this->statement_->get_backend_variable(context);\n-  Bexpression* lvar_ref = gogo->backend()->var_expression(bvar, VE_lvalue, loc);\n+  Bexpression* lvar_ref = gogo->backend()->var_expression(bvar, loc);\n \n   Named_object* fn = context->function();\n   go_assert(fn != NULL);\n   Bfunction* bfn = fn->func_value()->get_or_make_decl(gogo, fn);\n   Bexpression* bexpr = this->expr_->get_backend(context);\n   Bstatement* set = gogo->backend()->assignment_statement(bfn, lvar_ref,\n                                                           bexpr, loc);\n-  Bexpression* var_ref = gogo->backend()->var_expression(bvar, VE_rvalue, loc);\n+  Bexpression* var_ref = gogo->backend()->var_expression(bvar, loc);\n   Bexpression* ret = gogo->backend()->compound_expression(set, var_ref, loc);\n   return ret;\n }\n@@ -1084,11 +1081,11 @@ Sink_expression::do_get_backend(Translate_context* context)\n \tgogo->backend()->temporary_variable(fn_ctx, context->bblock(), bt, NULL,\n \t\t\t\t\t    false, loc, &decl);\n       Bexpression* var_ref =\n-          gogo->backend()->var_expression(this->bvar_, VE_lvalue, loc);\n+          gogo->backend()->var_expression(this->bvar_, loc);\n       var_ref = gogo->backend()->compound_expression(decl, var_ref, loc);\n       return var_ref;\n     }\n-  return gogo->backend()->var_expression(this->bvar_, VE_lvalue, loc);\n+  return gogo->backend()->var_expression(this->bvar_, loc);\n }\n \n // Ast dump for sink expression.\n@@ -1302,7 +1299,7 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n   Named_object* no = this->fn_;\n   Location loc = no->location();\n   if (this->dvar_ != NULL)\n-    return context->backend()->var_expression(this->dvar_, VE_rvalue, loc);\n+    return context->backend()->var_expression(this->dvar_, loc);\n \n   Gogo* gogo = context->gogo();\n   std::string var_name(gogo->function_descriptor_name(no));\n@@ -1340,7 +1337,7 @@ Func_descriptor_expression::do_get_backend(Translate_context* context)\n     }\n \n   this->dvar_ = bvar;\n-  return gogo->backend()->var_expression(bvar, VE_rvalue, loc);\n+  return gogo->backend()->var_expression(bvar, loc);\n }\n \n // Print a function descriptor expression.\n@@ -4286,7 +4283,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t  Temporary_statement* temp = sut->temporary();\n \t  Bvariable* bvar = temp->get_backend_variable(context);\n           Bexpression* bvar_expr =\n-              gogo->backend()->var_expression(bvar, VE_lvalue, loc);\n+              gogo->backend()->var_expression(bvar, loc);\n           Bexpression* bval = sut->expression()->get_backend(context);\n \n           Named_object* fn = context->function();\n@@ -4373,7 +4370,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t  gogo->backend()->implicit_variable_set_init(implicit, var_name, btype,\n \t\t\t\t\t\t      true, copy_to_heap, false,\n \t\t\t\t\t\t      bexpr);\n-\t  bexpr = gogo->backend()->var_expression(implicit, VE_rvalue, loc);\n+\t  bexpr = gogo->backend()->var_expression(implicit, loc);\n \n \t  // If we are not copying a slice initializer to the heap,\n \t  // then it can be changed by the program, so if it can\n@@ -4383,7 +4380,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n \t      && this->expr_->type()->has_pointer())\n \t    {\n \t      Bexpression* root =\n-                  gogo->backend()->var_expression(implicit, VE_rvalue, loc);\n+                  gogo->backend()->var_expression(implicit, loc);\n \t      root = gogo->backend()->address_expression(root, loc);\n \t      Type* type = Type::make_pointer_type(this->expr_->type());\n \t      gogo->add_gc_root(Expression::make_backend(root, type, loc));\n@@ -4400,7 +4397,7 @@ Unary_expression::do_get_backend(Translate_context* context)\n                                                 true, false, btype, loc);\n           gogo->backend()->immutable_struct_set_init(decl, var_name, true,\n \t\t\t\t\t\t     false, btype, loc, bexpr);\n-          bexpr = gogo->backend()->var_expression(decl, VE_rvalue, loc);\n+          bexpr = gogo->backend()->var_expression(decl, loc);\n         }\n \n       go_assert(!this->create_temp_ || this->expr_->is_variable());\n@@ -14309,7 +14306,7 @@ Heap_expression::do_get_backend(Translate_context* context)\n   Bstatement* assn;\n   if (!etype->has_pointer())\n     {\n-      space = gogo->backend()->var_expression(space_temp, VE_lvalue, loc);\n+      space = gogo->backend()->var_expression(space_temp, loc);\n       Bexpression* ref =\n \tgogo->backend()->indirect_expression(expr_btype, space, true, loc);\n       assn = gogo->backend()->assignment_statement(fndecl, ref, bexpr, loc);\n@@ -14322,12 +14319,12 @@ Heap_expression::do_get_backend(Translate_context* context)\n \t\t\t\t\t    expr_btype, bexpr, true, loc,\n \t\t\t\t\t    &edecl);\n       Bexpression* btempref = gogo->backend()->var_expression(btemp,\n-\t\t\t\t\t\t\t      VE_lvalue, loc);\n+\t\t\t\t\t\t\t      loc);\n       Bexpression* addr = gogo->backend()->address_expression(btempref, loc);\n \n       Expression* td = Expression::make_type_descriptor(etype, loc);\n       Type* etype_ptr = Type::make_pointer_type(etype);\n-      space = gogo->backend()->var_expression(space_temp, VE_rvalue, loc);\n+      space = gogo->backend()->var_expression(space_temp, loc);\n       Expression* elhs = Expression::make_backend(space, etype_ptr, loc);\n       Expression* erhs = Expression::make_backend(addr, etype_ptr, loc);\n       Expression* call = Runtime::make_call(Runtime::TYPEDMEMMOVE, loc, 3,\n@@ -14337,7 +14334,7 @@ Heap_expression::do_get_backend(Translate_context* context)\n       assn = gogo->backend()->compound_statement(edecl, s);\n     }\n   decl = gogo->backend()->compound_statement(decl, assn);\n-  space = gogo->backend()->var_expression(space_temp, VE_rvalue, loc);\n+  space = gogo->backend()->var_expression(space_temp, loc);\n   return gogo->backend()->compound_expression(decl, space, loc);\n }\n \n@@ -14661,7 +14658,7 @@ Ptrmask_symbol_expression::do_get_backend(Translate_context* context)\n \n   Bvariable* bvar = this->type_->gc_ptrmask_var(gogo, ptrsize, ptrdata);\n   Location bloc = Linemap::predeclared_location();\n-  Bexpression* bref = gogo->backend()->var_expression(bvar, VE_rvalue, bloc);\n+  Bexpression* bref = gogo->backend()->var_expression(bvar, bloc);\n   Bexpression* baddr = gogo->backend()->address_expression(bref, bloc);\n \n   Type* uint8_type = Type::lookup_integer_type(\"uint8\");\n@@ -15380,8 +15377,7 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n   Gogo* gogo = context->gogo();\n   Location loc = Linemap::predeclared_location();\n   if (this->bvar_ != NULL)\n-    return gogo->backend()->var_expression(this->bvar_, VE_rvalue,\n-                                           this->location());\n+    return gogo->backend()->var_expression(this->bvar_, this->location());\n \n   const Typed_identifier_list* interface_methods = this->itype_->methods();\n   go_assert(!interface_methods->empty());\n@@ -15421,8 +15417,7 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n       this->bvar_ =\n           gogo->backend()->immutable_struct_reference(mangled_name, asm_name,\n                                                       btype, loc);\n-      return gogo->backend()->var_expression(this->bvar_, VE_rvalue,\n-                                             this->location());\n+      return gogo->backend()->var_expression(this->bvar_, this->location());\n     }\n \n   // The first element is the type descriptor.\n@@ -15487,7 +15482,7 @@ Interface_mtable_expression::do_get_backend(Translate_context* context)\n \t\t\t\t\t\t  !is_public, btype, loc);\n   gogo->backend()->immutable_struct_set_init(this->bvar_, mangled_name, false,\n                                              !is_public, btype, loc, ctor);\n-  return gogo->backend()->var_expression(this->bvar_, VE_lvalue, loc);\n+  return gogo->backend()->var_expression(this->bvar_, loc);\n }\n \n void"}, {"sha": "9f58f497f8e48885d25dc9be573d1157ac0cb278", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=f60bea11ada835a0b007469816bd1130a2f9a77a", "patch": "@@ -1298,24 +1298,14 @@ class Var_expression : public Expression\n  public:\n   Var_expression(Named_object* variable, Location location)\n     : Expression(EXPRESSION_VAR_REFERENCE, location),\n-      variable_(variable), in_lvalue_pos_(VE_rvalue)\n+      variable_(variable)\n   { }\n \n   // Return the variable.\n   Named_object*\n   named_object() const\n   { return this->variable_; }\n \n-  // Does this var expression appear in an lvalue (assigned-to) context?\n-  bool\n-  in_lvalue_pos() const\n-  { return this->in_lvalue_pos_ == VE_lvalue; }\n-\n-  // Mark a var_expression as appearing in an lvalue context.\n-  void\n-  set_in_lvalue_pos()\n-  { this->in_lvalue_pos_ = VE_lvalue; }\n-\n  protected:\n   Expression*\n   do_lower(Gogo*, Named_object*, Statement_inserter*, int);\n@@ -1346,8 +1336,6 @@ class Var_expression : public Expression\n  private:\n   // The variable we are referencing.\n   Named_object* variable_;\n-  // Set to TRUE if var expression appears in lvalue context\n-  Varexpr_context in_lvalue_pos_;\n };\n \n // A reference to a variable within an enclosing function."}, {"sha": "54617360060022b163c2d90b8c50c8227620938f", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=f60bea11ada835a0b007469816bd1130a2f9a77a", "patch": "@@ -1394,7 +1394,7 @@ Gogo::write_globals()\n                 {\n                   Location loc = var->location();\n                   Bexpression* var_expr =\n-                      this->backend()->var_expression(bvar, VE_lvalue, loc);\n+                      this->backend()->var_expression(bvar, loc);\n                   var_init_stmt =\n                       this->backend()->assignment_statement(init_bfn, var_expr,\n                                                             var_binit, loc);\n@@ -5798,8 +5798,7 @@ Function::return_value(Gogo* gogo, Named_object* named_function,\n     {\n       Named_object* no = (*this->results_)[i];\n       Bvariable* bvar = no->get_backend_variable(gogo, named_function);\n-      Bexpression* val = gogo->backend()->var_expression(bvar, VE_rvalue,\n-                                                         location);\n+      Bexpression* val = gogo->backend()->var_expression(bvar, location);\n       if (no->result_var_value()->is_in_heap())\n \t{\n \t  Btype* bt = no->result_var_value()->type()->get_backend(gogo);\n@@ -6632,7 +6631,7 @@ Variable::get_init_block(Gogo* gogo, Named_object* function,\n               Expression::make_cast(this->type(), this->init_, loc);\n           Bexpression* val = val_expr->get_backend(&context);\n           Bexpression* var_ref =\n-              gogo->backend()->var_expression(var_decl, VE_lvalue, loc);\n+              gogo->backend()->var_expression(var_decl, loc);\n           decl_init = gogo->backend()->assignment_statement(bfunction, var_ref,\n                                                             val, loc);\n \t}"}, {"sha": "f3e0fd0743469622cee5d5a56f3775b8f6618122", "filename": "gcc/go/gofrontend/operator.h", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Foperator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Foperator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Foperator.h?ref=f60bea11ada835a0b007469816bd1130a2f9a77a", "patch": "@@ -63,10 +63,4 @@ enum Operator\n   OPERATOR_RSQUARE\t// ]\n };\n \n-// Whether a variable expression appears in lvalue (assignment) context.\n-enum Varexpr_context {\n-  VE_rvalue,\n-  VE_lvalue\n-};\n-\n #endif // !defined(GO_OPERATOR_H)"}, {"sha": "b22f690b3d6eac7ace6373175933ce1c5f81a3bf", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 0, "deletions": 97, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=f60bea11ada835a0b007469816bd1130a2f9a77a", "patch": "@@ -836,100 +836,6 @@ Assignment_statement::do_flatten(Gogo*, Named_object*, Block*,\n   return this;\n }\n \n-\n-// Helper class to locate a root Var_expression within an expression\n-// tree and mark it as being in an \"lvalue\" or assignment\n-// context. Examples:\n-//\n-//    x, y = 40, foo(w)\n-//    x[2] = bar(v)\n-//    x.z.w[blah(v + u)], y.another = 2, 3\n-//\n-// In the code above, vars \"x\" and \"y\" appear in lvalue / assignment\n-// context, whereas the other vars \"v\", \"u\", etc are in rvalue context.\n-//\n-// Note: at the moment the Var_expression version of \"do_copy()\"\n-// defaults to returning the original object, not a new object,\n-// meaning that a given Var_expression can be referenced from more\n-// than one place in the tree. This means that when we want to mark a\n-// Var_expression as having lvalue semantics, we need to make a copy\n-// of it. Example:\n-//\n-//    mystruct.myfield += 42\n-//\n-// When this is lowered to eliminate the += operator, we get a tree\n-//\n-//    mystruct.myfield = mystruct.field + 42\n-//\n-// in which the \"mystruct\" same Var_expression is referenced on both\n-// LHS and RHS subtrees. This in turn means that if we try to mark the\n-// LHS Var_expression the RHS Var_expression will also be marked.  To\n-// address this issue, the code below clones any var_expression before\n-// applying an lvalue marking.\n-//\n-\n-class Mark_lvalue_varexprs : public Traverse\n-{\n- public:\n-  Mark_lvalue_varexprs()\n-    : Traverse(traverse_expressions)\n-  { }\n-\n- protected:\n-  int\n-  expression(Expression**);\n-\n- private:\n-};\n-\n-int Mark_lvalue_varexprs::expression(Expression** ppexpr)\n-{\n-  Expression* e = *ppexpr;\n-\n-  Var_expression* ve = e->var_expression();\n-  if (ve)\n-    {\n-      ve = new Var_expression(ve->named_object(), ve->location());\n-      ve->set_in_lvalue_pos();\n-      *ppexpr = ve;\n-      return TRAVERSE_EXIT;\n-    }\n-\n-  Field_reference_expression* fre = e->field_reference_expression();\n-  if (fre != NULL)\n-    return TRAVERSE_CONTINUE;\n-\n-  Array_index_expression* aie = e->array_index_expression();\n-  if (aie != NULL)\n-    {\n-      Mark_lvalue_varexprs mlve;\n-      aie->set_is_lvalue();\n-      aie->array()->traverse_subexpressions(&mlve);\n-      return TRAVERSE_EXIT;\n-    }\n-\n-  Unary_expression* ue = e->unary_expression();\n-  if (ue && ue->op() == OPERATOR_MULT)\n-    return TRAVERSE_CONTINUE;\n-\n-  Type_conversion_expression* ce = e->conversion_expression();\n-  if (ce)\n-    return TRAVERSE_CONTINUE;\n-\n-  Temporary_reference_expression* tre =\n-      e->temporary_reference_expression();\n-  if (tre)\n-    {\n-      tre = new Temporary_reference_expression(tre->statement(),\n-                                               tre->location());\n-      *ppexpr = tre;\n-      tre->set_is_lvalue();\n-      return TRAVERSE_EXIT;\n-    }\n-\n-  return TRAVERSE_EXIT;\n-}\n-\n // Convert an assignment statement to the backend representation.\n \n Bstatement*\n@@ -942,9 +848,6 @@ Assignment_statement::do_get_backend(Translate_context* context)\n       return context->backend()->expression_statement(bfunction, rhs);\n     }\n \n-  Mark_lvalue_varexprs mlve;\n-  Expression::traverse(&this->lhs_, &mlve);\n-\n   Bexpression* lhs = this->lhs_->get_backend(context);\n   Expression* conv =\n       Expression::convert_for_assignment(context->gogo(), this->lhs_->type(),"}, {"sha": "247f40a520258b388465979c4125a79e69e3ca6b", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=f60bea11ada835a0b007469816bd1130a2f9a77a", "patch": "@@ -1206,8 +1206,7 @@ Type::type_descriptor_pointer(Gogo* gogo, Location location)\n       go_assert(t->type_descriptor_var_ != NULL);\n     }\n   Bexpression* var_expr =\n-      gogo->backend()->var_expression(t->type_descriptor_var_,\n-                                      VE_rvalue, location);\n+      gogo->backend()->var_expression(t->type_descriptor_var_, location);\n   Bexpression* var_addr =\n       gogo->backend()->address_expression(var_expr, location);\n   Type* td_type = Type::make_type_descriptor_type();\n@@ -2385,7 +2384,7 @@ Type::gc_symbol_pointer(Gogo* gogo)\n     }\n   Location bloc = Linemap::predeclared_location();\n   Bexpression* var_expr =\n-      gogo->backend()->var_expression(t->gc_symbol_var_, VE_rvalue, bloc);\n+      gogo->backend()->var_expression(t->gc_symbol_var_, bloc);\n   Bexpression* addr_expr =\n       gogo->backend()->address_expression(var_expr, bloc);\n \n@@ -7395,7 +7394,6 @@ Array_type::get_value_pointer(Gogo*, Expression* array, bool is_lvalue) const\n       else if (ve != NULL)\n         {\n           ve = new Var_expression(ve->named_object(), ve->location());\n-          ve->set_in_lvalue_pos();\n           array = ve;\n         }\n     }"}, {"sha": "d0226fca6bb592671a9d71a47a5755c73237dc44", "filename": "gcc/go/gofrontend/wb.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60bea11ada835a0b007469816bd1130a2f9a77a/gcc%2Fgo%2Fgofrontend%2Fwb.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fwb.cc?ref=f60bea11ada835a0b007469816bd1130a2f9a77a", "patch": "@@ -175,7 +175,6 @@ Write_barriers::variable(Named_object* no)\n   // Replace the initializer.\n   Location loc = init->location();\n   Expression* ref = Expression::make_var_reference(no, loc);\n-  ref->var_expression()->set_in_lvalue_pos();\n \n   Statement_inserter inserter(this->gogo_, var);\n   Statement* s = this->gogo_->assign_with_write_barrier(NULL, NULL, &inserter,"}]}