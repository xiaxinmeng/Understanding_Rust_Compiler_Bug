{"sha": "4cbc4bd7ad2977328c354a7088852281a8635c23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNiYzRiZDdhZDI5NzczMjhjMzU0YTcwODg4NTIyODFhODYzNWMyMw==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo.carlini@oracle.com", "date": "2013-05-21T22:49:24Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2013-05-21T22:49:24Z"}, "message": "call.c (build_conditional_expr_1): Add location_t parameter.\n\n/cp\n2013-05-21  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* call.c (build_conditional_expr_1): Add location_t parameter.\n\t(build_conditional_expr): Likewise.\n\t* typeck.c (rationalize_conditional_expr, cp_build_array_ref,\n\tget_member_function_from_ptrfunc, build_x_conditional_expr,\n\tcp_build_modify_expr): Update.\n\t* init.c (build_new_1): Likewise.\n\t* cp-tree.h: Update declaration.\n\n/testsuite\n2013-05-21  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* g++.dg/cpp0x/explicit3.C: Add column in dg-error strings.\n\t* g++.dg/warn/Wdouble-promotion.C: Likewise.\n\nFrom-SVN: r199166", "tree": {"sha": "18afd650a973e2d7b285417843b384e1a2fe755a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/18afd650a973e2d7b285417843b384e1a2fe755a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cbc4bd7ad2977328c354a7088852281a8635c23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cbc4bd7ad2977328c354a7088852281a8635c23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cbc4bd7ad2977328c354a7088852281a8635c23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cbc4bd7ad2977328c354a7088852281a8635c23/comments", "author": null, "committer": null, "parents": [{"sha": "4f7a634e7be19d39eca72e0c8e30e52c9e48f3f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f7a634e7be19d39eca72e0c8e30e52c9e48f3f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f7a634e7be19d39eca72e0c8e30e52c9e48f3f0"}], "stats": {"total": 137, "additions": 76, "deletions": 61}, "files": [{"sha": "b7b87cb4e481a12e96afd13797710ec2ea25cdda", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4cbc4bd7ad2977328c354a7088852281a8635c23", "patch": "@@ -1,3 +1,13 @@\n+2013-05-21  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* call.c (build_conditional_expr_1): Add location_t parameter.\n+\t(build_conditional_expr): Likewise.\n+\t* typeck.c (rationalize_conditional_expr, cp_build_array_ref,\n+\tget_member_function_from_ptrfunc, build_x_conditional_expr,\n+\tcp_build_modify_expr): Update.\n+\t* init.c (build_new_1): Likewise.\n+\t* cp-tree.h: Update declaration.\n+\n 2013-05-20  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/57016"}, {"sha": "71a1589d64ab7bba36fa5feea1c9745e48166ea4", "filename": "gcc/cp/call.c", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4cbc4bd7ad2977328c354a7088852281a8635c23", "patch": "@@ -4353,7 +4353,7 @@ conditional_conversion (tree e1, tree e2, tsubst_flags_t complain)\n    arguments to the conditional expression.  */\n \n static tree\n-build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n+build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n                           tsubst_flags_t complain)\n {\n   tree arg2_type;\n@@ -4373,7 +4373,7 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n   if (!arg2)\n     {\n       if (complain & tf_error)\n-\tpedwarn (input_location, OPT_Wpedantic, \n+\tpedwarn (loc, OPT_Wpedantic, \n \t\t \"ISO C++ forbids omitting the middle term of a ?: expression\");\n \n       /* Make sure that lvalues remain lvalues.  See g++.oliva/ext1.C.  */\n@@ -4407,16 +4407,16 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t  && TREE_CODE (arg3_type) != VECTOR_TYPE)\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"at least one operand of a vector conditional operator \"\n-\t\t   \"must be a vector\");\n+\t    error_at (loc, \"at least one operand of a vector conditional \"\n+\t\t      \"operator must be a vector\");\n \t  return error_mark_node;\n \t}\n \n       if ((TREE_CODE (arg2_type) == VECTOR_TYPE)\n \t  != (TREE_CODE (arg3_type) == VECTOR_TYPE))\n \t{\n \t  enum stv_conv convert_flag =\n-\t    scalar_to_vector (input_location, VEC_COND_EXPR, arg2, arg3,\n+\t    scalar_to_vector (loc, VEC_COND_EXPR, arg2, arg3,\n \t\t\t      complain & tf_error);\n \n \t  switch (convert_flag)\n@@ -4448,14 +4448,15 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t  || TYPE_SIZE (arg1_type) != TYPE_SIZE (arg2_type))\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"incompatible vector types in conditional expression: \"\n-\t\t   \"%qT, %qT and %qT\", TREE_TYPE (arg1), TREE_TYPE (orig_arg2),\n-\t\t   TREE_TYPE (orig_arg3));\n+\t    error_at (loc,\n+\t\t      \"incompatible vector types in conditional expression: \"\n+\t\t      \"%qT, %qT and %qT\", TREE_TYPE (arg1),\n+\t\t      TREE_TYPE (orig_arg2), TREE_TYPE (orig_arg3));\n \t  return error_mark_node;\n \t}\n \n       if (!COMPARISON_CLASS_P (arg1))\n-\targ1 = cp_build_binary_op (input_location, NE_EXPR, arg1,\n+\targ1 = cp_build_binary_op (loc, NE_EXPR, arg1,\n \t\t\t\t   build_zero_cst (arg1_type), complain);\n       return fold_build3 (VEC_COND_EXPR, arg2_type, arg1, arg2, arg3);\n     }\n@@ -4535,15 +4536,15 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n           if (complain & tf_error)\n             {\n               if (VOID_TYPE_P (arg2_type))\n-                error (\"second operand to the conditional operator \"\n-                       \"is of type %<void%>, \"\n-                       \"but the third operand is neither a throw-expression \"\n-                       \"nor of type %<void%>\");\n+                error_at (EXPR_LOC_OR_LOC (arg3, loc),\n+\t\t\t  \"second operand to the conditional operator \"\n+\t\t\t  \"is of type %<void%>, but the third operand is \"\n+\t\t\t  \"neither a throw-expression nor of type %<void%>\");\n               else\n-                error (\"third operand to the conditional operator \"\n-                       \"is of type %<void%>, \"\n-                       \"but the second operand is neither a throw-expression \"\n-                       \"nor of type %<void%>\");\n+                error_at (EXPR_LOC_OR_LOC (arg2, loc),\n+\t\t\t  \"third operand to the conditional operator \"\n+\t\t\t  \"is of type %<void%>, but the second operand is \"\n+\t\t\t  \"neither a throw-expression nor of type %<void%>\");\n             }\n \t  return error_mark_node;\n \t}\n@@ -4583,8 +4584,8 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t  || (conv3 && conv3->kind == ck_ambig))\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"operands to ?: have different types %qT and %qT\",\n-\t\t   arg2_type, arg3_type);\n+\t    error_at (loc, \"operands to ?: have different types %qT and %qT\",\n+\t\t      arg2_type, arg3_type);\n \t  result = error_mark_node;\n \t}\n       else if (conv2 && (!conv2->bad_p || !conv3))\n@@ -4690,9 +4691,8 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t{\n           if (complain & tf_error)\n             {\n-              op_error (input_location, COND_EXPR, NOP_EXPR,\n-\t\t\targ1, arg2, arg3, FALSE);\n-              print_z_candidates (location_of (arg1), candidates);\n+              op_error (loc, COND_EXPR, NOP_EXPR, arg1, arg2, arg3, FALSE);\n+              print_z_candidates (loc, candidates);\n             }\n \t  return error_mark_node;\n \t}\n@@ -4701,9 +4701,8 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t{\n           if (complain & tf_error)\n             {\n-              op_error (input_location, COND_EXPR, NOP_EXPR,\n-\t\t\targ1, arg2, arg3, FALSE);\n-              print_z_candidates (location_of (arg1), candidates);\n+              op_error (loc, COND_EXPR, NOP_EXPR, arg1, arg2, arg3, FALSE);\n+              print_z_candidates (loc, candidates);\n             }\n \t  return error_mark_node;\n \t}\n@@ -4770,7 +4769,7 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \tdo_warn_double_promotion (result_type, arg2_type, arg3_type,\n \t\t\t\t  \"implicit conversion from %qT to %qT to \"\n \t\t\t\t  \"match other result of conditional\",\n-\t\t\t\t  input_location);\n+\t\t\t\t  loc);\n \n       if (TREE_CODE (arg2_type) == ENUMERAL_TYPE\n \t  && TREE_CODE (arg3_type) == ENUMERAL_TYPE)\n@@ -4781,19 +4780,20 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n \t    /* Two enumerators from the same enumeration can have different\n \t       types when the enumeration is still being defined.  */;\n           else if (complain & tf_warning)\n-            warning (OPT_Wenum_compare, \n-                     \"enumeral mismatch in conditional expression: %qT vs %qT\",\n-                     arg2_type, arg3_type);\n+            warning_at (loc, OPT_Wenum_compare, \"enumeral mismatch in \"\n+\t\t\t\"conditional expression: %qT vs %qT\",\n+\t\t\targ2_type, arg3_type);\n         }\n       else if (extra_warnings\n \t       && ((TREE_CODE (arg2_type) == ENUMERAL_TYPE\n \t\t    && !same_type_p (arg3_type, type_promotes_to (arg2_type)))\n \t\t   || (TREE_CODE (arg3_type) == ENUMERAL_TYPE\n-\t\t       && !same_type_p (arg2_type, type_promotes_to (arg3_type)))))\n+\t\t       && !same_type_p (arg2_type,\n+\t\t\t\t\ttype_promotes_to (arg3_type)))))\n         {\n           if (complain & tf_warning)\n-            warning (0, \n-                     \"enumeral and non-enumeral type in conditional expression\");\n+            warning_at (loc, 0, \"enumeral and non-enumeral type in \"\n+\t\t\t\"conditional expression\");\n         }\n \n       arg2 = perform_implicit_conversion (result_type, arg2, complain);\n@@ -4835,8 +4835,8 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n   if (!result_type)\n     {\n       if (complain & tf_error)\n-        error (\"operands to ?: have different types %qT and %qT\",\n-               arg2_type, arg3_type);\n+        error_at (loc, \"operands to ?: have different types %qT and %qT\",\n+\t\t  arg2_type, arg3_type);\n       return error_mark_node;\n     }\n \n@@ -4873,12 +4873,12 @@ build_conditional_expr_1 (tree arg1, tree arg2, tree arg3,\n /* Wrapper for above.  */\n \n tree\n-build_conditional_expr (tree arg1, tree arg2, tree arg3,\n+build_conditional_expr (location_t loc, tree arg1, tree arg2, tree arg3,\n                         tsubst_flags_t complain)\n {\n   tree ret;\n   bool subtime = timevar_cond_start (TV_OVERLOAD);\n-  ret = build_conditional_expr_1 (arg1, arg2, arg3, complain);\n+  ret = build_conditional_expr_1 (loc, arg1, arg2, arg3, complain);\n   timevar_cond_stop (TV_OVERLOAD, subtime);\n   return ret;\n }"}, {"sha": "1f85ca7196fafccba623b7c8f827522b8191648f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4cbc4bd7ad2977328c354a7088852281a8635c23", "patch": "@@ -4969,7 +4969,7 @@ extern bool pragma_java_exceptions;\n /* in call.c */\n extern bool check_dtor_name\t\t\t(tree, tree);\n \n-extern tree build_conditional_expr\t\t(tree, tree, tree, \n+extern tree build_conditional_expr\t\t(location_t, tree, tree, tree, \n                                                  tsubst_flags_t);\n extern tree build_addr_func\t\t\t(tree, tsubst_flags_t);\n extern void set_flags_from_callee\t\t(tree);"}, {"sha": "671c774587d9f2e6e33fc6b882634df2f8f2be5c", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4cbc4bd7ad2977328c354a7088852281a8635c23", "patch": "@@ -2900,8 +2900,8 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \t\t\t\t\t   NE_EXPR, alloc_node,\n \t\t\t\t\t   nullptr_node,\n \t\t\t\t\t   complain);\n-\t  rval = build_conditional_expr (ifexp, rval, alloc_node, \n-                                         complain);\n+\t  rval = build_conditional_expr (input_location, ifexp, rval,\n+\t\t\t\t\t alloc_node, complain);\n \t}\n \n       /* Perform the allocation before anything else, so that ALLOC_NODE"}, {"sha": "11ac85b65cd920c839269772799ee047606a64b5", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4cbc4bd7ad2977328c354a7088852281a8635c23", "patch": "@@ -2141,7 +2141,8 @@ rationalize_conditional_expr (enum tree_code code, tree t,\n       gcc_assert (!TREE_SIDE_EFFECTS (op0)\n \t\t  && !TREE_SIDE_EFFECTS (op1));\n       return\n-\tbuild_conditional_expr (build_x_binary_op (input_location,\n+\tbuild_conditional_expr (EXPR_LOC_OR_HERE (t),\n+\t\t\t\tbuild_x_binary_op (EXPR_LOC_OR_HERE (t),\n \t\t\t\t\t\t   (TREE_CODE (t) == MIN_EXPR\n \t\t\t\t\t\t    ? LE_EXPR : GE_EXPR),\n \t\t\t\t\t\t   op0, TREE_CODE (op0),\n@@ -2154,7 +2155,7 @@ rationalize_conditional_expr (enum tree_code code, tree t,\n     }\n \n   return\n-    build_conditional_expr (TREE_OPERAND (t, 0),\n+    build_conditional_expr (EXPR_LOC_OR_HERE (t), TREE_OPERAND (t, 0),\n \t\t\t    cp_build_unary_op (code, TREE_OPERAND (t, 1), 0,\n                                                complain),\n \t\t\t    cp_build_unary_op (code, TREE_OPERAND (t, 2), 0,\n@@ -3024,7 +3025,7 @@ cp_build_array_ref (location_t loc, tree array, tree idx,\n \n     case COND_EXPR:\n       ret = build_conditional_expr\n-\t      (TREE_OPERAND (array, 0),\n+\t       (loc, TREE_OPERAND (array, 0),\n \t       cp_build_array_ref (loc, TREE_OPERAND (array, 1), idx,\n \t\t\t\t   complain),\n \t       cp_build_array_ref (loc, TREE_OPERAND (array, 2), idx,\n@@ -3306,7 +3307,7 @@ get_member_function_from_ptrfunc (tree *instance_ptrptr, tree function,\n \t\t     cp_build_addr_expr (e2, complain));\n \n       e2 = fold_convert (TREE_TYPE (e3), e2);\n-      e1 = build_conditional_expr (e1, e2, e3, complain);\n+      e1 = build_conditional_expr (input_location, e1, e2, e3, complain);\n       if (e1 == error_mark_node)\n \treturn error_mark_node;\n \n@@ -5902,7 +5903,7 @@ build_x_conditional_expr (location_t loc, tree ifexp, tree op1, tree op2,\n       op2 = build_non_dependent_expr (op2);\n     }\n \n-  expr = build_conditional_expr (ifexp, op1, op2, complain);\n+  expr = build_conditional_expr (loc, ifexp, op1, op2, complain);\n   if (processing_template_decl && expr != error_mark_node\n       && TREE_CODE (expr) != VEC_COND_EXPR)\n     {\n@@ -7152,7 +7153,7 @@ cp_build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs,\n \t  return error_mark_node;\n \n \tcond = build_conditional_expr\n-\t  (TREE_OPERAND (lhs, 0),\n+\t  (input_location, TREE_OPERAND (lhs, 0),\n \t   cp_build_modify_expr (TREE_OPERAND (lhs, 1),\n \t\t\t\t modifycode, rhs, complain),\n \t   cp_build_modify_expr (TREE_OPERAND (lhs, 2),"}, {"sha": "29f1b7f9d3d89b0f590a19bf9d34b907d4447ee5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4cbc4bd7ad2977328c354a7088852281a8635c23", "patch": "@@ -1,3 +1,8 @@\n+2013-05-21  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* g++.dg/cpp0x/explicit3.C: Add column in dg-error strings.\n+\t* g++.dg/warn/Wdouble-promotion.C: Likewise.\n+\n 2013-05-21  Easwaran Raman  <eraman@google.com>\n \n \tPR tree-optimization/57322"}, {"sha": "78d6f590cab7c4dd5b9687ba31fd8b674acaa06e", "filename": "gcc/testsuite/g++.dg/cpp0x/explicit3.C", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fexplicit3.C?ref=4cbc4bd7ad2977328c354a7088852281a8635c23", "patch": "@@ -42,10 +42,9 @@ int main()\n   // These do not.\n   switch (a); \t\t\t// { dg-error \"\" }\n   bool b = a;\t\t\t// { dg-error \"\" }\n-  // { dg-message \"candidate\" \"candidate note\" { target *-*-* } 44 }\n   f(a);\t\t\t\t// { dg-error \"\" }\n   B b2 = { a };\t\t\t// { dg-error \"\" }\n-  a + true;\t\t\t// { dg-message \"\" }\n-  b ? a : true;\t\t\t// { dg-message \"\" }\n-  a ? a : true;\t\t\t// { dg-message \"\" }\n+  a + true;\t\t\t// { dg-error \"5:no match\" }\n+  b ? a : true;\t\t\t// { dg-error \"5:no match\" }\n+  a ? a : true;\t\t\t// { dg-error \"5:no match\" }\n }"}, {"sha": "f4aafc531ac0e9957ce9ea95cb351050017eb86b", "filename": "gcc/testsuite/g++.dg/warn/Wdouble-promotion.C", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdouble-promotion.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cbc4bd7ad2977328c354a7088852281a8635c23/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdouble-promotion.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWdouble-promotion.C?ref=4cbc4bd7ad2977328c354a7088852281a8635c23", "patch": "@@ -29,19 +29,19 @@ usual_arithmetic_conversions(void)\n   /* Values of type \"float\" are implicitly converted to \"double\" or\n      \"long double\" due to use in arithmetic with \"double\" or \"long\n      double\" operands.  */\n-  local_f = f + 1.0;         /* { dg-warning \"implicit\" } */\n-  local_f = f - d;           /* { dg-warning \"implicit\" } */\n-  local_f = 1.0f * 1.0;      /* { dg-warning \"implicit\" } */\n-  local_f = 1.0f / d;        /* { dg-warning \"implicit\" } */\n-\n-  local_cf = cf + 1.0;       /* { dg-warning \"implicit\" } */\n-  local_cf = cf - d;         /* { dg-warning \"implicit\" } */\n-  local_cf = cf + 1.0 * ID;  /* { dg-warning \"implicit\" } */\n-  local_cf = cf - cd;        /* { dg-warning \"implicit\" } */\n+  local_f = f + 1.0;         /* { dg-warning \"15:implicit\" } */\n+  local_f = f - d;           /* { dg-warning \"15:implicit\" } */\n+  local_f = 1.0f * 1.0;      /* { dg-warning \"18:implicit\" } */\n+  local_f = 1.0f / d;        /* { dg-warning \"18:implicit\" } */\n+\n+  local_cf = cf + 1.0;       /* { dg-warning \"17:implicit\" } */\n+  local_cf = cf - d;         /* { dg-warning \"17:implicit\" } */\n+  local_cf = cf + 1.0 * ID;  /* { dg-warning \"17:implicit\" } */\n+  local_cf = cf - cd;        /* { dg-warning \"17:implicit\" } */\n   \n-  local_f = i ? f : d;       /* { dg-warning \"implicit\" } */\n-  i = f == d;                /* { dg-warning \"implicit\" } */\n-  i = d != f;                /* { dg-warning \"implicit\" } */\n+  local_f = i ? f : d;       /* { dg-warning \"15:implicit\" } */\n+  i = f == d;                /* { dg-warning \"9:implicit\" } */\n+  i = d != f;                /* { dg-warning \"9:implicit\" } */\n }\n \n void "}]}