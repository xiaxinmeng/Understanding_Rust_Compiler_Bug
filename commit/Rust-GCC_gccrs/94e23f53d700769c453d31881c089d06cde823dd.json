{"sha": "94e23f53d700769c453d31881c089d06cde823dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRlMjNmNTNkNzAwNzY5YzQ1M2QzMTg4MWMwODlkMDZjZGU4MjNkZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-13T17:04:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-13T17:04:08Z"}, "message": "Turn SECONDARY_MEMORY_NEEDED_MODE into a target hook\n\nThis includes a change to LRA.  Previously the code was:\n\n    if (sclass == NO_REGS && dclass == NO_REGS)\n      return false;\n  #ifdef SECONDARY_MEMORY_NEEDED\n    if (SECONDARY_MEMORY_NEEDED (sclass, dclass, GET_MODE (src))\n  #ifdef SECONDARY_MEMORY_NEEDED_MODE\n        && ((sclass != NO_REGS && dclass != NO_REGS)\n            || GET_MODE (src) != SECONDARY_MEMORY_NEEDED_MODE (GET_MODE (src)))\n  #endif\n        )\n      {\n        *sec_mem_p = true;\n        return false;\n      }\n  #endif\n\nin which the positioning of the second ifdef meant that defining\nSECONDARY_MEMORY_NEEDED_MODE to its default value was not a no-op:\nwithout a definition, we would consider using secondary reloads for\nmem<-reg and reg<-mem reloads even if the secondary memory has the\nsame mode as the original mem, while defining it would avoid this.\nThe latter behaviour seems correct.\n\nThe default is different for reload and LRA.  For LRA the default is\nto use the original mode, while reload promotes smaller-than-word\nintegral modes to word mode:\n\n  if (GET_MODE_BITSIZE (mode) < BITS_PER_WORD && INTEGRAL_MODE_P (mode))\n    mode = mode_for_size (BITS_PER_WORD,\n                          GET_MODE_CLASS (mode), 0).require ();\n\nSome of the ports that have switched to LRA seemed to have\nSECONDARY_MEMORY_NEEDED_MDOEs based on the old reload definition,\nand still referred to the reload.c:get_secondary_mem function in\nthe comments.  The patch just keeps them as-is.\n\n2017-09-13  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* target.def (secondary_memory_needed_mode): New hook:\n\t* targhooks.c (default_secondary_memory_needed_mode): Declare.\n\t* targhooks.h (default_secondary_memory_needed_mode): New function.\n\t* doc/tm.texi.in (SECONDARY_MEMORY_NEEDED_MODE): Replace with...\n\t(TARGET_SECONDARY_MEMORY_NEEDED_MODE): ...this.\n\t* doc/tm.texi: Regenerate.\n\t* lra-constraints.c (check_and_process_move): Use\n\ttargetm.secondary_memory_needed_mode instead of\n\tTARGET_SECONDARY_MEMORY_NEEDED_MODE.\n\t(curr_insn_transform): Likewise.\n\t* reload.c (get_secondary_mem): Likewise.\n\t* config/alpha/alpha.h (SECONDARY_MEMORY_NEEDED_MODE): Delete.\n\t* config/alpha/alpha.c (alpha_secondary_memory_needed_mode): New\n\tfunction.\n\t(TARGET_SECONDARY_MEMORY_NEEDED_MODE): Redefine.\n\t* config/i386/i386.h (SECONDARY_MEMORY_NEEDED_MODE): Delete.\n\t* config/i386/i386.c (ix86_secondary_memory_needed_mode): New function.\n\t(TARGET_SECONDARY_MEMORY_NEEDED_MODE): Redefine.\n\t* config/powerpcspe/powerpcspe.h (SECONDARY_MEMORY_NEEDED_MODE):\n\tDelete.\n\t* config/powerpcspe/powerpcspe-protos.h\n\t(rs6000_secondary_memory_needed_mode): Delete.\n\t* config/powerpcspe/powerpcspe.c\n\t(TARGET_SECONDARY_MEMORY_NEEDED_MODE): Redefine.\n\t(rs6000_secondary_memory_needed_mode): Make static.\n\t* config/rs6000/rs6000.h (SECONDARY_MEMORY_NEEDED_MODE): Delete.\n\t* config/rs6000/rs6000-protos.h (rs6000_secondary_memory_needed_mode):\n\tDelete.\n\t* config/rs6000/rs6000.c (TARGET_SECONDARY_MEMORY_NEEDED_MODE):\n\tRedefine.\n\t(rs6000_secondary_memory_needed_mode): Make static.\n\t* config/s390/s390.h (SECONDARY_MEMORY_NEEDED_MODE): Delete.\n\t* config/s390/s390.c (s390_secondary_memory_needed_mode): New function.\n\t(TARGET_SECONDARY_MEMORY_NEEDED_MODE): Redefine.\n\t* config/sparc/sparc.h (SECONDARY_MEMORY_NEEDED_MODE): Delete.\n\t* config/sparc/sparc.c (TARGET_SECONDARY_MEMORY_NEEDED_MODE):\n\tRedefine.\n\t(sparc_secondary_memory_needed_mode): New function.\n\t* system.h (TARGET_SECONDARY_MEMORY_NEEDED_MODE): Poison.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r252455", "tree": {"sha": "c40d61202954230108cceb97d333c2c34f9c4ddb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c40d61202954230108cceb97d333c2c34f9c4ddb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94e23f53d700769c453d31881c089d06cde823dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e23f53d700769c453d31881c089d06cde823dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94e23f53d700769c453d31881c089d06cde823dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94e23f53d700769c453d31881c089d06cde823dd/comments", "author": null, "committer": null, "parents": [{"sha": "bb5d97112a8272c608b18167de9255949129890c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb5d97112a8272c608b18167de9255949129890c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb5d97112a8272c608b18167de9255949129890c"}], "stats": {"total": 305, "additions": 187, "deletions": 118}, "files": [{"sha": "6b8f7f3fa1669580f6998fc8fdda034df5340cb8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -1,3 +1,47 @@\n+2017-09-13  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* target.def (secondary_memory_needed_mode): New hook:\n+\t* targhooks.c (default_secondary_memory_needed_mode): Declare.\n+\t* targhooks.h (default_secondary_memory_needed_mode): New function.\n+\t* doc/tm.texi.in (SECONDARY_MEMORY_NEEDED_MODE): Replace with...\n+\t(TARGET_SECONDARY_MEMORY_NEEDED_MODE): ...this.\n+\t* doc/tm.texi: Regenerate.\n+\t* lra-constraints.c (check_and_process_move): Use\n+\ttargetm.secondary_memory_needed_mode instead of\n+\tTARGET_SECONDARY_MEMORY_NEEDED_MODE.\n+\t(curr_insn_transform): Likewise.\n+\t* reload.c (get_secondary_mem): Likewise.\n+\t* config/alpha/alpha.h (SECONDARY_MEMORY_NEEDED_MODE): Delete.\n+\t* config/alpha/alpha.c (alpha_secondary_memory_needed_mode): New\n+\tfunction.\n+\t(TARGET_SECONDARY_MEMORY_NEEDED_MODE): Redefine.\n+\t* config/i386/i386.h (SECONDARY_MEMORY_NEEDED_MODE): Delete.\n+\t* config/i386/i386.c (ix86_secondary_memory_needed_mode): New function.\n+\t(TARGET_SECONDARY_MEMORY_NEEDED_MODE): Redefine.\n+\t* config/powerpcspe/powerpcspe.h (SECONDARY_MEMORY_NEEDED_MODE):\n+\tDelete.\n+\t* config/powerpcspe/powerpcspe-protos.h\n+\t(rs6000_secondary_memory_needed_mode): Delete.\n+\t* config/powerpcspe/powerpcspe.c\n+\t(TARGET_SECONDARY_MEMORY_NEEDED_MODE): Redefine.\n+\t(rs6000_secondary_memory_needed_mode): Make static.\n+\t* config/rs6000/rs6000.h (SECONDARY_MEMORY_NEEDED_MODE): Delete.\n+\t* config/rs6000/rs6000-protos.h (rs6000_secondary_memory_needed_mode):\n+\tDelete.\n+\t* config/rs6000/rs6000.c (TARGET_SECONDARY_MEMORY_NEEDED_MODE):\n+\tRedefine.\n+\t(rs6000_secondary_memory_needed_mode): Make static.\n+\t* config/s390/s390.h (SECONDARY_MEMORY_NEEDED_MODE): Delete.\n+\t* config/s390/s390.c (s390_secondary_memory_needed_mode): New function.\n+\t(TARGET_SECONDARY_MEMORY_NEEDED_MODE): Redefine.\n+\t* config/sparc/sparc.h (SECONDARY_MEMORY_NEEDED_MODE): Delete.\n+\t* config/sparc/sparc.c (TARGET_SECONDARY_MEMORY_NEEDED_MODE):\n+\tRedefine.\n+\t(sparc_secondary_memory_needed_mode): New function.\n+\t* system.h (TARGET_SECONDARY_MEMORY_NEEDED_MODE): Poison.\n+\n 2017-09-13  Jackson Woodruff  <jackson.woodruff@arm.com>\n \n \t* config/aarch64/constraints.md (Umq): New constraint."}, {"sha": "28fe4672b9c645bcc221b13c1efad56f501e56c7", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -1688,6 +1688,21 @@ alpha_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n \n   return NO_REGS;\n }\n+\n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED_MODE.  If MODE is\n+   floating-point, use it.  Otherwise, widen to a word like the default.\n+   This is needed because we always store integers in FP registers in\n+   quadword format.  This whole area is very tricky!  */\n+\n+static machine_mode\n+alpha_secondary_memory_needed_mode (machine_mode mode)\n+{\n+  if (GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    return mode;\n+  if (GET_MODE_SIZE (mode) >= 4)\n+    return mode;\n+  return mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (mode), 0).require ();\n+}\n \f\n /* Given SEQ, which is an INSN list, look for any MEMs in either\n    a SET_DEST or a SET_SRC and copy the in-struct, unchanging, and\n@@ -10062,6 +10077,8 @@ alpha_modes_tieable_p (machine_mode mode1, machine_mode mode2)\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD alpha_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n+#define TARGET_SECONDARY_MEMORY_NEEDED_MODE alpha_secondary_memory_needed_mode\n \n #undef TARGET_SCALAR_MODE_SUPPORTED_P\n #define TARGET_SCALAR_MODE_SUPPORTED_P alpha_scalar_mode_supported_p"}, {"sha": "10f32b73db86738aaba656367a8af5e221ec9fc3", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -486,16 +486,6 @@ enum reg_class {\n  (! TARGET_FIX && (((CLASS1) == FLOAT_REGS && (CLASS2) != FLOAT_REGS) \\\n                    || ((CLASS2) == FLOAT_REGS && (CLASS1) != FLOAT_REGS)))\n \n-/* Specify the mode to be used for memory when a secondary memory\n-   location is needed.  If MODE is floating-point, use it.  Otherwise,\n-   widen to a word like the default.  This is needed because we always\n-   store integers in FP registers in quadword format.  This whole\n-   area is very tricky! */\n-#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\\\n-  (GET_MODE_CLASS (MODE) == MODE_FLOAT ? (MODE)\t\t\\\n-   : GET_MODE_SIZE (MODE) >= 4 ? (MODE)\t\t\t\\\n-   : mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (MODE), 0).require ())\n-\n /* Return the class of registers that cannot change mode from FROM to TO.  */\n \n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS)\t\t\\"}, {"sha": "a508f568eaf5704fc2bace0882c6819f0a4b3d9f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -41162,6 +41162,20 @@ ix86_secondary_memory_needed (enum reg_class class1, enum reg_class class2,\n   return inline_secondary_memory_needed (class1, class2, mode, strict);\n }\n \n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED_MODE.\n+\n+   get_secondary_mem widens integral modes to BITS_PER_WORD.\n+   There is no need to emit full 64 bit move on 64 bit targets\n+   for integral modes that can be moved using 32 bit move.  */\n+\n+static machine_mode\n+ix86_secondary_memory_needed_mode (machine_mode mode)\n+{\n+  if (GET_MODE_BITSIZE (mode) < 32 && INTEGRAL_MODE_P (mode))\n+    return mode_for_size (32, GET_MODE_CLASS (mode), 0).require ();\n+  return mode;\n+}\n+\n /* Implement the TARGET_CLASS_MAX_NREGS hook.\n \n    On the 80386, this is the size of MODE in words,\n@@ -53206,6 +53220,8 @@ ix86_run_selftests (void)\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD ix86_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n+#define TARGET_SECONDARY_MEMORY_NEEDED_MODE ix86_secondary_memory_needed_mode\n \n #undef TARGET_CLASS_MAX_NREGS\n #define TARGET_CLASS_MAX_NREGS ix86_class_max_nregs"}, {"sha": "09b8da564eca59dbb65ca6451e584f815ef73a7c", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -1524,14 +1524,6 @@ enum reg_class\n #define SECONDARY_MEMORY_NEEDED(CLASS1, CLASS2, MODE) \\\n   ix86_secondary_memory_needed ((CLASS1), (CLASS2), (MODE), 1)\n \n-/* Get_secondary_mem widens integral modes to BITS_PER_WORD.\n-   There is no need to emit full 64 bit move on 64 bit targets\n-   for integral modes that can be moved using 32 bit move.  */\n-#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\t\\\n-  (GET_MODE_BITSIZE (MODE) < 32 && INTEGRAL_MODE_P (MODE)\t\\\n-   ? mode_for_size (32, GET_MODE_CLASS (MODE), 0).require ()\t\\\n-   : MODE)\n-\n /* Return a class of registers that cannot change FROM mode to TO mode.  */\n \n #define CANNOT_CHANGE_MODE_CLASS(FROM, TO, CLASS) \\"}, {"sha": "f3aa41bc516d4f0ec05b02b9a8a79a436d391ab1", "filename": "gcc/config/powerpcspe/powerpcspe-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-protos.h?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -154,7 +154,6 @@ extern void rs6000_emit_le_vsx_move (rtx, rtx, machine_mode);\n extern bool valid_sf_si_move (rtx, rtx, machine_mode);\n extern void rs6000_emit_move (rtx, rtx, machine_mode);\n extern rtx rs6000_secondary_memory_needed_rtx (machine_mode);\n-extern machine_mode rs6000_secondary_memory_needed_mode (machine_mode);\n extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, machine_mode,\n \t\t\t\t\t\t    int, int, int, int *);\n extern bool rs6000_legitimate_offset_address_p (machine_mode, rtx,"}, {"sha": "9b8d68b8ea7c955d7611f8ec0174f5c76523f794", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -1897,6 +1897,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD rs6000_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n+#define TARGET_SECONDARY_MEMORY_NEEDED_MODE rs6000_secondary_memory_needed_mode\n \n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P rs6000_legitimate_address_p\n@@ -21811,10 +21813,9 @@ rs6000_secondary_memory_needed_rtx (machine_mode mode)\n   return ret;\n }\n \n-/* Return the mode to be used for memory when a secondary memory\n-   location is needed.  For SDmode values we need to use DDmode, in\n-   all other cases we can use the same mode.  */\n-machine_mode\n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED_MODE.  For SDmode values we\n+   need to use DDmode, in all other cases we can use the same mode.  */\n+static machine_mode\n rs6000_secondary_memory_needed_mode (machine_mode mode)\n {\n   if (lra_in_progress && mode == SDmode)"}, {"sha": "5d1a138f75825df53dd1e18f256a0e333aa79224", "filename": "gcc/config/powerpcspe/powerpcspe.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.h?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -1611,13 +1611,6 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define SECONDARY_MEMORY_NEEDED_RTX(MODE) \\\n   rs6000_secondary_memory_needed_rtx (MODE)\n \n-/* Specify the mode to be used for memory when a secondary memory\n-   location is needed.  For cpus that cannot load/store SDmode values\n-   from the 64-bit FP registers without using a full 64-bit\n-   load/store, we need a wider mode.  */\n-#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\\\n-  rs6000_secondary_memory_needed_mode (MODE)\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n "}, {"sha": "b21652b40b49cc2fef05a85b243d31dbca9b4c49", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -155,7 +155,6 @@ extern void rs6000_emit_le_vsx_permute (rtx, rtx, machine_mode);\n extern void rs6000_emit_le_vsx_move (rtx, rtx, machine_mode);\n extern bool valid_sf_si_move (rtx, rtx, machine_mode);\n extern void rs6000_emit_move (rtx, rtx, machine_mode);\n-extern machine_mode rs6000_secondary_memory_needed_mode (machine_mode);\n extern rtx (*rs6000_legitimize_reload_address_ptr) (rtx, machine_mode,\n \t\t\t\t\t\t    int, int, int, int *);\n extern bool rs6000_legitimate_offset_address_p (machine_mode, rtx,"}, {"sha": "a4a89d03dfead74502aa56636adad597db481a8b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -1876,6 +1876,8 @@ static const struct attribute_spec rs6000_attribute_table[] =\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD rs6000_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n+#define TARGET_SECONDARY_MEMORY_NEEDED_MODE rs6000_secondary_memory_needed_mode\n \n #undef TARGET_LEGITIMATE_ADDRESS_P\n #define TARGET_LEGITIMATE_ADDRESS_P rs6000_legitimate_address_p\n@@ -19242,10 +19244,9 @@ mems_ok_for_quad_peep (rtx mem1, rtx mem2)\n   return 1;\n }\n \f\n-/* Return the mode to be used for memory when a secondary memory\n-   location is needed.  For SDmode values we need to use DDmode, in\n-   all other cases we can use the same mode.  */\n-machine_mode\n+/* Implement TARGET_SECONDARY_RELOAD_NEEDED_MODE.  For SDmode values we\n+   need to use DDmode, in all other cases we can use the same mode.  */\n+static machine_mode\n rs6000_secondary_memory_needed_mode (machine_mode mode)\n {\n   if (lra_in_progress && mode == SDmode)"}, {"sha": "1a7ce96202048451d1a4961cee8926fc68e89a8e", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -1514,13 +1514,6 @@ extern enum reg_class rs6000_constraints[RS6000_CONSTRAINT_MAX];\n #define SECONDARY_MEMORY_NEEDED(CLASS1,CLASS2,MODE)\t\t\t\\\n   rs6000_secondary_memory_needed_ptr (CLASS1, CLASS2, MODE)\n \n-/* Specify the mode to be used for memory when a secondary memory\n-   location is needed.  For cpus that cannot load/store SDmode values\n-   from the 64-bit FP registers without using a full 64-bit\n-   load/store, we need a wider mode.  */\n-#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\\\n-  rs6000_secondary_memory_needed_mode (MODE)\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n "}, {"sha": "1319f680eb13d0d1b8f27b919a27310c2b984995", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -4409,6 +4409,19 @@ s390_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   return NO_REGS;\n }\n \n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED_MODE.\n+\n+   get_secondary_mem widens its argument to BITS_PER_WORD which loses on 64bit\n+   because the movsi and movsf patterns don't handle r/f moves.  */\n+\n+static machine_mode\n+s390_secondary_memory_needed_mode (machine_mode mode)\n+{\n+  if (GET_MODE_BITSIZE (mode) < 32)\n+    return mode_for_size (32, GET_MODE_CLASS (mode), 0).require ();\n+  return mode;\n+}\n+\n /* Generate code to load SRC, which is PLUS that is not a\n    legitimate operand for the LA instruction, into TARGET.\n    SCRATCH may be used as scratch register.  */\n@@ -15959,6 +15972,8 @@ s390_asan_shadow_offset (void)\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD s390_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n+#define TARGET_SECONDARY_MEMORY_NEEDED_MODE s390_secondary_memory_needed_mode\n \n #undef TARGET_LIBGCC_CMP_RETURN_MODE\n #define TARGET_LIBGCC_CMP_RETURN_MODE s390_libgcc_cmp_return_mode"}, {"sha": "b4a23c3aa8cd1b416d2a4cf072cde362dd3927e0", "filename": "gcc/config/s390/s390.h", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fs390%2Fs390.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fs390%2Fs390.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.h?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -599,13 +599,6 @@ extern const enum reg_class regclass_map[FIRST_PSEUDO_REGISTER];\n    && (!TARGET_VX || (SCALAR_FLOAT_MODE_P (MODE)\t\t\t\\\n \t\t\t  && GET_MODE_SIZE (MODE) > 8)))\n \n-/* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on 64bit\n-   because the movsi and movsf patterns don't handle r/f moves.  */\n-#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\t\\\n- (GET_MODE_BITSIZE (MODE) < 32\t\t\t\t\t\\\n-  ? mode_for_size (32, GET_MODE_CLASS (MODE), 0).require ()\t\\\n-  : (MODE))\n-\n \n /* Stack layout and calling conventions.  */\n "}, {"sha": "469b03d2f8883464890579e82656ec061b9a568a", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -672,6 +672,7 @@ static void sparc_print_operand_address (FILE *, machine_mode, rtx);\n static reg_class_t sparc_secondary_reload (bool, rtx, reg_class_t,\n \t\t\t\t\t   machine_mode,\n \t\t\t\t\t   secondary_reload_info *);\n+static machine_mode sparc_secondary_memory_needed_mode (machine_mode);\n static scalar_int_mode sparc_cstore_mode (enum insn_code icode);\n static void sparc_atomic_assign_expand_fenv (tree *, tree *, tree *);\n static bool sparc_fixed_condition_code_regs (unsigned int *, unsigned int *);\n@@ -859,6 +860,8 @@ char sparc_hard_reg_printed[8];\n \n #undef TARGET_SECONDARY_RELOAD\n #define TARGET_SECONDARY_RELOAD sparc_secondary_reload\n+#undef TARGET_SECONDARY_MEMORY_NEEDED_MODE\n+#define TARGET_SECONDARY_MEMORY_NEEDED_MODE sparc_secondary_memory_needed_mode\n \n #undef TARGET_CONDITIONAL_REGISTER_USAGE\n #define TARGET_CONDITIONAL_REGISTER_USAGE sparc_conditional_register_usage\n@@ -13050,6 +13053,30 @@ sparc_secondary_reload (bool in_p, rtx x, reg_class_t rclass_i,\n   return NO_REGS;\n }\n \n+/* Implement TARGET_SECONDARY_MEMORY_NEEDED_MODE.\n+\n+   get_secondary_mem widens its argument to BITS_PER_WORD which loses on v9\n+   because the movsi and movsf patterns don't handle r/f moves.\n+   For v8 we copy the default definition.  */\n+\n+static machine_mode\n+sparc_secondary_memory_needed_mode (machine_mode mode)\n+{\n+  if (TARGET_ARCH64)\n+    {\n+      if (GET_MODE_BITSIZE (mode) < 32)\n+\treturn mode_for_size (32, GET_MODE_CLASS (mode), 0).require ();\n+      return mode;\n+    }\n+  else\n+    {\n+      if (GET_MODE_BITSIZE (mode) < BITS_PER_WORD)\n+\treturn mode_for_size (BITS_PER_WORD,\n+\t\t\t      GET_MODE_CLASS (mode), 0).require ();\n+      return mode;\n+    }\n+}\n+\n /* Emit code to conditionally move either OPERANDS[2] or OPERANDS[3] into\n    OPERANDS[0] in MODE.  OPERANDS[1] is the operator of the condition.  */\n "}, {"sha": "51bc3183ed5e36a341d06a77aa834942a38fed24", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -1055,18 +1055,6 @@ extern char leaf_reg_remap[];\n        || GET_MODE_SIZE (MODE) > 8 \\\n        || GET_MODE_SIZE (MODE) < 4))\n \n-/* Get_secondary_mem widens its argument to BITS_PER_WORD which loses on v9\n-   because the movsi and movsf patterns don't handle r/f moves.\n-   For v8 we copy the default definition.  */\n-#define SECONDARY_MEMORY_NEEDED_MODE(MODE)\t\t\t\t   \\\n-  (TARGET_ARCH64\t\t\t\t\t\t\t   \\\n-   ? (GET_MODE_BITSIZE (MODE) < 32\t\t\t\t\t   \\\n-      ? mode_for_size (32, GET_MODE_CLASS (MODE), 0).require ()\t\t   \\\n-      : MODE)\t\t\t\t\t\t\t\t   \\\n-   : (GET_MODE_BITSIZE (MODE) < BITS_PER_WORD\t\t\t\t   \\\n-      ? mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (MODE), 0).require () \\\n-      : MODE))\n-\n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.  */\n /* On SPARC, this is the size of MODE in words.  */"}, {"sha": "5e90208f5eba42900791078bf3c89be3d0903462", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -2747,29 +2747,27 @@ Do not define this macro if you do not define\n @code{SECONDARY_MEMORY_NEEDED}.\n @end defmac\n \n-@defmac SECONDARY_MEMORY_NEEDED_MODE (@var{mode})\n-When the compiler needs a secondary memory location to copy between two\n-registers of mode @var{mode}, it normally allocates sufficient memory to\n-hold a quantity of @code{BITS_PER_WORD} bits and performs the store and\n-load operations in a mode that many bits wide and whose class is the\n-same as that of @var{mode}.\n-\n-This is right thing to do on most machines because it ensures that all\n-bits of the register are copied and prevents accesses to the registers\n-in a narrower mode, which some machines prohibit for floating-point\n-registers.\n+@deftypefn {Target Hook} machine_mode TARGET_SECONDARY_MEMORY_NEEDED_MODE (machine_mode @var{mode})\n+If @code{SECONDARY_MEMORY_NEEDED} tells the compiler to use memory\n+when moving between two particular registers of mode @var{mode},\n+this hook specifies the mode that the memory should have.\n+\n+The default depends on @code{TARGET_LRA_P}.  Without LRA, the default\n+is to use a word-sized mode for integral modes that are smaller than a\n+a word.  This is right thing to do on most machines because it ensures\n+that all bits of the register are copied and prevents accesses to the\n+registers in a narrower mode, which some machines prohibit for\n+floating-point registers.\n \n However, this default behavior is not correct on some machines, such as\n the DEC Alpha, that store short integers in floating-point registers\n differently than in integer registers.  On those machines, the default\n-widening will not work correctly and you must define this macro to\n-suppress that widening in some cases.  See the file @file{alpha.h} for\n+widening will not work correctly and you must define this hook to\n+suppress that widening in some cases.  See the file @file{alpha.c} for\n details.\n \n-Do not define this macro if you do not define\n-@code{SECONDARY_MEMORY_NEEDED} or if widening @var{mode} to a mode that\n-is @code{BITS_PER_WORD} bits wide is correct for your machine.\n-@end defmac\n+With LRA, the default is to use @var{mode} unmodified.\n+@end deftypefn\n \n @deftypefn {Target Hook} bool TARGET_CLASS_LIKELY_SPILLED_P (reg_class_t @var{rclass})\n A target hook which returns @code{true} if pseudos that have been assigned"}, {"sha": "1919176d866a3401347f875582701774df9026fc", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -2324,29 +2324,7 @@ Do not define this macro if you do not define\n @code{SECONDARY_MEMORY_NEEDED}.\n @end defmac\n \n-@defmac SECONDARY_MEMORY_NEEDED_MODE (@var{mode})\n-When the compiler needs a secondary memory location to copy between two\n-registers of mode @var{mode}, it normally allocates sufficient memory to\n-hold a quantity of @code{BITS_PER_WORD} bits and performs the store and\n-load operations in a mode that many bits wide and whose class is the\n-same as that of @var{mode}.\n-\n-This is right thing to do on most machines because it ensures that all\n-bits of the register are copied and prevents accesses to the registers\n-in a narrower mode, which some machines prohibit for floating-point\n-registers.\n-\n-However, this default behavior is not correct on some machines, such as\n-the DEC Alpha, that store short integers in floating-point registers\n-differently than in integer registers.  On those machines, the default\n-widening will not work correctly and you must define this macro to\n-suppress that widening in some cases.  See the file @file{alpha.h} for\n-details.\n-\n-Do not define this macro if you do not define\n-@code{SECONDARY_MEMORY_NEEDED} or if widening @var{mode} to a mode that\n-is @code{BITS_PER_WORD} bits wide is correct for your machine.\n-@end defmac\n+@hook TARGET_SECONDARY_MEMORY_NEEDED_MODE\n \n @hook TARGET_CLASS_LIKELY_SPILLED_P\n "}, {"sha": "84be6c3fdcafd9bd5a17b5b8cd74c01d40f66f8b", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -1203,11 +1203,9 @@ check_and_process_move (bool *change_p, bool *sec_mem_p ATTRIBUTE_UNUSED)\n     return false;\n #ifdef SECONDARY_MEMORY_NEEDED\n   if (SECONDARY_MEMORY_NEEDED (sclass, dclass, GET_MODE (src))\n-#ifdef SECONDARY_MEMORY_NEEDED_MODE\n       && ((sclass != NO_REGS && dclass != NO_REGS)\n-\t  || GET_MODE (src) != SECONDARY_MEMORY_NEEDED_MODE (GET_MODE (src)))\n-#endif\n-      )\n+\t  || (GET_MODE (src)\n+\t      != targetm.secondary_memory_needed_mode (GET_MODE (src)))))\n     {\n       *sec_mem_p = true;\n       return false;\n@@ -3940,11 +3938,7 @@ curr_insn_transform (bool check_only_p)\n \t\t  && curr_static_id->operand[in].type == OP_IN);\n       rld = partial_subreg_p (GET_MODE (src), GET_MODE (dest)) ? src : dest;\n       rld_mode = GET_MODE (rld);\n-#ifdef SECONDARY_MEMORY_NEEDED_MODE\n-      sec_mode = SECONDARY_MEMORY_NEEDED_MODE (rld_mode);\n-#else\n-      sec_mode = rld_mode;\n-#endif\n+      sec_mode = targetm.secondary_memory_needed_mode (rld_mode);\n       new_reg = lra_create_new_reg (sec_mode, NULL_RTX,\n \t\t\t\t    NO_REGS, \"secondary\");\n       /* If the mode is changed, it should be wider.  */"}, {"sha": "d0061e5b27087a2c49dc697c4599091727f9a46c", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -574,13 +574,7 @@ get_secondary_mem (rtx x ATTRIBUTE_UNUSED, machine_mode mode,\n      locations do not support short load and stores from all registers\n      (e.g., FP registers).  */\n \n-#ifdef SECONDARY_MEMORY_NEEDED_MODE\n-  mode = SECONDARY_MEMORY_NEEDED_MODE (mode);\n-#else\n-  if (GET_MODE_BITSIZE (mode) < BITS_PER_WORD && INTEGRAL_MODE_P (mode))\n-    mode = mode_for_size (BITS_PER_WORD,\n-\t\t\t  GET_MODE_CLASS (mode), 0).require ();\n-#endif\n+  mode = targetm.secondary_memory_needed_mode (mode);\n \n   /* If we already have made a MEM for this operand in MODE, return it.  */\n   if (secondary_memlocs_elim[(int) mode][opnum] != 0)"}, {"sha": "7543339978e1f4872c1f6770da885b312cc23f3f", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -913,7 +913,7 @@ extern void fancy_abort (const char *, int, const char *)\n \tSTORE_BY_PIECES_P TARGET_FLT_EVAL_METHOD\t\t\t\\\n \tHARD_REGNO_CALL_PART_CLOBBERED HARD_REGNO_MODE_OK\t\t\\\n \tMODES_TIEABLE_P FUNCTION_ARG_PADDING SLOW_UNALIGNED_ACCESS\t\\\n-\tHARD_REGNO_NREGS\n+\tHARD_REGNO_NREGS SECONDARY_MEMORY_NEEDED_MODE\n \n /* Target macros only used for code built for the target, that have\n    moved to libgcc-tm.h or have never been present elsewhere.  */"}, {"sha": "7abb74e79c0352c885da3d1aefe2eb416d28097d", "filename": "gcc/target.def", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -5265,6 +5265,30 @@ forwarding logic, you can set @code{sri->extra_cost} to a negative amount.\",\n   secondary_reload_info *sri),\n  default_secondary_reload)\n \n+DEFHOOK\n+(secondary_memory_needed_mode,\n+ \"If @code{SECONDARY_MEMORY_NEEDED} tells the compiler to use memory\\n\\\n+when moving between two particular registers of mode @var{mode},\\n\\\n+this hook specifies the mode that the memory should have.\\n\\\n+\\n\\\n+The default depends on @code{TARGET_LRA_P}.  Without LRA, the default\\n\\\n+is to use a word-sized mode for integral modes that are smaller than a\\n\\\n+a word.  This is right thing to do on most machines because it ensures\\n\\\n+that all bits of the register are copied and prevents accesses to the\\n\\\n+registers in a narrower mode, which some machines prohibit for\\n\\\n+floating-point registers.\\n\\\n+\\n\\\n+However, this default behavior is not correct on some machines, such as\\n\\\n+the DEC Alpha, that store short integers in floating-point registers\\n\\\n+differently than in integer registers.  On those machines, the default\\n\\\n+widening will not work correctly and you must define this hook to\\n\\\n+suppress that widening in some cases.  See the file @file{alpha.c} for\\n\\\n+details.\\n\\\n+\\n\\\n+With LRA, the default is to use @var{mode} unmodified.\",\n+ machine_mode, (machine_mode mode),\n+ default_secondary_memory_needed_mode)\n+\n /* Given an rtx X being reloaded into a reg required to be in class CLASS,\n    return the class of reg to actually use.  */\n DEFHOOK"}, {"sha": "98e553c0fce799fe531dbf6bdec43e5123f47eef", "filename": "gcc/targhooks.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -1129,6 +1129,18 @@ default_secondary_reload (bool in_p ATTRIBUTE_UNUSED, rtx x ATTRIBUTE_UNUSED,\n   return rclass;\n }\n \n+/* The default implementation of TARGET_SECONDARY_MEMORY_NEEDED_MODE.  */\n+\n+machine_mode\n+default_secondary_memory_needed_mode (machine_mode mode)\n+{\n+  if (!targetm.lra_p ()\n+      && GET_MODE_BITSIZE (mode) < BITS_PER_WORD\n+      && INTEGRAL_MODE_P (mode))\n+    return mode_for_size (BITS_PER_WORD, GET_MODE_CLASS (mode), 0).require ();\n+  return mode;\n+}\n+\n /* By default, if flag_pic is true, then neither local nor global relocs\n    should be placed in readonly memory.  */\n "}, {"sha": "3d03215f7b7f226df619827e9f811c18beba9237", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94e23f53d700769c453d31881c089d06cde823dd/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=94e23f53d700769c453d31881c089d06cde823dd", "patch": "@@ -159,6 +159,7 @@ extern bool default_different_addr_displacement_p (void);\n extern reg_class_t default_secondary_reload (bool, rtx, reg_class_t,\n \t\t\t\t\t     machine_mode,\n \t\t\t\t\t     secondary_reload_info *);\n+extern machine_mode default_secondary_memory_needed_mode (machine_mode);\n extern void default_target_option_override (void);\n extern void hook_void_bitmap (bitmap);\n extern int default_reloc_rw_mask (void);"}]}