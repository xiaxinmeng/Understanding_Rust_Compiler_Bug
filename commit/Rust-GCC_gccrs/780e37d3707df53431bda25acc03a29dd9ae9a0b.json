{"sha": "780e37d3707df53431bda25acc03a29dd9ae9a0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzgwZTM3ZDM3MDdkZjUzNDMxYmRhMjVhY2MwM2EyOWRkOWFlOWEwYg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2005-12-19T19:13:21Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2005-12-19T19:13:21Z"}, "message": "tree-flow.h (struct var_ann_d): Change type of may_aliases field to VEC(tree, gc) *.\n\n\t* tree-flow.h (struct var_ann_d): Change type of\n\tmay_aliases field to VEC(tree, gc) *.\n\t(may_aliases): Declaration changed.\n\t* tree-ssa-alias.c (group_aliases, add_may_alias,\n\treplace_may_alias, dump_may_aliases_for,\n\tis_aliased_with, add_type_alias, new_type_alias):\n\tWork with VEC(tree, gc) * instead of varray.\n\t* tree-flow-inline.h (may_aliases): Ditto.\n\t* tree-ssa.c (verify_flow_insensitive_alias_info,\n\tverify_name_tags): Ditto.\n\t* tree-ssa-operands.c (add_stmt_operand): Ditto.\n\nFrom-SVN: r108804", "tree": {"sha": "0c8732c81e7c0d6f68cff04366bf2a4b0314e4d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c8732c81e7c0d6f68cff04366bf2a4b0314e4d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/780e37d3707df53431bda25acc03a29dd9ae9a0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780e37d3707df53431bda25acc03a29dd9ae9a0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/780e37d3707df53431bda25acc03a29dd9ae9a0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/780e37d3707df53431bda25acc03a29dd9ae9a0b/comments", "author": null, "committer": null, "parents": [{"sha": "b214e1e755e5cf41850818e8b214f5985c3209b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b214e1e755e5cf41850818e8b214f5985c3209b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b214e1e755e5cf41850818e8b214f5985c3209b4"}], "stats": {"total": 120, "additions": 68, "deletions": 52}, "files": [{"sha": "9780498fc423a3b8c4a191f4b90f61b56386cf5a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=780e37d3707df53431bda25acc03a29dd9ae9a0b", "patch": "@@ -1,3 +1,17 @@\n+2005-12-19  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-flow.h (struct var_ann_d): Change type of\n+\tmay_aliases field to VEC(tree, gc) *.\n+\t(may_aliases): Declaration changed.\n+\t* tree-ssa-alias.c (group_aliases, add_may_alias,\n+\treplace_may_alias, dump_may_aliases_for,\n+\tis_aliased_with, add_type_alias, new_type_alias):\n+\tWork with VEC(tree, gc) * instead of varray.\n+\t* tree-flow-inline.h (may_aliases): Ditto.\n+\t* tree-ssa.c (verify_flow_insensitive_alias_info,\n+\tverify_name_tags): Ditto.\n+\t* tree-ssa-operands.c (add_stmt_operand): Ditto.\n+\n 2005-12-19  J\"orn Rennecke <joern.rennecke@st.com>\n \n \t* cfgcleanup.c: Temporarily revert patches for PR 20070 till Bernd"}, {"sha": "057b2496c1a546d131567c47fb1b652e8e970d95", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=780e37d3707df53431bda25acc03a29dd9ae9a0b", "patch": "@@ -182,7 +182,7 @@ bb_for_stmt (tree t)\n \n /* Return the may_aliases varray for variable VAR, or NULL if it has\n    no may aliases.  */\n-static inline varray_type\n+static inline VEC(tree, gc) *\n may_aliases (tree var)\n {\n   var_ann_t ann = var_ann (var);"}, {"sha": "e59e809ea5eaa120bef056026633d41451fbb4b3", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=780e37d3707df53431bda25acc03a29dd9ae9a0b", "patch": "@@ -196,7 +196,7 @@ struct var_ann_d GTY(())\n   tree type_mem_tag;\n \n   /* Variables that may alias this variable.  */\n-  varray_type may_aliases;\n+  VEC(tree, gc) *may_aliases;\n \n   /* Used when going out of SSA form to indicate which partition this\n      variable represents storage for.  */\n@@ -309,7 +309,7 @@ extern void set_bb_for_stmt (tree, basic_block);\n static inline bool noreturn_call_p (tree);\n static inline void update_stmt (tree);\n static inline bool stmt_modified_p (tree);\n-static inline varray_type may_aliases (tree);\n+static inline VEC(tree, gc) *may_aliases (tree);\n static inline int get_lineno (tree);\n static inline const char *get_filename (tree);\n static inline bool is_exec_stmt (tree);"}, {"sha": "d7f12c35cea82359a6620c4ee9d93e4f84f5b1c8", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 35, "deletions": 32, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=780e37d3707df53431bda25acc03a29dd9ae9a0b", "patch": "@@ -1108,15 +1108,15 @@ group_aliases (struct alias_info *ai)\n       size_t j;\n       tree ptr = VARRAY_TREE (ai->processed_ptrs, i);\n       tree name_tag = SSA_NAME_PTR_INFO (ptr)->name_mem_tag;\n-      varray_type aliases;\n+      VEC(tree,gc) *aliases;\n+      tree alias;\n       \n       if (name_tag == NULL_TREE)\n \tcontinue;\n \n       aliases = var_ann (name_tag)->may_aliases;\n-      for (j = 0; aliases && j < VARRAY_ACTIVE_SIZE (aliases); j++)\n+      for (j = 0; VEC_iterate (tree, aliases, j, alias); j++)\n \t{\n-\t  tree alias = VARRAY_TREE (aliases, j);\n \t  var_ann_t ann = var_ann (alias);\n \n \t  if ((!MTAG_P (alias)\n@@ -1125,9 +1125,9 @@ group_aliases (struct alias_info *ai)\n \t    {\n \t      tree new_alias;\n \n-\t      gcc_assert (VARRAY_ACTIVE_SIZE (ann->may_aliases) == 1);\n+\t      gcc_assert (VEC_length (tree, ann->may_aliases) == 1);\n \n-\t      new_alias = VARRAY_TREE (ann->may_aliases, 0);\n+\t      new_alias = VEC_index (tree, ann->may_aliases, 0);\n \t      replace_may_alias (name_tag, j, new_alias);\n \t    }\n \t}\n@@ -1578,6 +1578,7 @@ add_may_alias (tree var, tree alias)\n   size_t i;\n   var_ann_t v_ann = get_var_ann (var);\n   var_ann_t a_ann = get_var_ann (alias);\n+  tree al;\n \n   /* Don't allow self-referential aliases.  */\n   gcc_assert (var != alias);\n@@ -1590,11 +1591,11 @@ add_may_alias (tree var, tree alias)\n #endif\n \n   if (v_ann->may_aliases == NULL)\n-    VARRAY_TREE_INIT (v_ann->may_aliases, 2, \"aliases\");\n+    v_ann->may_aliases = VEC_alloc (tree, gc, 2);\n \n   /* Avoid adding duplicates.  */\n-  for (i = 0; i < VARRAY_ACTIVE_SIZE (v_ann->may_aliases); i++)\n-    if (alias == VARRAY_TREE (v_ann->may_aliases, i))\n+  for (i = 0; VEC_iterate (tree, v_ann->may_aliases, i, al); i++)\n+    if (alias == al)\n       return;\n \n   /* If VAR is a call-clobbered variable, so is its new ALIAS.\n@@ -1607,7 +1608,7 @@ add_may_alias (tree var, tree alias)\n   else if (is_call_clobbered (alias))\n     mark_call_clobbered (var);\n \n-  VARRAY_PUSH_TREE (v_ann->may_aliases, alias);\n+  VEC_safe_push (tree, gc, v_ann->may_aliases, alias);\n   a_ann->is_alias_tag = 1;\n }\n \n@@ -1618,7 +1619,7 @@ static void\n replace_may_alias (tree var, size_t i, tree new_alias)\n {\n   var_ann_t v_ann = var_ann (var);\n-  VARRAY_TREE (v_ann->may_aliases, i) = new_alias;\n+  VEC_replace (tree, v_ann->may_aliases, i, new_alias);\n \n   /* If VAR is a call-clobbered variable, so is NEW_ALIAS.\n      FIXME, call-clobbering should only depend on whether an address\n@@ -2152,7 +2153,7 @@ debug_points_to_info (void)\n void\n dump_may_aliases_for (FILE *file, tree var)\n {\n-  varray_type aliases;\n+  VEC(tree, gc) *aliases;\n   \n   if (TREE_CODE (var) == SSA_NAME)\n     var = SSA_NAME_VAR (var);\n@@ -2161,10 +2162,11 @@ dump_may_aliases_for (FILE *file, tree var)\n   if (aliases)\n     {\n       size_t i;\n+      tree al;\n       fprintf (file, \"{ \");\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n+      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n \t{\n-\t  print_generic_expr (file, VARRAY_TREE (aliases, i), dump_flags);\n+\t  print_generic_expr (file, al, dump_flags);\n \t  fprintf (file, \" \");\n \t}\n       fprintf (file, \"}\");\n@@ -2223,7 +2225,8 @@ bool\n is_aliased_with (tree tag, tree sym)\n {\n   size_t i;\n-  varray_type aliases;\n+  VEC(tree,gc) *aliases;\n+  tree al;\n \n   if (var_ann (sym)->is_alias_tag)\n     {\n@@ -2232,8 +2235,8 @@ is_aliased_with (tree tag, tree sym)\n       if (aliases == NULL)\n \treturn false;\n \n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\tif (VARRAY_TREE (aliases, i) == sym)\n+      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+\tif (al == sym)\n \t  return true;\n     }\n   else\n@@ -2243,8 +2246,8 @@ is_aliased_with (tree tag, tree sym)\n       if (aliases == NULL)\n \treturn false;\n \n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\tif (VARRAY_TREE (aliases, i) == tag)\n+      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+\tif (al == tag)\n \t  return true;\n     }\n \n@@ -2258,11 +2261,12 @@ is_aliased_with (tree tag, tree sym)\n void\n add_type_alias (tree ptr, tree var)\n {\n-  varray_type aliases;\n-  tree tag;\n+  VEC(tree, gc) *aliases;\n+  tree tag, al;\n   var_ann_t ann = var_ann (ptr);\n   subvar_t svars;\n   VEC (tree, heap) *varvec = NULL;  \n+  unsigned i;\n \n   if (ann->type_mem_tag == NULL_TREE)\n     {\n@@ -2322,19 +2326,17 @@ add_type_alias (tree ptr, tree var)\n   mark_sym_for_renaming (tag);\n   if ((aliases = var_ann (tag)->may_aliases) != NULL)\n     {\n-      size_t i;\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\tmark_sym_for_renaming (VARRAY_TREE (aliases, i));\n+      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+\tmark_sym_for_renaming (al);\n     }\n \n   /* If we had grouped aliases, VAR may have aliases of its own.  Mark\n      them for renaming as well.  Other statements referencing the\n      aliases of VAR will need to be updated.  */\n   if ((aliases = var_ann (var)->may_aliases) != NULL)\n     {\n-      size_t i;\n-      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\tmark_sym_for_renaming (VARRAY_TREE (aliases, i));\n+      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+\tmark_sym_for_renaming (al);\n     }\n   VEC_free (tree, heap, varvec);\n }\n@@ -2377,12 +2379,12 @@ new_type_alias (tree ptr, tree var)\n \t same defs/uses/vdefs/vuses will be found after replacing a reference\n \t to var (or ARRAY_REF to var) with an INDIRECT_REF to ptr whose value\n \t is the address of var.  */\n-      varray_type aliases = v_ann->may_aliases;\n+      VEC(tree, gc) *aliases = v_ann->may_aliases;\n \n       if ((aliases != NULL)\n-\t  && (VARRAY_ACTIVE_SIZE (aliases) == 1))\n+\t  && (VEC_length (tree, aliases) == 1))\n \t{\n-\t  tree ali = VARRAY_TREE (aliases, 0);\n+\t  tree ali = VEC_index (tree, aliases, 0);\n \n \t  if (TREE_CODE (ali) == TYPE_MEMORY_TAG)\n \t    {\n@@ -2398,10 +2400,11 @@ new_type_alias (tree ptr, tree var)\n \tadd_may_alias (tag, var);\n       else\n \t{\n-\t  size_t i;\n+\t  unsigned i;\n+\t  tree al;\n \n-\t  for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\t    add_may_alias (tag, VARRAY_TREE (aliases, i));\n+\t  for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+\t    add_may_alias (tag, al);\n \t}\n     }    \n }"}, {"sha": "236db303ffcc2cca79e8974f2d9153521847c218", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=780e37d3707df53431bda25acc03a29dd9ae9a0b", "patch": "@@ -1601,7 +1601,7 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n     }\n   else\n     {\n-      varray_type aliases;\n+      VEC(tree,gc) *aliases;\n \n       /* The variable is not a GIMPLE register.  Add it (or its aliases) to\n \t virtual operands, unless the caller has specifically requested\n@@ -1639,11 +1639,12 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n \t}\n       else\n \t{\n-\t  size_t i;\n+\t  unsigned i;\n+\t  tree al;\n \n \t  /* The variable is aliased.  Add its aliases to the virtual\n \t     operands.  */\n-\t  gcc_assert (VARRAY_ACTIVE_SIZE (aliases) != 0);\n+\t  gcc_assert (VEC_length (tree, aliases) != 0);\n \n \t  if (flags & opf_is_def)\n \t    {\n@@ -1654,8 +1655,8 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n \t      if (v_ann->is_alias_tag)\n \t\tappend_v_may_def (var);\n \n-\t      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\t\tappend_v_may_def (VARRAY_TREE (aliases, i));\n+\t      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+\t\tappend_v_may_def (al);\n \t    }\n \t  else\n \t    {\n@@ -1664,8 +1665,8 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n \t      if (v_ann->is_alias_tag)\n \t\tappend_vuse (var);\n \n-\t      for (i = 0; i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\t\tappend_vuse (VARRAY_TREE (aliases, i));\n+\t      for (i = 0; VEC_iterate (tree, aliases, i, al); i++)\n+\t\tappend_vuse (al);\n \t    }\n \t}\n     }"}, {"sha": "f6924b3e634332a6147f136aab36107752e00d86", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/780e37d3707df53431bda25acc03a29dd9ae9a0b/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=780e37d3707df53431bda25acc03a29dd9ae9a0b", "patch": "@@ -381,15 +381,14 @@ verify_flow_insensitive_alias_info (void)\n     {\n       size_t j;\n       var_ann_t ann;\n-      varray_type may_aliases;\n+      VEC(tree,gc) *may_aliases;\n+      tree alias;\n \n       ann = var_ann (var);\n       may_aliases = ann->may_aliases;\n \n-      for (j = 0; may_aliases && j < VARRAY_ACTIVE_SIZE (may_aliases); j++)\n+      for (j = 0; VEC_iterate (tree, may_aliases, j, alias); j++)\n \t{\n-\t  tree alias = VARRAY_TREE (may_aliases, j);\n-\n \t  bitmap_set_bit (visited, DECL_UID (alias));\n \n \t  if (!may_be_aliased (alias))\n@@ -545,13 +544,12 @@ verify_name_tags (void)\n       if (tmt)\n \t{\n \t  size_t i;\n-\t  varray_type aliases = var_ann (tmt)->may_aliases;\n+\t  VEC(tree,gc) *aliases = var_ann (tmt)->may_aliases;\n+\t  tree alias;\n+\n \t  bitmap_clear (type_aliases);\n-\t  for (i = 0; aliases && i < VARRAY_ACTIVE_SIZE (aliases); i++)\n-\t    {\n-\t      tree alias = VARRAY_TREE (aliases, i);\n-\t      bitmap_set_bit (type_aliases, DECL_UID (alias));\n-\t    }\n+\t  for (i = 0; VEC_iterate (tree, aliases, i, alias); i++)\n+\t    bitmap_set_bit (type_aliases, DECL_UID (alias));\n \n \t  /* When grouping, we may have added PTR's type tag into the\n \t     alias set of PTR's name tag.  To prevent a false"}]}