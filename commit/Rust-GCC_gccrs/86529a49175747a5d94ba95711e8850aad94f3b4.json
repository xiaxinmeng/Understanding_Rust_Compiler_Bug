{"sha": "86529a49175747a5d94ba95711e8850aad94f3b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY1MjlhNDkxNzU3NDdhNWQ5NGJhOTU3MTFlODg1MGFhZDk0ZjNiNA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-05-05T12:26:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-05-05T12:26:05Z"}, "message": "expmed.c (expand_variable_shift): Rename to ...\n\n2011-05-05  Richard Guenther  <rguenther@suse.de>\n\n\t* expmed.c (expand_variable_shift): Rename to ...\n\t(expand_shift_1): ... this.  Take an expanded shift amount.\n\tFor rotates recurse directly not building trees for the shift amount.\n\t(expand_variable_shift): Wrap around expand_shift_1.\n\t(expand_shift): Adjust.\n\nFrom-SVN: r173428", "tree": {"sha": "6b5bb7c4ab2054ee711a211d7aa6d4c9fccd5e05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6b5bb7c4ab2054ee711a211d7aa6d4c9fccd5e05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86529a49175747a5d94ba95711e8850aad94f3b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86529a49175747a5d94ba95711e8850aad94f3b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86529a49175747a5d94ba95711e8850aad94f3b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86529a49175747a5d94ba95711e8850aad94f3b4/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "82357998ddcc01654e9c542de84af98ec23d1bf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82357998ddcc01654e9c542de84af98ec23d1bf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82357998ddcc01654e9c542de84af98ec23d1bf5"}], "stats": {"total": 66, "additions": 42, "deletions": 24}, "files": [{"sha": "bcf5f1c8dcfa78a5d0142c0f6f033776129517a9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86529a49175747a5d94ba95711e8850aad94f3b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86529a49175747a5d94ba95711e8850aad94f3b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86529a49175747a5d94ba95711e8850aad94f3b4", "patch": "@@ -1,3 +1,11 @@\n+2011-05-05  Richard Guenther  <rguenther@suse.de>\n+\n+\t* expmed.c (expand_variable_shift): Rename to ...\n+\t(expand_shift_1): ... this.  Take an expanded shift amount.\n+\tFor rotates recurse directly not building trees for the shift amount.\n+\t(expand_variable_shift): Wrap around expand_shift_1.\n+\t(expand_shift): Adjust.\n+\n 2011-05-05  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gimplify.c (create_tmp_var_raw): Don't call build_type_variant."}, {"sha": "4e1ea3a2b0a07978068d450f62c5061495b8bfc4", "filename": "gcc/expmed.c", "status": "modified", "additions": 34, "deletions": 24, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86529a49175747a5d94ba95711e8850aad94f3b4/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86529a49175747a5d94ba95711e8850aad94f3b4/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=86529a49175747a5d94ba95711e8850aad94f3b4", "patch": "@@ -2032,14 +2032,14 @@ expand_dec (rtx target, rtx dec)\n \f\n /* Output a shift instruction for expression code CODE,\n    with SHIFTED being the rtx for the value to shift,\n-   and AMOUNT the tree for the amount to shift by.\n+   and AMOUNT the rtx for the amount to shift by.\n    Store the result in the rtx TARGET, if that is convenient.\n    If UNSIGNEDP is nonzero, do a logical shift; otherwise, arithmetic.\n    Return the rtx for where the value is.  */\n \n-rtx\n-expand_variable_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n-\t\t       tree amount, rtx target, int unsignedp)\n+static rtx\n+expand_shift_1 (enum tree_code code, enum machine_mode mode, rtx shifted,\n+\t\trtx amount, rtx target, int unsignedp)\n {\n   rtx op1, temp = 0;\n   int left = (code == LSHIFT_EXPR || code == LROTATE_EXPR);\n@@ -2053,7 +2053,7 @@ expand_variable_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n   int attempt;\n   bool speed = optimize_insn_for_speed_p ();\n \n-  op1 = expand_normal (amount);\n+  op1 = amount;\n   op1_mode = GET_MODE (op1);\n \n   /* Determine whether the shift/rotate amount is a vector, or scalar.  If the\n@@ -2138,25 +2138,22 @@ expand_variable_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n \t\t code below.  */\n \n \t      rtx subtarget = target == shifted ? 0 : target;\n-\t      tree new_amount, other_amount;\n+\t      rtx new_amount, other_amount;\n \t      rtx temp1;\n-\t      tree type = TREE_TYPE (amount);\n-\t      if (GET_MODE (op1) != TYPE_MODE (type)\n-\t\t  && GET_MODE (op1) != VOIDmode)\n-\t\top1 = convert_to_mode (TYPE_MODE (type), op1, 1);\n-\t      new_amount = make_tree (type, op1);\n+\n+\t      new_amount = op1;\n \t      other_amount\n-\t\t= fold_build2 (MINUS_EXPR, type,\n-\t\t\t       build_int_cst (type, GET_MODE_BITSIZE (mode)),\n-\t\t\t       new_amount);\n+\t\t= simplify_gen_binary (MINUS, GET_MODE (op1),\n+\t\t\t\t       GEN_INT (GET_MODE_BITSIZE (mode)),\n+\t\t\t\t       op1);\n \n \t      shifted = force_reg (mode, shifted);\n \n-\t      temp = expand_variable_shift (left ? LSHIFT_EXPR : RSHIFT_EXPR,\n-\t\t\t\t\t    mode, shifted, new_amount, 0, 1);\n-\t      temp1 = expand_variable_shift (left ? RSHIFT_EXPR : LSHIFT_EXPR,\n-\t\t\t\t\t     mode, shifted, other_amount,\n-\t\t\t\t\t     subtarget, 1);\n+\t      temp = expand_shift_1 (left ? LSHIFT_EXPR : RSHIFT_EXPR,\n+\t\t\t\t     mode, shifted, new_amount, 0, 1);\n+\t      temp1 = expand_shift_1 (left ? RSHIFT_EXPR : LSHIFT_EXPR,\n+\t\t\t\t      mode, shifted, other_amount,\n+\t\t\t\t      subtarget, 1);\n \t      return expand_binop (mode, ior_optab, temp, temp1, target,\n \t\t\t\t   unsignedp, methods);\n \t    }\n@@ -2211,12 +2208,25 @@ rtx\n expand_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n \t      int amount, rtx target, int unsignedp)\n {\n-  /* ???  With re-writing expand_shift we could avoid going through a\n-     tree for the shift amount and directly do GEN_INT (amount).  */\n-  return expand_variable_shift (code, mode, shifted,\n-\t\t\t\tbuild_int_cst (integer_type_node, amount),\n-\t\t\t\ttarget, unsignedp);\n+  return expand_shift_1 (code, mode,\n+\t\t\t shifted, GEN_INT (amount), target, unsignedp);\n+}\n+\n+/* Output a shift instruction for expression code CODE,\n+   with SHIFTED being the rtx for the value to shift,\n+   and AMOUNT the tree for the amount to shift by.\n+   Store the result in the rtx TARGET, if that is convenient.\n+   If UNSIGNEDP is nonzero, do a logical shift; otherwise, arithmetic.\n+   Return the rtx for where the value is.  */\n+\n+rtx\n+expand_variable_shift (enum tree_code code, enum machine_mode mode, rtx shifted,\n+\t\t       tree amount, rtx target, int unsignedp)\n+{\n+  return expand_shift_1 (code, mode,\n+\t\t\t shifted, expand_normal (amount), target, unsignedp);\n }\n+\n \f\n /* Indicates the type of fixup needed after a constant multiplication.\n    BASIC_VARIANT means no fixup is needed, NEGATE_VARIANT means that"}]}