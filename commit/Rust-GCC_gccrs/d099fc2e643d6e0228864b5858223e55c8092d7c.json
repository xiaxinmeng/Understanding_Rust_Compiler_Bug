{"sha": "d099fc2e643d6e0228864b5858223e55c8092d7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDA5OWZjMmU2NDNkNmUwMjI4ODY0YjU4NTgyMjNlNTVjODA5MmQ3Yw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2020-12-15T20:36:54Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-04-29T08:00:50Z"}, "message": "[Ada] Self reference access discriminant\n\ngcc/ada/\n\n\t* sem_ch3.adb (Check_Anonymous_Access_Component): Factor out\n\tcore processing of Check_Anonymous_Access_Components.\n\t(Check_Anonymous_Access_Components): Call\n\tCheck_Anonymous_Access_Component.\n\t(Process_Discriminants): Call Check_Anonymous_Access_Component.\n\t* freeze.adb (Freeze_Record_Type): Code cleanups and add more tree\n\tchecking to handle changes in sem_ch3.adb.\n\t* sem_ch8.adb (Find_Type): Remove special case for access\n\tdiscriminant in task types, these are now supported.", "tree": {"sha": "b7ee8ff6fa25c901d9d41080b53e1e652c11d530", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b7ee8ff6fa25c901d9d41080b53e1e652c11d530"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d099fc2e643d6e0228864b5858223e55c8092d7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d099fc2e643d6e0228864b5858223e55c8092d7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d099fc2e643d6e0228864b5858223e55c8092d7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d099fc2e643d6e0228864b5858223e55c8092d7c/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b55ef4b8d6ff7d8d6f290172cdffbb616816f56a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b55ef4b8d6ff7d8d6f290172cdffbb616816f56a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b55ef4b8d6ff7d8d6f290172cdffbb616816f56a"}], "stats": {"total": 289, "additions": 148, "deletions": 141}, "files": [{"sha": "bf20cbcef44888e352ab4e93461c3c11c8d50b0b", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 6, "deletions": 31, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d099fc2e643d6e0228864b5858223e55c8092d7c/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d099fc2e643d6e0228864b5858223e55c8092d7c/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=d099fc2e643d6e0228864b5858223e55c8092d7c", "patch": "@@ -4002,11 +4002,6 @@ package body Freeze is\n          --  Set True if we find at least one component with no component\n          --  clause (used to warn about useless Pack pragmas).\n \n-         function Check_Allocator (N : Node_Id) return Node_Id;\n-         --  If N is an allocator, possibly wrapped in one or more level of\n-         --  qualified expression(s), return the inner allocator node, else\n-         --  return Empty.\n-\n          procedure Check_Itype (Typ : Entity_Id);\n          --  If the component subtype is an access to a constrained subtype of\n          --  an already frozen type, make the subtype frozen as well. It might\n@@ -4022,25 +4017,6 @@ package body Freeze is\n          --  variants referenceed by the Variant_Part VP are frozen. This is\n          --  a recursive routine to deal with nested variants.\n \n-         ---------------------\n-         -- Check_Allocator --\n-         ---------------------\n-\n-         function Check_Allocator (N : Node_Id) return Node_Id is\n-            Inner : Node_Id;\n-         begin\n-            Inner := N;\n-            loop\n-               if Nkind (Inner) = N_Allocator then\n-                  return Inner;\n-               elsif Nkind (Inner) = N_Qualified_Expression then\n-                  Inner := Expression (Inner);\n-               else\n-                  return Empty;\n-               end if;\n-            end loop;\n-         end Check_Allocator;\n-\n          -----------------\n          -- Check_Itype --\n          -----------------\n@@ -4355,22 +4331,24 @@ package body Freeze is\n \n             elsif Is_Access_Type (Etype (Comp))\n               and then Present (Parent (Comp))\n+              and then\n+                Nkind (Parent (Comp))\n+                  in N_Component_Declaration | N_Discriminant_Specification\n               and then Present (Expression (Parent (Comp)))\n             then\n                declare\n                   Alloc : constant Node_Id :=\n-                            Check_Allocator (Expression (Parent (Comp)));\n+                            Unqualify (Expression (Parent (Comp)));\n \n                begin\n-                  if Present (Alloc) then\n+                  if Nkind (Alloc) = N_Allocator then\n \n                      --  If component is pointer to a class-wide type, freeze\n                      --  the specific type in the expression being allocated.\n                      --  The expression may be a subtype indication, in which\n                      --  case freeze the subtype mark.\n \n-                     if Is_Class_Wide_Type\n-                          (Designated_Type (Etype (Comp)))\n+                     if Is_Class_Wide_Type (Designated_Type (Etype (Comp)))\n                      then\n                         if Is_Entity_Name (Expression (Alloc)) then\n                            Freeze_And_Append\n@@ -4382,17 +4360,14 @@ package body Freeze is\n                             (Entity (Subtype_Mark (Expression (Alloc))),\n                              N, Result);\n                         end if;\n-\n                      elsif Is_Itype (Designated_Type (Etype (Comp))) then\n                         Check_Itype (Etype (Comp));\n-\n                      else\n                         Freeze_And_Append\n                           (Designated_Type (Etype (Comp)), N, Result);\n                      end if;\n                   end if;\n                end;\n-\n             elsif Is_Access_Type (Etype (Comp))\n               and then Is_Itype (Designated_Type (Etype (Comp)))\n             then"}, {"sha": "eb28a694a5c942f30f0c031b9d2d440ad0794857", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 140, "deletions": 97, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d099fc2e643d6e0228864b5858223e55c8092d7c/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d099fc2e643d6e0228864b5858223e55c8092d7c/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d099fc2e643d6e0228864b5858223e55c8092d7c", "patch": "@@ -245,11 +245,12 @@ package body Sem_Ch3 is\n    --  belongs must be a concurrent type or a descendant of a type with\n    --  the reserved word 'limited' in its declaration.\n \n-   procedure Check_Anonymous_Access_Components\n-      (Typ_Decl  : Node_Id;\n-       Typ       : Entity_Id;\n-       Prev      : Entity_Id;\n-       Comp_List : Node_Id);\n+   procedure Check_Anonymous_Access_Component\n+     (Typ_Decl   : Node_Id;\n+      Typ        : Entity_Id;\n+      Prev       : Entity_Id;\n+      Comp_Def   : Node_Id;\n+      Access_Def : Node_Id);\n    --  Ada 2005 AI-382: an access component in a record definition can refer to\n    --  the enclosing record, in which case it denotes the type itself, and not\n    --  the current instance of the type. We create an anonymous access type for\n@@ -259,6 +260,13 @@ package body Sem_Ch3 is\n    --  circularity issues in Gigi. We create an incomplete type for the record\n    --  declaration, which is the designated type of the anonymous access.\n \n+   procedure Check_Anonymous_Access_Components\n+     (Typ_Decl  : Node_Id;\n+      Typ       : Entity_Id;\n+      Prev      : Entity_Id;\n+      Comp_List : Node_Id);\n+   --  Call Check_Anonymous_Access_Component on Comp_List\n+\n    procedure Check_Constraining_Discriminant (New_Disc, Old_Disc : Entity_Id);\n    --  Check that, if a new discriminant is used in a constraint defining the\n    --  parent subtype of a derivation, its subtype is statically compatible\n@@ -11157,21 +11165,20 @@ package body Sem_Ch3 is\n       end if;\n    end Check_Aliased_Component_Types;\n \n-   ---------------------------------------\n-   -- Check_Anonymous_Access_Components --\n-   ---------------------------------------\n+   --------------------------------------\n+   -- Check_Anonymous_Access_Component --\n+   --------------------------------------\n \n-   procedure Check_Anonymous_Access_Components\n-      (Typ_Decl  : Node_Id;\n-       Typ       : Entity_Id;\n-       Prev      : Entity_Id;\n-       Comp_List : Node_Id)\n+   procedure Check_Anonymous_Access_Component\n+     (Typ_Decl   : Node_Id;\n+      Typ        : Entity_Id;\n+      Prev       : Entity_Id;\n+      Comp_Def   : Node_Id;\n+      Access_Def : Node_Id)\n    is\n-      Loc         : constant Source_Ptr := Sloc (Typ_Decl);\n+      Loc         : constant Source_Ptr := Sloc (Comp_Def);\n       Anon_Access : Entity_Id;\n       Acc_Def     : Node_Id;\n-      Comp        : Node_Id;\n-      Comp_Def    : Node_Id;\n       Decl        : Node_Id;\n       Type_Def    : Node_Id;\n \n@@ -11205,13 +11212,18 @@ package body Sem_Ch3 is\n          --  Is_Tagged indicates whether the type is tagged. It is tagged if\n          --  it's \"is new ... with record\" or else \"is tagged record ...\".\n \n+         Typ_Def   : constant Node_Id :=\n+           (if Nkind (Typ_Decl) = N_Full_Type_Declaration\n+            then Type_Definition (Typ_Decl) else Empty);\n          Is_Tagged : constant Boolean :=\n-             (Nkind (Type_Definition (Typ_Decl)) = N_Derived_Type_Definition\n-               and then\n-                 Present (Record_Extension_Part (Type_Definition (Typ_Decl))))\n-           or else\n-             (Nkind (Type_Definition (Typ_Decl)) = N_Record_Definition\n-               and then Tagged_Present (Type_Definition (Typ_Decl)));\n+           Present (Typ_Def)\n+             and then\n+               ((Nkind (Typ_Def) = N_Derived_Type_Definition\n+                  and then\n+                    Present (Record_Extension_Part (Typ_Def)))\n+                or else\n+                  (Nkind (Typ_Def) = N_Record_Definition\n+                    and then Tagged_Present (Typ_Def)));\n \n       begin\n          --  If there is a previous partial view, no need to create a new one\n@@ -11429,88 +11441,104 @@ package body Sem_Ch3 is\n          return False;\n       end Mentions_T;\n \n-   --  Start of processing for Check_Anonymous_Access_Components\n+   --  Start of processing for Check_Anonymous_Access_Component\n \n    begin\n-      if No (Comp_List) then\n-         return;\n-      end if;\n+      if Present (Access_Def) and then Mentions_T (Access_Def) then\n+         Acc_Def := Access_To_Subprogram_Definition (Access_Def);\n \n-      Comp := First (Component_Items (Comp_List));\n-      while Present (Comp) loop\n-         if Nkind (Comp) = N_Component_Declaration\n-           and then Present\n-             (Access_Definition (Component_Definition (Comp)))\n-           and then\n-             Mentions_T (Access_Definition (Component_Definition (Comp)))\n-         then\n-            Comp_Def := Component_Definition (Comp);\n-            Acc_Def :=\n-              Access_To_Subprogram_Definition (Access_Definition (Comp_Def));\n-\n-            Build_Incomplete_Type_Declaration;\n-            Anon_Access := Make_Temporary (Loc, 'S');\n-\n-            --  Create a declaration for the anonymous access type: either\n-            --  an access_to_object or an access_to_subprogram.\n-\n-            if Present (Acc_Def) then\n-               if Nkind (Acc_Def) = N_Access_Function_Definition then\n-                  Type_Def :=\n-                    Make_Access_Function_Definition (Loc,\n-                      Parameter_Specifications =>\n-                        Parameter_Specifications (Acc_Def),\n-                      Result_Definition        => Result_Definition (Acc_Def));\n-               else\n-                  Type_Def :=\n-                    Make_Access_Procedure_Definition (Loc,\n-                      Parameter_Specifications =>\n-                        Parameter_Specifications (Acc_Def));\n-               end if;\n+         Build_Incomplete_Type_Declaration;\n+         Anon_Access := Make_Temporary (Loc, 'S');\n \n+         --  Create a declaration for the anonymous access type: either\n+         --  an access_to_object or an access_to_subprogram.\n+\n+         if Present (Acc_Def) then\n+            if Nkind (Acc_Def) = N_Access_Function_Definition then\n+               Type_Def :=\n+                 Make_Access_Function_Definition (Loc,\n+                   Parameter_Specifications =>\n+                     Parameter_Specifications (Acc_Def),\n+                   Result_Definition        => Result_Definition (Acc_Def));\n             else\n                Type_Def :=\n-                 Make_Access_To_Object_Definition (Loc,\n-                   Subtype_Indication =>\n-                      Relocate_Node\n-                        (Subtype_Mark (Access_Definition (Comp_Def))));\n-\n-               Set_Constant_Present\n-                 (Type_Def, Constant_Present (Access_Definition (Comp_Def)));\n-               Set_All_Present\n-                 (Type_Def, All_Present (Access_Definition (Comp_Def)));\n+                 Make_Access_Procedure_Definition (Loc,\n+                   Parameter_Specifications =>\n+                     Parameter_Specifications (Acc_Def));\n             end if;\n \n-            Set_Null_Exclusion_Present\n-              (Type_Def,\n-               Null_Exclusion_Present (Access_Definition (Comp_Def)));\n+         else\n+            Type_Def :=\n+              Make_Access_To_Object_Definition (Loc,\n+                Subtype_Indication =>\n+                   Relocate_Node (Subtype_Mark (Access_Def)));\n \n-            Decl :=\n-              Make_Full_Type_Declaration (Loc,\n-                Defining_Identifier => Anon_Access,\n-                Type_Definition     => Type_Def);\n+            Set_Constant_Present (Type_Def, Constant_Present (Access_Def));\n+            Set_All_Present (Type_Def, All_Present (Access_Def));\n+         end if;\n \n-            Insert_Before (Typ_Decl, Decl);\n-            Analyze (Decl);\n+         Set_Null_Exclusion_Present\n+           (Type_Def, Null_Exclusion_Present (Access_Def));\n \n-            --  If an access to subprogram, create the extra formals\n+         Decl :=\n+           Make_Full_Type_Declaration (Loc,\n+             Defining_Identifier => Anon_Access,\n+             Type_Definition     => Type_Def);\n \n-            if Present (Acc_Def) then\n-               Create_Extra_Formals (Designated_Type (Anon_Access));\n-            end if;\n+         Insert_Before (Typ_Decl, Decl);\n+         Analyze (Decl);\n+\n+         --  If an access to subprogram, create the extra formals\n \n+         if Present (Acc_Def) then\n+            Create_Extra_Formals (Designated_Type (Anon_Access));\n+         end if;\n+\n+         if Nkind (Comp_Def) = N_Component_Definition then\n             Rewrite (Comp_Def,\n               Make_Component_Definition (Loc,\n-                Subtype_Indication =>\n-               New_Occurrence_Of (Anon_Access, Loc)));\n+                Subtype_Indication => New_Occurrence_Of (Anon_Access, Loc)));\n+         else\n+            pragma Assert (Nkind (Comp_Def) = N_Discriminant_Specification);\n+            Rewrite (Comp_Def,\n+              Make_Discriminant_Specification (Loc,\n+                Defining_Identifier => Defining_Identifier (Comp_Def),\n+                Discriminant_Type   => New_Occurrence_Of (Anon_Access, Loc)));\n+         end if;\n \n-            if Ekind (Designated_Type (Anon_Access)) = E_Subprogram_Type then\n-               Set_Ekind (Anon_Access, E_Anonymous_Access_Subprogram_Type);\n-            else\n-               Set_Ekind (Anon_Access, E_Anonymous_Access_Type);\n-            end if;\n+         if Ekind (Designated_Type (Anon_Access)) = E_Subprogram_Type then\n+            Set_Ekind (Anon_Access, E_Anonymous_Access_Subprogram_Type);\n+         else\n+            Set_Ekind (Anon_Access, E_Anonymous_Access_Type);\n+         end if;\n+\n+         Set_Is_Local_Anonymous_Access (Anon_Access);\n+      end if;\n+   end Check_Anonymous_Access_Component;\n+\n+   ---------------------------------------\n+   -- Check_Anonymous_Access_Components --\n+   ---------------------------------------\n \n-            Set_Is_Local_Anonymous_Access (Anon_Access);\n+   procedure Check_Anonymous_Access_Components\n+     (Typ_Decl  : Node_Id;\n+      Typ       : Entity_Id;\n+      Prev      : Entity_Id;\n+      Comp_List : Node_Id)\n+   is\n+      Comp : Node_Id;\n+   begin\n+      if No (Comp_List) then\n+         return;\n+      end if;\n+\n+      Comp := First (Component_Items (Comp_List));\n+      while Present (Comp) loop\n+         if Nkind (Comp) = N_Component_Declaration then\n+            Check_Anonymous_Access_Component\n+              (Typ_Decl, Typ, Prev,\n+               Component_Definition (Comp),\n+               Access_Definition (Component_Definition (Comp)));\n          end if;\n \n          Next (Comp);\n@@ -20041,19 +20069,34 @@ package body Sem_Ch3 is\n          end if;\n \n          if Nkind (Discriminant_Type (Discr)) = N_Access_Definition then\n-            Discr_Type := Access_Definition (Discr, Discriminant_Type (Discr));\n+            Check_Anonymous_Access_Component\n+              (Typ_Decl   => N,\n+               Typ        => Defining_Identifier (N),\n+               Prev       => Prev,\n+               Comp_Def   => Discr,\n+               Access_Def => Discriminant_Type (Discr));\n+\n+            --  if Check_Anonymous_Access_Component replaced Discr then\n+            --  its Original_Node points to the old Discr and the access type\n+            --  for Discr_Type has already been created.\n+\n+            if Original_Node (Discr) /= Discr then\n+               Discr_Type := Etype (Discriminant_Type (Discr));\n+            else\n+               Discr_Type :=\n+                 Access_Definition (Discr, Discriminant_Type (Discr));\n \n-            --  Ada 2005 (AI-254)\n+               --  Ada 2005 (AI-254)\n \n-            if Present (Access_To_Subprogram_Definition\n-                         (Discriminant_Type (Discr)))\n-              and then Protected_Present (Access_To_Subprogram_Definition\n-                                           (Discriminant_Type (Discr)))\n-            then\n-               Discr_Type :=\n-                 Replace_Anonymous_Access_To_Protected_Subprogram (Discr);\n+               if Present (Access_To_Subprogram_Definition\n+                            (Discriminant_Type (Discr)))\n+                 and then Protected_Present (Access_To_Subprogram_Definition\n+                                              (Discriminant_Type (Discr)))\n+               then\n+                  Discr_Type :=\n+                    Replace_Anonymous_Access_To_Protected_Subprogram (Discr);\n+               end if;\n             end if;\n-\n          else\n             Find_Type (Discriminant_Type (Discr));\n             Discr_Type := Etype (Discriminant_Type (Discr));"}, {"sha": "62ebaa34fc26c00497a63ae3996ea642715a1d25", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 2, "deletions": 13, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d099fc2e643d6e0228864b5858223e55c8092d7c/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d099fc2e643d6e0228864b5858223e55c8092d7c/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=d099fc2e643d6e0228864b5858223e55c8092d7c", "patch": "@@ -8128,25 +8128,14 @@ package body Sem_Ch8 is\n                if Ekind (Base_Type (T_Name)) = E_Task_Type then\n \n                   --  In Ada 2005, a task name can be used in an access\n-                  --  definition within its own body. It cannot be used\n-                  --  in the discriminant part of the task declaration,\n-                  --  nor anywhere else in the declaration because entries\n-                  --  cannot have access parameters.\n+                  --  definition within its own body.\n \n                   if Ada_Version >= Ada_2005\n                     and then Nkind (Parent (N)) = N_Access_Definition\n                   then\n                      Set_Entity (N, T_Name);\n                      Set_Etype  (N, T_Name);\n-\n-                     if Has_Completion (T_Name) then\n-                        return;\n-\n-                     else\n-                        Error_Msg_N\n-                          (\"task type cannot be used as type mark \" &\n-                           \"within its own declaration\", N);\n-                     end if;\n+                     return;\n \n                   else\n                      Error_Msg_N"}]}