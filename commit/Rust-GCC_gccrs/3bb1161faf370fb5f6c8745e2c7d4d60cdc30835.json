{"sha": "3bb1161faf370fb5f6c8745e2c7d4d60cdc30835", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2JiMTE2MWZhZjM3MGZiNWY2Yzg3NDVlMmM3ZDRkNjBjZGMzMDgzNQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-07-19T09:12:32Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-07-19T09:12:32Z"}, "message": "wide-int.h (widest2_int): New.\n\n\t* wide-int.h (widest2_int): New.\n\t* gimple-fold.c (arith_overflowed_p): Use it.\n\t* tree.h (widest2_int_cst): New.\n\t* tree-vrp.c (wide_int_binop_overflow): Rename from\n\tvrp_int_const_binop.\n\tRewrite to work on trees.\n\t(extract_range_from_multiplicative_op_1): Abstract code to...\n\t(wide_int_range_min_max): ...here.\n\t(wide_int_range_cross_product): ...and here.\n\t(extract_range_from_binary_expr_1): Abstract overflow code to...\n\t(wide_int_range_cross_product_wrapping): ...here.\n\t* tree-vrp.h (wide_int_range_cross_product): New.\n\t(wide_int_range_cross_product_wrapping): New.\n\nFrom-SVN: r262874", "tree": {"sha": "207eeddd30feb310bbc8f4339783c1b9a6aefd4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/207eeddd30feb310bbc8f4339783c1b9a6aefd4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30ae6662408271f96a97d28f684022c413b71063", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30ae6662408271f96a97d28f684022c413b71063", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30ae6662408271f96a97d28f684022c413b71063"}], "stats": {"total": 446, "additions": 236, "deletions": 210}, "files": [{"sha": "ecdaf32fd7794414aa91451036a07dcea588e834", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3bb1161faf370fb5f6c8745e2c7d4d60cdc30835", "patch": "@@ -1,3 +1,19 @@\n+2018-07-19  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* wide-int.h (widest2_int): New.\n+\t* gimple-fold.c (arith_overflowed_p): Use it.\n+\t* tree.h (widest2_int_cst): New.\n+\t* tree-vrp.c (wide_int_binop_overflow): Rename from\n+\tvrp_int_const_binop.\n+\tRewrite to work on trees.\n+\t(extract_range_from_multiplicative_op_1): Abstract code to...\n+\t(wide_int_range_min_max): ...here.\n+\t(wide_int_range_cross_product): ...and here.\n+\t(extract_range_from_binary_expr_1): Abstract overflow code to...\n+\t(wide_int_range_mult_wrapping): ...here.\n+\t* tree-vrp.h (wide_int_range_cross_product): New.\n+\t(wide_int_range_mult_wrapping): New.\n+\n 2018-07-19  Andrew Senkevich  <andrew.senkevich@intel.com>\n \t    Julia Koval  <julia.koval@intel.com>\n "}, {"sha": "027ca4da97c78f2550de203aa8b88d2d20ea0299", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=3bb1161faf370fb5f6c8745e2c7d4d60cdc30835", "patch": "@@ -3986,9 +3986,6 @@ bool\n arith_overflowed_p (enum tree_code code, const_tree type,\n \t\t    const_tree arg0, const_tree arg1)\n {\n-  typedef FIXED_WIDE_INT (WIDE_INT_MAX_PRECISION * 2) widest2_int;\n-  typedef generic_wide_int <wi::extended_tree <WIDE_INT_MAX_PRECISION * 2> >\n-    widest2_int_cst;\n   widest2_int warg0 = widest2_int_cst (arg0);\n   widest2_int warg1 = widest2_int_cst (arg1);\n   widest2_int wres;"}, {"sha": "170cccb74f5a404d6b744938a478cc787ee35d66", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 199, "deletions": 207, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=3bb1161faf370fb5f6c8745e2c7d4d60cdc30835", "patch": "@@ -968,64 +968,43 @@ value_range_constant_singleton (value_range *vr)\n    indeterminate.  */\n \n static bool\n-vrp_int_const_binop (enum tree_code code, tree val1, tree val2, wide_int *res)\n+wide_int_binop_overflow (wide_int &res,\n+\t\t\t enum tree_code code,\n+\t\t\t const wide_int &w0, const wide_int &w1,\n+\t\t\t signop sign, bool overflow_undefined)\n {\n-  wi::overflow_type overflow = wi::OVF_NONE;\n-  signop sign = TYPE_SIGN (TREE_TYPE (val1));\n-  wide_int w1 = wi::to_wide (val1);\n-  wide_int w2 = wi::to_wide (val2);\n-\n-  switch (code)\n-    {\n-    case RSHIFT_EXPR:\n-    case LSHIFT_EXPR:\n-      w2 = wi::to_wide (val2, TYPE_PRECISION (TREE_TYPE (val1)));\n-      /* FALLTHRU */\n-    case MULT_EXPR:\n-    case TRUNC_DIV_EXPR:\n-    case EXACT_DIV_EXPR:\n-    case FLOOR_DIV_EXPR:\n-    case CEIL_DIV_EXPR:\n-    case ROUND_DIV_EXPR:\n-      if (!wide_int_binop (*res, code, w1, w2, sign, &overflow))\n-\treturn false;\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n+  wi::overflow_type overflow;\n+  if (!wide_int_binop (res, code, w0, w1, sign, &overflow))\n+    return false;\n \n   /* If the operation overflowed return -INF or +INF depending on the\n      operation and the combination of signs of the operands.  */\n-  if (overflow\n-      && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (val1)))\n-    {\n-      int sign1 = tree_int_cst_sgn (val1);\n-      int sign2 = tree_int_cst_sgn (val2);\n-\n-      /* Notice that we only need to handle the restricted set of\n-\t operations handled by extract_range_from_binary_expr.\n-\t Among them, only multiplication, addition and subtraction\n-\t can yield overflow without overflown operands because we\n-\t are working with integral types only... except in the\n-\t case VAL1 = -INF and VAL2 = -1 which overflows to +INF\n-\t for division too.  */\n-\n-      /* For multiplication, the sign of the overflow is given\n-\t by the comparison of the signs of the operands.  */\n-      if ((code == MULT_EXPR && sign1 == sign2)\n+  if (overflow && overflow_undefined)\n+    {\n+      switch (code)\n+\t{\n+\tcase MULT_EXPR:\n+\t  /* For multiplication, the sign of the overflow is given\n+\t     by the comparison of the signs of the operands.  */\n+\t  if (sign == UNSIGNED || w0.sign_mask () == w1.sign_mask ())\n+\t    res = wi::max_value (w0.get_precision (), sign);\n+\t  else\n+\t    res = wi::min_value (w0.get_precision (), sign);\n+\t  return true;\n+\n+\tcase TRUNC_DIV_EXPR:\n+\tcase FLOOR_DIV_EXPR:\n+\tcase CEIL_DIV_EXPR:\n+\tcase EXACT_DIV_EXPR:\n+\tcase ROUND_DIV_EXPR:\n \t  /* For division, the only case is -INF / -1 = +INF.  */\n-\t  || code == TRUNC_DIV_EXPR\n-\t  || code == FLOOR_DIV_EXPR\n-\t  || code == CEIL_DIV_EXPR\n-\t  || code == EXACT_DIV_EXPR\n-\t  || code == ROUND_DIV_EXPR)\n-\t*res = wi::max_value (TYPE_PRECISION (TREE_TYPE (val1)), sign);\n-      else\n-\t*res = wi::min_value (TYPE_PRECISION (TREE_TYPE (val1)), sign);\n-      return true;\n-    }\n+\t  res = wi::max_value (w0.get_precision (), sign);\n+\t  return true;\n \n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n   return !overflow;\n }\n \n@@ -1127,6 +1106,149 @@ ranges_from_anti_range (value_range *ar,\n   return vr0->type != VR_UNDEFINED;\n }\n \n+/* Order 2 sets of wide int ranges (w0/w1, w2/w3) and set MIN/MAX\n+   accordingly.  */\n+\n+static void\n+wide_int_range_min_max (wide_int &min, wide_int &max,\n+\t\t\twide_int &w0, wide_int &w1, wide_int &w2, wide_int &w3,\n+\t\t\tsignop sign)\n+{\n+  /* Order pairs w0,w1 and w2,w3.  */\n+  if (wi::gt_p (w0, w1, sign))\n+    std::swap (w0, w1);\n+  if (wi::gt_p (w2, w3, sign))\n+    std::swap (w2, w3);\n+\n+  /* Choose min and max from the ordered pairs.  */\n+  min = wi::min (w0, w2, sign);\n+  max = wi::max (w1, w3, sign);\n+}\n+\n+/* Calculate the cross product of two sets of ranges (VR0 and VR1) and\n+   store the result in [RES_LB, RES_UB].\n+\n+   CODE is the operation to perform with sign SIGN.\n+\n+   OVERFLOW_UNDEFINED is set if overflow is undefined for the operation type.\n+\n+   Return TRUE if we were able to calculate the cross product.  */\n+\n+bool\n+wide_int_range_cross_product (wide_int &res_lb, wide_int &res_ub,\n+\t\t\t      enum tree_code code, signop sign,\n+\t\t\t      const wide_int &vr0_lb, const wide_int &vr0_ub,\n+\t\t\t      const wide_int &vr1_lb, const wide_int &vr1_ub,\n+\t\t\t      bool overflow_undefined)\n+{\n+  wide_int cp1, cp2, cp3, cp4;\n+\n+  /* Compute the 4 cross operations, bailing if we get an overflow we\n+     can't handle.  */\n+\n+  if (!wide_int_binop_overflow (cp1, code, vr0_lb, vr1_lb, sign,\n+\t\t\t\toverflow_undefined))\n+    return false;\n+\n+  if (wi::eq_p (vr0_lb, vr0_ub))\n+    cp3 = cp1;\n+  else if (!wide_int_binop_overflow (cp3, code, vr0_ub, vr1_lb, sign,\n+\t\t\t\t     overflow_undefined))\n+    return false;\n+\n+  if (wi::eq_p (vr1_lb, vr1_ub))\n+    cp2 = cp1;\n+  else if (!wide_int_binop_overflow (cp2, code, vr0_lb, vr1_ub, sign,\n+\t\t\t\t     overflow_undefined))\n+    return false;\n+\n+  if (wi::eq_p (vr0_lb, vr0_ub))\n+    cp4 = cp2;\n+  else if (!wide_int_binop_overflow (cp4, code, vr0_ub, vr1_ub, sign,\n+\t\t\t\t     overflow_undefined))\n+    return false;\n+\n+  wide_int_range_min_max (res_lb, res_ub, cp1, cp2, cp3, cp4, sign);\n+  return true;\n+}\n+\n+/* Multiply two ranges when TYPE_OVERFLOW_WRAPS:\n+\n+     [RES_LB, RES_UB] = [MIN0, MAX0] * [MIN1, MAX1]\n+\n+   This is basically fancy code so we don't drop to varying with an\n+   unsigned [-3,-1]*[-3,-1].  */\n+\n+bool\n+wide_int_range_mult_wrapping (wide_int &res_lb,\n+\t\t\t      wide_int &res_ub,\n+\t\t\t      signop sign,\n+\t\t\t      unsigned prec,\n+\t\t\t      const wide_int &min0_,\n+\t\t\t      const wide_int &max0_,\n+\t\t\t      const wide_int &min1_,\n+\t\t\t      const wide_int &max1_)\n+{\n+  /* This test requires 2*prec bits if both operands are signed and\n+     2*prec + 2 bits if either is not.  Therefore, extend the values\n+     using the sign of the result to PREC2.  From here on out,\n+     everthing is just signed math no matter what the input types\n+     were.  */\n+  widest2_int min0 = widest2_int::from (min0_, sign);\n+  widest2_int max0 = widest2_int::from (max0_, sign);\n+  widest2_int min1 = widest2_int::from (min1_, sign);\n+  widest2_int max1 = widest2_int::from (max1_, sign);\n+  widest2_int sizem1 = wi::mask <widest2_int> (prec, false);\n+  widest2_int size = sizem1 + 1;\n+\n+  /* Canonicalize the intervals.  */\n+  if (sign == UNSIGNED)\n+    {\n+      if (wi::ltu_p (size, min0 + max0))\n+\t{\n+\t  min0 -= size;\n+\t  max0 -= size;\n+\t}\n+\n+      if (wi::ltu_p (size, min1 + max1))\n+\t{\n+\t  min1 -= size;\n+\t  max1 -= size;\n+\t}\n+    }\n+\n+  widest2_int prod0 = min0 * min1;\n+  widest2_int prod1 = min0 * max1;\n+  widest2_int prod2 = max0 * min1;\n+  widest2_int prod3 = max0 * max1;\n+\n+  /* Sort the 4 products so that min is in prod0 and max is in\n+     prod3.  */\n+  /* min0min1 > max0max1 */\n+  if (prod0 > prod3)\n+    std::swap (prod0, prod3);\n+\n+  /* min0max1 > max0min1 */\n+  if (prod1 > prod2)\n+    std::swap (prod1, prod2);\n+\n+  if (prod0 > prod1)\n+    std::swap (prod0, prod1);\n+\n+  if (prod2 > prod3)\n+    std::swap (prod2, prod3);\n+\n+  /* diff = max - min.  */\n+  prod2 = prod3 - prod0;\n+  if (wi::geu_p (prod2, sizem1))\n+    /* The range covers all values.  */\n+    return false;\n+\n+  res_lb = wide_int::from (prod0, prec, sign);\n+  res_ub = wide_int::from (prod3, prec, sign);\n+  return true;\n+}\n+\n /* Helper to extract a value-range *VR for a multiplicative operation\n    *VR0 CODE *VR1.  */\n \n@@ -1135,10 +1257,6 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n \t\t\t\t\tenum tree_code code,\n \t\t\t\t\tvalue_range *vr0, value_range *vr1)\n {\n-  enum value_range_type rtype;\n-  wide_int val, min, max;\n-  tree type;\n-\n   /* Multiplications, divisions and shifts are a bit tricky to handle,\n      depending on the mix of signs we have in the two ranges, we\n      need to operate on different values to get the minimum and\n@@ -1162,79 +1280,25 @@ extract_range_from_multiplicative_op_1 (value_range *vr,\n   gcc_assert (vr0->type == VR_RANGE\n \t      && vr0->type == vr1->type);\n \n-  rtype = vr0->type;\n-  type = TREE_TYPE (vr0->min);\n-  signop sgn = TYPE_SIGN (type);\n+  tree type = TREE_TYPE (vr0->min);\n+  wide_int res_lb, res_ub;\n+  wide_int vr0_lb = wi::to_wide (vr0->min);\n+  wide_int vr0_ub = wi::to_wide (vr0->max);\n+  wide_int vr1_lb = wi::to_wide (vr1->min);\n+  wide_int vr1_ub = wi::to_wide (vr1->max);\n+  bool overflow_undefined = TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (vr0->min));\n \n-  /* Compute the 4 cross operations and their minimum and maximum value.  */\n-  if (!vrp_int_const_binop (code, vr0->min, vr1->min, &val))\n+  if (!wide_int_range_cross_product (res_lb, res_ub,\n+\t\t\t\t     code, TYPE_SIGN (type),\n+\t\t\t\t     vr0_lb, vr0_ub, vr1_lb, vr1_ub,\n+\t\t\t\t     overflow_undefined))\n     {\n       set_value_range_to_varying (vr);\n       return;\n     }\n-  min = max = val;\n-\n-  if (vr1->max != vr1->min)\n-    {\n-      if (!vrp_int_const_binop (code, vr0->min, vr1->max, &val))\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-      if (wi::lt_p (val, min, sgn))\n-\tmin = val;\n-      else if (wi::gt_p (val, max, sgn))\n-\tmax = val;\n-    }\n-\n-  if (vr0->max != vr0->min)\n-    {\n-      if (!vrp_int_const_binop (code, vr0->max, vr1->min, &val))\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-      if (wi::lt_p (val, min, sgn))\n-\tmin = val;\n-      else if (wi::gt_p (val, max, sgn))\n-\tmax = val;\n-    }\n-\n-  if (vr0->min != vr0->max && vr1->min != vr1->max)\n-    {\n-      if (!vrp_int_const_binop (code, vr0->max, vr1->max, &val))\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-      if (wi::lt_p (val, min, sgn))\n-\tmin = val;\n-      else if (wi::gt_p (val, max, sgn))\n-\tmax = val;\n-    }\n-\n-  /* If the new range has its limits swapped around (MIN > MAX),\n-     then the operation caused one of them to wrap around, mark\n-     the new range VARYING.  */\n-  if (wi::gt_p (min, max, sgn))\n-    {\n-      set_value_range_to_varying (vr);\n-      return;\n-    }\n-\n-  /* We punt for [-INF, +INF].\n-     We learn nothing when we have INF on both sides.\n-     Note that we do accept [-INF, -INF] and [+INF, +INF].  */\n-  if (wi::eq_p (min, wi::min_value (TYPE_PRECISION (type), sgn))\n-      && wi::eq_p (max, wi::max_value (TYPE_PRECISION (type), sgn)))\n-    {\n-      set_value_range_to_varying (vr);\n-      return;\n-    }\n-\n-  set_value_range (vr, rtype,\n-\t\t   wide_int_to_tree (type, min),\n-\t\t   wide_int_to_tree (type, max), NULL);\n+  set_value_range (vr, VR_RANGE,\n+\t\t   wide_int_to_tree (type, res_lb),\n+\t\t   wide_int_to_tree (type, res_ub), NULL);\n }\n \n /* For op & or | attempt to optimize:\n@@ -1775,104 +1839,32 @@ extract_range_from_binary_expr_1 (value_range *vr,\n     }\n   else if (code == MULT_EXPR)\n     {\n-      /* Fancy code so that with unsigned, [-3,-1]*[-3,-1] does not\n-\t drop to varying.  This test requires 2*prec bits if both\n-\t operands are signed and 2*prec + 2 bits if either is not.  */\n-\n-      signop sign = TYPE_SIGN (expr_type);\n-      unsigned int prec = TYPE_PRECISION (expr_type);\n-\n       if (!range_int_cst_p (&vr0)\n \t  || !range_int_cst_p (&vr1))\n \t{\n \t  set_value_range_to_varying (vr);\n \t  return;\n \t}\n-\n       if (TYPE_OVERFLOW_WRAPS (expr_type))\n \t{\n-\t  typedef FIXED_WIDE_INT (WIDE_INT_MAX_PRECISION * 2) vrp_int;\n-\t  typedef generic_wide_int\n-             <wi::extended_tree <WIDE_INT_MAX_PRECISION * 2> > vrp_int_cst;\n-\t  vrp_int sizem1 = wi::mask <vrp_int> (prec, false);\n-\t  vrp_int size = sizem1 + 1;\n-\n-\t  /* Extend the values using the sign of the result to PREC2.\n-\t     From here on out, everthing is just signed math no matter\n-\t     what the input types were.  */\n-          vrp_int min0 = vrp_int_cst (vr0.min);\n-          vrp_int max0 = vrp_int_cst (vr0.max);\n-          vrp_int min1 = vrp_int_cst (vr1.min);\n-          vrp_int max1 = vrp_int_cst (vr1.max);\n-\t  /* Canonicalize the intervals.  */\n-\t  if (sign == UNSIGNED)\n-\t    {\n-\t      if (wi::ltu_p (size, min0 + max0))\n-\t\t{\n-\t\t  min0 -= size;\n-\t\t  max0 -= size;\n-\t\t}\n-\n-\t      if (wi::ltu_p (size, min1 + max1))\n-\t\t{\n-\t\t  min1 -= size;\n-\t\t  max1 -= size;\n-\t\t}\n-\t    }\n-\n-\t  vrp_int prod0 = min0 * min1;\n-\t  vrp_int prod1 = min0 * max1;\n-\t  vrp_int prod2 = max0 * min1;\n-\t  vrp_int prod3 = max0 * max1;\n-\n-\t  /* Sort the 4 products so that min is in prod0 and max is in\n-\t     prod3.  */\n-\t  /* min0min1 > max0max1 */\n-\t  if (prod0 > prod3)\n-\t    std::swap (prod0, prod3);\n-\n-\t  /* min0max1 > max0min1 */\n-\t  if (prod1 > prod2)\n-\t    std::swap (prod1, prod2);\n-\n-\t  if (prod0 > prod1)\n-\t    std::swap (prod0, prod1);\n-\n-\t  if (prod2 > prod3)\n-\t    std::swap (prod2, prod3);\n-\n-\t  /* diff = max - min.  */\n-\t  prod2 = prod3 - prod0;\n-\t  if (wi::geu_p (prod2, sizem1))\n+\t  signop sign = TYPE_SIGN (expr_type);\n+\t  unsigned int prec = TYPE_PRECISION (expr_type);\n+\t  wide_int res_lb, res_ub;\n+\t  if (!wide_int_range_mult_wrapping (res_lb, res_ub,\n+\t\t\t\t\t     sign, prec,\n+\t\t\t\t\t     wi::to_wide (vr0.min),\n+\t\t\t\t\t     wi::to_wide (vr0.max),\n+\t\t\t\t\t     wi::to_wide (vr1.min),\n+\t\t\t\t\t     wi::to_wide (vr1.max)))\n \t    {\n-\t      /* the range covers all values.  */\n \t      set_value_range_to_varying (vr);\n \t      return;\n \t    }\n-\n-\t  /* The following should handle the wrapping and selecting\n-\t     VR_ANTI_RANGE for us.  */\n-\t  min = wide_int_to_tree (expr_type, prod0);\n-\t  max = wide_int_to_tree (expr_type, prod3);\n+\t  min = wide_int_to_tree (expr_type, res_lb);\n+\t  max = wide_int_to_tree (expr_type, res_ub);\n \t  set_and_canonicalize_value_range (vr, VR_RANGE, min, max, NULL);\n \t  return;\n \t}\n-\n-      /* If we have an unsigned MULT_EXPR with two VR_ANTI_RANGEs,\n-\t drop to VR_VARYING.  It would take more effort to compute a\n-\t precise range for such a case.  For example, if we have\n-\t op0 == 65536 and op1 == 65536 with their ranges both being\n-\t ~[0,0] on a 32-bit machine, we would have op0 * op1 == 0, so\n-\t we cannot claim that the product is in ~[0,0].  Note that we\n-\t are guaranteed to have vr0.type == vr1.type at this\n-\t point.  */\n-      if (vr0.type == VR_ANTI_RANGE\n-\t  && !TYPE_OVERFLOW_UNDEFINED (expr_type))\n-\t{\n-\t  set_value_range_to_varying (vr);\n-\t  return;\n-\t}\n-\n       extract_range_from_multiplicative_op_1 (vr, code, &vr0, &vr1);\n       return;\n     }"}, {"sha": "daf12ce31d12a53d5dedefc73506a8d48053d593", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=3bb1161faf370fb5f6c8745e2c7d4d60cdc30835", "patch": "@@ -102,6 +102,19 @@ extern bool vrp_val_is_min (const_tree);\n extern bool vrp_val_is_max (const_tree);\n extern void copy_value_range (value_range *, value_range *);\n extern void set_value_range_to_value (value_range *, tree, bitmap);\n+extern bool wide_int_range_cross_product (wide_int &res_lb, wide_int &res_ub,\n+\t\t\t\t\t  enum tree_code code, signop sign,\n+\t\t\t\t\t  const wide_int &, const wide_int &,\n+\t\t\t\t\t  const wide_int &, const wide_int &,\n+\t\t\t\t\t  bool overflow_undefined);\n+extern bool wide_int_range_mult_wrapping (wide_int &res_lb,\n+\t\t\t\t\t  wide_int &res_ub,\n+\t\t\t\t\t  signop sign,\n+\t\t\t\t\t  unsigned prec,\n+\t\t\t\t\t  const wide_int &min0_,\n+\t\t\t\t\t  const wide_int &max0_,\n+\t\t\t\t\t  const wide_int &min1_,\n+\t\t\t\t\t  const wide_int &max1_);\n extern void extract_range_from_binary_expr_1 (value_range *, enum tree_code,\n \t\t\t\t\t      tree, value_range *,\n \t\t\t\t\t      value_range *);"}, {"sha": "d15f117b513b99e8e2ed68375dcc1ae3374fc5d7", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=3bb1161faf370fb5f6c8745e2c7d4d60cdc30835", "patch": "@@ -5416,6 +5416,11 @@ namespace wi\n   };\n }\n \n+/* Used to convert a tree to a widest2_int like this:\n+   widest2_int foo = widest2_int_cst (some_tree).  */\n+typedef generic_wide_int <wi::extended_tree <WIDE_INT_MAX_PRECISION * 2> >\n+  widest2_int_cst;\n+\n /* Refer to INTEGER_CST T as though it were a widest_int.\n \n    This function gives T's actual numerical value, influenced by the"}, {"sha": "9e0535b6be57cfa727555c2a6084cbc40ef1d008", "filename": "gcc/wide-int.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2Fwide-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3bb1161faf370fb5f6c8745e2c7d4d60cdc30835/gcc%2Fwide-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int.h?ref=3bb1161faf370fb5f6c8745e2c7d4d60cdc30835", "patch": "@@ -322,6 +322,9 @@ class wide_int_storage;\n typedef generic_wide_int <wide_int_storage> wide_int;\n typedef FIXED_WIDE_INT (ADDR_MAX_PRECISION) offset_int;\n typedef FIXED_WIDE_INT (WIDE_INT_MAX_PRECISION) widest_int;\n+/* Spelled out explicitly (rather than through FIXED_WIDE_INT)\n+   so as not to confuse gengtype.  */\n+typedef generic_wide_int < fixed_wide_int_storage <WIDE_INT_MAX_PRECISION * 2> > widest2_int;\n \n /* wi::storage_ref can be a reference to a primitive type,\n    so this is the conservatively-correct setting.  */"}]}