{"sha": "8ecd1c0da4b4d4a18ababc8dba2a33d618c81070", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGVjZDFjMGRhNGI0ZDRhMThhYmFiYzhkYmEyYTMzZDYxOGM4MTA3MA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2012-01-20T11:32:52Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2012-01-20T11:32:52Z"}, "message": "re PR libfortran/51899 (libgfortran's chmod.c fails to build on MinGW)\n\n2012-01-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR libgfortran/51899\n        * configure.ac: Check whether umask is available.\n        * intrinsics/chmod.c (chmod_func): Make compile with MinGW.\n        * configure: Regenerate.\n        * config.h.in: Regenerate.\n\nFrom-SVN: r183335", "tree": {"sha": "cf12a1b371d25420960613debb68d065507c18d8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf12a1b371d25420960613debb68d065507c18d8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f69ce7cf490b1e8347d0cb700e2f2cb5fbda6633", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f69ce7cf490b1e8347d0cb700e2f2cb5fbda6633", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f69ce7cf490b1e8347d0cb700e2f2cb5fbda6633"}], "stats": {"total": 70, "additions": 66, "deletions": 4}, "files": [{"sha": "49b4681e130acb3df5e455c70d22bbfea201ce96", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=8ecd1c0da4b4d4a18ababc8dba2a33d618c81070", "patch": "@@ -1,3 +1,11 @@\n+2012-01-20  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR libgfortran/51899\n+\t* configure.ac: Check whether umask is available.\n+\t* intrinsics/chmod.c (chmod_func): Make compile with MinGW.\n+\t* configure: Regenerate.\n+\t* config.h.in: Regenerate.\n+\n 2012-01-12  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/36755"}, {"sha": "373930935a7fd5c085d58fac648625e766ceda76", "filename": "libgfortran/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070/libgfortran%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070/libgfortran%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfig.h.in?ref=8ecd1c0da4b4d4a18ababc8dba2a33d618c81070", "patch": "@@ -783,6 +783,9 @@\n /* Define to 1 if the system has the type `uintptr_t'. */\n #undef HAVE_UINTPTR_T\n \n+/* Define to 1 if you have the `umask' function. */\n+#undef HAVE_UMASK\n+\n /* Define to 1 if you have the <unistd.h> header file. */\n #undef HAVE_UNISTD_H\n "}, {"sha": "0498238c7391f022c5f4fe230b392b32d604d419", "filename": "libgfortran/configure", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070/libgfortran%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070/libgfortran%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure?ref=8ecd1c0da4b4d4a18ababc8dba2a33d618c81070", "patch": "@@ -2591,6 +2591,7 @@ as_fn_append ac_func_list \" getpid\"\n as_fn_append ac_func_list \" getppid\"\n as_fn_append ac_func_list \" getuid\"\n as_fn_append ac_func_list \" geteuid\"\n+as_fn_append ac_func_list \" umask\"\n # Check that the precious variables saved in the cache have kept the same\n # value.\n ac_cache_corrupted=false\n@@ -12317,7 +12318,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12320 \"configure\"\n+#line 12321 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12423,7 +12424,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12426 \"configure\"\n+#line 12427 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -16529,6 +16530,8 @@ done\n \n \n \n+\n+\n \n \n "}, {"sha": "af987bd29165f1df21535aa2d043cbba521d1e0a", "filename": "libgfortran/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070/libgfortran%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070/libgfortran%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fconfigure.ac?ref=8ecd1c0da4b4d4a18ababc8dba2a33d618c81070", "patch": "@@ -266,7 +266,7 @@ ftruncate chsize chdir getlogin gethostname kill link symlink sleep ttyname \\\n alarm access fork execl wait setmode execve pipe dup2 close \\\n strcasestr getrlimit gettimeofday stat fstat lstat getpwuid vsnprintf dup \\\n getcwd localtime_r gmtime_r strerror_r getpwuid_r ttyname_r clock_gettime \\\n-readlink getgid getpid getppid getuid geteuid)\n+readlink getgid getpid getppid getuid geteuid umask)\n \n # Check for C99 (and other IEEE) math functions\n AC_CHECK_LIB([m],[acosf],[AC_DEFINE([HAVE_ACOSF],[1],[libm includes acosf])])"}, {"sha": "01db8beb9e0823d7b6528fa6fed0fa5dd926ec06", "filename": "libgfortran/intrinsics/chmod.c", "status": "modified", "additions": 49, "deletions": 1, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070/libgfortran%2Fintrinsics%2Fchmod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ecd1c0da4b4d4a18ababc8dba2a33d618c81070/libgfortran%2Fintrinsics%2Fchmod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fchmod.c?ref=8ecd1c0da4b4d4a18ababc8dba2a33d618c81070", "patch": "@@ -37,6 +37,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n \n    Sets the file permission \"chmod\" using a mode string.\n \n+   For MinGW, only _S_IWRITE and _S_IREAD are supported. To set those,\n+   only the user attributes are used.\n+\n    The mode string allows for the same arguments as POSIX's chmod utility.\n    a) string containing an octal number.\n    b) Comma separated list of clauses of the form:\n@@ -89,8 +92,15 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n \n   if (mode[0] >= '0' && mode[0] <= '9')\n     {\n+#ifdef __MINGW32__\n+      unsigned mode;\n+      if (sscanf (mode, \"%o\", &mode) != 1)\n+\treturn 1;\n+      file_mode = (mode_t) mode;\n+#else\n       if (sscanf (mode, \"%o\", &file_mode) != 1)\n \treturn 1;\n+#endif\n       return chmod (file, file_mode);\n     }\n \n@@ -101,10 +111,14 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n   file_mode = stat_buf.st_mode & ~S_IFMT;\n   is_dir = stat_buf.st_mode & S_IFDIR;\n \n+#ifdef HAVE_UMASK\n   /* Obtain the umask without distroying the setting.  */\n   mode_mask = 0;\n   mode_mask = umask (mode_mask);\n   (void) umask (mode_mask);\n+#else\n+  honor_umask = false;\n+#endif\n \n   for (i = 0; i < mode_len; i++)\n     {\n@@ -113,7 +127,9 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n \t  ugo[0] = false;\n \t  ugo[1] = false;\n \t  ugo[2] = false;\n+#ifdef HAVE_UMASK\n \t  honor_umask = true;\n+#endif\n \t}\n       continue_clause = false; \n       rwxXstugo[0] = false;\n@@ -140,7 +156,9 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n \t      ugo[1] = true;\n \t      ugo[2] = true;\n \t      part = 1;\n+#ifdef HAVE_UMASK\n \t      honor_umask = false;\n+#endif\n \t      break;\n \t    case 'u':\n \t      if (part == 2)\n@@ -153,7 +171,9 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n \t\treturn 1;\n \t      ugo[0] = true;\n \t      part = 1;\n+#ifdef HAVE_UMASK\n \t      honor_umask = false;\n+#endif\n \t      break;\n \t    case 'g':\n \t      if (part == 2)\n@@ -166,7 +186,9 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n \t\treturn 1;\n        \t      ugo[1] = true;\n \t      part = 1;\n+#ifdef HAVE_UMASK\n \t      honor_umask = false;\n+#endif\n \t      break;\n \t    case 'o':\n \t      if (part == 2)\n@@ -179,7 +201,9 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n \t\treturn 1;\n \t      ugo[2] = true;\n \t      part = 1;\n+#ifdef HAVE_UMASK\n \t      honor_umask = false;\n+#endif\n \t      break;\n \n \t    /* Mode setting: =+-.  */\n@@ -285,6 +309,18 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n \n       new_mode = 0;\n \n+#ifdef __MINGW32__\n+\n+      /* Read. */\n+      if (rwxXstugo[0] && (ugo[0] || honor_umask))\n+\tnew_mode |= _S_IREAD;\n+\n+      /* Write. */\n+      if (rwxXstugo[1] && (ugo[0] || honor_umask))\n+\tnew_mode |= _S_IWRITE;\n+\n+#else\n+\n       /* Read. */\n       if (rwxXstugo[0])\n \t{\n@@ -400,12 +436,20 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n \t\tnew_mode |= S_IXGRP;\n \t    }\n \t}\n+#endif  /* __MINGW32__ */\n \n+#ifdef HAVE_UMASK\n     if (honor_umask)\n       new_mode &= ~mode_mask;\n+#endif\n \n     if (set_mode == 1)\n       {\n+#ifdef __MINGW32__\n+\tif (ugo[0] || honor_umask)\n+\t  file_mode = (file_mode & ~(_S_IWRITE | _S_IREAD))\n+\t\t      | (new_mode & (_S_IWRITE | _S_IREAD));\n+#else\n \t/* Set '='.  */\n \tif ((ugo[0] || honor_umask) && !rwxXstugo[6])\n \t  file_mode = (file_mode & ~(S_ISUID | S_IRUSR | S_IWUSR | S_IXUSR))\n@@ -420,29 +464,33 @@ chmod_func (char *name, char *mode, gfc_charlen_type name_len,\n \t  file_mode |= S_ISVTX;\n \telse if (!is_dir)\n \t  file_mode &= ~S_ISVTX;\n+#endif\n       }\n     else if (set_mode == 2)\n       {\n \t/* Clear '-'.  */\n \tfile_mode &= ~new_mode;\n+#ifndef __MINGW32__\n \tif (rwxXstugo[5] || !is_dir)\n \t  file_mode &= ~S_ISVTX;\n+#endif\n       }\n     else if (set_mode == 3)\n       {\n \tfile_mode |= new_mode;\n+#ifndef __MINGW32__\n \tif (rwxXstugo[5] && is_dir)\n \t  file_mode |= S_ISVTX;\n \telse if (!is_dir)\n \t  file_mode &= ~S_ISVTX;\n+#endif\n       }\n   }\n \n   return chmod (file, file_mode);\n }\n \n \n-\n extern void chmod_i4_sub (char *, char *, GFC_INTEGER_4 *,\n \t\t\t  gfc_charlen_type, gfc_charlen_type);\n export_proto(chmod_i4_sub);"}]}