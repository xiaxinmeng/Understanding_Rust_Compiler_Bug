{"sha": "8ba2bda8e4b4276770901b720dee4f3d297dda3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGJhMmJkYThlNGI0Mjc2NzcwOTAxYjcyMGRlZTRmM2QyOTdkZGEzYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-08T20:08:32Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2019-05-08T20:08:32Z"}, "message": "compiler: generate memmove for non-pointer slice copy\n    \n    The builtin copy function is lowered to runtime functions\n    slicecopy, stringslicecopy, or typedslicecopy. The first two are\n    basically thin wrappers of memmove. Instead of making a runtime\n    call, we can just use __builtin_memmove. This gives the compiler\n    backend opportunities for further optimizations.\n    \n    Move the lowering of builtin copy function to flatten phase for\n    the ease of rewriting.\n    \n    Also do this optimization for the copy part of append(s1, s2...).\n    \n    Reviewed-on: https://go-review.googlesource.com/c/gofrontend/+/170005\n\nFrom-SVN: r271017", "tree": {"sha": "b09cebba2ae3f1765d776aeb1ec2af5bbfa25a62", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b09cebba2ae3f1765d776aeb1ec2af5bbfa25a62"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8ba2bda8e4b4276770901b720dee4f3d297dda3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba2bda8e4b4276770901b720dee4f3d297dda3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ba2bda8e4b4276770901b720dee4f3d297dda3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ba2bda8e4b4276770901b720dee4f3d297dda3c/comments", "author": null, "committer": null, "parents": [{"sha": "fbe4e644c0c8f1303ec91a25b8da6e626976500c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fbe4e644c0c8f1303ec91a25b8da6e626976500c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fbe4e644c0c8f1303ec91a25b8da6e626976500c"}], "stats": {"total": 190, "additions": 134, "deletions": 56}, "files": [{"sha": "919127300350580be65d52355fd8dff6903715b5", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba2bda8e4b4276770901b720dee4f3d297dda3c/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba2bda8e4b4276770901b720dee4f3d297dda3c/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=8ba2bda8e4b4276770901b720dee4f3d297dda3c", "patch": "@@ -1,4 +1,4 @@\n-3a9bccfbf4af1c756978c40967838d9f6a4e7a62\n+859e8ed3d632d9fe43d03fb81f6abefecf5fe3a6\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "707636ab6b17f18e9d0b504e7dda7fa05352f77b", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 129, "deletions": 55, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba2bda8e4b4276770901b720dee4f3d297dda3c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba2bda8e4b4276770901b720dee4f3d297dda3c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=8ba2bda8e4b4276770901b720dee4f3d297dda3c", "patch": "@@ -7743,8 +7743,9 @@ Builtin_call_expression::do_lower(Gogo*, Named_object* function,\n   return this;\n }\n \n-// Flatten a builtin call expression.  This turns the arguments of copy and\n-// append into temporary expressions.\n+// Flatten a builtin call expression.  This turns the arguments of some\n+// builtin calls into temporary expressions.  Also expand copy and append\n+// to runtime calls.\n \n Expression*\n Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n@@ -7781,6 +7782,85 @@ Builtin_call_expression::do_flatten(Gogo* gogo, Named_object* function,\n \t\t*pa = Expression::make_temporary_reference(temp, loc);\n \t      }\n \t  }\n+\n+        // Lower to runtime call.\n+        const Expression_list* args = this->args();\n+        go_assert(args != NULL && args->size() == 2);\n+        Expression* arg1 = args->front();\n+        Expression* arg2 = args->back();\n+        go_assert(arg1->is_variable());\n+        go_assert(arg2->is_variable());\n+        bool arg2_is_string = arg2->type()->is_string_type();\n+\n+        Expression* ret;\n+        Type* et = at->array_type()->element_type();\n+        if (et->has_pointer())\n+          {\n+            Expression* td = Expression::make_type_descriptor(et, loc);\n+            ret = Runtime::make_call(Runtime::TYPEDSLICECOPY, loc,\n+                                     3, td, arg1, arg2);\n+          }\n+        else\n+          {\n+            Type* int_type = Type::lookup_integer_type(\"int\");\n+            Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+            // l1 = len(arg1)\n+            Named_object* lenfn = gogo->lookup_global(\"len\");\n+            Expression* lenref = Expression::make_func_reference(lenfn, NULL, loc);\n+            Expression_list* len_args = new Expression_list();\n+            len_args->push_back(arg1->copy());\n+            Expression* len1 = Expression::make_call(lenref, len_args, false, loc);\n+            gogo->lower_expression(function, inserter, &len1);\n+            gogo->flatten_expression(function, inserter, &len1);\n+            Temporary_statement* l1tmp = Statement::make_temporary(int_type, len1, loc);\n+            inserter->insert(l1tmp);\n+\n+            // l2 = len(arg2)\n+            len_args = new Expression_list();\n+            len_args->push_back(arg2->copy());\n+            Expression* len2 = Expression::make_call(lenref, len_args, false, loc);\n+            gogo->lower_expression(function, inserter, &len2);\n+            gogo->flatten_expression(function, inserter, &len2);\n+            Temporary_statement* l2tmp = Statement::make_temporary(int_type, len2, loc);\n+            inserter->insert(l2tmp);\n+\n+            // n = (l1 < l2 ? l1 : l2)\n+            Expression* l1ref = Expression::make_temporary_reference(l1tmp, loc);\n+            Expression* l2ref = Expression::make_temporary_reference(l2tmp, loc);\n+            Expression* cond = Expression::make_binary(OPERATOR_LT, l1ref, l2ref, loc);\n+            Expression* n = Expression::make_conditional(cond,\n+                                                         l1ref->copy(),\n+                                                         l2ref->copy(),\n+                                                         loc);\n+            Temporary_statement* ntmp = Statement::make_temporary(NULL, n, loc);\n+            inserter->insert(ntmp);\n+\n+            // sz = n * sizeof(elem_type)\n+            Expression* nref = Expression::make_temporary_reference(ntmp, loc);\n+            nref = Expression::make_cast(uintptr_type, nref, loc);\n+            Expression* sz = Expression::make_type_info(et, TYPE_INFO_SIZE);\n+            sz = Expression::make_binary(OPERATOR_MULT, sz, nref, loc);\n+\n+            // memmove(arg1.ptr, arg2.ptr, sz)\n+            Expression* p1 = Expression::make_slice_info(arg1,\n+                                                         SLICE_INFO_VALUE_POINTER,\n+                                                         loc);\n+            Expression* p2 = (arg2_is_string\n+                              ? Expression::make_string_info(arg2,\n+                                                             STRING_INFO_DATA,\n+                                                             loc)\n+                              : Expression::make_slice_info(arg2,\n+                                                            SLICE_INFO_VALUE_POINTER,\n+                                                            loc));\n+            Expression* call = Runtime::make_call(Runtime::BUILTIN_MEMMOVE, loc, 3,\n+                                                  p1, p2, sz);\n+\n+            // n is the return value of copy\n+            nref = Expression::make_temporary_reference(ntmp, loc);\n+            ret = Expression::make_compound(call, nref, loc);\n+          }\n+        return ret;\n       }\n       break;\n \n@@ -8209,21 +8289,51 @@ Builtin_call_expression::flatten_append(Gogo* gogo, Named_object* function,\n \n   if (this->is_varargs())\n     {\n-      // copy(s1tmp[l1tmp:], s2tmp)\n-      a1 = Expression::make_temporary_reference(s1tmp, loc);\n-      ref = Expression::make_temporary_reference(l1tmp, loc);\n-      Expression* nil = Expression::make_nil(loc);\n-      a1 = Expression::make_array_index(a1, ref, nil, NULL, loc);\n-      a1->array_index_expression()->set_needs_bounds_check(false);\n-\n-      a2 = Expression::make_temporary_reference(s2tmp, loc);\n-\n-      Named_object* copyfn = gogo->lookup_global(\"copy\");\n-      Expression* copyref = Expression::make_func_reference(copyfn, NULL, loc);\n-      call_args = new Expression_list();\n-      call_args->push_back(a1);\n-      call_args->push_back(a2);\n-      call = Expression::make_call(copyref, call_args, false, loc);\n+      if (element_type->has_pointer())\n+        {\n+          // copy(s1tmp[l1tmp:], s2tmp)\n+          a1 = Expression::make_temporary_reference(s1tmp, loc);\n+          ref = Expression::make_temporary_reference(l1tmp, loc);\n+          Expression* nil = Expression::make_nil(loc);\n+          a1 = Expression::make_array_index(a1, ref, nil, NULL, loc);\n+          a1->array_index_expression()->set_needs_bounds_check(false);\n+\n+          a2 = Expression::make_temporary_reference(s2tmp, loc);\n+\n+          Named_object* copyfn = gogo->lookup_global(\"copy\");\n+          Expression* copyref = Expression::make_func_reference(copyfn, NULL, loc);\n+          call_args = new Expression_list();\n+          call_args->push_back(a1);\n+          call_args->push_back(a2);\n+          call = Expression::make_call(copyref, call_args, false, loc);\n+        }\n+      else\n+        {\n+          // memmove(&s1tmp[l1tmp], s2tmp.ptr, l2tmp*sizeof(elem))\n+          a1 = Expression::make_temporary_reference(s1tmp, loc);\n+          ref = Expression::make_temporary_reference(l1tmp, loc);\n+          a1 = Expression::make_array_index(a1, ref, NULL, NULL, loc);\n+          a1->array_index_expression()->set_needs_bounds_check(false);\n+          a1 = Expression::make_unary(OPERATOR_AND, a1, loc);\n+\n+          a2 = Expression::make_temporary_reference(s2tmp, loc);\n+          a2 = (a2->type()->is_string_type()\n+                ? Expression::make_string_info(a2,\n+                                               STRING_INFO_DATA,\n+                                               loc)\n+                : Expression::make_slice_info(a2,\n+                                              SLICE_INFO_VALUE_POINTER,\n+                                              loc));\n+\n+          Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+          ref = Expression::make_temporary_reference(l2tmp, loc);\n+          ref = Expression::make_cast(uintptr_type, ref, loc);\n+          a3 = Expression::make_type_info(element_type, TYPE_INFO_SIZE);\n+          a3 = Expression::make_binary(OPERATOR_MULT, a3, ref, loc);\n+\n+          call = Runtime::make_call(Runtime::BUILTIN_MEMMOVE, loc, 3,\n+                                    a1, a2, a3);\n+        }\n       gogo->lower_expression(function, inserter, &call);\n       gogo->flatten_expression(function, inserter, &call);\n       inserter->insert(Statement::make_statement(call, false));\n@@ -9666,44 +9776,8 @@ Builtin_call_expression::do_get_backend(Translate_context* context)\n       }\n \n     case BUILTIN_COPY:\n-      {\n-\tconst Expression_list* args = this->args();\n-\tgo_assert(args != NULL && args->size() == 2);\n-\tExpression* arg1 = args->front();\n-\tExpression* arg2 = args->back();\n-\n-\tType* arg1_type = arg1->type();\n-\tArray_type* at = arg1_type->array_type();\n-\tgo_assert(arg1->is_variable());\n-\n-\tExpression* call;\n-\n-\tType* arg2_type = arg2->type();\n-        go_assert(arg2->is_variable());\n-\tif (arg2_type->is_string_type())\n-\t  call = Runtime::make_call(Runtime::SLICESTRINGCOPY, location,\n-\t\t\t\t    2, arg1, arg2);\n-\telse\n-\t  {\n-\t    Type* et = at->element_type();\n-\t    if (et->has_pointer())\n-\t      {\n-\t\tExpression* td = Expression::make_type_descriptor(et,\n-\t\t\t\t\t\t\t\t  location);\n-\t\tcall = Runtime::make_call(Runtime::TYPEDSLICECOPY, location,\n-\t\t\t\t\t  3, td, arg1, arg2);\n-\t      }\n-\t    else\n-\t      {\n-\t\tExpression* sz = Expression::make_type_info(et,\n-\t\t\t\t\t\t\t    TYPE_INFO_SIZE);\n-\t\tcall = Runtime::make_call(Runtime::SLICECOPY, location, 3,\n-\t\t\t\t\t  arg1, arg2, sz);\n-\t      }\n-\t  }\n-\n-\treturn call->get_backend(context);\n-      }\n+      // Handled in Builtin_call_expression::do_flatten.\n+      go_unreachable();\n \n     case BUILTIN_APPEND:\n       // Handled in Builtin_call_expression::flatten_append."}, {"sha": "c17b4816d871cd0b98d8d07ebd3f51d689c999bc", "filename": "gcc/go/gofrontend/runtime.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8ba2bda8e4b4276770901b720dee4f3d297dda3c/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8ba2bda8e4b4276770901b720dee4f3d297dda3c/gcc%2Fgo%2Fgofrontend%2Fruntime.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fruntime.def?ref=8ba2bda8e4b4276770901b720dee4f3d297dda3c", "patch": "@@ -372,6 +372,10 @@ DEF_GO_RUNTIME(FIELDTRACK, \"__go_fieldtrack\", P1(POINTER), R0())\n // Unreachable code.\n DEF_GO_RUNTIME(UNREACHABLE, \"__builtin_unreachable\", P0(), R0())\n \n+// Memmove.\n+DEF_GO_RUNTIME(BUILTIN_MEMMOVE, \"__builtin_memmove\",\n+               P3(POINTER, POINTER, UINTPTR), R0())\n+\n // Remove helper macros.\n #undef ABFT6\n #undef ABFT2"}]}