{"sha": "f40b39a32027ffe76789c3d546218d5dea5ac74a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQwYjM5YTMyMDI3ZmZlNzY3ODljM2Q1NDYyMThkNWRlYTVhYzc0YQ==", "commit": {"author": {"name": "Alexander Ivchenko", "email": "alexander.ivchenko@intel.com", "date": "2014-10-16T11:46:07Z"}, "committer": {"name": "Kirill Yukhin", "email": "kyukhin@gcc.gnu.org", "date": "2014-10-16T11:46:07Z"}, "message": "AVX-512. 78/n. Use blend for inserting.\n\ngcc/\n\t* config/i386/i386.c (ix86_expand_vector_set): Handle V8DF, V8DI, V16SF,\n\tV16SI, V32HI, V64QI modes.\n\nCo-Authored-By: Andrey Turetskiy <andrey.turetskiy@intel.com>\nCo-Authored-By: Anna Tikhonova <anna.tikhonova@intel.com>\nCo-Authored-By: Ilya Tocar <ilya.tocar@intel.com>\nCo-Authored-By: Ilya Verbin <ilya.verbin@intel.com>\nCo-Authored-By: Kirill Yukhin <kirill.yukhin@intel.com>\nCo-Authored-By: Maxim Kuznetsov <maxim.kuznetsov@intel.com>\nCo-Authored-By: Michael Zolotukhin <michael.v.zolotukhin@intel.com>\n\nFrom-SVN: r216310", "tree": {"sha": "8f40c1030cff1d79f9e63e820aeceece641f1c20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f40c1030cff1d79f9e63e820aeceece641f1c20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f40b39a32027ffe76789c3d546218d5dea5ac74a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40b39a32027ffe76789c3d546218d5dea5ac74a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f40b39a32027ffe76789c3d546218d5dea5ac74a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f40b39a32027ffe76789c3d546218d5dea5ac74a/comments", "author": null, "committer": null, "parents": [{"sha": "6fba99cf789695c25f3920f876c34c2634515507", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6fba99cf789695c25f3920f876c34c2634515507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6fba99cf789695c25f3920f876c34c2634515507"}], "stats": {"total": 85, "additions": 85, "deletions": 0}, "files": [{"sha": "96356fc1e0bb8a57e3fc9a04eb78e5aa101a8f95", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40b39a32027ffe76789c3d546218d5dea5ac74a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40b39a32027ffe76789c3d546218d5dea5ac74a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f40b39a32027ffe76789c3d546218d5dea5ac74a", "patch": "@@ -1,3 +1,15 @@\n+2014-10-16  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n+\t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n+\t    Anna Tikhonova  <anna.tikhonova@intel.com>\n+\t    Ilya Tocar  <ilya.tocar@intel.com>\n+\t    Andrey Turetskiy  <andrey.turetskiy@intel.com>\n+\t    Ilya Verbin  <ilya.verbin@intel.com>\n+\t    Kirill Yukhin  <kirill.yukhin@intel.com>\n+\t    Michael Zolotukhin  <michael.v.zolotukhin@intel.com>\n+\n+\t* config/i386/i386.c (ix86_expand_vector_set): Handle V8DF, V8DI, V16SF,\n+\tV16SI, V32HI, V64QI modes.\n+\n 2014-10-16  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/53513"}, {"sha": "073e4ccc0ed5a31ca99e7222c15bc1edf5a5564d", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f40b39a32027ffe76789c3d546218d5dea5ac74a/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f40b39a32027ffe76789c3d546218d5dea5ac74a/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=f40b39a32027ffe76789c3d546218d5dea5ac74a", "patch": "@@ -40854,6 +40854,79 @@ ix86_expand_vector_set (bool mmx_ok, rtx target, rtx val, int elt)\n       emit_insn (gen_insert[j][i] (target, target, tmp));\n       return;\n \n+    case V8DFmode:\n+      if (TARGET_AVX512F)\n+\t{\n+\t  tmp = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, tmp,\n+\t\t\t\t  gen_rtx_VEC_DUPLICATE (mode, val)));\n+\t  emit_insn (gen_avx512f_blendmv8df (target, tmp, target,\n+\t\t\t\t\t     force_reg (QImode, GEN_INT (1 << elt))));\n+\t  return;\n+\t}\n+      else\n+\tbreak;\n+    case V8DImode:\n+      if (TARGET_AVX512F)\n+\t{\n+\t  tmp = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, tmp,\n+\t\t\t\t  gen_rtx_VEC_DUPLICATE (mode, val)));\n+\t  emit_insn (gen_avx512f_blendmv8di (target, tmp, target,\n+\t\t\t\t\t     force_reg (QImode, GEN_INT (1 << elt))));\n+\t  return;\n+\t}\n+      else\n+\tbreak;\n+    case V16SFmode:\n+      if (TARGET_AVX512F)\n+\t{\n+\t  tmp = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, tmp,\n+\t\t\t\t  gen_rtx_VEC_DUPLICATE (mode, val)));\n+\t  emit_insn (gen_avx512f_blendmv16sf (target, tmp, target,\n+\t\t\t\t\t      force_reg (HImode, GEN_INT (1 << elt))));\n+\t  return;\n+\t}\n+      else\n+\tbreak;\n+    case V16SImode:\n+      if (TARGET_AVX512F)\n+\t{\n+\t  tmp = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, tmp,\n+\t\t\t\t  gen_rtx_VEC_DUPLICATE (mode, val)));\n+\t  emit_insn (gen_avx512f_blendmv16si (target, tmp, target,\n+\t\t\t\t\t      force_reg (HImode, GEN_INT (1 << elt))));\n+\t  return;\n+\t}\n+      else\n+\tbreak;\n+    case V32HImode:\n+      if (TARGET_AVX512F && TARGET_AVX512BW)\n+\t{\n+\t  tmp = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, tmp,\n+\t\t\t\t  gen_rtx_VEC_DUPLICATE (mode, val)));\n+\t  emit_insn (gen_avx512bw_blendmv32hi (target, tmp, target,\n+\t\t\t\t\t       force_reg (SImode, GEN_INT (1 << elt))));\n+\t  return;\n+\t}\n+      else\n+\tbreak;\n+    case V64QImode:\n+      if (TARGET_AVX512F && TARGET_AVX512BW)\n+\t{\n+\t  tmp = gen_reg_rtx (mode);\n+\t  emit_insn (gen_rtx_SET (VOIDmode, tmp,\n+\t\t\t\t  gen_rtx_VEC_DUPLICATE (mode, val)));\n+\t  emit_insn (gen_avx512bw_blendmv64qi (target, tmp, target,\n+\t\t\t\t\t       force_reg (DImode, GEN_INT (1 << elt))));\n+\t  return;\n+\t}\n+      else\n+\tbreak;\n+\n     default:\n       break;\n     }"}]}