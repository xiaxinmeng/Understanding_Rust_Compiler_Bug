{"sha": "fe4e525c241f01ef04d2405172e337dfb1d63dda", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU0ZTUyNWMyNDFmMDFlZjA0ZDI0MDUxNzJlMzM3ZGZiMWQ2M2RkYQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-06-21T14:15:56Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-06-21T14:15:56Z"}, "message": "re PR fortran/40632 (Support F2008's contiguous attribute)\n\n2010-06-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/40632\n        * interface.c (compare_parameter): Add gfc_is_simply_contiguous\n        checks.\n        * symbol.c (gfc_add_contiguous): New function.\n        (gfc_copy_attr, check_conflict): Handle contiguous attribute.\n        * decl.c (match_attr_spec): Ditto.\n        (gfc_match_contiguous): New function.\n        * resolve.c (resolve_fl_derived, resolve_symbol): Handle\n        contiguous.\n        * gfortran.h (symbol_attribute): Add contiguous.\n        (gfc_is_simply_contiguous): Add prototype.\n        (gfc_add_contiguous): Add prototype.\n        * match.h (gfc_match_contiguous): Add prototype.\n        * parse.c (decode_specification_statement,\n        decode_statement): Handle contiguous attribute.\n        * expr.c (gfc_is_simply_contiguous): New function.\n        * dump-parse-tree.c (show_attr): Handle contiguous.\n        * module.c (ab_attribute, attr_bits, mio_symbol_attribute):\n        Ditto.\n        * trans-expr.c (gfc_add_interface_mapping): Copy\n        attr.contiguous.\n        * trans-array.c (gfc_conv_descriptor_stride_get,\n        gfc_conv_array_parameter): Handle contiguous arrays.\n        * trans-types.c (gfc_build_array_type, gfc_build_array_type,\n        gfc_sym_type, gfc_get_derived_type, gfc_get_array_descr_info):\n        Ditto.\n        * trans.h (gfc_array_kind): Ditto.\n        * trans-decl.c (gfc_get_symbol_decl): Ditto.\n\n2010-06-20  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/40632\n        * gfortran.dg/contiguous_1.f90: New.\n        * gfortran.dg/contiguous_2.f90: New.\n        * gfortran.dg/contiguous_3.f90: New.\n\nFrom-SVN: r161079", "tree": {"sha": "021d3ff6f25beca1bdf707ef4ee39618d4492016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/021d3ff6f25beca1bdf707ef4ee39618d4492016"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe4e525c241f01ef04d2405172e337dfb1d63dda", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe4e525c241f01ef04d2405172e337dfb1d63dda", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe4e525c241f01ef04d2405172e337dfb1d63dda", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe4e525c241f01ef04d2405172e337dfb1d63dda/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6ca9ec9caf619c7c87740d598bc2539163615bd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ca9ec9caf619c7c87740d598bc2539163615bd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ca9ec9caf619c7c87740d598bc2539163615bd6"}], "stats": {"total": 633, "additions": 607, "deletions": 26}, "files": [{"sha": "1385318d55070e4ea585f2f4ff40697dd0bd4452", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -1,3 +1,34 @@\n+2010-06-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/40632\n+\t* interface.c (compare_parameter): Add gfc_is_simply_contiguous\n+\tchecks.\n+\t* symbol.c (gfc_add_contiguous): New function.\n+\t(gfc_copy_attr, check_conflict): Handle contiguous attribute.\n+\t* decl.c (match_attr_spec): Ditto.\n+\t(gfc_match_contiguous): New function.\n+\t* resolve.c (resolve_fl_derived, resolve_symbol): Handle\n+\tcontiguous.\n+\t* gfortran.h (symbol_attribute): Add contiguous.\n+\t(gfc_is_simply_contiguous): Add prototype.\n+\t(gfc_add_contiguous): Add prototype.\n+\t* match.h (gfc_match_contiguous): Add prototype.\n+\t* parse.c (decode_specification_statement,\n+\tdecode_statement): Handle contiguous attribute.\n+\t* expr.c (gfc_is_simply_contiguous): New function.\n+\t* dump-parse-tree.c (show_attr): Handle contiguous.\n+\t* module.c (ab_attribute, attr_bits, mio_symbol_attribute):\n+\tDitto.\n+\t* trans-expr.c (gfc_add_interface_mapping): Copy\n+\tattr.contiguous.\n+\t* trans-array.c (gfc_conv_descriptor_stride_get,\n+\tgfc_conv_array_parameter): Handle contiguous arrays.\n+\t* trans-types.c (gfc_build_array_type, gfc_build_array_type,\n+\tgfc_sym_type, gfc_get_derived_type, gfc_get_array_descr_info):\n+\tDitto.\n+\t* trans.h (gfc_array_kind): Ditto.\n+\t* trans-decl.c (gfc_get_symbol_decl): Ditto.\n+\n 2010-06-20  Joseph Myers  <joseph@codesourcery.com>\n \n \t* options.c (gfc_handle_option): Don't handle N_OPTS."}, {"sha": "f7f48002d3f09473e942931897a69275bf0ae2a2", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 48, "deletions": 5, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -2875,8 +2875,8 @@ match_attr_spec (void)\n     DECL_IN, DECL_OUT, DECL_INOUT, DECL_INTRINSIC, DECL_OPTIONAL,\n     DECL_PARAMETER, DECL_POINTER, DECL_PROTECTED, DECL_PRIVATE,\n     DECL_PUBLIC, DECL_SAVE, DECL_TARGET, DECL_VALUE, DECL_VOLATILE,\n-    DECL_IS_BIND_C, DECL_CODIMENSION, DECL_ASYNCHRONOUS, DECL_NONE,\n-    GFC_DECL_END /* Sentinel */\n+    DECL_IS_BIND_C, DECL_CODIMENSION, DECL_ASYNCHRONOUS, DECL_CONTIGUOUS,\n+    DECL_NONE, GFC_DECL_END /* Sentinel */\n   }\n   decl_types;\n \n@@ -2939,6 +2939,7 @@ match_attr_spec (void)\n \t\t    }\n \t\t  break;\n \t\t}\n+\t      break;\n \n \t    case 'b':\n \t      /* Try and match the bind(c).  */\n@@ -2950,8 +2951,24 @@ match_attr_spec (void)\n \t      break;\n \n \t    case 'c':\n-\t      if (match_string_p (\"codimension\"))\n-\t\td = DECL_CODIMENSION;\n+\t      gfc_next_ascii_char ();\n+\t      if ('o' != gfc_next_ascii_char ())\n+\t\tbreak;\n+\t      switch (gfc_next_ascii_char ())\n+\t\t{\n+\t\tcase 'd':\n+\t\t  if (match_string_p (\"imension\"))\n+\t\t    {\n+\t\t      d = DECL_CODIMENSION;\n+\t\t      break;\n+\t\t    }\n+\t\tcase 'n':\n+\t\t  if (match_string_p (\"tiguous\"))\n+\t\t    {\n+\t\t      d = DECL_CONTIGUOUS;\n+\t\t      break;\n+\t\t    }\n+\t\t}\n \t      break;\n \n \t    case 'd':\n@@ -3144,6 +3161,9 @@ match_attr_spec (void)\n \t  case DECL_CODIMENSION:\n \t    attr = \"CODIMENSION\";\n \t    break;\n+\t  case DECL_CONTIGUOUS:\n+\t    attr = \"CONTIGUOUS\";\n+\t    break;\n \t  case DECL_DIMENSION:\n \t    attr = \"DIMENSION\";\n \t    break;\n@@ -3214,7 +3234,7 @@ match_attr_spec (void)\n       if (gfc_current_state () == COMP_DERIVED\n \t  && d != DECL_DIMENSION && d != DECL_CODIMENSION\n \t  && d != DECL_POINTER   && d != DECL_PRIVATE\n-\t  && d != DECL_PUBLIC && d != DECL_NONE)\n+\t  && d != DECL_PUBLIC && d != DECL_CONTIGUOUS && d != DECL_NONE)\n \t{\n \t  if (d == DECL_ALLOCATABLE)\n \t    {\n@@ -3283,6 +3303,15 @@ match_attr_spec (void)\n \t  t = gfc_add_codimension (&current_attr, NULL, &seen_at[d]);\n \t  break;\n \n+\tcase DECL_CONTIGUOUS:\n+\t  if (gfc_notify_std (GFC_STD_F2008,\n+\t\t\t      \"Fortran 2008: CONTIGUOUS attribute at %C\")\n+\t      == FAILURE)\n+\t    t = FAILURE;\n+\t  else\n+\t    t = gfc_add_contiguous (&current_attr, NULL, &seen_at[d]);\n+\t  break;\n+\n \tcase DECL_DIMENSION:\n \t  t = gfc_add_dimension (&current_attr, NULL, &seen_at[d]);\n \t  break;\n@@ -6120,6 +6149,20 @@ gfc_match_codimension (void)\n }\n \n \n+match\n+gfc_match_contiguous (void)\n+{\n+  if (gfc_notify_std (GFC_STD_F2008, \"Fortran 2008: CONTIGUOUS statement at %C\")\n+      == FAILURE)\n+    return MATCH_ERROR;\n+\n+  gfc_clear_attr (&current_attr);\n+  current_attr.contiguous = 1;\n+\n+  return attr_decl ();\n+}\n+\n+\n match\n gfc_match_dimension (void)\n {"}, {"sha": "fcf5b25d35086accb5b9817f30a2c2f9d6ca41a9", "filename": "gcc/fortran/dependency.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -1588,4 +1588,3 @@ gfc_dep_resolver (gfc_ref *lref, gfc_ref *rref)\n \n   return fin_dep == GFC_DEP_OVERLAP;\n }\n-"}, {"sha": "dd786bedabacb144717b5b5c84aa69b6e344d617", "filename": "gcc/fortran/dependency.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -43,3 +43,4 @@ int gfc_expr_is_one (gfc_expr *, int);\n \n int gfc_dep_resolver(gfc_ref *, gfc_ref *);\n int gfc_are_equivalenced_arrays (gfc_expr *, gfc_expr *);\n+"}, {"sha": "940455dd054f60c4ec5f3291e66a08c608a65944", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -598,6 +598,8 @@ show_attr (symbol_attribute *attr)\n     fputs (\" CODIMENSION\", dumpfile);\n   if (attr->dimension)\n     fputs (\" DIMENSION\", dumpfile);\n+  if (attr->contiguous)\n+    fputs (\" CONTIGUOUS\", dumpfile);\n   if (attr->external)\n     fputs (\" EXTERNAL\", dumpfile);\n   if (attr->intrinsic)"}, {"sha": "c876fdd774028c4348f88c2c9d0b3e0042b8c4f1", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -4080,3 +4080,105 @@ gfc_has_ultimate_pointer (gfc_expr *e)\n   else\n     return false;\n }\n+\n+\n+/* Check whether an expression is \"simply contiguous\", cf. F2008, 6.5.4.\n+   Note: A scalar is not regarded as \"simply contiguous\" by the standard.\n+   if bool is not strict, some futher checks are done - for instance,\n+   a \"(::1)\" is accepted.  */\n+\n+bool\n+gfc_is_simply_contiguous (gfc_expr *expr, bool strict)\n+{\n+  bool colon;\n+  int i;\n+  gfc_array_ref *ar = NULL;\n+  gfc_ref *ref, *part_ref = NULL;\n+\n+  if (expr->expr_type == EXPR_FUNCTION)\n+    return expr->value.function.esym\n+\t   ? expr->value.function.esym->result->attr.contiguous : false;\n+  else if (expr->expr_type != EXPR_VARIABLE)\n+    return false;\n+\n+  if (expr->rank == 0)\n+    return false;\n+\n+  for (ref = expr->ref; ref; ref = ref->next)\n+    {\n+      if (ar)\n+\treturn false; /* Array shall be last part-ref. */\n+\n+      if (ref->type == REF_COMPONENT)\n+\tpart_ref  = ref;\n+      else if (ref->type == REF_SUBSTRING)\n+\treturn false;\n+      else if (ref->u.ar.type != AR_ELEMENT)\n+\tar = &ref->u.ar;\n+    }\n+\n+  if ((part_ref && !part_ref->u.c.component->attr.contiguous\n+       && part_ref->u.c.component->attr.pointer)\n+      || (!part_ref && !expr->symtree->n.sym->attr.contiguous\n+\t  && (expr->symtree->n.sym->attr.pointer\n+\t      || expr->symtree->n.sym->as->type == AS_ASSUMED_SHAPE)))\n+    return false;\n+\n+  if (!ar || ar->type == AR_FULL)\n+    return true;\n+\n+  gcc_assert (ar->type == AR_SECTION);\n+\n+  /* Check for simply contiguous array */\n+  colon = true;\n+  for (i = 0; i < ar->dimen; i++)\n+    {\n+      if (ar->dimen_type[i] == DIMEN_VECTOR)\n+\treturn false;\n+\n+      if (ar->dimen_type[i] == DIMEN_ELEMENT)\n+\t{\n+\t  colon = false;\n+\t  continue;\n+\t}\n+\n+      gcc_assert (ar->dimen_type[i] == DIMEN_RANGE);\n+\n+\n+      /* If the previous section was not contiguous, that's an error,\n+\t unless we have effective only one element and checking is not\n+\t strict.  */\n+      if (!colon && (strict || !ar->start[i] || !ar->end[i]\n+\t\t     || ar->start[i]->expr_type != EXPR_CONSTANT\n+\t\t     || ar->end[i]->expr_type != EXPR_CONSTANT\n+\t\t     || mpz_cmp (ar->start[i]->value.integer,\n+\t\t\t\t ar->end[i]->value.integer) != 0))\n+\treturn false;\n+\n+      /* Following the standard, \"(::1)\" or - if known at compile time -\n+\t \"(lbound:ubound)\" are not simply contigous; if strict\n+\t is false, they are regarded as simply contiguous.  */\n+      if (ar->stride[i] && (strict || ar->stride[i]->expr_type != EXPR_CONSTANT\n+\t\t\t    || ar->stride[i]->ts.type != BT_INTEGER\n+\t\t\t    || mpz_cmp_si (ar->stride[i]->value.integer, 1) != 0))\n+\treturn false;\n+\n+      if (ar->start[i]\n+\t  && (strict || ar->start[i]->expr_type != EXPR_CONSTANT\n+\t      || !ar->as->lower[i]\n+\t      || ar->as->lower[i]->expr_type != EXPR_CONSTANT\n+\t      || mpz_cmp (ar->start[i]->value.integer,\n+\t\t\t  ar->as->lower[i]->value.integer) != 0))\n+\tcolon = false;\n+\n+      if (ar->end[i]\n+\t  && (strict || ar->end[i]->expr_type != EXPR_CONSTANT\n+\t      || !ar->as->upper[i]\n+\t      || ar->as->upper[i]->expr_type != EXPR_CONSTANT\n+\t      || mpz_cmp (ar->end[i]->value.integer,\n+\t\t\t  ar->as->upper[i]->value.integer) != 0))\n+\tcolon = false;\n+    }\n+  \n+  return true;\n+}"}, {"sha": "4a9b5f0226bd516518b4c24e6a56fd50928f52a4", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -665,7 +665,8 @@ typedef struct\n   unsigned allocatable:1, dimension:1, codimension:1, external:1, intrinsic:1,\n     optional:1, pointer:1, target:1, value:1, volatile_:1, temporary:1,\n     dummy:1, result:1, assign:1, threadprivate:1, not_always_present:1,\n-    implied_index:1, subref_array_pointer:1, proc_pointer:1, asynchronous:1;\n+    implied_index:1, subref_array_pointer:1, proc_pointer:1, asynchronous:1,\n+    contiguous:1;\n \n   /* For CLASS containers, the pointer attribute is sometimes set internally\n      even though it was not directly specified.  In this case, keep the\n@@ -2437,6 +2438,7 @@ gfc_try gfc_add_attribute (symbol_attribute *, locus *);\n gfc_try gfc_add_ext_attribute (symbol_attribute *, ext_attr_id_t, locus *);\n gfc_try gfc_add_allocatable (symbol_attribute *, locus *);\n gfc_try gfc_add_codimension (symbol_attribute *, const char *, locus *);\n+gfc_try gfc_add_contiguous (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_dimension (symbol_attribute *, const char *, locus *);\n gfc_try gfc_add_external (symbol_attribute *, locus *);\n gfc_try gfc_add_intrinsic (symbol_attribute *, locus *);\n@@ -2614,6 +2616,7 @@ void gfc_free_actual_arglist (gfc_actual_arglist *);\n gfc_actual_arglist *gfc_copy_actual_arglist (gfc_actual_arglist *);\n const char *gfc_extract_int (gfc_expr *, int *);\n bool is_subref_array (gfc_expr *);\n+bool gfc_is_simply_contiguous (gfc_expr *, bool);\n \n gfc_expr *gfc_build_conversion (gfc_expr *);\n void gfc_free_ref_list (gfc_ref *);"}, {"sha": "ee164fc6d1a2d31da08a1c4fe3f7482109981d4a", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -1435,6 +1435,16 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       return 1;\n     }\n \n+  /* F2008, C1241.  */\n+  if (formal->attr.pointer && formal->attr.contiguous\n+      && !gfc_is_simply_contiguous (actual, true))\n+    {\n+      if (where)\n+\tgfc_error (\"Actual argument to contiguous pointer dummy '%s' at %L \"\n+\t\t   \"must be simply contigous\", formal->name, &actual->where);\n+      return 0;\n+    }\n+\n   if ((actual->expr_type != EXPR_NULL || actual->ts.type != BT_UNKNOWN)\n       && !gfc_compare_types (&formal->ts, &actual->ts))\n     {\n@@ -1502,6 +1512,34 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t\t: actual->symtree->n.sym->as->corank);\n \t  return 0;\n \t}\n+\n+      /* F2008, 12.5.2.8.  */\n+      if (formal->attr.dimension\n+\t  && (formal->attr.contiguous || formal->as->type != AS_ASSUMED_SHAPE)\n+\t  && !gfc_is_simply_contiguous (actual, true))\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Actual argument to '%s' at %L must be simply \"\n+\t\t       \"contiguous\", formal->name, &actual->where);\n+\t  return 0;\n+\t}\n+    }\n+\n+  /* F2008, C1239/C1240.  */\n+  if (actual->expr_type == EXPR_VARIABLE\n+      && (actual->symtree->n.sym->attr.asynchronous\n+         || actual->symtree->n.sym->attr.volatile_)\n+      &&  (formal->attr.asynchronous || formal->attr.volatile_)\n+      && actual->rank && !gfc_is_simply_contiguous (actual, true)\n+      && ((formal->as->type != AS_ASSUMED_SHAPE && !formal->attr.pointer)\n+\t  || formal->attr.contiguous))\n+    {\n+      if (where)\n+\tgfc_error (\"Dummy argument '%s' has to be a pointer or assumed-shape \"\n+\t\t   \"array without CONTIGUOUS attribute - as actual argument at\"\n+\t\t   \" %L is not simply contiguous and both are ASYNCHRONOUS \"\n+\t\t   \"or VOLATILE\", formal->name, &actual->where);\n+      return 0;\n     }\n \n   if (symbol_rank (formal) == actual->rank)"}, {"sha": "501049e1220a47ddd207f78509f8628439651f08", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -168,6 +168,7 @@ void gfc_set_constant_character_len (int, gfc_expr *, int);\n match gfc_match_allocatable (void);\n match gfc_match_asynchronous (void);\n match gfc_match_codimension (void);\n+match gfc_match_contiguous (void);\n match gfc_match_dimension (void);\n match gfc_match_external (void);\n match gfc_match_gcc_attributes (void);"}, {"sha": "b42a9e8c1d11aff4885ec7be43ab46e661ad7c78", "filename": "gcc/fortran/module.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -1675,7 +1675,7 @@ typedef enum\n   AB_POINTER_COMP, AB_PRIVATE_COMP, AB_VALUE, AB_VOLATILE, AB_PROTECTED,\n   AB_IS_BIND_C, AB_IS_C_INTEROP, AB_IS_ISO_C, AB_ABSTRACT, AB_ZERO_COMP,\n   AB_IS_CLASS, AB_PROCEDURE, AB_PROC_POINTER, AB_ASYNCHRONOUS, AB_CODIMENSION,\n-  AB_COARRAY_COMP, AB_VTYPE, AB_VTAB\n+  AB_COARRAY_COMP, AB_VTYPE, AB_VTAB, AB_CONTIGUOUS\n }\n ab_attribute;\n \n@@ -1685,6 +1685,7 @@ static const mstring attr_bits[] =\n     minit (\"ASYNCHRONOUS\", AB_ASYNCHRONOUS),\n     minit (\"DIMENSION\", AB_DIMENSION),\n     minit (\"CODIMENSION\", AB_CODIMENSION),\n+    minit (\"CONTIGUOUS\", AB_CONTIGUOUS),\n     minit (\"EXTERNAL\", AB_EXTERNAL),\n     minit (\"INTRINSIC\", AB_INTRINSIC),\n     minit (\"OPTIONAL\", AB_OPTIONAL),\n@@ -1807,6 +1808,8 @@ mio_symbol_attribute (symbol_attribute *attr)\n \tMIO_NAME (ab_attribute) (AB_DIMENSION, attr_bits);\n       if (attr->codimension)\n \tMIO_NAME (ab_attribute) (AB_CODIMENSION, attr_bits);\n+      if (attr->contiguous)\n+\tMIO_NAME (ab_attribute) (AB_CONTIGUOUS, attr_bits);\n       if (attr->external)\n \tMIO_NAME (ab_attribute) (AB_EXTERNAL, attr_bits);\n       if (attr->intrinsic)\n@@ -1915,6 +1918,9 @@ mio_symbol_attribute (symbol_attribute *attr)\n \t    case AB_CODIMENSION:\n \t      attr->codimension = 1;\n \t      break;\n+\t    case AB_CONTIGUOUS:\n+\t      attr->contiguous = 1;\n+\t      break;\n \t    case AB_EXTERNAL:\n \t      attr->external = 1;\n \t      break;"}, {"sha": "26ea73a627c03fb12aa4bad5f61db41cda5d03c2", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -139,6 +139,7 @@ decode_specification_statement (void)\n \n     case 'c':\n       match (\"codimension\", gfc_match_codimension, ST_ATTR_DECL);\n+      match (\"contiguous\", gfc_match_contiguous, ST_ATTR_DECL);\n       break;\n \n     case 'd':\n@@ -346,6 +347,7 @@ decode_statement (void)\n       match (\"call\", gfc_match_call, ST_CALL);\n       match (\"close\", gfc_match_close, ST_CLOSE);\n       match (\"continue\", gfc_match_continue, ST_CONTINUE);\n+      match (\"contiguous\", gfc_match_contiguous, ST_ATTR_DECL);\n       match (\"cycle\", gfc_match_cycle, ST_CYCLE);\n       match (\"case\", gfc_match_case, ST_CASE);\n       match (\"common\", gfc_match_common, ST_COMMON);"}, {"sha": "20def447767a29f73f7ff50fe04898430de8b0ae", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -10826,6 +10826,14 @@ resolve_fl_derived (gfc_symbol *sym)\n \t  return FAILURE;\n \t}\n \n+      /* F2008, C448.  */\n+      if (c->attr.contiguous && (!c->attr.dimension || !c->attr.pointer))\n+\t{\n+\t  gfc_error (\"Component '%s' at %L has the CONTIGUOUS attribute but \"\n+\t\t     \"is not an array pointer\", c->name, &c->loc);\n+\t  return FAILURE;\n+\t}\n+\n       if (c->attr.proc_pointer && c->ts.interface)\n \t{\n \t  if (c->ts.interface->attr.procedure && !sym->attr.vtype)\n@@ -11397,6 +11405,7 @@ resolve_symbol (gfc_symbol *sym)\n \t  sym->attr.pure = ifc->attr.pure;\n \t  sym->attr.elemental = ifc->attr.elemental;\n \t  sym->attr.dimension = ifc->attr.dimension;\n+\t  sym->attr.contiguous = ifc->attr.contiguous;\n \t  sym->attr.recursive = ifc->attr.recursive;\n \t  sym->attr.always_explicit = ifc->attr.always_explicit;\n           sym->attr.ext_attr |= ifc->attr.ext_attr;\n@@ -11442,6 +11451,18 @@ resolve_symbol (gfc_symbol *sym)\n       return;\n     }\n \n+\n+  /* F2008, C530. */\n+  if (sym->attr.contiguous\n+      && (!sym->attr.dimension || (sym->as->type != AS_ASSUMED_SHAPE\n+\t\t\t\t   && !sym->attr.pointer)))\n+    {\n+      gfc_error (\"'%s' at %L has the CONTIGUOUS attribute but is not an \"\n+\t\t  \"array pointer or an assumed-shape array\", sym->name,\n+\t\t  &sym->declared_at);\n+      return;\n+    }\n+\n   if (sym->attr.flavor == FL_DERIVED && resolve_fl_derived (sym) == FAILURE)\n     return;\n \n@@ -11500,6 +11521,7 @@ resolve_symbol (gfc_symbol *sym)\n \t\t  sym->attr.dimension = sym->result->attr.dimension;\n \t\t  sym->attr.pointer = sym->result->attr.pointer;\n \t\t  sym->attr.allocatable = sym->result->attr.allocatable;\n+\t\t  sym->attr.contiguous = sym->result->attr.contiguous;\n \t\t}\n \t    }\n \t}"}, {"sha": "df6ada963c3fe100c54c40a85bf5fbdc724ed10f", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -372,7 +372,8 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n     *cray_pointee = \"CRAY POINTEE\", *data = \"DATA\", *value = \"VALUE\",\n     *volatile_ = \"VOLATILE\", *is_protected = \"PROTECTED\",\n     *is_bind_c = \"BIND(C)\", *procedure = \"PROCEDURE\",\n-    *asynchronous = \"ASYNCHRONOUS\", *codimension = \"CODIMENSION\";\n+    *asynchronous = \"ASYNCHRONOUS\", *codimension = \"CODIMENSION\",\n+    *contiguous = \"CONTIGUOUS\";\n   static const char *threadprivate = \"THREADPRIVATE\";\n \n   const char *a1, *a2;\n@@ -518,6 +519,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (cray_pointer, cray_pointee);\n   conf (cray_pointer, dimension);\n   conf (cray_pointer, codimension);\n+  conf (cray_pointer, contiguous);\n   conf (cray_pointer, pointer);\n   conf (cray_pointer, target);\n   conf (cray_pointer, allocatable);\n@@ -529,6 +531,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n   conf (cray_pointer, entry);\n \n   conf (cray_pointee, allocatable);\n+  conf (cray_pointer, contiguous);\n   conf (cray_pointer, codimension);\n   conf (cray_pointee, intent);\n   conf (cray_pointee, optional);\n@@ -613,6 +616,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       conf2 (dummy);\n       conf2 (volatile_);\n       conf2 (asynchronous);\n+      conf2 (contiguous);\n       conf2 (pointer);\n       conf2 (is_protected);\n       conf2 (target);\n@@ -720,6 +724,7 @@ check_conflict (symbol_attribute *attr, const char *name, locus *where)\n       conf2 (function);\n       conf2 (subroutine);\n       conf2 (entry);\n+      conf2 (contiguous);\n       conf2 (pointer);\n       conf2 (is_protected);\n       conf2 (target);\n@@ -927,6 +932,18 @@ gfc_add_dimension (symbol_attribute *attr, const char *name, locus *where)\n }\n \n \n+gfc_try\n+gfc_add_contiguous (symbol_attribute *attr, const char *name, locus *where)\n+{\n+\n+  if (check_used (attr, name, where))\n+    return FAILURE;\n+\n+  attr->contiguous = 1;\n+  return check_conflict (attr, name, where);\n+}\n+\n+\n gfc_try\n gfc_add_external (symbol_attribute *attr, locus *where)\n {\n@@ -1715,6 +1732,8 @@ gfc_copy_attr (symbol_attribute *dest, symbol_attribute *src, locus *where)\n     goto fail;\n   if (src->codimension && gfc_add_codimension (dest, NULL, where) == FAILURE)\n     goto fail;\n+  if (src->contiguous && gfc_add_contiguous (dest, NULL, where) == FAILURE)\n+    goto fail;\n   if (src->optional && gfc_add_optional (dest, where) == FAILURE)\n     goto fail;\n   if (src->pointer && gfc_add_pointer (dest, where) == FAILURE)"}, {"sha": "7eb8e755785ac9daccea5efd86b1c0fde52da121", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 42, "deletions": 5, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -285,7 +285,9 @@ gfc_conv_descriptor_stride_get (tree desc, tree dim)\n   tree type = TREE_TYPE (desc);\n   gcc_assert (GFC_DESCRIPTOR_TYPE_P (type));\n   if (integer_zerop (dim)\n-      && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n+      && (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE\n+\t  ||GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_SHAPE_CONT\n+\t  ||GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER_CONT))\n     return gfc_index_one_node;\n \n   return gfc_conv_descriptor_stride (desc, dim);\n@@ -5522,6 +5524,7 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n \n   ultimate_ptr_comp = false;\n   ultimate_alloc_comp = false;\n+\n   for (ref = expr->ref; ref; ref = ref->next)\n     {\n       if (ref->next == NULL)\n@@ -5608,15 +5611,18 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n   contiguous = g77 && !this_array_result && contiguous;\n \n   /* There is no need to pack and unpack the array, if it is contiguous\n-     and not deferred or assumed shape.  */\n+     and not a deferred- or assumed-shape array, or if it is simply\n+     contiguous.  */\n   no_pack = ((sym && sym->as\n \t\t  && !sym->attr.pointer\n \t\t  && sym->as->type != AS_DEFERRED\n \t\t  && sym->as->type != AS_ASSUMED_SHAPE)\n \t\t      ||\n \t     (ref && ref->u.ar.as\n \t\t  && ref->u.ar.as->type != AS_DEFERRED\n-\t\t  && ref->u.ar.as->type != AS_ASSUMED_SHAPE));\n+\t\t  && ref->u.ar.as->type != AS_ASSUMED_SHAPE)\n+\t\t      ||\n+\t     gfc_is_simply_contiguous (expr, false));\n \n   no_pack = contiguous && no_pack;\n \n@@ -5680,9 +5686,24 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n       gfc_add_expr_to_block (&se->post, tmp);\n     }\n \n-  if (g77)\n+  if (g77 || (fsym && fsym->attr.contiguous\n+\t      && !gfc_is_simply_contiguous (expr, false)))\n     {\n+      tree origptr = NULL_TREE;\n+\n       desc = se->expr;\n+\n+      /* For contiguous arrays, save the original value of the descriptor.  */\n+      if (!g77)\n+\t{\n+\t  origptr = gfc_create_var (pvoid_type_node, \"origptr\");\n+\t  tmp = build_fold_indirect_ref_loc (input_location, desc);\n+\t  tmp = gfc_conv_array_data (tmp);\n+\t  tmp = fold_build2 (MODIFY_EXPR, TREE_TYPE (origptr), origptr,\n+\t\t\t     fold_convert (TREE_TYPE (origptr), tmp));\n+\t  gfc_add_expr_to_block (&se->pre, tmp);\n+\t}\n+\n       /* Repack the array.  */\n       if (gfc_option.warn_array_temp)\n \t{\n@@ -5706,7 +5727,15 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n \n       ptr = gfc_evaluate_now (ptr, &se->pre);\n \n-      se->expr = ptr;\n+      /* Use the packed data for the actual argument, except for contiguous arrays,\n+\t where the descriptor's data component is set.  */\n+      if (g77)\n+\tse->expr = ptr;\n+      else\n+\t{\n+\t  tmp = build_fold_indirect_ref_loc (input_location, desc);\n+\t  gfc_conv_descriptor_data_set (&se->pre, tmp, ptr);\n+\t}\n \n       if (gfc_option.rtcheck & GFC_RTCHECK_ARRAY_TEMPS)\n \t{\n@@ -5768,6 +5797,14 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, bool g77,\n       gfc_add_block_to_block (&block, &se->post);\n \n       gfc_init_block (&se->post);\n+\n+      /* Reset the descriptor pointer.  */\n+      if (!g77)\n+        {\n+          tmp = build_fold_indirect_ref_loc (input_location, desc);\n+          gfc_conv_descriptor_data_set (&se->post, tmp, origptr);\n+        }\n+\n       gfc_add_block_to_block (&se->post, &block);\n     }\n }"}, {"sha": "d75a195924c874ac38b4531389f7f71b8d4992cd", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -1213,7 +1213,8 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n       /* Create variables to hold the non-constant bits of array info.  */\n       gfc_build_qualified_array (decl, sym);\n \n-      if ((sym->attr.allocatable || !sym->attr.dummy) && !sym->attr.pointer)\n+      if (sym->attr.contiguous\n+\t  || ((sym->attr.allocatable || !sym->attr.dummy) && !sym->attr.pointer))\n \tGFC_DECL_PACKED_ARRAY (decl) = 1;\n     }\n "}, {"sha": "0164c1635826abb3b6d2f4e4ef16efd2a46cd23c", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -1718,6 +1718,7 @@ gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n   new_sym->as = gfc_copy_array_spec (sym->as);\n   new_sym->attr.referenced = 1;\n   new_sym->attr.dimension = sym->attr.dimension;\n+  new_sym->attr.contiguous = sym->attr.contiguous;\n   new_sym->attr.codimension = sym->attr.codimension;\n   new_sym->attr.pointer = sym->attr.pointer;\n   new_sym->attr.allocatable = sym->attr.allocatable;"}, {"sha": "2f5b759886dd110d2c6755d62f82e77b8f86c313", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 18, "deletions": 9, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -1202,7 +1202,8 @@ gfc_is_nodesc_array (gfc_symbol * sym)\n \n static tree\n gfc_build_array_type (tree type, gfc_array_spec * as,\n-\t\t      enum gfc_array_kind akind, bool restricted)\n+\t\t      enum gfc_array_kind akind, bool restricted,\n+\t\t      bool contiguous)\n {\n   tree lbound[GFC_MAX_DIMENSIONS];\n   tree ubound[GFC_MAX_DIMENSIONS];\n@@ -1219,7 +1220,8 @@ gfc_build_array_type (tree type, gfc_array_spec * as,\n     }\n \n   if (as->type == AS_ASSUMED_SHAPE)\n-    akind = GFC_ARRAY_ASSUMED_SHAPE;\n+    akind = contiguous ? GFC_ARRAY_ASSUMED_SHAPE_CONT\n+\t\t       : GFC_ARRAY_ASSUMED_SHAPE;\n   return gfc_get_array_type_bounds (type, as->rank, as->corank, lbound,\n \t\t\t\t    ubound, 0, akind, restricted);\n }\n@@ -1799,10 +1801,12 @@ gfc_sym_type (gfc_symbol * sym)\n \t{\n \t  enum gfc_array_kind akind = GFC_ARRAY_UNKNOWN;\n \t  if (sym->attr.pointer)\n-\t    akind = GFC_ARRAY_POINTER;\n+\t    akind = sym->attr.contiguous ? GFC_ARRAY_POINTER_CONT\n+\t\t\t\t\t : GFC_ARRAY_POINTER;\n \t  else if (sym->attr.allocatable)\n \t    akind = GFC_ARRAY_ALLOCATABLE;\n-\t  type = gfc_build_array_type (type, sym->as, akind, restricted);\n+\t  type = gfc_build_array_type (type, sym->as, akind, restricted,\n+\t\t\t\t       sym->attr.contiguous);\n \t}\n     }\n   else\n@@ -2121,14 +2125,16 @@ gfc_get_derived_type (gfc_symbol * derived)\n \t    {\n \t      enum gfc_array_kind akind;\n \t      if (c->attr.pointer)\n-\t\takind = GFC_ARRAY_POINTER;\n+\t\takind = c->attr.contiguous ? GFC_ARRAY_POINTER_CONT\n+\t\t\t\t\t   : GFC_ARRAY_POINTER;\n \t      else\n \t\takind = GFC_ARRAY_ALLOCATABLE;\n \t      /* Pointers to arrays aren't actually pointer types.  The\n \t         descriptors are separate, but the data is common.  */\n \t      field_type = gfc_build_array_type (field_type, c->as, akind,\n \t\t\t\t\t\t !c->attr.target\n-\t\t\t\t\t\t && !c->attr.pointer);\n+\t\t\t\t\t\t && !c->attr.pointer,\n+\t\t\t\t\t\t c->attr.contiguous);\n \t    }\n \t  else\n \t    field_type = gfc_get_nodesc_array_type (field_type, c->as,\n@@ -2516,7 +2522,8 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   if (int_size_in_bytes (etype) <= 0)\n     return false;\n   /* Nor non-constant lower bounds in assumed shape arrays.  */\n-  if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_SHAPE)\n+  if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_SHAPE\n+      || GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_SHAPE_CONT)\n     {\n       for (dim = 0; dim < rank; dim++)\n \tif (GFC_TYPE_ARRAY_LBOUND (type, dim) == NULL_TREE\n@@ -2565,7 +2572,8 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)\n     info->allocated = build2 (NE_EXPR, boolean_type_node,\n \t\t\t      info->data_location, null_pointer_node);\n-  else if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER)\n+  else if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER\n+\t   || GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_POINTER_CONT)\n     info->associated = build2 (NE_EXPR, boolean_type_node,\n \t\t\t       info->data_location, null_pointer_node);\n \n@@ -2579,7 +2587,8 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n \t\t  size_binop (PLUS_EXPR, dim_off, upper_suboff));\n       t = build1 (INDIRECT_REF, gfc_array_index_type, t);\n       info->dimen[dim].upper_bound = t;\n-      if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_SHAPE)\n+      if (GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_SHAPE\n+\t  || GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ASSUMED_SHAPE_CONT)\n \t{\n \t  /* Assumed shape arrays have known lower bounds.  */\n \t  info->dimen[dim].upper_bound"}, {"sha": "02361fc8466b75159bdabaef328949b3ec89a936", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -620,14 +620,17 @@ extern GTY(()) tree gfor_fndecl_sr_kind;\n /* True if node is an integer constant.  */\n #define INTEGER_CST_P(node) (TREE_CODE(node) == INTEGER_CST)\n \n-/* G95-specific declaration information.  */\n+/* gfortran-specific declaration information, the _CONT versions denote\n+   arrays with CONTIGUOUS attribute.  */\n \n enum gfc_array_kind\n {\n   GFC_ARRAY_UNKNOWN,\n   GFC_ARRAY_ASSUMED_SHAPE,\n+  GFC_ARRAY_ASSUMED_SHAPE_CONT,\n   GFC_ARRAY_ALLOCATABLE,\n-  GFC_ARRAY_POINTER\n+  GFC_ARRAY_POINTER,\n+  GFC_ARRAY_POINTER_CONT\n };\n \n /* Array types only.  */"}, {"sha": "5ac708a2d3c58b3c3121c90e0813a0f08d1f14b9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -1,3 +1,10 @@\n+2010-06-21  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/40632\n+\t* gfortran.dg/contiguous_1.f90: New.\n+\t* gfortran.dg/contiguous_2.f90: New.\n+\t* gfortran.dg/contiguous_3.f90: New.\n+\n 2010-06-21  Kai Tietz  <kai.tietz@onevision.com>\n \n \t* gcc.target/x86_64/abi/callabi/leaf-1.c: New."}, {"sha": "e75c08d8ef4e2a1b4e2bf4ba45604db4f4c1e04e", "filename": "gcc/testsuite/gfortran.dg/contiguous_1.f90", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_1.f90?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -0,0 +1,177 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! PR fortran/40632\n+!\n+! CONTIGUOUS compile-time tests\n+!\n+\n+! C448: Must be an array with POINTER attribute\n+type t1\n+  integer, contiguous :: ca(5) ! { dg-error \"Component .ca. at .1. has the CONTIGUOUS\" }\n+end type t1\n+type t2\n+  integer, contiguous, allocatable :: cb(:) ! { dg-error \"Component .cb. at .1. has the CONTIGUOUS\" }\n+end type t2\n+type t3\n+  integer, contiguous, pointer :: cc(:) ! OK\n+end type t3\n+type t4\n+  integer, pointer, contiguous :: cd ! { dg-error \"Component .cd. at .1. has the CONTIGUOUS\" }\n+end type t4\n+end\n+\n+! C530: Must be an array and (a) a POINTER or (b) assumed shape.\n+subroutine test(x, y)\n+  integer, pointer :: x(:)\n+  integer, intent(in) :: y(:)\n+  contiguous :: x, y\n+\n+  integer, contiguous :: a(5) ! { dg-error \".a. at .1. has the CONTIGUOUS attribute\" }\n+  integer, contiguous, allocatable :: b(:) ! { dg-error \".b. at .1. has the CONTIGUOUS attribute\" }\n+  integer, contiguous, pointer :: c(:) ! OK\n+  integer, pointer, contiguous :: d ! { dg-error \".d. at .1. has the CONTIGUOUS attribute\" }\n+end\n+\n+! Pointer assignment check:\n+! If the pointer object has the CONTIGUOUS attribute, the pointer target shall be contiguous.\n+! Note: This is not compile-time checkable; but F2008, 5.3.7 except in a very few cases.\n+subroutine ptr_assign()\n+  integer, pointer, contiguous :: ptr1(:)\n+  integer, target :: tgt(5)\n+  ptr1 => tgt\n+end subroutine\n+\n+\n+! C1239 (R1223) If an actual argument is a nonpointer array that has the ASYNCHRONOUS or VOLATILE\n+! attribute but is not simply contiguous (6.5.4), and the corresponding dummy argument has either the\n+! VOLATILE or ASYNCHRONOUS attribute, that dummy argument shall be an assumed-shape array\n+! that does not have the CONTIGUOUS attribute.\n+\n+subroutine C1239\n+  type t\n+    integer :: e(4)\n+  end type t\n+  type(t), volatile :: f\n+  integer, asynchronous :: a(4), b(4)\n+  integer, volatile :: c(4), d(4)\n+  call test (a,b,c)      ! OK\n+  call test (a,b(::2),c) ! { dg-error \"array without CONTIGUOUS\" }\n+  call test (a(::2),b,c) ! { dg-error \"array without CONTIGUOUS\" }\n+\n+  call test (a,b,f%e)      ! OK\n+  call test (a,f%e,c)      ! OK\n+  call test (f%e,b,c)      ! OK\n+  call test (a,b,f%e(::2)) ! OK\n+  call test (a,f%e(::2),c) ! { dg-error \"array without CONTIGUOUS\" }\n+  call test (f%e(::2),b,c) ! { dg-error \"array without CONTIGUOUS\" }\n+contains\n+  subroutine test(u, v, w)\n+    integer, asynchronous :: u(:), v(*)\n+    integer, volatile :: w(:)\n+    contiguous :: u\n+  end subroutine test\n+end subroutine C1239\n+\n+\n+! C1240 (R1223) If an actual argument is an array pointer that has the ASYNCHRONOUS or VOLATILE\n+! attribute but does not have the CONTIGUOUS attribute, and the corresponding dummy argument has\n+! either the VOLATILE or ASYNCHRONOUS attribute, that dummy argument shall be an array pointer\n+! or an assumed-shape array that does not have the CONTIGUOUS attribute.\n+\n+subroutine C1240\n+  type t\n+    integer,pointer :: e(:)\n+  end type t\n+  type(t), volatile :: f\n+  integer, pointer, asynchronous :: a(:), b(:)\n+  integer,pointer, volatile :: c(:), d(:)\n+  call test (a,b,c)      ! { dg-error \"array without CONTIGUOUS\" }\n+  call test (a,b(::2),c) ! { dg-error \"array without CONTIGUOUS\" }\n+  call test (a(::2),b,c) ! { dg-error \"array without CONTIGUOUS\" }\n+\n+  call test (a,b,f%e)      ! { dg-error \"array without CONTIGUOUS\" }\n+  call test (a,f%e,c)      ! { dg-error \"array without CONTIGUOUS\" }\n+  call test (f%e,b,c)      ! { dg-error \"array without CONTIGUOUS\" }\n+  call test (a,b,f%e(::2)) ! { dg-error \"array without CONTIGUOUS\" }\n+  call test (a,f%e(::2),c) ! { dg-error \"array without CONTIGUOUS\" }\n+  call test (f%e(::2),b,c) ! { dg-error \"array without CONTIGUOUS\" }\n+\n+  call test2(a,b)\n+  call test3(a,b)\n+  call test2(c,d)\n+  call test3(c,d)\n+  call test2(f%e,d)\n+  call test3(c,f%e)\n+contains\n+  subroutine test(u, v, w)\n+    integer, asynchronous :: u(:), v(*)\n+    integer, volatile :: w(:)\n+    contiguous :: u\n+  end subroutine test\n+  subroutine test2(x,y)\n+    integer, asynchronous :: x(:)\n+    integer, volatile :: y(:)\n+  end subroutine test2 \n+  subroutine test3(x,y)\n+    integer, pointer, asynchronous :: x(:)\n+    integer, pointer, volatile :: y(:)\n+  end subroutine test3\n+end subroutine C1240\n+\n+\n+\n+! 12.5.2.7 Pointer dummy variables\n+! C1241 The actual argument corresponding to a dummy pointer with the CONTIGUOUS attribute shall be\n+! simply contiguous (6.5.4).\n+\n+subroutine C1241\n+  integer, pointer, contiguous :: a(:)\n+  integer, pointer :: b(:)\n+  call test(a)\n+  call test(b) ! { dg-error \"must be simply contigous\" }\n+contains\n+  subroutine test(x)\n+    integer, pointer, contiguous :: x(:)\n+  end subroutine test\n+end subroutine C1241\n+\n+\n+! 12.5.2.8 Coarray dummy variables\n+! If the dummy argument is an array coarray that has the CONTIGUOUS attribute or is not of assumed shape,\n+! the corresponding actual argument shall be simply contiguous\n+\n+subroutine sect12528(cob)\n+  integer, save :: coa(6)[*]\n+  integer :: cob(:)[*]\n+\n+  call test(coa)\n+  call test2(coa)\n+  call test3(coa)\n+\n+  call test(cob) ! { dg-error \"must be simply contiguous\" }\n+  call test2(cob) ! { dg-error \"must be simply contiguous\" }\n+  call test3(cob)\n+contains\n+  subroutine test(x)\n+    integer, contiguous :: x(:)[*]\n+  end subroutine test\n+  subroutine test2(x)\n+    integer :: x(*)[*]\n+  end subroutine test2\n+  subroutine test3(x)\n+    integer :: x(:)[*]\n+  end subroutine test3\n+end subroutine sect12528\n+\n+\n+\n+subroutine test34\n+  implicit none\n+  integer, volatile,pointer :: a(:,:),i\n+  call foo(a(2,2:3:2)) ! { dg-error \"must be simply contigous\" }\n+contains\n+  subroutine foo(x)\n+    integer, pointer, contiguous, volatile :: x(:)\n+  end subroutine\n+end subroutine test34"}, {"sha": "782d23dc7cd7a696ec5ce5756015685f548cd3b0", "filename": "gcc/testsuite/gfortran.dg/contiguous_2.f90", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_2.f90?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -0,0 +1,12 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f2003\" }\n+!\n+! PR fortran/40632\n+!\n+! CONTIGUOUS compile-time tests\n+!\n+\n+integer, pointer, contiguous :: a(:) ! { dg-error \"Fortran 2008:\" }\n+integer, pointer :: b(:)\n+contiguous :: b ! { dg-error \"Fortran 2008:\" }\n+end"}, {"sha": "aac55367a45b22911e164b906d66d236e490754d", "filename": "gcc/testsuite/gfortran.dg/contiguous_3.f90", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe4e525c241f01ef04d2405172e337dfb1d63dda/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcontiguous_3.f90?ref=fe4e525c241f01ef04d2405172e337dfb1d63dda", "patch": "@@ -0,0 +1,65 @@\n+! { dg-do compile }\n+! { dg-options \"-fdump-tree-original\" }\n+!\n+! PR fortran/40632\n+!\n+! CONTIGUOUS compile-time tests: Check that contigous\n+! works properly.\n+\n+subroutine test1(a,b)\n+  integer, pointer, contiguous :: test1_a(:)\n+  call foo(test1_a)\n+  call foo(test1_a(::1))\n+  call foo(test1_a(::2))\n+contains\n+  subroutine foo(b)\n+    integer :: b(*)\n+  end subroutine foo\n+end subroutine test1\n+\n+! For the first two no pack is done; for the third one, an array descriptor\n+! (cf. below test3) is created for packing.\n+!\n+! { dg-final { scan-tree-dump-times \"_internal_pack.*test1_a\" 0 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_internal_unpack.*test1_a\" 0 \"original\" } }\n+\n+\n+subroutine t2(a1,b1,c2,d2)\n+  integer, pointer, contiguous :: a1(:), b1(:)\n+  integer, pointer :: c2(:), d2(:)\n+  a1 = b1\n+  c2 = d2\n+end subroutine t2\n+\n+! { dg-final { scan-tree-dump-times \"= a1->dim.0..stride;\" 0 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"= b1->dim.0..stride;\" 0 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"= c2->dim.0..stride;\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"= d2->dim.0..stride;\" 1 \"original\" } }\n+\n+\n+subroutine test3()\n+  implicit none\n+  integer :: test3_a(8),i\n+  test3_a = [(i,i=1,8)]\n+  call foo(test3_a(::1))\n+  call foo(test3_a(::2))\n+  call bar(test3_a(::1))\n+  call bar(test3_a(::2))\n+contains\n+  subroutine foo(x)\n+    integer, contiguous :: x(:)\n+    print *, x\n+  end subroutine\n+  subroutine bar(x)\n+    integer :: x(:)\n+    print *, x\n+  end subroutine bar\n+end subroutine test3\n+\n+! Once for test1 (third call), once for test3 (second call)\n+! { dg-final { scan-tree-dump-times \"data = origptr\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_internal_pack .&parm\" 2 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_internal_unpack .&parm\" 2 \"original\" } }\n+\n+\n+! { dg-final { cleanup-tree-dump \"original\" } }"}]}