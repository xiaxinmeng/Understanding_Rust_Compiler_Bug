{"sha": "008e7397dad971c03c08fc1b0a4a98fddccaaed8", "node_id": "C_kwDOANBUbNoAKDAwOGU3Mzk3ZGFkOTcxYzAzYzA4ZmMxYjBhNGE5OGZkZGNjYWFlZDg", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-10-11T16:43:26Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2021-10-11T16:43:26Z"}, "message": "Commonize ipa-pta constraint generation for calls\n\nCommonize the three paths to produce constraints for function call\nand makes it more flexible, so we can implement new features more easily.  Main\nidea is to not special case pure and const since we can now describe all of\npure/const via their EAF flags (implicit_const_eaf_flags and\nimplicit_pure_eaf_flags) and info on existence of global memory loads/stores in\nfunction which is readily available in the modref tree.\n\nWhile rewriting the function, I dropped some of optimizations in the way we\ngenerate constraints. Some of them we may want to add back, but I think the\nconstraint solver should be fast to get rid of them quickly, so it looks like\nbit of premature optimization.\n\nWe now always produce one additional PTA variable (callescape) for things that\nescape into function call and thus can be stored to parameters or global memory\n(if modified). This is no longer the same as global escape in case function is\nnot reading global memory. It is also not same as call use, since we now\nunderstand the fact that interposable functions may use parameter in a way that\nis not releavnt for PTA (so we can not optimize out stores initializing the\nmemory, but we can be safe about fact that pointers stored does not escape).\n\nCompared to previous code we now handle correctly EAF_NOT_RETURNED in all cases\n(previously we did so only when all parameters had the flag) and also handle\nNOCLOBBER in more cases (since we make difference between global escape and\ncall escape). Because I commonized code handling args and static chains, we\ncould now easily extend modref to also track flags for static chain and return\nslot which I plan to do next.\n\nOtherwise I put some effort into producing constraints that produce similar\nsolutions as before (so it is harder to debug differences). For example if\nglobal memory is written one can simply move callescape to escape rather then\nmaking everything escape by its own constraints, but it affects ipa-pta\ntestcases.\n\ngcc/ChangeLog:\n\n\t* ipa-modref-tree.h (modref_tree::global_access_p): New member\n\tfunction.\n\t* ipa-modref.c:\n\t(implicint_const_eaf_flags,implicit_pure_eaf_flags,\n\tignore_stores_eaf_flags): Move to ipa-modref.h\n\t(remove_useless_eaf_flags): Remove early exit on NOCLOBBER.\n\t(modref_summary::global_memory_read_p): New member function.\n\t(modref_summary::global_memory_written_p): New member function.\n\t* ipa-modref.h (modref_summary::global_memory_read_p,\n\tmodref_summary::global_memory_written_p): Declare.\n\t(implicint_const_eaf_flags,implicit_pure_eaf_flags,\n\tignore_stores_eaf_flags): move here.\n\t* tree-ssa-structalias.c: Include ipa-modref-tree.h, ipa-modref.h\n\tand attr-fnspec.h.\n\t(handle_rhs_call): Rewrite.\n\t(handle_call_arg): New function.\n\t(determine_global_memory_access): New function.\n\t(handle_const_call): Remove\n\t(handle_pure_call): Remove\n\t(find_func_aliases_for_call): Update use of handle_rhs_call.\n\t(compute_points_to_sets): Handle global memory acccesses\n\tselectively\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/torture/ssa-pta-fn-1.c: Fix template; add noipa.\n\t* gcc.dg/tree-ssa/pta-callused.c: Fix template.", "tree": {"sha": "4a2b3b53633c275c20b3acf81a716c79a2cd57db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a2b3b53633c275c20b3acf81a716c79a2cd57db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/008e7397dad971c03c08fc1b0a4a98fddccaaed8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/008e7397dad971c03c08fc1b0a4a98fddccaaed8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/008e7397dad971c03c08fc1b0a4a98fddccaaed8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/008e7397dad971c03c08fc1b0a4a98fddccaaed8/comments", "author": null, "committer": null, "parents": [{"sha": "0de8c2f8104b74f46e63d0d5d7b9e8fd3f04bb98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0de8c2f8104b74f46e63d0d5d7b9e8fd3f04bb98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0de8c2f8104b74f46e63d0d5d7b9e8fd3f04bb98"}], "stats": {"total": 612, "additions": 317, "deletions": 295}, "files": [{"sha": "52f225b1aaebfc873bb166eeff9c0eb5f197288d", "filename": "gcc/ipa-modref-tree.h", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Fipa-modref-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Fipa-modref-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref-tree.h?ref=008e7397dad971c03c08fc1b0a4a98fddccaaed8", "patch": "@@ -148,7 +148,8 @@ struct GTY(()) modref_access_node\n \t       poly_int64 offset1, poly_int64 size1, poly_int64 max_size1,\n \t       bool record_adjustments)\n     {\n-      if (known_eq (offset, offset1)\n+      if (known_eq (parm_offset, parm_offset1)\n+\t  && known_eq (offset, offset1)\n \t  && known_eq (size, size1)\n \t  && known_eq (max_size, max_size1))\n \treturn;\n@@ -577,6 +578,10 @@ struct GTY((user)) modref_ref_node\n \t  }\n \t(*accesses)[best1].forced_merge (best2 < 0 ? a : (*accesses)[best2],\n \t\t\t\t\t record_adjustments);\n+\t/* CHeck that merging indeed merged ranges.  */\n+\tgcc_checking_assert ((*accesses)[best1].contains (best2 < 0 ? a : (*accesses)[best2]));\n+\t/*if (best2 >= 0)\n+\t  accesses->unordered_remove (best2);*/\n \tif (!(*accesses)[best1].useful_p ())\n \t  {\n \t    collapse ();\n@@ -1012,6 +1017,31 @@ struct GTY((user)) modref_tree\n     return NULL;\n   }\n \n+  /* Return true if tree contains access to global memory.  */\n+  bool global_access_p ()\n+  {\n+    size_t i, j, k;\n+    modref_base_node <T> *base_node;\n+    modref_ref_node <T> *ref_node;\n+    modref_access_node *access_node;\n+    if (every_base)\n+      return true;\n+    FOR_EACH_VEC_SAFE_ELT (bases, i, base_node)\n+      {\n+\tif (base_node->every_ref)\n+\t  return true;\n+\tFOR_EACH_VEC_SAFE_ELT (base_node->refs, j, ref_node)\n+\t  {\n+\t    if (ref_node->every_access)\n+\t      return true;\n+\t    FOR_EACH_VEC_SAFE_ELT (ref_node->accesses, k, access_node)\n+\t      if (access_node->parm_index < 0)\n+\t\treturn true;\n+\t  }\n+      }\n+    return false;\n+  }\n+\n   /* Return ggc allocated instance.  We explicitly call destructors via\n      ggc_delete and do not want finalizers to be registered and\n      called at the garbage collection time.  */"}, {"sha": "0bbec8df0a2676fa8e337e33584c483fb7326db8", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=008e7397dad971c03c08fc1b0a4a98fddccaaed8", "patch": "@@ -85,6 +85,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ssa-iterators.h\"\n #include \"stringpool.h\"\n #include \"tree-ssanames.h\"\n+#include \"attribs.h\"\n \n \n namespace {\n@@ -280,17 +281,6 @@ modref_summary::~modref_summary ()\n     ggc_delete (stores);\n }\n \n-/* All flags that are implied by the ECF_CONST functions.  */\n-const int implicit_const_eaf_flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE\n-\t\t\t\t     | EAF_NODIRECTESCAPE | EAF_NOREAD;\n-/* All flags that are implied by the ECF_PURE function.  */\n-const int implicit_pure_eaf_flags = EAF_NOCLOBBER | EAF_NOESCAPE\n-\t\t\t\t    | EAF_NODIRECTESCAPE;\n-/* All flags implied when we know we can ignore stores (i.e. when handling\n-   call to noreturn).  */\n-const int ignore_stores_eaf_flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE\n-\t\t\t\t    | EAF_NODIRECTESCAPE;\n-\n /* Remove all flags from EAF_FLAGS that are implied by ECF_FLAGS and not\n    useful to track.  If returns_void is true moreover clear\n    EAF_NOT_RETURNED.  */\n@@ -305,10 +295,6 @@ remove_useless_eaf_flags (int eaf_flags, int ecf_flags, bool returns_void)\n     eaf_flags &= ~implicit_pure_eaf_flags;\n   else if ((ecf_flags & ECF_NORETURN) || returns_void)\n     eaf_flags &= ~EAF_NOT_RETURNED;\n-  /* Only NOCLOBBER or DIRECT flags alone are not useful (see comments\n-     in tree-ssa-alias.c).  Give up earlier.  */\n-  if ((eaf_flags & ~(EAF_DIRECT | EAF_NOCLOBBER)) == 0)\n-    return 0;\n   return eaf_flags;\n }\n \n@@ -345,6 +331,26 @@ modref_summary::useful_p (int ecf_flags, bool check_flags)\n   return stores && !stores->every_base;\n }\n \n+/* Return true if global memory is read\n+   (that is loads summary contains global memory access).  */\n+bool\n+modref_summary::global_memory_read_p ()\n+{\n+  if (!loads)\n+    return true;\n+  return loads->global_access_p ();\n+}\n+\n+/* Return true if global memory is written.  */\n+bool\n+modref_summary::global_memory_written_p ()\n+{\n+  if (!stores)\n+    return true;\n+  return stores->global_access_p ();\n+}\n+\n+\n /* Single function summary used for LTO.  */\n \n typedef modref_tree <tree> modref_records_lto;\n@@ -2016,7 +2022,8 @@ analyze_function (function *f, bool ipa)\n \t     DECL_PURE_P (current_function_decl) ? \" (pure)\" : \"\");\n \n   /* Don't analyze this function if it's compiled with -fno-strict-aliasing.  */\n-  if (!flag_ipa_modref)\n+  if (!flag_ipa_modref\n+      || lookup_attribute (\"noipa\", DECL_ATTRIBUTES (current_function_decl)))\n     return;\n \n   /* Compute no-LTO summaries when local optimization is going to happen.  */"}, {"sha": "5afa3aa439f1fb0dc26e02dba54f92056da91a06", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=008e7397dad971c03c08fc1b0a4a98fddccaaed8", "patch": "@@ -37,10 +37,23 @@ struct GTY(()) modref_summary\n   ~modref_summary ();\n   void dump (FILE *);\n   bool useful_p (int ecf_flags, bool check_flags = true);\n+  bool global_memory_read_p ();\n+  bool global_memory_written_p ();\n };\n \n modref_summary *get_modref_function_summary (cgraph_node *func);\n void ipa_modref_c_finalize ();\n void ipa_merge_modref_summary_after_inlining (cgraph_edge *e);\n \n+/* All flags that are implied by the ECF_CONST functions.  */\n+static const int implicit_const_eaf_flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE\n+\t\t\t\t     | EAF_NODIRECTESCAPE | EAF_NOREAD;\n+/* All flags that are implied by the ECF_PURE function.  */\n+static const int implicit_pure_eaf_flags = EAF_NOCLOBBER | EAF_NOESCAPE\n+\t\t\t\t    | EAF_NODIRECTESCAPE;\n+/* All flags implied when we know we can ignore stores (i.e. when handling\n+   call to noreturn).  */\n+static const int ignore_stores_eaf_flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE\n+\t\t\t\t    | EAF_NODIRECTESCAPE;\n+\n #endif"}, {"sha": "de019a7ecaf962a79117de3ef959c3016b87b83b", "filename": "gcc/testsuite/gcc.dg/torture/ssa-pta-fn-1.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-pta-fn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-pta-fn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fssa-pta-fn-1.c?ref=008e7397dad971c03c08fc1b0a4a98fddccaaed8", "patch": "@@ -6,13 +6,13 @@ extern void abort (void);\n int *g;\n int dummy;\n \n-int * __attribute__((noinline,const))\n+int * __attribute__((noinline,const,noipa))\n foo_const(int *p) { return p; }\n \n-int * __attribute__((noinline,pure))\n+int * __attribute__((noinline,pure,noipa))\n foo_pure(int *p) { return p + dummy; }\n \n-int * __attribute__((noinline))\n+int * __attribute__((noinline,noipa))\n foo_normal(int *p) { g = p; return p; }\n \n void test_const(void)\n@@ -58,4 +58,4 @@ int main()\n \n /* { dg-final { scan-tree-dump \"q_const_. = { NONLOCAL i }\" \"alias\" } } */\n /* { dg-final { scan-tree-dump \"q_pure_. = { ESCAPED NONLOCAL i }\" \"alias\" } } */\n-/* { dg-final { scan-tree-dump \"q_normal_. = { ESCAPED NONLOCAL }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"q_normal_. = { ESCAPED NONLOCAL i }\" \"alias\" } } */"}, {"sha": "aa639b45dc21bd27602831d4108dfb2c1f48b891", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pta-callused.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpta-callused.c?ref=008e7397dad971c03c08fc1b0a4a98fddccaaed8", "patch": "@@ -22,5 +22,5 @@ int bar (int b)\n   return *foo (&q);\n }\n \n-/* { dg-final { scan-tree-dump \"CALLUSED\\\\(\\[0-9\\]+\\\\) = { f.* i q }\" \"alias\" } } */\n+/* { dg-final { scan-tree-dump \"CALLUSED\\\\(\\[0-9\\]+\\\\) = { NONLOCAL f.* i q }\" \"alias\" } } */\n "}, {"sha": "6f12a66ee0ddbf59540159116f26fbde4d6a38e3", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 245, "deletions": 273, "changes": 518, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/008e7397dad971c03c08fc1b0a4a98fddccaaed8/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=008e7397dad971c03c08fc1b0a4a98fddccaaed8", "patch": "@@ -44,6 +44,9 @@\n #include \"tree-ssa.h\"\n #include \"tree-cfg.h\"\n #include \"gimple-range.h\"\n+#include \"ipa-modref-tree.h\"\n+#include \"ipa-modref.h\"\n+#include \"attr-fnspec.h\"\n \n /* The idea behind this analyzer is to generate set constraints from the\n    program, then solve the resulting constraints in order to generate the\n@@ -4048,119 +4051,221 @@ get_function_part_constraint (varinfo_t fi, unsigned part)\n   return c;\n }\n \n-/* For non-IPA mode, generate constraints necessary for a call on the\n-   RHS.  */\n+/* Produce constraints for argument ARG of call STMT with eaf flags\n+   FLAGS.  RESULTS is array holding constraints for return value.\n+   CALLESCAPE_ID is variable where call loocal escapes are added.\n+   WRITES_GLOVEL_MEMORY is true if callee may write global memory. */\n \n static void\n-handle_rhs_call (gcall *stmt, vec<ce_s> *results)\n-{\n-  struct constraint_expr rhsc;\n-  unsigned i;\n-  bool returns_uses = false;\n+handle_call_arg (gcall *stmt, tree arg, vec<ce_s> *results, int flags,\n+\t\t int callescape_id, bool writes_global_memory)\n+{\n+  /* If the argument is not used we can ignore it.\n+     Similarly argument is invisile for us if it not clobbered, does not\n+     escape, is not read and can not be returned.  */\n+  if ((flags & EAF_UNUSED)\n+      || ((flags & (EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NOREAD\n+\t\t    | EAF_NOT_RETURNED))\n+\t  == (EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NOREAD\n+\t      | EAF_NOT_RETURNED)))\n+    return;\n+\n+  varinfo_t tem = new_var_info (NULL_TREE, \"callarg\", true);\n+  tem->is_reg_var = true;\n+  make_constraint_to (tem->id, arg);\n+  make_any_offset_constraints (tem);\n+\n+  if (!(flags & EAF_DIRECT))\n+    make_transitive_closure_constraints (tem);\n \n-  for (i = 0; i < gimple_call_num_args (stmt); ++i)\n+  if (!(flags & EAF_NOT_RETURNED))\n     {\n-      tree arg = gimple_call_arg (stmt, i);\n-      int flags = gimple_call_arg_flags (stmt, i);\n+      struct constraint_expr cexpr;\n+      cexpr.var = tem->id;\n+      cexpr.type = SCALAR;\n+      cexpr.offset = 0;\n+      results->safe_push (cexpr);\n+    }\n \n-      /* If the argument is not used we can ignore it.\n-\t Similarly argument is invisile for us if it not clobbered, does not\n-\t escape, is not read and can not be returned.  */\n-      if ((flags & EAF_UNUSED)\n-\t  || ((flags & (EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NOREAD\n-\t\t\t| EAF_NOT_RETURNED))\n-\t      == (EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NOREAD\n-\t\t  | EAF_NOT_RETURNED)))\n-\tcontinue;\n+  if (!(flags & EAF_NOREAD))\n+    {\n+      varinfo_t uses = get_call_use_vi (stmt);\n+      make_copy_constraint (uses, tem->id);\n+    }\n \n-      /* As we compute ESCAPED context-insensitive we do not gain\n-         any precision with just EAF_NOCLOBBER but not EAF_NOESCAPE\n-\t set.  The argument would still get clobbered through the\n-\t escape solution.  */\n-      if ((flags & EAF_NOCLOBBER)\n-\t   && (flags & (EAF_NOESCAPE | EAF_NODIRECTESCAPE)))\n-\t{\n-\t  varinfo_t uses = get_call_use_vi (stmt);\n-\t  varinfo_t tem = new_var_info (NULL_TREE, \"callarg\", true);\n-\t  tem->is_reg_var = true;\n-\t  make_constraint_to (tem->id, arg);\n-\t  make_any_offset_constraints (tem);\n-\t  if (!(flags & EAF_DIRECT))\n-\t    make_transitive_closure_constraints (tem);\n-\t  make_copy_constraint (uses, tem->id);\n-\t  /* TODO: This is overly conservative when some parameters are\n-\t     returned while others are not.  */\n-\t  if (!(flags & EAF_NOT_RETURNED))\n-\t    returns_uses = true;\n-\t  if (!(flags & (EAF_NOESCAPE | EAF_DIRECT)))\n-\t    make_indirect_escape_constraint (tem);\n-\t}\n-      else if (flags & (EAF_NOESCAPE | EAF_NODIRECTESCAPE))\n+  if (!(flags & EAF_NOCLOBBER))\n+    {\n+      struct constraint_expr lhs, rhs;\n+\n+      /* *arg = callescape.  */\n+      lhs.type = DEREF;\n+      lhs.var = tem->id;\n+      lhs.offset = 0;\n+\n+      rhs.type = SCALAR;\n+      rhs.var = callescape_id;\n+      rhs.offset = 0;\n+      process_constraint (new_constraint (lhs, rhs));\n+\n+      /* callclobbered = arg.  */\n+      make_copy_constraint (get_call_clobber_vi (stmt), tem->id);\n+    }\n+\n+  if (!(flags & (EAF_NOESCAPE | EAF_NODIRECTESCAPE)))\n+    {\n+      struct constraint_expr lhs, rhs;\n+\n+      /* callescape = arg;  */\n+      lhs.var = callescape_id;\n+      lhs.offset = 0;\n+      lhs.type = SCALAR;\n+\n+      rhs.var = tem->id;\n+      rhs.offset = 0;\n+      rhs.type = SCALAR;\n+      process_constraint (new_constraint (lhs, rhs));\n+\n+      if (writes_global_memory)\n+\tmake_escape_constraint (arg);\n+    }\n+  else if (!(flags & EAF_NOESCAPE))\n+    {\n+      struct constraint_expr lhs, rhs;\n+\n+      /* callescape = *(arg + UNKNOWN);  */\n+      lhs.var = callescape_id;\n+      lhs.offset = 0;\n+      lhs.type = SCALAR;\n+\n+      rhs.var = tem->id;\n+      rhs.offset = UNKNOWN_OFFSET;\n+      rhs.type = DEREF;\n+      process_constraint (new_constraint (lhs, rhs));\n+\n+      if (writes_global_memory)\n+\tmake_indirect_escape_constraint (tem);\n+    }\n+}\n+\n+/* Determine global memory access of call STMT and update\n+   WRITES_GLOBAL_MEMORY, READS_GLOBAL_MEMORY and USES_GLOBAL_MEMORY.  */\n+\n+static void\n+determine_global_memory_access (gcall *stmt,\n+\t\t\t\tbool *writes_global_memory,\n+\t\t\t\tbool *reads_global_memory,\n+\t\t\t\tbool *uses_global_memory)\n+{\n+  tree callee;\n+  cgraph_node *node;\n+  modref_summary *summary;\n+\n+  /* We need to detrmine reads to set uses.  */\n+  gcc_assert (!uses_global_memory || reads_global_memory);\n+\n+  if ((callee = gimple_call_fndecl (stmt)) != NULL_TREE\n+      && (node = cgraph_node::get (callee)) != NULL\n+      && (summary = get_modref_function_summary (node)))\n+    {\n+      if (writes_global_memory && *writes_global_memory)\n+\t*writes_global_memory = summary->global_memory_written_p ();\n+      if (reads_global_memory && *reads_global_memory)\n+\t*reads_global_memory = summary->global_memory_read_p ();\n+      if (reads_global_memory && uses_global_memory\n+\t  && !*reads_global_memory && node->binds_to_current_def_p ())\n+\t*uses_global_memory = false;\n+    }\n+  if ((writes_global_memory && *writes_global_memory)\n+      || (uses_global_memory && *uses_global_memory)\n+      || (reads_global_memory && *reads_global_memory))\n+    {\n+      attr_fnspec fnspec = gimple_call_fnspec (stmt);\n+      if (fnspec.known_p ())\n \t{\n-\t  struct constraint_expr lhs, rhs;\n-\t  varinfo_t uses = get_call_use_vi (stmt);\n-\t  varinfo_t clobbers = get_call_clobber_vi (stmt);\n-\t  varinfo_t tem = new_var_info (NULL_TREE, \"callarg\", true);\n-\t  tem->is_reg_var = true;\n-\t  make_constraint_to (tem->id, arg);\n-\t  make_any_offset_constraints (tem);\n-\t  if (!(flags & EAF_DIRECT))\n-\t    make_transitive_closure_constraints (tem);\n-\t  make_copy_constraint (uses, tem->id);\n-\t  if (!(flags & EAF_NOT_RETURNED))\n-\t    returns_uses = true;\n-\t  make_copy_constraint (clobbers, tem->id);\n-\t  /* Add *tem = nonlocal, do not add *tem = callused as\n-\t     EAF_NOESCAPE parameters do not escape to other parameters\n-\t     and all other uses appear in NONLOCAL as well.  */\n-\t  lhs.type = DEREF;\n-\t  lhs.var = tem->id;\n-\t  lhs.offset = 0;\n-\t  rhs.type = SCALAR;\n-\t  rhs.var = nonlocal_id;\n-\t  rhs.offset = 0;\n-\t  process_constraint (new_constraint (lhs, rhs));\n-\t  if (!(flags & (EAF_NOESCAPE | EAF_DIRECT)))\n-\t    make_indirect_escape_constraint (tem);\n+\t  if (writes_global_memory\n+\t      && !fnspec.global_memory_written_p ())\n+\t    *writes_global_memory = false;\n+\t  if (reads_global_memory && !fnspec.global_memory_read_p ())\n+\t    {\n+\t      *reads_global_memory = false;\n+\t      if (uses_global_memory)\n+\t\t*uses_global_memory = false;\n+\t    }\n \t}\n-      else\n-\tmake_escape_constraint (arg);\n     }\n+}\n+\n+/* For non-IPA mode, generate constraints necessary for a call on the\n+   RHS and collect return value constraint to RESULTS to be used later in\n+   handle_lhs_call.\n+  \n+   IMPLICIT_EAF_FLAGS are added to each function argument.  If\n+   WRITES_GLOBAL_MEMORY is true function is assumed to possibly write to global\n+   memory.  Similar for READS_GLOBAL_MEMORY.  */\n+\n+static void\n+handle_rhs_call (gcall *stmt, vec<ce_s> *results,\n+\t\t int implicit_eaf_flags,\n+\t\t bool writes_global_memory,\n+\t\t bool reads_global_memory)\n+{\n+  determine_global_memory_access (stmt, &writes_global_memory,\n+\t\t\t\t  &reads_global_memory,\n+\t\t\t\t  NULL);\n+\n+  varinfo_t callescape = new_var_info (NULL_TREE, \"callescape\", true);\n+\n+  /* If function can use global memory, add it to callescape\n+     and to possible return values.  If not we can still use/return addresses\n+     of global symbols.  */\n+  struct constraint_expr lhs, rhs;\n+\n+  lhs.type = SCALAR;\n+  lhs.var = callescape->id;\n+  lhs.offset = 0;\n+\n+  rhs.type = reads_global_memory ? SCALAR : ADDRESSOF;\n+  rhs.var = nonlocal_id;\n+  rhs.offset = 0;\n \n-  /* If we added to the calls uses solution make sure we account for\n-     pointers to it to be returned.  */\n-  if (returns_uses)\n+  process_constraint (new_constraint (lhs, rhs));\n+  results->safe_push (rhs);\n+\n+  varinfo_t uses = get_call_use_vi (stmt);\n+  make_copy_constraint (uses, callescape->id);\n+\n+  for (unsigned i = 0; i < gimple_call_num_args (stmt); ++i)\n     {\n-      rhsc.var = get_call_use_vi (stmt)->id;\n-      rhsc.offset = UNKNOWN_OFFSET;\n-      rhsc.type = SCALAR;\n-      results->safe_push (rhsc);\n+      tree arg = gimple_call_arg (stmt, i);\n+      int flags = gimple_call_arg_flags (stmt, i);\n+      handle_call_arg (stmt, arg, results,\n+\t\t       flags | implicit_eaf_flags,\n+\t\t       callescape->id, writes_global_memory);\n     }\n \n   /* The static chain escapes as well.  */\n   if (gimple_call_chain (stmt))\n-    make_escape_constraint (gimple_call_chain (stmt));\n+    handle_call_arg (stmt, gimple_call_chain (stmt), results,\n+\t\t     implicit_eaf_flags,\n+\t\t     callescape->id, writes_global_memory);\n \n   /* And if we applied NRV the address of the return slot escapes as well.  */\n   if (gimple_call_return_slot_opt_p (stmt)\n       && gimple_call_lhs (stmt) != NULL_TREE\n       && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (stmt))))\n     {\n       auto_vec<ce_s> tmpc;\n-      struct constraint_expr lhsc, *c;\n+      struct constraint_expr *c;\n+      unsigned i;\n+\n       get_constraint_for_address_of (gimple_call_lhs (stmt), &tmpc);\n-      lhsc.var = escaped_id;\n-      lhsc.offset = 0;\n-      lhsc.type = SCALAR;\n+\n+      make_constraints_to (callescape->id, tmpc);\n+      if (writes_global_memory)\n+\tmake_constraints_to (escaped_id, tmpc);\n       FOR_EACH_VEC_ELT (tmpc, i, c)\n-\tprocess_constraint (new_constraint (lhsc, *c));\n+\tresults->safe_push (*c);\n     }\n-\n-  /* Regular functions return nonlocal memory.  */\n-  rhsc.var = nonlocal_id;\n-  rhsc.offset = 0;\n-  rhsc.type = SCALAR;\n-  results->safe_push (rhsc);\n }\n \n /* For non-IPA mode, generate constraints necessary for a call\n@@ -4227,160 +4332,6 @@ handle_lhs_call (gcall *stmt, tree lhs, int flags, vec<ce_s> &rhsc,\n     process_all_all_constraints (lhsc, rhsc);\n }\n \n-/* For non-IPA mode, generate constraints necessary for a call of a\n-   const function that returns a pointer in the statement STMT.  */\n-\n-static void\n-handle_const_call (gcall *stmt, vec<ce_s> *results)\n-{\n-  struct constraint_expr rhsc;\n-  unsigned int k;\n-  bool need_uses = false;\n-\n-  /* Treat nested const functions the same as pure functions as far\n-     as the static chain is concerned.  */\n-  if (gimple_call_chain (stmt))\n-    {\n-      varinfo_t uses = get_call_use_vi (stmt);\n-      make_constraint_to (uses->id, gimple_call_chain (stmt));\n-      need_uses = true;\n-    }\n-\n-  /* And if we applied NRV the address of the return slot escapes as well.  */\n-  if (gimple_call_return_slot_opt_p (stmt)\n-      && gimple_call_lhs (stmt) != NULL_TREE\n-      && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (stmt))))\n-    {\n-      varinfo_t uses = get_call_use_vi (stmt);\n-      auto_vec<ce_s> tmpc;\n-      get_constraint_for_address_of (gimple_call_lhs (stmt), &tmpc);\n-      make_constraints_to (uses->id, tmpc);\n-      need_uses = true;\n-    }\n-\n-  if (need_uses)\n-    {\n-      varinfo_t uses = get_call_use_vi (stmt);\n-      make_any_offset_constraints (uses);\n-      make_transitive_closure_constraints (uses);\n-      rhsc.var = uses->id;\n-      rhsc.offset = 0;\n-      rhsc.type = SCALAR;\n-      results->safe_push (rhsc);\n-    }\n-\n-  /* May return offsetted arguments.  */\n-  varinfo_t tem = NULL;\n-  for (k = 0; k < gimple_call_num_args (stmt); ++k)\n-    {\n-      int flags = gimple_call_arg_flags (stmt, k);\n-\n-      /* If the argument is not used or not returned we can ignore it.  */\n-      if (flags & (EAF_UNUSED | EAF_NOT_RETURNED))\n-\tcontinue;\n-      if (!tem)\n-\t{\n-\t  tem = new_var_info (NULL_TREE, \"callarg\", true);\n-\t  tem->is_reg_var = true;\n-\t}\n-      tree arg = gimple_call_arg (stmt, k);\n-      auto_vec<ce_s> argc;\n-      get_constraint_for_rhs (arg, &argc);\n-      make_constraints_to (tem->id, argc);\n-    }\n-  if (tem)\n-    {\n-      ce_s ce;\n-      ce.type = SCALAR;\n-      ce.var = tem->id;\n-      ce.offset = UNKNOWN_OFFSET;\n-      results->safe_push (ce);\n-    }\n-\n-  /* May return addresses of globals.  */\n-  rhsc.var = nonlocal_id;\n-  rhsc.offset = 0;\n-  rhsc.type = ADDRESSOF;\n-  results->safe_push (rhsc);\n-}\n-\n-/* For non-IPA mode, generate constraints necessary for a call to a\n-   pure function in statement STMT.  */\n-\n-static void\n-handle_pure_call (gcall *stmt, vec<ce_s> *results)\n-{\n-  struct constraint_expr rhsc;\n-  unsigned i;\n-  varinfo_t uses = NULL;\n-  bool record_uses = false;\n-\n-  /* Memory reached from pointer arguments is call-used.  */\n-  for (i = 0; i < gimple_call_num_args (stmt); ++i)\n-    {\n-      tree arg = gimple_call_arg (stmt, i);\n-      int flags = gimple_call_arg_flags (stmt, i);\n-\n-      /* If the argument is not used we can ignore it.  */\n-      if ((flags & EAF_UNUSED)\n-\t  || (flags & (EAF_NOT_RETURNED | EAF_NOREAD))\n-\t     == (EAF_NOT_RETURNED | EAF_NOREAD))\n-\tcontinue;\n-      if (!uses)\n-\t{\n-\t  uses = get_call_use_vi (stmt);\n-\t  make_any_offset_constraints (uses);\n-\t  make_transitive_closure_constraints (uses);\n-\t}\n-      make_constraint_to (uses->id, arg);\n-      if (!(flags & EAF_NOT_RETURNED))\n-\trecord_uses = true;\n-    }\n-\n-  /* The static chain is used as well.  */\n-  if (gimple_call_chain (stmt))\n-    {\n-      if (!uses)\n-\t{\n-\t  uses = get_call_use_vi (stmt);\n-\t  make_any_offset_constraints (uses);\n-\t  make_transitive_closure_constraints (uses);\n-\t}\n-      make_constraint_to (uses->id, gimple_call_chain (stmt));\n-      record_uses = true;\n-    }\n-\n-  /* And if we applied NRV the address of the return slot.  */\n-  if (gimple_call_return_slot_opt_p (stmt)\n-      && gimple_call_lhs (stmt) != NULL_TREE\n-      && TREE_ADDRESSABLE (TREE_TYPE (gimple_call_lhs (stmt))))\n-    {\n-      if (!uses)\n-\t{\n-\t  uses = get_call_use_vi (stmt);\n-\t  make_any_offset_constraints (uses);\n-\t  make_transitive_closure_constraints (uses);\n-\t}\n-      auto_vec<ce_s> tmpc;\n-      get_constraint_for_address_of (gimple_call_lhs (stmt), &tmpc);\n-      make_constraints_to (uses->id, tmpc);\n-      record_uses = true;\n-    }\n-\n-  /* Pure functions may return call-used and nonlocal memory.  */\n-  if (record_uses)\n-    {\n-      rhsc.var = uses->id;\n-      rhsc.offset = 0;\n-      rhsc.type = SCALAR;\n-      results->safe_push (rhsc);\n-    }\n-  rhsc.var = nonlocal_id;\n-  rhsc.offset = 0;\n-  rhsc.type = SCALAR;\n-  results->safe_push (rhsc);\n-}\n-\n \n /* Return the varinfo for the callee of CALL.  */\n \n@@ -4931,13 +4882,13 @@ find_func_aliases_for_call (struct function *fn, gcall *t)\n       if (flags & (ECF_CONST|ECF_NOVOPS))\n \t{\n \t  if (gimple_call_lhs (t))\n-\t    handle_const_call (t, &rhsc);\n+\t    handle_rhs_call (t, &rhsc, implicit_const_eaf_flags, false, false);\n \t}\n       /* Pure functions can return addresses in and of memory\n \t reachable from their arguments, but they are not an escape\n \t point for reachable memory of their arguments.  */\n       else if (flags & (ECF_PURE|ECF_LOOPING_CONST_OR_PURE))\n-\thandle_pure_call (t, &rhsc);\n+\thandle_rhs_call (t, &rhsc, implicit_pure_eaf_flags, true, false);\n       /* If the call is to a replaceable operator delete and results\n \t from a delete expression as opposed to a direct call to\n \t such operator, then the effects for PTA (in particular\n@@ -4947,7 +4898,7 @@ find_func_aliases_for_call (struct function *fn, gcall *t)\n \t       && gimple_call_from_new_or_delete (t))\n \t;\n       else\n-\thandle_rhs_call (t, &rhsc);\n+\thandle_rhs_call (t, &rhsc, 0, true, true);\n       if (gimple_call_lhs (t))\n \thandle_lhs_call (t, gimple_call_lhs (t),\n \t\t\t gimple_call_return_flags (t), rhsc, fndecl);\n@@ -7582,43 +7533,64 @@ compute_points_to_sets (void)\n \t  pt = gimple_call_use_set (stmt);\n \t  if (gimple_call_flags (stmt) & ECF_CONST)\n \t    memset (pt, 0, sizeof (struct pt_solution));\n-\t  else if ((vi = lookup_call_use_vi (stmt)) != NULL)\n-\t    {\n-\t      *pt = find_what_var_points_to (cfun->decl, vi);\n-\t      /* Escaped (and thus nonlocal) variables are always\n-\t         implicitly used by calls.  */\n-\t      /* ???  ESCAPED can be empty even though NONLOCAL\n-\t\t always escaped.  */\n-\t      pt->nonlocal = 1;\n-\t      pt->escaped = 1;\n-\t    }\n \t  else\n \t    {\n-\t      /* If there is nothing special about this call then\n-\t\t we have made everything that is used also escape.  */\n-\t      *pt = cfun->gimple_df->escaped;\n-\t      pt->nonlocal = 1;\n+\t      bool uses_global_memory = true;\n+\t      bool reads_global_memory = true;\n+\n+\t      determine_global_memory_access (stmt, NULL,\n+\t\t\t\t\t      &reads_global_memory,\n+\t\t\t\t\t      &uses_global_memory);\n+\t      if (!uses_global_memory)\n+\t\t;\n+\t      else if ((vi = lookup_call_use_vi (stmt)) != NULL)\n+\t\t{\n+\t\t  *pt = find_what_var_points_to (cfun->decl, vi);\n+\t\t  /* Escaped (and thus nonlocal) variables are always\n+\t\t     implicitly used by calls.  */\n+\t\t  /* ???  ESCAPED can be empty even though NONLOCAL\n+\t\t     always escaped.  */\n+\t\t  pt->nonlocal = uses_global_memory;\n+\t\t  pt->escaped = uses_global_memory;\n+\t\t}\n+\t      else if (uses_global_memory)\n+\t\t{\n+\t\t  /* If there is nothing special about this call then\n+\t\t     we have made everything that is used also escape.  */\n+\t\t  *pt = cfun->gimple_df->escaped;\n+\t\t  pt->nonlocal = 1;\n+\t\t}\n \t    }\n \n \t  pt = gimple_call_clobber_set (stmt);\n \t  if (gimple_call_flags (stmt) & (ECF_CONST|ECF_PURE|ECF_NOVOPS))\n \t    memset (pt, 0, sizeof (struct pt_solution));\n-\t  else if ((vi = lookup_call_clobber_vi (stmt)) != NULL)\n-\t    {\n-\t      *pt = find_what_var_points_to (cfun->decl, vi);\n-\t      /* Escaped (and thus nonlocal) variables are always\n-\t         implicitly clobbered by calls.  */\n-\t      /* ???  ESCAPED can be empty even though NONLOCAL\n-\t\t always escaped.  */\n-\t      pt->nonlocal = 1;\n-\t      pt->escaped = 1;\n-\t    }\n \t  else\n \t    {\n-\t      /* If there is nothing special about this call then\n-\t\t we have made everything that is used also escape.  */\n-\t      *pt = cfun->gimple_df->escaped;\n-\t      pt->nonlocal = 1;\n+\t      bool writes_global_memory = true;\n+\n+\t      determine_global_memory_access (stmt, &writes_global_memory,\n+\t\t\t\t\t      NULL, NULL);\n+\n+\t      if (!writes_global_memory)\n+\t\t;\n+\t      else if ((vi = lookup_call_clobber_vi (stmt)) != NULL)\n+\t\t{\n+\t\t  *pt = find_what_var_points_to (cfun->decl, vi);\n+\t\t  /* Escaped (and thus nonlocal) variables are always\n+\t\t     implicitly clobbered by calls.  */\n+\t\t  /* ???  ESCAPED can be empty even though NONLOCAL\n+\t\t     always escaped.  */\n+\t\t  pt->nonlocal = writes_global_memory;\n+\t\t  pt->escaped = writes_global_memory;\n+\t\t}\n+\t      else if (writes_global_memory)\n+\t\t{\n+\t\t  /* If there is nothing special about this call then\n+\t\t     we have made everything that is used also escape.  */\n+\t\t  *pt = cfun->gimple_df->escaped;\n+\t\t  pt->nonlocal = 1;\n+\t\t}\n \t    }\n \t}\n     }"}]}