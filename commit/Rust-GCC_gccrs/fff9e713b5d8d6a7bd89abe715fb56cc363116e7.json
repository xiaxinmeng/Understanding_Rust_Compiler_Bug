{"sha": "fff9e713b5d8d6a7bd89abe715fb56cc363116e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZmOWU3MTNiNWQ4ZDZhN2JkODlhYmU3MTVmYjU2Y2MzNjMxMTZlNw==", "commit": {"author": {"name": "Michael Tiemann", "email": "tiemann@gnu.org", "date": "1992-02-17T13:20:31Z"}, "committer": {"name": "Michael Tiemann", "email": "tiemann@gnu.org", "date": "1992-02-17T13:20:31Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r334", "tree": {"sha": "d804ad07459719afeeebef4b119f764cc86a1de8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d804ad07459719afeeebef4b119f764cc86a1de8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fff9e713b5d8d6a7bd89abe715fb56cc363116e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff9e713b5d8d6a7bd89abe715fb56cc363116e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fff9e713b5d8d6a7bd89abe715fb56cc363116e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fff9e713b5d8d6a7bd89abe715fb56cc363116e7/comments", "author": null, "committer": null, "parents": [{"sha": "3785a1d8481231e6aa9a00d0d1679eae52190100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3785a1d8481231e6aa9a00d0d1679eae52190100", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3785a1d8481231e6aa9a00d0d1679eae52190100"}], "stats": {"total": 51, "additions": 41, "deletions": 10}, "files": [{"sha": "b6b218b7922a921b0a7f5ee88d1a2ffb2da8d7b7", "filename": "gcc/varasm.c", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fff9e713b5d8d6a7bd89abe715fb56cc363116e7/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fff9e713b5d8d6a7bd89abe715fb56cc363116e7/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=fff9e713b5d8d6a7bd89abe715fb56cc363116e7", "patch": "@@ -201,6 +201,19 @@ decode_reg_name (asmspec)\n     {\n       int i;\n \n+      /* Allow a decimal number as a \"register name\".  */\n+      for (i = strlen (asmspec) - 1; i >= 0; i--)\n+\tif (! (asmspec[i] >= '0' && asmspec[i] <= '9'))\n+\t  break;\n+      if (asmspec[0] != 0 && i < 0)\n+\t{\n+\t  i = atoi (asmspec);\n+\t  if (i < FIRST_PSEUDO_REGISTER && i >= 0)\n+\t    return i;\n+\t  else\n+\t    return -2;\n+\t}\n+\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (reg_names[i][0] && ! strcmp (asmspec, reg_names[i]))\n \t  return i;\n@@ -896,22 +909,26 @@ assemble_variable (decl, top_level, at_end)\n }\n \n /* Output something to declare an external symbol to the assembler.\n-   (Most assemblers don't need this, so we normally output nothing.)  */\n+   (Most assemblers don't need this, so we normally output nothing.)\n+   Do nothing if DECL is not external.  */\n \n void\n assemble_external (decl)\n      tree decl;\n {\n-  rtx rtl = DECL_RTL (decl);\n-\n #ifdef ASM_OUTPUT_EXTERNAL\n-  if (TREE_PUBLIC (decl)\n-      && GET_CODE (rtl) == MEM && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF\n-      && ! SYMBOL_REF_USED (XEXP (rtl, 0)))\n+  if (TREE_CODE_CLASS (TREE_CODE (decl)) == 'd'\n+      && TREE_EXTERNAL (decl) && TREE_PUBLIC (decl))\n     {\n-      /* Some systems do require some output.  */\n-      SYMBOL_REF_USED (XEXP (rtl, 0)) = 1;\n-      ASM_OUTPUT_EXTERNAL (asm_out_file, decl, XSTR (XEXP (rtl, 0), 0));\n+      rtx rtl = DECL_RTL (decl);\n+\n+      if (GET_CODE (rtl) == MEM && GET_CODE (XEXP (rtl, 0)) == SYMBOL_REF\n+\t  && ! SYMBOL_REF_USED (XEXP (rtl, 0)))\n+\t{\n+\t  /* Some systems do require some output.  */\n+\t  SYMBOL_REF_USED (XEXP (rtl, 0)) = 1;\n+\t  ASM_OUTPUT_EXTERNAL (asm_out_file, decl, XSTR (XEXP (rtl, 0), 0));\n+\t}\n     }\n #endif\n }\n@@ -1107,11 +1124,16 @@ assemble_integer (x, size, force)\n \t  if (word == 0)\n \t    break;\n \n-\t  assemble_integer (word, UNITS_PER_WORD);\n+\t  if (! assemble_integer (word, UNITS_PER_WORD, 0))\n+\t    break;\n \t}\n \n       if (i == size / UNITS_PER_WORD)\n \treturn 1;\n+      /* If we output at least one word and then could not finish,\n+\t there is no valid way to continue.  */\n+      if (i > 0)\n+\tabort ();\n     }\n \n   if (force)\n@@ -2455,6 +2477,15 @@ output_constant (exp, size)\n   if (size == 0)\n     return;\n \n+  /* Allow a constructor with no elements for any data type.\n+     This means to fill the space with zeros.  */\n+  if (TREE_CODE (exp) == CONSTRUCTOR\n+      && TREE_OPERAND (exp, 1) == 0)\n+    {\n+      assemble_zeros (size);\n+      return;\n+    }\n+\n   /* Eliminate the NOP_EXPR that makes a cast not be an lvalue.\n      That way we get the constant (we hope) inside it.  */\n   if (TREE_CODE (exp) == NOP_EXPR"}]}