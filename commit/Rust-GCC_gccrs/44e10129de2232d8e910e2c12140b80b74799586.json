{"sha": "44e10129de2232d8e910e2c12140b80b74799586", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDRlMTAxMjlkZTIyMzJkOGU5MTBlMmMxMjE0MGI4MGI3NDc5OTU4Ng==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2009-09-28T12:54:23Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2009-09-28T12:54:23Z"}, "message": "builtins.c (interclass_mathfn_icode): New helper.\n\n\t* builtins.c (interclass_mathfn_icode): New helper.\n\t(expand_builtin_interclass_mathfn): Use it here, and split folding\n\tinto ...\n\t(fold_builtin_interclass_mathfn): ... this new folder.\n\t(build_call_nofold_loc): New static helper.\n\t(build_call_nofold): New wrapper macro for above.\n\t(expand_builtin_int_roundingfn): Use it instead of build_call_expr.\n\t(expand_builtin_pow): Ditto.\n\t(expand_builtin_memset_args): Ditto.\n\t(expand_builtin_printf): Ditto.\n\t(expand_builtin_fprintf): Ditto.\n\t(expand_builtin_sprintf): Ditto.\n\t(expand_builtin_memory_chk): Ditto.\n\t(expand_builtin_mempcpy_args): Ditto and don't call folders.\n\t(expand_builtin_stpcpy): Ditto.\n\t(expand_builtin_strcmp): Ditto.\n\t(expand_builtin_strncmp): Ditto.\n\t(expand_builtin_strcpy): Remove FNDECL and MODE arguments.\n\t(expand_builtin_strcpy_args): Don't call folders.\n\t(expand_builtin_memcmp): Ditto.\n\t(expand_builtin_strncpy): Ditto, and use target.\n\t(expand_builtin_memcpy): Ditto.\n\t(expand_builtin_strstr, expand_builtin_strchr, expand_builtin_strrchr,\n\texpand_builtin_strpbrk, expand_builtin_memmove,\n\texpand_builtin_memmove_args, expand_builtin_bcopy,\n\texpand_builtin_memchr, expand_builtin_strcat, expand_builtin_strncat,\n\texpand_builtin_strspn, expand_builtin_strcspn,\n\texpand_builtin_fputs): Remove these.\n\t(expand_builtin): Don't call the above, change calls to other\n\texpanders that changed prototype.\n\t(fold_builtin_stpcpy): New folder split out from expand_builtin_stpcpy.\n\t(fold_builtin_1 <ISFINITE, ISINF, ISNORMAL>): Call\n\tfold_builtin_interclass_mathfn.\n\t(fold_builtin_2 <STPCPY>): Call fold_builtin_stpcpy.\n\t(fold_builtin_strcat): Add folding split from expand_builtin_strcat.\n\n\t* fold-const.c (fold_binary_loc <NE_EXPR>): Add !exp != 0 -> !exp.\n\t* passes.c (init_optimization_passes): Move pass_fold_builtins\n\tafter last phiopt pass.\n\t* tree-inline.c (fold_marked_statements): When folding builtins\n\titerate over all instruction potentially generated.\n\t* tree-ssa-ccp.c (gimplify_and_update_call_from_tree): Declare\n\tearlier.\n\t(fold_gimple_call): Use it to always fold calls (into potentially\n\tmultiple instructions).\n\t* tree-ssa-dom.c (optimize_stmt): Resolve __builtin_constant_p\n\tcalls into zero at this time.\n\t* tree-ssa-propagate.c (substitute_and_fold): Ignore multiple \n\tstatements generated by builtin folding.\n\ntestsuite/\n\t* gcc.dg/builtins-44.c: Use __builtin_isinf_sign when checking\n\tfor sign of -Inf.\n\nFrom-SVN: r152236", "tree": {"sha": "d0d5ddfb1d852abf4f125c9e24309f475790c349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0d5ddfb1d852abf4f125c9e24309f475790c349"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44e10129de2232d8e910e2c12140b80b74799586", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44e10129de2232d8e910e2c12140b80b74799586", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44e10129de2232d8e910e2c12140b80b74799586", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44e10129de2232d8e910e2c12140b80b74799586/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d813aaba522c350e5f22ac1d1346b83766ac55f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d813aaba522c350e5f22ac1d1346b83766ac55f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d813aaba522c350e5f22ac1d1346b83766ac55f2"}], "stats": {"total": 1199, "additions": 483, "deletions": 716}, "files": [{"sha": "74c6d06f6ae29d864c1d700bc25b362dc0c369be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e10129de2232d8e910e2c12140b80b74799586/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e10129de2232d8e910e2c12140b80b74799586/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=44e10129de2232d8e910e2c12140b80b74799586", "patch": "@@ -1,3 +1,55 @@\n+2009-09-28  Michael Matz  <matz@suse.de>\n+\n+\t* builtins.c (interclass_mathfn_icode): New helper.\n+\t(expand_builtin_interclass_mathfn): Use it here, and split folding\n+\tinto ...\n+\t(fold_builtin_interclass_mathfn): ... this new folder.\n+\t(build_call_nofold_loc): New static helper.\n+\t(build_call_nofold): New wrapper macro for above.\n+\t(expand_builtin_int_roundingfn): Use it instead of build_call_expr.\n+\t(expand_builtin_pow): Ditto.\n+\t(expand_builtin_memset_args): Ditto.\n+\t(expand_builtin_printf): Ditto.\n+\t(expand_builtin_fprintf): Ditto.\n+\t(expand_builtin_sprintf): Ditto.\n+\t(expand_builtin_memory_chk): Ditto.\n+\t(expand_builtin_mempcpy_args): Ditto and don't call folders.\n+\t(expand_builtin_stpcpy): Ditto.\n+\t(expand_builtin_strcmp): Ditto.\n+\t(expand_builtin_strncmp): Ditto.\n+\t(expand_builtin_strcpy): Remove FNDECL and MODE arguments.\n+\t(expand_builtin_strcpy_args): Don't call folders.\n+\t(expand_builtin_memcmp): Ditto.\n+\t(expand_builtin_strncpy): Ditto, and use target.\n+\t(expand_builtin_memcpy): Ditto.\n+\t(expand_builtin_strstr, expand_builtin_strchr, expand_builtin_strrchr,\n+\texpand_builtin_strpbrk, expand_builtin_memmove,\n+\texpand_builtin_memmove_args, expand_builtin_bcopy,\n+\texpand_builtin_memchr, expand_builtin_strcat, expand_builtin_strncat,\n+\texpand_builtin_strspn, expand_builtin_strcspn,\n+\texpand_builtin_fputs): Remove these.\n+\t(expand_builtin): Don't call the above, change calls to other\n+\texpanders that changed prototype.\n+\t(fold_builtin_stpcpy): New folder split out from expand_builtin_stpcpy.\n+\t(fold_builtin_1 <ISFINITE, ISINF, ISNORMAL>): Call\n+\tfold_builtin_interclass_mathfn.\n+\t(fold_builtin_2 <STPCPY>): Call fold_builtin_stpcpy.\n+\t(fold_builtin_strcat): Add folding split from expand_builtin_strcat.\n+\n+\t* fold-const.c (fold_binary_loc <NE_EXPR>): Add !exp != 0 -> !exp.\n+\t* passes.c (init_optimization_passes): Move pass_fold_builtins\n+\tafter last phiopt pass.\n+\t* tree-inline.c (fold_marked_statements): When folding builtins\n+\titerate over all instruction potentially generated.\n+\t* tree-ssa-ccp.c (gimplify_and_update_call_from_tree): Declare\n+\tearlier.\n+\t(fold_gimple_call): Use it to always fold calls (into potentially\n+\tmultiple instructions).\n+\t* tree-ssa-dom.c (optimize_stmt): Resolve __builtin_constant_p\n+\tcalls into zero at this time.\n+\t* tree-ssa-propagate.c (substitute_and_fold): Ignore multiple \n+\tstatements generated by builtin folding.\n+\n 2009-09-28  Nick Clifton  <nickc@redhat.com>\n \n \t* config/m32r/m32r.c (m32r_is_insn): Return false for debugging"}, {"sha": "64840e1f620fceaf9ee7578294b64d5c63580df8", "filename": "gcc/builtins.c", "status": "modified", "additions": 338, "deletions": 693, "changes": 1031, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=44e10129de2232d8e910e2c12140b80b74799586", "patch": "@@ -112,40 +112,26 @@ static rtx expand_builtin_next_arg (void);\n static rtx expand_builtin_va_start (tree);\n static rtx expand_builtin_va_end (tree);\n static rtx expand_builtin_va_copy (tree);\n-static rtx expand_builtin_memchr (tree, rtx, enum machine_mode);\n static rtx expand_builtin_memcmp (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_strcmp (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strcmp (tree, rtx);\n static rtx expand_builtin_strncmp (tree, rtx, enum machine_mode);\n static rtx builtin_memcpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n-static rtx expand_builtin_strcat (tree, tree, rtx, enum machine_mode);\n-static rtx expand_builtin_strncat (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_strspn (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_strcspn (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_memcpy (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_memcpy (tree, rtx);\n static rtx expand_builtin_mempcpy (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_mempcpy_args (tree, tree, tree, tree, rtx, \n+static rtx expand_builtin_mempcpy_args (tree, tree, tree, rtx, \n \t\t\t\t\tenum machine_mode, int);\n-static rtx expand_builtin_memmove (tree, rtx, enum machine_mode, int);\n-static rtx expand_builtin_memmove_args (tree, tree, tree, tree, rtx, \n-\t\t\t\t\tenum machine_mode, int);\n-static rtx expand_builtin_bcopy (tree, int);\n-static rtx expand_builtin_strcpy (tree, tree, rtx, enum machine_mode);\n-static rtx expand_builtin_strcpy_args (tree, tree, tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strcpy (tree, rtx);\n+static rtx expand_builtin_strcpy_args (tree, tree, rtx);\n static rtx expand_builtin_stpcpy (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_strncpy (tree, rtx, enum machine_mode);\n+static rtx expand_builtin_strncpy (tree, rtx);\n static rtx builtin_memset_gen_str (void *, HOST_WIDE_INT, enum machine_mode);\n static rtx expand_builtin_memset (tree, rtx, enum machine_mode);\n static rtx expand_builtin_memset_args (tree, tree, tree, rtx, enum machine_mode, tree);\n static rtx expand_builtin_bzero (tree);\n static rtx expand_builtin_strlen (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_strstr (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_strpbrk (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_strchr (tree, rtx, enum machine_mode);\n-static rtx expand_builtin_strrchr (tree, rtx, enum machine_mode);\n static rtx expand_builtin_alloca (tree, rtx);\n static rtx expand_builtin_unop (enum machine_mode, tree, rtx, rtx, optab);\n static rtx expand_builtin_frame_address (tree, tree);\n-static rtx expand_builtin_fputs (tree, rtx, bool);\n static rtx expand_builtin_printf (tree, rtx, enum machine_mode, bool);\n static rtx expand_builtin_fprintf (tree, rtx, enum machine_mode, bool);\n static rtx expand_builtin_sprintf (tree, rtx, enum machine_mode);\n@@ -2248,30 +2234,16 @@ expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n   return target;\n }\n \n-/* Expand a call to one of the builtin math functions that operate on\n-   floating point argument and output an integer result (ilogb, isinf,\n-   isnan, etc).\n-   Return 0 if a normal call should be emitted rather than expanding the\n-   function in-line.  EXP is the expression that is a call to the builtin\n-   function; if convenient, the result should be placed in TARGET.\n-   SUBTARGET may be used as the target for computing one of EXP's operands.  */\n+/* Given an interclass math builtin decl FNDECL and it's argument ARG\n+   return an RTL instruction code that implements the functionality.\n+   If that isn't possible or available return CODE_FOR_nothing.  */\n \n-static rtx\n-expand_builtin_interclass_mathfn (tree exp, rtx target, rtx subtarget)\n+static enum insn_code\n+interclass_mathfn_icode (tree arg, tree fndecl)\n {\n+  bool errno_set = false;\n   optab builtin_optab = 0;\n-  enum insn_code icode = CODE_FOR_nothing;\n-  rtx op0;\n-  tree fndecl = get_callee_fndecl (exp);\n   enum machine_mode mode;\n-  bool errno_set = false;\n-  tree arg;\n-  location_t loc = EXPR_LOCATION (exp);\n-\n-  if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))\n-    return NULL_RTX;\n-\n-  arg = CALL_EXPR_ARG (exp, 0);\n \n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n@@ -2282,6 +2254,12 @@ expand_builtin_interclass_mathfn (tree exp, rtx target, rtx subtarget)\n     case BUILT_IN_ISNORMAL:\n     case BUILT_IN_ISFINITE:\n     CASE_FLT_FN (BUILT_IN_FINITE):\n+    case BUILT_IN_FINITED32:\n+    case BUILT_IN_FINITED64:\n+    case BUILT_IN_FINITED128:\n+    case BUILT_IN_ISINFD32:\n+    case BUILT_IN_ISINFD64:\n+    case BUILT_IN_ISINFD128:\n       /* These builtins have no optabs (yet).  */\n       break;\n     default:\n@@ -2290,15 +2268,40 @@ expand_builtin_interclass_mathfn (tree exp, rtx target, rtx subtarget)\n \n   /* There's no easy way to detect the case we need to set EDOM.  */\n   if (flag_errno_math && errno_set)\n-    return NULL_RTX;\n+    return CODE_FOR_nothing;\n \n   /* Optab mode depends on the mode of the input argument.  */\n   mode = TYPE_MODE (TREE_TYPE (arg));\n \n   if (builtin_optab)\n-    icode = optab_handler (builtin_optab, mode)->insn_code;\n- \n-  /* Before working hard, check whether the instruction is available.  */\n+    return optab_handler (builtin_optab, mode)->insn_code;\n+  return CODE_FOR_nothing;\n+}\n+\n+/* Expand a call to one of the builtin math functions that operate on\n+   floating point argument and output an integer result (ilogb, isinf,\n+   isnan, etc).\n+   Return 0 if a normal call should be emitted rather than expanding the\n+   function in-line.  EXP is the expression that is a call to the builtin\n+   function; if convenient, the result should be placed in TARGET.\n+   SUBTARGET may be used as the target for computing one of EXP's operands.  */\n+\n+static rtx\n+expand_builtin_interclass_mathfn (tree exp, rtx target, rtx subtarget)\n+{\n+  enum insn_code icode = CODE_FOR_nothing;\n+  rtx op0;\n+  tree fndecl = get_callee_fndecl (exp);\n+  enum machine_mode mode;\n+  tree arg;\n+\n+  if (!validate_arglist (exp, REAL_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  arg = CALL_EXPR_ARG (exp, 0);\n+  icode = interclass_mathfn_icode (arg, fndecl);\n+  mode = TYPE_MODE (TREE_TYPE (arg));\n+\n   if (icode != CODE_FOR_nothing)\n     {\n       /* Make a suitable register to place result in.  */\n@@ -2325,71 +2328,7 @@ expand_builtin_interclass_mathfn (tree exp, rtx target, rtx subtarget)\n       return target;\n     }\n \n-  /* If there is no optab, try generic code.  */\n-  switch (DECL_FUNCTION_CODE (fndecl))\n-    {\n-      tree result;\n-\n-    CASE_FLT_FN (BUILT_IN_ISINF):\n-      {\n-\t/* isinf(x) -> isgreater(fabs(x),DBL_MAX).  */\n-\ttree const isgr_fn = built_in_decls[BUILT_IN_ISGREATER];\n-\ttree const type = TREE_TYPE (arg);\n-\tREAL_VALUE_TYPE r;\n-\tchar buf[128];\n-\n-\tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n-\treal_from_string (&r, buf);\n-\tresult = build_call_expr (isgr_fn, 2,\n-\t\t\t\t  fold_build1_loc (loc, ABS_EXPR, type, arg),\n-\t\t\t\t  build_real (type, r));\n-\treturn expand_expr (result, target, VOIDmode, EXPAND_NORMAL);\n-      }\n-    CASE_FLT_FN (BUILT_IN_FINITE):\n-    case BUILT_IN_ISFINITE:\n-      {\n-\t/* isfinite(x) -> islessequal(fabs(x),DBL_MAX).  */\n-\ttree const isle_fn = built_in_decls[BUILT_IN_ISLESSEQUAL];\n-\ttree const type = TREE_TYPE (arg);\n-\tREAL_VALUE_TYPE r;\n-\tchar buf[128];\n-\n-\tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n-\treal_from_string (&r, buf);\n-\tresult = build_call_expr (isle_fn, 2,\n-\t\t\t\t  fold_build1_loc (loc, ABS_EXPR, type, arg),\n-\t\t\t\t  build_real (type, r));\n-\treturn expand_expr (result, target, VOIDmode, EXPAND_NORMAL);\n-      }\n-    case BUILT_IN_ISNORMAL:\n-      {\n-\t/* isnormal(x) -> isgreaterequal(fabs(x),DBL_MIN) &\n-\t   islessequal(fabs(x),DBL_MAX).  */\n-\ttree const isle_fn = built_in_decls[BUILT_IN_ISLESSEQUAL];\n-\ttree const isge_fn = built_in_decls[BUILT_IN_ISGREATEREQUAL];\n-\ttree const type = TREE_TYPE (arg);\n-\tREAL_VALUE_TYPE rmax, rmin;\n-\tchar buf[128];\n-\n-\tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n-\treal_from_string (&rmax, buf);\n-\tsprintf (buf, \"0x1p%d\", REAL_MODE_FORMAT (mode)->emin - 1);\n-\treal_from_string (&rmin, buf);\n-\targ = builtin_save_expr (fold_build1_loc (loc, ABS_EXPR, type, arg));\n-\tresult = build_call_expr (isle_fn, 2, arg,\n-\t\t\t\t  build_real (type, rmax));\n-\tresult = fold_build2 (BIT_AND_EXPR, integer_type_node, result,\n-\t\t\t      build_call_expr (isge_fn, 2, arg,\n-\t\t\t\t\t       build_real (type, rmin)));\n-\treturn expand_expr (result, target, VOIDmode, EXPAND_NORMAL);\n-      }\n-    default:\n-      break;\n-    }\n-\n-  target = expand_call (exp, target, target == const0_rtx);\n-\n-  return target;\n+  return NULL_RTX;\n }\n \n /* Expand a call to the builtin sincos math function.\n@@ -2551,6 +2490,27 @@ expand_builtin_cexpi (tree exp, rtx target, rtx subtarget)\n \t\t      target, VOIDmode, EXPAND_NORMAL);\n }\n \n+/* Conveniently construct a function call expression.  FNDECL names the\n+   function to be called, N is the number of arguments, and the \"...\"\n+   parameters are the argument expressions.  Unlike build_call_exr\n+   this doesn't fold the call, hence it will always return a CALL_EXPR.  */\n+\n+static tree\n+build_call_nofold_loc (location_t loc, tree fndecl, int n, ...)\n+{\n+  va_list ap;\n+  tree fntype = TREE_TYPE (fndecl);\n+  tree fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n+\n+  va_start (ap, n);\n+  fn = build_call_valist (TREE_TYPE (fntype), fn, n, ap);\n+  va_end (ap);\n+  SET_EXPR_LOCATION (fn, loc);\n+  return fn;\n+}\n+#define build_call_nofold(...) \\\n+  build_call_nofold_loc (UNKNOWN_LOCATION, __VA_ARGS__)\n+\n /* Expand a call to one of the builtin rounding functions gcc defines\n    as an extension (lfloor and lceil).  As these are gcc extensions we\n    do not need to worry about setting errno to EDOM.\n@@ -2667,7 +2627,7 @@ expand_builtin_int_roundingfn (tree exp, rtx target)\n       fallback_fndecl = build_fn_decl (name, fntype);\n     }\n \n-  exp = build_call_expr (fallback_fndecl, 1, arg);\n+  exp = build_call_nofold (fallback_fndecl, 1, arg);\n \n   tmp = expand_normal (exp);\n \n@@ -3017,7 +2977,7 @@ expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n \t       && powi_cost (n/2) <= POWI_MAX_MULTS)\n \t      || n == 1))\n \t{\n-\t  tree call_expr = build_call_expr (fn, 1, narg0);\n+\t  tree call_expr = build_call_nofold (fn, 1, narg0);\n \t  /* Use expand_expr in case the newly built call expression\n \t     was folded to a non-call.  */\n \t  op = expand_expr (call_expr, subtarget, mode, EXPAND_NORMAL);\n@@ -3062,7 +3022,7 @@ expand_builtin_pow (tree exp, rtx target, rtx subtarget)\n \t       && powi_cost (n/3) <= POWI_MAX_MULTS)\n \t      || n == 1))\n \t{\n-\t  tree call_expr = build_call_expr (fn, 1,narg0);\n+\t  tree call_expr = build_call_nofold (fn, 1,narg0);\n \t  op = expand_builtin (call_expr, NULL_RTX, subtarget, mode, 0);\n \t  if (abs (n) % 3 == 2)\n \t    op = expand_simple_binop (mode, MULT, op, op, op,\n@@ -3260,84 +3220,6 @@ expand_builtin_strlen (tree exp, rtx target,\n     }\n }\n \n-/* Expand a call to the strstr builtin.  Return NULL_RTX if we failed the\n-   caller should emit a normal call, otherwise try to get the result\n-   in TARGET, if convenient (and in mode MODE if that's convenient).  */\n-\n-static rtx\n-expand_builtin_strstr (tree exp, rtx target, enum machine_mode mode)\n-{\n-  if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    {\n-      tree type = TREE_TYPE (exp);\n-      tree result = fold_builtin_strstr (EXPR_LOCATION (exp),\n-\t\t\t\t\t CALL_EXPR_ARG (exp, 0),\n-\t\t\t\t\t CALL_EXPR_ARG (exp, 1), type);\n-      if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n-  return NULL_RTX;\n-}\n-\n-/* Expand a call to the strchr builtin.  Return NULL_RTX if we failed the\n-   caller should emit a normal call, otherwise try to get the result\n-   in TARGET, if convenient (and in mode MODE if that's convenient).  */\n-\n-static rtx\n-expand_builtin_strchr (tree exp, rtx target, enum machine_mode mode)\n-{\n-  if (validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    {\n-      tree type = TREE_TYPE (exp);\n-      tree result = fold_builtin_strchr (EXPR_LOCATION (exp),\n-\t\t\t\t\t CALL_EXPR_ARG (exp, 0),\n-\t\t\t\t\t CALL_EXPR_ARG (exp, 1), type);\n-      if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-\n-      /* FIXME: Should use strchrM optab so that ports can optimize this.  */\n-    }\n-  return NULL_RTX;\n-}\n-\n-/* Expand a call to the strrchr builtin.  Return NULL_RTX if we failed the\n-   caller should emit a normal call, otherwise try to get the result\n-   in TARGET, if convenient (and in mode MODE if that's convenient).  */\n-\n-static rtx\n-expand_builtin_strrchr (tree exp, rtx target, enum machine_mode mode)\n-{\n-  if (validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    {\n-      tree type = TREE_TYPE (exp);\n-      tree result = fold_builtin_strrchr (EXPR_LOCATION (exp),\n-\t\t\t\t\t  CALL_EXPR_ARG (exp, 0),\n-\t\t\t\t\t  CALL_EXPR_ARG (exp, 1), type);\n-      if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n-  return NULL_RTX;\n-}\n-\n-/* Expand a call to the strpbrk builtin.  Return NULL_RTX if we failed the\n-   caller should emit a normal call, otherwise try to get the result\n-   in TARGET, if convenient (and in mode MODE if that's convenient).  */\n-\n-static rtx\n-expand_builtin_strpbrk (tree exp, rtx target, enum machine_mode mode)\n-{\n-  if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    {\n-      tree type = TREE_TYPE (exp);\n-      tree result = fold_builtin_strpbrk (EXPR_LOCATION (exp),\n-\t\t\t\t\t  CALL_EXPR_ARG (exp, 0),\n-\t\t\t\t\t  CALL_EXPR_ARG (exp, 1), type);\n-      if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n-  return NULL_RTX;\n-}\n-\n /* Callback routine for store_by_pieces.  Read GET_MODE_BITSIZE (MODE)\n    bytes from constant string DATA + OFFSET and return it as target\n    constant.  */\n@@ -3361,10 +3243,8 @@ builtin_memcpy_read_str (void *data, HOST_WIDE_INT offset,\n    mode MODE if that's convenient).  */\n \n static rtx\n-expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n+expand_builtin_memcpy (tree exp, rtx target)\n {\n-  tree fndecl = get_callee_fndecl (exp);\n-\n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n@@ -3378,25 +3258,10 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n       unsigned int dest_align\n \t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n       rtx dest_mem, src_mem, dest_addr, len_rtx;\n-      tree result = fold_builtin_memory_op (EXPR_LOCATION (exp),\n-\t\t\t\t\t    dest, src, len, \n-\t\t\t\t\t    TREE_TYPE (TREE_TYPE (fndecl)),\n-\t\t\t\t\t    false, /*endp=*/0);\n       HOST_WIDE_INT expected_size = -1;\n       unsigned int expected_align = 0;\n       tree_ann_common_t ann;\n \n-      if (result)\n-\t{\n-\t  while (TREE_CODE (result) == COMPOUND_EXPR)\n-\t    {\n-\t      expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,\n-\t\t\t   EXPAND_NORMAL);\n-\t      result = TREE_OPERAND (result, 1);\n-\t    }\n-\t  return expand_expr (result, target, mode, EXPAND_NORMAL);\n-\t}\n-\n       /* If DEST is not a pointer type, call the normal function.  */\n       if (dest_align == 0)\n \treturn NULL_RTX;\n@@ -3431,7 +3296,7 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n \t\t\t\t      builtin_memcpy_read_str,\n \t\t\t\t      CONST_CAST (char *, src_str),\n \t\t\t\t      dest_align, false, 0);\n-\t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+\t  dest_mem = force_operand (XEXP (dest_mem, 0), target);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n \t}\n@@ -3447,7 +3312,7 @@ expand_builtin_memcpy (tree exp, rtx target, enum machine_mode mode)\n \n       if (dest_addr == 0)\n \t{\n-\t  dest_addr = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+\t  dest_addr = force_operand (XEXP (dest_mem, 0), target);\n \t  dest_addr = convert_memory_address (ptr_mode, dest_addr);\n \t}\n       return dest_addr;\n@@ -3474,33 +3339,25 @@ expand_builtin_mempcpy (tree exp, rtx target, enum machine_mode mode)\n       tree src = CALL_EXPR_ARG (exp, 1);\n       tree len = CALL_EXPR_ARG (exp, 2);\n       return expand_builtin_mempcpy_args (dest, src, len,\n-\t\t\t\t\t  TREE_TYPE (exp),\n \t\t\t\t\t  target, mode, /*endp=*/ 1);\n     }\n }\n \n /* Helper function to do the actual work for expand_builtin_mempcpy.  The\n    arguments to the builtin_mempcpy call DEST, SRC, and LEN are broken out\n    so that this can also be called without constructing an actual CALL_EXPR.\n-   TYPE is the return type of the call.  The other arguments and return value\n-   are the same as for expand_builtin_mempcpy.  */\n+   The other arguments and return value are the same as for\n+   expand_builtin_mempcpy.  */\n \n static rtx\n-expand_builtin_mempcpy_args (tree dest, tree src, tree len, tree type,\n+expand_builtin_mempcpy_args (tree dest, tree src, tree len,\n \t\t\t     rtx target, enum machine_mode mode, int endp)\n {\n     /* If return value is ignored, transform mempcpy into memcpy.  */\n   if (target == const0_rtx && implicit_built_in_decls[BUILT_IN_MEMCPY])\n     {\n       tree fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n-      tree result = build_call_expr (fn, 3, dest, src, len);\n-\n-      while (TREE_CODE (result) == COMPOUND_EXPR)\n-\t{\n-\t  expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,\n-\t\t       EXPAND_NORMAL);\n-\t  result = TREE_OPERAND (result, 1);\n-\t}\n+      tree result = build_call_nofold (fn, 3, dest, src, len);\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n   else\n@@ -3510,19 +3367,6 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len, tree type,\n       unsigned int dest_align\n \t= get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n       rtx dest_mem, src_mem, len_rtx;\n-      tree result = fold_builtin_memory_op (UNKNOWN_LOCATION,\n-\t\t\t\t\t    dest, src, len, type, false, endp);\n-\n-      if (result)\n-\t{\n-\t  while (TREE_CODE (result) == COMPOUND_EXPR)\n-\t    {\n-\t      expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,\n-\t\t\t   EXPAND_NORMAL);\n-\t      result = TREE_OPERAND (result, 1);\n-\t    }\n-\t  return expand_expr (result, target, mode, EXPAND_NORMAL);\n-\t}\n \n       /* If either SRC or DEST is not a pointer type, don't do this\n \t operation in-line.  */\n@@ -3576,82 +3420,6 @@ expand_builtin_mempcpy_args (tree dest, tree src, tree len, tree type,\n     }\n }\n \n-/* Expand expression EXP, which is a call to the memmove builtin.  Return \n-   NULL_RTX if we failed; the caller should emit a normal call.  */\n-\n-static rtx\n-expand_builtin_memmove (tree exp, rtx target, enum machine_mode mode, int ignore)\n-{\n-  if (!validate_arglist (exp,\n- \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    return NULL_RTX;\n-  else\n-    {\n-      tree dest = CALL_EXPR_ARG (exp, 0);\n-      tree src = CALL_EXPR_ARG (exp, 1);\n-      tree len = CALL_EXPR_ARG (exp, 2);\n-      return expand_builtin_memmove_args (dest, src, len, TREE_TYPE (exp), \n-\t\t\t\t\t  target, mode, ignore);\n-    }\n-}\n-\n-/* Helper function to do the actual work for expand_builtin_memmove.  The\n-   arguments to the builtin_memmove call DEST, SRC, and LEN are broken out\n-   so that this can also be called without constructing an actual CALL_EXPR.\n-   TYPE is the return type of the call.  The other arguments and return value\n-   are the same as for expand_builtin_memmove.  */\n-\n-static rtx\n-expand_builtin_memmove_args (tree dest, tree src, tree len,\n-\t\t\t     tree type, rtx target, enum machine_mode mode, \n-                             int ignore)\n-{\n-  tree result = fold_builtin_memory_op (UNKNOWN_LOCATION,\n-\t\t\t\t\tdest, src, len, type, ignore, /*endp=*/3);\n-\n-  if (result)\n-    {\n-      STRIP_TYPE_NOPS (result);\n-      while (TREE_CODE (result) == COMPOUND_EXPR)\n-\t{\n-\t  expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,\n-\t\t       EXPAND_NORMAL);\n-\t  result = TREE_OPERAND (result, 1);\n-\t}\n-      return expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n-  \n-  /* Otherwise, call the normal function.  */\n-  return NULL_RTX;\n-}\n-\n-/* Expand expression EXP, which is a call to the bcopy builtin.  Return \n-   NULL_RTX if we failed the caller should emit a normal call.  */\n-\n-static rtx\n-expand_builtin_bcopy (tree exp, int ignore)\n-{\n-  tree type = TREE_TYPE (exp);\n-  tree src, dest, size;\n-  location_t loc = EXPR_LOCATION (exp);\n-\n-  if (!validate_arglist (exp,\n- \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    return NULL_RTX;\n-\n-  src = CALL_EXPR_ARG (exp, 0);\n-  dest = CALL_EXPR_ARG (exp, 1);\n-  size = CALL_EXPR_ARG (exp, 2);\n-\n-  /* Transform bcopy(ptr x, ptr y, int z) to memmove(ptr y, ptr x, size_t z).\n-     This is done this way so that if it isn't expanded inline, we fall\n-     back to calling bcopy instead of memmove.  */\n-  return expand_builtin_memmove_args (dest, src,\n- \t\t\t\t      fold_convert_loc (loc, sizetype, size),\n- \t\t\t\t      type, const0_rtx, VOIDmode, \n-\t\t\t\t      ignore);\n-}\n-\n #ifndef HAVE_movstr\n # define HAVE_movstr 0\n # define CODE_FOR_movstr CODE_FOR_nothing\n@@ -3725,13 +3493,13 @@ expand_movstr (tree dest, tree src, rtx target, int endp)\n    convenient).  */\n \n static rtx\n-expand_builtin_strcpy (tree fndecl, tree exp, rtx target, enum machine_mode mode)\n+expand_builtin_strcpy (tree exp, rtx target)\n {\n   if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n    {\n      tree dest = CALL_EXPR_ARG (exp, 0);\n      tree src = CALL_EXPR_ARG (exp, 1);\n-     return expand_builtin_strcpy_args (fndecl, dest, src, target, mode);\n+     return expand_builtin_strcpy_args (dest, src, target);\n    }\n    return NULL_RTX;\n }\n@@ -3743,15 +3511,9 @@ expand_builtin_strcpy (tree fndecl, tree exp, rtx target, enum machine_mode mode\n    expand_builtin_strcpy.  */\n \n static rtx\n-expand_builtin_strcpy_args (tree fndecl, tree dest, tree src,\n-\t\t\t    rtx target, enum machine_mode mode)\n+expand_builtin_strcpy_args (tree dest, tree src, rtx target)\n {\n-  tree result = fold_builtin_strcpy (UNKNOWN_LOCATION,\n-\t\t\t\t     fndecl, dest, src, 0);\n-  if (result)\n-    return expand_expr (result, target, mode, EXPAND_NORMAL);\n   return expand_movstr (dest, src, target, /*endp=*/0);\n-\n }\n \n /* Expand a call EXP to the stpcpy builtin.\n@@ -3775,15 +3537,7 @@ expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)\n   if (target == const0_rtx && implicit_built_in_decls[BUILT_IN_STRCPY])\n     {\n       tree fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n-      tree result = build_call_expr (fn, 2, dst, src);\n-\n-      STRIP_NOPS (result);\n-      while (TREE_CODE (result) == COMPOUND_EXPR)\n-\t{\n-\t  expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,\n-\t\t       EXPAND_NORMAL);\n-\t  result = TREE_OPERAND (result, 1);\n-\t}\n+      tree result = build_call_nofold (fn, 2, dst, src);\n       return expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n   else\n@@ -3799,7 +3553,7 @@ expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)\n \treturn expand_movstr (dst, src, target, /*endp=*/2);\n \n       lenp1 = size_binop_loc (loc, PLUS_EXPR, len, ssize_int (1));\n-      ret = expand_builtin_mempcpy_args (dst, src, lenp1, TREE_TYPE (exp),\n+      ret = expand_builtin_mempcpy_args (dst, src, lenp1,\n  \t\t\t\t\t target, mode, /*endp=*/2);\n \n       if (ret)\n@@ -3811,8 +3565,7 @@ expand_builtin_stpcpy (tree exp, rtx target, enum machine_mode mode)\n \n \t  if (CONST_INT_P (len_rtx))\n \t    {\n-\t      ret = expand_builtin_strcpy_args (get_callee_fndecl (exp),\n-\t\t\t\t\t\tdst, src, target, mode);\n+\t      ret = expand_builtin_strcpy_args (dst, src, target);\n \n \t      if (ret)\n \t\t{\n@@ -3859,9 +3612,8 @@ builtin_strncpy_read_str (void *data, HOST_WIDE_INT offset,\n    NULL_RTX if we failed the caller should emit a normal call.  */\n \n static rtx\n-expand_builtin_strncpy (tree exp, rtx target, enum machine_mode mode)\n+expand_builtin_strncpy (tree exp, rtx target)\n {\n-  tree fndecl = get_callee_fndecl (exp);\n   location_t loc = EXPR_LOCATION (exp);\n \n   if (validate_arglist (exp,\n@@ -3871,19 +3623,6 @@ expand_builtin_strncpy (tree exp, rtx target, enum machine_mode mode)\n       tree src = CALL_EXPR_ARG (exp, 1);\n       tree len = CALL_EXPR_ARG (exp, 2);\n       tree slen = c_strlen (src, 1);\n-      tree result = fold_builtin_strncpy (EXPR_LOCATION (exp),\n-\t\t\t\t\t  fndecl, dest, src, len, slen);\n-\n-      if (result)\n-\t{\n-\t  while (TREE_CODE (result) == COMPOUND_EXPR)\n-\t    {\n-\t      expand_expr (TREE_OPERAND (result, 0), const0_rtx, VOIDmode,\n-\t\t\t   EXPAND_NORMAL);\n-\t      result = TREE_OPERAND (result, 1);\n-\t    }\n-\t  return expand_expr (result, target, mode, EXPAND_NORMAL);\n-\t}\n \n       /* We must be passed a constant len and src parameter.  */\n       if (!host_integerp (len, 1) || !slen || !host_integerp (slen, 1))\n@@ -3912,7 +3651,7 @@ expand_builtin_strncpy (tree exp, rtx target, enum machine_mode mode)\n \t  store_by_pieces (dest_mem, tree_low_cst (len, 1),\n \t\t\t   builtin_strncpy_read_str,\n \t\t\t   CONST_CAST (char *, p), dest_align, false, 0);\n-\t  dest_mem = force_operand (XEXP (dest_mem, 0), NULL_RTX);\n+\t  dest_mem = force_operand (XEXP (dest_mem, 0), target);\n \t  dest_mem = convert_memory_address (ptr_mode, dest_mem);\n \t  return dest_mem;\n \t}\n@@ -4102,13 +3841,13 @@ expand_builtin_memset_args (tree dest, tree val, tree len,\n   fndecl = get_callee_fndecl (orig_exp);\n   fcode = DECL_FUNCTION_CODE (fndecl);\n   if (fcode == BUILT_IN_MEMSET)\n-    fn = build_call_expr (fndecl, 3, dest, val, len);\n+    fn = build_call_nofold (fndecl, 3, dest, val, len);\n   else if (fcode == BUILT_IN_BZERO)\n-    fn = build_call_expr (fndecl, 2, dest, len);\n+    fn = build_call_nofold (fndecl, 2, dest, len);\n   else\n     gcc_unreachable ();\n-  if (TREE_CODE (fn) == CALL_EXPR)\n-    CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (orig_exp);\n+  gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n+  CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (orig_exp);\n   return expand_call (fn, target, target == const0_rtx);\n }\n \n@@ -4137,49 +3876,20 @@ expand_builtin_bzero (tree exp)\n \t\t\t\t     const0_rtx, VOIDmode, exp);\n }\n \n-/* Expand a call to the memchr builtin.  Return NULL_RTX if we failed the\n-   caller should emit a normal call, otherwise try to get the result\n-   in TARGET, if convenient (and in mode MODE if that's convenient).  */\n-\n-static rtx\n-expand_builtin_memchr (tree exp, rtx target, enum machine_mode mode)\n-{\n-  if (validate_arglist (exp, POINTER_TYPE, INTEGER_TYPE,\n-\t\t\tINTEGER_TYPE, VOID_TYPE))\n-    {\n-      tree type = TREE_TYPE (exp);\n-      tree result = fold_builtin_memchr (EXPR_LOCATION (exp),\n-\t\t\t\t\t CALL_EXPR_ARG (exp, 0),\n-\t\t\t\t\t CALL_EXPR_ARG (exp, 1),\n-\t\t\t\t\t CALL_EXPR_ARG (exp, 2), type);\n-      if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n-  return NULL_RTX;\n-}\n-\n /* Expand expression EXP, which is a call to the memcmp built-in function.\n    Return NULL_RTX if we failed and the\n    caller should emit a normal call, otherwise try to get the result in\n    TARGET, if convenient (and in mode MODE, if that's convenient).  */\n \n static rtx\n-expand_builtin_memcmp (tree exp, rtx target, enum machine_mode mode)\n+expand_builtin_memcmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n+\t\t       ATTRIBUTE_UNUSED enum machine_mode mode)\n {\n-  location_t loc = EXPR_LOCATION (exp);\n+  location_t loc ATTRIBUTE_UNUSED = EXPR_LOCATION (exp);\n \n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n-  else\n-    {\n-      tree result = fold_builtin_memcmp (loc,\n-\t\t\t\t\t CALL_EXPR_ARG (exp, 0),\n- \t\t\t\t\t CALL_EXPR_ARG (exp, 1),\n- \t\t\t\t\t CALL_EXPR_ARG (exp, 2));\n-      if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n \n #if defined HAVE_cmpmemsi || defined HAVE_cmpstrnsi\n   {\n@@ -4277,20 +3987,10 @@ expand_builtin_memcmp (tree exp, rtx target, enum machine_mode mode)\n    the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n+expand_builtin_strcmp (tree exp, ATTRIBUTE_UNUSED rtx target)\n {\n-  location_t loc = EXPR_LOCATION (exp);\n-\n   if (!validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n-  else\n-    {\n-      tree result = fold_builtin_strcmp (loc,\n-\t\t\t\t\t CALL_EXPR_ARG (exp, 0),\n- \t\t\t\t\t CALL_EXPR_ARG (exp, 1));\n-      if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n \n #if defined HAVE_cmpstrsi || defined HAVE_cmpstrnsi\n   if (cmpstr_optab[SImode] != CODE_FOR_nothing\n@@ -4397,6 +4097,7 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n \n       if (insn)\n \t{\n+\t  enum machine_mode mode;\n \t  emit_insn (insn);\n \n \t  /* Return the value in the proper mode for this function.  */\n@@ -4415,9 +4116,9 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n     do_libcall:\n #endif\n       fndecl = get_callee_fndecl (exp);\n-      fn = build_call_expr (fndecl, 2, arg1, arg2);\n-      if (TREE_CODE (fn) == CALL_EXPR)\n-\tCALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n+      fn = build_call_nofold (fndecl, 2, arg1, arg2);\n+      gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n+      CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n       return expand_call (fn, target, target == const0_rtx);\n     }\n #endif\n@@ -4429,22 +4130,14 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n    the result in TARGET, if convenient.  */\n \n static rtx\n-expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n+expand_builtin_strncmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n+\t\t\tATTRIBUTE_UNUSED enum machine_mode mode)\n {\n-  location_t loc = EXPR_LOCATION (exp);\n+  location_t loc ATTRIBUTE_UNUSED = EXPR_LOCATION (exp);\n \n   if (!validate_arglist (exp,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n-  else\n-    {\n-      tree result = fold_builtin_strncmp (loc,\n-\t\t\t\t\t  CALL_EXPR_ARG (exp, 0),\n- \t\t\t\t\t  CALL_EXPR_ARG (exp, 1),\n- \t\t\t\t\t  CALL_EXPR_ARG (exp, 2));\n-      if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n \n   /* If c_strlen can determine an expression for one of the string\n      lengths, and it doesn't have side effects, then emit cmpstrnsi\n@@ -4518,155 +4211,39 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n \t   && REGNO (result) >= FIRST_PSEUDO_REGISTER))\n       result = gen_reg_rtx (insn_mode);\n \n-    /* Stabilize the arguments in case gen_cmpstrnsi fails.  */\n-    arg1 = builtin_save_expr (arg1);\n-    arg2 = builtin_save_expr (arg2);\n-    len = builtin_save_expr (len);\n-\n-    arg1_rtx = get_memory_rtx (arg1, len);\n-    arg2_rtx = get_memory_rtx (arg2, len);\n-    arg3_rtx = expand_normal (len);\n-    insn = gen_cmpstrnsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n-\t\t\t  GEN_INT (MIN (arg1_align, arg2_align)));\n-    if (insn)\n-      {\n-\temit_insn (insn);\n-\n-\t/* Return the value in the proper mode for this function.  */\n-\tmode = TYPE_MODE (TREE_TYPE (exp));\n-\tif (GET_MODE (result) == mode)\n-\t  return result;\n-\tif (target == 0)\n-\t  return convert_to_mode (mode, result, 0);\n-\tconvert_move (target, result, 0);\n-\treturn target;\n-      }\n-\n-    /* Expand the library call ourselves using a stabilized argument\n-       list to avoid re-evaluating the function's arguments twice.  */\n-    fndecl = get_callee_fndecl (exp);\n-    fn = build_call_expr (fndecl, 3, arg1, arg2, len);\n-    if (TREE_CODE (fn) == CALL_EXPR)\n-      CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n-    return expand_call (fn, target, target == const0_rtx);\n-  }\n-#endif\n-  return NULL_RTX;\n-}\n-\n-/* Expand expression EXP, which is a call to the strcat builtin.\n-   Return NULL_RTX if we failed the caller should emit a normal call,\n-   otherwise try to get the result in TARGET, if convenient.  */\n-\n-static rtx\n-expand_builtin_strcat (tree fndecl, tree exp, rtx target, enum machine_mode mode)\n-{\n-  location_t loc = EXPR_LOCATION (exp);\n-\n-  if (!validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    return NULL_RTX;\n-  else\n-    {\n-      tree dst = CALL_EXPR_ARG (exp, 0);\n-      tree src = CALL_EXPR_ARG (exp, 1);\n-      const char *p = c_getstr (src);\n-\n-      /* If the string length is zero, return the dst parameter.  */\n-      if (p && *p == '\\0')\n-\treturn expand_expr (dst, target, mode, EXPAND_NORMAL);\n-\n-      if (optimize_insn_for_speed_p ())\n-\t{\n-\t  /* See if we can store by pieces into (dst + strlen(dst)).  */\n-\t  tree newsrc, newdst,\n-\t    strlen_fn = implicit_built_in_decls[BUILT_IN_STRLEN];\n-\t  rtx insns;\n-\n-\t  /* Stabilize the argument list.  */\n-\t  newsrc = builtin_save_expr (src);\n-\t  dst = builtin_save_expr (dst);\n-\n-\t  start_sequence ();\n-\n-\t  /* Create strlen (dst).  */\n-\t  newdst = build_call_expr (strlen_fn, 1, dst);\n-\t  /* Create (dst p+ strlen (dst)).  */\n-\n-\t  newdst = fold_build2_loc (loc, POINTER_PLUS_EXPR,\n-\t\t\t\tTREE_TYPE (dst), dst, newdst);\n-\t  newdst = builtin_save_expr (newdst);\n-\n-\t  if (!expand_builtin_strcpy_args (fndecl, newdst, newsrc, target, mode))\n-\t    {\n-\t      end_sequence (); /* Stop sequence.  */\n-\t      return NULL_RTX;\n-\t    }\n-\n-\t  /* Output the entire sequence.  */\n-\t  insns = get_insns ();\n-\t  end_sequence ();\n-\t  emit_insn (insns);\n-\n-\t  return expand_expr (dst, target, mode, EXPAND_NORMAL);\n-\t}\n-\n-      return NULL_RTX;\n-    }\n-}\n-\n-/* Expand expression EXP, which is a call to the strncat builtin.\n-   Return NULL_RTX if we failed the caller should emit a normal call,\n-   otherwise try to get the result in TARGET, if convenient.  */\n-\n-static rtx\n-expand_builtin_strncat (tree exp, rtx target, enum machine_mode mode)\n-{\n-  if (validate_arglist (exp,\n- \t\t\tPOINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n-    {\n-      tree result = fold_builtin_strncat (EXPR_LOCATION (exp),\n-\t\t\t\t\t  CALL_EXPR_ARG (exp, 0),\n-\t\t\t\t\t  CALL_EXPR_ARG (exp, 1),\n-\t\t\t\t\t  CALL_EXPR_ARG (exp, 2));\n-      if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n-  return NULL_RTX;\n-}\n-\n-/* Expand expression EXP, which is a call to the strspn builtin.\n-   Return NULL_RTX if we failed the caller should emit a normal call,\n-   otherwise try to get the result in TARGET, if convenient.  */\n+    /* Stabilize the arguments in case gen_cmpstrnsi fails.  */\n+    arg1 = builtin_save_expr (arg1);\n+    arg2 = builtin_save_expr (arg2);\n+    len = builtin_save_expr (len);\n \n-static rtx\n-expand_builtin_strspn (tree exp, rtx target, enum machine_mode mode)\n-{\n-  if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    {\n-      tree result = fold_builtin_strspn (EXPR_LOCATION (exp),\n-\t\t\t\t\t CALL_EXPR_ARG (exp, 0),\n-\t\t\t\t\t CALL_EXPR_ARG (exp, 1));\n-      if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n-  return NULL_RTX;\n-}\n+    arg1_rtx = get_memory_rtx (arg1, len);\n+    arg2_rtx = get_memory_rtx (arg2, len);\n+    arg3_rtx = expand_normal (len);\n+    insn = gen_cmpstrnsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n+\t\t\t  GEN_INT (MIN (arg1_align, arg2_align)));\n+    if (insn)\n+      {\n+\temit_insn (insn);\n \n-/* Expand expression EXP, which is a call to the strcspn builtin.\n-   Return NULL_RTX if we failed the caller should emit a normal call,\n-   otherwise try to get the result in TARGET, if convenient.  */\n+\t/* Return the value in the proper mode for this function.  */\n+\tmode = TYPE_MODE (TREE_TYPE (exp));\n+\tif (GET_MODE (result) == mode)\n+\t  return result;\n+\tif (target == 0)\n+\t  return convert_to_mode (mode, result, 0);\n+\tconvert_move (target, result, 0);\n+\treturn target;\n+      }\n \n-static rtx\n-expand_builtin_strcspn (tree exp, rtx target, enum machine_mode mode)\n-{\n-  if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    {\n-      tree result = fold_builtin_strcspn (EXPR_LOCATION (exp),\n-\t\t\t\t\t  CALL_EXPR_ARG (exp, 0),\n-\t\t\t\t\t  CALL_EXPR_ARG (exp, 1));\n-      if (result)\n-\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n-    }\n+    /* Expand the library call ourselves using a stabilized argument\n+       list to avoid re-evaluating the function's arguments twice.  */\n+    fndecl = get_callee_fndecl (exp);\n+    fn = build_call_nofold (fndecl, 3, arg1, arg2, len);\n+    gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n+    CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n+    return expand_call (fn, target, target == const0_rtx);\n+  }\n+#endif\n   return NULL_RTX;\n }\n \n@@ -5297,26 +4874,6 @@ expand_builtin_unop (enum machine_mode target_mode, tree exp, rtx target,\n   return convert_to_mode (target_mode, target, 0);\n }\n \n-/* If the string passed to fputs is a constant and is one character\n-   long, we attempt to transform this call into __builtin_fputc().  */\n-\n-static rtx\n-expand_builtin_fputs (tree exp, rtx target, bool unlocked)\n-{\n-  /* Verify the arguments in the original call.  */\n-  if (validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n-    {\n-      tree result = fold_builtin_fputs (EXPR_LOCATION (exp),\n-\t\t\t\t\tCALL_EXPR_ARG (exp, 0),\n- \t\t\t\t\tCALL_EXPR_ARG (exp, 1),\n-\t\t\t\t\t(target == const0_rtx),\n-\t\t\t\t\tunlocked, NULL_TREE);\n-      if (result)\n-\treturn expand_expr (result, target, VOIDmode, EXPAND_NORMAL);\n-    }\n-  return NULL_RTX;\n-}\n-\n /* Expand a call to __builtin_expect.  We just return our argument \n    as the builtin_expect semantic should've been already executed by\n    tree branch prediction pass. */\n@@ -5476,7 +5033,7 @@ expand_builtin_printf (tree exp, rtx target, enum machine_mode mode,\n \t  || ! POINTER_TYPE_P (TREE_TYPE (CALL_EXPR_ARG (exp, 1))))\n \treturn NULL_RTX;\n       if (fn_puts)\n-\tfn = build_call_expr (fn_puts, 1, CALL_EXPR_ARG (exp, 1));\n+\tfn = build_call_nofold (fn_puts, 1, CALL_EXPR_ARG (exp, 1));\n     }\n   /* If the format specifier was \"%c\", call __builtin_putchar(arg).  */\n   else if (strcmp (fmt_str, target_percent_c) == 0)\n@@ -5485,7 +5042,7 @@ expand_builtin_printf (tree exp, rtx target, enum machine_mode mode,\n \t  || TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (exp, 1))) != INTEGER_TYPE)\n \treturn NULL_RTX;\n       if (fn_putchar)\n-\tfn = build_call_expr (fn_putchar, 1, CALL_EXPR_ARG (exp, 1));\n+\tfn = build_call_nofold (fn_putchar, 1, CALL_EXPR_ARG (exp, 1));\n     }\n   else\n     {\n@@ -5507,7 +5064,7 @@ expand_builtin_printf (tree exp, rtx target, enum machine_mode mode,\n \t     function.  */\n \t  arg = build_int_cst (NULL_TREE, fmt_str[0]);\n \t  if (fn_putchar)\n-\t    fn = build_call_expr (fn_putchar, 1, arg);\n+\t    fn = build_call_nofold (fn_putchar, 1, arg);\n \t}\n       else\n \t{\n@@ -5522,7 +5079,7 @@ expand_builtin_printf (tree exp, rtx target, enum machine_mode mode,\n \t      newstr[len - 1] = 0;\n \t      arg = build_string_literal (len, newstr);\n \t      if (fn_puts)\n-\t\tfn = build_call_expr (fn_puts, 1, arg);\n+\t\tfn = build_call_nofold (fn_puts, 1, arg);\n \t    }\n \t  else\n \t    /* We'd like to arrange to call fputs(string,stdout) here,\n@@ -5533,8 +5090,8 @@ expand_builtin_printf (tree exp, rtx target, enum machine_mode mode,\n \n   if (!fn)\n     return NULL_RTX;\n-  if (TREE_CODE (fn) == CALL_EXPR)\n-    CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n+  gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n+  CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n   return expand_expr (fn, target, mode, EXPAND_NORMAL);\n }\n \n@@ -5588,7 +5145,7 @@ expand_builtin_fprintf (tree exp, rtx target, enum machine_mode mode,\n \treturn NULL_RTX;\n       arg = CALL_EXPR_ARG (exp, 2);\n       if (fn_fputs)\n-\tfn = build_call_expr (fn_fputs, 2, arg, fp);\n+\tfn = build_call_nofold (fn_fputs, 2, arg, fp);\n     }\n   /* If the format specifier was \"%c\", call __builtin_fputc(arg,fp).  */\n   else if (strcmp (fmt_str, target_percent_c) == 0)\n@@ -5598,7 +5155,7 @@ expand_builtin_fprintf (tree exp, rtx target, enum machine_mode mode,\n \treturn NULL_RTX;\n       arg = CALL_EXPR_ARG (exp, 2);\n       if (fn_fputc)\n-\tfn = build_call_expr (fn_fputc, 2, arg, fp);\n+\tfn = build_call_nofold (fn_fputc, 2, arg, fp);\n     }\n   else\n     {\n@@ -5621,13 +5178,13 @@ expand_builtin_fprintf (tree exp, rtx target, enum machine_mode mode,\n \t fprintf(stream,string) with fputs(string,stream).  The fputs\n \t builtin will take care of special cases like length == 1.  */\n       if (fn_fputs)\n-\tfn = build_call_expr (fn_fputs, 2, fmt, fp);\n+\tfn = build_call_nofold (fn_fputs, 2, fmt, fp);\n     }\n \n   if (!fn)\n     return NULL_RTX;\n-  if (TREE_CODE (fn) == CALL_EXPR)\n-    CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n+  gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n+  CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n   return expand_expr (fn, target, mode, EXPAND_NORMAL);\n }\n \n@@ -5669,7 +5226,7 @@ expand_builtin_sprintf (tree exp, rtx target, enum machine_mode mode)\n \n       if ((nargs > 2) || ! fn)\n \treturn NULL_RTX;\n-      expand_expr (build_call_expr (fn, 2, dest, fmt),\n+      expand_expr (build_call_nofold (fn, 2, dest, fmt),\n \t\t   const0_rtx, VOIDmode, EXPAND_NORMAL);\n       if (target == const0_rtx)\n \treturn const0_rtx;\n@@ -5699,7 +5256,7 @@ expand_builtin_sprintf (tree exp, rtx target, enum machine_mode mode)\n       else\n \tlen = NULL_TREE;\n \n-      expand_expr (build_call_expr (fn, 2, dest, arg),\n+      expand_expr (build_call_nofold (fn, 2, dest, arg),\n \t\t   const0_rtx, VOIDmode, EXPAND_NORMAL);\n \n       if (target == const0_rtx)\n@@ -6650,13 +6207,13 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       break;\n \n     case BUILT_IN_STRCPY:\n-      target = expand_builtin_strcpy (fndecl, exp, target, mode);\n+      target = expand_builtin_strcpy (exp, target);\n       if (target)\n \treturn target;\n       break;\n \n     case BUILT_IN_STRNCPY:\n-      target = expand_builtin_strncpy (exp, target, mode);\n+      target = expand_builtin_strncpy (exp, target);\n       if (target)\n \treturn target;\n       break;\n@@ -6667,58 +6224,8 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \treturn target;\n       break;\n \n-    case BUILT_IN_STRCAT:\n-      target = expand_builtin_strcat (fndecl, exp, target, mode);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_STRNCAT:\n-      target = expand_builtin_strncat (exp, target, mode);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_STRSPN:\n-      target = expand_builtin_strspn (exp, target, mode);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_STRCSPN:\n-      target = expand_builtin_strcspn (exp, target, mode);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_STRSTR:\n-      target = expand_builtin_strstr (exp, target, mode);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_STRPBRK:\n-      target = expand_builtin_strpbrk (exp, target, mode);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_INDEX:\n-    case BUILT_IN_STRCHR:\n-      target = expand_builtin_strchr (exp, target, mode);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_RINDEX:\n-    case BUILT_IN_STRRCHR:\n-      target = expand_builtin_strrchr (exp, target, mode);\n-      if (target)\n-\treturn target;\n-      break;\n-\n     case BUILT_IN_MEMCPY:\n-      target = expand_builtin_memcpy (exp, target, mode);\n+      target = expand_builtin_memcpy (exp, target);\n       if (target)\n \treturn target;\n       break;\n@@ -6729,18 +6236,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \treturn target;\n       break;\n \n-    case BUILT_IN_MEMMOVE:\n-      target = expand_builtin_memmove (exp, target, mode, ignore);\n-      if (target)\n-\treturn target;\n-      break;\n-\n-    case BUILT_IN_BCOPY:\n-      target = expand_builtin_bcopy (exp, ignore);\n-      if (target)\n-\treturn target;\n-      break;\n-\n     case BUILT_IN_MEMSET:\n       target = expand_builtin_memset (exp, target, mode);\n       if (target)\n@@ -6754,7 +6249,7 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       break;\n \n     case BUILT_IN_STRCMP:\n-      target = expand_builtin_strcmp (exp, target, mode);\n+      target = expand_builtin_strcmp (exp, target);\n       if (target)\n \treturn target;\n       break;\n@@ -6765,12 +6260,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \treturn target;\n       break;\n \n-    case BUILT_IN_MEMCHR:\n-      target = expand_builtin_memchr (exp, target, mode);\n-      if (target)\n-\treturn target;\n-      break;\n-\n     case BUILT_IN_BCMP:\n     case BUILT_IN_MEMCMP:\n       target = expand_builtin_memcmp (exp, target, mode);\n@@ -6891,17 +6380,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \treturn target;\n       break;\n \n-    case BUILT_IN_FPUTS:\n-      target = expand_builtin_fputs (exp, target, false);\n-      if (target)\n-\treturn target;\n-      break;\n-    case BUILT_IN_FPUTS_UNLOCKED:\n-      target = expand_builtin_fputs (exp, target, true);\n-      if (target)\n-\treturn target;\n-      break;\n-\n     case BUILT_IN_FPRINTF:\n       target = expand_builtin_fprintf (exp, target, mode, false);\n       if (target)\n@@ -9302,6 +8780,46 @@ fold_builtin_strcpy (location_t loc, tree fndecl, tree dest, tree src, tree len)\n \t\t\t   build_call_expr_loc (loc, fn, 3, dest, src, len));\n }\n \n+/* Fold function call to builtin stpcpy with arguments DEST and SRC.\n+   Return NULL_TREE if no simplification can be made.  */\n+\n+static tree\n+fold_builtin_stpcpy (location_t loc, tree fndecl, tree dest, tree src)\n+{\n+  tree fn, len, lenp1, call, type;\n+\n+  if (!validate_arg (dest, POINTER_TYPE)\n+      || !validate_arg (src, POINTER_TYPE))\n+    return NULL_TREE;\n+\n+  len = c_strlen (src, 1);\n+  if (!len\n+      || TREE_CODE (len) != INTEGER_CST)\n+    return NULL_TREE;\n+\n+  if (optimize_function_for_size_p (cfun)\n+      /* If length is zero it's small enough.  */\n+      && !integer_zerop (len))\n+    return NULL_TREE;\n+\n+  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+  if (!fn)\n+    return NULL_TREE;\n+\n+  lenp1 = size_binop_loc (loc, PLUS_EXPR, len, ssize_int (1));\n+  /* We use dest twice in building our expression.  Save it from\n+     multiple expansions.  */\n+  dest = builtin_save_expr (dest);\n+  call = build_call_expr_loc (loc, fn, 3, dest, src, lenp1);\n+\n+  type = TREE_TYPE (TREE_TYPE (fndecl));\n+  len = fold_convert_loc (loc, sizetype, len);\n+  dest = fold_build2_loc (loc, POINTER_PLUS_EXPR, TREE_TYPE (dest), dest, len);\n+  dest = fold_convert_loc (loc, type, dest);\n+  dest = omit_one_operand_loc (loc, type, dest, call);\n+  return dest;\n+}\n+\n /* Fold function call to builtin strncpy with arguments DEST, SRC, and LEN.\n    If SLEN is not NULL, it represents the length of the source string.\n    Return NULL_TREE if no simplification can be made.  */\n@@ -10104,6 +9622,96 @@ fold_builtin_modf (location_t loc, tree arg0, tree arg1, tree rettype)\n   return NULL_TREE;\n }\n \n+/* Given a location LOC, an interclass builtin function decl FNDECL\n+   and its single argument ARG, return an folded expression computing\n+   the same, or NULL_TREE if we either couldn't or didn't want to fold\n+   (the latter happen if there's an RTL instruction available).  */\n+\n+static tree\n+fold_builtin_interclass_mathfn (location_t loc, tree fndecl, tree arg)\n+{\n+  enum machine_mode mode;\n+\n+  if (!validate_arg (arg, REAL_TYPE))\n+    return NULL_TREE;\n+\n+  if (interclass_mathfn_icode (arg, fndecl) != CODE_FOR_nothing)\n+    return NULL_TREE;\n+\n+  mode = TYPE_MODE (TREE_TYPE (arg));\n+\n+  /* If there is no optab, try generic code.  */\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+      tree result;\n+\n+    CASE_FLT_FN (BUILT_IN_ISINF):\n+      {\n+\t/* isinf(x) -> isgreater(fabs(x),DBL_MAX).  */\n+\ttree const isgr_fn = built_in_decls[BUILT_IN_ISGREATER];\n+\ttree const type = TREE_TYPE (arg);\n+\tREAL_VALUE_TYPE r;\n+\tchar buf[128];\n+\n+\tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n+\treal_from_string (&r, buf);\n+\tresult = build_call_expr (isgr_fn, 2,\n+\t\t\t\t  fold_build1_loc (loc, ABS_EXPR, type, arg),\n+\t\t\t\t  build_real (type, r));\n+\treturn result;\n+      }\n+    CASE_FLT_FN (BUILT_IN_FINITE):\n+    case BUILT_IN_ISFINITE:\n+      {\n+\t/* isfinite(x) -> islessequal(fabs(x),DBL_MAX).  */\n+\ttree const isle_fn = built_in_decls[BUILT_IN_ISLESSEQUAL];\n+\ttree const type = TREE_TYPE (arg);\n+\tREAL_VALUE_TYPE r;\n+\tchar buf[128];\n+\n+\tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n+\treal_from_string (&r, buf);\n+\tresult = build_call_expr (isle_fn, 2,\n+\t\t\t\t  fold_build1_loc (loc, ABS_EXPR, type, arg),\n+\t\t\t\t  build_real (type, r));\n+\t/*result = fold_build2_loc (loc, UNGT_EXPR,\n+\t\t\t\t  TREE_TYPE (TREE_TYPE (fndecl)),\n+\t\t\t\t  fold_build1_loc (loc, ABS_EXPR, type, arg),\n+\t\t\t\t  build_real (type, r));\n+\tresult = fold_build1_loc (loc, TRUTH_NOT_EXPR,\n+\t\t\t\t  TREE_TYPE (TREE_TYPE (fndecl)),\n+\t\t\t\t  result);*/\n+\treturn result;\n+      }\n+    case BUILT_IN_ISNORMAL:\n+      {\n+\t/* isnormal(x) -> isgreaterequal(fabs(x),DBL_MIN) &\n+\t   islessequal(fabs(x),DBL_MAX).  */\n+\ttree const isle_fn = built_in_decls[BUILT_IN_ISLESSEQUAL];\n+\ttree const isge_fn = built_in_decls[BUILT_IN_ISGREATEREQUAL];\n+\ttree const type = TREE_TYPE (arg);\n+\tREAL_VALUE_TYPE rmax, rmin;\n+\tchar buf[128];\n+\n+\tget_max_float (REAL_MODE_FORMAT (mode), buf, sizeof (buf));\n+\treal_from_string (&rmax, buf);\n+\tsprintf (buf, \"0x1p%d\", REAL_MODE_FORMAT (mode)->emin - 1);\n+\treal_from_string (&rmin, buf);\n+\targ = builtin_save_expr (fold_build1_loc (loc, ABS_EXPR, type, arg));\n+\tresult = build_call_expr (isle_fn, 2, arg,\n+\t\t\t\t  build_real (type, rmax));\n+\tresult = fold_build2 (BIT_AND_EXPR, integer_type_node, result,\n+\t\t\t      build_call_expr (isge_fn, 2, arg,\n+\t\t\t\t\t       build_real (type, rmin)));\n+\treturn result;\n+      }\n+    default:\n+      break;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Fold a call to __builtin_isnan(), __builtin_isinf, __builtin_finite.\n    ARG is the argument for the call.  */\n \n@@ -10664,13 +10272,26 @@ fold_builtin_1 (location_t loc, tree fndecl, tree arg0, bool ignore)\n     case BUILT_IN_FINITED64:\n     case BUILT_IN_FINITED128:\n     case BUILT_IN_ISFINITE:\n-      return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISFINITE);\n+      {\n+\ttree ret = fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISFINITE);\n+\tif (ret)\n+\t  return ret;\n+\treturn fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n+      }\n \n     CASE_FLT_FN (BUILT_IN_ISINF):\n     case BUILT_IN_ISINFD32:\n     case BUILT_IN_ISINFD64:\n     case BUILT_IN_ISINFD128:\n-      return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISINF);\n+      {\n+\ttree ret = fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISINF);\n+\tif (ret)\n+\t  return ret;\n+\treturn fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n+      }\n+\n+    case BUILT_IN_ISNORMAL:\n+      return fold_builtin_interclass_mathfn (loc, fndecl, arg0);\n \n     case BUILT_IN_ISINF_SIGN:\n       return fold_builtin_classify (loc, fndecl, arg0, BUILT_IN_ISINF_SIGN);\n@@ -10812,6 +10433,8 @@ fold_builtin_2 (location_t loc, tree fndecl, tree arg0, tree arg1, bool ignore)\n \n \t  return build_call_expr_loc (loc, fn, 2, arg0, arg1);\n \t}\n+      else\n+\treturn fold_builtin_stpcpy (loc, fndecl, arg0, arg1);\n       break;\n \n     case BUILT_IN_STRCMP:\n@@ -11777,6 +11400,42 @@ fold_builtin_strcat (location_t loc ATTRIBUTE_UNUSED, tree dst, tree src)\n       if (p && *p == '\\0')\n \treturn dst;\n \n+      if (optimize_insn_for_speed_p ())\n+\t{\n+\t  /* See if we can store by pieces into (dst + strlen(dst)).  */\n+\t  tree newdst, call;\n+\t  tree strlen_fn = implicit_built_in_decls[BUILT_IN_STRLEN];\n+\t  tree strcpy_fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+\n+\t  if (!strlen_fn || !strcpy_fn)\n+\t    return NULL_TREE;\n+\n+\t  /* If we don't have a movstr we don't want to emit an strcpy\n+\t     call.  We have to do that if the length of the source string\n+\t     isn't computable (in that case we can use memcpy probably\n+\t     later expanding to a sequence of mov instructions).  If we \n+\t     have movstr instructions we can emit strcpy calls.  */\n+\t  if (!HAVE_movstr)\n+\t    {\n+\t      tree len = c_strlen (src, 1);\n+\t      if (! len || TREE_SIDE_EFFECTS (len))\n+\t\treturn NULL_TREE;\n+\t    }\n+\n+\t  /* Stabilize the argument list.  */\n+\t  dst = builtin_save_expr (dst);\n+\n+\t  /* Create strlen (dst).  */\n+\t  newdst = build_call_expr_loc (loc, strlen_fn, 1, dst);\n+\t  /* Create (dst p+ strlen (dst)).  */\n+\n+\t  newdst = fold_build2_loc (loc, POINTER_PLUS_EXPR,\n+\t\t\t\tTREE_TYPE (dst), dst, newdst);\n+\t  newdst = builtin_save_expr (newdst);\n+\n+\t  call = build_call_expr_loc (loc, strcpy_fn, 2, newdst, src);\n+\t  return build2 (COMPOUND_EXPR, TREE_TYPE (dst), call, dst);\n+\t}\n       return NULL_TREE;\n     }\n }\n@@ -12297,16 +11956,9 @@ expand_builtin_memory_chk (tree exp, rtx target, enum machine_mode mode,\n       if (! fn)\n \treturn NULL_RTX;\n \n-      fn = build_call_expr (fn, 3, dest, src, len);\n-      STRIP_TYPE_NOPS (fn);\n-      while (TREE_CODE (fn) == COMPOUND_EXPR)\n-\t{\n-\t  expand_expr (TREE_OPERAND (fn, 0), const0_rtx, VOIDmode,\n-\t\t       EXPAND_NORMAL);\n-\t  fn = TREE_OPERAND (fn, 1);\n-\t}\n-      if (TREE_CODE (fn) == CALL_EXPR)\n-\tCALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n+      fn = build_call_nofold (fn, 3, dest, src, len);\n+      gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n+      CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n       return expand_expr (fn, target, mode, EXPAND_NORMAL);\n     }\n   else if (fcode == BUILT_IN_MEMSET_CHK)\n@@ -12352,16 +12004,9 @@ expand_builtin_memory_chk (tree exp, rtx target, enum machine_mode mode,\n \t      tree fn = built_in_decls[BUILT_IN_MEMCPY_CHK];\n \t      if (!fn)\n \t\treturn NULL_RTX;\n-\t      fn = build_call_expr (fn, 4, dest, src, len, size);\n-\t      STRIP_TYPE_NOPS (fn);\n-\t      while (TREE_CODE (fn) == COMPOUND_EXPR)\n-\t\t{\n-\t\t  expand_expr (TREE_OPERAND (fn, 0), const0_rtx, VOIDmode,\n-\t\t\t       EXPAND_NORMAL);\n-\t\t  fn = TREE_OPERAND (fn, 1);\n-\t\t}\n-\t      if (TREE_CODE (fn) == CALL_EXPR)\n-\t\tCALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n+\t      fn = build_call_nofold (fn, 4, dest, src, len, size);\n+\t      gcc_assert (TREE_CODE (fn) == CALL_EXPR);\n+\t      CALL_EXPR_TAILCALL (fn) = CALL_EXPR_TAILCALL (exp);\n \t      return expand_expr (fn, target, mode, EXPAND_NORMAL);\n \t    }\n \t}"}, {"sha": "1539ad21387a2fb76023db9d48099a12abb4e3fd", "filename": "gcc/fold-const.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=44e10129de2232d8e910e2c12140b80b74799586", "patch": "@@ -12614,6 +12614,11 @@ fold_binary_loc (location_t loc,\n         return fold_build1_loc (loc, TRUTH_NOT_EXPR, type,\n \t\t\t    fold_convert_loc (loc, type, arg0));\n \n+      /* !exp != 0 becomes !exp */\n+      if (TREE_CODE (arg0) == TRUTH_NOT_EXPR && integer_zerop (arg1)\n+\t  && code == NE_EXPR)\n+        return non_lvalue_loc (loc, fold_convert_loc (loc, type, arg0));\n+\n       /* If this is an equality comparison of the address of two non-weak,\n \t unaliased symbols neither of which are extern (since we do not\n \t have access to attributes for externs), then we know the result.  */"}, {"sha": "bcc966c320686c324baa5d9cd3c1df7043866b8c", "filename": "gcc/passes.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=44e10129de2232d8e910e2c12140b80b74799586", "patch": "@@ -626,6 +626,11 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_lower_complex);\n       NEXT_PASS (pass_sra);\n       NEXT_PASS (pass_rename_ssa_copies);\n+      /* The dom pass will also resolve all __builtin_constant_p calls\n+         that are still there to 0.  This has to be done after some\n+\t propagations have already run, but before some more dead code\n+\t is removed, and this place fits nicely.  Remember this when\n+\t trying to move or duplicate pass_dominator somewhere earlier.  */\n       NEXT_PASS (pass_dominator);\n       /* The only const/copy propagation opportunities left after\n \t DOM should be due to degenerate PHI nodes.  So rather than\n@@ -641,7 +646,6 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_object_sizes);\n       NEXT_PASS (pass_ccp);\n       NEXT_PASS (pass_copy_prop);\n-      NEXT_PASS (pass_fold_builtins);\n       NEXT_PASS (pass_cse_sincos);\n       NEXT_PASS (pass_optimize_bswap);\n       NEXT_PASS (pass_split_crit_edges);\n@@ -709,6 +713,7 @@ init_optimization_passes (void)\n       NEXT_PASS (pass_dse);\n       NEXT_PASS (pass_forwprop);\n       NEXT_PASS (pass_phiopt);\n+      NEXT_PASS (pass_fold_builtins);\n       NEXT_PASS (pass_tail_calls);\n       NEXT_PASS (pass_rename_ssa_copies);\n       NEXT_PASS (pass_uncprop);"}, {"sha": "a58e42ee21bf42dc853aac8bd4dccbd661b63ffe", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=44e10129de2232d8e910e2c12140b80b74799586", "patch": "@@ -1,3 +1,8 @@\n+2009-09-28  Michael Matz  <matz@suse.de>\n+\n+\t* gcc.dg/builtins-44.c: Use __builtin_isinf_sign when checking\n+\tfor sign of -Inf.\n+\n 2009-09-27  Richard Henderson  <rth@redhat.com>\n \n \t* gcc.c-torture/compile/pr41469.c: Add -fexceptions."}, {"sha": "1f1eaf0f6a51797f5d90aaa0f4194dadae2586ff", "filename": "gcc/testsuite/gcc.dg/builtins-44.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-44.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-44.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-44.c?ref=44e10129de2232d8e910e2c12140b80b74799586", "patch": "@@ -31,17 +31,13 @@ main ()\n   if (__builtin_isinfl (pinfl) != 1)\n     link_error ();\n \n-  if (__builtin_isinf (-pinf) != -1)\n+  if (__builtin_isinf_sign (-pinf) != -1)\n     link_error ();\n #ifndef __SPU__\n-  if (__builtin_isinf (-pinff) != -1)\n-    link_error ();\n-  if (__builtin_isinff (-pinff) != -1)\n+  if (__builtin_isinf_sign (-pinff) != -1)\n     link_error ();\n #endif\n-  if (__builtin_isinf (-pinfl) != -1)\n-    link_error ();\n-  if (__builtin_isinfl (-pinfl) != -1)\n+  if (__builtin_isinf_sign (-pinfl) != -1)\n     link_error ();\n \n   if (__builtin_isinf (4.0))"}, {"sha": "6e1ea39aa9259f0216dee76095d85ef6113d69af", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=44e10129de2232d8e910e2c12140b80b74799586", "patch": "@@ -3873,7 +3873,48 @@ fold_marked_statements (int first, struct pointer_set_t *statements)\n \t      gimple old_stmt = gsi_stmt (gsi);\n \t      tree old_decl = is_gimple_call (old_stmt) ? gimple_call_fndecl (old_stmt) : 0;\n \n-\t      if (fold_stmt (&gsi))\n+\t      if (old_decl && DECL_BUILT_IN (old_decl))\n+\t\t{\n+\t\t  /* Folding builtins can create multiple instructions,\n+\t\t     we need to look at all of them.  */\n+\t\t  gimple_stmt_iterator i2 = gsi;\n+\t\t  gsi_prev (&i2);\n+\t\t  if (fold_stmt (&gsi))\n+\t\t    {\n+\t\t      gimple new_stmt;\n+\t\t      if (gsi_end_p (i2))\n+\t\t\ti2 = gsi_start_bb (BASIC_BLOCK (first));\n+\t\t      else\n+\t\t\tgsi_next (&i2);\n+\t\t      while (1)\n+\t\t\t{\n+\t\t\t  new_stmt = gsi_stmt (i2);\n+\t\t\t  update_stmt (new_stmt);\n+\t\t\t  cgraph_update_edges_for_call_stmt (old_stmt, old_decl,\n+\t\t\t\t\t\t\t     new_stmt);\n+\n+\t\t\t  if (new_stmt == gsi_stmt (gsi))\n+\t\t\t    {\n+\t\t\t      /* It is okay to check only for the very last\n+\t\t\t\t of these statements.  If it is a throwing\n+\t\t\t\t statement nothing will change.  If it isn't\n+\t\t\t\t this can remove EH edges.  If that weren't\n+\t\t\t\t correct then because some intermediate stmts\n+\t\t\t\t throw, but not the last one.  That would mean\n+\t\t\t\t we'd have to split the block, which we can't\n+\t\t\t\t here and we'd loose anyway.  And as builtins\n+\t\t\t\t probably never throw, this all\n+\t\t\t\t is mood anyway.  */\n+\t\t\t      if (maybe_clean_or_replace_eh_stmt (old_stmt,\n+\t\t\t\t\t\t\t\t  new_stmt))\n+\t\t\t\tgimple_purge_dead_eh_edges (BASIC_BLOCK (first));\n+\t\t\t      break;\n+\t\t\t    }\n+\t\t\t  gsi_next (&i2);\n+\t\t\t}\n+\t\t    }\n+\t\t}\n+\t      else if (fold_stmt (&gsi))\n \t\t{\n \t\t  /* Re-read the statement from GSI as fold_stmt() may\n \t\t     have changed it.  */\n@@ -3882,7 +3923,8 @@ fold_marked_statements (int first, struct pointer_set_t *statements)\n \n \t\t  if (is_gimple_call (old_stmt)\n \t\t      || is_gimple_call (new_stmt))\n-\t\t    cgraph_update_edges_for_call_stmt (old_stmt, old_decl, new_stmt);\n+\t\t    cgraph_update_edges_for_call_stmt (old_stmt, old_decl,\n+\t\t\t\t\t\t       new_stmt);\n \n \t\t  if (maybe_clean_or_replace_eh_stmt (old_stmt, new_stmt))\n \t\t    gimple_purge_dead_eh_edges (BASIC_BLOCK (first));"}, {"sha": "76ea0e49e1c2059106161097d3ca7e6184b11a69", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=44e10129de2232d8e910e2c12140b80b74799586", "patch": "@@ -1424,8 +1424,8 @@ evaluate_stmt (gimple stmt)\n       else if (code == GIMPLE_SWITCH)\n         simplified = gimple_switch_index (stmt);\n       else\n-        /* These cannot satisfy is_gimple_min_invariant without folding.  */\n-        gcc_assert (code == GIMPLE_CALL || code == GIMPLE_COND);\n+\t/* These cannot satisfy is_gimple_min_invariant without folding.  */\n+\tgcc_assert (code == GIMPLE_CALL || code == GIMPLE_COND);\n     }\n \n   is_constant = simplified && is_gimple_min_invariant (simplified);\n@@ -2895,6 +2895,7 @@ fold_gimple_cond (gimple stmt)\n   return false;\n }\n \n+static void gimplify_and_update_call_from_tree (gimple_stmt_iterator *, tree);\n \n /* Attempt to fold a call statement referenced by the statement iterator GSI.\n    The statement may be replaced by another statement, e.g., if the call\n@@ -2915,7 +2916,11 @@ fold_gimple_call (gimple_stmt_iterator *gsi)\n       tree result = ccp_fold_builtin (stmt);\n \n       if (result)\n-        return update_call_from_tree (gsi, result);\n+\t{\n+          if (!update_call_from_tree (gsi, result))\n+\t    gimplify_and_update_call_from_tree (gsi, result);\n+\t  return true;\n+\t}\n     }\n   else\n     {"}, {"sha": "05a8d92a86f2677b97cdec4c6684e50891d1df0d", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=44e10129de2232d8e910e2c12140b80b74799586", "patch": "@@ -2133,6 +2133,20 @@ optimize_stmt (basic_block bb, gimple_stmt_iterator si)\n     {\n       eliminate_redundant_computations (&si);\n       stmt = gsi_stmt (si);\n+      if (gimple_code (stmt) == GIMPLE_CALL)\n+\t{\n+\t  /* Resolve __builtin_constant_p.  If it hasn't been\n+\t     folded to integer_one_node by now, it's fairly\n+\t     certain that the value simply isn't constant.  */\n+\t  tree callee = gimple_call_fndecl (stmt);\n+\t  if (callee\n+\t      && DECL_BUILT_IN_CLASS (callee) == BUILT_IN_NORMAL\n+\t      && DECL_FUNCTION_CODE (callee) == BUILT_IN_CONSTANT_P)\n+\t    {\n+\t      propagate_tree_value_into_stmt (&si, integer_zero_node);\n+\t      stmt = gsi_stmt (si);\n+\t    }\n+\t}\n     }\n \n   /* Record any additional equivalences created by this statement.  */"}, {"sha": "1491238858182bf72213e73e656d9a4b7237b23c", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44e10129de2232d8e910e2c12140b80b74799586/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=44e10129de2232d8e910e2c12140b80b74799586", "patch": "@@ -1001,17 +1001,18 @@ substitute_and_fold (prop_value_t *prop_value, ssa_prop_fold_stmt_fn fold_fn)\n \t  gimple stmt = gsi_stmt (i);\n \t  gimple old_stmt;\n \t  enum gimple_code code = gimple_code (stmt);\n+\t  gimple_stmt_iterator oldi;\n+\n+\t  oldi = i;\n+\t  gsi_prev (&i);\n \n \t  /* Ignore ASSERT_EXPRs.  They are used by VRP to generate\n \t     range information for names and they are discarded\n \t     afterwards.  */\n \n \t  if (code == GIMPLE_ASSIGN\n \t      && TREE_CODE (gimple_assign_rhs1 (stmt)) == ASSERT_EXPR)\n-\t    {\n-\t      gsi_prev (&i);\n-\t      continue;\n-\t    }\n+\t    continue;\n \n \t  /* No point propagating into a stmt whose result is not used,\n \t     but instead we might be able to remove a trivially dead stmt.  */\n@@ -1030,7 +1031,6 @@ substitute_and_fold (prop_value_t *prop_value, ssa_prop_fold_stmt_fn fold_fn)\n \t\t  fprintf (dump_file, \"\\n\");\n \t\t}\n \t      prop_stats.num_dce++;\n-\t      gsi_prev (&i);\n \t      i2 = gsi_for_stmt (stmt);\n \t      gsi_remove (&i2, true);\n \t      release_defs (stmt);\n@@ -1052,7 +1052,7 @@ substitute_and_fold (prop_value_t *prop_value, ssa_prop_fold_stmt_fn fold_fn)\n \t     specific information.  Do this before propagating\n \t     into the stmt to not disturb pass specific information.  */\n \t  if (fold_fn\n-\t      && (*fold_fn)(&i))\n+\t      && (*fold_fn)(&oldi))\n \t    {\n \t      did_replace = true;\n \t      prop_stats.num_stmts_folded++;\n@@ -1066,12 +1066,12 @@ substitute_and_fold (prop_value_t *prop_value, ssa_prop_fold_stmt_fn fold_fn)\n \n \t  /* If we made a replacement, fold the statement.  */\n \t  if (did_replace)\n-\t    fold_stmt (&i);\n+\t    fold_stmt (&oldi);\n \n \t  /* Now cleanup.  */\n \t  if (did_replace)\n \t    {\n-\t      stmt = gsi_stmt (i);\n+\t      stmt = gsi_stmt (oldi);\n \n               /* If we cleaned up EH information from the statement,\n                  remove EH edges.  */\n@@ -1105,8 +1105,6 @@ substitute_and_fold (prop_value_t *prop_value, ssa_prop_fold_stmt_fn fold_fn)\n \t      else\n \t\tfprintf (dump_file, \"Not folded\\n\");\n \t    }\n-\n-\t  gsi_prev (&i);\n \t}\n     }\n "}]}