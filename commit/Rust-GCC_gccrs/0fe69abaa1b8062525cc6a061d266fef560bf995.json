{"sha": "0fe69abaa1b8062525cc6a061d266fef560bf995", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGZlNjlhYmFhMWI4MDYyNTI1Y2M2YTA2MWQyNjZmZWY1NjBiZjk5NQ==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1998-11-25T19:45:42Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1998-11-25T19:45:42Z"}, "message": "c4x.c (c4x_modified_between_p, [...]): Delete.\n\n\t* config/c4x/c4x.c (c4x_modified_between_p, c4x_mem_set_p,\n \tc4x_mem_set_p, c4x_mem_modified_between_p, c4x_insn_moveable_p,\n\tc4x_parallel_pack, c4x_parallel_find, c4x_update_info_reg,\n\tc4x_update_info_regs, c4x_copy_insn_after, c4x_copy_insns_after,\n\tc4x_merge_notes, c4x_parallel_process,\n\tc4x_combine_parallel_independent, c4x_combine_parallel_dependent,\n\tc4x_combine_parallel): Delete.\n\nFrom-SVN: r23878", "tree": {"sha": "1a652d3adefd03b56ab49c03abe749b31aa13237", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a652d3adefd03b56ab49c03abe749b31aa13237"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0fe69abaa1b8062525cc6a061d266fef560bf995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe69abaa1b8062525cc6a061d266fef560bf995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0fe69abaa1b8062525cc6a061d266fef560bf995", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0fe69abaa1b8062525cc6a061d266fef560bf995/comments", "author": null, "committer": null, "parents": [{"sha": "51a6311276be2a14986ab83d8de0937683684fff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51a6311276be2a14986ab83d8de0937683684fff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51a6311276be2a14986ab83d8de0937683684fff"}], "stats": {"total": 789, "additions": 23, "deletions": 766}, "files": [{"sha": "c0181a92e24bd32686f61b5fc6c6686f111e4027", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe69abaa1b8062525cc6a061d266fef560bf995/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe69abaa1b8062525cc6a061d266fef560bf995/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0fe69abaa1b8062525cc6a061d266fef560bf995", "patch": "@@ -1,3 +1,26 @@\n+Thu Nov 26 16:37:59 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c (c4x_modified_between_p, c4x_mem_set_p,\n+ \tc4x_mem_set_p, c4x_mem_modified_between_p, c4x_insn_moveable_p,\n+\tc4x_parallel_pack, c4x_parallel_find, c4x_update_info_reg,\n+\tc4x_update_info_regs, c4x_copy_insn_after, c4x_copy_insns_after, \n+\tc4x_merge_notes, c4x_parallel_process, \n+\tc4x_combine_parallel_independent, c4x_combine_parallel_dependent,\n+\tc4x_combine_parallel): Delete.\n+\n+Thu Nov 26 15:16:05 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.c: (c4x_override_options): For compatibility\n+\twith old target options clear flag_branch_on_count_reg if\n+\t-mno-rptb specified and set flag_argument_alias is -mno-aliases\n+\tspecified.\n+\t(c4x_output_cbranch): Handle a sequence of insns rather than a\n+ \tsingle insn.\n+\t(c4x_rptb_insert): Don not emit a RPTB insn if the RC register\n+\thas not been allocated as the loop counter.\n+\t(c4x_address_conflict): \n+\t\n+\n Thu Nov 26 14:56:32 1998  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n \n \t* config/c4x/c4x.h (TARGET_DEFAULT): Add PARALEL_MPY_FLAG."}, {"sha": "b63b863bd78ed08de06eea64caa8c31c037397df", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 0, "deletions": 766, "changes": 766, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0fe69abaa1b8062525cc6a061d266fef560bf995/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0fe69abaa1b8062525cc6a061d266fef560bf995/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=0fe69abaa1b8062525cc6a061d266fef560bf995", "patch": "@@ -4107,772 +4107,6 @@ c4x_valid_type_attribute_p (type, attributes, identifier, args)\n }\n \n \n-/* This is a modified version of modified_between_p that doesn't give\n-   up if a changing MEM is found.  It checks all insns between START\n-   and END to see if any registers mentioned in X are set. */\n-static int\n-c4x_modified_between_p (x, start, end)\n-     rtx x;\n-     rtx start, end;\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  char *fmt;\n-  int i, j;\n-\n-  switch (code)\n-    {\n-    case CONST_INT:\n-    case CONST_DOUBLE:\n-    case CONST:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return 0;\n-\n-    case PC:\n-    case CC0:\n-      return 1;\n-\n-    case MEM:\n-      break;\n-\n-    case REG:\n-      return reg_set_between_p (x, start, end);\n-      \n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e' && c4x_modified_between_p (XEXP (x, i), start, end))\n-\treturn 1;\n-\n-      if (fmt[i] == 'E')\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  if (c4x_modified_between_p (XVECEXP (x, i, j), start, end))\n-\t    return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return 1 if rtx X references memory that is changing.  */\n-static int\n-c4x_mem_ref_p (x)\n-     rtx x;\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  char *fmt;\n-  int i, j;\n-\n-  if (code == MEM && !RTX_UNCHANGING_P (x))\n-    return 1;\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e' && c4x_mem_ref_p (XEXP (x, i)))\n-\treturn 1;\n-\n-      if (fmt[i] == 'E')\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  if (c4x_mem_ref_p (XVECEXP (x, i, j)))\n-\t    return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-/* Return 1 if rtx X sets or clobbers memory.  */\n-static int\n-c4x_mem_set_p (x)\n-     rtx x;\n-{\n-  enum rtx_code code = GET_CODE (x);\n-  char *fmt;\n-  int i, j;\n-\n-  if ((code == SET || code == CLOBBER)\n-      && (GET_CODE (SET_DEST (x)) == MEM))\n-    return 1;\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e' && c4x_mem_set_p (XEXP (x, i)))\n-\treturn 1;\n-\n-      if (fmt[i] == 'E')\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  if (c4x_mem_set_p (XVECEXP (x, i, j)))\n-\t    return 1;\n-    }\n-\n-  return 0;\n-}\n-\n-\n-/* Return 1 if any insns between START and END (exclusive) sets\n-   or clobbers memory.  */\n-static int\n-c4x_mem_modified_between_p (start, end)\n-     rtx start, end;\n-{\n-  rtx insn;\n-\n-  if (start == end)\n-    return 0;\n-\n-  for (insn = NEXT_INSN (start); insn != end; insn = NEXT_INSN (insn))\n-    if (GET_RTX_CLASS (GET_CODE (insn)) == 'i'\n-\t&& c4x_mem_set_p (PATTERN (insn)))\n-      return 1;\n-  return 0;\n-}\n-\n-\n-/* Returns 1 if INSN can be moved past all the insns between START and\n-   END exclusive.  If TARGET_ALIASES is not set and a memory store is\n-   detected, then 0 is returned.  */\n-static int\n-c4x_insn_moveable_p (insn, start, end)\n-     rtx insn;\n-     rtx start, end;\n-{\n-  if (start == end)\n-    return 1;\n-\n-  /* We can't use modified_between_p since this will\n-     return 1 if set1 contains a MEM.  */\n-  if (c4x_modified_between_p (insn, start, end))\n-    return 0;\n-\n-  return 1;\n-}\n-\n-\n-/* See if the insns INSN1 and INSN2 can be packed into a PARALLEL.\n-   Return 0 if the insns cannot be packed or the rtx of the packed\n-   insn (with clobbers added as necessary).  If DEPEND is non zero,\n-   then the destination register of INSN1 must be used by INSN2.  */\n-static rtx\n-c4x_parallel_pack (insn1, insn2, depend)\n-     rtx insn1;\n-     rtx insn2;\n-     int depend;\n-{\n-  rtx set1;\n-  rtx set2;\n-  rtx pack;\n-  enum machine_mode mode1;\n-  enum machine_mode mode2;\n-  int num_clobbers;\n-  int insn_code_number;\n-\n-  /* We could generalise things to not just rely on single sets.  */\n-  if (!(set1 = single_set (insn1))\n-      || !(set2 = single_set (insn2)))\n-    return 0;\n-\n-  mode1 = GET_MODE (SET_DEST (set1));\n-  mode2 = GET_MODE (SET_DEST (set2));\n-  if (mode1 != mode2)\n-    return 0;\n-\n-  if (depend)\n-    {\n-      rtx dst1;\n-\n-      /* Require insn2 to be dependent upon the result of insn1.  */\n-      dst1 = SET_DEST (set1);\n-      \n-      if (!REG_P (dst1))\n-\treturn 0;\n-\n-      if (!reg_mentioned_p (dst1, set2))\n-\treturn 0;\n-\n-      /* The dependent register must die in insn2 since a parallel\n-\t insn will generate a new value.  */\n-      if (!find_regno_note (insn2, REG_DEAD, REGNO (dst1)))\n-\treturn 0;\n-    }\n-\n-  pack = gen_rtx_PARALLEL (VOIDmode, gen_rtvec (2, set1, set2));\n-  num_clobbers = 0;\n-  if ((insn_code_number = recog (pack, pack, &num_clobbers)) < 0)\n-    return 0;\n-\n-  if (num_clobbers != 0)\n-    {\n-      rtx newpack;\n-      int i;\n-\n-      newpack = gen_rtx_PARALLEL (VOIDmode,\n-\t\t\t\t  gen_rtvec (GET_CODE (pack) == PARALLEL\n-\t\t\t\t    ? XVECLEN (pack, 0) + num_clobbers\n-\t\t\t\t    : num_clobbers + 1));\n-\n-      if (GET_CODE (pack) == PARALLEL)\n-\tfor (i = 0; i < XVECLEN (pack, 0); i++)\n-\t  XVECEXP (newpack, 0, i) = XVECEXP (pack, 0, i);\n-      else\n-\tXVECEXP (newpack, 0, 0) = pack;\n-\n-      add_clobbers (newpack, insn_code_number);\n-      pack = newpack;\n-    }\n-\n-  return pack;\n-}\n-\n-\n-static rtx\n-c4x_parallel_find (insn1, loop_end, depend, insn2)\n-     rtx insn1;\n-     rtx loop_end;\n-     int depend;\n-     rtx *insn2;\n-{\n-  rtx insn;\n-  rtx pack;\n-\n-  /* We could use the logical links if depend is non zero?  */\n-\n-  for (insn = NEXT_INSN (insn1); insn != loop_end; insn = NEXT_INSN(insn))\n-    {\n-      switch (GET_CODE (insn))\n-\t{\n-\tdefault:\n-\tcase JUMP_INSN:\n-\tcase CALL_INSN:\n-\tcase NOTE:\n-\t  break;\n-\n-\tcase INSN:\n-\t  if (!(pack = c4x_parallel_pack (insn1, insn, depend)))\n-\t    break;\n-\n-\t  /* What if insn1 or insn2 sets cc and is required by another\n-\t     insn?  */\n-\n-#if 0\n-\t  /* Check that nothing between insn1 and insn will spoil the\n-\t     show.  */\n-\t  if (NEXT_INSN (insn1) != insn \n-\t      && c4x_modified_between_p (insn, NEXT_INSN (insn1), insn))\n-\t    return 0;\n-#else\n-\t  /* This will do in the interim.  If the insns between\n-\t     insn1 and insn are harmless, we can move things around\n-\t     if we're careful.  */\n-\t  if (next_nonnote_insn (insn1) != insn)\n-\t    return 0;\n-#endif\n-\t  \n-\t  /* Do some checks here... */\n-\t  *insn2 = insn;\n-\t  return pack;\n-\t}\n-    }\n-  return 0;\n-}\n-\n-\n-/* Update the register info for reg REG found in the basic block BB,\n-   where SET is 1 if the register is being set.  */\n-static void\n-c4x_update_info_reg (reg, set, bb)\n-     rtx reg;\n-     int set;\n-     int bb;\n-{\n-  int regno;\n-\n-  if (!REG_P (reg))\n-    fatal_insn (\"Expecting register rtx\", reg);\n-\n-  regno = REGNO (reg);\n-\n-  /* REGNO_FIRST_UID and REGNO_LAST_UID don't need setting.  */\n-\n-  SET_REGNO_REG_SET (basic_block_live_at_start[bb], regno);\n-  REG_BASIC_BLOCK (regno) = REG_BLOCK_GLOBAL;\n-  if (set)\n-    REG_N_SETS (regno)++;  \n-  else\n-    REG_N_REFS (regno)++;  \n-}\n-\n-\n-/* Update the register info for all the regs in X found in the basic\n-   block BB.  */\n-static void\n-c4x_update_info_regs(x, bb)\n-     rtx x;\n-     int bb;\n-{\n-  enum rtx_code code;\n-  char *fmt;\n-  int i, j;\n-\n-  if (!x)\n-    return;\n-\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case CLOBBER:\n-#if 0\n-      if (REG_P (SET_DEST (x)))\n-\treturn;\n-      break;\n-#endif\n-\n-    case SET:\n-      if (REG_P (SET_DEST (x)))\n-\tc4x_update_info_reg (SET_DEST (x), 1, bb);\n-      else\n-\tc4x_update_info_regs (SET_DEST (x), bb);\n-\n-      if (code == SET)\n-\tc4x_update_info_regs (SET_SRC (x), bb);\n-      return;\n-\n-    case REG:\n-      c4x_update_info_reg (x, 0, bb);\n-      return;\n-\n-    default:\n-      break;\n-    }\n-\n-  fmt = GET_RTX_FORMAT (code);\n-  for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\tc4x_update_info_regs (XEXP (x, i), bb);\n-      else if (fmt[i] == 'E')\n-\tfor (j = XVECLEN (x, i) - 1; j >= 0; j--)\n-\t  c4x_update_info_regs (XVECEXP (x, i, j), bb);\n-    }\n-}\n-\n-\n-static void\n-c4x_copy_insn_after(insn, prev, bb)\n-     rtx insn;\n-     rtx prev;\n-     int bb;\n-{\n-  rtx note;\n-  rtx new;\n-\n-  emit_insn_after (copy_rtx (PATTERN (insn)), prev);\n-\n-  new = NEXT_INSN (prev);\n-\n-  /* Copy the REG_NOTES from insn to the new insn.  */\n-  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-    REG_NOTES (new) = gen_rtx (GET_CODE (note),\n-\t\t\t       REG_NOTE_KIND (note),\n-\t\t\t       XEXP (note, 0),\n-\t\t\t       REG_NOTES (new));\n-\n-  /* Handle all the registers within insn and update the reg info.  */\n-  c4x_update_info_regs (PATTERN (insn), bb);\n-}\n-\n-\n-static void\n-c4x_copy_insns_after(start, end, pprev, bb)\n-     rtx start;\n-     rtx end;\n-     rtx *pprev;\n-     int bb;\n-{\n-  rtx insn;\n-\n-  for (insn = start; insn != NEXT_INSN (end); insn = NEXT_INSN(insn))\n-    {\n-      switch (GET_CODE (insn))\n-\t{\n-\tcase CALL_INSN:\n-\t  /* We could allow a libcall with no side effects??? */\n-\t  fatal_insn(\"Repeat block loop contains a call\", insn);\n-\t  break;\n-\t  \n-\tcase INSN:\n-\t  c4x_copy_insn_after(insn, *pprev, bb - 1);\n-\t  *pprev = NEXT_INSN (*pprev);\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-}\n-\n-\n-/* Merge the notes of insn2 with the notes of insn.  */\n-static void\n-c4x_merge_notes(insn, insn2)\n-     rtx insn;\n-     rtx insn2;\n-{\n-  rtx note;\n-\t   \n-  for (note = REG_NOTES (insn2); note; note = XEXP (note, 1))\n-    {\n-      rtx link;\n-      \n-      for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n-\tif (REG_NOTE_KIND (note) == REG_NOTE_KIND (link)\n-\t    && XEXP (note, 0) == XEXP (link, 0))\n-\t  remove_note (insn, note);\n-    }\n-  for (note = REG_NOTES (insn2); note; note = XEXP (note, 1))\n-    REG_NOTES (insn) = gen_rtx (GET_CODE (note),\n-\t\t\t\tREG_NOTE_KIND (note),\n-\t\t\t\tXEXP (note, 0),\n-\t\t\t\tREG_NOTES (insn));\n-}\n-\n-\n-/* This pass must update information that subsequent passes expect to be\n-   correct.  Namely: reg_n_refs, reg_n_sets, reg_n_deaths,\n-   reg_n_calls_crossed, and reg_live_length.  Also, basic_block_head,\n-   basic_block_end.   */\n-\n-static int\n-c4x_parallel_process (loop_start, loop_end)\n-     rtx loop_start;\n-     rtx loop_end;\n-{\n-  rtx insn;\n-  rtx insn2;\n-  rtx pack;\n-  rtx hoist_pos;\n-  rtx sink_pos;\n-  rtx loop_count;\n-  rtx loop_count_set;\n-  rtx loop_count_reg;\n-  rtx jump_insn;\n-  rtx end_label;\n-  int num_packs;\n-  int bb;\n-\n-  jump_insn = PREV_INSN (loop_end);\n-\n-  /* The loop must have a calculable number of iterations\n-     since we need to reduce the loop count by one.  \n-\n-     For now, only process repeat block loops, since we can tell that\n-     these have a calculable number of iterations. \n-\n-     The loop count must be at least 2?  */\n-\n-  loop_count = PREV_INSN (loop_start);\n-  \n-  if (!(loop_count_set = single_set (loop_count)))\n-    return 0;\n-\n-#if 0\n-  /* Disable this optimisation until REG_LOOP_COUNT note\n-     added.  */\n-  if (!find_reg_note (loop_count, REG_LOOP_COUNT, NULL_RTX))\n-    return 0;\n-#else\n-  return 0;\n-#endif\n-\n-  loop_count_reg = SET_DEST (loop_count_set);\n-\t\t  \n-  /* Determine places to hoist and sink insns out of the loop. \n-     We need to hoist insns before the label at the top of the loop. \n-     We'll have to update basic_block_head.  */\n-  \n-  /* Place in the rtx where we hoist insns after.  */\n-  hoist_pos = loop_count;\n-\n-  /* Place in the rtx where we sink insns after.  */\n-  sink_pos = loop_end;\n-\n-  /* There must be an easier way to work out which basic block we are\n-     in.  */\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n-    if (basic_block_head[bb] == NEXT_INSN (loop_end))\n-      break;\n-\n-  if (bb >= n_basic_blocks)\n-    fatal_insn(\"Cannot find basic block for insn\", NEXT_INSN (loop_end));\n-\n-  /* Skip to label at top of loop.  */\n-  for (; GET_CODE (loop_start) != CODE_LABEL;\n-       loop_start = NEXT_INSN(loop_start));\n-  \n-  num_packs = 0;\n-  for (insn = loop_start; insn != loop_end; insn = NEXT_INSN(insn))\n-    {\n-      switch (GET_CODE (insn))\n-\t{\n-\tdefault:\n-\tcase JUMP_INSN:\n-\tcase CALL_INSN:\n-\tcase NOTE:\n-\t  break;\n-\n-\tcase INSN:\n-\n-\t  /* Look for potential insns to combine where the second one\n-\t     is dependent upon the first.  We could have another pass\n-\t     that tries combining independent insns but that is not so\n-\t     important.  We could do this afterwards as a more generic\n-\t     peepholer.  */\n-\t     \n-\t  if ((pack = c4x_parallel_find(insn, loop_end, 1, &insn2)))\n-\t    {\n-\t      rtx set1;\n-\t      rtx set2;\n-\t      rtx note;\n-\t      rtx seq_start;\n-\n-\t      set1 = single_set (insn);\n-\t      set2 = single_set (insn2);\n-\n-\t      /* We need to hoist a copy of insn1 out of the loop and\n-\t\t to sink a copy insn2 out of the loop.  We can avoid\n-\t\t the latter if the destination of insn2 is used\n-\t\t by a following insn within the loop.\n-\t\t \n-\t\t We cannot hoist insn1 out of the loop if any of the\n-\t\t preceeding insns within the loop modifies the destination\n-\t\t of insn1 or modifies any of the operands of insn1.  */\n-\n-\t      /* If the user has flagged that there are potential aliases,\n-\t\t then we can't move the insn if it references memory\n-\t\t past any insns that modify memory.  */\n-\t      if (TARGET_ALIASES \n-\t\t  && c4x_mem_ref_p (PATTERN (insn))\n-\t\t  && c4x_mem_modified_between_p (loop_start, loop_end))\n-\t\tbreak;\n-\n-\t      /* None of the registers used in insn can be modified by\n-\t\t any of the insns from the start of the loop until insn.  */\n-\t      if (!c4x_insn_moveable_p (set1, loop_start, insn))\n-\t\tbreak;\n-\n-\t      /* None of the registers used in insn can be modified by\n-\t\t any of the insns after insn2 until the end of the\n-\t\t loop, especially the result which needs to be saved\n-\t\t for the next iteration. */\n-\t      if (!c4x_insn_moveable_p (set1, insn2, loop_end))\n-\t\tbreak;\n-\n-\t      /* We need to hoist all the insns from the loop top\n-\t\t to and including insn.  */\n-\t      c4x_copy_insns_after (NEXT_INSN (loop_start), insn,\n-\t\t\t\t    &hoist_pos, bb);\n-\n-\t      /* We need to sink all the insns after insn to \n-\t\t loop_end.  */\n-\t      c4x_copy_insns_after (NEXT_INSN (insn), PREV_INSN (jump_insn),\n-\t\t\t\t    &sink_pos, bb + 1);\n-\n-\t      /* Change insn to the new parallel insn, retaining the notes\n-\t\t of the old insn.  */\n-\t      if (!validate_change (insn, &PATTERN (insn), pack, 0))\n-\t\tfatal_insn(\"Cannot replace insn with parallel insn\", pack);\n-\n-\t      /* Copy the REG_NOTES from insn2 to the new insn\n-\t\t avoiding duplicates.  */\n-\t      c4x_merge_notes (insn, insn2);\n-\n-\t      delete_insn (insn2);\n-\t      \n-\t      /* The destination register of insn1 no longer dies in\n-\t      this composite insn.  Don't use remove_death since that\n-\t      alters REG_N_DEATHS.  The REG_DEAD note has just been\n-\t      moved.  */\n-\t      note = find_regno_note (insn, REG_DEAD, REGNO (SET_DEST (set1)));\n-\t      if (note)\n-\t\tremove_note (insn, note);\n-\n-\t      /* ??? Do we have to modify the LOG_LINKS?  */\n-\n-\t      /* We need to decrement the loop count.  We probably\n-\t\t should test if the loop count is negative and branch\n-\t\t to end label if so.  */\n-\t      if (GET_CODE (SET_SRC (loop_count_set)) == CONST_INT)\n-\t\t{\n-\t\t  /* The loop count must be more than 1 surely?  */\n-\t\t  SET_SRC (loop_count_set) \n-\t\t    = GEN_INT (INTVAL (SET_SRC (loop_count_set)) - 1);\n-\t\t}\n-\t      else if (GET_CODE (SET_SRC (loop_count_set)) == PLUS\n-\t\t       && GET_CODE (XEXP (SET_SRC (loop_count_set), 1))\n-\t\t       == CONST_INT)\n-\t\t{\n-\t\t  XEXP (SET_SRC (loop_count_set), 1)\n-\t\t    = GEN_INT (INTVAL (XEXP (SET_SRC (loop_count_set), 1))\n-\t\t\t       - 1);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  start_sequence ();\n-\t\t  expand_binop (QImode, sub_optab, loop_count_reg,\n-\t\t\t\tGEN_INT (1), loop_count_reg,\t\t\n-\t\t\t\t1, OPTAB_DIRECT);\n-\t\t  seq_start = get_insns ();\n-\t\t  end_sequence ();\n-\t\t  emit_insns_after (seq_start, loop_count);\n-\n-\t\t  /* Check this.  What if we emit more than one insn?\n-\t\t     Can we emit more than one insn? */\n-\t\t  REG_NOTES (seq_start)\n-\t\t    = gen_rtx_EXPR_LIST (REG_UNUSED,\n-\t\t\t       loop_count_reg,\n-\t\t\t       REG_NOTES (seq_start));\n-\t\t}\n-\n-\t      if (GET_CODE (SET_SRC (loop_count_set)) != CONST_INT)\n-\t\t{\n-\t\t  end_label = gen_label_rtx();\n-\t\t  start_sequence ();\n-\t\t  emit_cmp_insn (loop_count_reg,\n-\t\t\t\t const0_rtx, LT, NULL_RTX, word_mode, 0, 0);\n-\t\t  emit_jump_insn (gen_blt (end_label));\n-\t\t  seq_start = get_insns ();\n-\t\t  end_sequence ();\n-\t\t  emit_insns_after (seq_start, hoist_pos);\n-\t\t  emit_label_after (end_label, sink_pos);\n-\t\t \n-#if 0 \n-\t\t  /* This is a bit of a hack...but why was it necessary?  */\n-\t\t  REG_NOTES (NEXT_INSN (seq_start))\n-\t\t    = gen_rtx_EXPR_LIST (REG_DEAD,\n-\t\t\t\t\t loop_count_reg,\n-\t\t\t\t\t REG_NOTES (NEXT_INSN (seq_start)));\n-#endif\n-\t\t}\n-\n-\t      if (TARGET_DEVEL)\n-\t\tdebug_rtx(insn);\n-\n-\t      num_packs ++;\n-\t      \n-#if 1\n-\t      /* If we want to pack more than one parallel insn\n-\t\t we will have to tag which insns have been\n-\t\t hoisted/sunk/paired.  We might need a recursive approach. */\n-\t      \n-\t      return num_packs;\n-#endif\n-\t    }\n-\t  break;\n-\t}\n-    }\n-  return num_packs;\n-}\n-\n-\n-static void\n-c4x_combine_parallel_independent (insns)\n-     rtx insns ATTRIBUTE_UNUSED;\n-{\n-  /* Combine independent insns like\n-     (set (mem (reg 0)) (reg 1))\n-     (set (reg 2) (mem (reg 3)))\n-     where (reg 1) != (reg 2) unless there is a REG_DEAD note\n-     on the first insn. */\n-\n-}\n-\n-static void\n-c4x_combine_parallel_dependent (insns)\n-     rtx insns;\n-{\n-  rtx insn;\n-  rtx loop_start;\n-  rtx loop_end;\n-  int num_jumps;\n-  int num_insns;\n-\n-   /* Find the innermost loop and check that it is unjumped.  */\n-  loop_start = NULL_RTX;\n-  num_jumps = 0;\n-  for (insn = insns; insn; insn = NEXT_INSN(insn))\n-    {\n-      switch (GET_CODE (insn))\n-\t{\n-\tcase INSN:\n-\t  num_insns++;\n-\t  break;\n-\n-\tcase CALL_INSN:\n-\t  /* We could allow a libcall with no side effects??? */\n-\tcase JUMP_INSN:\n-\t  num_jumps++;\n-\t  break;\n-\n-\tcase NOTE:\n-\t  switch (NOTE_LINE_NUMBER (insn))\n-\t    {\n-\t    case NOTE_INSN_LOOP_BEG:\n-\t      loop_start = insn;\n-\t      num_jumps = 0;\n-\t      num_insns = 0;\n-\t      break;\n-\n-\t    case NOTE_INSN_LOOP_CONT:\n-\t      if (!loop_start)\n-\t\tbreak;\n-\t      /* We can't handle a loop with jumps or calls.\n-\t\t If there are too many insns, we are unlikely\n-\t\t to be able to find a suitable case for optimisation.\n-\t\t The maximum number of insns may require tweaking.  */\n-\t      if (!num_jumps && num_insns < 20)\n-\t\t{\n-\t\t  /* Skip to end of loop.  */\n-\t\t  loop_end = NULL_RTX;\n-\t\t  for (; insn; insn = NEXT_INSN(insn))\n-\t\t    if (GET_CODE (insn) == NOTE\n-\t\t\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_END)\n-\t\t      break;\n-\t\t  loop_end = insn;\n-\t\t  if (!loop_end)\n-\t\t    fatal_insn(\"Could not find note at end of loop\", \n-\t\t\t       loop_start);\n-\t\t  c4x_parallel_process(loop_start, loop_end);\n-\t\t}\n-\t      loop_start = NULL_RTX;\n-\t      break;\n-\n-\t    default:\n-\t      break;\n-\t    }\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-}\n-\n-\n-void\n-c4x_combine_parallel (insns)\n-     rtx insns;\n-{\n- /* Only let people who know how to shoot themselves in the foot do so!  */\n-  if (!TARGET_PARALLEL_PACK)\n-    return;\n-  \n-  c4x_combine_parallel_dependent (insns);\n-\n-  c4x_combine_parallel_independent (insns);\n-}\n-\n-\n /* !!! FIXME to emit RPTS correctly.  */\n int\n c4x_rptb_rpts_p (insn, op)"}]}