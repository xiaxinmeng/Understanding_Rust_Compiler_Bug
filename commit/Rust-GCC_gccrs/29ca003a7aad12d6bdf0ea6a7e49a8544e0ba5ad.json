{"sha": "29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjljYTAwM2E3YWFkMTJkNmJkZjBlYTZhN2U0OWE4NTQ0ZTBiYTVhZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-01-18T19:40:12Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-01-18T19:40:12Z"}, "message": "m68k-protos.h (m68k_output_pic_call): Delete.\n\ngcc/\n\t* config/m68k/m68k-protos.h (m68k_output_pic_call): Delete.\n\t(output_call, m68k_legitimize_call_address): Declare.\n\t* config/m68k/m68k.h (EXTRA_CONSTRAINT): Remove unnecessary\n\tparenthesees.  Add support for a 'W' constraint.\n\t(LEGITIMATE_PIC_OPERAND_P): Remove SYMBOL_REF_FLAG handling.\n\t(PRINT_OPERAND_PUNCT_VALID_P): Remove comment about 'o'.\n\t(m68k_symbolic_call, m68k_symbolic_jump): Declare.\n\t* config/m68k/m68k.c (m68k_symbolic_call, m68k_symbolic_jump): New\n\tvariables.\n\t(override_options): Initialize them.  Do not set flag_no_function_cse\n\tfor TARGET_ID_SHARED_LIBRARY.\n\t(m68k_output_pic_call): Delete.\n\t(m68k_legitimize_call_address): New function.\n\t(print_operand): Remove the %o prefix.  Handle the %p prefix.\n\t(output_call): New function.\n\t(m68k_output_mi_thunk): Use m68k_symbolic_jump.  Always load the\n\ttarget address from the GOT if symbolic jumps are not allowed.\n\t* config/m68k/m68k.md (call, general_operand): Do not set\n\tSYMBOL_REF_FLAG.  Use m68k_legitimize_call_address instead.\n\tMerge separate flag_pic and !flag_pic define_insns into...\n\t(*call, *call_value): ...these new patterns.  Match the address\n\trather than the containing MEM and require it to be a call_operand.\n\tUse output_call to generate the asm template.\n\t* config/m68k/predicates.md (const_call_operand): New predicate.\n\t(call_operand): Likewise.\n\nFrom-SVN: r120921", "tree": {"sha": "c02edc016e7c96d87dd0ef5592fb69cb246610a8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c02edc016e7c96d87dd0ef5592fb69cb246610a8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/comments", "author": null, "committer": null, "parents": [{"sha": "85dbf7e2258db10de674de971de026bdcd75e9a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85dbf7e2258db10de674de971de026bdcd75e9a5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85dbf7e2258db10de674de971de026bdcd75e9a5"}], "stats": {"total": 324, "additions": 143, "deletions": 181}, "files": [{"sha": "2459a97ce57944e38b91b4cf9824a415dd82fe16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad", "patch": "@@ -1,3 +1,31 @@\n+2007-01-18  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* config/m68k/m68k-protos.h (m68k_output_pic_call): Delete.\n+\t(output_call, m68k_legitimize_call_address): Declare.\n+\t* config/m68k/m68k.h (EXTRA_CONSTRAINT): Remove unnecessary\n+\tparenthesees.  Add support for a 'W' constraint.\n+\t(LEGITIMATE_PIC_OPERAND_P): Remove SYMBOL_REF_FLAG handling.\n+\t(PRINT_OPERAND_PUNCT_VALID_P): Remove comment about 'o'.\n+\t(m68k_symbolic_call, m68k_symbolic_jump): Declare.\n+\t* config/m68k/m68k.c (m68k_symbolic_call, m68k_symbolic_jump): New\n+\tvariables.\n+\t(override_options): Initialize them.  Do not set flag_no_function_cse\n+\tfor TARGET_ID_SHARED_LIBRARY.\n+\t(m68k_output_pic_call): Delete.\n+\t(m68k_legitimize_call_address): New function.\n+\t(print_operand): Remove the %o prefix.  Handle the %p prefix.\n+\t(output_call): New function.\n+\t(m68k_output_mi_thunk): Use m68k_symbolic_jump.  Always load the\n+\ttarget address from the GOT if symbolic jumps are not allowed.\n+\t* config/m68k/m68k.md (call, general_operand): Do not set\n+\tSYMBOL_REF_FLAG.  Use m68k_legitimize_call_address instead.\n+\tMerge separate flag_pic and !flag_pic define_insns into...\n+\t(*call, *call_value): ...these new patterns.  Match the address\n+\trather than the containing MEM and require it to be a call_operand.\n+\tUse output_call to generate the asm template.\n+\t* config/m68k/predicates.md (const_call_operand): New predicate.\n+\t(call_operand): Likewise.\n+\n 2007-01-18  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* config/m68k/m68k.h (REGISTER_MOVE_COST): Simplify definition."}, {"sha": "30d25b75510705bf25ca9b4878665c1da9521fbe", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad", "patch": "@@ -39,7 +39,7 @@ extern const char *output_addsi3 (rtx *);\n extern const char *output_andsi3 (rtx *);\n extern const char *output_iorsi3 (rtx *);\n extern const char *output_xorsi3 (rtx *);\n-extern void m68k_output_pic_call (rtx dest);\n+extern const char *output_call (rtx);\n extern void output_dbcc_and_branch (rtx *);\n extern int floating_exact_log2 (rtx);\n extern bool strict_low_part_peephole_ok (enum machine_mode mode, rtx first_insn, rtx target);\n@@ -64,4 +64,5 @@ extern void override_options (void);\n extern const char *m68k_cpp_cpu_ident (const char *);\n extern const char *m68k_cpp_cpu_family (const char *);\n extern void init_68881_table (void);\n+extern rtx m68k_legitimize_call_address (rtx);\n extern int m68k_hard_regno_rename_ok(unsigned int, unsigned int);"}, {"sha": "03d59b98f9b082cef5eb9e12e7ea7899de8be9ef", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 76, "deletions": 80, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad", "patch": "@@ -327,6 +327,12 @@ enum fpu_type m68k_fpu;\n \n /* The set of FL_* flags that apply to the target processor.  */\n unsigned int m68k_cpu_flags;\n+\n+/* Asm templates for calling or jumping to an arbitrary symbolic address,\n+   or NULL if such calls or jumps are not supported.  The address is held\n+   in operand 0.  */\n+const char *m68k_symbolic_call;\n+const char *m68k_symbolic_jump;\n \f\n /* See whether TABLE has an entry with name NAME.  Return true and\n    store the entry in *ENTRY if so, otherwise return false and\n@@ -530,13 +536,42 @@ override_options (void)\n   if (TARGET_PCREL && flag_pic == 0)\n     flag_pic = 1;\n \n-  /* Turn off function cse if we are doing PIC.  We always want function call\n-     to be done as `bsr foo@PLTPC', so it will force the assembler to create\n-     the PLT entry for `foo'. Doing function cse will cause the address of\n-     `foo' to be loaded into a register, which is exactly what we want to\n-     avoid when we are doing PIC on svr4 m68k.  */\n-  if (flag_pic)\n-    flag_no_function_cse = 1;\n+  if (!flag_pic)\n+    {\n+#if MOTOROLA && !defined (USE_GAS)\n+      m68k_symbolic_call = \"jsr %a0\";\n+      m68k_symbolic_jump = \"jmp %a0\";\n+#else\n+      m68k_symbolic_call = \"jbsr %a0\";\n+      m68k_symbolic_jump = \"jra %a0\";\n+#endif\n+    }\n+  else if (TARGET_ID_SHARED_LIBRARY)\n+    /* All addresses must be loaded from the GOT.  */\n+    ;\n+  else if (TARGET_68020 || TARGET_ISAB)\n+    {\n+      if (TARGET_PCREL)\n+\t{\n+\t  m68k_symbolic_call = \"bsr.l %c0\";\n+\t  m68k_symbolic_jump = \"bra.l %c0\";\n+\t}\n+      else\n+\t{\n+#if defined(USE_GAS)\n+\t  m68k_symbolic_call = \"bsr.l %p0\";\n+\t  m68k_symbolic_jump = \"bra.l %p0\";\n+#else\n+\t  m68k_symbolic_call = \"bsr %p0\";\n+\t  m68k_symbolic_jump = \"bra %p0\";\n+#endif\n+\t}\n+      /* Turn off function cse if we are doing PIC.  We always want\n+\t function call to be done as `bsr foo@PLTPC'.  */\n+      /* ??? It's traditional to do this for -mpcrel too, but it isn't\n+\t clear how intentional that is.  */\n+      flag_no_function_cse = 1;\n+    }\n \n   SUBTARGET_OVERRIDE_OPTIONS;\n }\n@@ -1332,33 +1367,16 @@ flags_in_68881 (void)\n   return cc_status.flags & CC_IN_68881;\n }\n \n-/* Output a BSR instruction suitable for PIC code.  */\n-void\n-m68k_output_pic_call (rtx dest)\n-{\n-  const char *out;\n-\n-  if (!(GET_CODE (dest) == MEM && GET_CODE (XEXP (dest, 0)) == SYMBOL_REF))\n-    out = \"jsr %0\";\n-      /* We output a BSR instruction if we're building for a target that\n-\t supports long branches.  Otherwise we generate one of two sequences:\n-\t a shorter one that uses a GOT entry or a longer one that doesn't.\n-\t We'll use the -Os command-line flag to decide which to generate.\n-\t Both sequences take the same time to execute on the ColdFire.  */\n-  else if (TARGET_PCREL)\n-    out = \"bsr.l %o0\";\n-  else if (TARGET_68020)\n-#if defined(USE_GAS)\n-    out = \"bsr.l %0@PLTPC\";\n-#else\n-    out = \"bsr %0@PLTPC\";\n-#endif\n-  else if (optimize_size || TARGET_ID_SHARED_LIBRARY)\n-    out = \"move.l %0@GOT(%%a5), %%a1\\n\\tjsr (%%a1)\";\n-  else\n-    out = \"lea %0-.-8,%%a1\\n\\tjsr 0(%%pc,%%a1)\";\n+/* Convert X to a legitimate function call memory reference and return the\n+   result.  */\n \n-  output_asm_insn (out, &dest);\n+rtx\n+m68k_legitimize_call_address (rtx x)\n+{\n+  gcc_assert (MEM_P (x));\n+  if (call_operand (XEXP (x, 0), VOIDmode))\n+    return x;\n+  return replace_equiv_address (x, force_reg (Pmode, XEXP (x, 0)));\n }\n \n /* Output a dbCC; jCC sequence.  Note we do not handle the \n@@ -3083,12 +3101,10 @@ floating_exact_log2 (rtx x)\n    'b' for byte insn (no effect, on the Sun; this is for the ISI).\n    'd' to force memory addressing to be absolute, not relative.\n    'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n-   'o' for operands to go directly to output_operand_address (bypassing\n-       print_operand_address--used only for SYMBOL_REFs under TARGET_PCREL)\n    'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n        or print pair of registers as rx:ry.\n-\n-   */\n+   'p' print an address with @PLTPC attached, but only if the operand\n+       is not locally-bound.  */\n \n void\n print_operand (FILE *file, rtx op, int letter)\n@@ -3120,13 +3136,11 @@ print_operand (FILE *file, rtx op, int letter)\n     }\n   else if (letter == '/')\n     asm_fprintf (file, \"%R\");\n-  else if (letter == 'o')\n+  else if (letter == 'p')\n     {\n-      /* This is only for direct addresses with TARGET_PCREL */\n-      gcc_assert (GET_CODE (op) == MEM\n-\t\t  && GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t\t  && TARGET_PCREL);\n-      output_addr_const (file, XEXP (op, 0));\n+      output_addr_const (file, op);\n+      if (!(GET_CODE (op) == SYMBOL_REF && SYMBOL_REF_LOCAL_P (op)))\n+\tfprintf (file, \"@PLTPC\");\n     }\n   else if (GET_CODE (op) == REG)\n     {\n@@ -3693,6 +3707,18 @@ output_xorsi3 (rtx *operands)\n   return \"eor%.l %2,%0\";\n }\n \n+/* Return the instruction that should be used for a call to address X,\n+   which is known to be in operand 0.  */\n+\n+const char *\n+output_call (rtx x)\n+{\n+  if (symbolic_operand (x, VOIDmode))\n+    return m68k_symbolic_call;\n+  else\n+    return \"jsr %a0\";\n+}\n+\n #ifdef M68K_TARGET_COFF\n \n /* Output assembly to switch to section NAME with attribute FLAGS.  */\n@@ -3759,43 +3785,13 @@ m68k_output_mi_thunk (FILE *file, tree thunk ATTRIBUTE_UNUSED,\n \n   xops[0] = DECL_RTL (function);\n \n-  /* Logic taken from call patterns in m68k.md.  */\n-  if (flag_pic)\n-    {\n-      if (TARGET_PCREL)\n-\tfmt = \"bra.l %o0\";\n-      else if (flag_pic == 1 || TARGET_68020)\n-\t{\n-\t  if (MOTOROLA)\n-\t    {\n-#if defined (USE_GAS)\n-\t      fmt = \"bra.l %0@PLTPC\";\n-#else\n-\t      fmt = \"bra %0@PLTPC\";\n-#endif\n-\t    }\n-\t  else /* !MOTOROLA */\n-\t    {\n-#ifdef USE_GAS\n-\t      fmt = \"bra.l %0\";\n-#else\n-\t      fmt = \"jra %0,a1\";\n-#endif\n-\t    }\n-\t}\n-      else if (optimize_size || TARGET_ID_SHARED_LIBRARY)\n-        fmt = \"move.l %0@GOT(%%a5), %%a1\\n\\tjmp (%%a1)\";\n-      else\n-        fmt = \"lea %0-.-8,%%a1\\n\\tjmp 0(%%pc,%%a1)\";\n-    }\n-  else\n-    {\n-#if MOTOROLA && !defined (USE_GAS)\n-      fmt = \"jmp %0\";\n-#else\n-      fmt = \"jra %0\";\n-#endif\n-    }\n+  gcc_assert (MEM_P (xops[0])\n+\t      && symbolic_operand (XEXP (xops[0], 0), VOIDmode));\n+  xops[0] = XEXP (xops[0], 0);\n+\n+  fmt = m68k_symbolic_jump;\n+  if (m68k_symbolic_jump == NULL)\n+    fmt = \"move.l %%a1@GOT(%%a5), %%a1\\n\\tjmp (%%a1)\";\n \n   output_asm_insn (fmt, xops);\n }"}, {"sha": "2b72781bc1b37bd54e9800cde02557ba6c4d10f7", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad", "patch": "@@ -513,32 +513,35 @@ extern enum reg_class regno_reg_class[];\n /* `Q' means address register indirect addressing mode.\n    `S' is for operands that satisfy 'm' when -mpcrel is in effect.\n    `T' is for operands that satisfy 's' when -mpcrel is not in effect.\n-   `U' is for register offset addressing.  */\n+   `U' is for register offset addressing.\n+   `W' is for const_call_operands.  */\n #define EXTRA_CONSTRAINT(OP,CODE)\t\t\t\\\n-  (((CODE) == 'S')\t\t\t\t\t\\\n+  ((CODE) == 'S'\t\t\t\t\t\\\n    ? (TARGET_PCREL\t\t\t\t\t\\\n       && GET_CODE (OP) == MEM\t\t\t\t\\\n       && (GET_CODE (XEXP (OP, 0)) == SYMBOL_REF\t\t\\\n \t  || GET_CODE (XEXP (OP, 0)) == LABEL_REF\t\\\n \t  || GET_CODE (XEXP (OP, 0)) == CONST))\t\t\\\n    : \t\t\t\t\t\t\t\\\n-  (((CODE) == 'T')\t\t\t\t\t\\\n+   (CODE) == 'T'\t\t\t\t\t\\\n    ? ( !TARGET_PCREL \t\t\t\t\t\\\n       && (GET_CODE (OP) == SYMBOL_REF\t\t\t\\\n \t  || GET_CODE (OP) == LABEL_REF\t\t\t\\\n \t  || GET_CODE (OP) == CONST))\t\t\t\\\n    :\t\t\t\t\t\t\t\\\n-  (((CODE) == 'Q')\t\t\t\t\t\\\n+   (CODE) == 'Q'\t\t\t\t\t\\\n    ? (GET_CODE (OP) == MEM \t\t\t\t\\\n       && GET_CODE (XEXP (OP, 0)) == REG)\t\t\\\n    :\t\t\t\t\t\t\t\\\n-  (((CODE) == 'U')\t\t\t\t\t\\\n+   (CODE) == 'U'\t\t\t\t\t\\\n    ? (GET_CODE (OP) == MEM \t\t\t\t\\\n       && GET_CODE (XEXP (OP, 0)) == PLUS\t\t\\\n       && GET_CODE (XEXP (XEXP (OP, 0), 0)) == REG\t\\\n       && GET_CODE (XEXP (XEXP (OP, 0), 1)) == CONST_INT) \\\n    :\t\t\t\t\t\t\t\\\n-   0))))\n+   (CODE) == 'W'\t\t\t\t\t\\\n+   ? const_call_operand (OP, VOIDmode)\t\t\t\\\n+   : 0)\n \n /* On the m68k, use a data reg if possible when the\n    value is a constant in the range where moveq could be used\n@@ -803,7 +806,6 @@ __transfer_from_trampoline ()\t\t\t\t\t\\\n \n #define LEGITIMATE_PIC_OPERAND_P(X)\t\\\n   (! symbolic_operand (X, VOIDmode)\t\t\t\t\\\n-   || (GET_CODE (X) == SYMBOL_REF && SYMBOL_REF_FLAG (X))\t\\\n    || PCREL_GENERAL_OPERAND_OK)\n \n #ifndef REG_OK_STRICT\n@@ -1232,8 +1234,6 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n    'b' for byte insn (no effect, on the Sun; this is for the ISI).\n    'd' to force memory addressing to be absolute, not relative.\n    'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n-   'o' for operands to go directly to output_operand_address (bypassing\n-       print_operand_address--used only for SYMBOL_REFs under TARGET_PCREL)\n    'x' for float insn (print a CONST_DOUBLE as a float rather than in hex),\n        or print pair of registers as rx:ry.  */\n \n@@ -1292,3 +1292,5 @@ extern enum target_device m68k_cpu;\n extern enum uarch_type m68k_tune;\n extern enum fpu_type m68k_fpu;\n extern unsigned int m68k_cpu_flags;\n+extern const char *m68k_symbolic_call;\n+extern const char *m68k_symbolic_jump;"}, {"sha": "91b95fb2ccad0f5a32dfd1429b65401ee9248d1e", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 15, "deletions": 91, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad", "patch": "@@ -6371,122 +6371,46 @@\n     \"subql #1,%0\\;cmpl #-1,%0\\;jne %l1\";\n })\n \n-\n-;; For PIC calls, in order to be able to support\n-;; dynamic linker LAZY BINDING, all the procedure calls need to go\n-;; through the PLT (Procedure Linkage Table) section in PIC mode.\n-;;\n-;; PIC calls are handled by loading the address of the function into a\n-;; register (via movsi), then emitting a register indirect call using\n-;; the \"jsr\" function call syntax.\n-;;\n-;; When outputting MIT syntax (e.g. on Suns), we add a bogus extra\n-;; operand to the jbsr statement to indicate that this call should\n-;; go through the PLT (why? because this is the way that Sun does it).\n-;;\n-;; We have different patterns for PIC calls and non-PIC calls.  The\n-;; different patterns are only used to choose the right syntax.\n-;;\n-;; The svr4 m68k assembler recognizes this syntax: `bsr FUNC@PLTPC' and it\n-;; will create the correct relocation entry (R_68K_PLT32) for `FUNC',\n-;; that tells the linker editor to create an entry for `FUNC' in PLT\n-;; section at link time. However, all global objects reference are still\n-;; done by using `OBJ@GOT'. So, the goal here is to output the function\n-;; call operand as `FUNC@PLTPC', but output object operand as `OBJ@GOT'.\n-;; We need to have a way to differentiate these two different operands.\n-;;\n-;; The strategy I use here is to use SYMBOL_REF_FLAG to differentiate\n-;; these two different operands. The macro LEGITIMATE_PIC_OPERAND_P needs\n-;; to be changed to recognize function calls symbol_ref operand as a valid\n-;; PIC operand (by checking whether SYMBOL_REF_FLAG is set). This will\n-;; avoid the compiler to load this symbol_ref operand into a register.\n-;; Remember, the operand \"foo@PLTPC\" cannot be called via jsr directly\n-;; since the value is a PC relative offset, not a real address.\n-;;\n-;; All global objects are treated in the similar way as in SUN3. The only\n-;; difference is: on m68k svr4, the reference of such global object needs\n-;; to end with a suffix \"@GOT\" so the assembler and linker know to create\n-;; an entry for it in GOT (Global Offset Table) section. This is done in\n-;; m68k.c.\n-\n ;; Call subroutine with no return value.\n (define_expand \"call\"\n   [(call (match_operand:QI 0 \"memory_operand\" \"\")\n \t (match_operand:SI 1 \"general_operand\" \"\"))]\n   ;; Operand 1 not really used on the m68000.\n-\n   \"\"\n {\n-  if (flag_pic && GET_CODE (XEXP (operands[0], 0)) == SYMBOL_REF)\n-    SYMBOL_REF_FLAG (XEXP (operands[0], 0)) = 1;\n+  operands[0] = m68k_legitimize_call_address (operands[0]);\n })\n \n-;; This is a normal call sequence.\n-(define_insn \"\"\n-  [(call (match_operand:QI 0 \"memory_operand\" \"o\")\n-\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n+(define_insn \"*call\"\n+  [(call (mem:QI (match_operand:SI 0 \"call_operand\" \"a,W\"))\n+\t (match_operand:SI 1 \"general_operand\" \"g,g\"))]\n   ;; Operand 1 not really used on the m68000.\n-\n-  \"! flag_pic\"\n-{\n-#if MOTOROLA && !defined (USE_GAS)\n-  return \"jsr %0\";\n-#else\n-  return \"jbsr %0\";\n-#endif\n-})\n-\n-;; This is a PIC call sequence.\n-(define_insn \"\"\n-  [(call (match_operand:QI 0 \"memory_operand\" \"o\")\n-\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n-  ;; Operand 1 not really used on the m68000.\n-\n-  \"flag_pic\"\n+  \"\"\n {\n-  m68k_output_pic_call(operands[0]);\n-  return \"\";\n+  return output_call (operands[0]);\n })\n \n ;; Call subroutine, returning value in operand 0\n ;; (which must be a hard register).\n-;; See comments before \"call\" regarding PIC calls.\n (define_expand \"call_value\"\n   [(set (match_operand 0 \"\" \"\")\n \t(call (match_operand:QI 1 \"memory_operand\" \"\")\n-     (match_operand:SI 2 \"general_operand\" \"\")))]\n+\t      (match_operand:SI 2 \"general_operand\" \"\")))]\n   ;; Operand 2 not really used on the m68000.\n   \"\"\n {\n-  if (flag_pic && GET_CODE (XEXP (operands[1], 0)) == SYMBOL_REF)\n-    SYMBOL_REF_FLAG (XEXP (operands[1], 0)) = 1;\n+  operands[1] = m68k_legitimize_call_address (operands[1]);\n })\n \n-;; This is a normal call_value\n-(define_insn \"\"\n-  [(set (match_operand 0 \"\" \"=rf\")\n-\t(call (match_operand:QI 1 \"memory_operand\" \"o\")\n-\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n+(define_insn \"*call_value\"\n+  [(set (match_operand 0 \"\" \"=rf,rf\")\n+\t(call (mem:QI (match_operand:SI 1 \"call_operand\" \"a,W\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g,g\")))]\n   ;; Operand 2 not really used on the m68000.\n-  \"! flag_pic\"\n-{\n-#if MOTOROLA && !defined (USE_GAS)\n-  return \"jsr %1\";\n-#else\n-  return \"jbsr %1\";\n-#endif\n-})\n-\n-;; This is a PIC call_value\n-(define_insn \"\"\n-  [(set (match_operand 0 \"\" \"=rf\")\n-\t(call (match_operand:QI 1 \"memory_operand\" \"o\")\n-\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n-  ;; Operand 2 not really used on the m68000.\n-  \"flag_pic\"\n+  \"\"\n {\n-  m68k_output_pic_call(operands[1]);\n-  return \"\";\n+  operands[0] = operands[1];\n+  return output_call (operands[0]);\n })\n \n ;; Call subroutine returning any type."}, {"sha": "11e10f189b63e6e0cd4e9946b7677667915ee9c0", "filename": "gcc/config/m68k/predicates.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fpredicates.md?ref=29ca003a7aad12d6bdf0ea6a7e49a8544e0ba5ad", "patch": "@@ -159,6 +159,17 @@\n     }\n })\n \n+;; A constant that can be used the address in a call insn.\n+(define_predicate \"const_call_operand\"\n+  (ior (match_operand 0 \"const_int_operand\")\n+       (and (match_test \"m68k_symbolic_call != NULL\")\n+\t    (match_operand 0 \"symbolic_operand\"))))\n+\n+;; An operand that can be used as the address in a call insn.\n+(define_predicate \"call_operand\"\n+  (ior (match_operand 0 \"const_call_operand\")\n+       (match_operand 0 \"register_operand\")))\n+\n ;; TODO: Add a comment here.\n \n (define_predicate \"post_inc_operand\""}]}