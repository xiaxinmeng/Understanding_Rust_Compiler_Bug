{"sha": "455f19cb1cc13e726b806d792a8808f55aaa9a07", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU1ZjE5Y2IxY2MxM2U3MjZiODA2ZDc5MmE4ODA4ZjU1YWFhOWEwNw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2004-09-28T02:56:11Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2004-09-28T02:56:11Z"}, "message": "re PR c++/17642 (internal compiler error: in invert_truthvalue, at fold-const.c:2997)\n\n\tPR c++/17642\n\t* stor-layout.c (layout_decl): Use fold_convert, not convert.\n\t(bit_from_pos): Likewise.\n\t(byte_from_pos): Likewise.\n\t(pos_from_bit): Likewise.\n\t(normalize_offset): Likewise.\n\t(place_field): Likewise.\n\t(finalize_type_size): Likewise.\n\t(layout_type): Likewise.\n\t* tree.c (build_index_type): Likewise.\n\n\tPR c++/17642\n\t* cp-tree.h (fold_if_not_in_template): New function.\n\t* call.c (build_conditional_expr): Use fold_if_not_in_template.\n\t(build_cxx_call): Likewise.\n\t* cvt.c (convert_to_complex): Likewise.\n\t(ocp_convert): Likewise.\n\t(convert): Likewise.\n\t(convert_force): Likewise.\n\t* decl.c (compute_array_index_type): Clear\n\tprocessing_template_decl while folding array bounds.\n\t* pt.c (convert_nontype_argument): Clear\n\tprocessing_template_decl while processing non-type argument\n\tinitialization.\n\t* tree.c (fold_if_not_in_template): New function.\n\t* typeck.c (build_class_member_access_expr): Use\n\tfold_if_not_in_template.\n\t(build_array_ref): Likewise.\n\t(build_binary_op): Likewise.  Do not try to optimize computations\n\twhen processing templates.\n\t(cp_pointer_int_sum): Use fold_if_not_in_template.\n\t(pointer_diff): Likewise.\n\t(build_unary_op): Likewise.\n\t(build_reinterpret_cast): Likewise.\n\t(get_delta_difference): Likewise.\n\t(expand_ptrmemfunc_cst): Likewise.\n\t(dubious_conversion_warnings): Likewise.\n\n\t* g++.dg/template/crash23.C: New test.\n\nFrom-SVN: r88217", "tree": {"sha": "36630ae2e63d9c79e59704bfce96a6e0b3b33f2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36630ae2e63d9c79e59704bfce96a6e0b3b33f2c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/455f19cb1cc13e726b806d792a8808f55aaa9a07", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455f19cb1cc13e726b806d792a8808f55aaa9a07", "html_url": "https://github.com/Rust-GCC/gccrs/commit/455f19cb1cc13e726b806d792a8808f55aaa9a07", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/455f19cb1cc13e726b806d792a8808f55aaa9a07/comments", "author": null, "committer": null, "parents": [{"sha": "081077002d07ddac4094b11b1edd5f8d1175bddd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/081077002d07ddac4094b11b1edd5f8d1175bddd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/081077002d07ddac4094b11b1edd5f8d1175bddd"}], "stats": {"total": 295, "additions": 205, "deletions": 90}, "files": [{"sha": "d7fb97a35ac0b1673af96aa2cddc86c0e5e6981f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -1,3 +1,16 @@\n+2004-09-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/17642\n+\t* stor-layout.c (layout_decl): Use fold_convert, not convert.\n+\t(bit_from_pos): Likewise.\n+\t(byte_from_pos): Likewise.\n+\t(pos_from_bit): Likewise.\n+\t(normalize_offset): Likewise.\n+\t(place_field): Likewise.\n+\t(finalize_type_size): Likewise.\n+\t(layout_type): Likewise.\n+\t* tree.c (build_index_type): Likewise.\n+\n 2004-09-27  Devang Patel  <dpatel@apple.com>\n \n \t* expr.c (expand_expr_real_1): Handle VEC_COND_EXPR."}, {"sha": "561ac7a97f0235184fab1eec3d473538223017e6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -1,3 +1,32 @@\n+2004-09-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tPR c++/17642\n+\t* cp-tree.h (fold_if_not_in_template): New function.\n+\t* call.c (build_conditional_expr): Use fold_if_not_in_template.\n+\t(build_cxx_call): Likewise.\n+\t* cvt.c (convert_to_complex): Likewise.\n+\t(ocp_convert): Likewise.\n+\t(convert): Likewise.\n+\t(convert_force): Likewise.\n+\t* decl.c (compute_array_index_type): Clear\n+\tprocessing_template_decl while folding array bounds.\n+\t* pt.c (convert_nontype_argument): Clear\n+\tprocessing_template_decl while processing non-type argument\n+\tinitialization.\n+\t* tree.c (fold_if_not_in_template): New function.\n+\t* typeck.c (build_class_member_access_expr): Use\n+\tfold_if_not_in_template.\n+\t(build_array_ref): Likewise.\n+\t(build_binary_op): Likewise.  Do not try to optimize computations\n+\twhen processing templates.\n+\t(cp_pointer_int_sum): Use fold_if_not_in_template.\n+\t(pointer_diff): Likewise.\n+\t(build_unary_op): Likewise.\n+\t(build_reinterpret_cast): Likewise.\n+\t(get_delta_difference): Likewise.\n+\t(expand_ptrmemfunc_cst): Likewise.\n+\t(dubious_conversion_warnings): Likewise.\n+\n 2004-09-27  Matt Austern  <austern@apple.com>\n \n \t* cp/parser.c (struct cp_token): new one-bit field , implicit_extern_c"}, {"sha": "f61fa2a754d6ccd9ff82b4748c212230a7c34303", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -3442,7 +3442,8 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n     }\n \n  valid_operands:\n-  result = fold (build3 (COND_EXPR, result_type, arg1, arg2, arg3));\n+  result = fold_if_not_in_template (build3 (COND_EXPR, result_type, arg1, \n+\t\t\t\t\t    arg2, arg3));\n   /* We can't use result_type below, as fold might have returned a\n      throw_expr.  */\n \n@@ -4869,7 +4870,7 @@ build_cxx_call (tree fn, tree args)\n \n   /* Some built-in function calls will be evaluated at compile-time in\n      fold ().  */\n-  fn = fold (fn);\n+  fn = fold_if_not_in_template (fn);\n \n   if (VOID_TYPE_P (TREE_TYPE (fn)))\n     return fn;"}, {"sha": "0a2d9706e9381148eab3847edbe7defb4c1e8616", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -4207,6 +4207,7 @@ extern tree cp_add_pending_fn_decls (void*,tree);\n extern int cp_is_overload_p (tree);\n extern int cp_auto_var_in_fn_p (tree,tree);\n extern void cp_update_decl_after_saving (tree, void *);\n+extern tree fold_if_not_in_template             (tree);\n \n /* in typeck.c */\n extern int string_conv_p\t\t\t(tree, tree, int);"}, {"sha": "a5d42e463e57c6c2bea9ac480462246fbcaa0a73", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -643,7 +643,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       /* For complex data types, we need to perform componentwise\n          conversion.  */\n       else if (TREE_CODE (type) == COMPLEX_TYPE)\n-        return fold (convert_to_complex (type, e));\n+        return fold_if_not_in_template (convert_to_complex (type, e));\n       else if (TREE_CODE (e) == TARGET_EXPR)\n \t{\n \t  /* Don't build a NOP_EXPR of class type.  Instead, change the\n@@ -659,7 +659,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t  /* We shouldn't be treating objects of ADDRESSABLE type as\n \t     rvalues.  */\n \t  gcc_assert (!TREE_ADDRESSABLE (type));\n-\t  return fold (build1 (NOP_EXPR, type, e));\n+\t  return fold_if_not_in_template (build_nop (type, e));\n \t}\n     }\n \n@@ -696,10 +696,10 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       if (code == BOOLEAN_TYPE)\n \treturn cp_truthvalue_conversion (e);\n \n-      return fold (convert_to_integer (type, e));\n+      return fold_if_not_in_template (convert_to_integer (type, e));\n     }\n   if (POINTER_TYPE_P (type) || TYPE_PTR_TO_MEMBER_P (type))\n-    return fold (cp_convert_to_pointer (type, e, false));\n+    return fold_if_not_in_template (cp_convert_to_pointer (type, e, false));\n   if (code == VECTOR_TYPE)\n     {\n       tree in_vtype = TREE_TYPE (e);\n@@ -713,7 +713,7 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n             error (\"`%#T' used where a `%T' was expected\", in_vtype, type);\n           return error_mark_node;\n \t}\n-      return fold (convert_to_vector (type, e));\n+      return fold_if_not_in_template (convert_to_vector (type, e));\n     }\n   if (code == REAL_TYPE || code == COMPLEX_TYPE)\n     {\n@@ -729,9 +729,9 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n \t\t\tTREE_TYPE (e));\n \t}\n       if (code == REAL_TYPE)\n-\treturn fold (convert_to_real (type, e));\n+\treturn fold_if_not_in_template (convert_to_real (type, e));\n       else if (code == COMPLEX_TYPE)\n-\treturn fold (convert_to_complex (type, e));\n+\treturn fold_if_not_in_template (convert_to_complex (type, e));\n     }\n \n   /* New C++ semantics:  since assignment is now based on\n@@ -945,7 +945,7 @@ convert (tree type, tree expr)\n   if (POINTER_TYPE_P (type) && POINTER_TYPE_P (intype))\n     {\n       expr = decl_constant_value (expr);\n-      return fold (build1 (NOP_EXPR, type, expr));\n+      return fold_if_not_in_template (build_nop (type, expr));\n     }\n \n   return ocp_convert (type, expr, CONV_OLD_CONVERT,\n@@ -963,13 +963,14 @@ convert_force (tree type, tree expr, int convtype)\n   enum tree_code code = TREE_CODE (type);\n \n   if (code == REFERENCE_TYPE)\n-    return fold (convert_to_reference (type, e, CONV_C_CAST, LOOKUP_COMPLAIN,\n-\t\t\t\t       NULL_TREE));\n+    return (fold_if_not_in_template \n+\t    (convert_to_reference (type, e, CONV_C_CAST, LOOKUP_COMPLAIN,\n+\t\t\t\t   NULL_TREE)));\n   else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n     e = convert_from_reference (e);\n \n   if (code == POINTER_TYPE)\n-    return fold (convert_to_pointer_force (type, e));\n+    return fold_if_not_in_template (convert_to_pointer_force (type, e));\n \n   /* From typeck.c convert_for_assignment */\n   if (((TREE_CODE (TREE_TYPE (e)) == POINTER_TYPE && TREE_CODE (e) == ADDR_EXPR"}, {"sha": "fb1334fc16fbf691b6a360607c8239abb34a7bdc", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -6196,12 +6196,20 @@ compute_array_index_type (tree name, tree size)\n     itype = build_min (MINUS_EXPR, sizetype, size, integer_one_node);\n   else\n     {\n+      HOST_WIDE_INT saved_processing_template_decl;\n+\n       /* Compute the index of the largest element in the array.  It is\n-     \t one less than the number of elements in the array.  */\n-      itype\n-\t= fold (cp_build_binary_op (MINUS_EXPR,\n-\t\t\t\t    cp_convert (ssizetype, size),\n-\t\t\t\t    cp_convert (ssizetype, integer_one_node)));\n+     \t one less than the number of elements in the array.  We save\n+     \t and restore PROCESSING_TEMPLATE_DECL so that computations in\n+     \t cp_build_binary_op will be appropriately folded.  */\n+      saved_processing_template_decl = processing_template_decl;\n+      processing_template_decl = 0;\n+      itype = cp_build_binary_op (MINUS_EXPR,\n+\t\t\t\t  cp_convert (ssizetype, size),\n+\t\t\t\t  cp_convert (ssizetype, integer_one_node));\n+      itype = fold (itype);\n+      processing_template_decl = saved_processing_template_decl;\n+\n       if (!TREE_CONSTANT (itype))\n \t/* A variable sized array.  */\n \titype = variable_size (itype);"}, {"sha": "99c70b5f26830058fea9f0176169c4cf6309731c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -3381,6 +3381,8 @@ convert_nontype_argument (tree type, tree expr)\n \n   switch (TREE_CODE (type))\n     {\n+      HOST_WIDE_INT saved_processing_template_decl;\n+\n     case INTEGER_TYPE:\n     case BOOLEAN_TYPE:\n     case ENUMERAL_TYPE:\n@@ -3398,8 +3400,12 @@ convert_nontype_argument (tree type, tree expr)\n \t  return error_mark_node;\n \n       /* It's safe to call digest_init in this case; we know we're\n-\t just converting one integral constant expression to another.  */\n+\t just converting one integral constant expression to another.\n+\t */\n+      saved_processing_template_decl = processing_template_decl;\n+      processing_template_decl = 0;\n       expr = digest_init (type, expr, (tree*) 0);\n+      processing_template_decl = saved_processing_template_decl;\n \n       if (TREE_CODE (expr) != INTEGER_CST)\n \t/* Curiously, some TREE_CONSTANT integral expressions do not"}, {"sha": "16bb39bc740739c3f2cac6e558d289f8ca82f077", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -2331,6 +2331,19 @@ stabilize_init (tree init, tree *initp)\n   return true;\n }\n \n+/* Like \"fold\", but should be used whenever we might be processing the\n+   body of a template.  */\n+\n+tree\n+fold_if_not_in_template (tree expr)\n+{\n+  /* In the body of a template, there is never any need to call\n+     \"fold\".  We will call fold later when actually instantiating the\n+     template.  Integral constant expressions in templates will be\n+     evaluted via fold_non_dependent_expr, as necessary.  */\n+  return (processing_template_decl ? expr : fold (expr));\n+}\n+\n \f\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n /* Complain that some language-specific thing hanging off a tree"}, {"sha": "85337735f071a0cf785f56e742a8d202a3e59293", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 73, "deletions": 46, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -1768,8 +1768,9 @@ build_class_member_access_expr (tree object, tree member,\n \t  member_type = cp_build_qualified_type (member_type, type_quals);\n \t}\n \n-      result = fold (build3 (COMPONENT_REF, member_type, object, member,\n-\t\t\t     NULL_TREE));\n+      result = build3 (COMPONENT_REF, member_type, object, member,\n+\t\t       NULL_TREE);\n+      result = fold_if_not_in_template (result);\n \n       /* Mark the expression const or volatile, as appropriate.  Even\n \t though we've dealt with the type above, we still have to mark the\n@@ -2272,7 +2273,7 @@ build_array_ref (tree array, tree idx)\n \t|= (CP_TYPE_VOLATILE_P (type) | TREE_SIDE_EFFECTS (array));\n       TREE_THIS_VOLATILE (rval)\n \t|= (CP_TYPE_VOLATILE_P (type) | TREE_THIS_VOLATILE (array));\n-      return require_complete_type (fold (rval));\n+      return require_complete_type (fold_if_not_in_template (rval));\n     }\n \n   {\n@@ -2762,6 +2763,8 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n      convert it to this type.  */\n   tree final_type = 0;\n \n+  tree result;\n+\n   /* Nonzero if this is an operation like MIN or MAX which can\n      safely be computed in short if both args are promoted shorts.\n      Also implies COMMON.\n@@ -2782,6 +2785,9 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   /* Nonzero means set RESULT_TYPE to the common type of the args.  */\n   int common = 0;\n \n+  /* True if both operands have arithmetic type.  */\n+  bool arithmetic_types_p;\n+\n   /* Apply default conversions.  */\n   op0 = orig_op0;\n   op1 = orig_op1;\n@@ -3169,14 +3175,31 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n       break;\n     }\n \n-  if ((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE)\n-      &&\n-      (code1 == INTEGER_TYPE || code1 == REAL_TYPE || code1 == COMPLEX_TYPE))\n+  arithmetic_types_p = \n+    ((code0 == INTEGER_TYPE || code0 == REAL_TYPE || code0 == COMPLEX_TYPE)\n+     && (code1 == INTEGER_TYPE || code1 == REAL_TYPE \n+\t || code1 == COMPLEX_TYPE));\n+  /* Determine the RESULT_TYPE, if it is not already known.  */\n+  if (!result_type\n+      && arithmetic_types_p \n+      && (shorten || common || short_compare))\n+    result_type = common_type (type0, type1);\n+\n+  if (!result_type)\n     {\n-      int none_complex = (code0 != COMPLEX_TYPE && code1 != COMPLEX_TYPE);\n+      error (\"invalid operands of types `%T' and `%T' to binary `%O'\",\n+\t     TREE_TYPE (orig_op0), TREE_TYPE (orig_op1), code);\n+      return error_mark_node;\n+    }\n \n-      if (shorten || common || short_compare)\n-\tresult_type = common_type (type0, type1);\n+  /* If we're in a template, the only thing we need to know is the\n+     RESULT_TYPE.  */\n+  if (processing_template_decl)\n+    return build2 (resultcode, result_type, op0, op1);\n+\n+  if (arithmetic_types_p)\n+    {\n+      int none_complex = (code0 != COMPLEX_TYPE && code1 != COMPLEX_TYPE);\n \n       /* For certain operations (which identify themselves by shorten != 0)\n \t if both args were extended from the same smaller type,\n@@ -3419,19 +3442,11 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t}\n     }\n \n-  /* At this point, RESULT_TYPE must be nonzero to avoid an error message.\n-     If CONVERTED is zero, both args will be converted to type RESULT_TYPE.\n+  /* If CONVERTED is zero, both args will be converted to type RESULT_TYPE.\n      Then the expression will be built.\n      It will be given type FINAL_TYPE if that is nonzero;\n      otherwise, it will be given type RESULT_TYPE.  */\n \n-  if (!result_type)\n-    {\n-      error (\"invalid operands of types `%T' and `%T' to binary `%O'\",\n-\t\tTREE_TYPE (orig_op0), TREE_TYPE (orig_op1), code);\n-      return error_mark_node;\n-    }\n-\n   /* Issue warnings about peculiar, but valid, uses of NULL.  */\n   if (/* It's reasonable to use pointer values as operands of &&\n \t and ||, so NULL is no exception.  */\n@@ -3465,12 +3480,11 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n   if (build_type == NULL_TREE)\n     build_type = result_type;\n \n-  {\n-    tree result = fold (build2 (resultcode, build_type, op0, op1));\n-    if (final_type != 0)\n-      result = cp_convert (final_type, result);\n-    return result;\n-  }\n+  result = build2 (resultcode, build_type, op0, op1);\n+  result = fold_if_not_in_template (result);\n+  if (final_type != 0)\n+    result = cp_convert (final_type, result);\n+  return result;\n }\n \f\n /* Return a tree for the sum or difference (RESULTCODE says which)\n@@ -3488,7 +3502,8 @@ cp_pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n      pointer_int_sum() anyway.  */\n   complete_type (TREE_TYPE (res_type));\n \n-  return pointer_int_sum (resultcode, ptrop, fold (intop));\n+  return pointer_int_sum (resultcode, ptrop,\n+\t\t\t  fold_if_not_in_template (intop));\n }\n \n /* Return a tree for the difference of pointers OP0 and OP1.\n@@ -3532,7 +3547,7 @@ pointer_diff (tree op0, tree op1, tree ptrtype)\n   /* Do the division.  */\n \n   result = build2 (EXACT_DIV_EXPR, restype, op0, cp_convert (restype, op1));\n-  return fold (result);\n+  return fold_if_not_in_template (result);\n }\n \f\n /* Construct and perhaps optimize a tree representation\n@@ -3782,15 +3797,21 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n       if (TREE_CODE (arg) == COMPLEX_CST)\n \treturn TREE_REALPART (arg);\n       else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n-\treturn fold (build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg));\n+\t{\n+\t  arg = build1 (REALPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n+\t  return fold_if_not_in_template (arg);\n+\t}\n       else\n \treturn arg;\n \n     case IMAGPART_EXPR:\n       if (TREE_CODE (arg) == COMPLEX_CST)\n \treturn TREE_IMAGPART (arg);\n       else if (TREE_CODE (TREE_TYPE (arg)) == COMPLEX_TYPE)\n-\treturn fold (build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg));\n+\t{\n+\t  arg = build1 (IMAGPART_EXPR, TREE_TYPE (TREE_TYPE (arg)), arg);\n+\t  return fold_if_not_in_template (arg);\n+\t}\n       else\n \treturn cp_convert (TREE_TYPE (arg), integer_zero_node);\n       \n@@ -4133,7 +4154,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n     {\n       if (argtype == 0)\n \targtype = TREE_TYPE (arg);\n-      return fold (build1 (code, argtype, arg));\n+      return fold_if_not_in_template (build1 (code, argtype, arg));\n     }\n \n   error (\"%s\", errstring);\n@@ -4721,21 +4742,21 @@ build_reinterpret_cast (tree type, tree expr)\n \t   || (TYPE_PTRMEMFUNC_P (type) && TYPE_PTRMEMFUNC_P (intype)))\n     {\n       expr = decl_constant_value (expr);\n-      return fold (build1 (NOP_EXPR, type, expr));\n+      return fold_if_not_in_template (build_nop (type, expr));\n     }\n   else if ((TYPE_PTRMEM_P (type) && TYPE_PTRMEM_P (intype))\n \t   || (TYPE_PTROBV_P (type) && TYPE_PTROBV_P (intype)))\n     {\n       check_for_casting_away_constness (intype, type, \"reinterpret_cast\");\n       expr = decl_constant_value (expr);\n-      return fold (build1 (NOP_EXPR, type, expr));\n+      return fold_if_not_in_template (build_nop (type, expr));\n     }\n   else if ((TYPE_PTRFN_P (type) && TYPE_PTROBV_P (intype))\n \t   || (TYPE_PTRFN_P (intype) && TYPE_PTROBV_P (type)))\n     {\n       pedwarn (\"ISO C++ forbids casting between pointer-to-function and pointer-to-object\");\n       expr = decl_constant_value (expr);\n-      return fold (build1 (NOP_EXPR, type, expr));\n+      return fold_if_not_in_template (build_nop (type, expr));\n     }\n   else\n     {\n@@ -5382,7 +5403,8 @@ get_delta_difference (tree from, tree to, int force)\n \t}\n     }\n \n-  return fold (convert_to_integer (ptrdiff_type_node, result));\n+  return fold_if_not_in_template (convert_to_integer (ptrdiff_type_node, \n+\t\t\t\t\t\t      result));\n }\n \n /* Return a constructor for the pointer-to-member-function TYPE using\n@@ -5540,36 +5562,41 @@ expand_ptrmemfunc_cst (tree cst, tree *delta, tree *pfn)\n          fn; the call will do the opposite adjustment.  */\n       tree orig_class = DECL_CONTEXT (fn);\n       tree binfo = binfo_or_else (orig_class, fn_class);\n-      *delta = fold (build2 (PLUS_EXPR, TREE_TYPE (*delta),\n-\t\t\t     *delta, BINFO_OFFSET (binfo)));\n+      *delta = build2 (PLUS_EXPR, TREE_TYPE (*delta),\n+\t\t       *delta, BINFO_OFFSET (binfo));\n+      *delta = fold_if_not_in_template (*delta);\n \n       /* We set PFN to the vtable offset at which the function can be\n \t found, plus one (unless ptrmemfunc_vbit_in_delta, in which\n \t case delta is shifted left, and then incremented).  */\n       *pfn = DECL_VINDEX (fn);\n-      *pfn = fold (build2 (MULT_EXPR, integer_type_node, *pfn,\n-\t\t\t   TYPE_SIZE_UNIT (vtable_entry_type)));\n+      *pfn = build2 (MULT_EXPR, integer_type_node, *pfn,\n+\t\t     TYPE_SIZE_UNIT (vtable_entry_type));\n+      *pfn = fold_if_not_in_template (*pfn);\n \n       switch (TARGET_PTRMEMFUNC_VBIT_LOCATION)\n \t{\n \tcase ptrmemfunc_vbit_in_pfn:\n-\t  *pfn = fold (build2 (PLUS_EXPR, integer_type_node, *pfn,\n-\t\t\t       integer_one_node));\n+\t  *pfn = build2 (PLUS_EXPR, integer_type_node, *pfn,\n+\t\t\t integer_one_node);\n+\t  *pfn = fold_if_not_in_template (*pfn);\n \t  break;\n \n \tcase ptrmemfunc_vbit_in_delta:\n-\t  *delta = fold (build2 (LSHIFT_EXPR, TREE_TYPE (*delta),\n-\t\t\t\t *delta, integer_one_node));\n-\t  *delta = fold (build2 (PLUS_EXPR, TREE_TYPE (*delta),\n-\t\t\t\t *delta, integer_one_node));\n+\t  *delta = build2 (LSHIFT_EXPR, TREE_TYPE (*delta),\n+\t\t\t   *delta, integer_one_node);\n+\t  *delta = fold_if_not_in_template (*delta);\n+\t  *delta = build2 (PLUS_EXPR, TREE_TYPE (*delta),\n+\t\t\t   *delta, integer_one_node);\n+\t  *delta = fold_if_not_in_template (*delta);\n \t  break;\n \n \tdefault:\n \t  gcc_unreachable ();\n \t}\n \n-      *pfn = fold (build1 (NOP_EXPR, TYPE_PTRMEMFUNC_FN_TYPE (type),\n-\t\t\t   *pfn));\n+      *pfn = build_nop (TYPE_PTRMEMFUNC_FN_TYPE (type), *pfn);\n+      *pfn = fold_if_not_in_template (*pfn);\n     }\n }\n \n@@ -5639,7 +5666,7 @@ dubious_conversion_warnings (tree type, tree expr,\n       overflow_warning (expr);\n \n       if (TREE_CONSTANT (expr))\n-\texpr = fold (expr);\n+\texpr = fold_if_not_in_template (expr);\n     }\n   return expr;\n }"}, {"sha": "c86dd549700229d211281e6f92b1750ba4f8500f", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 27, "deletions": 24, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -330,8 +330,8 @@ layout_decl (tree decl, unsigned int known_align)\n     }\n   else if (DECL_SIZE_UNIT (decl) == 0)\n     DECL_SIZE_UNIT (decl)\n-      = convert (sizetype, size_binop (CEIL_DIV_EXPR, DECL_SIZE (decl),\n-\t\t\t\t       bitsize_unit_node));\n+      = fold_convert (sizetype, size_binop (CEIL_DIV_EXPR, DECL_SIZE (decl),\n+\t\t\t\t\t    bitsize_unit_node));\n \n   if (code != FIELD_DECL)\n     /* For non-fields, update the alignment from the type.  */\n@@ -540,27 +540,28 @@ tree\n bit_from_pos (tree offset, tree bitpos)\n {\n   return size_binop (PLUS_EXPR, bitpos,\n-\t\t     size_binop (MULT_EXPR, convert (bitsizetype, offset),\n+\t\t     size_binop (MULT_EXPR, \n+\t\t\t\t fold_convert (bitsizetype, offset),\n \t\t\t\t bitsize_unit_node));\n }\n \n tree\n byte_from_pos (tree offset, tree bitpos)\n {\n   return size_binop (PLUS_EXPR, offset,\n-\t\t     convert (sizetype,\n-\t\t\t      size_binop (TRUNC_DIV_EXPR, bitpos,\n-\t\t\t\t\t  bitsize_unit_node)));\n+\t\t     fold_convert (sizetype,\n+\t\t\t\t   size_binop (TRUNC_DIV_EXPR, bitpos,\n+\t\t\t\t\t       bitsize_unit_node)));\n }\n \n void\n pos_from_bit (tree *poffset, tree *pbitpos, unsigned int off_align,\n \t      tree pos)\n {\n   *poffset = size_binop (MULT_EXPR,\n-\t\t\t convert (sizetype,\n-\t\t\t\t  size_binop (FLOOR_DIV_EXPR, pos,\n-\t\t\t\t\t      bitsize_int (off_align))),\n+\t\t\t fold_convert (sizetype,\n+\t\t\t\t       size_binop (FLOOR_DIV_EXPR, pos,\n+\t\t\t\t\t\t   bitsize_int (off_align))),\n \t\t\t size_int (off_align / BITS_PER_UNIT));\n   *pbitpos = size_binop (FLOOR_MOD_EXPR, pos, bitsize_int (off_align));\n }\n@@ -580,7 +581,8 @@ normalize_offset (tree *poffset, tree *pbitpos, unsigned int off_align)\n \n       *poffset\n \t= size_binop (PLUS_EXPR, *poffset,\n-\t\t      size_binop (MULT_EXPR, convert (sizetype, extra_aligns),\n+\t\t      size_binop (MULT_EXPR, \n+\t\t\t\t  fold_convert (sizetype, extra_aligns),\n \t\t\t\t  size_int (off_align / BITS_PER_UNIT)));\n \n       *pbitpos\n@@ -869,9 +871,9 @@ place_field (record_layout_info rli, tree field)\n \t  /* First adjust OFFSET by the partial bits, then align.  */\n \t  rli->offset\n \t    = size_binop (PLUS_EXPR, rli->offset,\n-\t\t\t  convert (sizetype,\n-\t\t\t\t   size_binop (CEIL_DIV_EXPR, rli->bitpos,\n-\t\t\t\t\t       bitsize_unit_node)));\n+\t\t\t  fold_convert (sizetype,\n+\t\t\t\t\tsize_binop (CEIL_DIV_EXPR, rli->bitpos,\n+\t\t\t\t\t\t    bitsize_unit_node)));\n \t  rli->bitpos = bitsize_zero_node;\n \n \t  rli->offset = round_up (rli->offset, desired_align / BITS_PER_UNIT);\n@@ -1147,9 +1149,9 @@ place_field (record_layout_info rli, tree field)\n     {\n       rli->offset\n \t= size_binop (PLUS_EXPR, rli->offset,\n-\t\t      convert (sizetype,\n-\t\t\t       size_binop (CEIL_DIV_EXPR, rli->bitpos,\n-\t\t\t\t\t   bitsize_unit_node)));\n+\t\t      fold_convert (sizetype,\n+\t\t\t\t    size_binop (CEIL_DIV_EXPR, rli->bitpos,\n+\t\t\t\t\t\tbitsize_unit_node)));\n       rli->offset\n \t= size_binop (PLUS_EXPR, rli->offset, DECL_SIZE_UNIT (field));\n       rli->bitpos = bitsize_zero_node;\n@@ -1353,9 +1355,9 @@ finalize_type_size (tree type)\n        result will fit in sizetype.  We will get more efficient code using\n        sizetype, so we force a conversion.  */\n     TYPE_SIZE_UNIT (type)\n-      = convert (sizetype,\n-\t\t size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (type),\n-\t\t\t     bitsize_unit_node));\n+      = fold_convert (sizetype,\n+\t\t      size_binop (FLOOR_DIV_EXPR, TYPE_SIZE (type),\n+\t\t\t\t  bitsize_unit_node));\n \n   if (TYPE_SIZE (type) != 0)\n     {\n@@ -1638,10 +1640,10 @@ layout_type (tree type)\n \t    /* The initial subtraction should happen in the original type so\n \t       that (possible) negative values are handled appropriately.  */\n \t    length = size_binop (PLUS_EXPR, size_one_node,\n-\t\t\t\t convert (sizetype,\n-\t\t\t\t\t  fold (build2 (MINUS_EXPR,\n-\t\t\t\t\t\t\tTREE_TYPE (lb),\n-\t\t\t\t\t\t\tub, lb))));\n+\t\t\t\t fold_convert (sizetype,\n+\t\t\t\t\t       fold (build2 (MINUS_EXPR,\n+\t\t\t\t\t\t\t     TREE_TYPE (lb),\n+\t\t\t\t\t\t\t     ub, lb))));\n \n \t    /* Special handling for arrays of bits (for Chill).  */\n \t    element_size = TYPE_SIZE (element);\n@@ -1670,7 +1672,8 @@ layout_type (tree type)\n \t      length = size_binop (MAX_EXPR, length, size_zero_node);\n \n \t    TYPE_SIZE (type) = size_binop (MULT_EXPR, element_size,\n-\t\t\t\t\t   convert (bitsizetype, length));\n+\t\t\t\t\t   fold_convert (bitsizetype, \n+\t\t\t\t\t\t\t length));\n \n \t    /* If we know the size of the element, calculate the total\n \t       size directly, rather than do some division thing below."}, {"sha": "29293815d8cddbdd901e5c79e4d8eca262086397", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -8,6 +8,10 @@\n \tPR fortran/16938\n \t* gfortran.dg/pr16938.f90: New test.\n \n+2004-09-27  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/template/crash23.C: New test.\n+\n 2004-09-27  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/17585"}, {"sha": "0c3eac1acbfe826224ba5678a2fb102a591d7a7b", "filename": "gcc/testsuite/g++.dg/template/crash23.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash23.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash23.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash23.C?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -0,0 +1,9 @@\n+// PR c++/17642\n+\n+template<int dim>\n+int f(const int* const lsh, const int* const bbox, const int* const nghostzones, int d)\n+{\n+  for (int d=0; d<dim; ++d)\n+    lsh[d] - (bbox[2*d+1] ? 0 : nghostzones[d]);\n+}\n+"}, {"sha": "c3912e9ee72a76327782a848dbf26cbf39cf49a1", "filename": "gcc/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/455f19cb1cc13e726b806d792a8808f55aaa9a07/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=455f19cb1cc13e726b806d792a8808f55aaa9a07", "patch": "@@ -4218,7 +4218,7 @@ build_index_type (tree maxval)\n   TREE_TYPE (itype) = sizetype;\n   TYPE_PRECISION (itype) = TYPE_PRECISION (sizetype);\n   TYPE_MIN_VALUE (itype) = size_zero_node;\n-  TYPE_MAX_VALUE (itype) = convert (sizetype, maxval);\n+  TYPE_MAX_VALUE (itype) = fold_convert (sizetype, maxval);\n   TYPE_MODE (itype) = TYPE_MODE (sizetype);\n   TYPE_SIZE (itype) = TYPE_SIZE (sizetype);\n   TYPE_SIZE_UNIT (itype) = TYPE_SIZE_UNIT (sizetype);"}]}