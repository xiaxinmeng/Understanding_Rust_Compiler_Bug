{"sha": "4ec5affac92bd2e50aeae34fa9beceaf398a7377", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVjNWFmZmFjOTJiZDJlNTBhZWFlMzRmYTliZWNlYWYzOThhNzM3Nw==", "commit": {"author": {"name": "Maxim Kuvyrkov", "email": "maxim@codesourcery.com", "date": "2011-09-19T21:26:26Z"}, "committer": {"name": "Maxim Kuvyrkov", "email": "mkuvyrkov@gcc.gnu.org", "date": "2011-09-19T21:26:26Z"}, "message": "haifa-sched.c (has_edge_p, [...]): Remove maintenance overhead.\n\n\t* haifa-sched.c (has_edge_p, prev_non_location_insn, check_cfg):\n\tRemove maintenance overhead.\n\t(haifa_sched_init, sched_finish): Update.\n\nFrom-SVN: r178987", "tree": {"sha": "e551ace6d7416def4ad7987d42983ea091ec2b90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e551ace6d7416def4ad7987d42983ea091ec2b90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ec5affac92bd2e50aeae34fa9beceaf398a7377", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ec5affac92bd2e50aeae34fa9beceaf398a7377", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ec5affac92bd2e50aeae34fa9beceaf398a7377", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ec5affac92bd2e50aeae34fa9beceaf398a7377/comments", "author": null, "committer": null, "parents": [{"sha": "b5344bf45d1a2c0f3e6cf91177b855db72a9d016", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5344bf45d1a2c0f3e6cf91177b855db72a9d016", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5344bf45d1a2c0f3e6cf91177b855db72a9d016"}], "stats": {"total": 148, "additions": 6, "deletions": 142}, "files": [{"sha": "ade9a4b670b89643e052ab94f79b1a75f2d5c10c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ec5affac92bd2e50aeae34fa9beceaf398a7377/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ec5affac92bd2e50aeae34fa9beceaf398a7377/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ec5affac92bd2e50aeae34fa9beceaf398a7377", "patch": "@@ -1,3 +1,9 @@\n+2011-09-19  Maxim Kuvyrkov  <maxim@codesourcery.com>\n+\n+\t* haifa-sched.c (has_edge_p, prev_non_location_insn, check_cfg):\n+\tRemove maintenance overhead.\n+\t(haifa_sched_init, sched_finish): Update.\n+\n 2011-09-19  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/mmx.md (*mov<mode>_internal_rex64): Use if_then_else RTX"}, {"sha": "34a692fd712aade89cd6e760d33788966e07a82b", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 0, "deletions": 142, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ec5affac92bd2e50aeae34fa9beceaf398a7377/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ec5affac92bd2e50aeae34fa9beceaf398a7377/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=4ec5affac92bd2e50aeae34fa9beceaf398a7377", "patch": "@@ -717,10 +717,6 @@ static void sched_remove_insn (rtx);\n static void clear_priorities (rtx, rtx_vec_t *);\n static void calc_priorities (rtx_vec_t);\n static void add_jump_dependencies (rtx, rtx);\n-#ifdef ENABLE_CHECKING\n-static int has_edge_p (VEC(edge,gc) *, int);\n-static void check_cfg (rtx, rtx);\n-#endif\n \n #endif /* INSN_SCHEDULING */\n \f\n@@ -4303,13 +4299,6 @@ haifa_sched_init (void)\n   sched_create_empty_bb = sched_create_empty_bb_1;\n   haifa_recovery_bb_ever_added_p = false;\n \n-#ifdef ENABLE_CHECKING\n-  /* This is used preferably for finding bugs in check_cfg () itself.\n-     We must call sched_bbs_init () before check_cfg () because check_cfg ()\n-     assumes that the last insn in the last bb has a non-null successor.  */\n-  check_cfg (0, 0);\n-#endif\n-\n   nr_begin_data = nr_begin_control = nr_be_in_data = nr_be_in_control = 0;\n   before_recovery = 0;\n   after_recovery = 0;\n@@ -4378,12 +4367,6 @@ sched_finish (void)\n   regstat_free_calls_crossed ();\n \n   dfa_finish ();\n-\n-#ifdef ENABLE_CHECKING\n-  /* After reload ia64 backend clobbers CFG, so can't check anything.  */\n-  if (!reload_completed)\n-    check_cfg (0, 0);\n-#endif\n }\n \n /* Free all delay_pair structures that were recorded.  */\n@@ -5970,131 +5953,6 @@ bb_note (basic_block bb)\n   return note;\n }\n \n-#ifdef ENABLE_CHECKING\n-/* Helper function for check_cfg.\n-   Return nonzero, if edge vector pointed to by EL has edge with TYPE in\n-   its flags.  */\n-static int\n-has_edge_p (VEC(edge,gc) *el, int type)\n-{\n-  edge e;\n-  edge_iterator ei;\n-\n-  FOR_EACH_EDGE (e, ei, el)\n-    if (e->flags & type)\n-      return 1;\n-  return 0;\n-}\n-\n-/* Search back, starting at INSN, for an insn that is not a\n-   NOTE_INSN_VAR_LOCATION.  Don't search beyond HEAD, and return it if\n-   no such insn can be found.  */\n-static inline rtx\n-prev_non_location_insn (rtx insn, rtx head)\n-{\n-  while (insn != head && NOTE_P (insn)\n-\t && NOTE_KIND (insn) == NOTE_INSN_VAR_LOCATION)\n-    insn = PREV_INSN (insn);\n-\n-  return insn;\n-}\n-\n-/* Check few properties of CFG between HEAD and TAIL.\n-   If HEAD (TAIL) is NULL check from the beginning (till the end) of the\n-   instruction stream.  */\n-static void\n-check_cfg (rtx head, rtx tail)\n-{\n-  rtx next_tail;\n-  basic_block bb = 0;\n-  int not_first = 0, not_last;\n-\n-  if (head == NULL)\n-    head = get_insns ();\n-  if (tail == NULL)\n-    tail = get_last_insn ();\n-  next_tail = NEXT_INSN (tail);\n-\n-  do\n-    {\n-      not_last = head != tail;\n-\n-      if (not_first)\n-\tgcc_assert (NEXT_INSN (PREV_INSN (head)) == head);\n-      if (not_last)\n-\tgcc_assert (PREV_INSN (NEXT_INSN (head)) == head);\n-\n-      if (LABEL_P (head)\n-\t  || (NOTE_INSN_BASIC_BLOCK_P (head)\n-\t      && (!not_first\n-\t\t  || (not_first && !LABEL_P (PREV_INSN (head))))))\n-\t{\n-\t  gcc_assert (bb == 0);\n-\t  bb = BLOCK_FOR_INSN (head);\n-\t  if (bb != 0)\n-\t    gcc_assert (BB_HEAD (bb) == head);\n-\t  else\n-\t    /* This is the case of jump table.  See inside_basic_block_p ().  */\n-\t    gcc_assert (LABEL_P (head) && !inside_basic_block_p (head));\n-\t}\n-\n-      if (bb == 0)\n-\t{\n-\t  gcc_assert (!inside_basic_block_p (head));\n-\t  head = NEXT_INSN (head);\n-\t}\n-      else\n-\t{\n-\t  gcc_assert (inside_basic_block_p (head)\n-\t\t      || NOTE_P (head));\n-\t  gcc_assert (BLOCK_FOR_INSN (head) == bb);\n-\n-\t  if (LABEL_P (head))\n-\t    {\n-\t      head = NEXT_INSN (head);\n-\t      gcc_assert (NOTE_INSN_BASIC_BLOCK_P (head));\n-\t    }\n-\t  else\n-\t    {\n-\t      if (control_flow_insn_p (head))\n-\t\t{\n-\t\t  gcc_assert (prev_non_location_insn (BB_END (bb), head)\n-\t\t\t      == head);\n-\n-\t\t  if (any_uncondjump_p (head))\n-\t\t    gcc_assert (EDGE_COUNT (bb->succs) == 1\n-\t\t\t\t&& BARRIER_P (NEXT_INSN (head)));\n-\t\t  else if (any_condjump_p (head))\n-\t\t    gcc_assert (/* Usual case.  */\n-                                (EDGE_COUNT (bb->succs) > 1\n-                                 && !BARRIER_P (NEXT_INSN (head)))\n-                                /* Or jump to the next instruction.  */\n-                                || (EDGE_COUNT (bb->succs) == 1\n-                                    && (BB_HEAD (EDGE_I (bb->succs, 0)->dest)\n-                                        == JUMP_LABEL (head))));\n-\t\t}\n-\t      if (BB_END (bb) == head)\n-\t\t{\n-\t\t  if (EDGE_COUNT (bb->succs) > 1)\n-\t\t    gcc_assert (control_flow_insn_p (prev_non_location_insn\n-\t\t\t\t\t\t     (head, BB_HEAD (bb)))\n-\t\t\t\t|| has_edge_p (bb->succs, EDGE_COMPLEX));\n-\t\t  bb = 0;\n-\t\t}\n-\n-\t      head = NEXT_INSN (head);\n-\t    }\n-\t}\n-\n-      not_first = 1;\n-    }\n-  while (head != next_tail);\n-\n-  gcc_assert (bb == 0);\n-}\n-\n-#endif /* ENABLE_CHECKING */\n-\n /* Extend data structures for logical insn UID.  */\n void\n sched_extend_luids (void)"}]}