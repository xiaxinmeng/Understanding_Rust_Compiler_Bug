{"sha": "af205f678d2d6ac9043daa70c4caefdd76cd65bc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYyMDVmNjc4ZDJkNmFjOTA0M2RhYTcwYzRjYWVmZGQ3NmNkNjViYw==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2013-05-15T14:14:15Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2013-05-15T14:14:15Z"}, "message": "function.h (has_bb_partition): New rtl_data flag.\n\n2013-05-15  Teresa Johnson  <tejohnson@google.com>\n\n\t* function.h (has_bb_partition): New rtl_data flag.\n        (bb_reorder_complete): Ditto.\n\t* cfgcleanup.c (try_crossjump_to_edge): Check for has_bb_partition\n        instead of flag_reorder_blocks_and_partition.\n        * cfgrtl.c (verify_hot_cold_block_grouping): Moved from bb-reorder.c,\n        with some enhancements.\n        (rtl_verify_flow_info_1): Call verify_hot_cold_block_grouping.\n\t* bb-reorder.c (connect_traces): Check for has_bb_partition\n        instead of flag_reorder_blocks_and_partition.\n\t(verify_hot_cold_block_grouping): Moved to cfgrtl.c.\n\t(reorder_basic_blocks): Set bb_reorder_complete flag, remove call to\n        verify_hot_cold_block_grouping.\n\t(partition_hot_cold_basic_blocks): Set has_bb_partition.\n\nFrom-SVN: r198934", "tree": {"sha": "fa7f8529c4634be7caa170a0bcfcd4fd08a639c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa7f8529c4634be7caa170a0bcfcd4fd08a639c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af205f678d2d6ac9043daa70c4caefdd76cd65bc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af205f678d2d6ac9043daa70c4caefdd76cd65bc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af205f678d2d6ac9043daa70c4caefdd76cd65bc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af205f678d2d6ac9043daa70c4caefdd76cd65bc/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9adcfa3c1f4f3194b50c893f06bb52f1058aebe8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9adcfa3c1f4f3194b50c893f06bb52f1058aebe8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9adcfa3c1f4f3194b50c893f06bb52f1058aebe8"}], "stats": {"total": 116, "additions": 74, "deletions": 42}, "files": [{"sha": "fb7da45617345d376b2cd96f53d0b217a2c7dbc5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af205f678d2d6ac9043daa70c4caefdd76cd65bc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af205f678d2d6ac9043daa70c4caefdd76cd65bc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af205f678d2d6ac9043daa70c4caefdd76cd65bc", "patch": "@@ -1,3 +1,19 @@\n+2013-05-15  Teresa Johnson  <tejohnson@google.com>\n+\n+\t* function.h (has_bb_partition): New rtl_data flag.\n+\t(bb_reorder_complete): Ditto.\n+\t* cfgcleanup.c (try_crossjump_to_edge): Check for has_bb_partition\n+\tinstead of flag_reorder_blocks_and_partition.\n+\t* cfgrtl.c (verify_hot_cold_block_grouping): Moved from bb-reorder.c,\n+\twith some enhancements.\n+\t(rtl_verify_flow_info_1): Call verify_hot_cold_block_grouping.\n+\t* bb-reorder.c (connect_traces): Check for has_bb_partition\n+\tinstead of flag_reorder_blocks_and_partition.\n+\t(verify_hot_cold_block_grouping): Moved to cfgrtl.c.\n+\t(reorder_basic_blocks): Set bb_reorder_complete flag, remove call to\n+\tverify_hot_cold_block_grouping.\n+\t(partition_hot_cold_basic_blocks): Set has_bb_partition.\n+\n 2013-05-15  Ramana Radhakrishnan  <ramana.radhakrishnan@arm.com>\n \n \tPR target/19599"}, {"sha": "3167220d97298051613816406704491274d7c791", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 7, "deletions": 41, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af205f678d2d6ac9043daa70c4caefdd76cd65bc/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af205f678d2d6ac9043daa70c4caefdd76cd65bc/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=af205f678d2d6ac9043daa70c4caefdd76cd65bc", "patch": "@@ -1053,7 +1053,7 @@ connect_traces (int n_traces, struct trace *traces)\n   current_partition = BB_PARTITION (traces[0].first);\n   two_passes = false;\n \n-  if (flag_reorder_blocks_and_partition)\n+  if (crtl->has_bb_partition)\n     for (i = 0; i < n_traces && !two_passes; i++)\n       if (BB_PARTITION (traces[0].first)\n \t  != BB_PARTITION (traces[i].first))\n@@ -1262,7 +1262,7 @@ connect_traces (int n_traces, struct trace *traces)\n \t\t      }\n \t\t  }\n \n-\t      if (flag_reorder_blocks_and_partition)\n+\t      if (crtl->has_bb_partition)\n \t\ttry_copy = false;\n \n \t      /* Copy tiny blocks always; copy larger blocks only when the\n@@ -2068,43 +2068,6 @@ add_reg_crossing_jump_notes (void)\n \tadd_reg_note (BB_END (e->src), REG_CROSSING_JUMP, NULL_RTX);\n }\n \n-/* Verify, in the basic block chain, that there is at most one switch\n-   between hot/cold partitions. This is modelled on\n-   rtl_verify_flow_info_1, but it cannot go inside that function\n-   because this condition will not be true until after\n-   reorder_basic_blocks is called.  */\n-\n-static void\n-verify_hot_cold_block_grouping (void)\n-{\n-  basic_block bb;\n-  int err = 0;\n-  bool switched_sections = false;\n-  int current_partition = 0;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      if (!current_partition)\n-\tcurrent_partition = BB_PARTITION (bb);\n-      if (BB_PARTITION (bb) != current_partition)\n-\t{\n-\t  if (switched_sections)\n-\t    {\n-\t      error (\"multiple hot/cold transitions found (bb %i)\",\n-\t\t     bb->index);\n-\t      err = 1;\n-\t    }\n-\t  else\n-\t    {\n-\t      switched_sections = true;\n-\t      current_partition = BB_PARTITION (bb);\n-\t    }\n-\t}\n-    }\n-\n-  gcc_assert(!err);\n-}\n-\n /* Reorder basic blocks.  The main entry point to this file.  FLAGS is\n    the set of flags to pass to cfg_layout_initialize().  */\n \n@@ -2157,8 +2120,9 @@ reorder_basic_blocks (void)\n       dump_flow_info (dump_file, dump_flags);\n     }\n \n-  if (flag_reorder_blocks_and_partition)\n-    verify_hot_cold_block_grouping ();\n+  /* Signal that rtl_verify_flow_info_1 can now verify that there\n+     is at most one switch between hot/cold sections.  */\n+  crtl->bb_reorder_complete = true;\n }\n \n /* Determine which partition the first basic block in the function\n@@ -2503,6 +2467,8 @@ partition_hot_cold_basic_blocks (void)\n   if (!crossing_edges.exists ())\n     return 0;\n \n+  crtl->has_bb_partition = true;\n+\n   /* Make sure the source of any crossing edge ends in a jump and the\n      destination of any crossing edge has a label.  */\n   add_labels_and_missing_jumps (crossing_edges);"}, {"sha": "1379cf761565449c1a12fc26f6b7824bb30959fa", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af205f678d2d6ac9043daa70c4caefdd76cd65bc/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af205f678d2d6ac9043daa70c4caefdd76cd65bc/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=af205f678d2d6ac9043daa70c4caefdd76cd65bc", "patch": "@@ -1864,7 +1864,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n      partition boundaries).  See the comments at the top of\n      bb-reorder.c:partition_hot_cold_basic_blocks for complete details.  */\n \n-  if (flag_reorder_blocks_and_partition && reload_completed)\n+  if (crtl->has_bb_partition && reload_completed)\n     return false;\n \n   /* Search backward through forwarder blocks.  We don't need to worry"}, {"sha": "335e4d972bb7ca63807b9d1b93df8533d8d58711", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af205f678d2d6ac9043daa70c4caefdd76cd65bc/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af205f678d2d6ac9043daa70c4caefdd76cd65bc/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=af205f678d2d6ac9043daa70c4caefdd76cd65bc", "patch": "@@ -2058,6 +2058,44 @@ get_last_bb_insn (basic_block bb)\n \n   return end;\n }\n+\n+/* Verify, in the basic block chain, that there is at most one switch\n+   between hot/cold partitions. This condition will not be true until\n+   after reorder_basic_blocks is called.  */\n+\n+static void\n+verify_hot_cold_block_grouping (void)\n+{\n+  basic_block bb;\n+  int err = 0;\n+  bool switched_sections = false;\n+  int current_partition = BB_UNPARTITIONED;\n+\n+  if (!crtl->bb_reorder_complete)\n+    return;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      if (current_partition != BB_UNPARTITIONED\n+          && BB_PARTITION (bb) != current_partition)\n+\t{\n+\t  if (switched_sections)\n+\t    {\n+\t      error (\"multiple hot/cold transitions found (bb %i)\",\n+\t\t     bb->index);\n+\t      err = 1;\n+\t    }\n+\t  else\n+            switched_sections = true;\n+\n+          if (!crtl->has_bb_partition)\n+            error (\"partition found but function partition flag not set\");\n+\t}\n+      current_partition = BB_PARTITION (bb);\n+    }\n+\n+  gcc_assert(!err);\n+}\n \f\n /* Verify the CFG and RTL consistency common for both underlying RTL and\n    cfglayout RTL.\n@@ -2072,6 +2110,7 @@ get_last_bb_insn (basic_block bb)\n      and NOTE_INSN_BASIC_BLOCK\n    - verify that no fall_thru edge crosses hot/cold partition boundaries\n    - verify that there are no pending RTL branch predictions\n+   - verify that there is a single hot/cold partition boundary after bbro\n \n    In future it can be extended check a lot of other stuff as well\n    (reachability of basic blocks, life information, etc. etc.).  */\n@@ -2323,6 +2362,8 @@ rtl_verify_flow_info_1 (void)\n \t  }\n     }\n \n+  verify_hot_cold_block_grouping();\n+\n   /* Clean up.  */\n   return err;\n }"}, {"sha": "c651f5037f8b1f805467281a09ceab02d60de5e9", "filename": "gcc/function.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af205f678d2d6ac9043daa70c4caefdd76cd65bc/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af205f678d2d6ac9043daa70c4caefdd76cd65bc/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=af205f678d2d6ac9043daa70c4caefdd76cd65bc", "patch": "@@ -446,6 +446,15 @@ struct GTY(()) rtl_data {\n      sched2) and is useful only if the port defines LEAF_REGISTERS.  */\n   bool uses_only_leaf_regs;\n \n+  /* Nonzero if the function being compiled has undergone hot/cold partitioning\n+     (under flag_reorder_blocks_and_partition) and has at least one cold\n+     block.  */\n+  bool has_bb_partition;\n+\n+  /* Nonzero if the function being compiled has completed the bb reordering\n+     pass.  */\n+  bool bb_reorder_complete;\n+\n   /* Like regs_ever_live, but 1 if a reg is set or clobbered from an\n      asm.  Unlike regs_ever_live, elements of this array corresponding\n      to eliminable regs (like the frame pointer) are set if an asm"}]}