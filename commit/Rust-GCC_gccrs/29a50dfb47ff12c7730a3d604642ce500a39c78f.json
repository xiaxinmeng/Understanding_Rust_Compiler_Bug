{"sha": "29a50dfb47ff12c7730a3d604642ce500a39c78f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlhNTBkZmI0N2ZmMTJjNzczMGEzZDYwNDY0MmNlNTAwYTM5Yzc4Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2018-06-08T16:12:39Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2018-06-08T16:12:39Z"}, "message": "dumpfile.c (FIRST_ME_AUTO_NUMBERED_DUMP): Bump to 4.\n\n\n\t* dumpfile.c (FIRST_ME_AUTO_NUMBERED_DUMP): Bump to 4.\n\t* lto-lang.c (lto_link_dump_id, decl_merge_dump_id, partition_dump_id):\n\tNew global vars.\n\t(lto_register_dumps): New hook.\n\t(LANG_HOOKS_REGISTER_DUMPS): New.\n\t* lto-partition.c: Dump into dump_file instead of symtab->dump_file.\n\t* lto-symtab.c: Include lto.h; dump into dump_file instead of\n\tsymtab->dump_file.\n\t(lto_symtab_merge_decls): Initialize dump file.\n\t* lto.c (read_cgraph_and_symbols): Initialize dump file.\n\t(do_whole_program_analysis): Likewise.\n\nFrom-SVN: r261337", "tree": {"sha": "bc0b8a743872bd4b0673daa75981a8ee8dbce830", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc0b8a743872bd4b0673daa75981a8ee8dbce830"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29a50dfb47ff12c7730a3d604642ce500a39c78f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a50dfb47ff12c7730a3d604642ce500a39c78f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29a50dfb47ff12c7730a3d604642ce500a39c78f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a50dfb47ff12c7730a3d604642ce500a39c78f/comments", "author": null, "committer": null, "parents": [{"sha": "850078b7387f7286aac70e1e594f39baf9f429af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/850078b7387f7286aac70e1e594f39baf9f429af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/850078b7387f7286aac70e1e594f39baf9f429af"}], "stats": {"total": 244, "additions": 155, "deletions": 89}, "files": [{"sha": "1e67efcca28e67a40ac8bdf5c2846fe1cbdeb4be", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=29a50dfb47ff12c7730a3d604642ce500a39c78f", "patch": "@@ -1,3 +1,7 @@\n+2018-06-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* dumpfile.c (FIRST_ME_AUTO_NUMBERED_DUMP): Bump to 4.\n+\n 2018-06-08  David Edelsohn  <dje.gcc@gmail.com>\n \n \t* config/rs6000/rs6000.c (rs6000_passes_ieee128): Protect with #if"}, {"sha": "3dd41c42a7fa409ff312900b04ceae4f28929113", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=29a50dfb47ff12c7730a3d604642ce500a39c78f", "patch": "@@ -65,7 +65,7 @@ static struct dump_file_info dump_files[TDI_end] =\n   DUMP_FILE_INFO (\".gimple\", \"tree-gimple\", DK_tree, 0),\n   DUMP_FILE_INFO (\".nested\", \"tree-nested\", DK_tree, 0),\n #define FIRST_AUTO_NUMBERED_DUMP 1\n-#define FIRST_ME_AUTO_NUMBERED_DUMP 3\n+#define FIRST_ME_AUTO_NUMBERED_DUMP 4\n \n   DUMP_FILE_INFO (NULL, \"lang-all\", DK_lang, 0),\n   DUMP_FILE_INFO (NULL, \"tree-all\", DK_tree, 0),"}, {"sha": "feb98bbb521b6bd8cf010181b072f5635aff3eef", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=29a50dfb47ff12c7730a3d604642ce500a39c78f", "patch": "@@ -1,3 +1,16 @@\n+2018-06-08  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* lto-lang.c (lto_link_dump_id, decl_merge_dump_id, partition_dump_id):\n+\tNew global vars.\n+\t(lto_register_dumps): New hook.\n+\t(LANG_HOOKS_REGISTER_DUMPS): New.\n+\t* lto-partition.c: Dump into dump_file instead of symtab->dump_file.\n+\t* lto-symtab.c: Include lto.h; dump into dump_file instead of\n+\tsymtab->dump_file.\n+\t(lto_symtab_merge_decls): Initialize dump file.\n+\t* lto.c (read_cgraph_and_symbols): Initialize dump file.\n+\t(do_whole_program_analysis): Likewise.\n+\n 2018-06-08  Martin Liska  <mliska@suse.cz>\n \n \t* lto-partition.c (lto_balanced_map): Use cgraph_node::uid"}, {"sha": "a1a41bc27512c99607c8af93161e7d79ec031aac", "filename": "gcc/lto/lto-lang.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2Flto-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2Flto-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-lang.c?ref=29a50dfb47ff12c7730a3d604642ce500a39c78f", "patch": "@@ -37,6 +37,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"attribs.h\"\n \n+/* LTO specific dumps.  */\n+int lto_link_dump_id, decl_merge_dump_id, partition_dump_id;\n+\n static tree handle_noreturn_attribute (tree *, tree, tree, int, bool *);\n static tree handle_leaf_attribute (tree *, tree, tree, int, bool *);\n static tree handle_const_attribute (tree *, tree, tree, int, bool *);\n@@ -1375,6 +1378,23 @@ lto_init (void)\n   return true;\n }\n \n+/* Register c++-specific dumps.  */\n+\n+void\n+lto_register_dumps (gcc::dump_manager *dumps)\n+{\n+  lto_link_dump_id = dumps->dump_register\n+    (\".lto-link\", \"ipa-lto-link\", \"ipa-lto-link\",\n+     DK_ipa, OPTGROUP_NONE, false);\n+  decl_merge_dump_id = dumps->dump_register\n+    (\".lto-decl-merge\", \"ipa-lto-decl-merge\", \"ipa-lto-decl-merge\",\n+     DK_ipa, OPTGROUP_NONE, false);\n+  partition_dump_id = dumps->dump_register\n+    (\".lto-partition\", \"ipa-lto-partition\", \"ipa-lto-partition\",\n+     DK_ipa, OPTGROUP_NONE, false);\n+}\n+\n+\n /* Initialize tree structures required by the LTO front end.  */\n \n static void lto_init_ts (void)\n@@ -1390,6 +1410,8 @@ static void lto_init_ts (void)\n #define LANG_HOOKS_COMPLAIN_WRONG_LANG_P lto_complain_wrong_lang_p\n #undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n #define LANG_HOOKS_INIT_OPTIONS_STRUCT lto_init_options_struct\n+#undef LANG_HOOKS_REGISTER_DUMPS\n+#define LANG_HOOKS_REGISTER_DUMPS lto_register_dumps\n #undef LANG_HOOKS_HANDLE_OPTION\n #define LANG_HOOKS_HANDLE_OPTION lto_handle_option\n #undef LANG_HOOKS_POST_OPTIONS"}, {"sha": "0ceb1b63f953e7376a473fd1ef24b97a86452893", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 33, "deletions": 33, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=29a50dfb47ff12c7730a3d604642ce500a39c78f", "patch": "@@ -160,8 +160,8 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n   if (symbol_partitioned_p (node))\n     {\n       node->in_other_partition = 1;\n-      if (symtab->dump_file)\n-\tfprintf (symtab->dump_file,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Symbol node %s now used in multiple partitions\\n\",\n \t\t node->name ());\n     }\n@@ -541,13 +541,13 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n   order.qsort (node_cmp);\n   noreorder.qsort (node_cmp);\n \n-  if (symtab->dump_file)\n+  if (dump_file)\n     {\n       for (unsigned i = 0; i < order.length (); i++)\n-\tfprintf (symtab->dump_file, \"Balanced map symbol order:%s:%u\\n\",\n+\tfprintf (dump_file, \"Balanced map symbol order:%s:%u\\n\",\n \t\t order[i]->name (), order[i]->tp_first_run);\n       for (unsigned i = 0; i < noreorder.length (); i++)\n-\tfprintf (symtab->dump_file, \"Balanced map symbol no_reorder:%s:%u\\n\",\n+\tfprintf (dump_file, \"Balanced map symbol no_reorder:%s:%u\\n\",\n \t\t noreorder[i]->name (), noreorder[i]->tp_first_run);\n     }\n \n@@ -569,8 +569,8 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n     partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n   npartitions = 1;\n   partition = new_partition (\"\");\n-  if (symtab->dump_file)\n-    fprintf (symtab->dump_file, \"Total unit size: %\" PRId64 \", partition size: %\" PRId64 \"\\n\",\n+  if (dump_file)\n+    fprintf (dump_file, \"Total unit size: %\" PRId64 \", partition size: %\" PRId64 \"\\n\",\n \t     total_size, partition_size);\n \n   auto_vec<symtab_node *> next_nodes;\n@@ -763,8 +763,8 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t  best_n_nodes = lto_symtab_encoder_size (partition->encoder);\n \t  best_varpool_pos = varpool_pos;\n \t}\n-      if (symtab->dump_file)\n-\tfprintf (symtab->dump_file, \"Step %i: added %s/%i, size %i, \"\n+      if (dump_file)\n+\tfprintf (dump_file, \"Step %i: added %s/%i, size %i, \"\n \t\t \"cost %\" PRId64 \"/%\" PRId64 \" \"\n \t\t \"best %\" PRId64 \"/%\" PRId64\", step %i\\n\", i,\n \t\t order[i]->name (), order[i]->order,\n@@ -777,16 +777,16 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t{\n \t  if (best_i != i)\n \t    {\n-\t      if (symtab->dump_file)\n-\t\tfprintf (symtab->dump_file, \"Unwinding %i insertions to step %i\\n\",\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Unwinding %i insertions to step %i\\n\",\n \t\t\t i - best_i, best_i);\n \t      undo_partition (partition, best_n_nodes);\n \t      varpool_pos = best_varpool_pos;\n \t    }\n \t  gcc_assert (best_size == partition->insns);\n \t  i = best_i;\n-\t  if (symtab->dump_file)\n-\t    fprintf (symtab->dump_file,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Partition insns: %i (want %\" PRId64 \")\\n\",\n \t\t     partition->insns, partition_size);\n  \t  /* When we are finished, avoid creating empty partition.  */\n@@ -799,8 +799,8 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t  last_visited_node = 0;\n \t  cost = 0;\n \n-\t  if (symtab->dump_file)\n-\t    fprintf (symtab->dump_file, \"New partition\\n\");\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"New partition\\n\");\n \t  best_n_nodes = 0;\n \t  best_cost = -1;\n \n@@ -812,8 +812,8 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t    /* Watch for overflow.  */\n \t    partition_size = INT_MAX / 16;\n \n-\t  if (symtab->dump_file)\n-\t    fprintf (symtab->dump_file,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Total size: %\" PRId64 \" partition_size: %\" PRId64 \"\\n\",\n \t\t     total_size, partition_size);\n \t  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n@@ -840,21 +840,21 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n   gcc_assert (next_nodes.length () || npartitions != 1 || !best_cost || best_cost == -1);\n   add_sorted_nodes (next_nodes, partition);\n \n-  if (symtab->dump_file)\n+  if (dump_file)\n     {\n-      fprintf (symtab->dump_file, \"\\nPartition sizes:\\n\");\n+      fprintf (dump_file, \"\\nPartition sizes:\\n\");\n       unsigned partitions = ltrans_partitions.length ();\n \n       for (unsigned i = 0; i < partitions ; i++)\n \t{\n \t  ltrans_partition p = ltrans_partitions[i];\n-\t  fprintf (symtab->dump_file, \"partition %d contains %d (%2.2f%%)\"\n+\t  fprintf (dump_file, \"partition %d contains %d (%2.2f%%)\"\n \t\t   \" symbols and %d (%2.2f%%) insns\\n\", i, p->symbols,\n \t\t   100.0 * p->symbols / order.length (), p->insns,\n \t\t   100.0 * p->insns / original_total_size);\n \t}\n \n-      fprintf (symtab->dump_file, \"\\n\");\n+      fprintf (dump_file, \"\\n\");\n     }\n }\n \n@@ -869,8 +869,8 @@ must_not_rename (symtab_node *node, const char *name)\n   if (node->lto_file_data\n       && lto_get_decl_name_mapping (node->lto_file_data, name) != name)\n     {\n-      if (symtab->dump_file)\n-\tfprintf (symtab->dump_file,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Not privatizing symbol name: %s. It privatized already.\\n\",\n \t\t name);\n       return true;\n@@ -881,8 +881,8 @@ must_not_rename (symtab_node *node, const char *name)\n      that are not really clones.  */\n   if (node->unique_name)\n     {\n-      if (symtab->dump_file)\n-\tfprintf (symtab->dump_file,\n+      if (dump_file)\n+\tfprintf (dump_file,\n \t\t \"Not privatizing symbol name: %s. Has unique name.\\n\",\n \t\t name);\n       return true;\n@@ -972,8 +972,8 @@ privatize_symbol_name_1 (symtab_node *node, tree decl)\n \t\t\t     IDENTIFIER_POINTER\n \t\t\t     (DECL_ASSEMBLER_NAME (decl)));\n \n-  if (symtab->dump_file)\n-    fprintf (symtab->dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"Privatizing symbol name: %s -> %s\\n\",\n \t     name, IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)));\n \n@@ -1018,8 +1018,8 @@ promote_symbol (symtab_node *node)\n   TREE_PUBLIC (node->decl) = 1;\n   DECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n   DECL_VISIBILITY_SPECIFIED (node->decl) = true;\n-  if (symtab->dump_file)\n-    fprintf (symtab->dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t     \"Promoting as hidden: %s (%s)\\n\", node->name (),\n \t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)));\n \n@@ -1035,8 +1035,8 @@ promote_symbol (symtab_node *node)\n \t  TREE_PUBLIC (alias->decl) = 1;\n \t  DECL_VISIBILITY (alias->decl) = VISIBILITY_HIDDEN;\n \t  DECL_VISIBILITY_SPECIFIED (alias->decl) = true;\n-\t  if (symtab->dump_file)\n-\t    fprintf (symtab->dump_file,\n+\t  if (dump_file)\n+\t    fprintf (dump_file,\n \t\t     \"Promoting alias as hidden: %s\\n\",\n \t\t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)));\n \t}\n@@ -1102,8 +1102,8 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)\n   if (!s)\n     return;\n \n-  if (symtab->dump_file)\n-    fprintf (symtab->dump_file,\n+  if (dump_file)\n+    fprintf (dump_file,\n \t    \"Renaming statics with asm name: %s\\n\", node->name ());\n \n   /* Assign every symbol in the set that shares the same ASM name an unique"}, {"sha": "a40ba1f32eff706a7d9d9a45935843010ac19df4", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=29a50dfb47ff12c7730a3d604642ce500a39c78f", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ipa-utils.h\"\n #include \"builtins.h\"\n #include \"alias.h\"\n+#include \"lto.h\"\n #include \"lto-symtab.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n@@ -45,9 +46,9 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n   struct cgraph_edge *e, *next;\n   bool compatible_p;\n \n-  if (symtab->dump_file)\n+  if (dump_file)\n     {\n-      fprintf (symtab->dump_file, \"Replacing cgraph node %s by %s\"\n+      fprintf (dump_file, \"Replacing cgraph node %s by %s\"\n  \t       \" for symbol %s\\n\",\n \t       node->dump_name (),\n \t       prevailing_node->dump_name (),\n@@ -211,7 +212,7 @@ warn_type_compatibility_p (tree prevailing_type, tree type,\n       if (TREE_CODE (type) != TREE_CODE (prevailing_type))\n \tlev |= 1;\n       lev |= warn_type_compatibility_p (TREE_TYPE (prevailing_type),\n-\t\t\t\t        TREE_TYPE (type), false);\n+\t\t\t\t\tTREE_TYPE (type), false);\n       if (TREE_CODE (type) == METHOD_TYPE\n \t  && TREE_CODE (prevailing_type) == METHOD_TYPE)\n \tlev |= warn_type_compatibility_p (TYPE_METHOD_BASETYPE (prevailing_type),\n@@ -271,7 +272,7 @@ warn_type_compatibility_p (tree prevailing_type, tree type,\n \n       if (set1 && set2 && set1 != set2)\n \t{\n-          tree t1 = type, t2 = prevailing_type;\n+\t   tree t1 = type, t2 = prevailing_type;\n \n \t  /* Alias sets of arrays with aliased components are the same as alias\n \t     sets of the inner types.  */\n@@ -283,10 +284,10 @@ warn_type_compatibility_p (tree prevailing_type, tree type,\n \t      t1 = TREE_TYPE (t1);\n \t      t2 = TREE_TYPE (t2);\n \t    }\n-          if ((!POINTER_TYPE_P (t1) || !POINTER_TYPE_P (t2))\n+\t  if ((!POINTER_TYPE_P (t1) || !POINTER_TYPE_P (t2))\n \t      || (set1 != TYPE_ALIAS_SET (ptr_type_node)\n \t\t  && set2 != TYPE_ALIAS_SET (ptr_type_node)))\n-             lev |= 5;\n+\t    lev |= 5;\n \t}\n     }\n \n@@ -325,7 +326,7 @@ lto_symtab_merge (symtab_node *prevailing, symtab_node *entry)\n       DECL_POSSIBLY_INLINED (decl) |= DECL_POSSIBLY_INLINED (prevailing_decl);\n \n       if (warn_type_compatibility_p (TREE_TYPE (prevailing_decl),\n-\t\t\t             TREE_TYPE (decl),\n+\t\t\t\t     TREE_TYPE (decl),\n \t\t\t\t     DECL_COMMON (decl)\n \t\t\t\t     || DECL_EXTERNAL (decl)))\n \treturn false;\n@@ -536,8 +537,8 @@ lto_symtab_merge_p (tree prevailing, tree decl)\n {\n   if (TREE_CODE (prevailing) != TREE_CODE (decl))\n     {\n-      if (symtab->dump_file)\n-\tfprintf (symtab->dump_file, \"Not merging decls; \"\n+      if (dump_file)\n+\tfprintf (dump_file, \"Not merging decls; \"\n \t\t \"TREE_CODE mismatch\\n\");\n       return false;\n     }\n@@ -547,17 +548,17 @@ lto_symtab_merge_p (tree prevailing, tree decl)\n     {\n       if (DECL_BUILT_IN (prevailing) != DECL_BUILT_IN (decl))\n \t{\n-          if (symtab->dump_file)\n-\t    fprintf (symtab->dump_file, \"Not merging decls; \"\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not merging decls; \"\n \t\t     \"DECL_BUILT_IN mismatch\\n\");\n \t  return false;\n \t}\n       if (DECL_BUILT_IN (prevailing)\n \t  && (DECL_BUILT_IN_CLASS (prevailing) != DECL_BUILT_IN_CLASS (decl)\n \t      || DECL_FUNCTION_CODE (prevailing) != DECL_FUNCTION_CODE (decl)))\n \t{\n-          if (symtab->dump_file)\n-\t    fprintf (symtab->dump_file, \"Not merging decls; \"\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not merging decls; \"\n \t\t     \"DECL_BUILT_IN_CLASS or CODE mismatch\\n\");\n \t  return false;\n \t}\n@@ -572,8 +573,8 @@ lto_symtab_merge_p (tree prevailing, tree decl)\n       if ((prev_attr == NULL) != (attr == NULL)\n \t  || (prev_attr && !attribute_value_equal (prev_attr, attr)))\n \t{\n-          if (symtab->dump_file)\n-\t    fprintf (symtab->dump_file, \"Not merging decls; \"\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not merging decls; \"\n \t\t     \"error attribute mismatch\\n\");\n \t  return false;\n \t}\n@@ -583,8 +584,8 @@ lto_symtab_merge_p (tree prevailing, tree decl)\n       if ((prev_attr == NULL) != (attr == NULL)\n \t  || (prev_attr && !attribute_value_equal (prev_attr, attr)))\n \t{\n-          if (symtab->dump_file)\n-\t    fprintf (symtab->dump_file, \"Not merging decls; \"\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not merging decls; \"\n \t\t     \"warning attribute mismatch\\n\");\n \t  return false;\n \t}\n@@ -593,8 +594,8 @@ lto_symtab_merge_p (tree prevailing, tree decl)\n       attr = lookup_attribute (\"noreturn\", DECL_ATTRIBUTES (decl));\n       if ((prev_attr == NULL) != (attr == NULL))\n \t{\n-          if (symtab->dump_file)\n-\t    fprintf (symtab->dump_file, \"Not merging decls; \"\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not merging decls; \"\n \t\t     \"noreturn attribute mismatch\\n\");\n \t  return false;\n \t}\n@@ -631,7 +632,7 @@ lto_symtab_merge_decls_2 (symtab_node *first, bool diagnosed_p)\n \t visited.  */\n       if (lto_symtab_prevailing_decl (e->decl) != e->decl\n \t  || !lto_symtab_symbol_p (e)\n-          || e->decl == prevailing->decl)\n+\t  || e->decl == prevailing->decl)\n \tcontinue;\n \n       if (!lto_symtab_merge (prevailing, e)\n@@ -683,9 +684,9 @@ lto_symtab_merge_decls_2 (symtab_node *first, bool diagnosed_p)\n   FOR_EACH_VEC_ELT (mismatches, i, decl)\n     {\n       /* Do not diagnose two built-in declarations, there is no useful\n-         location in that case.  It also happens for AVR if two built-ins\n-         use the same asm name because their libgcc assembler code is the\n-         same, see PR78562.  */\n+\t location in that case.  It also happens for AVR if two built-ins\n+\t use the same asm name because their libgcc assembler code is the\n+\t same, see PR78562.  */\n       if (DECL_IS_BUILTIN (prevailing->decl)\n \t  && DECL_IS_BUILTIN (decl))\n \tcontinue;\n@@ -719,7 +720,7 @@ lto_symtab_merge_decls_2 (symtab_node *first, bool diagnosed_p)\n \t  diagnosed_p |= diag;\n \t}\n       else if ((DECL_USER_ALIGN (prevailing->decl)\n-\t        && DECL_USER_ALIGN (decl))\n+\t\t&& DECL_USER_ALIGN (decl))\n \t       && DECL_ALIGN (prevailing->decl) < DECL_ALIGN (decl))\n \t{\n \t  diagnosed_p |= warning_at (DECL_SOURCE_LOCATION (decl),\n@@ -753,13 +754,13 @@ lto_symtab_merge_decls_1 (symtab_node *first)\n   symtab_node *prevailing;\n   bool diagnosed_p = false;\n \n-  if (symtab->dump_file)\n+  if (dump_file)\n     {\n-      fprintf (symtab->dump_file, \"Merging nodes for %s. Candidates:\\n\",\n+      fprintf (dump_file, \"Merging nodes for %s. Candidates:\\n\",\n \t       first->asm_name ());\n       for (e = first; e; e = e->next_sharing_asm_name)\n \tif (TREE_PUBLIC (e->decl))\n-\t  e->dump (symtab->dump_file);\n+\t  e->dump (dump_file);\n     }\n \n   /* Compute the symbol resolutions.  This is a no-op when using the\n@@ -849,11 +850,11 @@ lto_symtab_merge_decls_1 (symtab_node *first)\n      mismatches.  */\n   lto_symtab_merge_decls_2 (prevailing, diagnosed_p);\n \n-  if (symtab->dump_file)\n+  if (dump_file)\n     {\n-      fprintf (symtab->dump_file, \"After resolution:\\n\");\n+      fprintf (dump_file, \"After resolution:\\n\");\n       for (e = prevailing; e; e = e->next_sharing_asm_name)\n-\te->dump (symtab->dump_file);\n+\te->dump (dump_file);\n     }\n }\n \n@@ -864,13 +865,20 @@ lto_symtab_merge_decls (void)\n {\n   symtab_node *node;\n \n+  gcc_assert (!dump_file);\n+  dump_file = dump_begin (decl_merge_dump_id, NULL);\n+\n   /* Populate assembler name hash.   */\n   symtab->symtab_initialize_asm_name_hash ();\n \n   FOR_EACH_SYMBOL (node)\n     if (!node->previous_sharing_asm_name\n \t&& node->next_sharing_asm_name)\n       lto_symtab_merge_decls_1 (node);\n+\n+  if (dump_file)\n+    dump_end (decl_merge_dump_id, dump_file);\n+  dump_file = NULL;\n }\n \n /* Helper to process the decl chain for the symbol table entry *SLOT.  */\n@@ -897,7 +905,7 @@ lto_symtab_merge_symbols_1 (symtab_node *prevailing)\n       /* No matter how we are going to deal with resolution, we will ultimately\n \t use prevailing definition.  */\n       if (ce)\n-          ipa_merge_profiles (dyn_cast<cgraph_node *> (prevailing),\n+\tipa_merge_profiles (dyn_cast<cgraph_node *> (prevailing),\n \t\t\t      dyn_cast<cgraph_node *> (e));\n \n       /* If we decided to replace the node by TO, do it.  */\n@@ -919,7 +927,7 @@ lto_symtab_merge_symbols_1 (symtab_node *prevailing)\n \t    {\n \t      lto_free_function_in_decl_state_for_node (ce);\n \t      if (!ce->weakref)\n-\t        ce->release_body ();\n+\t\tce->release_body ();\n \t      ce->reset ();\n \t      symtab->call_cgraph_removal_hooks (ce);\n \t    }\n@@ -956,7 +964,7 @@ lto_symtab_merge_symbols (void)\n       symtab->symtab_initialize_asm_name_hash ();\n \n       /* Do the actual merging.  \n-         At this point we invalidate hash translating decls into symtab nodes\n+\t At this point we invalidate hash translating decls into symtab nodes\n \t because after removing one of duplicate decls the hash is not correcly\n \t updated to the ohter dupliate.  */\n       FOR_EACH_SYMBOL (node)"}, {"sha": "3b57c12bc9ff23ef8da83482802d167d3aee2942", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=29a50dfb47ff12c7730a3d604642ce500a39c78f", "patch": "@@ -2972,29 +2972,43 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n       all_file_decl_data[i]->current_decl_state = NULL; \n     }\n \n-  /* Finally merge the cgraph according to the decl merging decisions.  */\n-  timevar_push (TV_IPA_LTO_CGRAPH_MERGE);\n-  if (symtab->dump_file)\n-    {\n-      fprintf (symtab->dump_file, \"Before merging:\\n\");\n-      symtab->dump (symtab->dump_file);\n-    }\n   if (!flag_ltrans)\n     {\n+      /* Finally merge the cgraph according to the decl merging decisions.  */\n+      timevar_push (TV_IPA_LTO_CGRAPH_MERGE);\n+\n+      gcc_assert (!dump_file);\n+      dump_file = dump_begin (lto_link_dump_id, NULL);\n+\n+      if (dump_file)\n+\t{\n+\t  fprintf (dump_file, \"Before merging:\\n\");\n+\t  symtab->dump (dump_file);\n+\t}\n       lto_symtab_merge_symbols ();\n       /* Removal of unreachable symbols is needed to make verify_symtab to pass;\n \t we are still having duplicated comdat groups containing local statics.\n \t We could also just remove them while merging.  */\n       symtab->remove_unreachable_nodes (dump_file);\n+      ggc_collect ();\n+\n+      if (dump_file)\n+        dump_end (lto_link_dump_id, dump_file);\n+      dump_file = NULL;\n+      timevar_pop (TV_IPA_LTO_CGRAPH_MERGE);\n     }\n-  ggc_collect ();\n   symtab->state = IPA_SSA;\n-  /* FIXME: Technically all node removals happening here are useless, because\n-     WPA should not stream them.  */\n+  /* All node removals happening here are useless, because\n+     WPA should not stream them.  Still always perform remove_unreachable_nodes\n+     because we may reshape clone tree, get rid of dead masters of inline\n+     clones and remove symbol entries for read-only variables we keep around\n+     only to be able to constant fold them.  */\n   if (flag_ltrans)\n-    symtab->remove_unreachable_nodes (dump_file);\n-\n-  timevar_pop (TV_IPA_LTO_CGRAPH_MERGE);\n+    {\n+      if (symtab->dump_file)\n+\t symtab->dump (symtab->dump_file);\n+      symtab->remove_unreachable_nodes (symtab->dump_file);\n+    }\n \n   /* Indicate that the cgraph is built and ready.  */\n   symtab->function_flags_ready = true;\n@@ -3152,19 +3166,19 @@ do_whole_program_analysis (void)\n   if (seen_error ())\n     return;\n \n-  if (symtab->dump_file)\n-    {\n-      fprintf (symtab->dump_file, \"Optimized \");\n-      symtab->dump (symtab->dump_file);\n-    }\n-\n-  symtab_node::checking_verify_symtab_nodes ();\n-  bitmap_obstack_release (NULL);\n-\n   /* We are about to launch the final LTRANS phase, stop the WPA timer.  */\n   timevar_pop (TV_WHOPR_WPA);\n \n   timevar_push (TV_WHOPR_PARTITIONING);\n+\n+  gcc_assert (!dump_file);\n+  dump_file = dump_begin (partition_dump_id, NULL);\n+\n+  if (dump_file)\n+    symtab->dump (dump_file);\n+\n+  symtab_node::checking_verify_symtab_nodes ();\n+  bitmap_obstack_release (NULL);\n   if (flag_lto_partition == LTO_PARTITION_1TO1)\n     lto_1_to_1_map ();\n   else if (flag_lto_partition == LTO_PARTITION_MAX)\n@@ -3192,6 +3206,9 @@ do_whole_program_analysis (void)\n      to globals with hidden visibility because they are accessed from multiple\n      partitions.  */\n   lto_promote_cross_file_statics ();\n+  if (dump_file)\n+     dump_end (partition_dump_id, dump_file);\n+  dump_file = NULL;\n   timevar_pop (TV_WHOPR_PARTITIONING);\n \n   timevar_stop (TV_PHASE_OPT_GEN);"}, {"sha": "6893fc87cd63ea6fece5af82f0c30f25f853e10e", "filename": "gcc/lto/lto.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2Flto.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29a50dfb47ff12c7730a3d604642ce500a39c78f/gcc%2Flto%2Flto.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.h?ref=29a50dfb47ff12c7730a3d604642ce500a39c78f", "patch": "@@ -51,6 +51,8 @@ extern void lto_obj_end_section (void);\n extern lto_file *lto_set_current_out_file (lto_file *file);\n extern lto_file *lto_get_current_out_file (void);\n \n+extern int lto_link_dump_id, decl_merge_dump_id, partition_dump_id;\n+\n /* Hash table entry to hold the start offset and length of an LTO\n    section in a .o file.  */\n struct lto_section_slot"}]}