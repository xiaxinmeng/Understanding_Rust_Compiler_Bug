{"sha": "dbb28e4b135080a823bd74f922ff48e79b52946a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGJiMjhlNGIxMzUwODBhODIzYmQ3NGY5MjJmZjQ4ZTc5YjUyOTQ2YQ==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2005-11-16T22:39:13Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2005-11-16T22:39:13Z"}, "message": "ZipEntry.java: Removed, fully merged now.\n\n       * java/util/zip/ZipEntry.java: Removed, fully merged now.\n       * java/util/zip/ZipFile.java: Likewise.\n       * sources.am: Regenerated.\n       * Makefile.in: Regenerated.\n\nFrom-SVN: r107106", "tree": {"sha": "05a8ae65c5ceaa5e6fce556f1723982447ba3455", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05a8ae65c5ceaa5e6fce556f1723982447ba3455"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dbb28e4b135080a823bd74f922ff48e79b52946a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbb28e4b135080a823bd74f922ff48e79b52946a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbb28e4b135080a823bd74f922ff48e79b52946a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbb28e4b135080a823bd74f922ff48e79b52946a/comments", "author": null, "committer": null, "parents": [{"sha": "f7657ed3d6d901f34228e20df4a02b091ea24126", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7657ed3d6d901f34228e20df4a02b091ea24126", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7657ed3d6d901f34228e20df4a02b091ea24126"}], "stats": {"total": 974, "additions": 11, "deletions": 963}, "files": [{"sha": "da76224bb54be9a09d414020dfe8afb9bb02339e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbb28e4b135080a823bd74f922ff48e79b52946a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbb28e4b135080a823bd74f922ff48e79b52946a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=dbb28e4b135080a823bd74f922ff48e79b52946a", "patch": "@@ -1,3 +1,10 @@\n+2005-11-15  Mark Wielaard  <mark@klomp.org>\n+\n+\t* java/util/zip/ZipEntry.java: Removed, fully merged now.\n+\t* java/util/zip/ZipFile.java: Likewise.\n+\t* sources.am: Regenerated.\n+\t* Makefile.in: Regenerated.\n+\n 2005-11-15  Tom Tromey  <tromey@redhat.com>\n \n \tclasspath/23890:"}, {"sha": "a1fc7ce053b6896a8cb862dba79ad7bb8cdb5030", "filename": "libjava/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbb28e4b135080a823bd74f922ff48e79b52946a/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbb28e4b135080a823bd74f922ff48e79b52946a/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=dbb28e4b135080a823bd74f922ff48e79b52946a", "patch": "@@ -3348,9 +3348,9 @@ java/util/zip/GZIPOutputStream.java \\\n java/util/zip/Inflater.java \\\n java/util/zip/InflaterInputStream.java \\\n classpath/java/util/zip/ZipConstants.java \\\n-java/util/zip/ZipEntry.java \\\n+classpath/java/util/zip/ZipEntry.java \\\n classpath/java/util/zip/ZipException.java \\\n-java/util/zip/ZipFile.java \\\n+classpath/java/util/zip/ZipFile.java \\\n classpath/java/util/zip/ZipInputStream.java \\\n classpath/java/util/zip/ZipOutputStream.java\n "}, {"sha": "04c5e01bb999b8bdab9e22a4e4646d65c4ff5d10", "filename": "libjava/java/util/zip/ZipEntry.java", "status": "removed", "additions": 0, "deletions": 408, "changes": 408, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7657ed3d6d901f34228e20df4a02b091ea24126/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7657ed3d6d901f34228e20df4a02b091ea24126/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipEntry.java?ref=f7657ed3d6d901f34228e20df4a02b091ea24126", "patch": "@@ -1,408 +0,0 @@\n-/* ZipEntry.java --\n-   Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.util.zip;\n-\n-import java.util.Calendar;\n-import java.util.Date;\n-\n-/**\n- * This class represents a member of a zip archive.  ZipFile and\n- * ZipInputStream will give you instances of this class as information\n- * about the members in an archive.  On the other hand ZipOutputStream\n- * needs an instance of this class to create a new member.\n- *\n- * @author Jochen Hoenicke \n- */\n-public class ZipEntry implements ZipConstants, Cloneable\n-{\n-  private static final int KNOWN_SIZE   = 1;\n-  private static final int KNOWN_CSIZE  = 2;\n-  private static final int KNOWN_CRC    = 4;\n-  private static final int KNOWN_TIME   = 8;\n-\n-  private static Calendar cal;\n-\n-  private String name;\n-  private int size;\n-  private long compressedSize = -1;\n-  private int crc;\n-  private int dostime;\n-  private short known = 0;\n-  private short method = -1;\n-  private byte[] extra = null;\n-  private String comment = null;\n-\n-  int flags;              /* used by ZipOutputStream */\n-  int offset;             /* used by ZipFile and ZipOutputStream */\n-\n-  /**\n-   * Compression method.  This method doesn't compress at all.\n-   */\n-  public static final int STORED = 0;\n-  /**\n-   * Compression method.  This method uses the Deflater.\n-   */\n-  public static final int DEFLATED = 8;\n-\n-  /**\n-   * Creates a zip entry with the given name.\n-   * @param name the name. May include directory components separated\n-   * by '/'.\n-   *\n-   * @exception NullPointerException when name is null.\n-   * @exception IllegalArgumentException when name is bigger then 65535 chars.\n-   */\n-  public ZipEntry(String name)\n-  {\n-    int length = name.length();\n-    if (length > 65535)\n-      throw new IllegalArgumentException(\"name length is \" + length);\n-    this.name = name;\n-  }\n-\n-  /**\n-   * Creates a copy of the given zip entry.\n-   * @param e the entry to copy.\n-   */\n-  public ZipEntry(ZipEntry e)\n-  {\n-    name = e.name;\n-    known = e.known;\n-    size = e.size;\n-    compressedSize = e.compressedSize;\n-    crc = e.crc;\n-    dostime = e.dostime;\n-    method = e.method;\n-    extra = e.extra;\n-    comment = e.comment;\n-  }\n-\n-  final void setDOSTime(int dostime)\n-  {\n-    this.dostime = dostime;\n-    known |= KNOWN_TIME;\n-  }\n-\n-  final int getDOSTime()\n-  {\n-    if ((known & KNOWN_TIME) == 0)\n-      return 0;\n-    else\n-      return dostime;\n-  }\n-\n-  /**\n-   * Creates a copy of this zip entry.\n-   */\n-  /**\n-   * Clones the entry.\n-   */\n-  public Object clone()\n-  {\n-    try\n-      {\n-\t// The JCL says that the `extra' field is also copied.\n-\tZipEntry clone = (ZipEntry) super.clone();\n-\tif (extra != null)\n-\t  clone.extra = (byte[]) extra.clone();\n-\treturn clone;\n-      }\n-    catch (CloneNotSupportedException ex)\n-      {\n-\tthrow new InternalError();\n-      }\n-  }\n-\n-  /**\n-   * Returns the entry name.  The path components in the entry are\n-   * always separated by slashes ('/').  \n-   */\n-  public String getName()\n-  {\n-    return name;\n-  }\n-\n-  /**\n-   * Sets the time of last modification of the entry.\n-   * @time the time of last modification of the entry.\n-   */\n-  public void setTime(long time)\n-  {\n-    Calendar cal = getCalendar();\n-    synchronized (cal)\n-      {\n-\tcal.setTime(new Date(time));\n-\tdostime = (cal.get(Calendar.YEAR) - 1980 & 0x7f) << 25\n-\t  | (cal.get(Calendar.MONTH) + 1) << 21\n-\t  | (cal.get(Calendar.DAY_OF_MONTH)) << 16\n-\t  | (cal.get(Calendar.HOUR_OF_DAY)) << 11\n-\t  | (cal.get(Calendar.MINUTE)) << 5\n-\t  | (cal.get(Calendar.SECOND)) >> 1;\n-      }\n-    this.known |= KNOWN_TIME;\n-  }\n-\n-  /**\n-   * Gets the time of last modification of the entry.\n-   * @return the time of last modification of the entry, or -1 if unknown.\n-   */\n-  public long getTime()\n-  {\n-    if ((known & KNOWN_TIME) == 0)\n-      return -1;\n-    \n-    int sec = 2 * (dostime & 0x1f);\n-    int min = (dostime >> 5) & 0x3f;\n-    int hrs = (dostime >> 11) & 0x1f;\n-    int day = (dostime >> 16) & 0x1f;\n-    int mon = ((dostime >> 21) & 0xf) - 1;\n-    int year = ((dostime >> 25) & 0x7f) + 1980; /* since 1900 */\n-   \n-    try\n-      {\n-\tcal = getCalendar();\n-\tsynchronized (cal)\n-\t  {\n-\t    cal.set(year, mon, day, hrs, min, sec);\n-\t    return cal.getTime().getTime();\n-\t  }\n-      }\n-    catch (RuntimeException ex)\n-      {\n-\t/* Ignore illegal time stamp */\n-\tknown &= ~KNOWN_TIME;\n-\treturn -1;\n-      }\n-  }\n-\n-  private static synchronized Calendar getCalendar()\n-  {\n-    if (cal == null)\n-      cal = Calendar.getInstance();\n-\n-    return cal;\n-  }\n-\n-  /**\n-   * Sets the size of the uncompressed data.\n-   * @exception IllegalArgumentException if size is not in 0..0xffffffffL\n-   */\n-  public void setSize(long size)\n-  {\n-    if ((size & 0xffffffff00000000L) != 0)\n-\tthrow new IllegalArgumentException();\n-    this.size = (int) size;\n-    this.known |= KNOWN_SIZE;\n-  }\n-\n-  /**\n-   * Gets the size of the uncompressed data.\n-   * @return the size or -1 if unknown.\n-   */\n-  public long getSize()\n-  {\n-    return (known & KNOWN_SIZE) != 0 ? size & 0xffffffffL : -1L;\n-  }\n-\n-  /**\n-   * Sets the size of the compressed data.\n-   */\n-  public void setCompressedSize(long csize)\n-  {\n-    this.compressedSize = csize;\n-  }\n-\n-  /**\n-   * Gets the size of the compressed data.\n-   * @return the size or -1 if unknown.\n-   */\n-  public long getCompressedSize()\n-  {\n-    return compressedSize;\n-  }\n-\n-  /**\n-   * Sets the crc of the uncompressed data.\n-   * @exception IllegalArgumentException if crc is not in 0..0xffffffffL\n-   */\n-  public void setCrc(long crc)\n-  {\n-    if ((crc & 0xffffffff00000000L) != 0)\n-\tthrow new IllegalArgumentException();\n-    this.crc = (int) crc;\n-    this.known |= KNOWN_CRC;\n-  }\n-\n-  /**\n-   * Gets the crc of the uncompressed data.\n-   * @return the crc or -1 if unknown.\n-   */\n-  public long getCrc()\n-  {\n-    return (known & KNOWN_CRC) != 0 ? crc & 0xffffffffL : -1L;\n-  }\n-\n-  /**\n-   * Sets the compression method.  Only DEFLATED and STORED are\n-   * supported.\n-   * @exception IllegalArgumentException if method is not supported.\n-   * @see ZipOutputStream#DEFLATED\n-   * @see ZipOutputStream#STORED \n-   */\n-  public void setMethod(int method)\n-  {\n-    if (method != ZipOutputStream.STORED\n-\t&& method != ZipOutputStream.DEFLATED)\n-\tthrow new IllegalArgumentException();\n-    this.method = (short) method;\n-  }\n-\n-  /**\n-   * Gets the compression method.  \n-   * @return the compression method or -1 if unknown.\n-   */\n-  public int getMethod()\n-  {\n-    return method;\n-  }\n-\n-  /**\n-   * Sets the extra data.\n-   * @exception IllegalArgumentException if extra is longer than 0xffff bytes.\n-   */\n-  public void setExtra(byte[] extra)\n-  {\n-    if (extra == null) \n-      {\n-\tthis.extra = null;\n-\treturn;\n-      }\n-\n-    if (extra.length > 0xffff)\n-      throw new IllegalArgumentException();\n-    this.extra = extra;\n-    try\n-      {\n-\tint pos = 0;\n-\twhile (pos < extra.length) \n-\t  {\n-\t    int sig = (extra[pos++] & 0xff)\n-\t      | (extra[pos++] & 0xff) << 8;\n-\t    int len = (extra[pos++] & 0xff)\n-\t      | (extra[pos++] & 0xff) << 8;\n-\t    if (sig == 0x5455) \n-\t      {\n-\t\t/* extended time stamp */\n-\t\tint flags = extra[pos];\n-\t\tif ((flags & 1) != 0)\n-\t\t  {\n-\t\t    long time = ((extra[pos+1] & 0xff)\n-\t\t\t    | (extra[pos+2] & 0xff) << 8\n-\t\t\t    | (extra[pos+3] & 0xff) << 16\n-\t\t\t    | (extra[pos+4] & 0xff) << 24);\n-\t\t    setTime(time);\n-\t\t  }\n-\t      }\n-\t    pos += len;\n-\t  }\n-      }\n-    catch (ArrayIndexOutOfBoundsException ex)\n-      {\n-\t/* be lenient */\n-\treturn;\n-      }\n-  }\n-\n-  /**\n-   * Gets the extra data.\n-   * @return the extra data or null if not set.\n-   */\n-  public byte[] getExtra()\n-  {\n-    return extra;\n-  }\n-\n-  /**\n-   * Sets the entry comment.\n-   * @exception IllegalArgumentException if comment is longer than 0xffff.\n-   */\n-  public void setComment(String comment)\n-  {\n-    if (comment != null && comment.length() > 0xffff)\n-      throw new IllegalArgumentException();\n-    this.comment = comment;\n-  }\n-\n-  /**\n-   * Gets the comment.\n-   * @return the comment or null if not set.\n-   */\n-  public String getComment()\n-  {\n-    return comment;\n-  }\n-\n-  /**\n-   * Gets true, if the entry is a directory.  This is solely\n-   * determined by the name, a trailing slash '/' marks a directory.  \n-   */\n-  public boolean isDirectory()\n-  {\n-    int nlen = name.length();\n-    return nlen > 0 && name.charAt(nlen - 1) == '/';\n-  }\n-\n-  /**\n-   * Gets the string representation of this ZipEntry.  This is just\n-   * the name as returned by getName().\n-   */\n-  public String toString()\n-  {\n-    return name;\n-  }\n-\n-  /**\n-   * Gets the hashCode of this ZipEntry.  This is just the hashCode\n-   * of the name.  Note that the equals method isn't changed, though.\n-   */\n-  public int hashCode()\n-  {\n-    return name.hashCode();\n-  }\n-}"}, {"sha": "3fbff16c501c574250489a228b27a2d778a6141e", "filename": "libjava/java/util/zip/ZipFile.java", "status": "removed", "additions": 0, "deletions": 551, "changes": 551, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7657ed3d6d901f34228e20df4a02b091ea24126/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7657ed3d6d901f34228e20df4a02b091ea24126/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Futil%2Fzip%2FZipFile.java?ref=f7657ed3d6d901f34228e20df4a02b091ea24126", "patch": "@@ -1,551 +0,0 @@\n-/* ZipFile.java --\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005  Free Software Foundation, Inc.\n-\n-This file is part of GNU Classpath.\n-\n-GNU Classpath is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GNU Classpath is distributed in the hope that it will be useful, but\n-WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n-General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GNU Classpath; see the file COPYING.  If not, write to the\n-Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA\n-02110-1301 USA.\n-\n-Linking this library statically or dynamically with other modules is\n-making a combined work based on this library.  Thus, the terms and\n-conditions of the GNU General Public License cover the whole\n-combination.\n-\n-As a special exception, the copyright holders of this library give you\n-permission to link this library with independent modules to produce an\n-executable, regardless of the license terms of these independent\n-modules, and to copy and distribute the resulting executable under\n-terms of your choice, provided that you also meet, for each linked\n-independent module, the terms and conditions of the license of that\n-module.  An independent module is a module which is not derived from\n-or based on this library.  If you modify this library, you may extend\n-this exception to your version of the library, but you are not\n-obligated to do so.  If you do not wish to do so, delete this\n-exception statement from your version. */\n-\n-\n-package java.util.zip;\n-\n-import java.io.BufferedInputStream;\n-import java.io.DataInput;\n-import java.io.EOFException;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.RandomAccessFile;\n-import java.util.Enumeration;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-\n-/**\n- * This class represents a Zip archive.  You can ask for the contained\n- * entries, or get an input stream for a file entry.  The entry is\n- * automatically decompressed.\n- *\n- * This class is thread safe:  You can open input streams for arbitrary\n- * entries in different threads.\n- *\n- * @author Jochen Hoenicke\n- * @author Artur Biesiadowski\n- */\n-public class ZipFile implements ZipConstants\n-{\n-\n-  /**\n-   * Mode flag to open a zip file for reading.\n-   */\n-  public static final int OPEN_READ = 0x1;\n-\n-  /**\n-   * Mode flag to delete a zip file after reading.\n-   */\n-  public static final int OPEN_DELETE = 0x4;\n-\n-  // Name of this zip file.\n-  private final String name;\n-\n-  // File from which zip entries are read.\n-  private final RandomAccessFile raf;\n-\n-  // The entries of this zip file when initialized and not yet closed.\n-  private HashMap entries;\n-\n-  private boolean closed = false;\n-\n-  /**\n-   * Opens a Zip file with the given name for reading.\n-   * @exception IOException if a i/o error occured.\n-   * @exception ZipException if the file doesn't contain a valid zip\n-   * archive.  \n-   */\n-  public ZipFile(String name) throws ZipException, IOException\n-  {\n-    this.raf = new RandomAccessFile(name, \"r\");\n-    this.name = name;\n-  }\n-\n-  /**\n-   * Opens a Zip file reading the given File.\n-   * @exception IOException if a i/o error occured.\n-   * @exception ZipException if the file doesn't contain a valid zip\n-   * archive.  \n-   */\n-  public ZipFile(File file) throws ZipException, IOException\n-  {\n-    this.raf = new RandomAccessFile(file, \"r\");\n-    this.name = file.getPath();\n-  }\n-\n-  /**\n-   * Opens a Zip file reading the given File in the given mode.\n-   *\n-   * If the OPEN_DELETE mode is specified, the zip file will be deleted at\n-   * some time moment after it is opened. It will be deleted before the zip\n-   * file is closed or the Virtual Machine exits.\n-   * \n-   * The contents of the zip file will be accessible until it is closed.\n-   *\n-   * @since JDK1.3\n-   * @param mode Must be one of OPEN_READ or OPEN_READ | OPEN_DELETE\n-   *\n-   * @exception IOException if a i/o error occured.\n-   * @exception ZipException if the file doesn't contain a valid zip\n-   * archive.  \n-   */\n-  public ZipFile(File file, int mode) throws ZipException, IOException\n-  {\n-    if (mode != OPEN_READ && mode != (OPEN_READ | OPEN_DELETE))\n-      throw new IllegalArgumentException(\"invalid mode\");\n-    if ((mode & OPEN_DELETE) != 0)\n-      file.deleteOnExit();\n-    this.raf = new RandomAccessFile(file, \"r\");\n-    this.name = file.getPath();\n-  }\n-\n-  /**\n-   * Read an unsigned short in little endian byte order from the given\n-   * DataInput stream using the given byte buffer.\n-   *\n-   * @param di DataInput stream to read from.\n-   * @param b the byte buffer to read in (must be at least 2 bytes long).\n-   * @return The value read.\n-   *\n-   * @exception IOException if a i/o error occured.\n-   * @exception EOFException if the file ends prematurely\n-   */\n-  private int readLeShort(DataInput di, byte[] b) throws IOException\n-  {\n-    di.readFully(b, 0, 2);\n-    return (b[0] & 0xff) | (b[1] & 0xff) << 8;\n-  }\n-\n-  /**\n-   * Read an int in little endian byte order from the given\n-   * DataInput stream using the given byte buffer.\n-   *\n-   * @param di DataInput stream to read from.\n-   * @param b the byte buffer to read in (must be at least 4 bytes long).\n-   * @return The value read.\n-   *\n-   * @exception IOException if a i/o error occured.\n-   * @exception EOFException if the file ends prematurely\n-   */\n-  private int readLeInt(DataInput di, byte[] b) throws IOException\n-  {\n-    di.readFully(b, 0, 4);\n-    return ((b[0] & 0xff) | (b[1] & 0xff) << 8)\n-\t    | ((b[2] & 0xff) | (b[3] & 0xff) << 8) << 16;\n-  }\n-\n-  /**\n-   * Read an unsigned short in little endian byte order from the given\n-   * byte buffer at the given offset.\n-   *\n-   * @param b the byte array to read from.\n-   * @param off the offset to read from.\n-   * @return The value read.\n-   */\n-  private int readLeShort(byte[] b, int off)\n-  {\n-    return (b[off] & 0xff) | (b[off+1] & 0xff) << 8;\n-  }\n-\n-  /**\n-   * Read an int in little endian byte order from the given\n-   * byte buffer at the given offset.\n-   *\n-   * @param b the byte array to read from.\n-   * @param off the offset to read from.\n-   * @return The value read.\n-   */\n-  private int readLeInt(byte[] b, int off)\n-  {\n-    return ((b[off] & 0xff) | (b[off+1] & 0xff) << 8)\n-\t    | ((b[off+2] & 0xff) | (b[off+3] & 0xff) << 8) << 16;\n-  }\n-  \n-\n-  /**\n-   * Read the central directory of a zip file and fill the entries\n-   * array.  This is called exactly once when first needed. It is called\n-   * while holding the lock on <code>raf</code>.\n-   *\n-   * @exception IOException if a i/o error occured.\n-   * @exception ZipException if the central directory is malformed \n-   */\n-  private void readEntries() throws ZipException, IOException\n-  {\n-    /* Search for the End Of Central Directory.  When a zip comment is \n-     * present the directory may start earlier.\n-     * FIXME: This searches the whole file in a very slow manner if the\n-     * file isn't a zip file.\n-     */\n-    long pos = raf.length() - ENDHDR;\n-    byte[] ebs  = new byte[CENHDR];\n-    \n-    do\n-      {\n-\tif (pos < 0)\n-\t  throw new ZipException\n-\t    (\"central directory not found, probably not a zip file: \" + name);\n-\traf.seek(pos--);\n-      }\n-    while (readLeInt(raf, ebs) != ENDSIG);\n-    \n-    if (raf.skipBytes(ENDTOT - ENDNRD) != ENDTOT - ENDNRD)\n-      throw new EOFException(name);\n-    int count = readLeShort(raf, ebs);\n-    if (raf.skipBytes(ENDOFF - ENDSIZ) != ENDOFF - ENDSIZ)\n-      throw new EOFException(name);\n-    int centralOffset = readLeInt(raf, ebs);\n-\n-    entries = new HashMap(count+count/2);\n-    raf.seek(centralOffset);\n-    \n-    byte[] buffer = new byte[16];\n-    for (int i = 0; i < count; i++)\n-      {\n-      \traf.readFully(ebs);\n-\tif (readLeInt(ebs, 0) != CENSIG)\n-\t  throw new ZipException(\"Wrong Central Directory signature: \" + name);\n-\n-\tint method = readLeShort(ebs, CENHOW);\n-\tint dostime = readLeInt(ebs, CENTIM);\n-\tint crc = readLeInt(ebs, CENCRC);\n-\tint csize = readLeInt(ebs, CENSIZ);\n-\tint size = readLeInt(ebs, CENLEN);\n-\tint nameLen = readLeShort(ebs, CENNAM);\n-\tint extraLen = readLeShort(ebs, CENEXT);\n-\tint commentLen = readLeShort(ebs, CENCOM);\n-\t\n-\tint offset = readLeInt(ebs, CENOFF);\n-\n-\tint needBuffer = Math.max(nameLen, commentLen);\n-\tif (buffer.length < needBuffer)\n-\t  buffer = new byte[needBuffer];\n-\n-\traf.readFully(buffer, 0, nameLen);\n-\tString name = new String(buffer, 0, 0, nameLen);\n-\n-\tZipEntry entry = new ZipEntry(name);\n-\tentry.setMethod(method);\n-\tentry.setCrc(crc & 0xffffffffL);\n-\tentry.setSize(size & 0xffffffffL);\n-\tentry.setCompressedSize(csize & 0xffffffffL);\n-\tentry.setDOSTime(dostime);\n-\tif (extraLen > 0)\n-\t  {\n-\t    byte[] extra = new byte[extraLen];\n-\t    raf.readFully(extra);\n-\t    entry.setExtra(extra);\n-\t  }\n-\tif (commentLen > 0)\n-\t  {\n-\t    raf.readFully(buffer, 0, commentLen);\n-\t    entry.setComment(new String(buffer, 0, commentLen));\n-\t  }\n-\tentry.offset = offset;\n-\tentries.put(name, entry);\n-      }\n-  }\n-\n-  /**\n-   * Closes the ZipFile.  This also closes all input streams given by\n-   * this class.  After this is called, no further method should be\n-   * called.\n-   * \n-   * @exception IOException if a i/o error occured.\n-   */\n-  public void close() throws IOException\n-  {\n-    synchronized (raf)\n-      {\n-\tclosed = true;\n-\tentries = null;\n-\traf.close();\n-      }\n-  }\n-\n-  /**\n-   * Calls the <code>close()</code> method when this ZipFile has not yet\n-   * been explicitly closed.\n-   */\n-  protected void finalize() throws IOException\n-  {\n-    if (!closed && raf != null) close();\n-  }\n-\n-  /**\n-   * Returns an enumeration of all Zip entries in this Zip file.\n-   */\n-  public Enumeration entries()\n-  {\n-    try\n-      {\n-\treturn new ZipEntryEnumeration(getEntries().values().iterator());\n-      }\n-    catch (IOException ioe)\n-      {\n-\treturn null;\n-      }\n-  }\n-\n-  /**\n-   * Checks that the ZipFile is still open and reads entries when necessary.\n-   *\n-   * @exception IllegalStateException when the ZipFile has already been closed.\n-   * @exception IOEexception when the entries could not be read.\n-   */\n-  private HashMap getEntries() throws IOException\n-  {\n-    synchronized(raf)\n-      {\n-\tif (closed)\n-\t  throw new IllegalStateException(\"ZipFile has closed: \" + name);\n-\n-\tif (entries == null)\n-\t  readEntries();\n-\n-\treturn entries;\n-      }\n-  }\n-\n-  /**\n-   * Searches for a zip entry in this archive with the given name.\n-   *\n-   * @param the name. May contain directory components separated by\n-   * slashes ('/').\n-   * @return the zip entry, or null if no entry with that name exists.\n-   */\n-  public ZipEntry getEntry(String name)\n-  {\n-    try\n-      {\n-\tHashMap entries = getEntries();\n-\tZipEntry entry = (ZipEntry) entries.get(name);\n-\treturn entry != null ? (ZipEntry) entry.clone() : null;\n-      }\n-    catch (IOException ioe)\n-      {\n-\treturn null;\n-      }\n-  }\n-\n-\n-  //access should be protected by synchronized(raf)\n-  private byte[] locBuf = new byte[LOCHDR];\n-\n-  /**\n-   * Checks, if the local header of the entry at index i matches the\n-   * central directory, and returns the offset to the data.\n-   * \n-   * @param entry to check.\n-   * @return the start offset of the (compressed) data.\n-   *\n-   * @exception IOException if a i/o error occured.\n-   * @exception ZipException if the local header doesn't match the \n-   * central directory header\n-   */\n-  private long checkLocalHeader(ZipEntry entry) throws IOException\n-  {\n-    synchronized (raf)\n-      {\n-\traf.seek(entry.offset);\n-\traf.readFully(locBuf);\n-\t\n-\tif (readLeInt(locBuf, 0) != LOCSIG)\n-\t  throw new ZipException(\"Wrong Local header signature: \" + name);\n-\n-\tif (entry.getMethod() != readLeShort(locBuf, LOCHOW))\n-\t  throw new ZipException(\"Compression method mismatch: \" + name);\n-\n-\tif (entry.getName().length() != readLeShort(locBuf, LOCNAM))\n-\t  throw new ZipException(\"file name length mismatch: \" + name);\n-\n-\tint extraLen = entry.getName().length() + readLeShort(locBuf, LOCEXT);\n-\treturn entry.offset + LOCHDR + extraLen;\n-      }\n-  }\n-\n-  /**\n-   * Creates an input stream reading the given zip entry as\n-   * uncompressed data.  Normally zip entry should be an entry\n-   * returned by getEntry() or entries().\n-   *\n-   * This implementation returns null if the requested entry does not\n-   * exist.  This decision is not obviously correct, however, it does\n-   * appear to mirror Sun's implementation, and it is consistant with\n-   * their javadoc.  On the other hand, the old JCL book, 2nd Edition,\n-   * claims that this should return a \"non-null ZIP entry\".  We have\n-   * chosen for now ignore the old book, as modern versions of Ant (an\n-   * important application) depend on this behaviour.  See discussion\n-   * in this thread:\n-   * http://gcc.gnu.org/ml/java-patches/2004-q2/msg00602.html\n-   *\n-   * @param entry the entry to create an InputStream for.\n-   * @return the input stream, or null if the requested entry does not exist.\n-   *\n-   * @exception IOException if a i/o error occured.\n-   * @exception ZipException if the Zip archive is malformed.  \n-   */\n-  public InputStream getInputStream(ZipEntry entry) throws IOException\n-  {\n-    HashMap entries = getEntries();\n-    String name = entry.getName();\n-    ZipEntry zipEntry = (ZipEntry) entries.get(name);\n-    if (zipEntry == null)\n-      return null;\n-\n-    long start = checkLocalHeader(zipEntry);\n-    int method = zipEntry.getMethod();\n-    InputStream is = new BufferedInputStream(new PartialInputStream\n-      (raf, start, zipEntry.getCompressedSize()));\n-    switch (method)\n-      {\n-      case ZipOutputStream.STORED:\n-\treturn is;\n-      case ZipOutputStream.DEFLATED:\n-\treturn new InflaterInputStream(is, new Inflater(true));\n-      default:\n-\tthrow new ZipException(\"Unknown compression method \" + method);\n-      }\n-  }\n-  \n-  /**\n-   * Returns the (path) name of this zip file.\n-   */\n-  public String getName()\n-  {\n-    return name;\n-  }\n-\n-  /**\n-   * Returns the number of entries in this zip file.\n-   */\n-  public int size()\n-  {\n-    try\n-      {\n-\treturn getEntries().size();\n-      }\n-    catch (IOException ioe)\n-      {\n-\treturn 0;\n-      }\n-  }\n-  \n-  private static class ZipEntryEnumeration implements Enumeration\n-  {\n-    private final Iterator elements;\n-\n-    public ZipEntryEnumeration(Iterator elements)\n-    {\n-      this.elements = elements;\n-    }\n-\n-    public boolean hasMoreElements()\n-    {\n-      return elements.hasNext();\n-    }\n-\n-    public Object nextElement()\n-    {\n-      /* We return a clone, just to be safe that the user doesn't\n-       * change the entry.  \n-       */\n-      return ((ZipEntry)elements.next()).clone();\n-    }\n-  }\n-\n-  private static class PartialInputStream extends InputStream\n-  {\n-    private final RandomAccessFile raf;\n-    long filepos, end;\n-\n-    public PartialInputStream(RandomAccessFile raf, long start, long len)\n-    {\n-      this.raf = raf;\n-      filepos = start;\n-      end = start + len;\n-    }\n-    \n-    public int available()\n-    {\n-      long amount = end - filepos;\n-      if (amount > Integer.MAX_VALUE)\n-\treturn Integer.MAX_VALUE;\n-      return (int) amount;\n-    }\n-    \n-    public int read() throws IOException\n-    {\n-      if (filepos == end)\n-\treturn -1;\n-      synchronized (raf)\n-\t{\n-\t  raf.seek(filepos++);\n-\t  return raf.read();\n-\t}\n-    }\n-\n-    public int read(byte[] b, int off, int len) throws IOException\n-    {\n-      if (len > end - filepos)\n-\t{\n-\t  len = (int) (end - filepos);\n-\t  if (len == 0)\n-\t    return -1;\n-\t}\n-      synchronized (raf)\n-\t{\n-\t  raf.seek(filepos);\n-\t  int count = raf.read(b, off, len);\n-\t  if (count > 0)\n-\t    filepos += len;\n-\t  return count;\n-\t}\n-    }\n-\n-    public long skip(long amount)\n-    {\n-      if (amount < 0)\n-\tthrow new IllegalArgumentException();\n-      if (amount > end - filepos)\n-\tamount = end - filepos;\n-      filepos += amount;\n-      return amount;\n-    }\n-  }\n-}"}, {"sha": "af1db9370bdbfe36bed17e9101597acb5d4e8824", "filename": "libjava/sources.am", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dbb28e4b135080a823bd74f922ff48e79b52946a/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dbb28e4b135080a823bd74f922ff48e79b52946a/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=dbb28e4b135080a823bd74f922ff48e79b52946a", "patch": "@@ -3832,9 +3832,9 @@ java/util/zip/GZIPOutputStream.java \\\n java/util/zip/Inflater.java \\\n java/util/zip/InflaterInputStream.java \\\n classpath/java/util/zip/ZipConstants.java \\\n-java/util/zip/ZipEntry.java \\\n+classpath/java/util/zip/ZipEntry.java \\\n classpath/java/util/zip/ZipException.java \\\n-java/util/zip/ZipFile.java \\\n+classpath/java/util/zip/ZipFile.java \\\n classpath/java/util/zip/ZipInputStream.java \\\n classpath/java/util/zip/ZipOutputStream.java\n "}]}