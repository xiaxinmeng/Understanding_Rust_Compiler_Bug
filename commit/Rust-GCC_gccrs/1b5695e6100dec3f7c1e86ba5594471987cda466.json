{"sha": "1b5695e6100dec3f7c1e86ba5594471987cda466", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWI1Njk1ZTYxMDBkZWMzZjdjMWU4NmJhNTU5NDQ3MTk4N2NkYTQ2Ng==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-11-20T03:25:26Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-11-20T03:25:26Z"}, "message": "re PR c++/56041 (Constexpr conversion function definition not found in template argument context)\n\n\tPR c++/56041\n\t* cp-tree.h (struct processing_template_decl_sentinel): New.\n\t* pt.c (instantiate_non_dependent_expr_internal): Split out from...\n\t(instantiate_non_dependent_expr_sfinae): Here.\n\t(convert_nontype_argument): Use them.\n\t* constexpr.c (fold_non_dependent_expr): Use them.\n\nFrom-SVN: r217823", "tree": {"sha": "4e02eacae240a2fb6eb263ef634db37cd98148ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4e02eacae240a2fb6eb263ef634db37cd98148ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1b5695e6100dec3f7c1e86ba5594471987cda466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b5695e6100dec3f7c1e86ba5594471987cda466", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b5695e6100dec3f7c1e86ba5594471987cda466", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b5695e6100dec3f7c1e86ba5594471987cda466/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9d39384c6b3173c71d17d39f4108e47ef46b886c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d39384c6b3173c71d17d39f4108e47ef46b886c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d39384c6b3173c71d17d39f4108e47ef46b886c"}], "stats": {"total": 122, "additions": 96, "deletions": 26}, "files": [{"sha": "09781410a19cb58168aaa22e2c0a2a789b902b52", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b5695e6100dec3f7c1e86ba5594471987cda466/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b5695e6100dec3f7c1e86ba5594471987cda466/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=1b5695e6100dec3f7c1e86ba5594471987cda466", "patch": "@@ -1,5 +1,12 @@\n 2014-11-19  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/56041\n+\t* cp-tree.h (struct processing_template_decl_sentinel): New.\n+\t* pt.c (instantiate_non_dependent_expr_internal): Split out from...\n+\t(instantiate_non_dependent_expr_sfinae): Here.\n+\t(convert_nontype_argument): Use them.\n+\t* constexpr.c (fold_non_dependent_expr): Use them.\n+\n \tPR c++/63885\n \t* constexpr.c (cxx_eval_constant_expression) [PARM_DECL]: Don't\n \tcomplain yet about a reference."}, {"sha": "2678223a6038618cbd0d00786bb058ffc9e1d616", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b5695e6100dec3f7c1e86ba5594471987cda466/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b5695e6100dec3f7c1e86ba5594471987cda466/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=1b5695e6100dec3f7c1e86ba5594471987cda466", "patch": "@@ -3506,17 +3506,8 @@ fold_non_dependent_expr (tree t)\n       if (!instantiation_dependent_expression_p (t)\n \t  && potential_constant_expression (t))\n \t{\n-\t  HOST_WIDE_INT saved_processing_template_decl;\n-\n-\t  saved_processing_template_decl = processing_template_decl;\n-\t  processing_template_decl = 0;\n-\t  t = tsubst_copy_and_build (t,\n-\t\t\t\t     /*args=*/NULL_TREE,\n-\t\t\t\t     tf_none,\n-\t\t\t\t     /*in_decl=*/NULL_TREE,\n-\t\t\t\t     /*function_p=*/false,\n-\t\t\t\t     /*integral_constant_expression_p=*/true);\n-\t  processing_template_decl = saved_processing_template_decl;\n+\t  processing_template_decl_sentinel s;\n+\t  t = instantiate_non_dependent_expr_internal (t, tf_none);\n \n \t  if (type_unknown_p (t)\n \t      || BRACE_ENCLOSED_INITIALIZER_P (t))"}, {"sha": "b3781ab7a72aee25dc7ee40696d0f108b6903bcb", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b5695e6100dec3f7c1e86ba5594471987cda466/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b5695e6100dec3f7c1e86ba5594471987cda466/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=1b5695e6100dec3f7c1e86ba5594471987cda466", "patch": "@@ -1082,6 +1082,8 @@ struct GTY(()) saved_scope {\n   struct saved_scope *prev;\n };\n \n+extern GTY(()) struct saved_scope *scope_chain;\n+\n /* The current open namespace.  */\n \n #define current_namespace scope_chain->old_namespace\n@@ -1123,6 +1125,24 @@ struct GTY(()) saved_scope {\n #define processing_specialization scope_chain->x_processing_specialization\n #define processing_explicit_instantiation scope_chain->x_processing_explicit_instantiation\n \n+/* RAII sentinel to handle clearing processing_template_decl and restoring\n+   it when done.  */\n+\n+struct processing_template_decl_sentinel\n+{\n+  int saved;\n+  processing_template_decl_sentinel (bool reset = true)\n+    : saved (processing_template_decl)\n+  {\n+    if (reset)\n+      processing_template_decl = 0;\n+  }\n+  ~processing_template_decl_sentinel()\n+  {\n+    processing_template_decl = saved;\n+  }\n+};\n+\n /* The cached class binding level, from the most recently exited\n    class, or NULL if none.  */\n \n@@ -1140,8 +1160,6 @@ struct GTY(()) saved_scope {\n \n /* A list of private types mentioned, for deferred access checking.  */\n \n-extern GTY(()) struct saved_scope *scope_chain;\n-\n struct GTY((for_user)) cxx_int_tree_map {\n   unsigned int uid;\n   tree to;\n@@ -5716,6 +5734,7 @@ extern void make_args_non_dependent\t\t(vec<tree, va_gc> *);\n extern bool reregister_specialization\t\t(tree, tree, tree);\n extern tree instantiate_non_dependent_expr\t(tree);\n extern tree instantiate_non_dependent_expr_sfinae (tree, tsubst_flags_t);\n+extern tree instantiate_non_dependent_expr_internal (tree, tsubst_flags_t);\n extern bool alias_type_or_template_p            (tree);\n extern bool alias_template_specialization_p     (const_tree);\n extern bool dependent_alias_template_spec_p     (const_tree);"}, {"sha": "05ca70628658e3dd6fb5bd3459869dfad9589860", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b5695e6100dec3f7c1e86ba5594471987cda466/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b5695e6100dec3f7c1e86ba5594471987cda466/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=1b5695e6100dec3f7c1e86ba5594471987cda466", "patch": "@@ -5212,6 +5212,24 @@ redeclare_class_template (tree type, tree parms)\n     return true;\n }\n \n+/* The actual substitution part of instantiate_non_dependent_expr_sfinae,\n+   to be used when the caller has already checked\n+   (processing_template_decl\n+    && !instantiation_dependent_expression_p (expr)\n+    && potential_constant_expression (expr))\n+   and cleared processing_template_decl.  */\n+\n+tree\n+instantiate_non_dependent_expr_internal (tree expr, tsubst_flags_t complain)\n+{\n+  return tsubst_copy_and_build (expr,\n+\t\t\t\t/*args=*/NULL_TREE,\n+\t\t\t\tcomplain,\n+\t\t\t\t/*in_decl=*/NULL_TREE,\n+\t\t\t\t/*function_p=*/false,\n+\t\t\t\t/*integral_constant_expression_p=*/true);\n+}\n+\n /* Simplify EXPR if it is a non-dependent expression.  Returns the\n    (possibly simplified) expression.  */\n \n@@ -5232,17 +5250,8 @@ instantiate_non_dependent_expr_sfinae (tree expr, tsubst_flags_t complain)\n       && !instantiation_dependent_expression_p (expr)\n       && potential_constant_expression (expr))\n     {\n-      HOST_WIDE_INT saved_processing_template_decl;\n-\n-      saved_processing_template_decl = processing_template_decl;\n-      processing_template_decl = 0;\n-      expr = tsubst_copy_and_build (expr,\n-\t\t\t\t    /*args=*/NULL_TREE,\n-\t\t\t\t    complain,\n-\t\t\t\t    /*in_decl=*/NULL_TREE,\n-\t\t\t\t    /*function_p=*/false,\n-\t\t\t\t    /*integral_constant_expression_p=*/true);\n-      processing_template_decl = saved_processing_template_decl;\n+      processing_template_decl_sentinel s;\n+      expr = instantiate_non_dependent_expr_internal (expr, complain);\n     }\n   return expr;\n }\n@@ -5736,11 +5745,15 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n      so that access checking can be performed when the template is\n      instantiated -- but here we need the resolved form so that we can\n      convert the argument.  */\n+  bool non_dep = false;\n   if (TYPE_REF_OBJ_P (type)\n       && has_value_dependent_address (expr))\n     /* If we want the address and it's value-dependent, don't fold.  */;\n-  else if (!type_unknown_p (expr))\n-    expr = instantiate_non_dependent_expr_sfinae (expr, complain);\n+  else if (!type_unknown_p (expr)\n+\t   && processing_template_decl\n+\t   && !instantiation_dependent_expression_p (expr)\n+\t   && potential_constant_expression (expr))\n+    non_dep = true;\n   if (error_operand_p (expr))\n     return error_mark_node;\n   expr_type = TREE_TYPE (expr);\n@@ -5749,6 +5762,12 @@ convert_nontype_argument (tree type, tree expr, tsubst_flags_t complain)\n   else\n     expr = mark_rvalue_use (expr);\n \n+  /* If the argument is non-dependent, perform any conversions in\n+     non-dependent context as well.  */\n+  processing_template_decl_sentinel s (non_dep);\n+  if (non_dep)\n+    expr = instantiate_non_dependent_expr_internal (expr, complain);\n+\n   /* 14.3.2/5: The null pointer{,-to-member} conversion is applied\n      to a non-type argument of \"nullptr\".  */\n   if (expr == nullptr_node && TYPE_PTR_OR_PTRMEM_P (type))"}, {"sha": "fd34f23f9ee628570350571138b8e8402dc2c4b4", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-conv1.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1b5695e6100dec3f7c1e86ba5594471987cda466/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-conv1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1b5695e6100dec3f7c1e86ba5594471987cda466/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-conv1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-conv1.C?ref=1b5695e6100dec3f7c1e86ba5594471987cda466", "patch": "@@ -0,0 +1,34 @@\n+// PR c++/56041\n+// { dg-do compile { target c++11 } }\n+\n+template< class T, T v >\n+struct integral_constant\n+{\n+  using type       = integral_constant<T,v>;\n+  using value_type = T;\n+  static constexpr T value  = v;\n+  constexpr operator T  ( )  noexcept { return value; }\n+};\n+\n+using true_type  = integral_constant<bool, true>;\n+using false_type = integral_constant<bool, false>;\n+\n+template< bool b, class T = void >  struct enable_if  { using type = T; };\n+template< class T >                 struct enable_if<false, T>  { };\n+\n+\n+template< class T,\n+\t  class = typename enable_if< true_type{}       // should compile; doesn't\n+\t\t\t\t      , T>::type\n+\t  >\n+T try_it( )  { return T{}; }\n+\n+int main( )\n+{\n+  static_assert( true_type{}     , \"failed test 1!\" );\n+  static_assert( true_type{}     , \"failed test 2!\" );\n+  static_assert( ! false_type{}  , \"failed test 3!\" );\n+  static_assert( !! true_type{}  , \"failed test 4!\" );\n+\n+  return try_it<int>();\n+}"}]}