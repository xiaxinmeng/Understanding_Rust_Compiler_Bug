{"sha": "7705e9db01267c127d2b9f9a33b5218546898ef6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzcwNWU5ZGIwMTI2N2MxMjdkMmI5ZjlhMzNiNTIxODU0Njg5OGVmNg==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@cygnus.com", "date": "1999-07-20T20:56:10Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "1999-07-20T20:56:10Z"}, "message": "re GNATS gcj/12 (gcj accepts invalid code where an exception must be caught/thrown)\n\nTue Jul 20 13:20:05 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n        * parse.y (resolve_and_layout): Check methods only once.\n        (resolve_qualified_expression_name): Verify thrown exceptions\n        compatibility.\n        (check_thrown_exceptions): Reject exceptions thrown in\n        initializer. Error message tuned.\n\n(This fixes PR #12. Libgcj's java/net must be updated in order to compiles\n with a patch at this URL:\n http://sourceware.cygnus.com/ml/java-patches/1999-q3/msg00048.html)\n\nFrom-SVN: r28196", "tree": {"sha": "5ca1ceb178214a9ef4598a10e5149aadc81751b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ca1ceb178214a9ef4598a10e5149aadc81751b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7705e9db01267c127d2b9f9a33b5218546898ef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7705e9db01267c127d2b9f9a33b5218546898ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7705e9db01267c127d2b9f9a33b5218546898ef6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7705e9db01267c127d2b9f9a33b5218546898ef6/comments", "author": null, "committer": null, "parents": [{"sha": "33551dfec5a986d6e042dc61c4517af4e75fd76e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33551dfec5a986d6e042dc61c4517af4e75fd76e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33551dfec5a986d6e042dc61c4517af4e75fd76e"}], "stats": {"total": 80, "additions": 64, "deletions": 16}, "files": [{"sha": "2e7bb3a715db8b410e14c5ef07edb220ea319a74", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7705e9db01267c127d2b9f9a33b5218546898ef6/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7705e9db01267c127d2b9f9a33b5218546898ef6/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=7705e9db01267c127d2b9f9a33b5218546898ef6", "patch": "@@ -1,3 +1,11 @@\n+Tue Jul 20 13:20:05 1999  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n+\n+\t* parse.y (resolve_and_layout): Check methods only once.\n+\t(resolve_qualified_expression_name): Verify thrown exceptions\n+ \tcompatibility.\n+\t(check_thrown_exceptions): Reject exceptions thrown in\n+ \tinitializer. Error message tuned.\n+\t\n 1999-07-14  Andrew Haley  <aph@cygnus.com>\n \n         * expr.c (expand_expr): Do not return the last statement in a"}, {"sha": "e36ef3f3cc9b134d8518a9f8a80e4028624de54d", "filename": "gcc/java/parse.c", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7705e9db01267c127d2b9f9a33b5218546898ef6/gcc%2Fjava%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7705e9db01267c127d2b9f9a33b5218546898ef6/gcc%2Fjava%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.c?ref=7705e9db01267c127d2b9f9a33b5218546898ef6", "patch": "@@ -6922,7 +6922,9 @@ resolve_and_layout (something, cl)\n \n   /* Resolve and layout if necessary */\n   layout_class_methods (TREE_TYPE (decl));\n-  if (CLASS_FROM_SOURCE_P (TREE_TYPE (decl)))\n+  /* Check methods, but only once */\n+  if (CLASS_FROM_SOURCE_P (TREE_TYPE (decl)) \n+      && !CLASS_LOADED_P (TREE_TYPE (decl)))\n     CHECK_METHODS (decl);\n   if (TREE_TYPE (decl) != current_class && !CLASS_LOADED_P (TREE_TYPE (decl)))\n     safe_layout_class (TREE_TYPE (decl));\n@@ -9018,6 +9020,8 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n   for (q = EXPR_WFL_QUALIFICATION (wfl); q; q = TREE_CHAIN (q))\n     {\n       tree qual_wfl = QUAL_WFL (q);\n+      tree ret_decl;\t\t/* for EH checking */\n+      int location;\t\t/* for EH checking */\n \n       /* 15.10.1 Field Access Using a Primary */\n       switch (TREE_CODE (qual_wfl))\n@@ -9036,14 +9040,21 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  /* And code for the function call */\n \t  if (complete_function_arguments (qual_wfl))\n \t    return 1;\n+\t  \n \t  if (from_super && TREE_CODE (qual_wfl) == CALL_EXPR)\n \t    CALL_USING_SUPER (qual_wfl) = 1;\n-\t  *where_found = \n-\t    patch_method_invocation (qual_wfl, decl, type, &is_static, NULL);\n+\t  location = (TREE_CODE (qual_wfl) == CALL_EXPR ?\n+\t\t      EXPR_WFL_LINECOL (TREE_OPERAND (qual_wfl, 0)) : 0);\n+\t  *where_found = patch_method_invocation (qual_wfl, decl, type, \n+\t\t\t\t\t\t  &is_static, &ret_decl);\n \t  if (*where_found == error_mark_node)\n \t    return 1;\n \t  *type_found = type = QUAL_DECL_TYPE (*where_found);\n \n+\t  /* EH check */\n+\t  if (location)\n+\t    check_thrown_exceptions (location, ret_decl);\n+\n \t  /* If the previous call was static and this one is too,\n \t     build a compound expression to hold the two (because in\n \t     that case, previous function calls aren't transported as\n@@ -14040,11 +14051,20 @@ check_thrown_exceptions (location, decl)\n \t  continue;\n #endif\n \tEXPR_WFL_LINECOL (wfl_operator) = location;\n-\tparse_error_context \n-\t  (wfl_operator, \"Exception `%s' must be caught, or it must be \"\n-\t   \"declared in the `throws' clause of `%s'\", \n-\t   lang_printable_name (TREE_VALUE (throws), 0),\n-\t   IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n+\tif (DECL_NAME (current_function_decl) == finit_identifier_node)\n+\t  parse_error_context\n+            (wfl_operator, \"Exception `%s' can't be thrown in initializer\",\n+\t     lang_printable_name (TREE_VALUE (throws), 0));\n+\telse \n+\t  {\n+\t    parse_error_context \n+\t      (wfl_operator, \"Exception `%s' must be caught, or it must be \"\n+\t       \"declared in the `throws' clause of `%s'\", \n+\t       lang_printable_name (TREE_VALUE (throws), 0),\n+\t       (DECL_NAME (current_function_decl) == init_identifier_node ?\n+\t\tIDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))) :\n+\t\tIDENTIFIER_POINTER (DECL_NAME (current_function_decl))));\n+\t  }\n       }\n }\n "}, {"sha": "be1c788b8de41663e99cc40bc76b37a1999a687b", "filename": "gcc/java/parse.y", "status": "modified", "additions": 28, "deletions": 8, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7705e9db01267c127d2b9f9a33b5218546898ef6/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7705e9db01267c127d2b9f9a33b5218546898ef6/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=7705e9db01267c127d2b9f9a33b5218546898ef6", "patch": "@@ -4335,7 +4335,9 @@ resolve_and_layout (something, cl)\n \n   /* Resolve and layout if necessary */\n   layout_class_methods (TREE_TYPE (decl));\n-  if (CLASS_FROM_SOURCE_P (TREE_TYPE (decl)))\n+  /* Check methods, but only once */\n+  if (CLASS_FROM_SOURCE_P (TREE_TYPE (decl)) \n+      && !CLASS_LOADED_P (TREE_TYPE (decl)))\n     CHECK_METHODS (decl);\n   if (TREE_TYPE (decl) != current_class && !CLASS_LOADED_P (TREE_TYPE (decl)))\n     safe_layout_class (TREE_TYPE (decl));\n@@ -6431,6 +6433,8 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n   for (q = EXPR_WFL_QUALIFICATION (wfl); q; q = TREE_CHAIN (q))\n     {\n       tree qual_wfl = QUAL_WFL (q);\n+      tree ret_decl;\t\t/* for EH checking */\n+      int location;\t\t/* for EH checking */\n \n       /* 15.10.1 Field Access Using a Primary */\n       switch (TREE_CODE (qual_wfl))\n@@ -6449,14 +6453,21 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t  /* And code for the function call */\n \t  if (complete_function_arguments (qual_wfl))\n \t    return 1;\n+\t  \n \t  if (from_super && TREE_CODE (qual_wfl) == CALL_EXPR)\n \t    CALL_USING_SUPER (qual_wfl) = 1;\n-\t  *where_found = \n-\t    patch_method_invocation (qual_wfl, decl, type, &is_static, NULL);\n+\t  location = (TREE_CODE (qual_wfl) == CALL_EXPR ?\n+\t\t      EXPR_WFL_LINECOL (TREE_OPERAND (qual_wfl, 0)) : 0);\n+\t  *where_found = patch_method_invocation (qual_wfl, decl, type, \n+\t\t\t\t\t\t  &is_static, &ret_decl);\n \t  if (*where_found == error_mark_node)\n \t    return 1;\n \t  *type_found = type = QUAL_DECL_TYPE (*where_found);\n \n+\t  /* EH check */\n+\t  if (location)\n+\t    check_thrown_exceptions (location, ret_decl);\n+\n \t  /* If the previous call was static and this one is too,\n \t     build a compound expression to hold the two (because in\n \t     that case, previous function calls aren't transported as\n@@ -11453,11 +11464,20 @@ check_thrown_exceptions (location, decl)\n \t  continue;\n #endif\n \tEXPR_WFL_LINECOL (wfl_operator) = location;\n-\tparse_error_context \n-\t  (wfl_operator, \"Exception `%s' must be caught, or it must be \"\n-\t   \"declared in the `throws' clause of `%s'\", \n-\t   lang_printable_name (TREE_VALUE (throws), 0),\n-\t   IDENTIFIER_POINTER (DECL_NAME (current_function_decl)));\n+\tif (DECL_NAME (current_function_decl) == finit_identifier_node)\n+\t  parse_error_context\n+            (wfl_operator, \"Exception `%s' can't be thrown in initializer\",\n+\t     lang_printable_name (TREE_VALUE (throws), 0));\n+\telse \n+\t  {\n+\t    parse_error_context \n+\t      (wfl_operator, \"Exception `%s' must be caught, or it must be \"\n+\t       \"declared in the `throws' clause of `%s'\", \n+\t       lang_printable_name (TREE_VALUE (throws), 0),\n+\t       (DECL_NAME (current_function_decl) == init_identifier_node ?\n+\t\tIDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (current_class))) :\n+\t\tIDENTIFIER_POINTER (DECL_NAME (current_function_decl))));\n+\t  }\n       }\n }\n "}]}