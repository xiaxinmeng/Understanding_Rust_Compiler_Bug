{"sha": "13c247d6f2a75b7e7a11546e897489716bc31506", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNjMjQ3ZDZmMmE3NWI3ZTdhMTE1NDZlODk3NDg5NzE2YmMzMTUwNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-11-18T15:27:56Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-11-18T15:27:56Z"}, "message": "Handle VIEW_CONVERT_EXPR for variable-length vectors\n\nThis patch handles VIEW_CONVERT_EXPRs of variable-length VECTOR_CSTs\nby adding tree-level versions of native_decode_vector_rtx and\nsimplify_const_vector_subreg.  It uses the same code for fixed-length\nvectors, both to get more coverage and because operating directly on\nthe compressed encoding should be more efficient for longer vectors\nwith a regular pattern.\n\nThe structure and comments are very similar between the tree and\nrtx routines.\n\n2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* fold-const.c (native_encode_vector): Turn into a wrapper function,\n\tsplitting the main code out into...\n\t(native_encode_vector_part): ...this new function.\n\t(native_decode_vector_tree): New function.\n\t(fold_view_convert_vector_encoding): Likewise.\n\t(fold_view_convert_expr): Use it for converting VECTOR_CSTs\n\tto VECTOR_TYPEs.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/acle/general/temporaries_1.c: New test.\n\nFrom-SVN: r278410", "tree": {"sha": "0abb0a06b28004f8567d7b28e9840f2c7748a456", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0abb0a06b28004f8567d7b28e9840f2c7748a456"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13c247d6f2a75b7e7a11546e897489716bc31506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c247d6f2a75b7e7a11546e897489716bc31506", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13c247d6f2a75b7e7a11546e897489716bc31506", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c247d6f2a75b7e7a11546e897489716bc31506/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8489e1f45b50600c01eb8ed8c5d0ca914ded281c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8489e1f45b50600c01eb8ed8c5d0ca914ded281c"}], "stats": {"total": 223, "additions": 214, "deletions": 9}, "files": [{"sha": "932b87a6e5c7b4514b59e87149a2181148386a79", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c247d6f2a75b7e7a11546e897489716bc31506/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c247d6f2a75b7e7a11546e897489716bc31506/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=13c247d6f2a75b7e7a11546e897489716bc31506", "patch": "@@ -1,3 +1,13 @@\n+2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* fold-const.c (native_encode_vector): Turn into a wrapper function,\n+\tsplitting the main code out into...\n+\t(native_encode_vector_part): ...this new function.\n+\t(native_decode_vector_tree): New function.\n+\t(fold_view_convert_vector_encoding): Likewise.\n+\t(fold_view_convert_expr): Use it for converting VECTOR_CSTs\n+\tto VECTOR_TYPEs.\n+\n 2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-data-ref.c (create_intersect_range_checks_index): If the"}, {"sha": "02daacdb36b889ece2f9415095c448c454e084fc", "filename": "gcc/fold-const.c", "status": "modified", "additions": 130, "deletions": 9, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c247d6f2a75b7e7a11546e897489716bc31506/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c247d6f2a75b7e7a11546e897489716bc31506/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=13c247d6f2a75b7e7a11546e897489716bc31506", "patch": "@@ -7715,22 +7715,18 @@ native_encode_complex (const_tree expr, unsigned char *ptr, int len, int off)\n   return rsize + isize;\n }\n \n-\n-/* Subroutine of native_encode_expr.  Encode the VECTOR_CST\n-   specified by EXPR into the buffer PTR of length LEN bytes.\n-   Return the number of bytes placed in the buffer, or zero\n-   upon failure.  */\n+/* Like native_encode_vector, but only encode the first COUNT elements.\n+   The other arguments are as for native_encode_vector.  */\n \n static int\n-native_encode_vector (const_tree expr, unsigned char *ptr, int len, int off)\n+native_encode_vector_part (const_tree expr, unsigned char *ptr, int len,\n+\t\t\t   int off, unsigned HOST_WIDE_INT count)\n {\n-  unsigned HOST_WIDE_INT i, count;\n+  unsigned HOST_WIDE_INT i;\n   int size, offset;\n   tree itype, elem;\n \n   offset = 0;\n-  if (!VECTOR_CST_NELTS (expr).is_constant (&count))\n-    return 0;\n   itype = TREE_TYPE (TREE_TYPE (expr));\n   size = GET_MODE_SIZE (SCALAR_TYPE_MODE (itype));\n   for (i = 0; i < count; i++)\n@@ -7754,6 +7750,20 @@ native_encode_vector (const_tree expr, unsigned char *ptr, int len, int off)\n   return offset;\n }\n \n+/* Subroutine of native_encode_expr.  Encode the VECTOR_CST\n+   specified by EXPR into the buffer PTR of length LEN bytes.\n+   Return the number of bytes placed in the buffer, or zero\n+   upon failure.  */\n+\n+static int\n+native_encode_vector (const_tree expr, unsigned char *ptr, int len, int off)\n+{\n+  unsigned HOST_WIDE_INT count;\n+  if (!VECTOR_CST_NELTS (expr).is_constant (&count))\n+    return 0;\n+  return native_encode_vector_part (expr, ptr, len, off, count);\n+}\n+\n \n /* Subroutine of native_encode_expr.  Encode the STRING_CST\n    specified by EXPR into the buffer PTR of length LEN bytes.\n@@ -8049,6 +8059,113 @@ can_native_interpret_type_p (tree type)\n     }\n }\n \n+/* Read a vector of type TYPE from the target memory image given by BYTES,\n+   starting at byte FIRST_BYTE.  The vector is known to be encodable using\n+   NPATTERNS interleaved patterns with NELTS_PER_PATTERN elements each,\n+   and BYTES is known to have enough bytes to supply NPATTERNS *\n+   NELTS_PER_PATTERN vector elements.  Each element of BYTES contains\n+   BITS_PER_UNIT bits and the bytes are in target memory order.\n+\n+   Return the vector on success, otherwise return null.  */\n+\n+static tree\n+native_decode_vector_tree (tree type, vec<unsigned char> bytes,\n+\t\t\t   unsigned int first_byte, unsigned int npatterns,\n+\t\t\t   unsigned int nelts_per_pattern)\n+{\n+  tree_vector_builder builder (type, npatterns, nelts_per_pattern);\n+  tree elt_type = TREE_TYPE (type);\n+  unsigned int elt_bits = tree_to_uhwi (TYPE_SIZE (elt_type));\n+  if (VECTOR_BOOLEAN_TYPE_P (type) && elt_bits <= BITS_PER_UNIT)\n+    {\n+      /* This is the only case in which elements can be smaller than a byte.\n+\t Element 0 is always in the lsb of the containing byte.  */\n+      elt_bits = TYPE_PRECISION (elt_type);\n+      for (unsigned int i = 0; i < builder.encoded_nelts (); ++i)\n+\t{\n+\t  unsigned int bit_index = first_byte * BITS_PER_UNIT + i * elt_bits;\n+\t  unsigned int byte_index = bit_index / BITS_PER_UNIT;\n+\t  unsigned int lsb = bit_index % BITS_PER_UNIT;\n+\t  builder.quick_push (bytes[byte_index] & (1 << lsb)\n+\t\t\t      ? build_all_ones_cst (elt_type)\n+\t\t\t      : build_zero_cst (elt_type));\n+\t}\n+    }\n+  else\n+    {\n+      unsigned int elt_bytes = elt_bits / BITS_PER_UNIT;\n+      for (unsigned int i = 0; i < builder.encoded_nelts (); ++i)\n+\t{\n+\t  tree elt = native_interpret_expr (elt_type, &bytes[first_byte],\n+\t\t\t\t\t    elt_bytes);\n+\t  if (!elt)\n+\t    return NULL_TREE;\n+\t  builder.quick_push (elt);\n+\t  first_byte += elt_bytes;\n+\t}\n+    }\n+  return builder.build ();\n+}\n+\n+/* Try to view-convert VECTOR_CST EXPR to VECTOR_TYPE TYPE by operating\n+   directly on the VECTOR_CST encoding, in a way that works for variable-\n+   length vectors.  Return the resulting VECTOR_CST on success or null\n+   on failure.  */\n+\n+static tree\n+fold_view_convert_vector_encoding (tree type, tree expr)\n+{\n+  tree expr_type = TREE_TYPE (expr);\n+  poly_uint64 type_bits, expr_bits;\n+  if (!poly_int_tree_p (TYPE_SIZE (type), &type_bits)\n+      || !poly_int_tree_p (TYPE_SIZE (expr_type), &expr_bits))\n+    return NULL_TREE;\n+\n+  poly_uint64 type_units = TYPE_VECTOR_SUBPARTS (type);\n+  poly_uint64 expr_units = TYPE_VECTOR_SUBPARTS (expr_type);\n+  unsigned int type_elt_bits = vector_element_size (type_bits, type_units);\n+  unsigned int expr_elt_bits = vector_element_size (expr_bits, expr_units);\n+\n+  /* We can only preserve the semantics of a stepped pattern if the new\n+     vector element is an integer of the same size.  */\n+  if (VECTOR_CST_STEPPED_P (expr)\n+      && (!INTEGRAL_TYPE_P (type) || type_elt_bits != expr_elt_bits))\n+    return NULL_TREE;\n+\n+  /* The number of bits needed to encode one element from every pattern\n+     of the original vector.  */\n+  unsigned int expr_sequence_bits\n+    = VECTOR_CST_NPATTERNS (expr) * expr_elt_bits;\n+\n+  /* The number of bits needed to encode one element from every pattern\n+     of the result.  */\n+  unsigned int type_sequence_bits\n+    = least_common_multiple (expr_sequence_bits, type_elt_bits);\n+\n+  /* Don't try to read more bytes than are available, which can happen\n+     for constant-sized vectors if TYPE has larger elements than EXPR_TYPE.\n+     The general VIEW_CONVERT handling can cope with that case, so there's\n+     no point complicating things here.  */\n+  unsigned int nelts_per_pattern = VECTOR_CST_NELTS_PER_PATTERN (expr);\n+  unsigned int buffer_bytes = CEIL (nelts_per_pattern * type_sequence_bits,\n+\t\t\t\t    BITS_PER_UNIT);\n+  unsigned int buffer_bits = buffer_bytes * BITS_PER_UNIT;\n+  if (known_gt (buffer_bits, expr_bits))\n+    return NULL_TREE;\n+\n+  /* Get enough bytes of EXPR to form the new encoding.  */\n+  auto_vec<unsigned char, 128> buffer (buffer_bytes);\n+  buffer.quick_grow (buffer_bytes);\n+  if (native_encode_vector_part (expr, buffer.address (), buffer_bytes, 0,\n+\t\t\t\t buffer_bits / expr_elt_bits)\n+      != (int) buffer_bytes)\n+    return NULL_TREE;\n+\n+  /* Reencode the bytes as TYPE.  */\n+  unsigned int type_npatterns = type_sequence_bits / type_elt_bits;\n+  return native_decode_vector_tree (type, buffer, 0, type_npatterns,\n+\t\t\t\t    nelts_per_pattern);\n+}\n \n /* Fold a VIEW_CONVERT_EXPR of a constant expression EXPR to type\n    TYPE at compile-time.  If we're unable to perform the conversion\n@@ -8065,6 +8182,10 @@ fold_view_convert_expr (tree type, tree expr)\n   if (CHAR_BIT != 8 || BITS_PER_UNIT != 8)\n     return NULL_TREE;\n \n+  if (VECTOR_TYPE_P (type) && TREE_CODE (expr) == VECTOR_CST)\n+    if (tree res = fold_view_convert_vector_encoding (type, expr))\n+      return res;\n+\n   len = native_encode_expr (expr, buffer, sizeof (buffer));\n   if (len == 0)\n     return NULL_TREE;"}, {"sha": "033f2e176676214604db4dd64e2816625f2611b8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c247d6f2a75b7e7a11546e897489716bc31506/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c247d6f2a75b7e7a11546e897489716bc31506/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=13c247d6f2a75b7e7a11546e897489716bc31506", "patch": "@@ -1,3 +1,7 @@\n+2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/acle/general/temporaries_1.c: New test.\n+\n 2019-11-18  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.dg/vect/vect-alias-check-8.c: Expect WAR/WAW checks to be used."}, {"sha": "217131d8c05d9879de3a646dee57f17dafa9326b", "filename": "gcc/testsuite/gcc.target/aarch64/sve/acle/general/temporaries_1.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13c247d6f2a75b7e7a11546e897489716bc31506/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Ftemporaries_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13c247d6f2a75b7e7a11546e897489716bc31506/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Ftemporaries_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Facle%2Fgeneral%2Ftemporaries_1.c?ref=13c247d6f2a75b7e7a11546e897489716bc31506", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* { dg-final { check-function-bodies \"**\" \"\" } } */\n+\n+#include <arm_sve.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/*\n+** test_s8:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1b\t(z[0-9]+\\.b), \\1/z, \\[x0\\]\n+**\tadd\t\\2, \\2, #1\n+**\tst1b\t\\2, \\1, \\[x1\\]\n+**\tret\n+*/\n+void\n+test_s8 (int8_t *x, int8_t *y)\n+{\n+  int8_t tmp1[32], tmp2[32];\n+\n+  svbool_t pg = svptrue_b8 ();\n+  svst1 (pg, tmp1, svld1 (pg, x));\n+  svst1 (pg, tmp2, svadd_x (pg, svld1 (pg, tmp1), 1));\n+  svst1 (pg, y, svld1 (pg, tmp2));\n+}\n+\n+/*\n+** test_s32_b8:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1w\t(z[0-9]+\\.s), \\1/z, \\[x0\\]\n+**\tadd\t\\2, \\2, #1\n+**\tst1w\t\\2, \\1, \\[x1\\]\n+**\tret\n+*/\n+void\n+test_s32_b8 (int32_t *x, int32_t *y)\n+{\n+  int32_t tmp1[8], tmp2[8];\n+\n+  svbool_t pg = svptrue_b8 ();\n+  svst1 (pg, tmp1, svld1 (pg, x));\n+  svst1 (pg, tmp2, svadd_x (pg, svld1 (pg, tmp1), 1));\n+  svst1 (pg, y, svld1 (pg, tmp2));\n+}\n+\n+/*\n+** test_s32_b32:\n+**\tptrue\t(p[0-7])\\.b, all\n+**\tld1w\t(z[0-9]+\\.s), \\1/z, \\[x0\\]\n+**\tadd\t\\2, \\2, #1\n+**\tst1w\t\\2, \\1, \\[x1\\]\n+**\tret\n+*/\n+void\n+test_s32_b32 (int32_t *x, int32_t *y)\n+{\n+  int32_t tmp1[8], tmp2[8];\n+\n+  svbool_t pg = svptrue_b32 ();\n+  svst1 (pg, tmp1, svld1 (pg, x));\n+  svst1 (pg, tmp2, svadd_x (pg, svld1 (pg, tmp1), 1));\n+  svst1 (pg, y, svld1 (pg, tmp2));\n+}\n+\n+#ifdef __cplusplus\n+}\n+#endif"}]}