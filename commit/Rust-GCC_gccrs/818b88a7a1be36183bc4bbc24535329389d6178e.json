{"sha": "818b88a7a1be36183bc4bbc24535329389d6178e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE4Yjg4YTdhMWJlMzYxODNiYzRiYmMyNDUzNTMyOTM4OWQ2MTc4ZQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2016-05-02T16:55:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-05-02T16:55:56Z"}, "message": "ipa-inline-analysis.c (reset_inline_summary): Clear fp_expressions\n\n\n\t* ipa-inline-analysis.c (reset_inline_summary): Clear fp_expressions\n\t(dump_inline_summary): Dump it.\n\t(fp_expression_p): New predicate.\n\t(estimate_function_body_sizes): Use it.\n\t(inline_merge_summary): Merge fp_expressions.\n\t(inline_read_section): Read fp_expressions.\n\t(inline_write_summary): Write fp_expressions.\n\t* ipa-inline.c (can_inline_edge_p): Permit inlining across fp math\n\tcodegen boundary if either caller or callee is !fp_expressions.\n\t* ipa-inline.h (inline_summary): Add fp_expressions.\n\t* ipa-inline-transform.c (inline_call): When inlining !fp_expressions\n\tto fp_expressions be sure the fp generation flags are updated.\n\n\t* gcc.dg/ipa/inline-8.c: New testcase.\n\nFrom-SVN: r235766", "tree": {"sha": "0c1f84b05ac0062b33430a17eb812449e210f06b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0c1f84b05ac0062b33430a17eb812449e210f06b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/818b88a7a1be36183bc4bbc24535329389d6178e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/818b88a7a1be36183bc4bbc24535329389d6178e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/818b88a7a1be36183bc4bbc24535329389d6178e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/818b88a7a1be36183bc4bbc24535329389d6178e/comments", "author": null, "committer": null, "parents": [{"sha": "dd77684f05433afcba15743ba1e2445804f9ac9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dd77684f05433afcba15743ba1e2445804f9ac9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dd77684f05433afcba15743ba1e2445804f9ac9f"}], "stats": {"total": 178, "additions": 163, "deletions": 15}, "files": [{"sha": "9464a9505562257a370a9b13ae7492e15713299b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=818b88a7a1be36183bc4bbc24535329389d6178e", "patch": "@@ -1,3 +1,18 @@\n+2016-05-02  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-inline-analysis.c (reset_inline_summary): Clear fp_expressions\n+\t(dump_inline_summary): Dump it.\n+\t(fp_expression_p): New predicate.\n+\t(estimate_function_body_sizes): Use it.\n+\t(inline_merge_summary): Merge fp_expressions.\n+\t(inline_read_section): Read fp_expressions.\n+\t(inline_write_summary): Write fp_expressions.\n+\t* ipa-inline.c (can_inline_edge_p): Permit inlining across fp math\n+\tcodegen boundary if either caller or callee is !fp_expressions.\n+\t* ipa-inline.h (inline_summary): Add fp_expressions.\n+\t* ipa-inline-transform.c (inline_call): When inlining !fp_expressions\n+\tto fp_expressions be sure the fp generation flags are updated.\n+\n 2016-05-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/70467"}, {"sha": "a2f31285506e5dbed302d6abe2fa85afc6c0c303", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=818b88a7a1be36183bc4bbc24535329389d6178e", "patch": "@@ -850,7 +850,8 @@ evaluate_conditions_for_known_args (struct cgraph_node *node,\n \t  if (known_aggs.exists ())\n \t    {\n \t      agg = known_aggs[c->operand_num];\n-\t      val = ipa_find_agg_cst_for_param (agg, c->offset, c->by_ref);\n+\t      val = ipa_find_agg_cst_for_param (agg, known_vals[c->operand_num],\n+\t\t\t\t\t\tc->offset, c->by_ref);\n \t    }\n \t  else\n \t    val = NULL_TREE;\n@@ -1069,6 +1070,7 @@ reset_inline_summary (struct cgraph_node *node,\n     reset_inline_edge_summary (e);\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     reset_inline_edge_summary (e);\n+  info->fp_expressions = false;\n }\n \n /* Hook that is called by cgraph.c when a node is removed.  */\n@@ -1423,6 +1425,8 @@ dump_inline_summary (FILE *f, struct cgraph_node *node)\n \tfprintf (f, \" inlinable\");\n       if (s->contains_cilk_spawn)\n \tfprintf (f, \" contains_cilk_spawn\");\n+      if (s->fp_expressions)\n+\tfprintf (f, \" fp_expression\");\n       fprintf (f, \"\\n  self time:       %i\\n\", s->self_time);\n       fprintf (f, \"  global time:     %i\\n\", s->time);\n       fprintf (f, \"  self size:       %i\\n\", s->self_size);\n@@ -2459,6 +2463,21 @@ clobber_only_eh_bb_p (basic_block bb, bool need_eh = true)\n   return true;\n }\n \n+/* Return true if STMT compute a floating point expression that may be affected\n+   by -ffast-math and similar flags.  */\n+\n+static bool\n+fp_expression_p (gimple *stmt)\n+{\n+  ssa_op_iter i;\n+  tree op;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt, i, SSA_OP_DEF|SSA_OP_USE)\n+    if (FLOAT_TYPE_P (TREE_TYPE (op)))\n+      return true;\n+  return false;\n+}\n+\n /* Compute function body size parameters for NODE.\n    When EARLY is true, we compute only simple summaries without\n    non-trivial predicates to drive the early inliner.  */\n@@ -2733,6 +2752,13 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n \t\t\t\t       this_time * (2 - prob), &p);\n \t\t}\n \n+\t      if (!info->fp_expressions && fp_expression_p (stmt))\n+\t\t{\n+\t\t  info->fp_expressions = true;\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"   fp_expression set\\n\");\n+\t\t}\n+\n \t      gcc_assert (time >= 0);\n \t      gcc_assert (size >= 0);\n \t    }\n@@ -3577,6 +3603,8 @@ inline_merge_summary (struct cgraph_edge *edge)\n   else\n     toplev_predicate = true_predicate ();\n \n+  info->fp_expressions |= callee_info->fp_expressions;\n+\n   if (callee_info->conds)\n     evaluate_properties_for_edge (edge, true, &clause, NULL, NULL, NULL);\n   if (ipa_node_params_sum && callee_info->conds)\n@@ -4229,6 +4257,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       bp = streamer_read_bitpack (&ib);\n       info->inlinable = bp_unpack_value (&bp, 1);\n       info->contains_cilk_spawn = bp_unpack_value (&bp, 1);\n+      info->fp_expressions = bp_unpack_value (&bp, 1);\n \n       count2 = streamer_read_uhwi (&ib);\n       gcc_assert (!info->conds);\n@@ -4395,6 +4424,7 @@ inline_write_summary (void)\n \t  bp = bitpack_create (ob->main_stream);\n \t  bp_pack_value (&bp, info->inlinable, 1);\n \t  bp_pack_value (&bp, info->contains_cilk_spawn, 1);\n+\t  bp_pack_value (&bp, info->fp_expressions, 1);\n \t  streamer_write_bitpack (&bp);\n \t  streamer_write_uhwi (ob, vec_safe_length (info->conds));\n \t  for (i = 0; vec_safe_iterate (info->conds, i, &c); i++)"}, {"sha": "759617bb72f5b41a564b99c045db69799de86f4a", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=818b88a7a1be36183bc4bbc24535329389d6178e", "patch": "@@ -338,6 +338,63 @@ inline_call (struct cgraph_edge *e, bool update_original,\n       DECL_FUNCTION_SPECIFIC_OPTIMIZATION (to->decl)\n \t = build_optimization_node (&opts);\n     }\n+  inline_summary *caller_info = inline_summaries->get (to);\n+  inline_summary *callee_info = inline_summaries->get (callee);\n+  if (!caller_info->fp_expressions && callee_info->fp_expressions)\n+    {\n+      caller_info->fp_expressions = true;\n+      if (opt_for_fn (callee->decl, flag_rounding_math)\n+\t  != opt_for_fn (to->decl, flag_rounding_math)\n+\t  || opt_for_fn (callee->decl, flag_trapping_math)\n+\t     != opt_for_fn (to->decl, flag_trapping_math)\n+\t  || opt_for_fn (callee->decl, flag_unsafe_math_optimizations)\n+\t     != opt_for_fn (to->decl, flag_unsafe_math_optimizations)\n+\t  || opt_for_fn (callee->decl, flag_finite_math_only)\n+\t     != opt_for_fn (to->decl, flag_finite_math_only)\n+\t  || opt_for_fn (callee->decl, flag_signaling_nans)\n+\t     != opt_for_fn (to->decl, flag_signaling_nans)\n+\t  || opt_for_fn (callee->decl, flag_cx_limited_range)\n+\t     != opt_for_fn (to->decl, flag_cx_limited_range)\n+\t  || opt_for_fn (callee->decl, flag_signed_zeros)\n+\t     != opt_for_fn (to->decl, flag_signed_zeros)\n+\t  || opt_for_fn (callee->decl, flag_associative_math)\n+\t     != opt_for_fn (to->decl, flag_associative_math)\n+\t  || opt_for_fn (callee->decl, flag_reciprocal_math)\n+\t     != opt_for_fn (to->decl, flag_reciprocal_math)\n+\t  || opt_for_fn (callee->decl, flag_errno_math)\n+\t     != opt_for_fn (to->decl, flag_errno_math))\n+\t{\n+\t  struct gcc_options opts = global_options;\n+\n+\t  cl_optimization_restore (&opts, opts_for_fn (to->decl));\n+\t  opts.x_flag_rounding_math\n+\t    = opt_for_fn (callee->decl, flag_rounding_math);\n+\t  opts.x_flag_trapping_math\n+\t    = opt_for_fn (callee->decl, flag_trapping_math);\n+\t  opts.x_flag_unsafe_math_optimizations\n+\t    = opt_for_fn (callee->decl, flag_unsafe_math_optimizations);\n+\t  opts.x_flag_finite_math_only\n+\t    = opt_for_fn (callee->decl, flag_finite_math_only);\n+\t  opts.x_flag_signaling_nans\n+\t    = opt_for_fn (callee->decl, flag_signaling_nans);\n+\t  opts.x_flag_cx_limited_range\n+\t    = opt_for_fn (callee->decl, flag_cx_limited_range);\n+\t  opts.x_flag_signed_zeros\n+\t    = opt_for_fn (callee->decl, flag_signed_zeros);\n+\t  opts.x_flag_associative_math\n+\t    = opt_for_fn (callee->decl, flag_associative_math);\n+\t  opts.x_flag_reciprocal_math\n+\t    = opt_for_fn (callee->decl, flag_reciprocal_math);\n+\t  opts.x_flag_errno_math\n+\t    = opt_for_fn (callee->decl, flag_errno_math);\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Copying FP flags from %s:%i to %s:%i\\n\",\n+\t\t     callee->name (), callee->order, to->name (), to->order);\n+\t  build_optimization_node (&opts);\n+\t  DECL_FUNCTION_SPECIFIC_OPTIMIZATION (to->decl)\n+\t     = build_optimization_node (&opts);\n+\t}\n+    }\n \n   /* If aliases are involved, redirect edge to the actual destination and\n      possibly remove the aliases.  */"}, {"sha": "d520c556d435593a44ea9a759e709649acceba33", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 18, "deletions": 14, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=818b88a7a1be36183bc4bbc24535329389d6178e", "patch": "@@ -338,7 +338,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n   else if (e->call_stmt_cannot_inline_p)\n     {\n       if (e->inline_failed != CIF_FUNCTION_NOT_OPTIMIZED)\n-        e->inline_failed = CIF_MISMATCHED_ARGUMENTS;\n+        e->inline_failed = e->caller->thunk.thunk_p ? CIF_THUNK : CIF_MISMATCHED_ARGUMENTS;\n       inlinable = false;\n     }\n   /* Don't inline if the functions have different EH personalities.  */\n@@ -396,6 +396,8 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n \t     (DECL_DISREGARD_INLINE_LIMITS (callee->decl)\n \t      && lookup_attribute (\"always_inline\",\n \t\t\t\t   DECL_ATTRIBUTES (callee->decl)));\n+      inline_summary *caller_info = inline_summaries->get (caller);\n+      inline_summary *callee_info = inline_summaries->get (callee);\n \n      /* Until GCC 4.9 we did not check the semantics alterning flags\n \tbellow and inline across optimization boundry.\n@@ -417,16 +419,21 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n \t\t   == !opt_for_fn (callee->decl, optimize) || !always_inline))\n \t      || check_match (flag_wrapv)\n \t      || check_match (flag_trapv)\n-\t      /* Strictly speaking only when the callee uses FP math.  */\n-\t      || check_maybe_up (flag_rounding_math)\n-\t      || check_maybe_up (flag_trapping_math)\n-\t      || check_maybe_down (flag_unsafe_math_optimizations)\n-\t      || check_maybe_down (flag_finite_math_only)\n-\t      || check_maybe_up (flag_signaling_nans)\n-\t      || check_maybe_down (flag_cx_limited_range)\n-\t      || check_maybe_up (flag_signed_zeros)\n-\t      || check_maybe_down (flag_associative_math)\n-\t      || check_maybe_down (flag_reciprocal_math)\n+\t      /* When caller or callee does FP math, be sure FP codegen flags\n+\t\t compatible.  */\n+\t      || ((caller_info->fp_expressions && callee_info->fp_expressions)\n+\t\t  && (check_maybe_up (flag_rounding_math)\n+\t\t      || check_maybe_up (flag_trapping_math)\n+\t\t      || check_maybe_down (flag_unsafe_math_optimizations)\n+\t\t      || check_maybe_down (flag_finite_math_only)\n+\t\t      || check_maybe_up (flag_signaling_nans)\n+\t\t      || check_maybe_down (flag_cx_limited_range)\n+\t\t      || check_maybe_up (flag_signed_zeros)\n+\t\t      || check_maybe_down (flag_associative_math)\n+\t\t      || check_maybe_down (flag_reciprocal_math)\n+\t\t      /* Strictly speaking only when the callee contains function\n+\t\t\t calls that may end up setting errno.  */\n+\t\t      || check_maybe_up (flag_errno_math)))\n \t      /* We do not want to make code compiled with exceptions to be\n \t\t brought into a non-EH function unless we know that the callee\n \t\t does not throw.\n@@ -435,9 +442,6 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n \t\t  && DECL_FUNCTION_PERSONALITY (callee->decl))\n \t      || (check_maybe_up (flag_exceptions)\n \t\t  && DECL_FUNCTION_PERSONALITY (callee->decl))\n-\t      /* Strictly speaking only when the callee contains function\n-\t\t calls that may end up setting errno.  */\n-\t      || check_maybe_up (flag_errno_math)\n \t      /* When devirtualization is diabled for callee, it is not safe\n \t\t to inline it as we possibly mangled the type info.\n \t\t Allow early inlining of always inlines.  */"}, {"sha": "df535d06316f474ca18c097756d071e216e9f5c2", "filename": "gcc/ipa-inline.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Fipa-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Fipa-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.h?ref=818b88a7a1be36183bc4bbc24535329389d6178e", "patch": "@@ -132,6 +132,8 @@ struct GTY(()) inline_summary\n   /* True wen there is only one caller of the function before small function\n      inlining.  */\n   unsigned int single_caller : 1;\n+  /* True if function contains any floating point expressions.  */\n+  unsigned int fp_expressions : 1;\n \n   /* Information about function that will result after applying all the\n      inline decisions present in the callgraph.  Generally kept up to"}, {"sha": "45af33f0de5c28fff8e21ac22913bc6a0e613519", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=818b88a7a1be36183bc4bbc24535329389d6178e", "patch": "@@ -1,3 +1,7 @@\n+2016-05-02  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* gcc.dg/ipa/inline-8.c: New testcase.\n+\n 2016-05-02  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/70467"}, {"sha": "a4ac5d0487b50344d697b19bd10498e7b9b793a2", "filename": "gcc/testsuite/gcc.dg/ipa/inline-8.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/818b88a7a1be36183bc4bbc24535329389d6178e/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Finline-8.c?ref=818b88a7a1be36183bc4bbc24535329389d6178e", "patch": "@@ -0,0 +1,36 @@\n+/* Verify that we do not inline isnanf test info -ffast-math code but that we\n+   do inline trivial functions across -Ofast boundary.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O2\"  } */\n+#include <math.h>\n+/* Can't be inlined because isnanf will be optimized out.  */\n+int\n+cmp (float a)\n+{\n+  return isnanf (a);\n+}\n+/* Can be inlined.  */\n+int\n+move (int a)\n+{\n+  return a;\n+}\n+float a;\n+void\n+set ()\n+{\n+ a=nan(\"\");\n+}\n+float b;\n+__attribute__ ((optimize(\"Ofast\")))\n+int\n+main()\n+{\n+  b++;\n+  if (cmp(a))\n+    __builtin_abort ();\n+  float a = move (1);\n+  if (!__builtin_constant_p (a))\n+    __builtin_abort ();\n+  return 0;\n+}"}]}