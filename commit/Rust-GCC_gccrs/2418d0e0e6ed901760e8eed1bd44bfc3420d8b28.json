{"sha": "2418d0e0e6ed901760e8eed1bd44bfc3420d8b28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQxOGQwZTBlNmVkOTAxNzYwZThlZWQxYmQ0NGJmYzM0MjBkOGIyOA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2009-07-09T01:20:23Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2009-07-09T01:20:23Z"}, "message": "re PR libfortran/40330 (incorrect IO)\n\n2009-07-08  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libfortran/40330\n\tPR libfortran/40662\n\t* io/io.h (st_parameter_dt): Define format_not_saved bit used to signal\n\twhether the parsed format data was previously saved. Used to determine\n\tif the current format data should be freed or not.\n\t* io/transfer.c (st_read_done): Use the format_not_saved bit.\n\t(st_write_done): Likewise.\n\t* io/format.c (parse_format_list): Add boolean pointer to arg list. This\n\tpointer is used to return status to the caller regarding whether it is\n\tsafe to cache the parsed format data.  Currently, if a FMT_STRING token\n\tis encounetered, it is not safe to cache. Also, added a local boolean\n\tvariable to hold this information as recursive calls to\n\tparse_format_list are made.  Remove previous save_format logic.\n\t(parse_format): Do not use the format caching facility if the current\n\tunit is an internal unit or if it is not safe to save parsed format\n\tdata.\n\nFrom-SVN: r149398", "tree": {"sha": "3bf52d80ea16f6a7a75628ee694ae0b8f8dd3739", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3bf52d80ea16f6a7a75628ee694ae0b8f8dd3739"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28/comments", "author": null, "committer": null, "parents": [{"sha": "0eb8f20cf8b866a10d5aeac74f8445c4f61bcaf5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0eb8f20cf8b866a10d5aeac74f8445c4f61bcaf5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0eb8f20cf8b866a10d5aeac74f8445c4f61bcaf5"}], "stats": {"total": 83, "additions": 54, "deletions": 29}, "files": [{"sha": "7ea4129aed27bf4be01ed49840599f5fc06134bd", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=2418d0e0e6ed901760e8eed1bd44bfc3420d8b28", "patch": "@@ -1,3 +1,22 @@\n+2009-07-08  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libfortran/40330\n+\tPR libfortran/40662\n+\t* io/io.h (st_parameter_dt): Define format_not_saved bit used to signal\n+\twhether the parsed format data was previously saved. Used to determine\n+\tif the current format data should be freed or not.\n+\t* io/transfer.c (st_read_done): Use the format_not_saved bit.\n+\t(st_write_done): Likewise.\n+\t* io/format.c (parse_format_list): Add boolean pointer to arg list. This\n+\tpointer is used to return status to the caller regarding whether it is\n+\tsafe to cache the parsed format data.  Currently, if a FMT_STRING token\n+\tis encounetered, it is not safe to cache. Also, added a local boolean\n+\tvariable to hold this information as recursive calls to\n+\tparse_format_list are made.  Remove previous save_format logic.\n+\t(parse_format): Do not use the format caching facility if the current\n+\tunit is an internal unit or if it is not safe to save parsed format\n+\tdata.\n+\t\n 2009-06-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libfortran/40576"}, {"sha": "e40adb9b2a103f82c2202dc84f400da7f16319fb", "filename": "libgfortran/io/format.c", "status": "modified", "additions": 30, "deletions": 26, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28/libgfortran%2Fio%2Fformat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28/libgfortran%2Fio%2Fformat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fformat.c?ref=2418d0e0e6ed901760e8eed1bd44bfc3420d8b28", "patch": "@@ -578,16 +578,16 @@ format_lex (format_data *fmt)\n  * parenthesis node which contains the rest of the list. */\n \n static fnode *\n-parse_format_list (st_parameter_dt *dtp)\n+parse_format_list (st_parameter_dt *dtp, bool *save_ok)\n {\n   fnode *head, *tail;\n   format_token t, u, t2;\n   int repeat;\n   format_data *fmt = dtp->u.p.fmt;\n-  bool save_format;\n+  bool saveit;\n \n   head = tail = NULL;\n-  save_format = !is_internal_unit (dtp);\n+  saveit = *save_ok;\n \n   /* Get the next format item */\n  format_item:\n@@ -604,7 +604,7 @@ parse_format_list (st_parameter_dt *dtp)\n \tcase FMT_LPAREN:\n \t  get_fnode (fmt, &head, &tail, FMT_LPAREN);\n \t  tail->repeat = repeat;\n-\t  tail->u.child = parse_format_list (dtp);\n+\t  tail->u.child = parse_format_list (dtp, &saveit);\n \t  if (fmt->error != NULL)\n \t    goto finished;\n \n@@ -631,7 +631,7 @@ parse_format_list (st_parameter_dt *dtp)\n     case FMT_LPAREN:\n       get_fnode (fmt, &head, &tail, FMT_LPAREN);\n       tail->repeat = 1;\n-      tail->u.child = parse_format_list (dtp);\n+      tail->u.child = parse_format_list (dtp, &saveit);\n       if (fmt->error != NULL)\n \tgoto finished;\n \n@@ -687,8 +687,9 @@ parse_format_list (st_parameter_dt *dtp)\n       goto between_desc;\n \n     case FMT_STRING:\n+      /* TODO: Find out why is is necessary to turn off format caching.  */\n+      saveit = false;\n       get_fnode (fmt, &head, &tail, FMT_STRING);\n-\n       tail->u.string.p = fmt->string;\n       tail->u.string.length = fmt->value;\n       tail->repeat = 1;\n@@ -698,7 +699,6 @@ parse_format_list (st_parameter_dt *dtp)\n     case FMT_DP:\n       notify_std (&dtp->common, GFC_STD_F2003, \"Fortran 2003: DC or DP \"\n \t\t  \"descriptor not allowed\");\n-      save_format = true;\n     /* Fall through.  */\n     case FMT_S:\n     case FMT_SS:\n@@ -724,10 +724,8 @@ parse_format_list (st_parameter_dt *dtp)\n       get_fnode (fmt, &head, &tail, FMT_DOLLAR);\n       tail->repeat = 1;\n       notify_std (&dtp->common, GFC_STD_GNU, \"Extension: $ descriptor\");\n-      save_format = false;\n       goto between_desc;\n \n-\n     case FMT_T:\n     case FMT_TL:\n     case FMT_TR:\n@@ -759,7 +757,6 @@ parse_format_list (st_parameter_dt *dtp)\n \n     case FMT_H:\n       get_fnode (fmt, &head, &tail, FMT_STRING);\n-\n       if (fmt->format_string_len < 1)\n \t{\n \t  fmt->error = bad_hollerith;\n@@ -822,7 +819,6 @@ parse_format_list (st_parameter_dt *dtp)\n \t      fmt->saved_token = t;\n \t      fmt->value = 1;\t/* Default width */\n \t      notify_std (&dtp->common, GFC_STD_GNU, posint_required);\n-\t      save_format = false;\n \t    }\n \t}\n \n@@ -959,7 +955,6 @@ parse_format_list (st_parameter_dt *dtp)\n \t}\n \n       get_fnode (fmt, &head, &tail, FMT_STRING);\n-\n       tail->u.string.p = fmt->format_string;\n       tail->u.string.length = repeat;\n       tail->repeat = 1;\n@@ -1074,6 +1069,9 @@ parse_format_list (st_parameter_dt *dtp)\n   goto format_item;\n \n  finished:\n+\n+  *save_ok = saveit;\n+  \n   return head;\n }\n \n@@ -1166,18 +1164,23 @@ void\n parse_format (st_parameter_dt *dtp)\n {\n   format_data *fmt;\n+  bool format_cache_ok;\n \n-  /* Lookup format string to see if it has already been parsed.  */\n-\n-  dtp->u.p.fmt = find_parsed_format (dtp);\n+  format_cache_ok = !is_internal_unit (dtp);\n \n-  if (dtp->u.p.fmt != NULL)\n+  /* Lookup format string to see if it has already been parsed.  */\n+  if (format_cache_ok)\n     {\n-      dtp->u.p.fmt->reversion_ok = 0;\n-      dtp->u.p.fmt->saved_token = FMT_NONE;\n-      dtp->u.p.fmt->saved_format = NULL;\n-      reset_fnode_counters (dtp);\n-      return;\n+      dtp->u.p.fmt = find_parsed_format (dtp);\n+\n+      if (dtp->u.p.fmt != NULL)\n+\t{\n+\t  dtp->u.p.fmt->reversion_ok = 0;\n+\t  dtp->u.p.fmt->saved_token = FMT_NONE;\n+\t  dtp->u.p.fmt->saved_format = NULL;\n+\t  reset_fnode_counters (dtp);\n+\t  return;\n+\t}\n     }\n \n   /* Not found so proceed as follows.  */\n@@ -1191,12 +1194,12 @@ parse_format (st_parameter_dt *dtp)\n   fmt->error = NULL;\n   fmt->value = 0;\n \n-  /* Initialize variables used during traversal of the tree */\n+  /* Initialize variables used during traversal of the tree.  */\n \n   fmt->reversion_ok = 0;\n   fmt->saved_format = NULL;\n \n-  /* Allocate the first format node as the root of the tree */\n+  /* Allocate the first format node as the root of the tree.  */\n \n   fmt->last = &fmt->array;\n   fmt->last->next = NULL;\n@@ -1208,7 +1211,7 @@ parse_format (st_parameter_dt *dtp)\n   fmt->avail++;\n \n   if (format_lex (fmt) == FMT_LPAREN)\n-    fmt->array.array[0].u.child = parse_format_list (dtp);\n+    fmt->array.array[0].u.child = parse_format_list (dtp, &format_cache_ok);\n   else\n     fmt->error = \"Missing initial left parenthesis in format\";\n \n@@ -1219,9 +1222,10 @@ parse_format (st_parameter_dt *dtp)\n       return;\n     }\n \n-  /* TODO: Interim fix for PR40508. Revise this for PR40330.  */\n-  if (!is_internal_unit(dtp))\n+  if (format_cache_ok)\n     save_parsed_format (dtp);\n+  else\n+    dtp->u.p.format_not_saved = 1;\n }\n \n "}, {"sha": "088969a0fcae1e7b393bdb680d96c7a4bdd7f800", "filename": "libgfortran/io/io.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28/libgfortran%2Fio%2Fio.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28/libgfortran%2Fio%2Fio.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fio.h?ref=2418d0e0e6ed901760e8eed1bd44bfc3420d8b28", "patch": "@@ -481,7 +481,9 @@ typedef struct st_parameter_dt\n \t  unsigned at_eof : 1;\n \t  /* Used for g0 floating point output.  */\n \t  unsigned g0_no_blanks : 1;\n-\t  /* 15 unused bits.  */\n+\t  /* Used to signal use of free_format_data.  */\n+\t  unsigned format_not_saved : 1;\n+\t  /* 14 unused bits.  */\n \n \t  char last_char;\n \t  char nml_delim;"}, {"sha": "7d833b78013957dd327d4beead7930e658620dda", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2418d0e0e6ed901760e8eed1bd44bfc3420d8b28/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=2418d0e0e6ed901760e8eed1bd44bfc3420d8b28", "patch": "@@ -3251,7 +3251,7 @@ void\n st_read_done (st_parameter_dt *dtp)\n {\n   finalize_transfer (dtp);\n-  if (is_internal_unit (dtp))\n+  if (is_internal_unit (dtp) || dtp->u.p.format_not_saved)\n     free_format_data (dtp->u.p.fmt);\n   free_ionml (dtp);\n   if (dtp->u.p.current_unit != NULL)\n@@ -3303,7 +3303,7 @@ st_write_done (st_parameter_dt *dtp)\n \tbreak;\n       }\n \n-  if (is_internal_unit (dtp))\n+  if (is_internal_unit (dtp) || dtp->u.p.format_not_saved)\n     free_format_data (dtp->u.p.fmt);\n   free_ionml (dtp);\n   if (dtp->u.p.current_unit != NULL)"}]}