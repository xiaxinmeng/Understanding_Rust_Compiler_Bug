{"sha": "c2beaa0254cdfa9c4da5b9bc4177b07c893e207b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzJiZWFhMDI1NGNkZmE5YzRkYTViOWJjNDE3N2IwN2M4OTNlMjA3Yg==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2011-02-19T05:11:21Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2011-02-19T05:11:21Z"}, "message": "Updated comments\n\nFrom-SVN: r170308", "tree": {"sha": "4f05a5be63689ea1bed8add55e68f8c0dbe4d8c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f05a5be63689ea1bed8add55e68f8c0dbe4d8c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c2beaa0254cdfa9c4da5b9bc4177b07c893e207b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2beaa0254cdfa9c4da5b9bc4177b07c893e207b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c2beaa0254cdfa9c4da5b9bc4177b07c893e207b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c2beaa0254cdfa9c4da5b9bc4177b07c893e207b/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "54ba93231b4a4d8ca3007949c9d68b6a09440c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54ba93231b4a4d8ca3007949c9d68b6a09440c26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54ba93231b4a4d8ca3007949c9d68b6a09440c26"}], "stats": {"total": 621, "additions": 336, "deletions": 285}, "files": [{"sha": "eda00dfdd9a5c912c23d221ccf7e4dec661a52fa", "filename": "gcc/objc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2beaa0254cdfa9c4da5b9bc4177b07c893e207b/gcc%2Fobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2beaa0254cdfa9c4da5b9bc4177b07c893e207b/gcc%2Fobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2FChangeLog?ref=c2beaa0254cdfa9c4da5b9bc4177b07c893e207b", "patch": "@@ -1,3 +1,8 @@\n+2011-01-19  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc-next-runtime-abi-01.c: Updated comments.\n+\t* objc-next-runtime-abi-02.c: Same.\n+\n 2011-01-19  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-act.c (objc_init, generate_struct_by_value_array): Updated"}, {"sha": "3bab0a92d5e567efbf194444fe2d0d256cb011c1", "filename": "gcc/objc/objc-next-runtime-abi-01.c", "status": "modified", "additions": 62, "deletions": 50, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2beaa0254cdfa9c4da5b9bc4177b07c893e207b/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2beaa0254cdfa9c4da5b9bc4177b07c893e207b/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-01.c?ref=c2beaa0254cdfa9c4da5b9bc4177b07c893e207b", "patch": "@@ -18,10 +18,10 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* This implements the original NeXT ABI (0) used for m32 code and indicated\n-   by module version 6.  It also implements the small number of additions made\n-   for properties and optional protocol methods as ABI=1 \n-   (module version 7).  */\n+/* This implements the original NeXT ABI (0) used for m32 code and\n+   indicated by module version 6.  It also implements the small number\n+   of additions made for properties and optional protocol methods as\n+   ABI=1 (module version 7).  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -39,8 +39,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-objc.h\"\n #include \"objc-act.h\"\n \n-/* When building Objective-C++, we are not linking against the C front-end\n-   and so need to replicate the C tree-construction functions in some way.  */\n+/* When building Objective-C++, we are not linking against the C\n+   front-end and so need to replicate the C tree-construction\n+   functions in some way.  */\n #ifdef OBJCPLUS\n #define OBJCP_REMAP_FUNCTIONS\n #include \"objcp-decl.h\"\n@@ -85,9 +86,9 @@ along with GCC; see the file COPYING3.  If not see\n #define TAG_MSGSEND_FAST\t\t\"objc_msgSend_Fast\"\n #define TAG_ASSIGNIVAR_FAST\t\t\"objc_assign_ivar_Fast\"\n \n-/* The version identifies which language generation and runtime\n-   the module (file) was compiled for, and is recorded in the\n-   module descriptor.  */\n+/* The version identifies which language generation and runtime the\n+   module (file) was compiled for, and is recorded in the module\n+   descriptor.  */\n #define OBJC_VERSION\t\t\t(flag_objc_abi >= 1 ? 7 : 6)\n \n #define UTAG_CLASS_EXT\t\t\t\"_objc_class_ext\"\n@@ -96,10 +97,10 @@ along with GCC; see the file COPYING3.  If not see\n \n #define CLS_HAS_CXX_STRUCTORS\t\t0x2000L\n \n-/* rt_trees identifiers - shared between NeXT implementations.  These allow\n-   the FE to tag meta-data in a manner that survives LTO and can be used when\n-   the  runtime requires that certain meta-data items appear in particular\n-   named sections.  */\n+/* rt_trees identifiers - shared between NeXT implementations.  These\n+   allow the FE to tag meta-data in a manner that survives LTO and can\n+   be used when the runtime requires that certain meta-data items\n+   appear in particular named sections.  */\n \n #include \"objc-next-metadata-tags.h\"\n extern GTY(()) tree objc_rt_trees[OCTI_RT_META_MAX];\n@@ -187,14 +188,15 @@ objc_next_runtime_abi_01_init (objc_runtime_hooks *rthooks)\n   return true;\n }\n \n-/* We need a way to convey what kind of meta-data are represented by a given\n-   variable, since each type is expected (by the runtime) to be found in a\n-   specific named section.  The solution must be usable with LTO.\n+/* We need a way to convey what kind of meta-data are represented by a\n+   given variable, since each type is expected (by the runtime) to be\n+   found in a specific named section.  The solution must be usable\n+   with LTO.\n    \n-   The scheme used for NeXT ABI 0/1 (partial matching of variable names) is not\n-   satisfactory for LTO & ABI-2.  We now tag ObjC meta-data with identification\n-   attributes in the front end.  The back-end may choose to act on these as it\n-   requires.  */\n+   The scheme used for NeXT ABI 0/1 (partial matching of variable\n+   names) is not satisfactory for LTO & ABI-2.  We now tag ObjC\n+   meta-data with identification attributes in the front end.  The\n+   back-end may choose to act on these as it requires.  */\n \n static void\n next_runtime_abi_01_init_metadata_attributes (void)\n@@ -252,9 +254,10 @@ static void next_runtime_01_initialize (void)\n   tree type;\n \n #ifdef OBJCPLUS\n-      /* For all NeXT objc ABIs -fobjc-call-cxx-cdtors is on by default. */\n-      if (!global_options_set.x_flag_objc_call_cxx_cdtors)\n-        global_options.x_flag_objc_call_cxx_cdtors = 1;\n+  /* For all NeXT objc ABIs -fobjc-call-cxx-cdtors is on by\n+     default.  */\n+  if (!global_options_set.x_flag_objc_call_cxx_cdtors)\n+    global_options.x_flag_objc_call_cxx_cdtors = 1;\n #endif\n \n   /* Set up attributes to be attached to the meta-data so that they\n@@ -265,7 +268,8 @@ static void next_runtime_01_initialize (void)\n     objc_prop_list_ptr = build_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t\t\t     get_identifier (\"_prop_list_t\")));\n \n- /* Declare type of selector-objects that represent an operation name.  */\n+ /* Declare type of selector-objects that represent an operation\n+    name.  */\n   /* `struct objc_selector *' */\n   objc_selector_type = build_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t\t\t   get_identifier (TAG_SELECTOR)));\n@@ -306,8 +310,8 @@ static void next_runtime_01_initialize (void)\n \t\t\t\t\t\t NULL, NULL_TREE);\n \n   /* These can throw, because the function that gets called can throw\n-     in Obj-C++, or could itself call something that can throw even\n-     in Obj-C.  */\n+     in Obj-C++, or could itself call something that can throw even in\n+     Obj-C.  */\n   TREE_NOTHROW (umsg_decl) = 0;\n   TREE_NOTHROW (umsg_nonnil_decl) = 0;\n   TREE_NOTHROW (umsg_stret_decl) = 0;\n@@ -357,7 +361,8 @@ static void next_runtime_01_initialize (void)\n   objc_get_meta_class_decl\n     = add_builtin_function (TAG_GETMETACLASS, type, 0, NOT_BUILT_IN, NULL, NULL_TREE);\n \n-  /* This is the type of all of the following functions objc_copyStruct().  */\n+  /* This is the type of all of the following functions\n+     objc_copyStruct().  */\n   type = build_function_type_list (void_type_node,\n \t\t\t\t   ptr_type_node,\n \t\t\t\t   const_ptr_type_node,\n@@ -368,7 +373,7 @@ static void next_runtime_01_initialize (void)\n   /* Declare the following function:\n \t void\n          objc_copyStruct (void *destination, const void *source, \n-\t                  ptrdiff_t size, BOOL is_atomic, BOOL has_strong);  */\n+\t                  ptrdiff_t size, BOOL is_atomic, BOOL has_strong); */\n   objc_copyStruct_decl = add_builtin_function (\"objc_copyStruct\",\n \t\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n \t\t\t\t\t\t   NULL, NULL_TREE);\n@@ -385,7 +390,8 @@ static void next_runtime_01_initialize (void)\n \n /* --- templates --- */\n \n-/* struct _objc_class {\n+/* struct _objc_class \n+   {\n      struct _objc_class *isa;\n      struct _objc_class *super_class;\n      char *name;\n@@ -403,10 +409,11 @@ static void next_runtime_01_initialize (void)\n      void *sel_id;\n      void *gc_object_type;\n     #endif\n-   };  */\n+   }; */\n \n-/* The 'sel_id' & 'gc_object_type' fields are not used by the NeXT runtime.\n-   We generate them for ABI==0 to maintain backward binary compatibility.  */\n+/* The 'sel_id' & 'gc_object_type' fields are not used by the NeXT\n+   runtime.  We generate them for ABI==0 to maintain backward binary\n+   compatibility.  */\n \n static void\n build_v1_class_template (void)\n@@ -474,16 +481,17 @@ build_v1_class_template (void)\n   objc_finish_struct (objc_class_template, decls);\n }\n \n-/* struct _objc_category {\n+/* struct _objc_category\n+   {\n      char *category_name;\n      char *class_name;\n      struct _objc_method_list *instance_methods;\n      struct _objc_method_list *class_methods;\n      struct _objc_protocol_list *protocols;\n-   if ABI=1\n+   #if ABI=1\n      uint32_t size;\t// sizeof (struct _objc_category)\n      struct _objc_property_list *instance_properties;  // category's own @property decl.\n-   END\n+   #endif\n    };   */\n \n static void\n@@ -515,28 +523,30 @@ build_v1_category_template (void)\n  \n       /* struct _objc_property_list *instance_properties;\n          This field describes a category's @property declarations.\n-         Properties from inherited protocols are not included. */\n+         Properties from inherited protocols are not included.  */\n       ptype = build_pointer_type (xref_tag (RECORD_TYPE, \n \t\t\t\t\t    get_identifier (UTAG_PROPERTY_LIST)));\n       add_field_decl (ptype, \"instance_properties\", &chain);\n     }\n   objc_finish_struct (objc_category_template, decls);\n }\n \n-/* Begin code generation for protocols... \n+/* Begin code generation for protocols...\n    Modified for ObjC #1 extensions.  */\n \n-/* struct _objc_protocol {\n-   IF ABI=1\n+/* struct _objc_protocol\n+   {\n+   #if ABI=1\n      struct _objc_protocol_extension *isa;\n-   ElSE\n+   #else\n      struct _objc_class *isa;\n- \n+   #endif \n+\n      char *protocol_name;\n      struct _objc_protocol **protocol_list;\n      struct _objc__method_prototype_list *instance_methods;\n      struct _objc__method_prototype_list *class_methods;\n-   };  */\n+   }; */\n \n static void\n build_v1_protocol_template (void)\n@@ -550,7 +560,7 @@ build_v1_protocol_template (void)\n     ptype = build_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t\t\t  get_identifier (UTAG_PROTOCOL_EXT)));\n   else\n-    /* struct _objc_class *isa;  */\n+    /* struct _objc_class *isa; */\n     ptype = build_pointer_type (xref_tag (RECORD_TYPE,\n \t\t\t\t\tget_identifier (UTAG_CLASS)));\n \n@@ -969,7 +979,7 @@ next_runtime_abi_01_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED,\n /* assemble_external (super_class);*/\n   super_name = my_build_string_pointer (IDENTIFIER_LENGTH (super_name) + 1,\n \t\t\t\t\tIDENTIFIER_POINTER (super_name));\n-  /* super_class = objc_get{Meta}Class(\"CLASS_SUPER_NAME\");  */\n+  /* super_class = objc_get{Meta}Class(\"CLASS_SUPER_NAME\"); */\n   return build_function_call (input_location,\n \t\t\t      super_class,\n \t\t\t      build_tree_list (NULL_TREE, super_name));\n@@ -1727,7 +1737,7 @@ build_v1_category_initializer (tree type, tree cat_name, tree class_name,\n   return objc_build_constructor (type, v);\n }\n \n-/* static struct objc_category _OBJC_CATEGORY_<name> = { ... };  */\n+/* static struct objc_category _OBJC_CATEGORY_<name> = { ... }; */\n /* TODO: get rid of passing stuff around in globals.  */\n static void\n generate_v1_category (struct imp_entry *impent)\n@@ -1789,8 +1799,7 @@ generate_v1_category (struct imp_entry *impent)\n   impent->class_decl = cat_decl;\n }\n \n-/* This routine builds the class extension used by v1 NeXT.\n-*/\n+/* This routine builds the class extension used by v1 NeXT.  */\n \n static tree\n generate_objc_class_ext (tree property_list, tree context)\n@@ -1861,7 +1870,7 @@ generate_objc_class_ext (tree property_list, tree context)\n      void *sel_id;\n      void *gc_object_type;\n   #endif\n-   };  */\n+   }; */\n \n static tree\n build_v1_shared_structure_initializer (tree type, tree isa, tree super,\n@@ -1984,7 +1993,7 @@ generate_ivars_list (tree chain, const char *name, tree attr)\n }\n \n /* static struct objc_class _OBJC_METACLASS_Foo={ ... };\n-   static struct objc_class _OBJC_CLASS_Foo={ ... };  */\n+   static struct objc_class _OBJC_CLASS_Foo={ ... }; */\n \n static void\n generate_v1_class_structs (struct imp_entry *impent)\n@@ -2357,6 +2366,9 @@ objc_generate_v1_next_metadata (void)\n   tree chain, attr;\n   long vers;\n \n+  /* FIXME: Make sure that we generate no metadata if there is nothing\n+     to put into it.  */\n+\n   if (objc_static_instances)\n     gcc_unreachable (); /* Not for NeXT */\n \n@@ -2590,7 +2602,7 @@ next_sjlj_build_enter_and_setjmp (struct objc_try_context **ctcp)\n \n /* Build:\n \n-   DECL = objc_exception_extract(&_stack);  */\n+   DECL = objc_exception_extract(&_stack); */\n \n static tree\n next_sjlj_build_exc_extract (struct objc_try_context **ctcp, tree decl)"}, {"sha": "3de0d05bf70d37c30b1b4cf84b2419d6d146eec9", "filename": "gcc/objc/objc-next-runtime-abi-02.c", "status": "modified", "additions": 269, "deletions": 235, "changes": 504, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c2beaa0254cdfa9c4da5b9bc4177b07c893e207b/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c2beaa0254cdfa9c4da5b9bc4177b07c893e207b/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-next-runtime-abi-02.c?ref=c2beaa0254cdfa9c4da5b9bc4177b07c893e207b", "patch": "@@ -352,7 +352,8 @@ static void next_runtime_02_initialize (void)\n {\n   tree type;\n #ifdef OBJCPLUS\n-  /* For all objc ABIs -fobjc-call-cxx-cdtors is on by default. */\n+  /* For all NeXT objc ABIs -fobjc-call-cxx-cdtors is on by\n+     default.  */\n   if (!global_options_set.x_flag_objc_call_cxx_cdtors)\n     global_options.x_flag_objc_call_cxx_cdtors = 1;\n #endif\n@@ -460,7 +461,8 @@ static void next_runtime_02_initialize (void)\n \t\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n \t\t\t\t\t\t   NULL, NULL_TREE);\n \n-  /* This is the type of all of the following functions objc_copyStruct().  */\n+  /* This is the type of all of the following functions\n+     objc_copyStruct().  */\n   type = build_function_type_list (void_type_node,\n \t\t\t\t   ptr_type_node,\n \t\t\t\t   const_ptr_type_node,\n@@ -471,7 +473,7 @@ static void next_runtime_02_initialize (void)\n   /* Declare the following function:\n \t void\n          objc_copyStruct (void *destination, const void *source, \n-\t                  ptrdiff_t size, BOOL is_atomic, BOOL has_strong);  */\n+\t                  ptrdiff_t size, BOOL is_atomic, BOOL has_strong); */\n   objc_copyStruct_decl = add_builtin_function (\"objc_copyStruct\",\n \t\t\t\t\t\t   type, 0, NOT_BUILT_IN,\n \t\t\t\t\t\t   NULL, NULL_TREE);\n@@ -481,11 +483,12 @@ static void next_runtime_02_initialize (void)\n \n   gcc_assert (!flag_objc_sjlj_exceptions);\n \n-  /* Although we warn that fobjc-exceptions is required for exceptions \n-     code, we carry on an create it anyway.  */\n+  /* Although we warn that fobjc-exceptions is required for exceptions\n+     code, we carry on and create it anyway.  */\n \n   /* This can be required, even when exceptions code is not present,\n-     when an __attribute__((objc_exception)) is applied to a class.  */\n+     when an __attribute__((objc_exception)) is applied to a\n+     class.  */\n   build_v2_ehtype_template ();\n \n   /* void * objc_begin_catch (void *) */\n@@ -519,19 +522,21 @@ static void next_runtime_02_initialize (void)\n \n /* NOTE --- templates --- */\n \n-/* Set 'objc_v2_message_ref_template' to the data type node for 'struct _message_ref_t'.\n-   This needs to be done just once per compilation.  Also Set \n-   'objc_v2_super_message_ref_template' to data type node \n-   for 'struct _super_message_ref_t'. */ \n+/* Set 'objc_v2_message_ref_template' to the data type node for\n+   'struct _message_ref_t'.  This needs to be done just once per\n+   compilation.  Also Set 'objc_v2_super_message_ref_template' to data\n+   type node for 'struct _super_message_ref_t'.  */\n \n-/* struct _message_ref_t {\n+/* struct _message_ref_t\n+   {\n      IMP messenger;\n      SEL name;\n    };\n    where IMP is: id (*) (id, _message_ref_t*, ...)\n */\n \n-/* struct _super_message_ref_t {\n+/* struct _super_message_ref_t\n+   {\n      SUPER_IMP messenger;\n      SEL name;\n    };\n@@ -598,7 +603,8 @@ build_v2_message_ref_templates (void)\n \n /* Build following types which represent each class implementation.\n \n-struct class_ro_t {\n+struct class_ro_t\n+{\n     uint32_t const flags;\n     uint32_t const instanceStart;\n     uint32_t const instanceSize;\n@@ -614,7 +620,8 @@ struct class_ro_t {\n     const struct _prop_list_t * const properties;\n };\n \n-struct class_t {\n+struct class_t\n+{\n     struct class_t *isa;\n     struct class_t *superclass;\n     void *cache;\n@@ -640,40 +647,40 @@ build_v2_class_templates (void)\n   /* uint32_t const flags; */\n   decls = add_field_decl (integer_type_node, \"flags\", &chain);\n \n-  /* uint32_t const instanceStart */\n+  /* uint32_t const instanceStart; */\n   add_field_decl (integer_type_node, \"instanceStart\", &chain);\n \n-  /* uint32_t const instanceSize */\n+  /* uint32_t const instanceSize; */\n   add_field_decl (integer_type_node, \"instanceSize\", &chain);\n \n-  /* This ABI is currently only used on m64 NeXT, we choose to\n-     make the alignment padding explicit.  */\n-  /* uint32_t const reserved. */\n+  /* This ABI is currently only used on m64 NeXT.  We always\n+     explicitly declare the alignment padding.  */\n+  /* uint32_t const reserved; */\n   add_field_decl (integer_type_node, \"reserved\", &chain);\n \n-  /* const uint8_t * const ivarLayout */\n+  /* const uint8_t * const ivarLayout; */\n   cnst_strg_type = build_pointer_type (unsigned_char_type_node);\n   add_field_decl (cnst_strg_type, \"ivarLayout\", &chain);\n \n   /* const char *const name; */\n   add_field_decl (string_type_node, \"name\", &chain);\n \n-  /* const struct method_list_t * const baseMethods */\n+  /* const struct method_list_t * const baseMethods; */\n   add_field_decl (objc_method_list_ptr, \"baseMethods\", &chain);\n \n-  /* const struct objc_protocol_list *const baseProtocols */\n+  /* const struct objc_protocol_list *const baseProtocols; */\n   add_field_decl (build_pointer_type \n \t\t\t(xref_tag (RECORD_TYPE, \n \t\t\t\t   get_identifier (UTAG_V2_PROTOCOL_LIST))),\n \t\t\t\t  \"baseProtocols\", &chain);\n \n-  /* const struct ivar_list_t *const ivars */\n+  /* const struct ivar_list_t *const ivars; */\n   add_field_decl (objc_v2_ivar_list_ptr, \"ivars\", &chain);  \n \n   /* const uint8_t * const weakIvarLayout; */\n   add_field_decl (cnst_strg_type, \"weakIvarLayout\",  &chain);\n \n-  /* struct _prop_list_t * baseProperties */\n+  /* struct _prop_list_t * baseProperties; */\n   add_field_decl (objc_prop_list_ptr, \"baseProperties\", &chain);\n \n   objc_finish_struct (objc_v2_class_ro_template, decls);\n@@ -687,7 +694,7 @@ build_v2_class_templates (void)\n   decls = add_field_decl (build_pointer_type (objc_v2_class_template),\n \t\t\t  \"isa\", &chain);\n \n-  /* struct class_t * const superclass */\n+  /* struct class_t * const superclass; */\n   add_field_decl (build_pointer_type (objc_v2_class_template),\n \t\t\t\t      \"superclass\", &chain);\n \n@@ -703,11 +710,11 @@ build_v2_class_templates (void)\n   objc_finish_struct (objc_v2_class_template, decls);\n }\n \n-/* struct _objc_super {\n+/* struct _objc_super\n+   {\n      struct _objc_object *self;\n      Class cls;\n-   };  */\n-\n+   }; */\n void\n build_v2_super_template (void)\n {\n@@ -724,7 +731,8 @@ build_v2_super_template (void)\n   objc_finish_struct (objc_super_template, decls);\n }\n \n-/* struct protocol_t {\n+/* struct protocol_t\n+  {\n      Class isa; \n      const char * const protocol_name;\n      const struct protocol_list_t * const protocol_list;\n@@ -745,10 +753,10 @@ build_v2_protocol_template (void)\n   objc_v2_protocol_template = \n \tobjc_start_struct (get_identifier (UTAG_V2_PROTOCOL));\n \n-  /* Class isa; */ \n+  /* Class isa; */\n   decls = add_field_decl (objc_object_type, \"isa\", &chain);\n \n-  /* char *protocol_name; */ \n+  /* char *protocol_name; */\n   add_field_decl (string_type_node, \"protocol_name\", &chain);\n \n   /* const struct protocol_list_t * const protocol_list; */\n@@ -761,26 +769,27 @@ build_v2_protocol_template (void)\n   /* const struct method_list_t * const class_methods; */\n   add_field_decl (objc_method_proto_list_ptr, \"class_methods\", &chain);\n \n-  /* const struct method_list_t * optionalInstanceMethods */\n+  /* const struct method_list_t * optionalInstanceMethods; */\n   add_field_decl (objc_method_proto_list_ptr, \"optionalInstanceMethods\", &chain);\n \n-  /* const struct method_list_t * optionalClassMethods */\n+  /* const struct method_list_t * optionalClassMethods; */\n   add_field_decl (objc_method_proto_list_ptr, \"optionalClassMethods\", &chain);\n \n   /* struct _prop_list_t * properties; */\n   add_field_decl (objc_prop_list_ptr, \"properties\", &chain);\n \n-  /* const uint32_t size;  */\n+  /* const uint32_t size; */\n   add_field_decl (integer_type_node, \"size\", &chain);\n \n-  /* const uint32_t flags;  */\n+  /* const uint32_t flags; */\n   add_field_decl (integer_type_node, \"flags\", &chain);\n \n   objc_finish_struct (objc_v2_protocol_template, decls);\n }\n \n /* Build type for a category:\n-   struct category_t {\n+   struct category_t\n+   {\n      const char * const name;\n      struct class_t *const cls;\n      const struct method_list_t * const instance_methods;\n@@ -822,9 +831,8 @@ build_v2_category_template (void)\n \n /* NOTE --- Decls, Identifiers, Names etc. --- */\n \n-/* This routine is given a name and returns a matching extern variable if \n-   one is found. \n-*/\n+/* This routine is given a name and returns a matching extern variable\n+   if one is found.  */\n \n static tree\n hash_name_lookup (hash *hashlist, tree name)\n@@ -843,9 +851,9 @@ hash_name_lookup (hash *hashlist, tree name)\n   return 0;\n }\n \n-/* This routine is given an extern variable and enters it in its hash table.\n-   Note that hashing is done on its inner IDENTIFIER_NODE node.\n-*/\n+/* This routine is given an extern variable and enters it in its hash\n+   table.  Note that hashing is done on its inner IDENTIFIER_NODE\n+   node.  */\n \n static void \n hash_name_enter (hash *hashlist, tree id)\n@@ -902,8 +910,8 @@ create_global_decl (tree type, const char *name)\n   return var;\n }\n \n-/* Create a symbol with __attribute__ ((visibility (\"hidden\"))) \n-   attribute (private extern) */\n+/* Create a symbol with __attribute__ ((visibility (\"hidden\")))\n+   attribute (private extern).  */\n \n static tree \n create_hidden_decl (tree type, const char *name)\n@@ -915,10 +923,14 @@ create_hidden_decl (tree type, const char *name)\n }\n \n /* Irritatingly, we have a different superclass field name for ABI=2.  */\n+/* PS/TODO: The field name does not matter, it is only used internally\n+   by the compiler.  We can rename it to whatever we want. ;-) */\n \n static tree\n next_runtime_abi_02_super_superclassfield_id (void)\n {\n+  /* TODO: Simplify.  Just always return get_identifier (\"cls\"), or at\n+     most look it once at startup then always return it.  */\n   if (!super_superclassfield_id)\n     super_superclassfield_id = get_identifier (\"cls\");\n   return super_superclassfield_id;\n@@ -1011,8 +1023,8 @@ typedef struct GTY(()) ident_data_tuple {\n DEF_VEC_O(ident_data_tuple);\n DEF_VEC_ALLOC_O(ident_data_tuple, gc);\n \n-/* This routine creates a file scope static variable of type 'Class' to hold\n-   the address of a class. */\n+/* This routine creates a file scope static variable of type 'Class'\n+   to hold the address of a class.  */\n \n static tree\n build_v2_class_reference_decl (tree ident)\n@@ -1027,9 +1039,9 @@ build_v2_class_reference_decl (tree ident)\n }\n \n /* This routine builds a class refs entry for each class name used.\n-   Initially, a (static-ref, IDENT) tuple is added to the list.\n-   The ident is replaced with address of  the class metadata (of type 'Class')\n-   in the output routine.  */\n+   Initially, a (static-ref, IDENT) tuple is added to the list.  The\n+   ident is replaced with address of the class metadata (of type\n+   'Class') in the output routine.  */\n \n static GTY (()) VEC (ident_data_tuple, gc) * classrefs;\n \n@@ -1055,6 +1067,7 @@ objc_v2_get_class_reference (tree ident)\n   else\n     /* Somewhat arbitrary initial provision.  */\n     classrefs = VEC_alloc (ident_data_tuple, gc, 16);\n+\n   /* We come here if we don't find the entry - or if the table was yet\n      to be created.  */\n   decl = build_v2_class_reference_decl (ident);\n@@ -1074,7 +1087,7 @@ next_runtime_abi_02_get_class_reference (tree ident)\n       /* We fall back to using objc_getClass ().  */\n       VEC(tree,gc) *vec =  VEC_alloc (tree, gc, 1);\n       tree t;\n-      /* ??? add_class_reference (ident); - is pointless, since the \n+      /* ??? add_class_reference (ident); - is pointless, since the\n          system lib does not export the equivalent symbols.  Maybe we\n          need to build a class ref anyway.  */\n       t = my_build_string_pointer (IDENTIFIER_LENGTH (ident) + 1,\n@@ -1087,11 +1100,12 @@ next_runtime_abi_02_get_class_reference (tree ident)\n     }\n }\n \n-/* Used by get_arg_type_list.  \n-   Return the types for receiver & _cmd at the start of a method argument list.\n-   context is either METHOD_DEF or METHOD_REF, saying whether we are trying\n-   to define a method or call one.  superflag says this is for a send to super.\n-   meth may be NULL, in the case that there is no prototype.  */\n+/* Used by get_arg_type_list.\n+   Return the types for receiver & _cmd at the start of a method\n+   argument list.  context is either METHOD_DEF or METHOD_REF, saying\n+   whether we are trying to define a method or call one.  superflag\n+   says this is for a send to super.  meth may be NULL, in the case\n+   that there is no prototype.  */\n \n static tree\n next_runtime_abi_02_get_arg_type_list_base (tree meth, int context, int superflag)\n@@ -1156,8 +1170,8 @@ next_runtime_abi_02_build_selector_reference (location_t loc ATTRIBUTE_UNUSED,\n }\n \n /* Declare a variable of type 'struct message_ref_t'. */\n-/* This will be finished in build_v2_message_ref_translation_table (). \n-   We take an idea from LLVM in making the names a bit more connected \n+/* This will be finished in build_v2_message_ref_translation_table ().\n+   We take an idea from LLVM in making the names a bit more connected\n    and thus the asm more readable.  */\n \n static tree\n@@ -1167,7 +1181,7 @@ build_v2_message_reference_decl (tree sel_name, tree message_func_ident)\n   char buf[BUFSIZE], *t;\n   int offset = 12;\n \n-  /* Skip past the objc_msgSend it's the same for all... */\n+  /* Skip past the objc_msgSend it's the same for all...  */\n   if (IDENTIFIER_POINTER (message_func_ident)[offset] == '_')\n     offset++;\n \n@@ -1196,8 +1210,9 @@ DEF_VEC_ALLOC_O(msgref_entry, gc);\n \n static GTY (()) VEC (msgref_entry, gc) * msgrefs;\n \n-/* Build the list of (objc_msgSend_fixup_xxx, selector name) Used later on to\n-   initialize the table of 'struct message_ref_t' elements. */\n+/* Build the list of (objc_msgSend_fixup_xxx, selector name), used\n+   later on to initialize the table of 'struct message_ref_t'\n+   elements.  */\n \n static tree\n build_v2_selector_messenger_reference (tree sel_name, tree message_func_decl)\n@@ -1215,6 +1230,7 @@ build_v2_selector_messenger_reference (tree sel_name, tree message_func_decl)\n   else\n     /* Somewhat arbitrary initial provision.  */\n     msgrefs = VEC_alloc (msgref_entry, gc, 32);\n+\n   /* We come here if we don't find a match or at the start.  */\n   decl = build_v2_message_reference_decl (sel_name, \n \t\t\t\t\t  DECL_NAME (message_func_decl));\n@@ -1272,6 +1288,7 @@ objc_v2_get_protocol_reference (tree ident)\n   else\n     /* Somewhat arbitrary initial provision.  */\n     protrefs = VEC_alloc (prot_list_entry, gc, 32);\n+\n   /* We come here if we don't find the entry - or if the table was yet\n      to be created.  */\n   decl = build_v2_protocollist_ref_decl (ident);\n@@ -1291,9 +1308,9 @@ next_runtime_abi_02_get_protocol_reference (location_t loc ATTRIBUTE_UNUSED,\n   return objc_v2_get_protocol_reference (p);\n }\n \n-/* This routine returns the ivar declaration, if component is a valid ivar field; \n-   NULL_TREE otherwise. On finding an ivar, it also returns the class name in CLASS.\n-*/\n+/* This routine returns the ivar declaration, if component is a valid\n+   ivar field; NULL_TREE otherwise. On finding an ivar, it also\n+   returns the class name in CLASS.  */\n \n static tree\n objc_is_ivar (tree expr, tree component, tree *klass)\n@@ -1334,11 +1351,10 @@ create_ivar_offset_name (char *buf, tree class_name, tree field_decl)\n   return;\n }\n \n-/* This routine generates new abi's ivar reference tree. It amounts to generating\n-   *(TYPE*)((char*)pObj + OFFSET_IVAR) when we normally generate pObj->IVAR\n-   OFFSET_IVAR is an 'extern' variable holding the offset for 'IVAR' field. TYPE\n-   is type of IVAR field.\n-*/\n+/* This routine generates new abi's ivar reference tree.  It amounts\n+   to generating *(TYPE*)((char*)pObj + OFFSET_IVAR) when we normally\n+   generate pObj->IVAR.  OFFSET_IVAR is an 'extern' variable holding\n+   the offset for 'IVAR' field.  TYPE is type of IVAR field.  */\n \n static tree\n objc_v2_build_ivar_ref (tree datum, tree component)\n@@ -1351,10 +1367,11 @@ objc_v2_build_ivar_ref (tree datum, tree component)\n     return NULL_TREE;\n \n   /* This routine only handles non-bitfield fields */\n-  /* DECL_INITIAL macro is set to width of bitfield and can be relied on to\n-     check for bitfield ivars. Note that I cannot rely on DECL_BIT_FIELD macro\n-     because it is only set when the whole struct is seen (at finish_struct) \n-     and not when the ivar chain is built. */\n+  /* DECL_INITIAL macro is set to width of bitfield and can be relied\n+     on to check for bitfield ivars.  Note that I cannot rely on\n+     DECL_BIT_FIELD macro because it is only set when the whole struct\n+     is seen (at finish_struct) and not when the ivar chain is\n+     built.  */\n   if (DECL_INITIAL (field))\n     return NULL_TREE;\n \n@@ -1378,10 +1395,10 @@ objc_v2_build_ivar_ref (tree datum, tree component)\n   /* Finally: *(ftype*)((char*)datum + offset) */\n   ref = build_indirect_ref (input_location, expr, RO_UNARY_STAR);\n \n-  /* We must set type of the resulting expression to be the same as the\n-     field type. This is because, build_indirect_ref (...) rebuilds the\n-     type which may result in lost information; as in the case of \n-     protocol-qualified types (id <protocol> ). */\n+  /* We must set type of the resulting expression to be the same as\n+     the field type. This is because, build_indirect_ref (...)\n+     rebuilds the type which may result in lost information; as in the\n+     case of protocol-qualified types (id <protocol> ).  */\n   TREE_TYPE (ref) = ftype;\n \n   if (TREE_READONLY (datum) || TREE_READONLY (field))\n@@ -1409,9 +1426,8 @@ next_runtime_abi_02_build_ivar_ref (location_t loc ATTRIBUTE_UNUSED,\n   return objc_build_component_ref (base, id);\n }\n \n-/* [super ...] references are listed here (and built into a table at meta\n-   -data emit time). */\n-\n+/* [super ...] references are listed here (and built into a table at\n+   meta -data emit time).  */\n static tree\n build_v2_superclass_ref_decl (tree ident, bool inst)\n {\n@@ -1473,7 +1489,7 @@ static tree\n next_runtime_abi_02_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED, \n \t\t\t\t\t   struct imp_entry *imp, bool inst_meth)\n {\n-  /* ??? is this OK when zero-link = true? */\n+  /* ??? is this OK when zero-link = true?  */\n   tree super_name = CLASS_SUPER_NAME (imp->imp_template);\n   tree super_class;\n \n@@ -1484,9 +1500,9 @@ next_runtime_abi_02_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED,\n       if (!inst_meth)\n \t\n \t/* If we are in a class method, we must retrieve the\n-\t   _metaclass_ for the current class, pointed at by\n-\t   the class's \"isa\" pointer.  The following assumes that\n-\t   \"isa\" is the first ivar in a class (which it must be).  */\n+\t   _metaclass_ for the current class, pointed at by the\n+\t   class's \"isa\" pointer.  The following assumes that \"isa\" is\n+\t   the first ivar in a class (which it must be).  */\n \t   super_class = \n \t\tbuild_indirect_ref (input_location,\n \t\t\t\t    build_c_cast (input_location,\n@@ -1498,10 +1514,10 @@ next_runtime_abi_02_get_category_super_ref (location_t loc ATTRIBUTE_UNUSED,\n   /* ??? Do we need to add the class ref anway for zero-link?  */\n   /* else do it the slow way.  */\n   super_class = (inst_meth ? objc_get_class_decl : objc_get_meta_class_decl);\n-/* assemble_external (super_class);*/\n+  /* assemble_external (super_class); */\n   super_name = my_build_string_pointer (IDENTIFIER_LENGTH (super_name) + 1,\n \t\t\t\t\tIDENTIFIER_POINTER (super_name));\n-  /* super_class = objc_get{Meta}Class(\"CLASS_SUPER_NAME\");  */\n+  /* super_class = objc_get{Meta}Class(\"CLASS_SUPER_NAME\"); */\n   return build_function_call (input_location,\n \t\t\t      super_class,\n \t\t\t      build_tree_list (NULL_TREE, super_name));\n@@ -1525,15 +1541,15 @@ next_runtime_abi_02_receiver_is_class_object (tree receiver)\n   return NULL_TREE;\n }\n \n-/* Assign all arguments in VALUES which have side-effect to a temporary and\n-   replaced that argument in VALUES list with the temporary. TYPELIST is the\n-   list of argument types. */\n+/* Assign all arguments in VALUES which have side-effect to a\n+   temporary and replaced that argument in VALUES list with the\n+   temporary. TYPELIST is the list of argument types. */\n \n static tree\n objc_copy_to_temp_side_effect_params (tree typelist, tree values)\n {\n   tree valtail, typetail;\n-  /* skip over receiver and the &_msf_ref types */\n+  /* Skip over receiver and the &_msf_ref types.  */\n   gcc_assert (TREE_CHAIN (typelist));\n   typetail = TREE_CHAIN (TREE_CHAIN (typelist));\n \n@@ -1546,7 +1562,7 @@ objc_copy_to_temp_side_effect_params (tree typelist, tree values)\n \tbreak; \n       if (!TREE_SIDE_EFFECTS (value))\n \tcontinue;\n-      /* To prevent re-evaluation */\n+      /* To prevent re-evaluation.  */\n       value = save_expr (value);\n       add_stmt (value);\n       TREE_VALUE (valtail) = value;\n@@ -1555,8 +1571,7 @@ objc_copy_to_temp_side_effect_params (tree typelist, tree values)\n }\n \n /* Build the new abi's messaging library call. It looks like:\n-   (*_msg.messenger) (receiver, &_msg, ...)\n-*/\n+   (*_msg.messenger) (receiver, &_msg, ...) */\n \n static tree\n build_v2_build_objc_method_call (int super_flag, tree method_prototype,\n@@ -1586,7 +1601,7 @@ build_v2_build_objc_method_call (int super_flag, tree method_prototype,\n     method_params = objc_copy_to_temp_side_effect_params (method_param_types, \n \t\t\t\t\t\t\t  method_params);\n \n-  /* Get &message_ref_t.messenger */\n+  /* Get &message_ref_t.messenger.  */\n   sender = build_c_cast (input_location, \n \t\t\t build_pointer_type (super_flag\n \t\t\t\t\t     ? objc_v2_super_imp_type\n@@ -1617,7 +1632,8 @@ build_v2_build_objc_method_call (int super_flag, tree method_prototype,\n \t  || TREE_CODE (ret_type) == UNION_TYPE)\n \t{\n \t  VEC(constructor_elt,gc) *rtt = NULL;\n-\t  /* ??? CHECKME. hmmm..... think we need something more here.  */\n+\t  /* ??? CHECKME. hmmm..... think we need something more\n+\t     here.  */\n \t  CONSTRUCTOR_APPEND_ELT (rtt, NULL_TREE, NULL_TREE);\n \t  ftree = objc_build_constructor (ret_type, rtt);\n \t}\n@@ -1659,8 +1675,9 @@ next_runtime_abi_02_build_objc_method_call (location_t loc,\n \t\t    objc_object_type);\n \n   /* Do we need to check for nil receivers ? */\n-  /* For now, message sent to classes need no nil check. In future, class\n-      declaration marked as weak_import must be nil checked. */\n+  /* For now, message sent to classes need no nil check.  In the\n+      future, class declaration marked as weak_import must be nil\n+      checked.  */\n   if (super \n       || (TREE_CODE (receiver) == VAR_DECL \n \t  && TREE_TYPE (receiver) == objc_class_type))\n@@ -1719,10 +1736,10 @@ next_runtime_abi_02_setup_const_string_class_decl (void)\n \n   string_class_decl = lookup_name (constant_string_global_id);\n \n-  /* In OBJC2 abi constant string class reference refers to \n-     class name for NSConstantString class. This declaration may not be\n-     available yet (in fact it is not in most cases). So, declare an extern \n-     OBJC_CLASS_$_NSConstantString in its place. */\n+  /* In OBJC2 abi, constant string class reference refers to class\n+     name for NSConstantString class.  This declaration may not be\n+     available yet (in fact it is not in most cases).  So, declare an\n+     extern OBJC_CLASS_$_NSConstantString in its place. */\n   if (!string_class_decl)\n     string_class_decl = \n \tcreate_extern_decl (objc_v2_class_template,\n@@ -1738,7 +1755,7 @@ next_runtime_abi_02_build_const_string_constructor (location_t loc, tree string,\n   tree constructor, fields, var;\n   VEC(constructor_elt,gc) *v = NULL;\n \n-  /* NeXT:   (NSConstantString *) & ((__builtin_ObjCString) { isa, string, length })   */\n+  /* NeXT: (NSConstantString *) & ((__builtin_ObjCString) { isa, string, length }) */\n   fields = TYPE_FIELDS (internal_const_str_type);\n   CONSTRUCTOR_APPEND_ELT (v, fields,\n \t\t\t  build_unary_op (loc, ADDR_EXPR, string_class_decl, 0));\n@@ -1763,7 +1780,8 @@ next_runtime_abi_02_build_const_string_constructor (location_t loc, tree string,\n /* NOTE --- NeXT V2 Metadata templates --- */\n \n /* This routine builds the following type:\n-   struct _prop_t {\n+   struct _prop_t\n+   {\n      const char * const name;\t\t\t// property name\n      const char * const attributes;\t\t// comma-delimited, encoded, \n \t\t\t\t\t\t// property attributes\n@@ -1787,7 +1805,8 @@ build_v2_property_template (void)\n   return prop_record;\n }\n \n-/* struct ivar_t {\n+/* struct ivar_t\n+   {\n      unsigned long int *offset;\n      char *name;\n      char *type;\n@@ -1805,7 +1824,7 @@ build_v2_ivar_t_template (void)\n   objc_ivar_id = get_identifier (\"_ivar_t\");\n   objc_ivar_record = objc_start_struct (objc_ivar_id);\n \n-  /* unsigned long int *offset */\n+  /* unsigned long int *offset; */\n   decls = add_field_decl (build_pointer_type \n \t\t\t   (TREE_TYPE (size_zero_node)), \"offset\", &chain);\n \n@@ -1874,8 +1893,7 @@ newabi_append_ro (const char *name)\n \n /* Build the struct message_ref_t msg = \n \t       {objc_msgSend_fixup_xxx, @selector(func)} \n-   table. \n-*/\n+   table.  */\n \n static \n void build_v2_message_ref_translation_table (void)\n@@ -1894,20 +1912,21 @@ void build_v2_message_ref_translation_table (void)\n       location_t loc = DECL_SOURCE_LOCATION (ref->refdecl);\n \n       initializer = NULL;\n-      /* First 'IMP messenger' field..  */\n+      /* First 'IMP messenger' field...  */\n       expr = build_unary_op (loc, ADDR_EXPR, ref->func, 0);\n       expr = convert (objc_v2_imp_type, expr);\n       CONSTRUCTOR_APPEND_ELT (initializer, NULL_TREE, expr);\n \n-      /* then..  'SEL name' field */\n+      /* ... then 'SEL name' field.  */\n       expr = build_selector (ref->selname);\n       CONSTRUCTOR_APPEND_ELT (initializer, NULL_TREE, expr);\n       constructor = objc_build_constructor (struct_type, initializer);\n       finish_var_decl (ref->refdecl, constructor); \n     }\n }\n \n-/* Build decl = initializer; for each externally visible class reference. */\n+/* Build decl = initializer; for each externally visible class\n+   reference.  */\n \n static void\n build_v2_classrefs_table (void)\n@@ -1922,8 +1941,9 @@ build_v2_classrefs_table (void)\n     {\n       tree expr = ref->ident;\n       tree decl = ref->data;\n-      /* Interface with no implementation and yet one of its messages has been\n-\t used. Need to generate a full address-of tree for it here. */\n+      /* Interface with no implementation and yet one of its messages\n+\t has been used. Need to generate a full address-of tree for it\n+\t here.  */\n       if (TREE_CODE (expr) == IDENTIFIER_NODE)\n         {\n           const char *name = objc_build_internal_classname (expr, false);\n@@ -1937,7 +1957,8 @@ build_v2_classrefs_table (void)\n     }\n }\n \n-/* Build decl = initializer; for each externally visible class reference. */\n+/* Build decl = initializer; for each externally visible super class\n+   reference.  */\n \n static void\n build_v2_super_classrefs_table (bool metaclass)\n@@ -1954,8 +1975,9 @@ build_v2_super_classrefs_table (bool metaclass)\n     {\n       tree expr = ref->ident;\n       tree decl = ref->data;\n-      /* Interface with no implementation and yet one of its messages has been\n-\t used. Need to generate a full address-of tree for it here. */\n+      /* Interface with no implementation and yet one of its messages\n+\t has been used. Need to generate a full address-of tree for it\n+\t here.  */\n       if (TREE_CODE (expr) == IDENTIFIER_NODE)\n \t{\n \t  const char * name = objc_build_internal_classname (expr, metaclass);\n@@ -1966,8 +1988,8 @@ build_v2_super_classrefs_table (bool metaclass)\n     }\n }\n \n-/* Add the global class meta-data declaration to the list which later on\n-   ends up in the __class_list section. */\n+/* Add the global class meta-data declaration to the list which later\n+   on ends up in the __class_list section.  */\n \n static GTY(()) VEC(tree,gc) *class_list;\n \n@@ -1981,8 +2003,8 @@ objc_v2_add_to_class_list (tree global_class_decl)\n \n static GTY(()) VEC(tree,gc) *nonlazy_class_list;\n \n-/* Add the global class meta-data declaration to the list which later on\n-   ends up in the __nonlazy_class section. */\n+/* Add the global class meta-data declaration to the list which later\n+   on ends up in the __nonlazy_class section.  */\n \n static void \n objc_v2_add_to_nonlazy_class_list (tree global_class_decl)\n@@ -1994,8 +2016,8 @@ objc_v2_add_to_nonlazy_class_list (tree global_class_decl)\n \n static GTY(()) VEC(tree,gc) *category_list;\n \n-/* Add the category meta-data declaration to the list which later on ends up \n-   in the __nonlazy_category section. */\n+/* Add the category meta-data declaration to the list which later on\n+   ends up in the __nonlazy_category section.  */\n \n static void \n objc_v2_add_to_category_list (tree decl)\n@@ -2007,8 +2029,8 @@ objc_v2_add_to_category_list (tree decl)\n \n static GTY(()) VEC(tree,gc) *nonlazy_category_list;\n \n-/* Add the category meta-data declaration to the list which later on ends up \n-   in the __category_list section. */\n+/* Add the category meta-data declaration to the list which later on\n+   ends up in the __category_list section.  */\n \n static void \n objc_v2_add_to_nonlazy_category_list (tree decl)\n@@ -2033,8 +2055,8 @@ has_load_impl (tree clsmeth)\n   return false;\n }\n \n-/* Build a __{class,category}_list section table containing address of all\n-   @implemented {class,category} meta-data. */\n+/* Build a __{class,category}_list section table containing address of\n+   all @implemented {class,category} meta-data.  */\n \n static void\n build_v2_address_table (VEC(tree,gc) *src, const char *nam, tree attr)\n@@ -2060,17 +2082,17 @@ build_v2_address_table (VEC(tree,gc) *src, const char *nam, tree attr)\n   type = build_array_type (objc_class_type, \n \t\t\t   build_index_type (build_int_cst (NULL_TREE, count - 1)));\n   decl = start_var_decl (type, nam);\n-  /* The runtime wants this, even if it appears unused, so we must force the\n-     output.  */\n+  /* The runtime wants this, even if it appears unused, so we must\n+     force the output.  */\n   DECL_PRESERVE_P (decl) = 1;\n   expr = objc_build_constructor (type, initlist);\n   OBJCMETA (decl, objc_meta, attr);\n   finish_var_decl (decl, expr);\n }\n \n-/* Build decl = initializer; \n-   for each protocol referenced in @protocol(MyProt) expression. \n-   Refs as built in the entry section above.  */\n+/* Build decl = initializer; for each protocol referenced in\n+   @protocol(MyProt) expression.  Refs as built in the entry section\n+   above.  */\n \n static void\n build_v2_protocol_list_translation_table (void)\n@@ -2097,8 +2119,8 @@ build_v2_protocol_list_translation_table (void)\n \n static GTY (()) VEC (prot_list_entry, gc) * protlist;\n \n-/* Add the local protocol meta-data declaration to the list which later on ends up \n-   in the __protocol_list section. */\n+/* Add the local protocol meta-data declaration to the list which\n+   later on ends up in the __protocol_list section.  */\n \n static void\n objc_add_to_protocol_list (tree protocol_interface_decl, tree protocol_decl)\n@@ -2112,8 +2134,8 @@ objc_add_to_protocol_list (tree protocol_interface_decl, tree protocol_decl)\n   VEC_safe_push (prot_list_entry, gc, protlist, &e);\n }\n \n-/* Build the __protocol_list section table containing address of all generate protocol_t \n-   meta-data. */\n+/* Build the __protocol_list section table containing address of all\n+   generate protocol_t meta-data.  */\n \n static void\n build_v2_protocol_list_address_table (void)\n@@ -2140,8 +2162,8 @@ build_v2_protocol_list_address_table (void)\n     /* TODO: upgrade to the the clang/llvm hidden version.  */\n }\n \n-/* This routine declares a variable to hold meta data for \n-   'struct protocol_list_t'. */\n+/* This routine declares a variable to hold meta data for 'struct\n+   protocol_list_t'.  */\n \n static tree\n generate_v2_protocol_list (tree i_or_p, tree klass_ctxt)\n@@ -2216,12 +2238,12 @@ generate_v2_protocol_list (tree i_or_p, tree klass_ctxt)\n   return refs_decl;\n }\n \n-/* This routine builds one 'struct method_t' initializer list. Note that the\n-   old ABI is supposed to build 'struct objc_method' which has 3 fields, but\n-   it does not build the initialization expression for 'method_imp' which for\n-   protocols is NULL any way.  To be consistant with declaration of \n-   'struct method_t', in the new ABI we set the method_t.imp to NULL.\n-*/\n+/* This routine builds one 'struct method_t' initializer list. Note\n+   that the old ABI is supposed to build 'struct objc_method' which\n+   has 3 fields, but it does not build the initialization expression\n+   for 'method_imp' which for protocols is NULL any way.  To be\n+   consistant with declaration of 'struct method_t', in the new ABI we\n+   set the method_t.imp to NULL.  */\n \n static tree\n build_v2_descriptor_table_initializer (tree type, tree entries)\n@@ -2246,11 +2268,12 @@ build_v2_descriptor_table_initializer (tree type, tree entries)\n   return objc_build_constructor (build_array_type (type, 0), initlist);\n }\n \n-/* struct method_list_t {\n+/* struct method_list_t\n+  {\n      uint32_t entsize;\n      uint32_t method_count;\n      struct objc_method method_list[method_count];\n-   };  */\n+   }; */\n \n static tree\n build_v2_method_list_template (tree list_type, int size)\n@@ -2260,7 +2283,7 @@ build_v2_method_list_template (tree list_type, int size)\n \n   method_list_t_record = objc_start_struct (NULL_TREE);\n  \n-  /* uint32_t const entsize */\n+  /* uint32_t const entsize; */\n   decls = add_field_decl (integer_type_node, \"entsize\", &chain);\n \n   /* int method_count; */\n@@ -2274,9 +2297,9 @@ build_v2_method_list_template (tree list_type, int size)\n   return method_list_t_record;\n }\n \n-/* Note, as above that we are building to the objc_method_template \n-   which has the *imp field.  ABI0/1 build with objc_method_prototype_template\n-   which is missing this field.  */\n+/* Note, as above that we are building to the objc_method_template\n+   which has the *imp field.  ABI0/1 build with\n+   objc_method_prototype_template which is missing this field.  */\n static tree \n generate_v2_meth_descriptor_table (tree chain, tree protocol,\n \t\t\t\t   const char *prefix, tree attr)\n@@ -2320,8 +2343,8 @@ generate_v2_meth_descriptor_table (tree chain, tree protocol,\n   return decl;\n }\n \n-/* This routine builds the initializer list to initialize the\n-   'struct _prop_t prop_list[]'  field of 'struct _prop_list_t' meta-data. */\n+/* This routine builds the initializer list to initialize the 'struct\n+   _prop_t prop_list[]' field of 'struct _prop_list_t' meta-data.  */\n \n static tree\n build_v2_property_table_initializer (tree type, tree context)\n@@ -2336,7 +2359,8 @@ build_v2_property_table_initializer (tree type, tree context)\n   for (; x; x = TREE_CHAIN (x))\n     {\n       VEC(constructor_elt,gc) *elemlist = NULL;\n-      /* NOTE! sections where property name/attribute go MUST change later. */\n+      /* NOTE! sections where property name/attribute go MUST change\n+\t later.  */\n       tree attribute, name_ident = PROPERTY_NAME (x);\n \n       CONSTRUCTOR_APPEND_ELT (elemlist, NULL_TREE, \n@@ -2354,7 +2378,8 @@ build_v2_property_table_initializer (tree type, tree context)\n }\n \n /* This routine builds the following type:\n-   struct _prop_list_t {\n+   struct _prop_list_t\n+   {\n      uint32_t entsize;\t\t\t// sizeof (struct _prop_t)\n      uint32_t prop_count;\n      struct _prop_t prop_list [prop_count];\n@@ -2370,10 +2395,10 @@ build_v2_property_list_template (tree list_type, int size)\n   /* anonymous.  */\n   property_list_t_record = objc_start_struct (NULL_TREE);\n  \n-  /* uint32_t const entsize */\n+  /* uint32_t const entsize; */\n   decls = add_field_decl (integer_type_node, \"entsize\", &chain);\n \n-  /* int prop_count */\n+  /* int prop_count; */\n   add_field_decl (integer_type_node, \"prop_count\", &chain);\n \n   /* struct _prop_t prop_list[]; */\n@@ -2384,9 +2409,8 @@ build_v2_property_list_template (tree list_type, int size)\n   return property_list_t_record;\n }\n \n-/*\n-  Top-level routine to generate property tables for each implementation.\n-*/\n+/* Top-level routine to generate property tables for each\n+   implementation.  */\n \n static tree\n generate_v2_property_table (tree context, tree klass_ctxt)\n@@ -2503,9 +2527,8 @@ build_v2_protocol_initializer (tree type, tree protocol_name, tree protocol_list\n   return objc_build_constructor (type, inits);\n }\n \n-/*\n-   Main routine to build all meta data for all protocols used in a translation unit. \n-*/\n+/* Main routine to build all meta data for all protocols used in a\n+   translation unit.  */\n \n static void\n generate_v2_protocols (void)\n@@ -2516,7 +2539,8 @@ generate_v2_protocols (void)\n   if (!protocol_chain)\n     return ;\n \n-  /* If a protocol was directly referenced, pull in indirect references.  */\n+  /* If a protocol was directly referenced, pull in indirect\n+     references.  */\n   for (p = protocol_chain; p; p = TREE_CHAIN (p))\n     if (PROTOCOL_FORWARD_DECL (p) && PROTOCOL_LIST (p))\n       generate_protocol_references (PROTOCOL_LIST (p));\n@@ -2583,10 +2607,11 @@ generate_v2_protocols (void)\n \n   if (some)\n     {\n-      /* Make sure we get the Protocol class linked in - reference it... */\n+      /* Make sure we get the Protocol class linked in - reference\n+\t it...  */\n       p = objc_v2_get_class_reference (get_identifier (PROTOCOL_OBJECT_CLASS_NAME));\n-      /* .. but since we don't specifically use the ref.. \n-         we need to force it.  */\n+      /* ... but since we don't specifically use the reference...  we\n+         need to force it.  */\n       DECL_PRESERVE_P (p) = 1;\n     }\n }\n@@ -2665,7 +2690,7 @@ build_v2_category_initializer (tree type, tree cat_name, tree class_name,\n   return objc_build_constructor (type, v);\n }\n \n-/* static struct category_t _OBJC_CATEGORY_$_<name> = { ... };  */\n+/* static struct category_t _OBJC_CATEGORY_$_<name> = { ... }; */\n \n static void\n generate_v2_category (struct imp_entry *impent)\n@@ -2702,7 +2727,7 @@ generate_v2_category (struct imp_entry *impent)\n   else\n     protocol_decl = NULL_TREE;\n \n-/*  decl = update_var_decl(impent->class_decl);*/\n+/* decl = update_var_decl(impent->class_decl); */\n \n   props = generate_v2_property_table (NULL_TREE, cat);\n \n@@ -2732,16 +2757,17 @@ generate_v2_category (struct imp_entry *impent)\n   finish_var_decl (cat_decl, initlist);\n   impent->class_decl = cat_decl;\n \n-  /* Add to list of pointers in __category_list section */\n+  /* Add to list of pointers in __category_list section.  */\n   objc_v2_add_to_category_list (cat_decl);\n   if (has_load_impl (CLASS_CLS_METHODS (impent->imp_context)))\n     objc_v2_add_to_nonlazy_category_list (cat_decl);\n }\n \n-/* This routine declares a variable to hold the offset for ivar FIELD_DECL.\n-   Variable name is .objc_ivar.ClassName.IvarName. */\n+/* This routine declares a variable to hold the offset for ivar\n+   FIELD_DECL.  Variable name is .objc_ivar.ClassName.IvarName.  */\n \n-typedef struct GTY(()) ivarref_entry {\n+typedef struct GTY(()) ivarref_entry\n+{\n   tree decl;\n   tree offset;\n } ivarref_entry;\n@@ -2789,11 +2815,10 @@ ivar_offset_ref (tree class_name, tree field_decl)\n   return decl;\n }\n \n-/* This routine builds initializer-list needed to initialize \n-   'struct ivar_t list[count]\n-   of 'struct ivar_list_t' meta data. TYPE is 'struct ivar_t' and \n-   FIELD_DECL is list of ivars for the target class.\n-*/\n+/* This routine builds initializer-list needed to initialize 'struct\n+   ivar_t list[count] of 'struct ivar_list_t' meta data. TYPE is\n+   'struct ivar_t' and FIELD_DECL is list of ivars for the target\n+   class.  */\n \n static tree\n build_v2_ivar_list_initializer (tree class_name, tree type, tree field_decl)\n@@ -2806,26 +2831,26 @@ build_v2_ivar_list_initializer (tree class_name, tree type, tree field_decl)\n       int val;\n       tree id;\n \n-      /* Unnamed bitfields are ignored. */\n+      /* Unnamed bitfields are ignored.  */\n       if (!DECL_NAME (field_decl))\n \t{\n \t  field_decl = DECL_CHAIN (field_decl);\n \t  continue;\n \t}\n \n-      /* Set offset */\n+      /* Set offset.  */\n       CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE,\n \t\t\t      build_unary_op (input_location,\n \t\t\t\t\t      ADDR_EXPR, \n \t\t\t\t\t      ivar_offset_ref (class_name, \n \t\t\t\t\t\t\t       field_decl), 0));\n \n-      /* Set name */\n+      /* Set name.  */\n       CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE,\n \t\t\t      add_objc_string (DECL_NAME (field_decl),\n \t\t\t\t\t\tmeth_var_names));\n \n-      /* Set type */\n+      /* Set type.  */\n       encode_field_decl (field_decl,\n \t\t\t obstack_object_size (&util_obstack),\n \t\t\t OBJC_ENCODE_DONT_INLINE_DEFS);\n@@ -2836,13 +2861,13 @@ build_v2_ivar_list_initializer (tree class_name, tree type, tree field_decl)\n       CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, id);\n       obstack_free (&util_obstack, util_firstobj);\n \n-      /* Set alignment */\n+      /* Set alignment.  */\n       val = DECL_ALIGN_UNIT (field_decl);\n       val = exact_log2 (val);\n       CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, \n \t\t\t      build_int_cst (integer_type_node, val));\n  \n-      /* Set size */\n+      /* Set size.  */\n       val = TREE_INT_CST_LOW (DECL_SIZE_UNIT (field_decl));\n       CONSTRUCTOR_APPEND_ELT (ivar, NULL_TREE, \n \t\t\t      build_int_cst (integer_type_node, val));\n@@ -2860,7 +2885,8 @@ build_v2_ivar_list_initializer (tree class_name, tree type, tree field_decl)\n }\n \n /*\n-  struct ivar_list_t {\n+  struct ivar_list_t\n+  {\n     uint32 entsize;\n     uint32 count;\n     struct iver_t list[count];\n@@ -2873,7 +2899,7 @@ build_v2_ivar_list_t_template (tree list_type, int size)\n   tree objc_ivar_list_record;\n   tree decls, *chain = NULL;\n \n-  /* Anonymous. */\n+  /* Anonymous.  */\n   objc_ivar_list_record = objc_start_struct (NULL_TREE);\n \n   /* uint32 entsize; */\n@@ -2890,11 +2916,10 @@ build_v2_ivar_list_t_template (tree list_type, int size)\n   return objc_ivar_list_record;\n }\n \n-/* This routine declares a static variable of type 'struct ivar_list_t' and\n-   initializes it. \n-   chain is the source of the data, name is the name for the var. \n-   attr is the meta-data section tag attribute\n-   templ is the implementation template for the class. */\n+/* This routine declares a static variable of type 'struct\n+   ivar_list_t' and initializes it.  chain is the source of the data,\n+   name is the name for the var.  attr is the meta-data section tag\n+   attribute.  templ is the implementation template for the class.  */\n \n static tree\n generate_v2_ivars_list (tree chain, const char *name, tree attr, tree templ)\n@@ -2926,7 +2951,8 @@ generate_v2_ivars_list (tree chain, const char *name, tree attr, tree templ)\n   return decl;\n }\n \n-/* Routine to build initializer list to initialize objects of type struct class_t; */\n+/* Routine to build initializer list to initialize objects of type\n+   struct class_t; */\n \n static tree\n build_v2_class_t_initializer (tree type, tree isa, tree superclass,\n@@ -2958,7 +2984,7 @@ build_v2_class_t_initializer (tree type, tree isa, tree superclass,\n   return objc_build_constructor (type, initlist);\n }\n \n-/* Routine to build object of struct class_ro_t { ... };  */\n+/* Routine to build object of struct class_ro_t { ... }; */\n \n static tree\n build_v2_class_ro_t_initializer (tree type, tree name, \n@@ -2987,9 +3013,9 @@ build_v2_class_ro_t_initializer (tree type, tree name,\n   CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE, \n \t\t\t  build_int_cst (integer_type_node, instanceSize));\n \n-  /* This ABI is currently only used on m64 NeXT, we choose to\n-     make the alignment padding explicit.  */\n-  /* reserved, pads alignment. */\n+  /* This ABI is currently only used on m64 NeXT.  We always\n+     explicitly declare the alignment padding.  */\n+  /* reserved, pads alignment.  */\n   CONSTRUCTOR_APPEND_ELT (initlist, NULL_TREE, \n \t\t\t    build_int_cst (integer_type_node, 0));\n \n@@ -3063,6 +3089,7 @@ objc_v2_add_to_ehtype_list (tree name)\n   else\n     /* Arbitrary initial count.  */\n     ehtype_list = VEC_alloc (ident_data_tuple, gc, 8);\n+\n   /* Not found, or new list.  */\n   e.ident = name;\n   e.data = NULL_TREE;\n@@ -3098,12 +3125,12 @@ generate_v2_class_structs (struct imp_entry *impent)\n   gcc_assert (!CP_DECL_CONTEXT (metaclass_decl) || CP_DECL_CONTEXT (metaclass_decl) == global_namespace);\n #endif\n \n-  /* Generation of data for meta class */\n+  /* Generation of data for meta class.  */\n   my_super_id = CLASS_SUPER_NAME (impent->imp_template);\n   if (my_super_id)\n     {\n-      /* compute reference to root's name. For meta class, \"isa\" is reference \n-\t to root class name. */\n+      /* Compute reference to root's name.  For a meta class, \"isa\" is\n+\t a reference to the root class name. */\n       tree my_root_id = my_super_id;\n       tree my_root_int, interface;\n       do\n@@ -3127,24 +3154,24 @@ generate_v2_class_structs (struct imp_entry *impent)\n       /* Install class `isa' and `super' pointers at runtime.  */\n       interface = lookup_interface (my_super_id);\n       gcc_assert (interface);\n-      /* Similarly, for OBJC_CLASS_$_<interface>... */\n+      /* Similarly, for OBJC_CLASS_$_<interface>...  */\n       snprintf (buf, BUFSIZE, \"OBJC_CLASS_$_%s\", \n \t\tIDENTIFIER_POINTER (CLASS_NAME (interface)));\n       class_superclass_expr = create_extern_decl (objc_v2_class_template, buf);\n       class_superclass_expr = build_fold_addr_expr (class_superclass_expr);\n-      /* ... and for OBJC_METACLASS_$_<interface>. */\n+      /* ... and for OBJC_METACLASS_$_<interface>.  */\n       snprintf (buf, BUFSIZE, \"OBJC_METACLASS_$_%s\", \n \t\tIDENTIFIER_POINTER (CLASS_NAME (interface)));\n       metaclass_superclass_expr = create_extern_decl (objc_v2_class_template, buf);\n       metaclass_superclass_expr = build_fold_addr_expr (metaclass_superclass_expr);\n     }\n   else\n     {\n-      /* root class.  */\n+      /* Root class.  */\n       root_expr = build_unary_op (loc, ADDR_EXPR, metaclass_decl, 0);\n       metaclass_superclass_expr = build_unary_op (loc, ADDR_EXPR, class_decl, 0);\n       class_superclass_expr = build_int_cst (NULL_TREE, 0);\n-      flags |= 0x02; /* RO_ROOT: it is also a root meta class */\n+      flags |= 0x02; /* RO_ROOT: it is also a root meta class.  */\n     }\n \n   if (CLASS_PROTOCOL_LIST (impent->imp_template))\n@@ -3170,10 +3197,11 @@ generate_v2_class_structs (struct imp_entry *impent)\n \n   instanceStart = TREE_INT_CST_LOW (TYPE_SIZE_UNIT (objc_v2_class_template));\n \n-  /* Currently there are no class ivars and generation of class variables for\n-     the root of the inheritance has been removed. It causes multiple defines\n-     if there are two root classes in the link, because each will define its\n-     own identically-named offset variable. */\n+  /* Currently there are no class ivars and generation of class\n+     variables for the root of the inheritance has been removed.  It\n+     causes multiple defines if there are two root classes in the\n+     link, because each will define its own identically-named offset\n+     variable.  */\n \n   class_ivars = NULL_TREE;\n   /* TODO: Add total size of class variables when implemented. */\n@@ -3186,7 +3214,7 @@ generate_v2_class_structs (struct imp_entry *impent)\n \t\t\t newabi_append_ro (IDENTIFIER_POINTER\n \t\t\t\t\t\t(DECL_NAME (metaclass_decl))));\n \n-  /* TODO: ivarLayout needs t be built. */\n+  /* TODO: ivarLayout needs t be built.  */\n   initlist = \n \tbuild_v2_class_ro_t_initializer (TREE_TYPE (decl), name_expr,\n \t\t\t\t\t(flags | cls_flags), instanceStart,\n@@ -3239,7 +3267,7 @@ generate_v2_class_structs (struct imp_entry *impent)\n \t\t\t\t\t   impent->imp_template);\n     }\n \n-  /* Compute instanceStart */\n+  /* Compute instanceStart.  */\n   gcc_assert (CLASS_STATIC_TEMPLATE (impent->imp_template));\n   field = TYPE_FIELDS (CLASS_STATIC_TEMPLATE (impent->imp_template));\n   if (my_super_id && field && TREE_CHAIN (field))\n@@ -3252,7 +3280,7 @@ generate_v2_class_structs (struct imp_entry *impent)\n \n   gcc_assert (inst_ivars? (firstIvar != NULL_TREE): true);\n \n-  /* Compute instanceSize */\n+  /* Compute instanceSize.  */\n   while (field && TREE_CHAIN (field)\n          && TREE_CODE (TREE_CHAIN (field)) == FIELD_DECL)\n     field = TREE_CHAIN (field);\n@@ -3266,8 +3294,8 @@ generate_v2_class_structs (struct imp_entry *impent)\n \n   props = generate_v2_property_table (NULL_TREE, impent->imp_context);\n \n-  /* If the class has no ivars, instanceStart should be set to the superclass's \n-     instanceSize */\n+  /* If the class has no ivars, instanceStart should be set to the\n+     superclass's instanceSize.  */\n   instanceStart = \n \t(inst_ivars != NULL_TREE) ? (unsigned) int_byte_position (firstIvar) \n \t\t\t\t  : instanceSize;\n@@ -3307,7 +3335,8 @@ generate_v2_class_structs (struct imp_entry *impent)\n     objc_v2_add_to_ehtype_list (CLASS_NAME (impent->imp_template));\n }\n \n-/* This routine outputs the (ivar_reference_offset, offset) tuples. */\n+/* This routine outputs the (ivar_reference_offset, offset)\n+   tuples.  */\n \n static void\n build_v2_ivar_offset_ref_table (void)\n@@ -3352,15 +3381,18 @@ objc_generate_v2_next_metadata (void)\n {\n   struct imp_entry *impent;\n \n+  /* FIXME: Make sure that we generate no metadata if there is nothing\n+     to put into it.  */\n+\n   gcc_assert (!objc_static_instances); /* Not for NeXT */\n \n   build_metadata_templates ();\n \n   for (impent = imp_list; impent; impent = impent->next)\n     {\n       /* If -gen-decls is present, Dump the @interface of each class.\n-\t TODO: Dump the classes in the  order they were found, rather than in\n-\t reverse order as we are doing now.  */\n+\t TODO: Dump the classes in the order they were found, rather\n+\t than in reverse order as we are doing now.  */\n       if (flag_gen_declaration)\n \tdump_interface (gen_declaration_file, impent->imp_context);\n \n@@ -3429,10 +3461,11 @@ build_v2_ehtype_template (void)\n   objc_finish_struct (objc_v2_ehtype_template, decls);\n }\n \n-/* Template for the Objective-C family typeinfo type for ABI=2.\n-   This starts off the same as the gxx/cxx eh typeinfo.\n+/* Template for the Objective-C family typeinfo type for ABI=2.  This\n+   starts off the same as the gxx/cxx eh typeinfo.\n \n-   struct _objc_ehtype_t {\n+   struct _objc_ehtype_t\n+   {\n      void *_objc_ehtype_vtable_ptr;\t- as per c++\n      const char *className;\t\t- as per c++\n      struct class_t *const cls;\n@@ -3448,9 +3481,10 @@ objc2_build_ehtype_initializer (tree name, tree cls)\n   VEC(constructor_elt,gc) *initlist = NULL;\n   tree addr, offs;\n \n-  /* This is done the same way as c++, missing the two first entries in the \n-     parent vtable.  NOTE: there is a fix-me in the Apple/NeXT runtime source\n-     about this so, perhaps, this will change at some point.  */\n+  /* This is done the same way as c++, missing the two first entries\n+     in the parent vtable.  NOTE: there is a fix-me in the Apple/NeXT\n+     runtime source about this so, perhaps, this will change at some\n+     point.  */\n   /* _objc_ehtype_vtable + 2*sizeof(void*)  */\n   if (!next_v2_ehvtable_decl)\n     {\n@@ -3481,7 +3515,8 @@ build_ehtype (tree name, const char *eh_name, bool weak)\n   tree name_expr, class_name_expr, ehtype_decl, inits;\n \n   name_expr = add_objc_string (name, class_names);\n-  /* Extern ref. for the class. ??? maybe we can look this up somewhere.  */\n+  /* Extern ref. for the class. ???  Maybe we can look this up\n+     somewhere.  */\n   class_name_expr = \n \tcreate_extern_decl (objc_v2_class_template,\n \t\t\t    objc_build_internal_classname (name, false));\n@@ -3496,8 +3531,7 @@ build_ehtype (tree name, const char *eh_name, bool weak)\n }\n \n /* This routine returns TRUE if CLS or any of its super classes has\n-   __attribute__ ((objc_exception)).\n-*/\n+   __attribute__ ((objc_exception)).  */\n \n static bool\n objc2_objc_exception_attr (tree cls)\n@@ -3565,10 +3599,9 @@ lookup_ehtype_ref (tree id)\n   return NULL_TREE;\n }\n \n-/* This hook, called via lang_eh_runtime_type, generates a runtime object\n-   which is either the address of the 'OBJC_EHTYPE_$_class' object or\n-   address of external OBJC_EHTYPE_id object.\n-*/\n+/* This hook, called via lang_eh_runtime_type, generates a runtime\n+   object which is either the address of the 'OBJC_EHTYPE_$_class'\n+   object or address of external OBJC_EHTYPE_id object.  */\n static tree\n next_runtime_02_eh_type (tree type)\n {\n@@ -3582,8 +3615,8 @@ next_runtime_02_eh_type (tree type)\n     {\n       if (!next_v2_EHTYPE_id_decl)\n \t{\n-\t  /* This is provided by the Apple/NeXT libobjc.dylib so we need \n-\t     only to reference it.  */\n+\t  /* This is provided by the Apple/NeXT libobjc.dylib so we\n+\t     need only to reference it.  */\n \t  next_v2_EHTYPE_id_decl = \n \t\tstart_var_decl (objc_v2_ehtype_template, \"OBJC_EHTYPE_id\");\n \t  DECL_EXTERNAL (next_v2_EHTYPE_id_decl) = 1;\n@@ -3596,8 +3629,8 @@ next_runtime_02_eh_type (tree type)\n   if (!POINTER_TYPE_P (type) || !TYPED_OBJECT (TREE_TYPE (type)))\n     {\n #ifdef OBJCPLUS\n-      /* This routine is also called for c++'s catch clause; in which case,\n-\t we use c++'s typeinfo decl. */\n+      /* This routine is also called for c++'s catch clause; in which\n+\t case, we use c++'s typeinfo decl.  */\n       return build_eh_type_type (type);\n #else\n       error (\"non-objective-c type '%T' cannot be caught\", type);\n@@ -3607,7 +3640,7 @@ next_runtime_02_eh_type (tree type)\n   else \n     t = OBJC_TYPE_NAME (TREE_TYPE (type));\n   \n-  /* We have to build a reference to the OBJC_EHTYPE_<Class>. */\n+  /* We have to build a reference to the OBJC_EHTYPE_<Class>.  */\n   t = lookup_ehtype_ref (t);\n   if (!t)\n     goto err_mark_in;\n@@ -3639,7 +3672,7 @@ build_throw_stmt (location_t loc, tree throw_expr, bool rethrown)\n     t = build_function_call_vec (loc, objc_rethrow_exception_decl, NULL, NULL);\n   else\n     {\n-      /* Throw like the others .. */\n+      /* Throw like the others...  */\n       VEC(tree, gc) *parms = VEC_alloc (tree, gc, 1);\n       VEC_quick_push (tree, parms, throw_expr);\n       t = build_function_call_vec (loc, objc_exception_throw_decl, parms, NULL);\n@@ -3675,14 +3708,15 @@ static tree begin_catch (struct objc_try_context **cur_try_context, tree type,\n   /* Initialize the decl from the EXC_PTR_EXPR we get from the runtime.  */\n   t = objc_build_exc_ptr (cur_try_context);\n   t = convert (TREE_TYPE (decl), t);\n-  /* TODO location stuff. */\n+  /* FIXME: location.  */\n   if (type && type != error_mark_node)\n     {\n       t = build1(NOP_EXPR, ptr_type_node, t);\n       t = build_function_call (input_location, objc2_begin_catch_decl,\n \t\t\t      tree_cons (NULL_TREE, t, NULL_TREE));\n \n-      /* We might want to build a catch object for this (if it's not id).  */\n+      /* We might want to build a catch object for this (if it's not\n+\t id).  */\n       if (POINTER_TYPE_P (type)\n \t  && !objc_is_object_id (TREE_TYPE (type))\n \t  && TYPED_OBJECT (TREE_TYPE (type)))\n@@ -3705,20 +3739,20 @@ finish_catch (struct objc_try_context **cur_try_context, tree curr_catch)\n   t = CATCH_BODY (curr_catch);\n   if (TREE_CODE (t) == BIND_EXPR)\n     {\n-      /* usual case of @catch (objc-expr). */\n+      /* Usual case of @catch (objc-expr).  */\n       objc_begin_try_stmt (loc, BIND_EXPR_BODY (t));\n       BIND_EXPR_BODY (t) = NULL_TREE;\n       l = &BIND_EXPR_BODY (t);\n     }\n   else\n     {\n-      /* NULL entry, @catch (...) */\n+      /* NULL entry, meaning @catch (...).  */\n       objc_begin_try_stmt (loc, t);\n       CATCH_BODY (curr_catch) = NULL_TREE;\n       l = &CATCH_BODY (curr_catch);\n     }\n \n-  /* Pick up the new context we made in begin_try above.. */\n+  /* Pick up the new context we made in begin_try above...  */\n   ct = *cur_try_context; \n   func = build_function_call_vec (loc, objc2_end_catch_decl, NULL, NULL);\n   append_to_statement_list (func, &ct->finally_body);"}]}