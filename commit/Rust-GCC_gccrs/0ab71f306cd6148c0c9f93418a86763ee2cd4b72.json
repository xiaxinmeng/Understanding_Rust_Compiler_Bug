{"sha": "0ab71f306cd6148c0c9f93418a86763ee2cd4b72", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGFiNzFmMzA2Y2Q2MTQ4YzBjOWY5MzQxOGE4Njc2M2VlMmNkNGI3Mg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2011-08-25T18:22:54Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2011-08-25T18:22:54Z"}, "message": "* call.c (convert_like_real): Remove redundant complain checks.\n\nFrom-SVN: r178082", "tree": {"sha": "c3896711c344072311800b26a4eaa85eb78cb8f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c3896711c344072311800b26a4eaa85eb78cb8f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ab71f306cd6148c0c9f93418a86763ee2cd4b72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab71f306cd6148c0c9f93418a86763ee2cd4b72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ab71f306cd6148c0c9f93418a86763ee2cd4b72", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ab71f306cd6148c0c9f93418a86763ee2cd4b72/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7888350f3973a45d98581573bcf7773eb10d8322", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7888350f3973a45d98581573bcf7773eb10d8322", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7888350f3973a45d98581573bcf7773eb10d8322"}], "stats": {"total": 62, "additions": 26, "deletions": 36}, "files": [{"sha": "10e64ef7f35dae121480d8238829bd83ab381949", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab71f306cd6148c0c9f93418a86763ee2cd4b72/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab71f306cd6148c0c9f93418a86763ee2cd4b72/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=0ab71f306cd6148c0c9f93418a86763ee2cd4b72", "patch": "@@ -1,5 +1,7 @@\n 2011-08-25  Jason Merrill  <jason@redhat.com>\n \n+\t* call.c (convert_like_real): Remove redundant complain checks.\n+\n \tPR c++/50157\n \t* call.c (convert_like_real): Exit early if bad and !tf_error.\n "}, {"sha": "dc3582414f57dd845ef139bfcc2c287c43f97d6f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 24, "deletions": 36, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ab71f306cd6148c0c9f93418a86763ee2cd4b72/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ab71f306cd6148c0c9f93418a86763ee2cd4b72/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0ab71f306cd6148c0c9f93418a86763ee2cd4b72", "patch": "@@ -5733,11 +5733,8 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t       empty list, since that is handled separately in 8.5.4.  */\n \t    && cand->num_convs > 0)\n \t  {\n-\t    if (complain & tf_error)\n-\t      error (\"converting to %qT from initializer list would use \"\n-\t\t     \"explicit constructor %qD\", totype, convfn);\n-\t    else\n-\t      return error_mark_node;\n+\t    error (\"converting to %qT from initializer list would use \"\n+\t\t   \"explicit constructor %qD\", totype, convfn);\n \t  }\n \n \t/* Set user_conv_p on the argument conversions, so rvalue/base\n@@ -5789,6 +5786,9 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n         }\n       return expr;\n     case ck_ambig:\n+      /* We leave bad_p off ck_ambig because overload resolution considers\n+\t it valid, it just fails when we try to perform it.  So we need to\n+         check complain here, too.  */\n       if (complain & tf_error)\n \t{\n \t  /* Call build_user_type_conversion again for the error.  */\n@@ -5899,14 +5899,9 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t/* Copy-list-initialization doesn't actually involve a copy.  */\n \treturn expr;\n       expr = build_temp (expr, totype, flags, &diag_kind, complain);\n-      if (diag_kind && fn)\n-\t{\n-\t  if ((complain & tf_error))\n-\t    emit_diagnostic (diag_kind, DECL_SOURCE_LOCATION (fn), 0,\n-\t\t\t     \"  initializing argument %P of %qD\", argnum, fn);\n-\t  else if (diag_kind == DK_ERROR)\n-\t    return error_mark_node;\n-\t}\n+      if (diag_kind && fn && complain)\n+\temit_diagnostic (diag_kind, DECL_SOURCE_LOCATION (fn), 0,\n+\t\t\t \"  initializing argument %P of %qD\", argnum, fn);\n       return build_cplus_new (totype, expr, complain);\n \n     case ck_ref_bind:\n@@ -5916,13 +5911,10 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \tif (convs->bad_p && TYPE_REF_IS_RVALUE (ref_type)\n \t    && real_lvalue_p (expr))\n \t  {\n-\t    if (complain & tf_error)\n-\t      {\n-\t\terror (\"cannot bind %qT lvalue to %qT\",\n-\t\t       TREE_TYPE (expr), totype);\n-\t\tif (fn)\n-\t\t  error (\"  initializing argument %P of %q+D\", argnum, fn);\n-\t      }\n+\t    error (\"cannot bind %qT lvalue to %qT\",\n+\t\t   TREE_TYPE (expr), totype);\n+\t    if (fn)\n+\t      error (\"  initializing argument %P of %q+D\", argnum, fn);\n \t    return error_mark_node;\n \t  }\n \n@@ -5948,19 +5940,16 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t    if (!CP_TYPE_CONST_NON_VOLATILE_P (type)\n \t\t&& !TYPE_REF_IS_RVALUE (ref_type))\n \t      {\n-\t\tif (complain & tf_error)\n-\t\t  {\n-\t\t    /* If the reference is volatile or non-const, we\n-\t\t       cannot create a temporary.  */\n-\t\t    if (lvalue & clk_bitfield)\n-\t\t      error (\"cannot bind bitfield %qE to %qT\",\n-\t\t\t     expr, ref_type);\n-\t\t    else if (lvalue & clk_packed)\n-\t\t      error (\"cannot bind packed field %qE to %qT\",\n-\t\t\t     expr, ref_type);\n-\t\t    else\n-\t\t      error (\"cannot bind rvalue %qE to %qT\", expr, ref_type);\n-\t\t  }\n+\t\t/* If the reference is volatile or non-const, we\n+\t\t   cannot create a temporary.  */\n+\t\tif (lvalue & clk_bitfield)\n+\t\t  error (\"cannot bind bitfield %qE to %qT\",\n+\t\t\t expr, ref_type);\n+\t\telse if (lvalue & clk_packed)\n+\t\t  error (\"cannot bind packed field %qE to %qT\",\n+\t\t\t expr, ref_type);\n+\t\telse\n+\t\t  error (\"cannot bind rvalue %qE to %qT\", expr, ref_type);\n \t\treturn error_mark_node;\n \t      }\n \t    /* If the source is a packed field, and we must use a copy\n@@ -5973,9 +5962,8 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n \t\t&& CLASS_TYPE_P (type)\n \t\t&& type_has_nontrivial_copy_init (type))\n \t      {\n-\t\tif (complain & tf_error)\n-\t\t  error (\"cannot bind packed field %qE to %qT\",\n-\t\t\t expr, ref_type);\n+\t\terror (\"cannot bind packed field %qE to %qT\",\n+\t\t       expr, ref_type);\n \t\treturn error_mark_node;\n \t      }\n \t    if (lvalue & clk_bitfield)"}]}