{"sha": "772d532e0ba1e4b22c2b7d576e14b34ee929c093", "node_id": "C_kwDOANBUbNoAKDc3MmQ1MzJlMGJhMWU0YjIyYzJiN2Q1NzZlMTRiMzRlZTkyOWMwOTM", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-08-31T21:37:59Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2022-09-27T22:49:25Z"}, "message": "c++: Implement C++23 P2266R1, Simpler implicit move [PR101165]\n\nThis patch implements https://wg21.link/p2266, which, once again,\nchanges the implicit move rules.  Here's a brief summary of various\nchanges in this area:\n\nr125211: Introduced moving from certain lvalues when returning them\nr171071: CWG 1148, enable move from value parameter on return\nr212099: CWG 1579, it's OK to call a converting ctor taking an rvalue\nr251035: CWG 1579, do maybe-rvalue overload resolution twice\nr11-2411: Avoid calling const copy ctor on implicit move\nr11-2412: C++20 implicit move changes, remove the fallback overload\n          resolution, allow move on throw of parameters and implicit\n\t  move of rvalue references\n\nP2266 enables the implicit move even for functions that return references.\nThat is, we will now perform a move in\n\n  X&& foo (X&& x) {\n    return x;\n  }\n\nP2266 also removes the fallback overload resolution, but this was\nresolved by r11-2412: we only do convert_for_initialization with\nLOOKUP_PREFER_RVALUE in C++17 and older.\nP2266 also says that a returned move-eligible id-expression is always an\nxvalue.  This required some further short, but nontrivial changes,\nespecially when it comes to deduction, because we have to pay attention\nto whether we have auto, auto&& (which is like T&&), or decltype(auto)\nwith (un)parenthesized argument.  In C++23,\n\n  decltype(auto) f(int&& x) { return (x); }\n  auto&& f(int x) { return x; }\n\nboth should deduce to 'int&&' but\n\n  decltype(auto) f(int x) { return x; }\n\nshould deduce to 'int'.  A cornucopia of tests attached.  I've also\nverified that we behave like clang++.\n\nxvalue_p seemed to be broken: since the introduction of clk_implicit_rval,\nit cannot use '==' when checking for clk_rvalueref.\n\nSince this change breaks code, it's only enabled in C++23.  In\nparticular, this code will not compile in C++23:\n\n  int& g(int&& x) { return x; }\n\nbecause x is now treated as an rvalue, and you can't bind a non-const lvalue\nreference to an rvalue.\n\nThis patch also fixes PR106882 (the check_return_expr changes).\n\n\tPR c++/101165\n\tPR c++/106882\n\ngcc/c-family/ChangeLog:\n\n\t* c-cppbuiltin.cc (c_cpp_builtins): Define __cpp_implicit_move.\n\ngcc/cp/ChangeLog:\n\n\t* call.cc (reference_binding): Check clk_implicit_rval in C++20 only.\n\t* cp-tree.h (unparenthesized_id_or_class_member_access_p): Declare.\n\t* pt.cc (unparenthesized_id_or_class_member_access_p): New function,\n\tbroken out of...\n\t(do_auto_deduction): ...here.  Use it.  In C++23, maybe call\n\ttreat_lvalue_as_rvalue_p.\n\t* tree.cc (xvalue_p): Check & clk_rvalueref, not == clk_rvalueref.\n\t* typeck.cc (check_return_expr): Allow implicit move for functions\n\treturning a reference as well, or when the return value type is not\n\ta scalar type.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/conversion/pr41426.C: Add dg-error for C++23.\n\t* g++.dg/cpp0x/elision_weak.C: Likewise.\n\t* g++.dg/cpp0x/move-return3.C: Only link in c++20_down.\n\t* g++.dg/cpp1y/decltype-auto2.C: Add dg-error for C++23.\n\t* g++.dg/cpp1y/lambda-generic-89419.C: Likewise.\n\t* g++.dg/cpp23/feat-cxx2b.C: Test __cpp_implicit_move.\n\t* g++.dg/gomp/pr56217.C: Only compile in c++20_down.\n\t* g++.dg/warn/Wno-return-local-addr.C: Add dg-error for C++23.\n\t* g++.dg/warn/Wreturn-local-addr.C: Adjust dg-error.\n\t* g++.old-deja/g++.brendan/crash55.C: Add dg-error for C++23.\n\t* g++.old-deja/g++.jason/temporary2.C: Likewise.\n\t* g++.old-deja/g++.mike/p2846b.C: Adjust.\n\t* g++.dg/cpp1y/decltype-auto6.C: New test.\n\t* g++.dg/cpp23/decltype1.C: New test.\n\t* g++.dg/cpp23/decltype2.C: New test.\n\t* g++.dg/cpp23/elision1.C: New test.\n\t* g++.dg/cpp23/elision2.C: New test.\n\t* g++.dg/cpp23/elision3.C: New test.\n\t* g++.dg/cpp23/elision4.C: New test.\n\t* g++.dg/cpp23/elision5.C: New test.\n\t* g++.dg/cpp23/elision6.C: New test.\n\t* g++.dg/cpp23/elision7.C: New test.", "tree": {"sha": "06f8f5a94dddbd674053f1fb22087696f2fc8f23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/06f8f5a94dddbd674053f1fb22087696f2fc8f23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/772d532e0ba1e4b22c2b7d576e14b34ee929c093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/772d532e0ba1e4b22c2b7d576e14b34ee929c093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/772d532e0ba1e4b22c2b7d576e14b34ee929c093", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/772d532e0ba1e4b22c2b7d576e14b34ee929c093/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "78bc6497fc61bbdacfb416ee0246a775360d9af6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78bc6497fc61bbdacfb416ee0246a775360d9af6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78bc6497fc61bbdacfb416ee0246a775360d9af6"}], "stats": {"total": 656, "additions": 620, "deletions": 36}, "files": [{"sha": "d4de5a0dc57d1d61802e4ab738a4855b7c64a9c9", "filename": "gcc/c-family/c-cppbuiltin.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fc-family%2Fc-cppbuiltin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fc-family%2Fc-cppbuiltin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-cppbuiltin.cc?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -1082,6 +1082,7 @@ c_cpp_builtins (cpp_reader *pfile)\n \t  cpp_define (pfile, \"__cpp_multidimensional_subscript=202110L\");\n \t  cpp_define (pfile, \"__cpp_named_character_escapes=202207L\");\n \t  cpp_define (pfile, \"__cpp_static_call_operator=202207L\");\n+\t  cpp_define (pfile, \"__cpp_implicit_move=202207L\");\n \t}\n       if (flag_concepts)\n         {"}, {"sha": "3506b0fcfbb5b9cbe5f9109daf77b68807117a25", "filename": "gcc/cp/call.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fcp%2Fcall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fcp%2Fcall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.cc?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -1880,8 +1880,10 @@ reference_binding (tree rto, tree rfrom, tree expr, bool c_cast_p, int flags,\n \n       /* Nor the reverse.  */\n       if (!is_lvalue && !TYPE_REF_IS_RVALUE (rto)\n-\t  /* Unless it's really an lvalue.  */\n-\t  && !(cxx_dialect >= cxx20\n+\t  /* Unless it's really a C++20 lvalue being treated as an xvalue.\n+\t     But in C++23, such an expression is just an xvalue, not a special\n+\t     lvalue, so the binding is once again ill-formed.  */\n+\t  && !(cxx_dialect == cxx20\n \t       && (gl_kind & clk_implicit_rval))\n \t  && (!CP_TYPE_CONST_NON_VOLATILE_P (to)\n \t      || (flags & LOOKUP_NO_RVAL_BIND))"}, {"sha": "19bbfbc557fd076273938aad7b00f94e9cbb549c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -7292,6 +7292,7 @@ extern tree make_constrained_decltype_auto\t(tree, tree);\n extern tree make_template_placeholder\t\t(tree);\n extern bool template_placeholder_p\t\t(tree);\n extern bool ctad_template_p\t\t\t(tree);\n+extern bool unparenthesized_id_or_class_member_access_p (tree);\n extern tree do_auto_deduction                   (tree, tree, tree,\n                                                  tsubst_flags_t\n \t\t\t\t\t\t = tf_warning_or_error,"}, {"sha": "2d83dfd6954cbc9639128cfdb2aeaf2b925078b9", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 38, "deletions": 12, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -30408,6 +30408,26 @@ do_class_deduction (tree ptype, tree tmpl, tree init,\n \t\t\t\t  cp_type_quals (ptype));\n }\n \n+/* Return true if INIT is an unparenthesized id-expression or an\n+   unparenthesized class member access.  Used for the argument of\n+   decltype(auto).  */\n+\n+bool\n+unparenthesized_id_or_class_member_access_p (tree init)\n+{\n+  STRIP_ANY_LOCATION_WRAPPER (init);\n+\n+  /* We need to be able to tell '(r)' and 'r' apart (when it's of\n+     reference type).  Only the latter is an id-expression.  */\n+  if (REFERENCE_REF_P (init)\n+      && !REF_PARENTHESIZED_P (init))\n+    init = TREE_OPERAND (init, 0);\n+  return (DECL_P (init)\n+\t  || ((TREE_CODE (init) == COMPONENT_REF\n+\t       || TREE_CODE (init) == SCOPE_REF)\n+\t      && !REF_PARENTHESIZED_P (init)));\n+}\n+\n /* Replace occurrences of 'auto' in TYPE with the appropriate type deduced\n    from INIT.  AUTO_NODE is the TEMPLATE_TYPE_PARM used for 'auto' in TYPE.\n    The CONTEXT determines the context in which auto deduction is performed\n@@ -30443,6 +30463,23 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n      auto_node.  */\n   complain &= ~tf_partial;\n \n+  /* In C++23, we must deduce the type to int&& for code like\n+       decltype(auto) f(int&& x) { return (x); }\n+     or\n+       auto&& f(int x) { return x; }\n+     so we use treat_lvalue_as_rvalue_p.  But don't do it for\n+       decltype(auto) f(int x) { return x; }\n+     where we should deduce 'int' rather than 'int&&'; transmogrifying\n+     INIT to an rvalue would break that.  */\n+  tree r;\n+  if (cxx_dialect >= cxx23\n+      && context == adc_return_type\n+      && (!AUTO_IS_DECLTYPE (auto_node)\n+\t  || !unparenthesized_id_or_class_member_access_p (init))\n+      && (r = treat_lvalue_as_rvalue_p (maybe_undo_parenthesized_ref (init),\n+\t\t\t\t\t/*return*/true)))\n+    init = r;\n+\n   if (tree tmpl = CLASS_PLACEHOLDER_TEMPLATE (auto_node))\n     /* C++17 class template argument deduction.  */\n     return do_class_deduction (type, tmpl, init, flags, complain);\n@@ -30504,18 +30541,7 @@ do_auto_deduction (tree type, tree init, tree auto_node,\n     }\n   else if (AUTO_IS_DECLTYPE (auto_node))\n     {\n-      /* Figure out if INIT is an unparenthesized id-expression or an\n-\t unparenthesized class member access.  */\n-      tree stripped_init = tree_strip_any_location_wrapper (init);\n-      /* We need to be able to tell '(r)' and 'r' apart (when it's of\n-\t reference type).  Only the latter is an id-expression.  */\n-      if (REFERENCE_REF_P (stripped_init)\n-\t  && !REF_PARENTHESIZED_P (stripped_init))\n-\tstripped_init = TREE_OPERAND (stripped_init, 0);\n-      const bool id = (DECL_P (stripped_init)\n-\t\t       || ((TREE_CODE (stripped_init) == COMPONENT_REF\n-\t\t\t    || TREE_CODE (stripped_init) == SCOPE_REF)\n-\t\t\t   && !REF_PARENTHESIZED_P (stripped_init)));\n+      const bool id = unparenthesized_id_or_class_member_access_p (init);\n       tree deduced = finish_decltype_type (init, id, complain);\n       deduced = canonicalize_type_argument (deduced, complain);\n       if (deduced == error_mark_node)"}, {"sha": "ea4dfc651bbbef94d0765438bd49bf8875b690e2", "filename": "gcc/cp/tree.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fcp%2Ftree.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fcp%2Ftree.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.cc?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -382,7 +382,7 @@ obvalue_p (const_tree ref)\n bool\n xvalue_p (const_tree ref)\n {\n-  return (lvalue_kind (ref) == clk_rvalueref);\n+  return (lvalue_kind (ref) & clk_rvalueref);\n }\n \n /* True if REF is a bit-field.  */"}, {"sha": "5f16c4d242603f4194b9952c8296aca9e341b96b", "filename": "gcc/cp/typeck.cc", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fcp%2Ftypeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Fcp%2Ftypeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.cc?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -11042,9 +11042,13 @@ check_return_expr (tree retval, bool *no_warning)\n \t the conditions for the named return value optimization.  */\n       bool converted = false;\n       tree moved;\n-      /* This is only interesting for class type.  */\n-      if (CLASS_TYPE_P (functype)\n-\t  && (moved = treat_lvalue_as_rvalue_p (retval, /*return*/true)))\n+      /* Until C++23, this was only interesting for class type, but in C++23,\n+\t we should do the below when we're converting rom/to a class/reference\n+\t (a non-scalar type).  */\n+\tif ((cxx_dialect < cxx23\n+\t     ? CLASS_TYPE_P (functype)\n+\t     : !SCALAR_TYPE_P (functype) || !SCALAR_TYPE_P (TREE_TYPE (retval)))\n+\t    && (moved = treat_lvalue_as_rvalue_p (retval, /*return*/true)))\n \t{\n \t  if (cxx_dialect < cxx20)\n \t    {"}, {"sha": "b4ecbca5f3ac1516000b97337a240bdb751f54d2", "filename": "gcc/testsuite/g++.dg/conversion/pr41426.C", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fpr41426.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fpr41426.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fconversion%2Fpr41426.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -11,19 +11,20 @@ struct A\n A<float> g1()\n {\n    float f[] = {1.1f, 2.3f};\n-   return f;\n+   return f; // { dg-error \"cannot bind non-const\" \"\" { target c++23 } }\n }\n \n const A<float> &g3()\n {\n    float f[] = {1.1f, 2.3f};\n-   return f; // { dg-warning \"returning reference to temporary\" }\n+   return f; // { dg-warning \"returning reference to temporary\" \"\" { target c++20_down } }\n+// { dg-error \"non-const lvalue|invalid user-defined conversion\" \"\" { target c++23 } .-1 }\n }\n \n A<float> &g4()\n {\n    float f[] = {1.1f, 2.3f};\n-   return f; // { dg-error \"cannot bind non-const lvalue ref\" }\n+   return f; // { dg-error \"cannot bind non-const lvalue ref|invalid user-defined conversion\" }\n }\n \n struct B\n@@ -35,6 +36,5 @@ struct B\n B g2()\n {\n    int c[10];\n-   return c;\n+   return c; // { dg-error \"non-const lvalue\" \"\" { target c++23 } }\n }\n-"}, {"sha": "ddd1274313057dd130557d9635d02a4ff6d5ab11", "filename": "gcc/testsuite/g++.dg/cpp0x/elision_weak.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_weak.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_weak.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Felision_weak.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -9,11 +9,11 @@ struct S\n S f()\n {\n   S s;\n-  return s;\n+  return s; // { dg-error \"cannot bind non-const lvalue reference\" \"\" { target c++23 } }\n }\n \n void g()\n {\n   S s;\n-  throw s;\n+  throw s; // { dg-error \"cannot bind non-const lvalue reference\" \"\" { target c++23 } }\n }"}, {"sha": "30a936fb35a8979ad0f41059b3b98ecd11e9029d", "filename": "gcc/testsuite/g++.dg/cpp0x/move-return3.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fmove-return3.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -1,6 +1,7 @@\n // PR c++/91212\n // Test that C++11 implicit move semantics don't call the const copy.\n-// { dg-do link }\n+// In C++23, we call #2.\n+// { dg-do link { target c++20_down } }\n \n struct T { int i; };\n "}, {"sha": "24b32edfacf92513b9560bf5b865b247ade04b79", "filename": "gcc/testsuite/g++.dg/cpp1y/decltype-auto2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fdecltype-auto2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fdecltype-auto2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fdecltype-auto2.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -8,5 +8,5 @@ auto constexpr RtoL1(T&& r) -> decltype(auto) {\n int main() {\n     int t;\n     int x{3};\n-    decltype (RtoL1(x+0)) y = t;\n+    decltype (RtoL1(x+0)) y = t; // { dg-error \"cannot bind rvalue reference\" \"\" { target c++23 } }\n }"}, {"sha": "da53278645c55d7044110a1e31d9ec22a77e7e71", "filename": "gcc/testsuite/g++.dg/cpp1y/decltype-auto6.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fdecltype-auto6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fdecltype-auto6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Fdecltype-auto6.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/101165 - P2266R1 - Simpler implicit move\n+// { dg-do compile { target c++14 } }\n+// A variant of cxx23/elision1.C:eight, just with ().\n+\n+struct Widget {\n+  Widget(Widget&&);\n+};\n+\n+Widget val();\n+\n+decltype(auto)\n+foo ()\n+{\n+  decltype(auto) x = val();  // OK, x is Widget\n+  // We deduce the return type to int&&, therefore we're doing something\n+  // we ought not to be doing -- returning a reference to a local variable!\n+  // In C++20, we deduce to int&, but that has the same problem!\n+  return (x); // { dg-warning \"reference to local variable\" }\n+}"}, {"sha": "8e64d4e64abbfb3c92c9c54215b8f0d3435d2079", "filename": "gcc/testsuite/g++.dg/cpp1y/lambda-generic-89419.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-89419.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-89419.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1y%2Flambda-generic-89419.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -2,7 +2,7 @@\n // { dg-do compile { target c++14 } }\n \n struct A;\n-struct B {\n+struct B { // { dg-error \"cannot bind\" \"\" { target c++23 } }\n   struct C { C (); C (C &); } b;\n };\n struct D { A operator* (); };\n@@ -13,12 +13,12 @@ struct E {\n   auto bar () { return e; }\n   D e;\n };\n-struct F { B f; int g; };\n+struct F { B f; int g; }; // { dg-error \"use of deleted function\" \"\" { target c++23 } }\n \n int\n main ()\n {\n   E e;\n   auto f = *e.bar ();\n-  auto i = [&] { F g; g.g = 1; auto h = [&](auto) { g.g = 0; }; f.foo (h); return g; };\n+  auto i = [&] { F g; g.g = 1; auto h = [&](auto) { g.g = 0; }; f.foo (h); return g; }; // { dg-error \"use of deleted function\" \"\" { target c++23 } }\n }"}, {"sha": "6f3cd0d45d558e4de2e85b567af52243581810f8", "filename": "gcc/testsuite/g++.dg/cpp23/decltype1.C", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fdecltype1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fdecltype1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fdecltype1.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -0,0 +1,113 @@\n+// PR c++/101165 - P2266R1 - Simpler implicit move\n+// { dg-do compile { target c++23 } }\n+// Tests from P2266R1, decltype-related changes in\n+// $ 3.2.1. Interaction with decltype and decltype(auto)\n+\n+template<typename T, typename U>\n+struct same_type { static const bool value = false; };\n+\n+template<typename T>\n+struct same_type<T, T> { static const bool value = true; };\n+\n+auto f1(int x) -> decltype(x) { return (x); }\n+static_assert(same_type<decltype(f1), int (int)>::value);\n+auto f2(int x) -> decltype((x)) { return (x); }   // { dg-error \"cannot bind\" }\n+static_assert(same_type<decltype(f2), int& (int)>::value);\n+auto f3(int x) -> decltype(auto) { return (x); }  // { dg-warning \"reference to local variable\" }\n+static_assert(same_type<decltype(f3), int&& (int)>::value);\n+auto g1(int x) -> decltype(x) { return x; }\n+static_assert(same_type<decltype(g1), int (int)>::value);\n+auto g2(int x) -> decltype((x)) { return x; }\t  // { dg-error \"cannot bind\" }\n+static_assert(same_type<decltype(g2), int& (int)>::value);\n+auto g3(int x) -> decltype(auto) { return x; }\n+static_assert(same_type<decltype(g3), int (int)>::value);\n+\n+// Note that f2 and g2 are well-formed in C++20, but we propose to make\n+// f2 and g2 ill-formed, because they attempt to bind an lvalue reference\n+// to a move-eligible xvalue expression.\n+\n+struct X { };\n+\n+auto\n+f4 (X x)\n+{\n+  return x;\n+}\n+static_assert(same_type<decltype(f4), X(X)>::value);\n+\n+auto&\n+f5 (X x)\n+{\n+  return x; // { dg-error \"cannot bind non-const lvalue reference\" }\n+}\n+static_assert(same_type<decltype(f5), X&(X)>::value);\n+\n+auto&&\n+f6 (X x)\n+{\n+  return x; // { dg-warning \"reference to local variable\" }\n+}\n+static_assert(same_type<decltype(f6), X&&(X)>::value);\n+\n+auto\n+f7 (X x)\n+{\n+  return (x);\n+}\n+static_assert(same_type<decltype(f7), X(X)>::value);\n+\n+auto&\n+f8 (X x)\n+{\n+  return (x); // { dg-error \"cannot bind non-const lvalue reference\" }\n+}\n+static_assert(same_type<decltype(f8), X&(X)>::value);\n+\n+auto&&\n+f9 (X x)\n+{\n+  return (x); // { dg-warning \"reference to local variable\" }\n+}\n+static_assert(same_type<decltype(f9), X&&(X)>::value);\n+\n+decltype(auto)\n+f10 (X x)\n+{\n+  return x;\n+}\n+static_assert(same_type<decltype(f10), X(X)>::value);\n+\n+decltype(auto)\n+f11 (X x)\n+{\n+  return (x); // { dg-warning \"reference to local variable\" }\n+}\n+static_assert(same_type<decltype(f11), X&&(X)>::value);\n+\n+decltype(auto)\n+f12 (X& x)\n+{\n+  return x;\n+}\n+static_assert(same_type<decltype(f12), X&(X&)>::value);\n+\n+decltype(auto)\n+f13 (X& x)\n+{\n+  return (x);\n+}\n+static_assert(same_type<decltype(f13), X&(X&)>::value);\n+\n+decltype(auto)\n+f14 (X&& x)\n+{\n+  return x;\n+}\n+static_assert(same_type<decltype(f14), X&&(X&&)>::value);\n+\n+decltype(auto)\n+f15 (X&& x)\n+{\n+  return (x);\n+}\n+static_assert(same_type<decltype(f15), X&&(X&&)>::value);"}, {"sha": "84679c48f82873644a5b90d7738dc8019737414c", "filename": "gcc/testsuite/g++.dg/cpp23/decltype2.C", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fdecltype2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fdecltype2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Fdecltype2.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -0,0 +1,49 @@\n+// PR c++/101165 - P2266R1 - Simpler implicit move\n+// { dg-do compile { target c++23 } }\n+// Test decltype(auto) more.\n+\n+template<typename T, typename U>\n+struct same_type { static const bool value = false; };\n+\n+template<typename T>\n+struct same_type<T, T> { static const bool value = true; };\n+\n+struct Widget {\n+  int x;\n+};\n+\n+Widget wg;\n+\n+decltype(auto) fn0(Widget&& x) {\n+    return (::wg);\n+}\n+static_assert(same_type<decltype(fn0), Widget& (Widget&&)>::value);\n+\n+decltype(auto) fn1(Widget&& x) {\n+    return ::wg;\n+}\n+static_assert(same_type<decltype(fn1), Widget (Widget&&)>::value);\n+\n+decltype(auto) fn2() {\n+    Widget w;\n+    return w;\n+}\n+static_assert(same_type<decltype(fn2), Widget ()>::value);\n+\n+decltype(auto) fn3() {\n+    Widget w;\n+    return (w); // { dg-warning \"reference to local variable\" }\n+}\n+static_assert(same_type<decltype(fn3), Widget&& ()>::value);\n+\n+decltype(auto) fn4() {\n+    Widget w;\n+    return w.x;\n+}\n+static_assert(same_type<decltype(fn4), int ()>::value);\n+\n+decltype(auto) fn5() {\n+    Widget w;\n+    return (w.x); // { dg-warning \"reference to local variable\" }\n+}\n+static_assert(same_type<decltype(fn5), int& ()>::value);"}, {"sha": "f44fd2a061cb82648d54498e6b6c3e5c59edda91", "filename": "gcc/testsuite/g++.dg/cpp23/elision1.C", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision1.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -0,0 +1,114 @@\n+// PR c++/101165 - P2266R1 - Simpler implicit move\n+// { dg-do compile { target c++23 } }\n+// Tests from P2266R1.\n+\n+namespace std {\n+  template<typename _Tp>\n+    struct remove_reference\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&>\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&&>\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp>\n+    constexpr typename std::remove_reference<_Tp>::type&&\n+    move(_Tp&& __t) noexcept\n+    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }\n+}\n+\n+template<typename T, typename U>\n+struct same_type { static const bool value = false; };\n+\n+template<typename T>\n+struct same_type<T, T> { static const bool value = true; };\n+\n+struct Widget {\n+    Widget(Widget&&);\n+};\n+\n+struct RRefTaker {\n+    RRefTaker(Widget&&);\n+};\n+\n+struct Mutt {\n+    operator int*() &&;\n+};\n+\n+struct Jeff {\n+    operator int&() &&;\n+};\n+\n+struct Ella {\n+    operator int() &&;\n+};\n+\n+Widget one(Widget w) {\n+    return w;  // OK since C++11\n+}\n+\n+RRefTaker two(Widget w) {\n+    return w;  // OK since C++11 + CWG1579\n+}\n+\n+RRefTaker three(Widget&& w) {\n+    return w;  // OK since C++20 because P0527\n+}\n+\n+// Tests that implicit move applies even to functions that return references.\n+Widget&& four(Widget&& w) {\n+    return w;  // OK since C++23\n+}\n+\n+// ... or pointers.\n+int* five(Mutt x) {\n+    return x;  // OK since C++20 because P1155\n+}\n+\n+int& six(Jeff x) {\n+    return x;\n+}\n+\n+int test_ella(Ella e) {\n+  return e;\n+}\n+\n+template<class T>\n+T&& seven(T&& x) { return x; }\n+\n+void test_seven(Widget w) {\n+    Widget& r = seven(w);\n+    Widget&& rr = seven(std::move(w));\n+}\n+\n+Widget val();\n+Widget& lref();\n+Widget&& rref();\n+\n+decltype(auto) eight() {\n+    decltype(auto) x = val();  // OK, x is Widget\n+    return x;  // OK, return type is Widget, we get copy elision\n+}\n+\n+decltype(auto) nine() {\n+    decltype(auto) x = lref();  // OK, x is Widget&\n+    return x;  // OK, return type is Widget&\n+}\n+\n+decltype(auto) ten() {\n+  decltype(auto) x = rref();  // OK, x is Widget&&\n+  // This was an error: return type is Widget&&, cannot bind to x.\n+  // But in C++23, x is treated as an rvalue.\n+  return x;\n+}\n+\n+// Now returns Widget&&, not Widget&.\n+// This is from $ 3.2.1. Interaction with decltype and decltype(auto).\n+decltype(auto) eleven(Widget&& x) {\n+    return (x);\n+}\n+static_assert(same_type<decltype(eleven), Widget&& (Widget&&)>::value);"}, {"sha": "a698fc9f3abf98ae186320d2f298c2f45d87c48a", "filename": "gcc/testsuite/g++.dg/cpp23/elision2.C", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision2.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -0,0 +1,46 @@\n+// PR c++/101165 - P2266R1 - Simpler implicit move\n+// { dg-do compile { target c++20 } }\n+// Test from P2266R1, $ 3.3. Two overload resolutions are overly confusing.\n+\n+struct Widget {\n+    Widget();\n+    Widget(Widget&&);\n+};\n+\n+struct Frodo {\n+    Frodo(Widget&);\n+    Frodo(Widget&&) = delete;\n+};\n+\n+struct Sam {\n+    Sam(Widget&) = delete; // #1\n+    Sam(const Widget&);  // #2\n+};\n+\n+Sam twelve() {\n+    Widget w;\n+    // This is supposed to call #2 since C++20 because P1155.\n+    // But we actually choose #1 since r11-2411 (in C++20 only).\n+    return w; // { dg-error \"deleted\" \"\" { target c++20_only } }\n+}\n+\n+Frodo thirteen() {\n+    Widget w;\n+    // This is a correct error in both C++20 and C++23.\n+    return w;  // { dg-error \"use of deleted function\" }\n+}\n+\n+struct Merry {};\n+struct Pippin {};\n+struct Together : Merry, Pippin {};\n+struct Quest {\n+    Quest(Merry&&);\n+    Quest(Pippin&&);\n+    Quest(Together&);\n+};\n+\n+Quest fourteen() {\n+  Together t;\n+  // C++20: calls Quest(Together&).  Proposed: ill-formed.\n+  return t; // { dg-error \"ambiguous\" \"\" { target c++23 } }\n+}"}, {"sha": "246342e64d3e88f8279912cd7445a35af66499c7", "filename": "gcc/testsuite/g++.dg/cpp23/elision3.C", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision3.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -0,0 +1,16 @@\n+// PR c++/101165 - P2266R1 - Simpler implicit move\n+// { dg-do compile { target c++23 } }\n+// Test from P2266R1, $ 3.4. A specific case involving reference_wrapper.\n+\n+#include <functional>\n+\n+struct Widget {\n+    Widget();\n+    Widget(Widget&&);\n+};\n+\n+std::reference_wrapper<Widget> fifteen() {\n+    Widget w;\n+    // OK until CWG1579; OK after LWG2993.  Proposed: ill-formed\n+    return w;  // { dg-error \"could not convert\" }\n+}"}, {"sha": "c19b86b8b5fb72643c99ad5e831b820a1942c66f", "filename": "gcc/testsuite/g++.dg/cpp23/elision4.C", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision4.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -0,0 +1,38 @@\n+// PR c++/101165 - P2266R1 - Simpler implicit move\n+// { dg-do compile { target c++23 } }\n+// Test from P2266R1, $ 5.2. LibreOffice OString constructor.\n+\n+struct X {\n+    X(auto&);\n+};\n+\n+// The following compiles in C++20 (deducing X(char (&)[10])) but not\n+// after P2266 (because the returned expression now has type char (&&)[10],\n+// which cannot bind to auto&).\n+X f() {\n+    char a[10];\n+    return a; // { dg-error \"cannot bind non-const lvalue reference\" }\n+}\n+\n+// The solution was to change it by making the return convert explicitly\n+// rather than implicitly:\n+X fixed() {\n+    char a[10];\n+    return X(a);\n+}\n+\n+// $ 5.3. LibreOffice o3tl::temporary\n+\n+template<class T>\n+T& temporary1(T&& x) { return x; } // { dg-error \"cannot bind non-const lvalue reference\" }\n+\n+// Fixed by:\n+template<class T>\n+T& temporary2(T&& x) { return static_cast<T&>(x); }\n+\n+void\n+test ()\n+{\n+  int& r1 = temporary1 (42);\n+  int& r2 = temporary2 (42);\n+}"}, {"sha": "a7d3e7c27c4a1e7ff4d9a689e1bb3ca4b4eecdc8", "filename": "gcc/testsuite/g++.dg/cpp23/elision5.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision5.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -0,0 +1,53 @@\n+// PR c++/101165 - P2266R1 - Simpler implicit move\n+// { dg-do compile { target c++23 } }\n+// Test from [class.copy.elision]/4.\n+\n+class Thing {\n+public:\n+  Thing();\n+  ~Thing();\n+  Thing(Thing&&);\n+private:\n+  Thing(const Thing&);\n+};\n+\n+Thing f(bool b) {\n+  Thing t;\n+  if (b)\n+    throw t;            // OK, Thing(Thing&&) used (or elided) to throw t\n+  return t;             // OK, Thing(Thing&&) used (or elided) to return t\n+}\n+\n+Thing t2 = f(false);    // OK, no extra copy/move performed, t2 constructed by call to f\n+\n+struct Weird {\n+  Weird();\n+  Weird(Weird&);\n+};\n+\n+Weird g(bool b) {\n+  static Weird w1;\n+  Weird w2;\n+  if (b) {\n+    return w1;  // OK: Weird(Weird&)\n+  } else {\n+    return w2;  // { dg-error \"cannot bind non-const lvalue reference\" }\n+  }\n+}\n+\n+int& h(bool b, int i) {\n+  static int s;\n+  if (b)\n+    return s;   // OK\n+  else\n+    return i;   // { dg-error \"cannot bind non-const lvalue reference\" }\n+}\n+\n+decltype(auto) h2(Thing t) {\n+  return t;     // OK, t is an xvalue and h2's return type is Thing\n+}\n+\n+decltype(auto) h3(Thing t) {\n+  // OK, (t) is an xvalue and h3's return type is Thing&&\n+  return (t); // { dg-warning \"reference to local variable\" }\n+}"}, {"sha": "5d58da9e57730815e413d0fdd7458ca87741b118", "filename": "gcc/testsuite/g++.dg/cpp23/elision6.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision6.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -0,0 +1,20 @@\n+// PR c++/101165 - P2266R1 - Simpler implicit move\n+// { dg-do compile { target c++23 } }\n+// From [diff.cpp20.expr].\n+\n+template<typename T, typename U>\n+struct same_type { static const bool value = false; };\n+\n+template<typename T>\n+struct same_type<T, T> { static const bool value = true; };\n+\n+// In C++23, returns int&&; previously returned int&.\n+decltype(auto) f(int&& x) { return (x); }\n+static_assert(same_type<decltype(f), int&& (int&&)>::value);\n+\n+// This used to work in C++20.\n+int& g(int&& x) { return x; } // { dg-error \"cannot bind non-const lvalue reference\" }\n+\n+template<typename T>\n+decltype(auto) h(T&& x) { return (x); }\n+static_assert(same_type<decltype(h(42)), int&&>::value);"}, {"sha": "19fa89ae133935d3fd65e46f1fa66976caa18fff", "filename": "gcc/testsuite/g++.dg/cpp23/elision7.C", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Felision7.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -0,0 +1,72 @@\n+// PR c++/101165 - P2266R1 - Simpler implicit move\n+// { dg-do compile { target c++23 } }\n+\n+struct X {\n+  X ();\n+  X(X&&);\n+};\n+\n+X&& rref ();\n+\n+X&&\n+f1 (X&& x)\n+{\n+  return x;\n+}\n+\n+template<typename T> T&&\n+f2 (T&& x)\n+{\n+  return x;\n+}\n+template X& f2<X&>(X&);\n+template X&& f2<X>(X&&);\n+\n+X&&\n+f3 ()\n+{\n+  X&& x = rref ();\n+  return x;\n+}\n+\n+void\n+f4 ()\n+try {\n+  X x;\n+  throw x;\n+} catch (...) { }\n+\n+void\n+f5 ()\n+{\n+  auto l1 = [](auto x) -> auto { return x; };\n+  auto &&x1 = l1(X{});\n+  auto l2 = [](auto x) -> auto& { return x; }; // { dg-error \"cannot bind non-const lvalue reference\" }\n+  auto &&x2 = l2(X{});\n+  auto l3 = [](auto x) -> auto&& { return x; }; // { dg-warning \"reference to local\" }\n+  auto &&x3 = l3(X{});\n+}\n+\n+constexpr int &\n+f6 (int &&n)\n+{\n+  return n; // { dg-error \"cannot bind non-const lvalue reference\" }\n+}\n+\n+void\n+do_f6 ()\n+{\n+  auto x = f6 (42);\n+}\n+\n+template<typename T> auto &\n+f7 (T &&t)\n+{\n+  return t; // { dg-error \"cannot bind non-const lvalue reference\" }\n+}\n+\n+void\n+do_f7 ()\n+{\n+  const int &x = f7 (0);\n+}"}, {"sha": "b52cf378b410e05225a172c4886466e48842b0bb", "filename": "gcc/testsuite/g++.dg/cpp23/feat-cxx2b.C", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp23%2Ffeat-cxx2b.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -569,3 +569,9 @@\n #elif __cpp_static_call_operator != 202207\n #  error \"__cpp_static_call_operator != 202207\"\n #endif\n+\n+#ifndef __cpp_implicit_move\n+#  error \"__cpp_implicit_move\"\n+#elif __cpp_implicit_move != 202207\n+#  error \"__cpp_implicit_move != 202207\"\n+#endif"}, {"sha": "731c0c08811a86f9159271f8ebabe71227e2f1f6", "filename": "gcc/testsuite/g++.dg/gomp/pr56217.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr56217.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr56217.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fgomp%2Fpr56217.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -1,5 +1,5 @@\n // PR middle-end/56217\n-// { dg-do compile }\n+// { dg-do compile { target c++20_down } }\n // { dg-options \"-fopenmp\" }\n \n struct S { int *p; S (); S (S &); };\n@@ -10,5 +10,7 @@ foo ()\n   S s;\n   #pragma omp task shared (s)\n     s.p = 0;\n+  // This fails in C++23, because \"cannot bind non-const lvalue reference of\n+  // type 'S&' to an rvalue of type 'S'\".\n   return s;\n }"}, {"sha": "cc9bb59770ee253bdaa32dae9a386158aac1f2b4", "filename": "gcc/testsuite/g++.dg/warn/Wno-return-local-addr.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWno-return-local-addr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWno-return-local-addr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWno-return-local-addr.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -4,7 +4,7 @@\n int& bad1()\n {\n   int x = 0;\n-  return x;\n+  return x; // { dg-error \"cannot bind non-const lvalue reference\" \"\" { target c++23 } }\n }\n \n int* bad2()"}, {"sha": "4c18c2f06a040be44160a5d3261b342fc1fa6d80", "filename": "gcc/testsuite/g++.dg/warn/Wreturn-local-addr.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreturn-local-addr.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreturn-local-addr.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fwarn%2FWreturn-local-addr.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -5,7 +5,7 @@\n int& bad1()\n {\n   int x = 0;\n-  return x;\t\t// { dg-error \"reference to local variable\" }\n+  return x;\t\t// { dg-error \"reference to local variable|cannot bind non-const lvalue reference\" }\n }\n \n int* bad2()"}, {"sha": "b93e6e0c69566c3c29c17b79e1c9a06687abfaef", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash55.C", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash55.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash55.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash55.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -8,5 +8,6 @@\n \n           local = x+2;\n       \n-          return local; // { dg-warning \"reference to local\" }\n+          return local; // { dg-warning \"reference to local\" \"\" { target c++20_down } }\n+// { dg-error \"non-const lvalue\" \"\" { target c++23 } .-1 }\n       }"}, {"sha": "2709b50e7f1f07ce1d257de8f5efae3333147ca4", "filename": "gcc/testsuite/g++.old-deja/g++.jason/temporary2.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemporary2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemporary2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftemporary2.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -8,7 +8,7 @@ public:\n   int i;\n };\n \n-X foo() { X x; return x; }\n+X foo() { X x; return x; } // { dg-error \"cannot bind non-const lvalue reference\" \"\" { target c++23 } }\n \n int main() \n {"}, {"sha": "5bcf9e3624093ca21d18fa3fdd970a27de7328e9", "filename": "gcc/testsuite/g++.old-deja/g++.mike/p2846b.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp2846b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/772d532e0ba1e4b22c2b7d576e14b34ee929c093/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp2846b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fp2846b.C?ref=772d532e0ba1e4b22c2b7d576e14b34ee929c093", "patch": "@@ -42,7 +42,7 @@ public:\n B A::compute(void) const\n {\n   B sub(*this, 1);\n-  return sub;\n+  return static_cast<B&>(sub);\n }\n \n int main ()"}]}