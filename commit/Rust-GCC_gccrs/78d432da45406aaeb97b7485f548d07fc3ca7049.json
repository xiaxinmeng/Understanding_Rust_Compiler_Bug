{"sha": "78d432da45406aaeb97b7485f548d07fc3ca7049", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhkNDMyZGE0NTQwNmFhZWI5N2I3NDg1ZjU0OGQwN2ZjM2NhNzA0OQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2013-07-08T08:19:20Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-07-08T08:19:20Z"}, "message": "einfo.adb (Get_Pragma): Handle the retrieval of delayed pragmas stored in N_Contract nodes.\n\n2013-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb (Get_Pragma): Handle the retrieval of delayed\n\tpragmas stored in N_Contract nodes.\n\t* einfo.ads (Get_Pragma): Update the comment on usage.\n\t* sem_prag.adb (Check_Precondition_Postcondition): Retain a copy\n\tof the pragma when it applies to a body that acts as a spec. The\n\tcopy is preanalyzed and chained on the contract of the body.\n\nFrom-SVN: r200774", "tree": {"sha": "7c0c51ec75e08539b1ae46df7140c5e3b9e335b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c0c51ec75e08539b1ae46df7140c5e3b9e335b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78d432da45406aaeb97b7485f548d07fc3ca7049", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d432da45406aaeb97b7485f548d07fc3ca7049", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78d432da45406aaeb97b7485f548d07fc3ca7049", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d432da45406aaeb97b7485f548d07fc3ca7049/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5884c232046e65f6b617ee69f34b4c90a31b68eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5884c232046e65f6b617ee69f34b4c90a31b68eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5884c232046e65f6b617ee69f34b4c90a31b68eb"}], "stats": {"total": 121, "additions": 103, "deletions": 18}, "files": [{"sha": "9178fc867142f4012698dc3d2bd84b6a1b4bdd5b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d432da45406aaeb97b7485f548d07fc3ca7049/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d432da45406aaeb97b7485f548d07fc3ca7049/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=78d432da45406aaeb97b7485f548d07fc3ca7049", "patch": "@@ -1,3 +1,12 @@\n+2013-07-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb (Get_Pragma): Handle the retrieval of delayed\n+\tpragmas stored in N_Contract nodes.\n+\t* einfo.ads (Get_Pragma): Update the comment on usage.\n+\t* sem_prag.adb (Check_Precondition_Postcondition): Retain a copy\n+\tof the pragma when it applies to a body that acts as a spec. The\n+\tcopy is preanalyzed and chained on the contract of the body.\n+\n 2013-07-08  Robert Dewar  <dewar@adacore.com>\n \n \t* rtsfind.adb: Minor comment fix."}, {"sha": "0ed05608afb13c50711a557622af69e0edb61ec9", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d432da45406aaeb97b7485f548d07fc3ca7049/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d432da45406aaeb97b7485f548d07fc3ca7049/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=78d432da45406aaeb97b7485f548d07fc3ca7049", "patch": "@@ -6280,19 +6280,58 @@ package body Einfo is\n    -- Get_Pragma --\n    ----------------\n \n-   function Get_Pragma (E  : Entity_Id; Id : Pragma_Id) return Node_Id\n-   is\n-      N : Node_Id;\n+   function Get_Pragma (E : Entity_Id; Id : Pragma_Id) return Node_Id is\n+      Is_CDG  : constant Boolean :=\n+                  Id = Pragma_Depends or else Id = Pragma_Global;\n+      Is_CTC  : constant Boolean :=\n+                  Id = Pragma_Contract_Cases or else Id = Pragma_Test_Case;\n+      Is_PPC  : constant Boolean :=\n+                  Id = Pragma_Precondition or else Id = Pragma_Postcondition;\n+      Delayed : constant Boolean := Is_CDG or else Is_CTC or else Is_PPC;\n+      Item    : Node_Id;\n+      Items   : Node_Id;\n \n    begin\n-      N := First_Rep_Item (E);\n-      while Present (N) loop\n-         if Nkind (N) = N_Pragma\n-           and then Get_Pragma_Id (Pragma_Name (N)) = Id\n+      --  Handle delayed pragmas that appear in N_Contract nodes. Those have to\n+      --  be extracted from their specialized list.\n+\n+      if Delayed then\n+         Items := Contract (E);\n+\n+         if No (Items) then\n+            return Empty;\n+\n+         elsif Is_CDG then\n+            Item := Classifications (Items);\n+\n+         elsif Is_CTC then\n+            Item := Contract_Test_Cases (Items);\n+\n+         else\n+            Item := Pre_Post_Conditions (Items);\n+         end if;\n+\n+      --  Regular pragmas\n+\n+      else\n+         Item := First_Rep_Item (E);\n+      end if;\n+\n+      while Present (Item) loop\n+         if Nkind (Item) = N_Pragma\n+           and then Get_Pragma_Id (Pragma_Name (Item)) = Id\n          then\n-            return N;\n+            return Item;\n+\n+         --  All nodes in N_Contract are chained using Next_Pragma\n+\n+         elsif Delayed then\n+            Item := Next_Pragma (Item);\n+\n+         --  Regular pragmas\n+\n          else\n-            Next_Rep_Item (N);\n+            Next_Rep_Item (Item);\n          end if;\n       end loop;\n "}, {"sha": "24bb12cf797c316666f13dc0ec360a1ca887e9f3", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d432da45406aaeb97b7485f548d07fc3ca7049/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d432da45406aaeb97b7485f548d07fc3ca7049/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=78d432da45406aaeb97b7485f548d07fc3ca7049", "patch": "@@ -7375,7 +7375,9 @@ package Einfo is\n    function Get_Pragma (E : Entity_Id; Id : Pragma_Id) return Node_Id;\n    --  Searches the Rep_Item chain for a given entity E, for an instance of\n    --  a pragma with the given pragma Id. If found, the value returned is the\n-   --  N_Pragma node, otherwise Empty is returned.\n+   --  N_Pragma node, otherwise Empty is returned. Delayed pragmas such as\n+   --  Precondition, Postcondition, Contract_Cases, Depends and Global appear\n+   --  in the N_Contract node of entity E and are also handled by this routine.\n \n    function Get_Record_Representation_Clause (E : Entity_Id) return Node_Id;\n    --  Searches the Rep_Item chain for a given entity E, for a record"}, {"sha": "4fe6c57a5bd0ada4f907ba6fe8c352bad2c89024", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d432da45406aaeb97b7485f548d07fc3ca7049/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d432da45406aaeb97b7485f548d07fc3ca7049/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=78d432da45406aaeb97b7485f548d07fc3ca7049", "patch": "@@ -3565,12 +3565,13 @@ package body Sem_Prag is\n          --  If we fall through loop, pragma is at start of list, so see if it\n          --  is at the start of declarations of a subprogram body.\n \n-         if Nkind (Parent (N)) = N_Subprogram_Body\n-           and then List_Containing (N) = Declarations (Parent (N))\n+         PO := Parent (N);\n+\n+         if Nkind (PO) = N_Subprogram_Body\n+           and then List_Containing (N) = Declarations (PO)\n          then\n-            if Operating_Mode /= Generate_Code\n-              or else Inside_A_Generic\n-            then\n+            if Operating_Mode /= Generate_Code or else Inside_A_Generic then\n+\n                --  Analyze pragma expression for correctness and for ASIS use\n \n                Preanalyze_Assert_Expression\n@@ -3585,22 +3586,56 @@ package body Sem_Prag is\n                end if;\n             end if;\n \n+            --  Retain a copy of the pre- or postcondition pragma for formal\n+            --  verification purposes. The copy is needed because the pragma is\n+            --  expanded into other constructs which are not acceptable in the\n+            --  N_Contract node.\n+\n+            if Acts_As_Spec (PO)\n+              and then (SPARK_Mode or else Formal_Extensions)\n+            then\n+               declare\n+                  Prag : constant Node_Id := New_Copy_Tree (N);\n+\n+               begin\n+                  --  Preanalyze the pragma\n+\n+                  Preanalyze_Assert_Expression\n+                    (Get_Pragma_Arg\n+                      (First (Pragma_Argument_Associations (Prag))),\n+                     Standard_Boolean);\n+\n+                  --  Preanalyze the corresponding aspect (if any)\n+\n+                  if Present (Corresponding_Aspect (Prag)) then\n+                     Preanalyze_Assert_Expression\n+                       (Expression (Corresponding_Aspect (Prag)),\n+                     Standard_Boolean);\n+                  end if;\n+\n+                  --  Chain the copy on the contract of the body\n+\n+                  Add_Contract_Item\n+                    (Prag, Defining_Unit_Name (Specification (PO)));\n+               end;\n+            end if;\n+\n             In_Body := True;\n             return;\n \n          --  See if it is in the pragmas after a library level subprogram\n \n-         elsif Nkind (Parent (N)) = N_Compilation_Unit_Aux then\n+         elsif Nkind (PO) = N_Compilation_Unit_Aux then\n \n             --  In formal verification mode, analyze pragma expression for\n             --  correctness, as it is not expanded later.\n \n             if SPARK_Mode then\n                Analyze_PPC_In_Decl_Part\n-                 (N, Defining_Entity (Unit (Parent (Parent (N)))));\n+                 (N, Defining_Entity (Unit (Parent (PO))));\n             end if;\n \n-            Chain_PPC (Unit (Parent (Parent (N))));\n+            Chain_PPC (Unit (Parent (PO)));\n             return;\n          end if;\n "}]}