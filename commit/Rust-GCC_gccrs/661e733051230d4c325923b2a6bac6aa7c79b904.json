{"sha": "661e733051230d4c325923b2a6bac6aa7c79b904", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjYxZTczMzA1MTIzMGQ0YzMyNTkyM2IyYTZiYWM2YWE3Yzc5YjkwNA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2009-11-18T14:10:02Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2009-11-18T14:10:02Z"}, "message": "ipa-prop.h (struct ipa_param_call_note): New field lto_stmt_uid.\n\n2009-11-18  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-prop.h (struct ipa_param_call_note): New field lto_stmt_uid.\n\t(lto_ipa_fixup_call_notes): Declare.\n\t* ipa-prop.c (ipa_note_param_call): Store gimple uid.\n\t(update_call_notes_after_inlining): Copy call stmt uid to the new\n\tedge.\n\t(ipa_write_param_call_note): New function.\n\t(ipa_read_param_call_note): New function\n\t(ipa_write_node_info): Write also param call notes.  Removed a bogus\n\tcomment, reformatted to fit 80 columns.\n\t(ipa_read_node_info): Read also param call notes. Removed a bogus\n\tcomment.  Remove ipa_edge_args_vector growth.\n\t(lto_ipa_fixup_call_notes): New function.\n\t* ipa-cp.c (pass_ipa_cp): Add stmt_fixup hook.\n\t* ipa-inline.c (cgraph_mark_inline_edge): Perform indirect\n\tinlining regardless of flag_wpa.\n\t(cgraph_decide_inlining_of_small_functions): Likewise.\n\t(cgraph_decide_inlining): Likewise.\n\t(inline_read_summary): Likewise.\n\nFrom-SVN: r154293", "tree": {"sha": "e8c86b76abdb454a38d3c0e0f799953c7b36fa05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e8c86b76abdb454a38d3c0e0f799953c7b36fa05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/661e733051230d4c325923b2a6bac6aa7c79b904", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/661e733051230d4c325923b2a6bac6aa7c79b904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/661e733051230d4c325923b2a6bac6aa7c79b904", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/661e733051230d4c325923b2a6bac6aa7c79b904/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "827c5be4f719bbd9cbee6d27baaa4276b80e9c1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/827c5be4f719bbd9cbee6d27baaa4276b80e9c1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/827c5be4f719bbd9cbee6d27baaa4276b80e9c1d"}], "stats": {"total": 134, "additions": 113, "deletions": 21}, "files": [{"sha": "07fbcf4520ccd15d8bc02382b23418fa73ea2453", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/661e733051230d4c325923b2a6bac6aa7c79b904/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/661e733051230d4c325923b2a6bac6aa7c79b904/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=661e733051230d4c325923b2a6bac6aa7c79b904", "patch": "@@ -1,3 +1,24 @@\n+2009-11-18  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* ipa-prop.h (struct ipa_param_call_note): New field lto_stmt_uid.\n+\t(lto_ipa_fixup_call_notes): Declare.\n+\t* ipa-prop.c (ipa_note_param_call): Store gimple uid.\n+\t(update_call_notes_after_inlining): Copy call stmt uid to the new\n+\tedge.\n+\t(ipa_write_param_call_note): New function.\n+\t(ipa_read_param_call_note): New function\n+\t(ipa_write_node_info): Write also param call notes.  Removed a bogus\n+\tcomment, reformatted to fit 80 columns.\n+\t(ipa_read_node_info): Read also param call notes. Removed a bogus\n+\tcomment.  Remove ipa_edge_args_vector growth.\n+\t(lto_ipa_fixup_call_notes): New function.\n+\t* ipa-cp.c (pass_ipa_cp): Add stmt_fixup hook.\n+\t* ipa-inline.c (cgraph_mark_inline_edge): Perform indirect\n+\tinlining regardless of flag_wpa.\n+\t(cgraph_decide_inlining_of_small_functions): Likewise.\n+\t(cgraph_decide_inlining): Likewise.\n+\t(inline_read_summary): Likewise.\n+\n 2009-11-18  Jan Hubicka  <jh@suse.cz>\n \n \t* predict.c (compute_function_frequency): Export."}, {"sha": "4b632c0d9fb52389d84a9a99e4516bfc00b0bf7f", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/661e733051230d4c325923b2a6bac6aa7c79b904/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/661e733051230d4c325923b2a6bac6aa7c79b904/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=661e733051230d4c325923b2a6bac6aa7c79b904", "patch": "@@ -1327,7 +1327,7 @@ struct ipa_opt_pass_d pass_ipa_cp =\n  ipcp_write_summary,\t\t\t/* write_summary */\n  ipcp_read_summary,\t\t\t/* read_summary */\n  NULL,\t\t\t\t\t/* function_read_summary */\n- NULL,\t\t\t\t\t/* stmt_fixup */\n+ lto_ipa_fixup_call_notes, \t\t/* stmt_fixup */\n  0,\t\t\t\t\t/* TODOs */\n  NULL,\t\t\t\t\t/* function_transform */\n  NULL,\t\t\t\t\t/* variable_transform */"}, {"sha": "786c21c0ca3da4c05689cd3866c39ffc5c9f0684", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/661e733051230d4c325923b2a6bac6aa7c79b904/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/661e733051230d4c325923b2a6bac6aa7c79b904/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=661e733051230d4c325923b2a6bac6aa7c79b904", "patch": "@@ -334,7 +334,7 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n     overall_size -= orig_size;\n   ncalls_inlined++;\n \n-  if (flag_indirect_inlining && !flag_wpa)\n+  if (flag_indirect_inlining)\n     return ipa_propagate_indirect_call_infos (curr, new_edges);\n   else\n     return false;\n@@ -900,7 +900,7 @@ cgraph_decide_inlining_of_small_functions (void)\n   int min_size, max_size;\n   VEC (cgraph_edge_p, heap) *new_indirect_edges = NULL;\n \n-  if (flag_indirect_inlining && !flag_wpa)\n+  if (flag_indirect_inlining)\n     new_indirect_edges = VEC_alloc (cgraph_edge_p, heap, 8);\n \n   if (dump_file)\n@@ -1047,10 +1047,10 @@ cgraph_decide_inlining_of_small_functions (void)\n \t  if (where->global.inlined_to)\n \t    where = where->global.inlined_to;\n \t  if (!cgraph_decide_recursive_inlining (where,\n-\t\t\t\t\t\t flag_indirect_inlining && !flag_wpa\n+\t\t\t\t\t\t flag_indirect_inlining\n \t\t\t\t\t\t ? &new_indirect_edges : NULL))\n \t    continue;\n-\t  if (flag_indirect_inlining && !flag_wpa)\n+\t  if (flag_indirect_inlining)\n \t    add_new_edges_to_heap (heap, new_indirect_edges);\n           update_callee_keys (heap, where, updated_nodes);\n \t}\n@@ -1069,7 +1069,7 @@ cgraph_decide_inlining_of_small_functions (void)\n \t    }\n \t  callee = edge->callee;\n \t  cgraph_mark_inline_edge (edge, true, &new_indirect_edges);\n-\t  if (flag_indirect_inlining && !flag_wpa)\n+\t  if (flag_indirect_inlining)\n \t    add_new_edges_to_heap (heap, new_indirect_edges);\n \n \t  update_callee_keys (heap, callee, updated_nodes);\n@@ -1138,7 +1138,7 @@ cgraph_decide_inlining (void)\n   int initial_size = 0;\n \n   cgraph_remove_function_insertion_hook (function_insertion_hook_holder);\n-  if (in_lto_p && flag_indirect_inlining && !flag_wpa)\n+  if (in_lto_p && flag_indirect_inlining)\n     ipa_update_after_lto_read ();\n \n   max_count = 0;\n@@ -1294,7 +1294,7 @@ cgraph_decide_inlining (void)\n     }\n \n   /* Free ipa-prop structures if they are no longer needed.  */\n-  if (flag_indirect_inlining && !flag_wpa)\n+  if (flag_indirect_inlining)\n     free_all_ipa_structures_after_iinln ();\n \n   if (dump_file)\n@@ -2001,7 +2001,7 @@ inline_transform (struct cgraph_node *node)\n static void \n inline_read_summary (void)\n {\n-  if (flag_indirect_inlining && !flag_wpa)\n+  if (flag_indirect_inlining)\n     {\n       ipa_register_cgraph_hooks ();\n       if (!flag_ipa_cp)\n@@ -2044,7 +2044,7 @@ struct ipa_opt_pass_d pass_ipa_inline =\n  inline_write_summary,\t\t\t/* write_summary */\n  inline_read_summary,\t\t\t/* read_summary */\n  NULL,\t\t\t\t\t/* function_read_summary */\n- NULL,\t\t\t\t\t/* stmt_fixup */\n+ lto_ipa_fixup_call_notes,\t\t/* stmt_fixup */\n  0,\t\t\t\t\t/* TODOs */\n  inline_transform,\t\t\t/* function_transform */\n  NULL,\t\t\t\t\t/* variable_transform */"}, {"sha": "7394f911771af5a1b837589eeb1eda3cfe0059ec", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 79, "deletions": 11, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/661e733051230d4c325923b2a6bac6aa7c79b904/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/661e733051230d4c325923b2a6bac6aa7c79b904/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=661e733051230d4c325923b2a6bac6aa7c79b904", "patch": "@@ -751,6 +751,7 @@ ipa_note_param_call (struct ipa_node_params *info, int formal_id,\n   note = XCNEW (struct ipa_param_call_note);\n   note->formal_id = formal_id;\n   note->stmt = stmt;\n+  note->lto_stmt_uid = gimple_uid (stmt);\n   note->count = bb->count;\n   note->frequency = compute_call_stmt_bb_frequency (current_function_decl, bb);\n \n@@ -1100,6 +1101,7 @@ update_call_notes_after_inlining (struct cgraph_edge *cs,\n \t  new_indirect_edge = cgraph_create_edge (node, callee, nt->stmt,\n \t\t\t\t\t\t  nt->count, nt->frequency,\n \t\t\t\t\t\t  nt->loop_nest);\n+\t  new_indirect_edge->lto_stmt_uid = nt->lto_stmt_uid;\n \t  new_indirect_edge->indirect_call = 1;\n \t  ipa_check_create_edge_args ();\n \t  if (new_edges)\n@@ -1961,6 +1963,40 @@ ipa_read_jump_function (struct lto_input_block *ib,\n     }\n }\n \n+/* Stream out a parameter call note.  */\n+\n+static void\n+ipa_write_param_call_note (struct output_block *ob,\n+\t\t\t   struct ipa_param_call_note *note)\n+{\n+  gcc_assert (!note->processed);\n+  lto_output_uleb128_stream (ob->main_stream, gimple_uid (note->stmt));\n+  lto_output_sleb128_stream (ob->main_stream, note->formal_id);\n+  lto_output_sleb128_stream (ob->main_stream, note->count);\n+  lto_output_sleb128_stream (ob->main_stream, note->frequency);\n+  lto_output_sleb128_stream (ob->main_stream, note->loop_nest);\n+}\n+\n+/* Read in a parameter call note.  */\n+\n+static void\n+ipa_read_param_call_note (struct lto_input_block *ib,\n+\t\t\t  struct ipa_node_params *info)\n+\n+{\n+  struct ipa_param_call_note *note = XCNEW (struct ipa_param_call_note);\n+\n+  note->lto_stmt_uid = (unsigned int) lto_input_uleb128 (ib);\n+  note->formal_id = (int) lto_input_sleb128 (ib);\n+  note->count = (gcov_type) lto_input_sleb128 (ib);\n+  note->frequency = (int) lto_input_sleb128 (ib);\n+  note->loop_nest = (int) lto_input_sleb128 (ib);\n+\n+  note->next = info->param_calls;\n+  info->param_calls = note;\n+}\n+\n+\n /* Stream out NODE info to OB.  */\n \n static void\n@@ -1972,16 +2008,17 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n   int j;\n   struct cgraph_edge *e;\n   struct bitpack_d *bp;\n+  int note_count;\n+  struct ipa_param_call_note *note;\n \n   encoder = ob->decl_state->cgraph_node_encoder;\n   node_ref = lto_cgraph_encoder_encode (encoder, node);\n   lto_output_uleb128_stream (ob->main_stream, node_ref);\n \n-  /* Note that flags will need to be read in the opposite\n-     order as we are pushing the bitflags into FLAGS.  */\n   bp = bitpack_create ();\n   bp_pack_value (bp, info->called_with_var_arguments, 1);\n-  gcc_assert (info->modification_analysis_done || ipa_get_param_count (info) == 0);\n+  gcc_assert (info->modification_analysis_done\n+\t      || ipa_get_param_count (info) == 0);\n   gcc_assert (info->uses_analysis_done || ipa_get_param_count (info) == 0);\n   gcc_assert (!info->node_enqueued);\n   gcc_assert (!info->ipcp_orig_node);\n@@ -1996,10 +2033,17 @@ ipa_write_node_info (struct output_block *ob, struct cgraph_node *node)\n     {\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n \n-      lto_output_uleb128_stream (ob->main_stream, ipa_get_cs_argument_count (args));\n+      lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t\t ipa_get_cs_argument_count (args));\n       for (j = 0; j < ipa_get_cs_argument_count (args); j++)\n \tipa_write_jump_function (ob, ipa_get_ith_jump_func (args, j));\n     }\n+\n+  for (note = info->param_calls; note; note = note->next)\n+    note_count++;\n+  lto_output_uleb128_stream (ob->main_stream, note_count);\n+  for (note = info->param_calls; note; note = note->next)\n+    ipa_write_param_call_note (ob, note);\n }\n \n /* Srtream in NODE info from IB.  */\n@@ -2012,12 +2056,10 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n   int k;\n   struct cgraph_edge *e;\n   struct bitpack_d *bp;\n+  int i, note_count;\n \n   ipa_initialize_node_params (node);\n \n-  /* Note that the flags must be read in the opposite\n-     order in which they were written (the bitflags were\n-     pushed into FLAGS).  */\n   bp = lto_input_bitpack (ib);\n   info->called_with_var_arguments = bp_unpack_value (bp, 1);\n   if (ipa_get_param_count (info) != 0)\n@@ -2037,10 +2079,6 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n       struct ipa_edge_args *args = IPA_EDGE_REF (e);\n       int count = lto_input_uleb128 (ib);\n \n-      if (VEC_length (ipa_edge_args_t, ipa_edge_args_vector)\n-\t  <= (unsigned) cgraph_edge_max_uid)\n-\tVEC_safe_grow_cleared (ipa_edge_args_t, gc,\n-\t\t\t       ipa_edge_args_vector, cgraph_edge_max_uid + 1);\n       ipa_set_cs_argument_count (args, count);\n       if (!count)\n \tcontinue;\n@@ -2050,6 +2088,10 @@ ipa_read_node_info (struct lto_input_block *ib, struct cgraph_node *node,\n       for (k = 0; k < ipa_get_cs_argument_count (args); k++)\n \tipa_read_jump_function (ib, ipa_get_ith_jump_func (args, k), data_in);\n     }\n+\n+  note_count = lto_input_uleb128 (ib);\n+  for (i = 0; i < note_count; i++)\n+    ipa_read_param_call_note (ib, info);\n }\n \n /* Write jump functions for nodes in SET.  */\n@@ -2174,3 +2216,29 @@ ipa_update_after_lto_read (void)\n \t}\n     }\n }\n+\n+/* Walk param call notes of NODE and set their call statements given the uid\n+   stored in each note and STMTS which is an array of statements indexed by the\n+   uid.  */\n+\n+void\n+lto_ipa_fixup_call_notes (struct cgraph_node *node, gimple *stmts)\n+{\n+  struct ipa_node_params *info;\n+  struct ipa_param_call_note *note;\n+\n+  ipa_check_create_node_params ();\n+  info = IPA_NODE_REF (node);\n+  note = info->param_calls;\n+  /* If there are no notes or they have already been fixed up (the same fixup\n+     is called for both inlining and ipa-cp), there's nothing to do. */\n+  if (!note || note->stmt)\n+    return;\n+\n+  do\n+    {\n+      note->stmt = stmts[note->lto_stmt_uid];\n+      note = note->next;\n+    }\n+  while (note);\n+}"}, {"sha": "4dc87d785030237364ae61ee3fcb10a3b1693d35", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/661e733051230d4c325923b2a6bac6aa7c79b904/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/661e733051230d4c325923b2a6bac6aa7c79b904/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=661e733051230d4c325923b2a6bac6aa7c79b904", "patch": "@@ -143,6 +143,8 @@ struct ipa_param_call_note\n   struct ipa_param_call_note *next;\n   /* Statement that contains the call to the parameter above.  */\n   gimple stmt;\n+  /* When in LTO, we the above stmt will be NULL and we need an uid. */\n+  unsigned int lto_stmt_uid;\n   /* Index of the parameter that is called.  */\n   int formal_id;\n   /* Expected number of executions: calculated in profile.c.  */\n@@ -508,6 +510,7 @@ void ipa_dump_param_adjustments (FILE *, ipa_parm_adjustment_vec, tree);\n void ipa_prop_write_jump_functions (cgraph_node_set set);\n void ipa_prop_read_jump_functions (void);\n void ipa_update_after_lto_read (void);\n+void lto_ipa_fixup_call_notes (struct cgraph_node *, gimple *);\n \n /* From tree-sra.c:  */\n bool build_ref_for_offset (tree *, tree, HOST_WIDE_INT, tree, bool);"}]}