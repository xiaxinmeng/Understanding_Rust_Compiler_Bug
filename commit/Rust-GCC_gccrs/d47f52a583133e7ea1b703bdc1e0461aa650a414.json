{"sha": "d47f52a583133e7ea1b703bdc1e0461aa650a414", "node_id": "C_kwDOANBUbNoAKGQ0N2Y1MmE1ODMxMzNlN2VhMWI3MDNiZGMxZTA0NjFhYTY1MGE0MTQ", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-05-23T16:55:32Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-05-26T16:28:04Z"}, "message": "gccrs: support deref cycles to resolve to trait items\n\nFixes #2190\n\ngcc/rust/ChangeLog:\n\n\t* backend/rust-compile-expr.cc (HIRCompileBase::resolve_deref_adjustment):\n\treuse op overload code\n\t* typecheck/rust-autoderef.cc (Adjuster::try_deref_type): update\n\t(Adjuster::try_raw_deref_type): likewise\n\t* typecheck/rust-autoderef.h: likewise\n\t* typecheck/rust-hir-dot-operator.cc (MethodResolver::select):\n\timprove debug loging\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/issue-2190-1.rs: New test.\n\t* rust/compile/issue-2190-2.rs: New test.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "2f71627c5274a15229e55d69eca9c992b4a98fb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f71627c5274a15229e55d69eca9c992b4a98fb8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d47f52a583133e7ea1b703bdc1e0461aa650a414", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d47f52a583133e7ea1b703bdc1e0461aa650a414", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d47f52a583133e7ea1b703bdc1e0461aa650a414", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d47f52a583133e7ea1b703bdc1e0461aa650a414/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e656f08b6f7794c0c04a808fec50ea9a079577c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e656f08b6f7794c0c04a808fec50ea9a079577c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e656f08b6f7794c0c04a808fec50ea9a079577c7"}], "stats": {"total": 168, "additions": 106, "deletions": 62}, "files": [{"sha": "b35db09190c2351ef67b2e0c7095eda087abf3a9", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=d47f52a583133e7ea1b703bdc1e0461aa650a414", "patch": "@@ -2367,15 +2367,8 @@ HIRCompileBase::resolve_deref_adjustment (Resolver::Adjustment &adjustment,\n   rust_assert (adjustment.has_operator_overload ());\n \n   TyTy::FnType *lookup = adjustment.get_deref_operator_fn ();\n-  HIR::ImplItem *resolved_item = adjustment.get_deref_hir_item ();\n-\n-  tree fn_address = error_mark_node;\n-  if (!lookup->has_subsititions_defined ())\n-    fn_address = CompileInherentImplItem::Compile (resolved_item, ctx, nullptr,\n-\t\t\t\t\t\t   true, locus);\n-  else\n-    fn_address = CompileInherentImplItem::Compile (resolved_item, ctx, lookup,\n-\t\t\t\t\t\t   true, locus);\n+  TyTy::BaseType *receiver = adjustment.get_actual ();\n+  tree fn_address = resolve_method_address (lookup, receiver, locus);\n \n   // does it need a reference to call\n   tree adjusted_argument = expression;"}, {"sha": "4ad0904b1d0109008cb00fa82b108f1d72909cc3", "filename": "gcc/rust/typecheck/rust-autoderef.cc", "status": "modified", "additions": 66, "deletions": 40, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.cc?ref=d47f52a583133e7ea1b703bdc1e0461aa650a414", "patch": "@@ -28,7 +28,7 @@ namespace Resolver {\n static bool\n resolve_operator_overload_fn (\n   Analysis::RustLangItem::ItemType lang_item_type, TyTy::BaseType *ty,\n-  TyTy::FnType **resolved_fn, HIR::ImplItem **impl_item,\n+  TyTy::FnType **resolved_fn,\n   Adjustment::AdjustmentType *requires_ref_adjustment);\n \n TyTy::BaseType *\n@@ -44,19 +44,18 @@ Adjustment\n Adjuster::try_deref_type (TyTy::BaseType *ty,\n \t\t\t  Analysis::RustLangItem::ItemType deref_lang_item)\n {\n-  HIR::ImplItem *impl_item = nullptr;\n   TyTy::FnType *fn = nullptr;\n   Adjustment::AdjustmentType requires_ref_adjustment\n     = Adjustment::AdjustmentType::ERROR;\n   bool operator_overloaded\n-    = resolve_operator_overload_fn (deref_lang_item, ty, &fn, &impl_item,\n+    = resolve_operator_overload_fn (deref_lang_item, ty, &fn,\n \t\t\t\t    &requires_ref_adjustment);\n   if (!operator_overloaded)\n     {\n       return Adjustment::get_error ();\n     }\n \n-  auto resolved_base = fn->get_return_type ()->clone ();\n+  auto resolved_base = fn->get_return_type ()->destructure ();\n   bool is_valid_type = resolved_base->get_kind () == TyTy::TypeKind::REF;\n   if (!is_valid_type)\n     return Adjustment::get_error ();\n@@ -81,7 +80,7 @@ Adjuster::try_deref_type (TyTy::BaseType *ty,\n     }\n \n   return Adjustment::get_op_overload_deref_adjustment (adjustment_type, ty,\n-\t\t\t\t\t\t       ref_base, fn, impl_item,\n+\t\t\t\t\t\t       ref_base, fn,\n \t\t\t\t\t\t       requires_ref_adjustment);\n }\n \n@@ -94,7 +93,7 @@ Adjuster::try_raw_deref_type (TyTy::BaseType *ty)\n \n   const TyTy::ReferenceType *ref_base\n     = static_cast<const TyTy::ReferenceType *> (ty);\n-  auto infered = ref_base->get_base ()->clone ();\n+  auto infered = ref_base->get_base ()->destructure ();\n \n   return Adjustment (Adjustment::AdjustmentType::INDIRECTION, ty, infered);\n }\n@@ -122,8 +121,8 @@ Adjuster::try_unsize_type (TyTy::BaseType *ty)\n \n static bool\n resolve_operator_overload_fn (\n-  Analysis::RustLangItem::ItemType lang_item_type, TyTy::BaseType *ty,\n-  TyTy::FnType **resolved_fn, HIR::ImplItem **impl_item,\n+  Analysis::RustLangItem::ItemType lang_item_type, TyTy::BaseType *lhs,\n+  TyTy::FnType **resolved_fn,\n   Adjustment::AdjustmentType *requires_ref_adjustment)\n {\n   auto context = TypeCheckContext::get ();\n@@ -139,35 +138,69 @@ resolve_operator_overload_fn (\n   if (!lang_item_defined)\n     return false;\n \n+  // we might be in a static or const context and unknown is fine\n+  TypeCheckContextItem current_context = TypeCheckContextItem::get_error ();\n+  if (context->have_function_context ())\n+    {\n+      current_context = context->peek_context ();\n+    }\n+\n+  // this flags stops recurisve calls to try and deref when none is available\n+  // which will cause an infinite loop\n+  bool autoderef_flag = true;\n   auto segment = HIR::PathIdentSegment (associated_item_name);\n-  auto candidates\n-    = MethodResolver::Probe (ty, HIR::PathIdentSegment (associated_item_name),\n-\t\t\t     true);\n+  auto candidates = MethodResolver::Probe (lhs, segment, autoderef_flag);\n+\n+  // remove any recursive candidates\n+  std::set<MethodCandidate> resolved_candidates;\n+  for (auto &c : candidates)\n+    {\n+      const TyTy::BaseType *candidate_type = c.candidate.ty;\n+      rust_assert (candidate_type->get_kind () == TyTy::TypeKind::FNDEF);\n+\n+      const TyTy::FnType &fn\n+\t= *static_cast<const TyTy::FnType *> (candidate_type);\n \n-  bool have_implementation_for_lang_item = !candidates.empty ();\n+      DefId current_fn_defid = current_context.get_defid ();\n+      bool recursive_candidated = fn.get_id () == current_fn_defid;\n+      if (!recursive_candidated)\n+\t{\n+\t  resolved_candidates.insert (c);\n+\t}\n+    }\n+\n+  bool have_implementation_for_lang_item = resolved_candidates.size () > 0;\n   if (!have_implementation_for_lang_item)\n     return false;\n \n-  // multiple candidates?\n-  if (candidates.size () > 1)\n+  if (resolved_candidates.size () > 1)\n     {\n-      // error out? probably not for this case\n+      // no need to error out as we are just trying to see if there is a fit\n       return false;\n     }\n \n   // Get the adjusted self\n-  auto candidate = *candidates.begin ();\n-  Adjuster adj (ty);\n+  MethodCandidate candidate = *resolved_candidates.begin ();\n+  Adjuster adj (lhs);\n   TyTy::BaseType *adjusted_self = adj.adjust_type (candidate.adjustments);\n \n-  // is this the case we are recursive\n-  // handle the case where we are within the impl block for this\n-  // lang_item otherwise we end up with a recursive operator overload\n-  // such as the i32 operator overload trait\n-  TypeCheckContextItem fn_context = context->peek_context ();\n-  if (fn_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n+  PathProbeCandidate &resolved_candidate = candidate.candidate;\n+  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n+  rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::BaseType *lookup = lookup_tyty;\n+  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n+  rust_assert (fn->is_method ());\n+\n+  rust_debug (\"is_impl_item_candidate: %s\",\n+\t      resolved_candidate.is_impl_candidate () ? \"true\" : \"false\");\n+\n+  // in the case where we resolve to a trait bound we have to be careful we are\n+  // able to do so there is a case where we are currently resolving the deref\n+  // operator overload function which is generic and this might resolve to the\n+  // trait item of deref which is not valid as its just another recursive case\n+  if (current_context.get_type () == TypeCheckContextItem::ItemType::IMPL_ITEM)\n     {\n-      auto &impl_item = fn_context.get_impl_item ();\n+      auto &impl_item = current_context.get_impl_item ();\n       HIR::ImplBlock *parent = impl_item.first;\n       HIR::Function *fn = impl_item.second;\n \n@@ -201,24 +234,17 @@ resolve_operator_overload_fn (\n \t}\n     }\n \n-  TyTy::BaseType *lookup_tyty = candidate.candidate.ty;\n-\n-  // rust only support impl item deref operator overloading ie you must have an\n-  // impl block for it\n-  rust_assert (candidate.candidate.type\n-\t       == PathProbeCandidate::CandidateType::IMPL_FUNC);\n-  *impl_item = candidate.candidate.item.impl.impl_item;\n-\n-  rust_assert (lookup_tyty->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::BaseType *lookup = lookup_tyty;\n-  TyTy::FnType *fn = static_cast<TyTy::FnType *> (lookup);\n-  rust_assert (fn->is_method ());\n+  // we found a valid operator overload\n+  fn->prepare_higher_ranked_bounds ();\n+  rust_debug (\"resolved operator overload to: {%u} {%s}\",\n+\t      candidate.candidate.ty->get_ref (),\n+\t      candidate.candidate.ty->debug_str ().c_str ());\n \n   if (fn->needs_substitution ())\n     {\n-      if (ty->get_kind () == TyTy::TypeKind::ADT)\n+      if (lhs->get_kind () == TyTy::TypeKind::ADT)\n \t{\n-\t  const TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (ty);\n+\t  const TyTy::ADTType *adt = static_cast<const TyTy::ADTType *> (lhs);\n \n \t  auto s = fn->get_self_type ()->get_root ();\n \t  rust_assert (s->can_eq (adt, false));\n@@ -265,8 +291,8 @@ resolve_operator_overload_fn (\n \t  rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n \t  fn = static_cast<TyTy::FnType *> (lookup);\n \n-\t  Location unify_locus = mappings->lookup_location (ty->get_ref ());\n-\t  unify_site (ty->get_ref (),\n+\t  Location unify_locus = mappings->lookup_location (lhs->get_ref ());\n+\t  unify_site (lhs->get_ref (),\n \t\t      TyTy::TyWithLocation (fn->get_self_type ()),\n \t\t      TyTy::TyWithLocation (adjusted_self), unify_locus);\n "}, {"sha": "74e7c5f3b3c8380cf4996acd2981cc6127b1cdf7", "filename": "gcc/rust/typecheck/rust-autoderef.h", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-autoderef.h?ref=d47f52a583133e7ea1b703bdc1e0461aa650a414", "patch": "@@ -42,18 +42,15 @@ class Adjustment\n   // ctor for all adjustments except derefs\n   Adjustment (AdjustmentType type, TyTy::BaseType *actual,\n \t      TyTy::BaseType *expected)\n-    : Adjustment (type, actual, expected, nullptr, nullptr,\n-\t\t  AdjustmentType::ERROR)\n+    : Adjustment (type, actual, expected, nullptr, AdjustmentType::ERROR)\n   {}\n \n   static Adjustment get_op_overload_deref_adjustment (\n     AdjustmentType type, TyTy::BaseType *actual, TyTy::BaseType *expected,\n-    TyTy::FnType *fn, HIR::ImplItem *deref_item,\n-    Adjustment::AdjustmentType requires_ref_adjustment)\n+    TyTy::FnType *fn, Adjustment::AdjustmentType requires_ref_adjustment)\n   {\n     rust_assert (type == DEREF || type == DEREF_MUT);\n-    return Adjustment (type, actual, expected, fn, deref_item,\n-\t\t       requires_ref_adjustment);\n+    return Adjustment (type, actual, expected, fn, requires_ref_adjustment);\n   }\n \n   AdjustmentType get_type () const { return type; }\n@@ -107,15 +104,12 @@ class Adjustment\n     return requires_ref_adjustment;\n   }\n \n-  HIR::ImplItem *get_deref_hir_item () const { return deref_item; }\n-\n private:\n   Adjustment (AdjustmentType type, TyTy::BaseType *actual,\n \t      TyTy::BaseType *expected, TyTy::FnType *deref_operator_fn,\n-\t      HIR::ImplItem *deref_item,\n \t      Adjustment::AdjustmentType requires_ref_adjustment)\n     : type (type), actual (actual), expected (expected),\n-      deref_operator_fn (deref_operator_fn), deref_item (deref_item),\n+      deref_operator_fn (deref_operator_fn),\n       requires_ref_adjustment (requires_ref_adjustment)\n   {}\n \n@@ -127,7 +121,6 @@ class Adjustment\n   //\n   // the fn that we are calling\n   TyTy::FnType *deref_operator_fn;\n-  HIR::ImplItem *deref_item;\n   // operator overloads can requre a reference\n   Adjustment::AdjustmentType requires_ref_adjustment;\n };"}, {"sha": "323902947cfb3fdd8aabda344e560d05b393dbcd", "filename": "gcc/rust/typecheck/rust-hir-dot-operator.cc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-dot-operator.cc?ref=d47f52a583133e7ea1b703bdc1e0461aa650a414", "patch": "@@ -66,8 +66,9 @@ MethodResolver::try_hook (const TyTy::BaseType &r)\n bool\n MethodResolver::select (TyTy::BaseType &receiver)\n {\n-  rust_debug (\"MethodResolver::select reciever=[%s]\",\n-\t      receiver.debug_str ().c_str ());\n+  rust_debug (\"MethodResolver::select reciever=[%s] path=[%s]\",\n+\t      receiver.debug_str ().c_str (),\n+\t      segment_name.as_string ().c_str ());\n \n   struct impl_item_candidate\n   {"}, {"sha": "85091b22e3b6cb95a7aea4398da7186f1a68c582", "filename": "gcc/testsuite/rust/compile/issue-2190-1.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2190-1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2190-1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2190-1.rs?ref=d47f52a583133e7ea1b703bdc1e0461aa650a414", "patch": "@@ -0,0 +1,11 @@\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+fn foo<T: Deref<Target = i32>>(t: &T) -> i32 {\n+    t.max(2)\n+    // { dg-error \"failed to resolve method for .max.\" \"\" { target *-*-* } .-1 }\n+    // { dg-error \"failed to type resolve expression\" \"\" { target *-*-* } .-2 }\n+}"}, {"sha": "48ab72b92001afc565d26cae972ef7fc6d370e54", "filename": "gcc/testsuite/rust/compile/issue-2190-2.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2190-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d47f52a583133e7ea1b703bdc1e0461aa650a414/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2190-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2190-2.rs?ref=d47f52a583133e7ea1b703bdc1e0461aa650a414", "patch": "@@ -0,0 +1,20 @@\n+// { dg-options \"-w\" }\n+#[lang = \"deref\"]\n+trait Deref {\n+    type Target;\n+    fn deref(&self) -> &Self::Target;\n+}\n+\n+fn foo<T: Deref<Target = i32>>(t: &T) -> i32 {\n+    t.max(2)\n+}\n+\n+impl i32 {\n+    fn max(self, other: i32) -> i32 {\n+        if self > other {\n+            self\n+        } else {\n+            other\n+        }\n+    }\n+}"}]}