{"sha": "7e4fb06a5182286640bf73410d09ab324c5e73ad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U0ZmIwNmE1MTgyMjg2NjQwYmY3MzQxMGQwOWFiMzI0YzVlNzNhZA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-06-27T17:52:03Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2003-06-27T17:52:03Z"}, "message": "alpha.c (function_arg): Don't pass small aggregates in floating point registers.\n\n        * config/alpha/alpha.c (function_arg): Don't pass small aggregates\n        in floating point registers.  Validate that we don't receive complex\n        values here.  Use #elif.\n        (return_in_memory, function_value): New.\n        (alpha_va_arg): Handle complex values as two arguments.\n        * config/alpha/alpha.h (RETURN_IN_MEMORY): Use return_in_memory.\n        (FUNCTION_VALUE, LIBCALL_VALUE): Use function_value.\n        (SPLIT_COMPLEX_ARGS): New.\n        * config/alpha/alpha-protos.h: Update.\n\nFrom-SVN: r68591", "tree": {"sha": "49762bdb5dbf79cca9a0994dd11b48b208a92a1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/49762bdb5dbf79cca9a0994dd11b48b208a92a1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e4fb06a5182286640bf73410d09ab324c5e73ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4fb06a5182286640bf73410d09ab324c5e73ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e4fb06a5182286640bf73410d09ab324c5e73ad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e4fb06a5182286640bf73410d09ab324c5e73ad/comments", "author": null, "committer": null, "parents": [{"sha": "75d75435b640d134ed3b195e1d3b068bbf1fc6ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75d75435b640d134ed3b195e1d3b068bbf1fc6ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75d75435b640d134ed3b195e1d3b068bbf1fc6ba"}], "stats": {"total": 207, "additions": 174, "deletions": 33}, "files": [{"sha": "9d71ea635e6ae6eee2f780cc301742dd2f304f36", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4fb06a5182286640bf73410d09ab324c5e73ad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4fb06a5182286640bf73410d09ab324c5e73ad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7e4fb06a5182286640bf73410d09ab324c5e73ad", "patch": "@@ -1,4 +1,16 @@\n-2003-06-13  Ulrich Weigand  <uweigand@de.ibm.com>\n+2003-06-27  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/alpha/alpha.c (function_arg): Don't pass small aggregates\n+\tin floating point registers.  Validate that we don't receive complex\n+\tvalues here.  Use #elif.\n+\t(return_in_memory, function_value): New.\n+\t(alpha_va_arg): Handle complex values as two arguments.\n+\t* config/alpha/alpha.h (RETURN_IN_MEMORY): Use return_in_memory.\n+\t(FUNCTION_VALUE, LIBCALL_VALUE): Use function_value.\n+\t(SPLIT_COMPLEX_ARGS): New.\n+\t* config/alpha/alpha-protos.h: Update.\n+\n+2003-06-27  Ulrich Weigand  <uweigand@de.ibm.com>\n \n         * ggc-page.c (inverse_table): Change type of mult to size_t.\n         (compute_inverse): Compute inverse using size_t, not unsigned int."}, {"sha": "0e14e6b2da362f607b97f7749085b4fc0cb8a924", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4fb06a5182286640bf73410d09ab324c5e73ad/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4fb06a5182286640bf73410d09ab324c5e73ad/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=7e4fb06a5182286640bf73410d09ab324c5e73ad", "patch": "@@ -135,6 +135,9 @@ extern void alpha_setup_incoming_varargs (CUMULATIVE_ARGS, enum machine_mode,\n extern void alpha_va_start (tree, rtx);\n extern rtx alpha_va_arg (tree, tree);\n extern rtx function_arg (CUMULATIVE_ARGS, enum machine_mode, tree, int);\n+extern rtx function_value (tree, tree, enum machine_mode);\n+extern bool return_in_memory (tree, enum machine_mode);\n+\n extern void alpha_start_function (FILE *, const char *, tree);\n extern void alpha_end_function (FILE *, const char *, tree);\n "}, {"sha": "d1b884fa780fdcf36cf44e21e4cd95c26568fb3b", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 150, "deletions": 13, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4fb06a5182286640bf73410d09ab324c5e73ad/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4fb06a5182286640bf73410d09ab324c5e73ad/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=7e4fb06a5182286640bf73410d09ab324c5e73ad", "patch": "@@ -5864,14 +5864,25 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n   int basereg;\n   int num_args;\n \n-  /* Set up defaults for FP operands passed in FP registers, and\n-     integral operands passed in integer registers.  */\n-  if (TARGET_FPREGS\n-      && (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-\t  || GET_MODE_CLASS (mode) == MODE_FLOAT))\n-    basereg = 32 + 16;\n-  else\n+  /* Don't get confused and pass small structures in FP registers.  */\n+  if (type && AGGREGATE_TYPE_P (type))\n     basereg = 16;\n+  else\n+    {\n+#ifdef ENABLE_CHECKING\n+      /* With SPLIT_COMPLEX_ARGS, we shouldn't see any raw complex\n+\t values here.  */\n+      if (COMPLEX_MODE_P (mode))\n+\tabort ();\n+#endif\n+\n+      /* Set up defaults for FP operands passed in FP registers, and\n+\t integral operands passed in integer registers.  */\n+      if (TARGET_FPREGS && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+\tbasereg = 32 + 16;\n+      else\n+\tbasereg = 16;\n+    }\n \n   /* ??? Irritatingly, the definition of CUMULATIVE_ARGS is different for\n      the three platforms, so we can't avoid conditional compilation.  */\n@@ -5884,8 +5895,7 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n       if (num_args >= 6 || MUST_PASS_IN_STACK (mode, type))\n \treturn NULL_RTX;\n     }\n-#else\n-#if TARGET_ABI_UNICOSMK\n+#elif TARGET_ABI_UNICOSMK\n     {\n       int size;\n \n@@ -5949,7 +5959,7 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n \t    }\n \t}\n     }\n-#else\n+#elif TARGET_ABI_OSF\n     {\n       if (cum >= 6)\n \treturn NULL_RTX;\n@@ -5963,12 +5973,119 @@ function_arg (CUMULATIVE_ARGS cum, enum machine_mode mode, tree type,\n       else if (FUNCTION_ARG_PASS_BY_REFERENCE (cum, mode, type, named))\n \tbasereg = 16;\n     }\n-#endif /* TARGET_ABI_UNICOSMK */\n-#endif /* TARGET_ABI_OPEN_VMS */\n+#else\n+#error Unhandled ABI\n+#endif\n \n   return gen_rtx_REG (mode, num_args + basereg);\n }\n \n+/* Return true if TYPE must be returned in memory, instead of in registers.  */\n+\n+bool\n+return_in_memory (tree type, enum machine_mode mode)\n+{\n+  int size;\n+\n+  if (type)\n+    {\n+      mode = TYPE_MODE (type);\n+\n+      /* All aggregates are returned in memory.  */\n+      if (AGGREGATE_TYPE_P (type))\n+\treturn true;\n+    }\n+\n+  size = GET_MODE_SIZE (mode);\n+  switch (GET_MODE_CLASS (mode))\n+    {\n+    case MODE_VECTOR_FLOAT:\n+      /* Pass all float vectors in memory, like an aggregate.  */\n+      return true;\n+\n+    case MODE_COMPLEX_FLOAT:\n+      /* We judge complex floats on the size of their element,\n+\t not the size of the whole type.  */\n+      size = GET_MODE_UNIT_SIZE (mode);\n+      break;\n+\n+    case MODE_INT:\n+    case MODE_FLOAT:\n+    case MODE_COMPLEX_INT:\n+    case MODE_VECTOR_INT:\n+      break;\n+\n+    default:\n+      /* ??? We get called on all sorts of random stuff from \n+\t aggregate_value_p.  We can't abort, but it's not clear\n+\t what's safe to return.  Pretend it's a struct I guess.  */\n+      return true;\n+    }\n+\n+  /* Otherwise types must fit in one register.  */\n+  return size > UNITS_PER_WORD;\n+}\n+\n+/* Define how to find the value returned by a function.  VALTYPE is the\n+   data type of the value (as a tree).  If the precise function being\n+   called is known, FUNC is its FUNCTION_DECL; otherwise, FUNC is 0.\n+   MODE is set instead of VALTYPE for libcalls.\n+\n+   On Alpha the value is found in $0 for integer functions and\n+   $f0 for floating-point functions.  */\n+\n+rtx\n+function_value (tree valtype, tree func ATTRIBUTE_UNUSED,\n+\t\tenum machine_mode mode)\n+{\n+  unsigned int regnum;\n+  enum mode_class class;\n+\n+#ifdef ENABLE_CHECKING\n+  if (return_in_memory (valtype, mode))\n+    abort ();\n+#endif\n+\n+  if (valtype)\n+    mode = TYPE_MODE (valtype);\n+\n+  class = GET_MODE_CLASS (mode);\n+  switch (class)\n+    {\n+    case MODE_INT:\n+      /* Do the same thing as PROMOTE_MODE.  */\n+      mode = DImode;\n+      /* FALLTHRU */\n+\n+    case MODE_COMPLEX_INT:\n+    case MODE_VECTOR_INT:\n+      regnum = 0;\n+      break;\n+\n+    case MODE_FLOAT:\n+      regnum = 32;\n+      break;\n+\n+    case MODE_COMPLEX_FLOAT:\n+      {\n+\tenum machine_mode cmode = GET_MODE_INNER (mode);\n+\n+\treturn gen_rtx_PARALLEL\n+\t  (VOIDmode,\n+\t   gen_rtvec (2,\n+\t\t      gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_REG (cmode, 32),\n+\t\t\t\t         GEN_INT (0)),\n+\t\t      gen_rtx_EXPR_LIST (VOIDmode, gen_rtx_REG (cmode, 33),\n+\t\t\t\t         GEN_INT (GET_MODE_SIZE (cmode)))));\n+      }\n+\n+    default:\n+      abort ();\n+    }\n+\n+  return gen_rtx_REG (mode, regnum);\n+}\n+\n tree\n alpha_build_va_list (void)\n {\n@@ -6162,7 +6279,27 @@ alpha_va_arg (tree valist, tree type)\n       indirect = 1;\n       rounded_size = size_int (UNITS_PER_WORD);\n     }\n-  else if (FLOAT_TYPE_P (type))\n+  else if (TREE_CODE (type) == COMPLEX_TYPE)\n+    {\n+      rtx real_part, imag_part, value, tmp;\n+\n+      real_part = alpha_va_arg (valist, TREE_TYPE (type));\n+      imag_part = alpha_va_arg (valist, TREE_TYPE (type));\n+\n+      /* ??? Most irritatingly, we're not returning the value here,\n+\t but the address.  Since real_part and imag_part are not\n+\t necessarily contiguous, we must copy to local storage.  */\n+\n+      real_part = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (type)), real_part);\n+      imag_part = gen_rtx_MEM (TYPE_MODE (TREE_TYPE (type)), imag_part);\n+      value = gen_rtx_CONCAT (TYPE_MODE (type), real_part, imag_part);\n+\n+      tmp = assign_temp (type, 0, 1, 0);\n+      emit_move_insn (tmp, value);\n+\n+      return XEXP (tmp, 0);\n+    }\n+  else if (TREE_CODE (type) == REAL_TYPE)\n     {\n       tree fpaddend, cond;\n "}, {"sha": "267d292a17da8d3aa0441139bfcc85508e859daf", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 8, "deletions": 19, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e4fb06a5182286640bf73410d09ab324c5e73ad/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e4fb06a5182286640bf73410d09ab324c5e73ad/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=7e4fb06a5182286640bf73410d09ab324c5e73ad", "patch": "@@ -994,25 +994,14 @@ extern int alpha_memory_latency;\n    On Alpha the value is found in $0 for integer functions and\n    $f0 for floating-point functions.  */\n \n-#define FUNCTION_VALUE(VALTYPE, FUNC)\t\\\n-  gen_rtx_REG (((INTEGRAL_TYPE_P (VALTYPE)\t\t\t\\\n-\t\t && TYPE_PRECISION (VALTYPE) < BITS_PER_WORD)\t\\\n-\t\t|| POINTER_TYPE_P (VALTYPE))\t\t\t\\\n-\t       ? word_mode : TYPE_MODE (VALTYPE),\t\t\\\n-\t       ((TARGET_FPREGS\t\t\t\t\t\\\n-\t\t && (TREE_CODE (VALTYPE) == REAL_TYPE\t\t\\\n-\t\t     || TREE_CODE (VALTYPE) == COMPLEX_TYPE))\t\\\n-\t\t? 32 : 0))\n+#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n+  function_value (VALTYPE, FUNC, VOIDmode)\n \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n \n-#define LIBCALL_VALUE(MODE)\t\\\n-   gen_rtx_REG (MODE,\t\t\t\t\t\t\\\n-\t\t(TARGET_FPREGS\t\t\t\t\t\\\n-\t\t && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n-\t\t     || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n-\t\t ? 32 : 0))\n+#define LIBCALL_VALUE(MODE) \\\n+  function_value (NULL, NULL, MODE)\n \n /* The definition of this macro implies that there are cases where\n    a scalar value cannot be returned in registers.\n@@ -1021,10 +1010,7 @@ extern int alpha_memory_latency;\n    are integers whose size is larger than 64 bits.  */\n \n #define RETURN_IN_MEMORY(TYPE) \\\n-  (TYPE_MODE (TYPE) == BLKmode \\\n-   || TYPE_MODE (TYPE) == TFmode \\\n-   || TYPE_MODE (TYPE) == TCmode \\\n-   || (TREE_CODE (TYPE) == INTEGER_TYPE && TYPE_PRECISION (TYPE) > 64))\n+  return_in_memory (TYPE, VOIDmode)\n \n /* 1 if N is a possible register number for a function value\n    as seen by the caller.  */\n@@ -1889,3 +1875,6 @@ do {\t\t\t\t\t\t\t\\\n \n /* Generate calls to memcpy, etc., not bcopy, etc.  */\n #define TARGET_MEM_FUNCTIONS 1\n+\n+/* Pass complex arguments independently.  */\n+#define SPLIT_COMPLEX_ARGS 1"}]}