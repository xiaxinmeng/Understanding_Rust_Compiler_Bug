{"sha": "231ddcb73423479b1644e7422ab008afa9e1ef51", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMxZGRjYjczNDIzNDc5YjE2NDRlNzQyMmFiMDA4YWZhOWUxZWY1MQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-28T21:04:58Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-28T21:04:58Z"}, "message": "Initial revision\n\nFrom-SVN: r246", "tree": {"sha": "28ec3af9b09c9d8b5843d849414088506562e297", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28ec3af9b09c9d8b5843d849414088506562e297"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/231ddcb73423479b1644e7422ab008afa9e1ef51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/231ddcb73423479b1644e7422ab008afa9e1ef51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/231ddcb73423479b1644e7422ab008afa9e1ef51", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/231ddcb73423479b1644e7422ab008afa9e1ef51/comments", "author": null, "committer": null, "parents": [{"sha": "2ac4fed045181a6ea52cf4656ae18cb28ccde04d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac4fed045181a6ea52cf4656ae18cb28ccde04d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ac4fed045181a6ea52cf4656ae18cb28ccde04d"}], "stats": {"total": 1328, "additions": 1328, "deletions": 0}, "files": [{"sha": "b191d8b70f87c544ac81ec8605cb3983039ddf5d", "filename": "gcc/config/ns32k/ns32k.h", "status": "added", "additions": 1328, "deletions": 0, "changes": 1328, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/231ddcb73423479b1644e7422ab008afa9e1ef51/gcc%2Fconfig%2Fns32k%2Fns32k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/231ddcb73423479b1644e7422ab008afa9e1ef51/gcc%2Fconfig%2Fns32k%2Fns32k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.h?ref=231ddcb73423479b1644e7422ab008afa9e1ef51", "patch": "@@ -0,0 +1,1328 @@\n+/* Definitions of target machine for GNU compiler.  NS32000 version.\n+   Copyright (C) 1988 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@mcc.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Note that some other tm.h files include this one and then override\n+   many of the definitions that relate to assembler syntax.  */\n+\n+extern enum reg_class secondary_reload_class();\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dns32000 -Dunix\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+#define TARGET_VERSION fprintf (stderr, \" (32000, GAS syntax)\");\n+\n+\f\n+/* ABSOLUTE PREFIX, IMMEDIATE_PREFIX and EXTERNAL_PREFIX can be defined\n+   to cover most NS32k addressing syntax variations.  This way we don't\n+   need to redefine long macros in all the tm.h files for just slight\n+   variations in assembler syntax. */\n+\n+#ifndef ABSOLUTE_PREFIX\n+#define ABSOLUTE_PREFIX '@'\n+#endif\n+\n+#if defined(IMMEDIATE_PREFIX) && IMMEDIATE_PREFIX\n+#define PUT_IMMEDIATE_PREFIX(FILE) putc(IMMEDIATE_PREFIX, FILE)\n+#else\n+#define PUT_IMMEDIATE_PREFIX(FILE)\n+#endif\n+#if defined(ABSOLUTE_PREFIX) && ABSOLUTE_PREFIX\n+#define PUT_ABSOLUTE_PREFIX(FILE) putc(ABSOLUTE_PREFIX, FILE)\n+#else\n+#define PUT_ABSOLUTE_PREFIX(FILE)\n+#endif\n+#if defined(EXTERNAL_PREFIX) && EXTERNAL_PREFIX\n+#define PUT_EXTERNAL_PREFIX(FILE) putc(EXTERNAL_PREFIX, FILE)\n+#else\n+#define PUT_EXTERNAL_PREFIX(FILE)\n+#endif\n+\n+/* Run-time compilation parameters selecting different hardware subsets.  */\n+\n+extern int target_flags;\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Compile 32081 insns for floating point (not library calls). */\n+#define TARGET_32081 (target_flags & 1)\n+\n+/* Compile using rtd insn calling sequence.\n+   This will not work unless you use prototypes at least\n+   for all functions that can take varying numbers of args.  */\n+#define TARGET_RTD (target_flags & 2)\n+\n+/* Compile passing first two args in regs 0 and 1.  */\n+#define TARGET_REGPARM (target_flags & 4)\n+\n+/* Options to select type of CPU, for better optimization.\n+   The output is correct for any kind of 32000 regardless of these options.  */\n+#define TARGET_32532 (target_flags & 8)\n+#define TARGET_32332 (target_flags & 16)\n+\n+/* Ok to use the static base register (and presume it's 0) */\n+#define TARGET_SB    ((target_flags & 32) == 0)\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { { \"32081\", 1},\t\t\t\t\\\n+    { \"soft-float\", -1},\t\t\t\\\n+    { \"rtd\", 2},\t\t\t\t\\\n+    { \"nortd\", -2},\t\t\t\t\\\n+    { \"regparm\", 4},\t\t\t\t\\\n+    { \"noregparm\", -4},\t\t\t\t\\\n+    { \"32532\", 24},\t\t\t\t\\\n+    { \"32332\", -16},\t\t\t\t\\\n+    { \"32332\", 8},\t\t\t\t\\\n+    { \"32032\", -24},\t\t\t\t\\\n+    { \"sb\", -32},\t\t\t\t\\\n+    { \"nosb\", 32},\t\t\t\t\\\n+    { \"\", TARGET_DEFAULT}}\n+/* TARGET_DEFAULT is defined in encore.h, pc532.h, etc.  */\n+\f\n+/* target machine storage layout */\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is not true on the ns32k.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+/* That is not true on the ns32k.  */\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* Define this if most significant word of a multiword number is lowest\n+   numbered. This is not true on the ns32k.  */\n+#define WORDS_BIG_ENDIAN 0\n+\n+/* Number of bits in an addressible storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 32000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 16\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* Every structure's size must be a multiple of this.  */\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  National claims that the NS32032\n+   works without strict alignment, but rumor has it that operands\n+   crossing a page boundary cause unpredictable results.  */\n+#define STRICT_ALIGNMENT\n+\n+/* If bit field type is int, dont let it cross an int,\n+   and give entire struct the alignment of an int.  */\n+/* Required on the 386 since it doesn't have a full set of bitfield insns.\n+   (There is no signed extv insn.)  */\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\f\n+/* Standard register usage.  */\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  */\n+#define FIRST_PSEUDO_REGISTER 18\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+   On the ns32k, these are the FP, SP, (SB and PC are not included here).  */\n+#define FIXED_REGISTERS {0, 0, 0, 0, 0, 0, 0, 0, \\\n+\t\t\t 0, 0, 0, 0, 0, 0, 0, 0, \\\n+\t\t\t 1, 1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS {1, 1, 1, 0, 0, 0, 0, 0, \\\n+\t\t\t     1, 1, 1, 1, 0, 0, 0, 0, \\\n+\t\t\t     1, 1}\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+   On the ns32k, all registers are 32 bits long.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE. */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) hard_regno_mode_ok (REGNO, MODE)\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) \\\n+  (((MODE1) == DFmode || (MODE1) == DCmode || (MODE1) == DImode) ==\t\\\n+   ((MODE2) == DFmode || (MODE2) == DCmode || (MODE2) == DImode))\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* NS32000 pc is not overloaded on a register.  */\n+/* #define PC_REGNUM */\n+\n+/* Register to use for pushing function arguments. */\n+#define STACK_POINTER_REGNUM 17\n+\n+/* Base register for access to local variables of the function. */\n+#define FRAME_POINTER_REGNUM 16\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 16\n+\n+/* Register in which static-chain is passed to a function.  */\n+#define STATIC_CHAIN_REGNUM 1\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.  */\n+#define STRUCT_VALUE_REGNUM 2\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+   \n+enum reg_class { NO_REGS, GENERAL_REGS, FLOAT_REGS, FRAME_POINTER_REG, STACK_POINTER_REG, \n+                 GEN_AND_MEM_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"GENERAL_REGS\", \"FLOAT_REGS\", \"FRAME_POINTER_REG\", \"STACK_POINTER_REG\", \"GEN_AND_MEM_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS {0, 0x00ff, 0xff00, 0x10000, 0x20000, 0x300ff, 0x3ffff }\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) \\\n+  ((REGNO) < 8 ? GENERAL_REGS          \\\n+   : (REGNO) < 16 ? FLOAT_REGS         \\\n+   : (REGNO) == 16 ? FRAME_POINTER_REG \\\n+   : (REGNO) == 17 ? STACK_POINTER_REG \\\n+   : NO_REGS)\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define INDEX_REG_CLASS GENERAL_REGS\n+#define BASE_REG_CLASS  GEN_AND_MEM_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C)\t\\\n+ ((C) == 'f' ? FLOAT_REGS\t\t\\\n+  : (C) == 'x' ? FRAME_POINTER_REG\t\\\n+  : (C) == 'y' ? STACK_POINTER_REG      \\\n+  : NO_REGS)\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   On the ns32k, these letters are used as follows:\n+\n+   I : Matches integers which are valid shift amounts for scaled indexing.\n+       These are 0, 1, 2, 3 for byte, word, double, and quadword.\n+       Used for matching arithmetic shifts only on 32032 & 32332.\n+   J : Matches integers which fit a \"quick\" operand.\n+   K : Matches integers 0 to 7 (for inss and exts instructions).\n+  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((VALUE) < 8 && (VALUE) + 8 >= 0 ?\t\t\\\n+   ((C) == 'I' ? (!TARGET_32532 && 0 <= (VALUE) && (VALUE) <= 3) : \\\n+    (C) == 'J' ? (VALUE) <= 7 :\t\t\t\\\n+    (C) == 'K' ? 0 <= (VALUE) : 0) : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 1\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+/* On the 32000, this is the size of MODE in words */\n+#define CLASS_MAX_NREGS(CLASS, MODE) \\\n+  ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\f\n+/* Stack layout; function entry, exit and calling.  */\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* If we generate an insn to push BYTES bytes,\n+   this says how many the stack pointer really advances by.\n+   On the 32000, sp@- in a byte insn really pushes a BYTE.  */\n+#define PUSH_ROUNDING(BYTES) (BYTES)\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 8\n+\n+/* Value is the number of byte of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.\n+\n+   On the 32000, the RET insn may be used to pop them if the number\n+     of args is fixed, but if the number is variable then the caller\n+     must pop them all.  RET can't be used for library calls now\n+     because the library is compiled with the Unix compiler.\n+   Use of RET is a selectable option, since it is incompatible with\n+   standard Unix calling sequences.  If the option is not selected,\n+   the caller must always pop the args.  */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE)   \\\n+  ((TARGET_RTD && TREE_CODE (FUNTYPE) != IDENTIFIER_NODE\t\\\n+    && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n+\t|| (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n+\t    == void_type_node)))\t\t\t\t\\\n+   ? (SIZE) : 0)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* On the 32000 the return value is in R0,\n+   or perhaps in F0 is there is fp support.  */   \n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  (TREE_CODE (VALTYPE) == REAL_TYPE && TARGET_32081 \\\n+   ? gen_rtx (REG, TYPE_MODE (VALTYPE), 8) \\\n+   : gen_rtx (REG, TYPE_MODE (VALTYPE), 0))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+/* On the 32000 the return value is in R0,\n+   or perhaps F0 is there is fp support.  */   \n+\n+#define LIBCALL_VALUE(MODE)  \\\n+  (((MODE) == DFmode || (MODE) == SFmode) && TARGET_32081 \\\n+   ? gen_rtx (REG, MODE, 8) \\\n+   : gen_rtx (REG, MODE, 0))\n+\n+/* Define this if PCC uses the nonreentrant convention for returning\n+   structure and union values.  */\n+\n+#define PCC_STATIC_STRUCT_RETURN\n+\n+/* 1 if N is a possible register number for a function value.\n+   On the 32000, R0 and F0 are the only registers thus used.  */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) (((N) & ~8) == 0)\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the 32000, no registers are used in this way.  */\n+\n+#define FUNCTION_ARG_REGNO_P(N) 0\n+\f\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On the ns32k, this is a single integer, which is a number of bytes\n+   of arguments scanned so far.  */\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.\n+\n+   On the ns32k, the offset starts at 0.  */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME)\t\\\n+ ((CUM) = 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n+ ((CUM) += ((MODE) != BLKmode\t\t\t\\\n+\t    ? (GET_MODE_SIZE (MODE) + 3) & ~3\t\\\n+\t    : (int_size_in_bytes (TYPE) + 3) & ~3))\n+\n+/* Define where to put the arguments to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis).  */\n+\n+/* On the 32000 all args are pushed, except if -mregparm is specified\n+   then the first two words of arguments are passed in r0, r1.\n+   *NOTE* -mregparm does not work.\n+   It exists only to test register calling conventions.  */\n+\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+((TARGET_REGPARM && (CUM) < 8) ? gen_rtx (REG, (MODE), (CUM) / 4) : 0)\n+\n+/* For an arg passed partly in registers and partly in memory,\n+   this is the number of registers used.\n+   For args passed entirely in registers or entirely in memory, zero.  */\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n+((TARGET_REGPARM && (CUM) < 8\t\t\t\t\t\\\n+  && 8 < ((CUM) + ((MODE) == BLKmode\t\t\t\t\\\n+\t\t      ? int_size_in_bytes (TYPE)\t\t\\\n+\t\t      : GET_MODE_SIZE (MODE))))  \t\t\\\n+ ? 2 - (CUM) / 4 : 0)\n+\n+#ifndef MAIN_FUNCTION_PROLOGUE\n+#define MAIN_FUNCTION_PROLOGUE\n+#endif\n+\n+/*\n+ * The function prologue for the ns32k is fairly simple.\n+ * If a frame pointer is needed (decided in reload.c ?) then\n+ * we need assembler of the form\n+ *\n+ *  # Save the oldframe pointer, set the new frame pointer, make space\n+ *  # on the stack and save any general purpose registers necessary\n+ *\n+ *  enter [<general purpose regs to save>], <local stack space>\n+ *\n+ *  movf  fn, tos    # Save any floating point registers necessary\n+ *  .\n+ *  .\n+ *\n+ * If a frame pointer is not needed we need assembler of the form\n+ *  # Save any general purpose registers necessary\n+ *\n+ *  save [<general purpose regs to save>]\n+ *\n+ *  movf  fn, tos    # Save any floating point registers necessary\n+ *  .\n+ *  .\n+ */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE)     \\\n+{ register int regno, g_regs_used = 0;\t\t\t\t\\\n+  int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n+  int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  MAIN_FUNCTION_PROLOGUE;\t\t\t\t\t\\\n+  for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno]\t\t\t\t\t\\\n+\t&& ! call_used_regs[regno])\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  *bufp = -1;\t\t\t\t\t\t\t\\\n+  for (; regno < 16; regno++)\t\t\t\t\t\\\n+    if (regs_ever_live[regno] && !call_used_regs[regno]) {\t\\\n+      *fbufp++ = regno;\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  *fbufp = -1;\t\t\t\t\t\t\t\\\n+  bufp = used_regs_buf;\t\t\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tenter [\");\t\t\t\t\\\n+  else if (g_regs_used)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\tsave [\");\t\t\t\t\t\\\n+  while (*bufp >= 0)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"r%d\", *bufp++);\t\t\t\t\\\n+      if (*bufp >= 0)\t\t\t\t\t\t\\\n+\tfputc (',', FILE);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    fprintf (FILE, \"],%d\\n\", SIZE);\t\t\t\t\\\n+  else if (g_regs_used)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"]\\n\");\t\t\t\t\t\\\n+  fbufp = used_fregs_buf;\t\t\t\t\t\\\n+  while (*fbufp >= 0)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((*fbufp & 1) || (fbufp[0] != fbufp[1] - 1))\t\t\\\n+\tfprintf (FILE, \"\\tmovf f%d,tos\\n\", *fbufp++ - 8);\t\\\n+      else\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\tmovl f%d,tos\\n\", fbufp[0] - 8);\t\\\n+\t  fbufp += 2;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.\n+\n+   THIS DEFINITION FOR THE 32000 IS A GUESS.  IT HAS NOT BEEN TESTED.  */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   fprintf (FILE, \"\\taddr LP%d,r0\\n\\tbsr mcount\\n\", (LABELNO))\n+\n+/* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n+   the stack pointer does not matter.  The value is tested only in\n+   functions that have frame pointers.\n+   No definition is equivalent to always zero.\n+\n+   We use 0, because using 1 requires hair in FUNCTION_EPILOGUE\n+   that is worse than the stack adjust we could save.  */\n+\n+/* #define EXIT_IGNORE_STACK 1 */\n+\n+/* This macro generates the assembly code for function exit,\n+   on machines that need it.  If FUNCTION_EPILOGUE is not defined\n+   then individual return instructions are generated for each\n+   return statement.  Args are same as for FUNCTION_PROLOGUE.\n+\n+   The function epilogue should not depend on the current stack pointer,\n+   if EXIT_IGNORE_STACK is nonzero.  That doesn't apply here.\n+\n+   If a frame pointer is needed (decided in reload.c ?) then\n+   we need assembler of the form\n+\n+    movf  tos, fn\t# Restore any saved floating point registers\n+    .\n+    .\n+\n+    # Restore any saved general purpose registers, restore the stack\n+    # pointer from the frame pointer, restore the old frame pointer.\n+    exit [<general purpose regs to save>]\n+\n+   If a frame pointer is not needed we need assembler of the form\n+    # Restore any general purpose registers saved\n+\n+    movf  tos, fn\t# Restore any saved floating point registers\n+    .\n+    .\n+    .\n+    restore [<general purpose regs to save>]  */\n+\n+#define FUNCTION_EPILOGUE(FILE, SIZE) \\\n+{ register int regno, g_regs_used = 0, f_regs_used = 0;\t\t\\\n+  int used_regs_buf[8], *bufp = used_regs_buf;\t\t\t\\\n+  int used_fregs_buf[8], *fbufp = used_fregs_buf;\t\t\\\n+  extern char call_used_regs[];\t\t\t\t\t\\\n+  *fbufp++ = -2;\t\t\t\t\t\t\\\n+  for (regno = 8; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && !call_used_regs[regno]) {\t\\\n+       *fbufp++ = regno; f_regs_used++;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  fbufp--;\t\t\t\t\t\t\t\\\n+  for (regno = 0; regno < 8; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno]\t\t\t\t\t\\\n+\t&& ! call_used_regs[regno])\t\t\t\t\\\n+    {                                                         \t\\\n+      *bufp++ = regno; g_regs_used++;\t\t\t\t\\\n+    }                                                         \t\\\n+  while (fbufp > used_fregs_buf)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if ((*fbufp & 1) && fbufp[0] == fbufp[-1] + 1)\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"\\tmovl tos,f%d\\n\", fbufp[-1] - 8);\t\\\n+\t  fbufp -= 2;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else fprintf (FILE, \"\\tmovf tos,f%d\\n\", *fbufp-- - 8);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (frame_pointer_needed)\t\t\t\t\t\\\n+    fprintf (FILE, \"\\texit [\");\t\t\t\t\t\\\n+  else if (g_regs_used)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\trestore [\");\t\t\t\t\\\n+  while (bufp > used_regs_buf)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"r%d\", *--bufp);\t\t\t\t\\\n+      if (bufp > used_regs_buf)\t\t\t\t\t\\\n+\tfputc (',', FILE);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  if (g_regs_used || frame_pointer_needed)\t\t\t\\\n+    fprintf (FILE, \"]\\n\");\t\t\t\t\t\\\n+  if (current_function_pops_args)\t\t\t\t\\\n+    fprintf (FILE, \"\\tret %d\\n\", current_function_pops_args);\t\\\n+  else fprintf (FILE, \"\\tret 0\\n\"); }\n+\n+/* Store in the variable DEPTH the initial difference between the\n+   frame pointer reg contents and the stack pointer reg contents,\n+   as of the start of the function body.  This depends on the layout\n+   of the fixed parts of the stack frame and on how registers are saved.  */\n+\n+#define INITIAL_FRAME_POINTER_OFFSET(DEPTH)\t\t\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  int regno;\t\t\t\t\t\t\t\\\n+  int offset = -4;\t\t\t\t\t\t\\\n+  for (regno = 0; regno < 16; regno++)\t\t\t\t\\\n+    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+      offset += 4;\t\t\t\t\t\t\\\n+  (DEPTH) = offset - get_frame_size ();\t\t\t\t\\\n+}\n+\f\n+\n+/* Output assembler code for a block containing the constant parts\n+   of a trampoline, leaving space for the variable parts.  */\n+\n+/* On the 32k, the trampoline looks like this:\n+     addr  .,r2\n+     jump  @__trampoline\n+     .int STATIC\n+     .int FUNCTION\n+Doing trampolines with a library assist function is easier than figuring\n+out how to do stores to memory in reverse byte order (the way immediate\n+operands on the 32k are stored).  */\n+\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  fprintf (FILE, \"\\taddr .,r2\\n\" );\t\t\t\t\t\\\n+  fprintf (FILE, \"\\tjump @__trampoline\\n\" );\t\t\t\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n+  ASM_OUTPUT_INT (FILE, const0_rtx);\t\t\t\t\t\\\n+}\n+\n+/* Length in units of the trampoline for entering a nested function.  */\n+\n+#define TRAMPOLINE_SIZE 20\n+\n+/* Emit RTL insns to initialize the variable parts of a trampoline.\n+   FNADDR is an RTX for the address of the function's pure code.\n+   CXT is an RTX for the static chain value for the function.  */\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\t     \\\n+{\t\t\t\t\t\t\t\t\t     \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 12)), CXT);    \\\n+  emit_move_insn (gen_rtx (MEM, SImode, plus_constant (TRAMP, 16)), FNADDR); \\\n+}\n+\n+/* This is the library routine that is used\n+   to transfer control from the trampoline\n+   to the actual nested function.  */\n+\n+/* The function name __transfer_from_trampoline is not actually used.\n+   The function definition just permits use of \"asm with operands\"\n+   (though the operand list is empty).  */\n+#define TRANSFER_FROM_TRAMPOLINE\t\\\n+void\t\t\t\t\t\\\n+__transfer_from_trampoline ()\t\t\\\n+{\t\t\t\t\t\\\n+  asm (\"___trampoline:\");\t\t\\\n+  asm (\"movd 16(r2),tos\");\t\t\\\n+  asm (\"movd 12(r2),r2\");\t\t\\\n+  asm (\"ret\");\t\t\t\t\\\n+}\n+\n+\n+\f\n+/* Addressing modes, and classification of registers for them.  */\n+\n+/* #define HAVE_POST_INCREMENT */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+/* note that FP and SP cannot be used as an index. What about PC? */\n+#define REGNO_OK_FOR_INDEX_P(REGNO)  \\\n+((REGNO) < 8 || (unsigned)reg_renumber[REGNO] < 8)\n+#define REGNO_OK_FOR_BASE_P(REGNO)   \\\n+((REGNO) < 8 || (unsigned)reg_renumber[REGNO] < 8 \\\n+ || (REGNO) == FRAME_POINTER_REGNUM || (REGNO) == STACK_POINTER_REGNUM)\n+\n+#define FP_REG_P(X)  (GET_CODE (X) == REG && REGNO (X) > 7 && REGNO (X) < 16)\n+\f\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* Recognize any constant value that is a valid address.\n+   This might not work on future ns32k processors as negative\n+   displacements are not officially allowed but a mode reserved\n+   to National.  This works on processors up to 32532, though. */\n+\n+#define CONSTANT_ADDRESS_P(X)   \\\n+  (GET_CODE (X) == LABEL_REF || GET_CODE (X) == SYMBOL_REF\t\t\\\n+   || GET_CODE (X) == CONST\t\t\t\t\t\t\\\n+   || (GET_CODE (X) == CONST_INT\t\t\t\t\t\\\n+       && ((unsigned)INTVAL (X) >= 0xe0000000\t\t\t\t\\\n+\t   || (unsigned)INTVAL (X) < 0x20000000)))\n+\n+#define CONSTANT_ADDRESS_NO_LABEL_P(X)   \\\n+  (GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n+   && ((unsigned)INTVAL (X) >= 0xe0000000\t\t\t\t\\\n+       || (unsigned)INTVAL (X) < 0x20000000))\n+\n+/* Return the register class of a scratch register needed to copy IN into\n+   or out of a register in CLASS in MODE.  If it can be done directly,\n+   NO_REGS is returned.  */\n+\n+#define SECONDARY_RELOAD_CLASS(CLASS,MODE,IN) \\\n+  secondary_reload_class (CLASS, MODE, IN)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) \\\n+  (REGNO (X) < 8 || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   of if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) (REGNO (X) < 8 || REGNO (X) >= FRAME_POINTER_REGNUM)\n+/* Nonzero if X is a floating point reg or a pseudo reg.  */\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS.  */\n+\n+/* 1 if X is an address that we could indirect through.  */\n+/***** NOTE ***** There is a bug in the Sequent assembler which fails\n+ to fixup addressing information for symbols used as offsets\n+ from registers which are not FP or SP (or SB or PC).  This\n+ makes _x(fp) valid, while _x(r0) is invalid.  */\n+\n+#define INDIRECTABLE_1_ADDRESS_P(X)  \\\n+  (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n+   || (GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\t\t\\\n+   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+       && GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\t\\\n+       && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n+       && CONSTANT_ADDRESS_P (XEXP (X, 1))))\n+\n+#define MEM_REG(X) \\\n+  ((GET_CODE (X) == REG && (REGNO (X) ^ 16) < 2)\t\t\t\\\n+   || (TARGET_SB && CONSTANT_ADDRESS_P (X)))\n+\n+#define INDIRECTABLE_2_ADDRESS_P(X)  \\\n+  (GET_CODE (X) == MEM\t\t\t\t\t\t\t\\\n+   && (((xfoo0 = XEXP (X, 0), MEM_REG (xfoo0))\t\t\t\t\\\n+       || (GET_CODE (xfoo0) == PLUS\t\t\t\t\t\\\n+\t   && GET_CODE (XEXP (xfoo0, 0)) == REG\t\t\t\t\\\n+\t   && MEM_REG (XEXP (xfoo0, 0))\t\t\t\t\t\\\n+\t   && CONSTANT_ADDRESS_NO_LABEL_P (XEXP (xfoo0, 1))))\t\t\\\n+       || (TARGET_SB && CONSTANT_ADDRESS_P (xfoo0))))\n+\n+#define INDIRECTABLE_ADDRESS_P(X)  \\\n+  (INDIRECTABLE_1_ADDRESS_P(X)\t\t\t\t\t\t\\\n+   || INDIRECTABLE_2_ADDRESS_P (X)\t\t\t\t\t\\\n+   || (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+       && CONSTANT_ADDRESS_NO_LABEL_P (XEXP (X, 1))\t\t\t\\\n+       && INDIRECTABLE_2_ADDRESS_P (XEXP (X, 0))))\n+\n+/* Go to ADDR if X is a valid address not using indexing.\n+   (This much is the easy part.)  */\n+#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n+{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n+  if (GET_CODE (xfoob) == REG && REG_OK_FOR_BASE_P (xfoob)) goto ADDR;\t\\\n+  if (INDIRECTABLE_1_ADDRESS_P(X)) goto ADDR;\t\t\t\t\\\n+  if (INDIRECTABLE_2_ADDRESS_P (X)) goto ADDR;\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    if (CONSTANT_ADDRESS_NO_LABEL_P (XEXP (X, 1)))\t\t\t\\\n+      if (INDIRECTABLE_2_ADDRESS_P (XEXP (X, 0)))\t\t\t\\\n+\tgoto ADDR;\t\t\t\t\t\t\t\\\n+}\n+\n+/* 1 if PROD is either a reg times size of mode MODE\n+   or just a reg, if MODE is just one byte. Actually, on the ns32k,\n+   since the index mode is independent of the operand size,\n+   we can match more stuff...\n+\n+   This macro's expansion uses the temporary variables xfoo0, xfoo1\n+   and xfoo2 that must be declared in the surrounding context.  */\n+#define INDEX_TERM_P(PROD, MODE)   \\\n+((GET_CODE (PROD) == REG && REG_OK_FOR_INDEX_P (PROD))\t\t\t\\\n+ || (GET_CODE (PROD) == MULT\t\t\t\t\t\t\\\n+     &&\t(xfoo0 = XEXP (PROD, 0), xfoo1 = XEXP (PROD, 1),\t\t\\\n+\t (GET_CODE (xfoo1) == CONST_INT\t\t\t\t\t\\\n+\t  && GET_CODE (xfoo0) == REG\t\t\t\t\t\\\n+\t  && FITS_INDEX_RANGE (INTVAL (xfoo1))\t\t\t\t\\\n+\t  && REG_OK_FOR_INDEX_P (xfoo0)))))\n+\n+#define FITS_INDEX_RANGE(X)  \\\n+  ((xfoo2 = (unsigned)(X)-1),\t\t\t\t\t\t\\\n+   ((xfoo2 < 4 && xfoo2 != 2) || xfoo2 == 7))\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n+{ register rtx xfooy, xfooz, xfoo0, xfoo1;\t\t\t\t\\\n+  unsigned xfoo2;\t\t\t\t\t\t\t\\\n+  xfooy = X;\t\t\t\t\t\t\t\t\\\n+  GO_IF_NONINDEXED_ADDRESS (xfooy, ADDR);\t\t\t\t\\\n+  if (GET_CODE (xfooy) == PLUS)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (CONSTANT_ADDRESS_NO_LABEL_P (XEXP (xfooy, 1))\t\t\t\\\n+\t  && GET_CODE (XEXP (xfooy, 0)) == PLUS)\t\t\t\\\n+\txfooy = XEXP (xfooy, 0);\t\t\t\t\t\\\n+      else if (CONSTANT_ADDRESS_NO_LABEL_P (XEXP (xfooy, 0))\t\t\\\n+\t  && GET_CODE (XEXP (xfooy, 1)) == PLUS)\t\t\t\\\n+\txfooy = XEXP (xfooy, 1);\t\t\t\t\t\\\n+      xfooz = XEXP (xfooy, 1);\t\t\t\t\t\t\\\n+      if (INDEX_TERM_P (xfooz, MODE))\t\t\t\t\t\\\n+\t{ rtx t = XEXP (xfooy, 0); GO_IF_NONINDEXED_ADDRESS (t, ADDR); }\\\n+      xfooz = XEXP (xfooy, 0);\t\t\t\t\t\t\\\n+      if (INDEX_TERM_P (xfooz, MODE))\t\t\t\t\t\\\n+\t{ rtx t = XEXP (xfooy, 1); GO_IF_NONINDEXED_ADDRESS (t, ADDR); }\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  else if (INDEX_TERM_P (xfooy, MODE))\t\t\t\t\t\\\n+    goto ADDR;\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (xfooy) == PRE_DEC)\t\t\t\t\t\\\n+    if (REGNO (XEXP (xfooy, 0)) == STACK_POINTER_REGNUM) goto ADDR;\t\\\n+  else abort ();\t\t\t\t\t\t\t\\\n+}\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   For the ns32k, we do nothing */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)   {}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   On the ns32k, only predecrement and postincrement address depend thus\n+   (the amount of decrement or increment being the length of the operand).  */\n+\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\t\\\n+ { if (GET_CODE (ADDR) == POST_INC || GET_CODE (ADDR) == PRE_DEC)\t\\\n+     goto LABEL;}\n+\f\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.\n+   Can do SImode, but HI mode is more efficient. */\n+#define CASE_VECTOR_MODE HImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+#define CASE_VECTOR_PC_RELATIVE\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.  */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 4\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* Nonzero if access to memory by bytes is slow and undesirable.  */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+/* #define SHIFT_COUNT_TRUNCATED */\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* We assume that the store-condition-codes instructions store 0 for false\n+   and some other value for true.  This is the value stored for true.  */\n+\n+#define STORE_FLAG_VALUE 1\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* Compute the cost of address ADDRESS. */\n+\n+#define ADDRESS_COST(RTX) calc_address_cost (RTX)\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if (INTVAL (RTX) <= 7 && INTVAL (RTX) >= -8) return 0;\t\\\n+    if (INTVAL (RTX) < 0x4000 && INTVAL (RTX) >= -0x4000)\t\\\n+      return 1;\t\t\t\t\t\t\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 3;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 5;\n+\f\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  */\n+\n+/* This bit means that what ought to be in the Z bit\n+   should be tested in the F bit.  */\n+#define CC_Z_IN_F 04000\n+\n+/* This bit means that what ought to be in the Z bit\n+   is complemented in the F bit.  */\n+#define CC_Z_IN_NOT_F 010000\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+{ if (GET_CODE (EXP) == SET)\t\t\t\t\t\\\n+    { if (GET_CODE (SET_DEST (EXP)) == CC0)\t\t\t\\\n+\t{ cc_status.flags = 0;\t\t\t\t\t\\\n+\t  cc_status.value1 = SET_DEST (EXP);\t\t\t\\\n+\t  cc_status.value2 = SET_SRC (EXP);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (SET_SRC (EXP)) == CALL)\t\t\\\n+\t{ CC_STATUS_INIT; }\t\t\t\t\t\\\n+      else if (GET_CODE (SET_DEST (EXP)) == REG)\t\t\\\n+\t{ if (cc_status.value1\t\t\t\t\t\\\n+\t      && reg_overlap_mentioned_p (SET_DEST (EXP), cc_status.value1)) \\\n+\t    cc_status.value1 = 0;\t\t\t\t\\\n+\t  if (cc_status.value2\t\t\t\t\t\\\n+\t      && reg_overlap_mentioned_p (SET_DEST (EXP), cc_status.value2)) \\\n+\t    cc_status.value2 = 0;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (SET_DEST (EXP)) == MEM)\t\t\\\n+\t{ CC_STATUS_INIT; }\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (EXP) == PARALLEL\t\t\t\t\\\n+\t   && GET_CODE (XVECEXP (EXP, 0, 0)) == SET)\t\t\\\n+    { if (GET_CODE (SET_DEST (XVECEXP (EXP, 0, 0))) == CC0)\t\\\n+\t{ cc_status.flags = 0;\t\t\t\t\t\\\n+\t  cc_status.value1 = SET_DEST (XVECEXP (EXP, 0, 0));\t\\\n+\t  cc_status.value2 = SET_SRC (XVECEXP (EXP, 0, 0));\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (SET_DEST (XVECEXP (EXP, 0, 0))) == REG) \\\n+\t{ if (cc_status.value1\t\t\t\t\t\\\n+\t      && reg_overlap_mentioned_p (SET_DEST (XVECEXP (EXP, 0, 0)), cc_status.value1)) \\\n+\t    cc_status.value1 = 0;\t\t\t\t\\\n+\t  if (cc_status.value2\t\t\t\t\t\\\n+\t      && reg_overlap_mentioned_p (SET_DEST (XVECEXP (EXP, 0, 0)), cc_status.value2)) \\\n+\t    cc_status.value2 = 0;\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (SET_DEST (XVECEXP (EXP, 0, 0))) == MEM) \\\n+\t{ CC_STATUS_INIT; }\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (EXP) == CALL)\t\t\t\t\\\n+    { /* all bets are off */ CC_STATUS_INIT; }\t\t\t\\\n+  else { /* nothing happens? CC_STATUS_INIT; */}\t\t\\\n+  if (cc_status.value1 && GET_CODE (cc_status.value1) == REG\t\\\n+      && cc_status.value2\t\t\t\t\t\\\n+      && reg_overlap_mentioned_p (cc_status.value1, cc_status.value2))\t\\\n+    abort ();\t\t\t\\\n+}\n+\n+/* Describe the costs of the following register moves which are discouraged:\n+   1.) Moves between the Floating point registers and the frame pointer and stack pointer\n+   2.) Moves between the stack pointer and the frame pointer\n+   3.) Moves between the floating point and general registers */\n+\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)   \\\n+  ((((CLASS1) == FLOAT_REGS && ((CLASS2) == STACK_POINTER_REG || (CLASS2) == FRAME_POINTER_REG))    \\\n+   || ((CLASS2) == FLOAT_REGS && ((CLASS1) == STACK_POINTER_REG || (CLASS1) == FRAME_POINTER_REG))  \\\n+   || ((CLASS1) == STACK_POINTER_REG && (CLASS2) == FRAME_POINTER_REG)                              \\\n+   || ((CLASS2) == STACK_POINTER_REG && (CLASS1) == FRAME_POINTER_REG)                              \\\n+   || ((CLASS1) == FLOAT_REGS && (CLASS2) == GENERAL_REGS)                                          \\\n+   || ((CLASS1) == GENERAL_REGS && (CLASS2) == FLOAT_REGS))                                         \\\n+ ? 4  : 2)\n+\n+#define OUTPUT_JUMP(NORMAL, NO_OV)  \\\n+{ if (cc_status.flags & CC_NO_OVERFLOW)\t\t\t\t\\\n+    return NO_OV;\t\t\t\t\t\t\\\n+  return NORMAL; }\n+\f\n+/* Dividing the output into sections */\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* Define the output Assembly Language */\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE) fprintf (FILE, \"#NO_APP\\n\");\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+/* Output of Data */\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.double 0d%.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.float 0f%.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.long \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining an external/static\n+   address which is not in tree format (for collect.c).  */\n+\n+#define ASM_OUTPUT_LABELREF_AS_INT(STREAM, NAME)\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.long\\t\");\t\t\t\t\t\\\n+  ASM_OUTPUT_LABELREF (STREAM, NAME);\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\n\");\t\t\t\t\t\t\\\n+} while (0)\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmovd %s,tos\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmovd tos,%s\\n\", reg_names[REGNO])\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \\\n+ \"f0\", \"f1\", \"f2\", \"f3\", \"f4\", \"f5\", \"f6\", \"f7\", \\\n+ \"fp\", \"sp\"}\n+\n+/* How to renumber registers for dbx and gdb.\n+   NS32000 may need more change in the numeration.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) ((REGNO < 8) ? (REGNO)+4 : (REGNO))\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#ifndef COLLECT\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+#else\n+#define ASM_OUTPUT_LABEL(STREAM,NAME)\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"%s:\\n\", NAME);\t\t\t\t\t\\\n+} while (0)\n+#endif\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#ifndef COLLECT\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+#else\n+#define ASM_GLOBALIZE_LABEL(STREAM,NAME)\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  fprintf (STREAM, \"\\t.globl\\t%s\\n\", NAME);\t\t\t\t\\\n+} while (0)\n+#endif\n+\n+/* This is how to output a reference to a user-level label named NAME.\n+   `assemble_name' uses this.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+  fprintf (FILE, \"_%s\", NAME)\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* This is how to align the code that follows an unconditional branch.  */\n+\n+#define ASM_OUTPUT_ALIGN_CODE(FILE)\t\\\n+  fprintf (FILE, \"\\t.align 2\\n\")\n+\n+/* This is how to output an element of a case-vector that is absolute.\n+   (The ns32k does not use such vectors,\n+   but we must define this macro anyway.)  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.long L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+/* ** Notice that the second element is LI format! */\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word L%d-LI%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n+  fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %u\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print an instruction operand X on file FILE.\n+   CODE is the code from the %-spec that requested printing this operand;\n+   if `%z3' was used to print operand 3, then CODE is 'z'. */\n+\n+/* %$ means print the prefix for an immediate operand.  */\n+\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE)\t\t\t\t\\\n+  ((CODE) == '$' || (CODE) == '?')\n+\n+#define PRINT_OPERAND(FILE, X, CODE)       print_operand(FILE, X, CODE)\n+\n+/* Print a memory operand whose address is X, on file FILE.  */\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR) print_operand_address(FILE, ADDR)\n+\n+/* Define functions in ns32k.c and used in insn-output.c.  */\n+\n+extern char *output_move_double ();\n+extern char *output_shift_insn ();\n+\n+/*\n+Local variables:\n+version-control: t\n+End:\n+*/"}]}