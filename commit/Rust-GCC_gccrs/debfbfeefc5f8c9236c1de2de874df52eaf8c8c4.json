{"sha": "debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGViZmJmZWVmYzVmOGM5MjM2YzFkZTJkZTg3NGRmNTJlYWY4YzhjNA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-10-12T02:43:25Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-10-12T02:43:25Z"}, "message": "In libobjc/: 2010-10-12 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2010-10-12  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * Makefile.in (C_SOURCE_FILES): Added protocols.c.\n        * objc-private/protocols.h: New.\n        * protocols.c: New.\n        * init.c: Include objc-private/protocols.h.\n        (__objc_exec_class): Call __objc_protocols_init on startup.\n        (__objc_init_protocols): Call __objc_protocols_add_protocol.\n        * objc-private/runtime.h: Use (struct objc_method_list *) instead\n        of MethodList_t, and (struct objc_method *) instead of Method_t.\n        * objc/deprecated/struct_objc_class.h: Define\n        __objc_STRUCT_OBJC_CLASS_defined.\n        * objc-private/module-abi-8.h (struct\n        objc_method_description_list): New.\n        (struct objc_class): Only define if\n        __objc_STRUCT_OBJC_CLASS_defined is undefined.\n        * objc/runtime.h (class_getName): New.\n        (objc_getProtocol): New.\n        (objc_copyProtocolList): New.\n        (class_addProtocol): New.\n        (class_conformsToProtocol): New.\n        (class_copyProtocolList): New.\n        (protocol_conformsToProtocol): New.\n        (protocol_isEqual): New.\n        (protocol_getName): New.\n        (protocol_getMethodDescription): New.\n        (protocol_copyMethodDescriptionList): New.\n        (protocol_getProperty): New.\n        (protocol_copyPropertyList): New.\n        (protocol_copyProtocolList): New.\n        * class.c (class_getName): New.\n        * selector.c (sel_isEqual): New.\n\nFrom-SVN: r165349", "tree": {"sha": "1565198dee2ff7c323dd7ae7d47bcb976d011d43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1565198dee2ff7c323dd7ae7d47bcb976d011d43"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "524660d2e3e96ac715623c052338c25a14938dfa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/524660d2e3e96ac715623c052338c25a14938dfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/524660d2e3e96ac715623c052338c25a14938dfa"}], "stats": {"total": 829, "additions": 822, "deletions": 7}, "files": [{"sha": "569d6a69c3afbc96527afc1e9e4b7d368b4a25a0", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "patch": "@@ -1,3 +1,36 @@\n+2010-10-12  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* Makefile.in (C_SOURCE_FILES): Added protocols.c.\n+\t* objc-private/protocols.h: New.\n+\t* protocols.c: New.\n+\t* init.c: Include objc-private/protocols.h.\n+\t(__objc_exec_class): Call __objc_protocols_init on startup.\n+\t(__objc_init_protocols): Call __objc_protocols_add_protocol.\n+\t* objc-private/runtime.h: Use (struct objc_method_list *) instead\n+\tof MethodList_t, and (struct objc_method *) instead of Method_t.\n+\t* objc/deprecated/struct_objc_class.h: Define\n+\t__objc_STRUCT_OBJC_CLASS_defined.\n+\t* objc-private/module-abi-8.h (struct\n+\tobjc_method_description_list): New.\n+\t(struct objc_class): Only define if\n+\t__objc_STRUCT_OBJC_CLASS_defined is undefined.\n+\t* objc/runtime.h (class_getName): New.\n+\t(objc_getProtocol): New.\n+\t(objc_copyProtocolList): New.\n+\t(class_addProtocol): New.\n+\t(class_conformsToProtocol): New.\n+\t(class_copyProtocolList): New.\n+\t(protocol_conformsToProtocol): New.\n+\t(protocol_isEqual): New.\n+\t(protocol_getName): New.\n+\t(protocol_getMethodDescription): New.\n+\t(protocol_copyMethodDescriptionList): New.\n+\t(protocol_getProperty): New.\n+\t(protocol_copyPropertyList): New.\n+\t(protocol_copyProtocolList): New.\n+\t* class.c (class_getName): New.\n+\t* selector.c (sel_isEqual): New.\n+\t\n 2010-10-12  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* selector.c (sel_getName): Return \"<null selector>\" for a NULL"}, {"sha": "4790f952b9dce4c3ebebe4bec83c7642c6f6e546", "filename": "libobjc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FMakefile.in?ref=debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "patch": "@@ -177,6 +177,7 @@ C_SOURCE_FILES = \\\n    objc-foreach.c \\\n    objc-sync.c \\\n    objects.c \\\n+   protocols.c \\\n    sarray.c \\\n    selector.c \\\n    sendmsg.c \\"}, {"sha": "727b26f4b97773781388229dbe7e0ecebf666439", "filename": "libobjc/class.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fclass.c?ref=debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "patch": "@@ -139,7 +139,8 @@ static class_node_ptr class_table_array[CLASS_TABLE_SIZE];\n /* The table writing mutex - we lock on writing to avoid conflicts\n    between different writers, but we read without locks.  That is\n    possible because we assume pointer assignment to be an atomic\n-   operation.  */\n+   operation.  TODO: This is only true under certain circumstances,\n+   which should be clarified.  */\n static objc_mutex_t __class_table_lock = NULL;\n \n /* CLASS_TABLE_HASH is how we compute the hash of a class name.  It is\n@@ -730,7 +731,14 @@ __objc_resolve_class_links (void)\n   objc_mutex_unlock (__objc_runtime_mutex);\n }\n \n+const char *\n+class_getName (Class class_)\n+{\n+  if (class_ == Nil)\n+    return \"nil\";\n \n+  return class_->name;\n+}\n \n #define CLASSOF(c) ((c)->class_pointer)\n "}, {"sha": "9384f5865c35c8125b829e1751b0ffc5ddd1d6b2", "filename": "libobjc/init.c", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Finit.c?ref=debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "patch": "@@ -33,6 +33,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include \"objc-private/objc-list.h\" \n #include \"objc-private/runtime.h\"\n #include \"objc-private/objc-sync.h\" /* For __objc_sync_init() */\n+#include \"objc-private/protocols.h\" /* For __objc_protocols_init() and __objc_protocols_add_protocol() */\n \n /* The version number of this runtime.  This must match the number \n    defined in gcc (objc-act.c).  */\n@@ -48,7 +49,17 @@ static struct objc_list *unclaimed_proto_list = 0; \t/* !T:MUTEX */\n /* List of unresolved static instances.  */\n static struct objc_list *uninitialized_statics = 0; \t/* !T:MUTEX */\n \n-/* Global runtime \"write\" mutex.  */\n+/* Global runtime \"write\" mutex.  Having a single mutex prevents\n+   deadlocks, but reduces concurrency.  To improve concurrency, some\n+   groups of functions in the runtime have their own separate mutex\n+   (eg, __class_table_lock in class.c); to avoid deadlocks, these\n+   routines must make sure that they never acquire any other lock\n+   while holding their own local lock.  Ie, they should lock, execute\n+   some C code that does not perform any calls to other runtime\n+   functions which may potentially lock different locks, then unlock.\n+   If they need to perform any calls to other runtime functions that\n+   may potentially lock other locks, then they should use the global\n+   __objc_runtime_mutex.  */\n objc_mutex_t __objc_runtime_mutex = 0;\n \n /* Number of threads that are alive.  */\n@@ -551,6 +562,7 @@ __objc_exec_class (Module_t module)\n       __objc_load_methods = objc_hash_new (128, \n \t\t\t\t\t   (hash_func_type)objc_hash_ptr,\n \t\t\t\t\t   objc_compare_ptrs);\n+      __objc_protocols_init ();\n       __objc_sync_init ();\n       previous_constructors = 1;\n     }\n@@ -862,10 +874,14 @@ __objc_init_protocols (struct objc_protocol_list *protos)\n       struct objc_protocol *aProto = protos->list[i];\n       if (((size_t)aProto->class_pointer) == PROTOCOL_VERSION)\n \t{\n-\t  /* assign class pointer */\n+\t  /* Assign class pointer */\n \t  aProto->class_pointer = proto_class;\n \n-\t  /* init super protocols */\n+\t  /* Register the protocol in the hashtable or protocols by\n+\t     name.  */\n+\t  __objc_protocols_add_protocol (aProto->protocol_name, aProto);\n+\n+\t  /* Init super protocols */\n \t  __objc_init_protocols (aProto->protocol_list);\n \t}\n       else if (protos->list[i]->class_pointer != proto_class)"}, {"sha": "120f5139d045c16c22b330cd06f25581b155cc77", "filename": "libobjc/objc-private/module-abi-8.h", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fobjc-private%2Fmodule-abi-8.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fobjc-private%2Fmodule-abi-8.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-private%2Fmodule-abi-8.h?ref=debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "patch": "@@ -138,6 +138,24 @@ struct objc_method_list\n \t\t\t\t\t     structure. */\n };\n \n+/* Currently defined in Protocol.m (that definition should go away\n+   once we include this file).  */\n+struct objc_method_description_list\n+{\n+  int count;\n+  struct objc_method_description list[1];\n+};\n+\n+/* Currently defined by objc/objc.h.  */\n+/*\n+struct objc_protocol {\n+  struct objc_class* class_pointer;\n+  char *protocol_name;\n+  struct objc_protocol_list *protocol_list;\n+  struct objc_method_description_list *instance_methods, *class_methods; \n+};\n+*/\n+\n struct objc_protocol_list\n {\n   struct objc_protocol_list *next;\n@@ -155,6 +173,7 @@ struct objc_protocol_list\n   some members change type. The compiler generates \"char* const\" and\n   places a string in the following member variables: super_class.\n */\n+#ifndef __objc_STRUCT_OBJC_CLASS_defined\n struct objc_class {     \n   struct objc_class*  class_pointer;    /* Pointer to the class's meta\n \t\t\t\t\t   class. */\n@@ -197,6 +216,7 @@ struct objc_class {\n   struct objc_protocol_list *protocols; /* Protocols conformed to */\n   void* gc_object_type;\n };\n+#endif /* __objc_STRUCT_OBJC_CLASS_defined */\n \n /* The compiler generates one of these structures for each category.\n    A class may have many categories and contain both instance and"}, {"sha": "49a2d92648f3baa279977082e66a819a261c76e1", "filename": "libobjc/objc-private/protocols.h", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fobjc-private%2Fprotocols.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fobjc-private%2Fprotocols.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-private%2Fprotocols.h?ref=debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "patch": "@@ -0,0 +1,46 @@\n+/* GNU Objective C Runtime protocols - Private functions\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Nicola Pero <nicola.pero@meta-innovation.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 3, or (at your option) any later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef __objc_private_protocols_INCLUDE_GNU\n+#define __objc_private_protocols_INCLUDE_GNU\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif /* __cplusplus */\n+\n+/* This function needs to be called at startup by init.c.  */\n+void\n+__objc_protocols_init (void);\n+\n+/* This function adds a protocol to the internal hashtable of\n+   protocols by name, which allows objc_getProtocol(name) to be\n+   implemented efficiently.  */\n+void\n+__objc_protocols_add_protocol (const char *name, Protocol *object);\n+\n+#ifdef __cplusplus\n+}\n+#endif /* __cplusplus */\n+\n+#endif /* not __objc_private_protocols_INCLUDE_GNU */"}, {"sha": "3917c3ef3b03c1de2ef0df3d2b7dfbb1c414f318", "filename": "libobjc/objc-private/runtime.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fobjc-private%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fobjc-private%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc-private%2Fruntime.h?ref=debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "patch": "@@ -58,18 +58,18 @@ extern void __objc_init_dispatch_tables(void); /* (objc-dispatch.c) */\n extern void __objc_install_premature_dtable(Class); /* (objc-dispatch.c) */\n extern void __objc_resolve_class_links(void);  /* (objc-class.c) */\n extern void __objc_register_selectors_from_class(Class); /* (objc-sel.c) */\n-extern void __objc_register_selectors_from_list (MethodList_t); /* (selector.c) */\n+extern void __objc_register_selectors_from_list (struct objc_method_list *); /* (selector.c) */\n extern void __objc_update_dispatch_table_for_class (Class);/* (objc-msg.c) */\n \n extern int  __objc_init_thread_system(void);    /* thread.c */\n extern int  __objc_fini_thread_system(void);    /* thread.c */\n extern void __objc_print_dtable_stats(void);    /* sendmsg.c */\n \n-extern void class_add_method_list(Class, MethodList_t);\n+extern void class_add_method_list(Class, struct objc_method_list *);\n \n /* Registering instance methods as class methods for root classes */\n extern void __objc_register_instance_methods_to_class(Class);\n-extern Method_t search_for_method_in_list(MethodList_t list, SEL op);\n+extern struct objc_method * search_for_method_in_list(struct objc_method_list * list, SEL op);\n \n /* True when class links has been resolved */     \n extern BOOL __objc_class_links_resolved;"}, {"sha": "07927feb69d7679568cdf711e2c4324330bbf356", "filename": "libobjc/objc/deprecated/struct_objc_class.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fobjc%2Fdeprecated%2Fstruct_objc_class.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fobjc%2Fdeprecated%2Fstruct_objc_class.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fdeprecated%2Fstruct_objc_class.h?ref=debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "patch": "@@ -1,4 +1,5 @@\n /* This structure used to be public, but is now private to the runtime.  */\n+#define __objc_STRUCT_OBJC_CLASS_defined\n \n /*\n ** The compiler generates one of these structures for each class.  "}, {"sha": "b5ae87bc7c82489f55d6cd02e622cd3f3f992c6a", "filename": "libobjc/objc/runtime.h", "status": "modified", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fruntime.h?ref=debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "patch": "@@ -356,6 +356,138 @@ objc_EXPORT int objc_getClassList (Class *returnValue, int maxNumberOfClassesToR\n    the documentation is unclear on what they are supposed to do, and\n    the GNU Objective-C Runtime currently does not provide them.  */\n \n+/* Return the name of the class 'class_', or the string \"nil\" if the\n+   class_ is Nil.  */\n+objc_EXPORT const char * class_getName (Class class_);\n+\n+\n+/** Implementation: the following functions are in protocols.c.  */\n+\n+/* Return the protocol with name 'name', or nil if it the protocol is\n+   not known to the runtime.  */\n+objc_EXPORT Protocol *objc_getProtocol (const char *name);\n+\n+/* Return all the protocols known to the runtime.  The return value of\n+   the function is a pointer to an area, allocated with malloc(), that\n+   contains all the protocols known to the runtime; the list is\n+   terminated by NULL.  You should free this area using free() once\n+   you no longer need it.  Optionally, if you pass a non-NULL\n+   'numberOfReturnedProtocols' pointer, the unsigned int that it\n+   points to will be filled with the number of protocols returned.  If\n+   there are no protocols known to the runtime, NULL is returned.  */\n+objc_EXPORT Protocol **objc_copyProtocolList (unsigned int *numberOfReturnedProtocols);\n+\n+/* Add a protocol to a class, and return YES if it was done\n+   succesfully, and NO if not.  At the moment, NO should only happen\n+   if class_ or protocol are nil, if the protocol is not a Protocol\n+   object or if the class already conforms to the protocol.  */\n+objc_EXPORT BOOL class_addProtocol (Class class_, Protocol *protocol);\n+\n+/* Return YES if the class 'class_' conforms to Protocol 'protocol',\n+   and NO if not.  */\n+objc_EXPORT BOOL class_conformsToProtocol (Class class_, Protocol *protocol);\n+\n+/* Return all the protocols that the class conforms to.  The return\n+   value of the function is a pointer to an area, allocated with\n+   malloc(), that contains all the protocols formally adopted by the\n+   class.  It does not include protocols adopted by superclasses.  The\n+   list is terminated by NULL.  Optionally, if you pass a non-NULL\n+   'numberOfReturnedProtocols' pointer, the unsigned int that it\n+   points to will be filled with the number of protocols returned.  */\n+objc_EXPORT Protocol **class_copyProtocolList (Class class_, unsigned int *numberOfReturnedProtocols);\n+\n+/* Return YES if protocol 'protocol' conforms to protocol\n+   'anotherProtocol', and NO if not.  Note that if one of the two\n+   protocols is nil, it returns NO.  */\n+objc_EXPORT BOOL protocol_conformsToProtocol (Protocol *protocol, Protocol *anotherProtocol);\n+\n+/* Return YES if protocol 'protocol' is the same as protocol\n+   'anotherProtocol', and 'NO' if not.  Note that it returns YES if\n+   the two protocols are both nil.  */\n+objc_EXPORT BOOL protocol_isEqual (Protocol *protocol, Protocol *anotherProtocol);\n+\n+/* Return the name of protocol 'protocol'.  If 'protocol' is nil or is\n+   not a Protocol, return NULL.  */\n+objc_EXPORT const char *protocol_getName (Protocol *protocol);\n+\n+/* Return the method description for the method with selector\n+   'selector' in protocol 'protocol'; if 'requiredMethod' is YES, the\n+   function searches the list of required methods; if NO, the list of\n+   optional methods.  If 'instanceMethod' is YES, the function search\n+   for an instance method; if NO, for a class method.  If there is no\n+   matching method, an objc_method_description structure with both\n+   name and types set to NULL is returned.  This function will only\n+   find methods that are directly declared in the protocol itself, not\n+   in other protocols that this protocol adopts.\n+\n+   Note that the traditional ABI does not store the list of optional\n+   methods of a protocol in a compiled module, so the traditional ABI\n+   will always return (NULL, NULL) when requiredMethod == NO.  */\n+objc_EXPORT struct objc_method_description protocol_getMethodDescription (Protocol *protocol, \n+\t\t\t\t\t\t\t\t\t  SEL selector,\n+\t\t\t\t\t\t\t\t\t  BOOL requiredMethod,\n+\t\t\t\t\t\t\t\t\t  BOOL instanceMethod);\n+\n+/* Return the method descriptions of all the methods of the protocol.\n+   The return value of the function is a pointer to an area, allocated\n+   with malloc(), that contains all the method descriptions of the\n+   methods of the protocol.  It does not recursively include methods\n+   of the protocols adopted by this protocol.  The list is terminated\n+   by a NULL objc_method_description (one with both fields set to\n+   NULL).  Optionally, if you pass a non-NULL\n+   'numberOfReturnedMethods' pointer, the unsigned int that it points\n+   to will be filled with the number of properties returned.\n+\n+   Note that the traditional ABI does not store the list of optional\n+   methods of a protocol in a compiled module, so the traditional ABI\n+   will always return an empty list if requiredMethod is set to\n+   NO.  */\n+objc_EXPORT struct objc_method_description *protocol_copyMethodDescriptionList (Protocol *protocol,\n+\t\t\t\t\t\t\t\t\t\tBOOL requiredMethod,\n+\t\t\t\t\t\t\t\t\t\tBOOL instanceMethod,\n+\t\t\t\t\t\t\t\t\t\tunsigned int *numberOfReturnedMethods);\n+\n+/* Return the property with name 'propertyName' of the protocol\n+   'protocol'.  If 'requiredProperty' is YES, the function searches\n+   the list of required properties; if NO, the list of optional\n+   properties.  If 'instanceProperty' is YES, the function searches\n+   the list of instance properties; if NO, the list of class\n+   properties.  At the moment, optional properties and class\n+   properties are not part of the Objective-C language, so both\n+   'requiredProperty' and 'instanceProperty' should be set to YES.\n+   This function returns NULL if the required property can not be\n+   found.\n+\n+   Note that the traditional ABI does not store the list of properties\n+   of a protocol in a compiled module, so the traditional ABI will\n+   always return NULL.  */\n+objc_EXPORT Property protocol_getProperty (Protocol *protocol, const char *propertyName, \n+\t\t\t\t\t   BOOL requiredProperty, BOOL instanceProperty);\n+\n+/* Return all the properties of the protocol.  The return value of the\n+   function is a pointer to an area, allocated with malloc(), that\n+   contains all the properties of the protocol.  It does not\n+   recursively include properties of the protocols adopted by this\n+   protocol.  The list is terminated by NULL.  Optionally, if you pass\n+   a non-NULL 'numberOfReturnedProperties' pointer, the unsigned int\n+   that it points to will be filled with the number of properties\n+   returned.\n+\n+   Note that the traditional ABI does not store the list of properties\n+   of a protocol in a compiled module, so the traditional ABI will\n+   always return NULL and store 0 in numberOfReturnedProperties.  */\n+objc_EXPORT Property *protocol_copyPropertyList (Protocol *protocol, unsigned int *numberOfReturnedProperties);\n+\n+/* Return all the protocols that the protocol conforms to.  The return\n+   value of the function is a pointer to an area, allocated with\n+   malloc(), that contains all the protocols formally adopted by the\n+   protocol.  It does not recursively include protocols adopted by the\n+   protocols adopted by this protocol.  The list is terminated by\n+   NULL.  Optionally, if you pass a non-NULL\n+   'numberOfReturnedProtocols' pointer, the unsigned int that it\n+   points to will be filled with the number of protocols returned.  */\n+objc_EXPORT Protocol **protocol_copyProtocolList (Protocol *protocol, unsigned int *numberOfReturnedProtocols);\n+\n \n /* TODO: Add all the other functions in the API.  */\n "}, {"sha": "af62a2dba3affd169f036550e4c851cafb9a62d6", "filename": "libobjc/protocols.c", "status": "added", "additions": 550, "deletions": 0, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fprotocols.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fprotocols.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fprotocols.c?ref=debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "patch": "@@ -0,0 +1,550 @@\n+/* GNU Objective C Runtime protocol related functions.\n+   Copyright (C) 2010 Free Software Foundation, Inc.\n+   Contributed by Nicola Pero\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under the\n+terms of the GNU General Public License as published by the Free Software\n+Foundation; either version 3, or (at your option) any later version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n+FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n+details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"objc-private/common.h\"\n+#include \"objc/objc.h\"\n+#include \"objc/runtime.h\"\n+#include \"objc-private/module-abi-8.h\" /* For runtime structures  */\n+#include \"objc/thr.h\"\n+#include \"objc-private/runtime.h\"      /* the kitchen sink */\n+#include \"objc-private/hash.h\"         /* For the hash table of protocols.  */\n+#include \"objc-private/protocols.h\"    /* For __objc_protocols_init() and __objc_protocols_add_protocol() */\n+\n+/* This is a table that maps a name to a Protocol instance with that\n+   name.  Because there may be multiple Protocol instances with the\n+   same name (no harm in that) the table records only one\n+   instance.  */\n+static cache_ptr __protocols_hashtable;\n+\n+/* A mutex protecting the protocol_hashtable.  */\n+static objc_mutex_t __protocols_hashtable_lock = NULL;\n+\n+/* Called at startup by init.c.  */\n+void\n+__objc_protocols_init (void)\n+{\n+  __protocols_hashtable_lock = objc_mutex_allocate ();\n+\n+  /* The keys in the table are strings, and the values are Protocol\n+     objects.  */\n+  __protocols_hashtable = objc_hash_new (64, (hash_func_type) objc_hash_string,\n+\t\t\t\t\t (compare_func_type) objc_compare_strings);\n+}\n+\n+/* Add a protocol to the hashtable.  */\n+void\n+__objc_protocols_add_protocol (const char *name, Protocol *object)\n+{\n+  objc_mutex_lock (__protocols_hashtable_lock);\n+\n+  /* If we find a protocol with the same name already in the\n+     hashtable, we do not need to add the new one, because it will be\n+     identical to it.  This in the reasonable assumption that two\n+     protocols with the same name are identical, which is expected in\n+     any sane program.  If we are really paranoid, we would compare\n+     the protocols and abort if they are not identical.\n+     Unfortunately, this would slow down the startup of all\n+     Objective-C programs while trying to catch a problem that has\n+     never been seen in practice, so we don't do it.  */\n+  if (! objc_hash_is_key_in_hash (__protocols_hashtable, name))\n+    {\n+      objc_hash_add (&__protocols_hashtable, name, object);\n+    }\n+\n+  objc_mutex_unlock (__protocols_hashtable_lock);\n+}\n+\n+Protocol *\n+objc_getProtocol (const char *name)\n+{\n+  Protocol *protocol;\n+\n+  if (name == NULL)\n+    return NULL;\n+\n+  objc_mutex_lock (__protocols_hashtable_lock);\n+  protocol = (Protocol *)(objc_hash_value_for_key (__protocols_hashtable, name));\n+  objc_mutex_unlock (__protocols_hashtable_lock);\n+\n+  return protocol;\n+}\n+\n+Protocol **\n+objc_copyProtocolList (unsigned int *numberOfReturnedProtocols)\n+{\n+  unsigned int count = 0;\n+  Protocol **returnValue = NULL;\n+  node_ptr node;\n+\n+  objc_mutex_lock (__protocols_hashtable_lock);\n+\n+  /* Count how many protocols we have.  */\n+  node = objc_hash_next (__protocols_hashtable, NULL);\n+  while (node)\n+    {\n+      count++;\n+      node = objc_hash_next (__protocols_hashtable, node);\n+    }\n+\n+  if (count != 0)\n+    {\n+      unsigned int i = 0;\n+\n+      /* Allocate enough memory to hold them.  */\n+      returnValue = (Protocol **)(malloc (sizeof (Protocol *) * (count + 1)));\n+      \n+      /* Copy the protocols.  */\n+      node = objc_hash_next (__protocols_hashtable, NULL);\n+      while (node)\n+\t{\n+\t  returnValue[i] = node->value;\n+\t  i++;\n+\t  node = objc_hash_next (__protocols_hashtable, node);\n+\t}\n+\n+      returnValue[i] = NULL;\n+    }\n+  objc_mutex_unlock (__protocols_hashtable_lock);\n+\n+  if (numberOfReturnedProtocols)\n+    *numberOfReturnedProtocols = count;\n+\n+  return returnValue;\n+}\n+\n+BOOL \n+class_addProtocol (Class class_, Protocol *protocol)\n+{\n+  struct objc_protocol_list *protocols;\n+\n+  if (class_ == Nil  ||  protocol == NULL)\n+    return NO;\n+\n+  if (class_conformsToProtocol (class_, protocol))\n+    return NO;\n+\n+  /* Check that it is a Protocol object before casting it to (struct\n+     objc_protocol *).  */\n+  if (protocol->class_pointer != objc_lookupClass (\"Protocol\"))\n+    return NO;\n+\n+  objc_mutex_lock (__objc_runtime_mutex);\n+\n+  /* Create the objc_protocol_list.  */\n+  protocols = malloc (sizeof (struct objc_protocol_list));\n+  protocols->count = 1;\n+  protocols->list[0] = protocol;\n+\n+  /* Attach it to the list of class protocols.  */\n+  protocols->next = class_->protocols;\n+  class_->protocols = protocols;\n+\n+  objc_mutex_unlock (__objc_runtime_mutex);\n+\n+  return YES;\n+}\n+\n+BOOL \n+class_conformsToProtocol (Class class_, Protocol *protocol)\n+{\n+  struct objc_protocol_list* proto_list;\n+\n+  if (class_ == Nil  ||  protocol == NULL)\n+    return NO;\n+\n+  /* Check that it is a Protocol object before casting it to (struct\n+     objc_protocol *).  */\n+  if (protocol->class_pointer != objc_lookupClass (\"Protocol\"))\n+    return NO;\n+\n+  /* Acquire the runtime lock because the list of protocols for a\n+     class may be modified concurrently, for example if another thread\n+     calls class_addProtocol(), or dynamically loads from a file a\n+     category of the class.  */\n+  objc_mutex_lock (__objc_runtime_mutex);\n+  proto_list = class_->protocols;\n+\n+  while (proto_list)\n+    {\n+      size_t i;\n+      for (i = 0; i < proto_list->count; i++)\n+\t{\n+\t  if (proto_list->list[i] == protocol\n+\t      || protocol_conformsToProtocol (proto_list->list[i],\n+\t\t\t\t\t      protocol))\n+\t    {\n+\t      objc_mutex_unlock (__objc_runtime_mutex);\n+\t      return YES;\n+\t    }\n+\t}\n+      proto_list = proto_list->next;\n+    }\n+  \n+  objc_mutex_unlock (__objc_runtime_mutex);\n+  return NO;\n+}\n+\n+Protocol **\n+class_copyProtocolList (Class class_, unsigned int *numberOfReturnedProtocols)\n+{\n+  unsigned int count = 0;\n+  Protocol **returnValue = NULL;\n+  struct objc_protocol_list* proto_list;\n+\n+  /* Lock the runtime mutex because the class protocols may be\n+     concurrently modified.  */\n+  objc_mutex_lock (__objc_runtime_mutex);\n+\n+  /* Count how many protocols we have.  */\n+  proto_list = class_->protocols;\n+\n+  while (proto_list)\n+    {\n+      count = count + proto_list->count;\n+      proto_list = proto_list->next;\n+    }\n+\n+  if (count != 0)\n+    {\n+      unsigned int i = 0;\n+      \n+      /* Allocate enough memory to hold them.  */\n+      returnValue = (Protocol **)(malloc (sizeof (Protocol *) * (count + 1)));\n+      \n+      /* Copy the protocols.  */\n+      proto_list = class_->protocols;\n+      \n+      while (proto_list)\n+\t{\n+\t  size_t j;\n+\t  for (j = 0; j < proto_list->count; j++)\n+\t    {\n+\t      returnValue[i] = proto_list->list[j];\n+\t      i++;\n+\t    }\n+\t  proto_list = proto_list->next;\n+\t}\n+      \n+      returnValue[i] = NULL;\n+    }\n+  objc_mutex_unlock (__objc_runtime_mutex);\n+\n+  if (numberOfReturnedProtocols)\n+    *numberOfReturnedProtocols = count;\n+\n+  return returnValue;\n+}\n+\n+BOOL \n+protocol_conformsToProtocol (Protocol *protocol, Protocol *anotherProtocol)\n+{\n+  struct objc_protocol_list* proto_list;\n+\n+  if (protocol == NULL  ||  anotherProtocol == NULL)\n+    return NO;\n+\n+  if (protocol == anotherProtocol)\n+    return YES;\n+    \n+  /* Check that the objects are Protocol objects before casting them\n+     to (struct objc_protocol *).  */\n+  if (protocol->class_pointer != anotherProtocol->class_pointer)\n+    return NO;\n+  \n+  if (protocol->class_pointer != objc_lookupClass (\"Protocol\"))\n+    return NO;\n+\n+  if (strcmp (((struct objc_protocol *)protocol)->protocol_name,\n+\t      ((struct objc_protocol *)anotherProtocol)->protocol_name) == 0)\n+    return YES;\n+\n+  /* We do not acquire any lock because protocols are currently\n+     immutable.  We can freely iterate over a protocol structure.  */\n+  proto_list = ((struct objc_protocol *)protocol)->protocol_list;\n+  while (proto_list)\n+    {\n+      size_t i;\n+      \n+      for (i = 0; i < proto_list->count; i++)\n+\t{\n+\t  if (protocol_conformsToProtocol (proto_list->list[i], anotherProtocol))\n+\t    return YES;\n+\t}\n+      proto_list = proto_list->next;\n+    }\n+\n+  return NO;\n+}\n+\n+BOOL \n+protocol_isEqual (Protocol *protocol, Protocol *anotherProtocol)\n+{\n+  if (protocol == anotherProtocol)\n+    return YES;\n+\n+  if (protocol == NULL  ||  anotherProtocol == NULL)\n+    return NO;\n+  \n+  /* Check that the objects are Protocol objects before casting them\n+     to (struct objc_protocol *).  */\n+  if (protocol->class_pointer != anotherProtocol->class_pointer)\n+    return NO;\n+  \n+  if (protocol->class_pointer != objc_lookupClass (\"Protocol\"))\n+    return NO;\n+\n+  /* Equality between formal protocols is only formal (nothing to do\n+     with actually checking the list of methods they have!).  Two\n+     formal Protocols are equal if and only if they have the same\n+     name.\n+\n+     Please note (for comparisons with other implementations) that\n+     checking the names is equivalent to checking that Protocol A\n+     conforms to Protocol B and Protocol B conforms to Protocol A,\n+     because this happens iff they have the same name.  If they have\n+     different names, A conforms to B if and only if A includes B, but\n+     the situation where A includes B and B includes A is a circular\n+     dependency between Protocols which is forbidden by the compiler,\n+     so A conforms to B and B conforms to A with A and B having\n+     different names is an impossible case.  */\n+  if (strcmp (((struct objc_protocol *)protocol)->protocol_name,\n+\t      ((struct objc_protocol *)anotherProtocol)->protocol_name) == 0)\n+    return YES;\n+  \n+  return NO;\n+}\n+\n+const char *\n+protocol_getName (Protocol *protocol)\n+{\n+  /* Check that it is a Protocol object before casting it to (struct\n+     objc_protocol *).  */\n+  if (protocol->class_pointer != objc_lookupClass (\"Protocol\"))\n+    return NULL;\n+\n+  return ((struct objc_protocol *)protocol)->protocol_name;\n+}\n+\n+struct objc_method_description protocol_getMethodDescription (Protocol *protocol, \n+\t\t\t\t\t\t\t      SEL selector,\n+\t\t\t\t\t\t\t      BOOL requiredMethod,\n+\t\t\t\t\t\t\t      BOOL instanceMethod)\n+{\n+  struct objc_method_description no_result = { NULL, NULL };\n+  const char* selector_name;\n+  struct objc_method_description_list *methods;\n+  int i;\n+\n+  /* TODO: New ABI.  */\n+  /* The current ABI does not have any information on optional protocol methods.  */\n+  if (! requiredMethod)\n+    return no_result;\n+\n+  /* Check that it is a Protocol object before casting it to (struct\n+     objc_protocol *).  */\n+  if (protocol->class_pointer != objc_lookupClass (\"Protocol\"))\n+    return no_result;\n+\n+  selector_name = sel_getName (selector);\n+\n+  if (instanceMethod)\n+    methods = ((struct objc_protocol *)protocol)->instance_methods;\n+  else\n+    methods = ((struct objc_protocol *)protocol)->class_methods;\n+\n+  if (methods)\n+    {\n+      for (i = 0; i < methods->count; i++)\n+\t{\n+\t  if (strcmp ((char*)(methods->list[i].name), selector_name) == 0)\n+\t    return methods->list[i];\n+\t}\n+    }\n+\n+  return no_result;\n+}\n+\n+struct objc_method_description *protocol_copyMethodDescriptionList (Protocol *protocol,\n+\t\t\t\t\t\t\t\t    BOOL requiredMethod,\n+\t\t\t\t\t\t\t\t    BOOL instanceMethod,\n+\t\t\t\t\t\t\t\t    unsigned int *numberOfReturnedMethods)\n+{\n+  struct objc_method_description_list *methods;\n+  unsigned int count = 0;\n+  struct objc_method_description *returnValue = NULL;\n+\n+  /* TODO: New ABI */\n+  /* The current ABI does not have any information on optional protocol methods.  */\n+  if (! requiredMethod)\n+    {\n+      if (numberOfReturnedMethods)\n+\t*numberOfReturnedMethods = 0;\n+\n+      return NULL;\n+    }\n+\n+  /* Check that it is a Protocol object before casting it to (struct\n+     objc_protocol *).  */\n+  if (protocol == NULL  ||  protocol->class_pointer != objc_lookupClass (\"Protocol\"))\n+    {\n+      if (numberOfReturnedMethods)\n+\t*numberOfReturnedMethods = 0;\n+\n+      return NULL;\n+    }\n+  \n+  /* We do not acquire any lock because protocols are currently\n+     immutable.  We can freely iterate over a protocol structure.  */\n+\n+  if (instanceMethod)\n+    methods = ((struct objc_protocol *)protocol)->instance_methods;\n+  else\n+    methods = ((struct objc_protocol *)protocol)->class_methods;\n+\n+  if (methods)\n+    {\n+      unsigned int i;\n+      count = methods->count;\n+\n+      /* Allocate enough memory to hold them.  */\n+      returnValue = (struct objc_method_description *)(malloc (sizeof (struct objc_method_description) * (count + 1)));\n+\n+      /* Copy them.  */\n+      for (i = 0; i < count; i++)\n+\t{\n+\t  returnValue[i].name = methods->list[i].name;\n+\t  returnValue[i].types = methods->list[i].types;\n+\t}\n+      returnValue[i].name = NULL;\n+      returnValue[i].types = NULL;\n+    }\n+\n+  if (numberOfReturnedMethods)\n+    *numberOfReturnedMethods = count;\n+\n+  return returnValue;\n+}\n+\n+Property protocol_getProperty (Protocol *protocol, const char *propertyName, \n+\t\t\t       BOOL requiredProperty, BOOL instanceProperty)\n+{\n+  if (protocol == NULL  ||  propertyName == NULL)\n+    return NULL;\n+\n+  if (!requiredProperty  ||  !instanceProperty)\n+    return NULL;\n+\n+  /* Check that it is a Protocol object before casting it to (struct\n+     objc_protocol *).  */\n+  if (protocol->class_pointer != objc_lookupClass (\"Protocol\"))\n+    return NULL;\n+\n+  /* TODO: New ABI.  */\n+  /* The current ABI does not have any information on protocol properties.  */\n+  return NULL;\n+}\n+\n+Property *protocol_copyPropertyList (Protocol *protocol, unsigned int *numberOfReturnedProperties)\n+{\n+  unsigned int count = 0;\n+  Property *returnValue = NULL;\n+\n+  /* Check that it is a Protocol object before casting it to (struct\n+     objc_protocol *).  */\n+  if (protocol == NULL  ||  protocol->class_pointer != objc_lookupClass (\"Protocol\"))\n+    {\n+      if (numberOfReturnedProperties)\n+\t*numberOfReturnedProperties = 0;\n+\n+      return NULL;\n+    }\n+  \n+  /* We do not acquire any lock because protocols are currently\n+     immutable.  We can freely iterate over a protocol structure.  */\n+\n+  /* TODO: New ABI.  */\n+  /* The current ABI does not have any information on protocol properties.  */\n+  if (numberOfReturnedProperties)\n+    *numberOfReturnedProperties = count;\n+\n+  return returnValue;\n+}\n+\n+Protocol **protocol_copyProtocolList (Protocol *protocol, unsigned int *numberOfReturnedProtocols)\n+{\n+  unsigned int count = 0;\n+  Protocol **returnValue = NULL;\n+  struct objc_protocol_list* proto_list;\n+\n+  /* Check that it is a Protocol object before casting it to (struct\n+     objc_protocol *).  */\n+  if (protocol == NULL  ||  protocol->class_pointer != objc_lookupClass (\"Protocol\"))\n+    {\n+      if (numberOfReturnedProtocols)\n+\t*numberOfReturnedProtocols = 0;\n+\n+      return NULL;\n+    }\n+  \n+  /* We do not acquire any lock because protocols are currently\n+     immutable.  We can freely iterate over a protocol structure.  */\n+\n+  /* Count how many protocols we have.  */\n+  proto_list = ((struct objc_protocol *)protocol)->protocol_list;\n+\n+  while (proto_list)\n+    {\n+      count = count + proto_list->count;\n+      proto_list = proto_list->next;\n+    }\n+\n+  if (count != 0)\n+    {\n+      unsigned int i = 0;\n+      \n+      /* Allocate enough memory to hold them.  */\n+      returnValue = (Protocol **)(malloc (sizeof (Protocol *) * (count + 1)));\n+      \n+      /* Copy the protocols.  */\n+      proto_list = ((struct objc_protocol *)protocol)->protocol_list;\n+      \n+      while (proto_list)\n+\t{\n+\t  size_t j;\n+\t  for (j = 0; j < proto_list->count; j++)\n+\t    {\n+\t      returnValue[i] = proto_list->list[j];\n+\t      i++;\n+\t    }\n+\t  proto_list = proto_list->next;\n+\t}\n+\n+      returnValue[i] = NULL;\n+    }\n+\n+  if (numberOfReturnedProtocols)\n+    *numberOfReturnedProtocols = count;\n+\n+  return returnValue;\n+}"}, {"sha": "0c12130ae3807dcaaaefb5906a6f881d8557a9de", "filename": "libobjc/selector.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fselector.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/debfbfeefc5f8c9236c1de2de874df52eaf8c8c4/libobjc%2Fselector.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fselector.c?ref=debfbfeefc5f8c9236c1de2de874df52eaf8c8c4", "patch": "@@ -163,6 +163,14 @@ void __objc_register_instance_methods_to_class (Class class)\n     __objc_update_dispatch_table_for_class (class->class_pointer);\n }\n \n+BOOL\n+sel_isEqual (SEL s1, SEL s2)\n+{\n+  if (s1 == 0 || s2 == 0)\n+    return s1 == s2;\n+  else\n+    return s1->sel_id == s2->sel_id;\n+}\n \n /* Returns YES iff t1 and t2 have same method types, but we ignore\n    the argframe layout */"}]}