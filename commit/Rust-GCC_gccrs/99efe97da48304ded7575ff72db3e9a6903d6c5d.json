{"sha": "99efe97da48304ded7575ff72db3e9a6903d6c5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTllZmU5N2RhNDgzMDRkZWQ3NTc1ZmY3MmRiM2U5YTY5MDNkNmM1ZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-06-19T07:24:02Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-06-19T07:24:02Z"}, "message": "Add new micro-benchmark for string operations.\n\n2019-06-19  Martin Liska  <mliska@suse.cz>\n\n\t* bench-stringop: New file.\n\nFrom-SVN: r272469", "tree": {"sha": "85ddc83b841d98645bbdd721703904181a045242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/85ddc83b841d98645bbdd721703904181a045242"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99efe97da48304ded7575ff72db3e9a6903d6c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99efe97da48304ded7575ff72db3e9a6903d6c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99efe97da48304ded7575ff72db3e9a6903d6c5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99efe97da48304ded7575ff72db3e9a6903d6c5d/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "20b603dba4bea71cbdf9dde7db44d6b5bbcb7654", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20b603dba4bea71cbdf9dde7db44d6b5bbcb7654"}], "stats": {"total": 162, "additions": 162, "deletions": 0}, "files": [{"sha": "56aaec909d0940947599efe6ce285e14f98f8a6b", "filename": "contrib/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99efe97da48304ded7575ff72db3e9a6903d6c5d/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99efe97da48304ded7575ff72db3e9a6903d6c5d/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=99efe97da48304ded7575ff72db3e9a6903d6c5d", "patch": "@@ -1,3 +1,7 @@\n+2019-06-19  Martin Liska  <mliska@suse.cz>\n+\n+\t* bench-stringop: New file.\n+\n 2019-05-21  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* mklog: Open files in text mode."}, {"sha": "7af8bfd96a063901dedecf8a396f644d418ad4e8", "filename": "contrib/bench-stringop", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99efe97da48304ded7575ff72db3e9a6903d6c5d/contrib%2Fbench-stringop", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99efe97da48304ded7575ff72db3e9a6903d6c5d/contrib%2Fbench-stringop", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fbench-stringop?ref=99efe97da48304ded7575ff72db3e9a6903d6c5d", "patch": "@@ -0,0 +1,158 @@\n+#!/bin/bash\n+\n+# Script to measure memset and memcpy for different sizes and strategies.\n+#\n+# Contributed by Jan Hubicka <jh@suse.cz>\n+#\n+# Copyright (C) 2019 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING.  If not, write to\n+# the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+# Boston, MA 02110-1301, USA.\n+\n+# This script will search a line starting with 'spawn' that includes the\n+# pattern you are looking for (typically a source file name).\n+#\n+# Once it finds that pattern, it re-executes the whole command\n+# in the spawn line.  If the pattern matches more than one spawn\n+# command, it asks which one you want.\n+\n+test()\n+{\n+rm -f a.out\n+cat <<END | $1 -x c -O3 $3 -DAVG_SIZE=$2 $STRINGOP -DMEMORY_COPIES=$memsize -\n+#define BUFFER_SIZE (16*1024*1024 + AVG_SIZE*2)\n+/*#define MEMORY_COPIES (1024*1024*64*(long long)10)*/\n+$type t[BUFFER_SIZE];\n+int main()\n+{\n+  unsigned int i;\n+  for (i=0;i<((long long)MEMORY_COPIES + AVG_SIZE * 2 - 1)/AVG_SIZE*2;i++)\n+#ifdef test_memset\n+    __builtin_memset (t+(i*1024*1024+i*1)%(BUFFER_SIZE - AVG_SIZE*2), i, (AVG_SIZE + i) % (AVG_SIZE * 2 + 0));\n+#else\n+    __builtin_memcpy (t+(i*1024*1024+i*1)%(BUFFER_SIZE - AVG_SIZE*2), t+((i+1)*1024*1024*4+i*1)%(BUFFER_SIZE - AVG_SIZE *2), (AVG_SIZE + i) % (AVG_SIZE * 2 + 0));\n+#endif\n+  return 0;\n+}\n+END\n+TIME=`/usr/bin/time -f \"%E\" ./a.out 2>&1`\n+echo -n \" \"$TIME\n+echo $TIME $4 >>/tmp/accum\n+}\n+\n+test2()\n+{\n+rm -f a.out\n+cat <<END | clang -x c -O3 $3 -DAVG_SIZE=$2 $STRINGOP -DMEMORY_COPIES=$memsize 2>/dev/null -\n+#define BUFFER_SIZE (16*1024*1024 + AVG_SIZE*2)\n+/*#define MEMORY_COPIES (1024*1024*64*(long long)10)*/\n+$type t[BUFFER_SIZE];\n+int main()\n+{\n+  unsigned int i;\n+  for (i=0;i<((long long)MEMORY_COPIES + AVG_SIZE * 2 - 1)/AVG_SIZE*2;i++)\n+#ifdef test_memset\n+    __builtin_memset (t+(i*1024*1024+i*1)%(BUFFER_SIZE - AVG_SIZE*2), i, (AVG_SIZE + i) % (AVG_SIZE * 2 + 0));\n+#else\n+    __builtin_memcpy (t+(i*1024*1024+i*1)%(BUFFER_SIZE - AVG_SIZE*2), t+((i+1)*1024*1024*4+i*1)%(BUFFER_SIZE - AVG_SIZE *2), (AVG_SIZE + i) % (AVG_SIZE * 2 + 0));\n+#endif\n+  return 0;\n+}\n+END\n+TIME=`/usr/bin/time -f \"%E\" ./a.out 2>&1`\n+echo -n \" \"$TIME\n+echo $TIME $4 >>/tmp/accum\n+}\n+\n+testrow()\n+{\n+echo -n \"\" >/tmp/accum\n+printf \"%12i \" $3\n+test \"$2\" \"$3\" \"-mstringop-strategy=libcall\" libcall\n+test \"$2\" \"$3\" \"-mstringop-strategy=rep_byte -malign-stringops\" rep1\n+test \"$2\" \"$3\" \"-mstringop-strategy=rep_byte -mno-align-stringops\" rep1noalign\n+test \"$2\" \"$3\" \"-mstringop-strategy=rep_4byte -malign-stringops\" rep4\n+test \"$2\" \"$3\" \"-mstringop-strategy=rep_4byte -mno-align-stringops\" rep4noalign\n+if [ \"$mode\" == 64 ]\n+then\n+test \"$2\" \"$3\" \"-mstringop-strategy=rep_8byte -malign-stringops\" rep8\n+test \"$2\" \"$3\" \"-mstringop-strategy=rep_8byte -mno-align-stringops\" rep8noalign\n+fi\n+test \"$2\" \"$3\" \"-mstringop-strategy=loop -malign-stringops\"  loop\n+test \"$2\" \"$3\" \"-mstringop-strategy=loop -mno-align-stringops\"  loopnoalign\n+test \"$2\" \"$3\" \"-mstringop-strategy=unrolled_loop -malign-stringops\" unrl\n+test \"$2\" \"$3\" \"-mstringop-strategy=unrolled_loop -mno-align-stringops\" unrlnoalign\n+test \"$2\" \"$3\" \"-mstringop-strategy=vector_loop -malign-stringops\" sse\n+test \"$2\" \"$3\" \"-mstringop-strategy=vector_loop -mno-align-stringops -msse2\" ssenoalign\n+#test2 \"$2\" \"$3\" \"\" \n+test \"$2\" \"$3\" \"-mstringop-strategy=byte_loop\" byte\n+best=`cat /tmp/accum | sort | head -1`\n+test \"$2\" \"$3\" \" -fprofile-generate\" >/dev/null 2>&1\n+test \"$2\" \"$3\" \" -fprofile-use\"\n+test \"$2\" \"$3\" \" -minline-stringops-dynamically\"\n+echo \"    $best\"\n+}\n+\n+test_all_sizes()\n+{\n+if [ \"$mode\" == 64 ]\n+then\n+echo \"  block size  libcall rep1    noalg   rep4    noalg   rep8    noalg   loop    noalg   unrl    noalg   sse     noalg   byte    PGO     dynamic    BEST\"\n+else\n+echo \"  block size  libcall rep1    noalg   rep4    noalg   loop    noalg   unrl    noalg   sse     noalg   byte    PGO     dynamic    BEST\"\n+fi\n+#for size in 1 2 3 4 6 8 10 12 14 16 24 32 48 64 128 256 512 1024 4096 8192 81920 819200 8192000\n+#for size in 8192000 819200 81920 8192 4096 2048 1024 512 256 128 64 48 32 24 16 14 12 10 8 6 5 4 3 2 1\n+for size in 8192000 819200 81920 20480 8192 4096 2048 1024 512 256 128 64 48 32 24 16 14 12 10 8 6 4 1\n+#for size in 128 256 1024 4096 8192 81920 819200\n+do\n+testrow \"$1\" \"$2\" $size\n+done\n+}\n+\n+mode=$1\n+shift\n+export memsize=$1\n+shift\n+cmdline=$*\n+if [ \"$mode\" != 32 ]\n+then\n+  if [ \"$mode\" != 64 ]\n+  then\n+    echo \"Usage:\"\n+    echo \"test_stringop mode size cmdline\"\n+    echo \"mode is either 32 or 64\"\n+    echo \"size is amount of memory copied in each test.  Should be chosed small enough so runtime is less than minute for each test and sorting works\"\n+    echo \"Example: test_stringop 32 640000000 ./xgcc -B ./ -march=pentium3\"\n+    exit\n+  fi\n+fi\n+\n+echo \"memcpy\"\n+export STRINGOP=\"\"\n+type=char\n+test_all_sizes $mode \"$cmdline -m$mode\"\n+echo \"Aligned\"\n+type=long\n+test_all_sizes $mode \"$cmdline -m$mode\"\n+echo \"memset\"\n+export STRINGOP=\"-Dtest_memset=1\"\n+type=char\n+test_all_sizes $mode \"$cmdline -m$mode\"\n+echo \"Aligned\"\n+type=long\n+test_all_sizes $mode \"$cmdline -m$mode\""}]}