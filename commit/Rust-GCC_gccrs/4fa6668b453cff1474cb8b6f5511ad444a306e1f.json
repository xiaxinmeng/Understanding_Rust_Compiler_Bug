{"sha": "4fa6668b453cff1474cb8b6f5511ad444a306e1f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGZhNjY2OGI0NTNjZmYxNDc0Y2I4YjZmNTUxMWFkNDQ0YTMwNmUxZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-30T22:30:05Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-03-30T22:30:05Z"}, "message": "(global_symbolic_reference_mentioned_p): New  parameter F.\n\n(print_operand_address): When generating pic baseregisters are only\nallowed if offset is CONST_INT. For {SYMBOL,LABEL}_REF a indexregister\nhas to be used instead. (sb) is no longer emitted for constant\nabsolute addresses.  (output_move_double): Use CONSTANT_P instead of\nCONSTANT_ADDRESS_P.\n\nFrom-SVN: r6925", "tree": {"sha": "3fa4d829594e11845b925efa0162016b01c58179", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3fa4d829594e11845b925efa0162016b01c58179"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4fa6668b453cff1474cb8b6f5511ad444a306e1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fa6668b453cff1474cb8b6f5511ad444a306e1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4fa6668b453cff1474cb8b6f5511ad444a306e1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4fa6668b453cff1474cb8b6f5511ad444a306e1f/comments", "author": null, "committer": null, "parents": [{"sha": "6b0639bc6c077b981c0f6106f3e35b53560af29a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b0639bc6c077b981c0f6106f3e35b53560af29a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b0639bc6c077b981c0f6106f3e35b53560af29a"}], "stats": {"total": 53, "additions": 34, "deletions": 19}, "files": [{"sha": "2012c7f481e8b27f53e48a9d9cd795e25720a828", "filename": "gcc/config/ns32k/ns32k.c", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4fa6668b453cff1474cb8b6f5511ad444a306e1f/gcc%2Fconfig%2Fns32k%2Fns32k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4fa6668b453cff1474cb8b6f5511ad444a306e1f/gcc%2Fconfig%2Fns32k%2Fns32k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fns32k%2Fns32k.c?ref=4fa6668b453cff1474cb8b6f5511ad444a306e1f", "patch": "@@ -260,7 +260,7 @@ output_move_double (operands)\n \n   if (REG_P (operands[1]))\n     optype1 = REGOP;\n-  else if (CONSTANT_ADDRESS_P (operands[1])\n+  else if (CONSTANT_P (operands[1])\n \t   || GET_CODE (operands[1]) == CONST_DOUBLE)\n     optype1 = CNSTOP;\n   else if (offsettable_memref_p (operands[1]))\n@@ -299,7 +299,7 @@ output_move_double (operands)\n     latehalf[1] = adj_offsettable_operand (operands[1], 4);\n   else if (optype1 == CNSTOP)\n     {\n-      if (CONSTANT_ADDRESS_P (operands[1]))\n+      if (CONSTANT_P (operands[1]))\n \tlatehalf[1] = const0_rtx;\n       else if (GET_CODE (operands[1]) == CONST_DOUBLE)\n \tsplit_double (operands[1], &operands[1], &latehalf[1]);\n@@ -400,8 +400,9 @@ check_reg (oper, reg)\n /* Returns 1 if OP contains a global symbol reference */\n \n int\n-global_symbolic_reference_mentioned_p (op)\n+global_symbolic_reference_mentioned_p (op, f)\n      rtx op;\n+     int f;\n {\n   register char *fmt;\n   register int i;\n@@ -411,9 +412,9 @@ global_symbolic_reference_mentioned_p (op)\n       if (! SYMBOL_REF_FLAG (op))\n \treturn 1;\n       else\n-return 0;\n+        return 0;\n     }\n-  else if (GET_CODE (op) != CONST)\n+  else if (f && GET_CODE (op) != CONST)\n     return 0;\n \n   fmt = GET_RTX_FORMAT (GET_CODE (op));\n@@ -424,11 +425,11 @@ return 0;\n \t  register int j;\n \n \t  for (j = XVECLEN (op, i) - 1; j >= 0; j--)\n-\t    if (global_symbolic_reference_mentioned_p (XVECEXP (op, i, j)))\n+\t    if (global_symbolic_reference_mentioned_p (XVECEXP (op, i, j), 0))\n \t      return 1;\n \t}\n       else if (fmt[i] == 'e' \n-\t       && global_symbolic_reference_mentioned_p (XEXP (op, i)))\n+\t       && global_symbolic_reference_mentioned_p (XEXP (op, i), 0))\n \treturn 1;\n     }\n \n@@ -672,15 +673,20 @@ print_operand_address (file, addr)\n   if (! offset)\n     offset = const0_rtx;\n \n-#ifdef INDEX_RATHER_THAN_BASE\n+  if (base\n+#ifndef INDEX_RATHER_THAN_BASE\n+      && flag_pic \n+      && GET_CODE (base) != SYMBOL_REF \n+      && GET_CODE (offset) != CONST_INT\n+#else\n   /* This is a re-implementation of the SEQUENT_ADDRESS_BUG fix.  */\n-  if (base && !indexexp && GET_CODE (base) == REG\n+#endif\n+      && !indexexp && GET_CODE (base) == REG\n       && REG_OK_FOR_INDEX_P (base))\n     {\n       indexexp = base;\n-      base = 0;\n+      base = NULL;\n     }\n-#endif\n \n   /* now, offset, base and indexexp are set */\n   if (! base)\n@@ -766,21 +772,30 @@ print_operand_address (file, addr)\n \tif (base)\n \t  fprintf (file, \"(%s)\", reg_names[REGNO (base)]);\n #ifdef BASE_REG_NEEDED\n-\telse if (TARGET_SB)\n-\t  fprintf (file, \"(sb)\");\n-\telse\n-\t  abort ();\n+  else \n+    {\n+      /* Abs. addresses don't need a base (I think). */\n+      if (GET_CODE (offset) != CONST_INT\n+#ifndef PC_RELATIVE\n+           && GET_CODE (offset) != LABEL_REF\n+\t   && GET_CODE (offset) != SYMBOL_REF\n+\t   && GET_CODE (offset) != CONST\n+#endif\n+         )\n+        {\n+\t  if (TARGET_SB)\n+\t    fprintf (file, \"(sb)\");\n+\t  else\n+\t    abort ();\n+        }\n+    }\n #endif\n \tfprintf (file, \")\");\n \tbreak;\n \n       default:\n \tabort ();\n       }\n-#if 0\n-  else if (flag_pic && SYMBOL_REF_FLAG (offset))\n-    fprintf (file, \"(sb)\");\n-#endif\n #ifdef PC_RELATIVE\n   else if (GET_CODE (offset) == LABEL_REF\n \t   || GET_CODE (offset) == SYMBOL_REF"}]}