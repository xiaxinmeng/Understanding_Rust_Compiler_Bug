{"sha": "459b3825489c0f1826af597c800a6b57a5bf2394", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU5YjM4MjU0ODljMGYxODI2YWY1OTdjODAwYTZiNTdhNWJmMjM5NA==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1998-04-30T16:25:19Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1998-04-30T16:25:19Z"}, "message": "Prevent buffer overrun in debug output; Make alloc_{INSN,EXPR}_LIST static\n\nFrom-SVN: r19503", "tree": {"sha": "01ca0438400660a74ca0002d6369ddb6794e41cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/01ca0438400660a74ca0002d6369ddb6794e41cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/459b3825489c0f1826af597c800a6b57a5bf2394", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/459b3825489c0f1826af597c800a6b57a5bf2394", "html_url": "https://github.com/Rust-GCC/gccrs/commit/459b3825489c0f1826af597c800a6b57a5bf2394", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/459b3825489c0f1826af597c800a6b57a5bf2394/comments", "author": null, "committer": null, "parents": [{"sha": "61fbdb55bdf16f021d24f6b8130abe3f14d34dd9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61fbdb55bdf16f021d24f6b8130abe3f14d34dd9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61fbdb55bdf16f021d24f6b8130abe3f14d34dd9"}], "stats": {"total": 514, "additions": 288, "deletions": 226}, "files": [{"sha": "b00603c4867ed2918d4204a314b240715e3ab4d7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/459b3825489c0f1826af597c800a6b57a5bf2394/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/459b3825489c0f1826af597c800a6b57a5bf2394/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=459b3825489c0f1826af597c800a6b57a5bf2394", "patch": "@@ -1,3 +1,15 @@\n+Thu Apr 30 16:57:34 1998  Michael Meissner  <meissner@cygnus.com>\n+\n+\t* haifa-sched.c (print_{exp,value}): Various changes to make the\n+\tdebug output easier to read.  Also, use only one buffer, and make\n+\tsure the buffer we are passed in doesn't overflow.\n+\t(safe_concat): Concatenate to a buffer without overflow.\n+\n+Thu Apr 30 16:57:34 1998  Kaveh R. Ghazi\" <ghazi@caip.rutgers.edu>\n+\n+\t* haifa-sched.c (alloc_{INSN,EXPR}_LIST): Make static to agree\n+\twith the prototype.\n+\t\n Wed Apr 29 21:45:16 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n \t* sched.c (new_insn_dead_notes): Check if the register was"}, {"sha": "c1d199725b1998b9fc577eac040f9153d4aebe88", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 276, "deletions": 226, "changes": 502, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/459b3825489c0f1826af597c800a6b57a5bf2394/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/459b3825489c0f1826af597c800a6b57a5bf2394/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=459b3825489c0f1826af597c800a6b57a5bf2394", "patch": "@@ -473,6 +473,7 @@ static void split_hard_reg_notes PROTO ((rtx, rtx, rtx));\n static void new_insn_dead_notes PROTO ((rtx, rtx, rtx, rtx));\n static void update_n_sets PROTO ((rtx, int));\n static void update_flow_info PROTO ((rtx, rtx, rtx, rtx));\n+static char *safe_concat PROTO ((char *, char *, char *));\n \n /* Main entry point of this file.  */\n void schedule_insns PROTO ((FILE *));\n@@ -825,7 +826,7 @@ free_list (listp, unused_listp)\n   *listp = 0;\n }\n \n-rtx\n+static rtx\n alloc_INSN_LIST (val, next)\n      rtx val, next;\n {\n@@ -845,7 +846,7 @@ alloc_INSN_LIST (val, next)\n   return r;\n }\n \n-rtx\n+static rtx\n alloc_EXPR_LIST (kind, val, next)\n      int kind;\n      rtx val, next;\n@@ -5564,6 +5565,28 @@ init_block_visualization ()\n \n #define BUF_LEN 256\n \n+static char *\n+safe_concat (buf, cur, str)\n+     char *buf;\n+     char *cur;\n+     char *str;\n+{\n+  char *end = buf + BUF_LEN - 2;\t/* leave room for null */\n+  int c;\n+\n+  if (cur > end)\n+    {\n+      *end = '\\0';\n+      return end;\n+    }\n+\n+  while (cur < end && (c = *str++) != '\\0')\n+    *cur++ = c;\n+\n+  *cur = '\\0';\n+  return cur;\n+}\n+\n /* This recognizes rtx, I classified as expressions. These are always */\n /* represent some action on values or results of other expression, */\n /* that may be stored in objects representing values.  */\n@@ -5574,332 +5597,335 @@ print_exp (buf, x, verbose)\n      rtx x;\n      int verbose;\n {\n-  char t1[BUF_LEN], t2[BUF_LEN], t3[BUF_LEN];\n+  char tmp[BUF_LEN];\n+  char *st[4];\n+  char *cur = buf;\n+  char *fun = (char *)0;\n+  char *sep;\n+  rtx op[4];\n+  int i;\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      st[i] = (char *)0;\n+      op[i] = NULL_RTX;\n+    }\n \n   switch (GET_CODE (x))\n     {\n     case PLUS:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s+%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"+\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case LO_SUM:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%sl+%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"+low(\";\n+      op[1] = XEXP (x, 1);\n+      st[2] = \")\";\n       break;\n     case MINUS:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s-%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"-\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case COMPARE:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s??%s\", t1, t2);\n+      fun = \"cmp\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n       break;\n     case NEG:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"-%s\", t1);\n+      st[0] = \"-\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case MULT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s*%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"*\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case DIV:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s/%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"/\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case UDIV:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%su/%s\", t1, t2);\n+      fun = \"udiv\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n       break;\n     case MOD:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s%%%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"%\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case UMOD:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%su%%%s\", t1, t2);\n+      fun = \"umod\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n       break;\n     case SMIN:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"smin (%s, %s)\", t1, t2);\n+      fun = \"smin\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n       break;\n     case SMAX:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"smax(%s,%s)\", t1, t2);\n+      fun = \"smax\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n       break;\n     case UMIN:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"umin (%s, %s)\", t1, t2);\n+      fun = \"umin\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n       break;\n     case UMAX:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"umax(%s,%s)\", t1, t2);\n+      fun = \"umax\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n       break;\n     case NOT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"!%s\", t1);\n+      st[0] = \"!\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case AND:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s&%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"&\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case IOR:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s|%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"|\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case XOR:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s^%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"^\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case ASHIFT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s<<%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<<\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case LSHIFTRT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s0>%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \" 0>>\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case ASHIFTRT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s>>%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">>\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case ROTATE:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s<-<%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<-<\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case ROTATERT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s>->%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">->\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case ABS:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"abs(%s)\", t1);\n+      fun = \"abs\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case SQRT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"sqrt(%s)\", t1);\n+      fun = \"sqrt\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case FFS:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"ffs(%s)\", t1);\n+      fun = \"ffs\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case EQ:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s == %s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"==\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case NE:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s!=%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"!=\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case GT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s>%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case GTU:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s>u%s\", t1, t2);\n+      fun = \"gtu\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n       break;\n     case LT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s<%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case LTU:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s<u%s\", t1, t2);\n+      fun = \"ltu\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n       break;\n     case GE:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s>=%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \">=\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case GEU:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s>=u%s\", t1, t2);\n+      fun = \"geu\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n       break;\n     case LE:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s<=%s\", t1, t2);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"<=\";\n+      op[1] = XEXP (x, 1);\n       break;\n     case LEU:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      sprintf (buf, \"%s<=u%s\", t1, t2);\n+      fun = \"leu\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n       break;\n     case SIGN_EXTRACT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      print_value (t3, XEXP (x, 2), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"sign_extract(%s,%s,%s)\", t1, t2, t3);\n-      else\n-\tsprintf (buf, \"sxt(%s,%s,%s)\", t1, t2, t3);\n+      fun = (verbose) ? \"sign_extract\" : \"sxt\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      op[2] = XEXP (x, 2);\n       break;\n     case ZERO_EXTRACT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      print_value (t3, XEXP (x, 2), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"zero_extract(%s,%s,%s)\", t1, t2, t3);\n-      else\n-\tsprintf (buf, \"zxt(%s,%s,%s)\", t1, t2, t3);\n+      fun = (verbose) ? \"zero_extract\" : \"zxt\";\n+      op[0] = XEXP (x, 0);\n+      op[1] = XEXP (x, 1);\n+      op[2] = XEXP (x, 2);\n       break;\n     case SIGN_EXTEND:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"sign_extend(%s)\", t1);\n-      else\n-\tsprintf (buf, \"sxn(%s)\", t1);\n+      fun = (verbose) ? \"sign_extend\" : \"sxn\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case ZERO_EXTEND:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"zero_extend(%s)\", t1);\n-      else\n-\tsprintf (buf, \"zxn(%s)\", t1);\n+      fun = (verbose) ? \"zero_extend\" : \"zxn\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case FLOAT_EXTEND:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"float_extend(%s)\", t1);\n-      else\n-\tsprintf (buf, \"fxn(%s)\", t1);\n+      fun = (verbose) ? \"float_extend\" : \"fxn\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case TRUNCATE:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"trunc(%s)\", t1);\n-      else\n-\tsprintf (buf, \"trn(%s)\", t1);\n+      fun = (verbose) ? \"trunc\" : \"trn\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case FLOAT_TRUNCATE:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"float_trunc(%s)\", t1);\n-      else\n-\tsprintf (buf, \"ftr(%s)\", t1);\n+      fun = (verbose) ? \"float_trunc\" : \"ftr\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case FLOAT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"float(%s)\", t1);\n-      else\n-\tsprintf (buf, \"flt(%s)\", t1);\n+      fun = (verbose) ? \"float\" : \"flt\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case UNSIGNED_FLOAT:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"uns_float(%s)\", t1);\n-      else\n-\tsprintf (buf, \"ufl(%s)\", t1);\n+      fun = (verbose) ? \"uns_float\" : \"ufl\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case FIX:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"fix(%s)\", t1);\n+      fun = \"fix\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case UNSIGNED_FIX:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      if (verbose)\n-\tsprintf (buf, \"uns_fix(%s)\", t1);\n-      else\n-\tsprintf (buf, \"ufx(%s)\", t1);\n+      fun = (verbose) ? \"uns_fix\" : \"ufx\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case PRE_DEC:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"--%s\", t1);\n+      st[0] = \"--\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case PRE_INC:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"++%s\", t1);\n+      st[0] = \"++\";\n+      op[0] = XEXP (x, 0);\n       break;\n     case POST_DEC:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"%s--\", t1);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"--\";\n       break;\n     case POST_INC:\n-      print_value (t1, XEXP (x, 0), verbose);\n-      sprintf (buf, \"%s++\", t1);\n+      op[0] = XEXP (x, 0);\n+      st[1] = \"++\";\n       break;\n     case CALL:\n-      print_value (t1, XEXP (x, 0), verbose);\n+      st[0] = \"call \";\n+      op[0] = XEXP (x, 0);\n       if (verbose)\n \t{\n-\t  print_value (t2, XEXP (x, 1), verbose);\n-\t  sprintf (buf, \"call %s argc:%s\", t1, t2);\n+\t  st[1] = \" argc:\";\n+\t  op[1] = XEXP (x, 1);\n \t}\n-      else\n-\tsprintf (buf, \"call %s\", t1);\n       break;\n     case IF_THEN_ELSE:\n-      print_exp (t1, XEXP (x, 0), verbose);\n-      print_value (t2, XEXP (x, 1), verbose);\n-      print_value (t3, XEXP (x, 2), verbose);\n-      sprintf (buf, \"{(%s)?%s:%s}\", t1, t2, t3);\n+      st[0] = \"{(\";\n+      op[0] = XEXP (x, 0);\n+      st[1] = \")?\";\n+      op[1] = XEXP (x, 1);\n+      st[2] = \":\";\n+      op[2] = XEXP (x, 2);\n+      st[3] = \"}\";\n       break;\n     case TRAP_IF:\n-      print_value (t1, TRAP_CONDITION (x), verbose);\n-      sprintf (buf, \"trap_if %s\", t1);\n+      fun = \"trap_if\";\n+      op[0] = TRAP_CONDITION (x);\n       break;\n     case UNSPEC:\n-      {\n-\tint i;\n-\n-\tsprintf (t1, \"unspec{\");\n-\tfor (i = 0; i < XVECLEN (x, 0); i++)\n-\t  {\n-\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n-\t    sprintf (t3, \"%s%s;\", t1, t2);\n-\t    strcpy (t1, t3);\n-\t  }\n-\tsprintf (buf, \"%s}\", t1);\n-      }\n-      break;\n     case UNSPEC_VOLATILE:\n       {\n-\tint i;\n-\n-\tsprintf (t1, \"unspec/v{\");\n+\tcur = safe_concat (buf, cur, \"unspec\");\n+\tif (GET_CODE (x) == UNSPEC_VOLATILE)\n+\t  cur = safe_concat (buf, cur, \"/v\");\n+\tcur = safe_concat (buf, cur, \"[\");\n+\tsep = \"\";\n \tfor (i = 0; i < XVECLEN (x, 0); i++)\n \t  {\n-\t    print_pattern (t2, XVECEXP (x, 0, i), verbose);\n-\t    sprintf (t3, \"%s%s;\", t1, t2);\n-\t    strcpy (t1, t3);\n+\t    print_pattern (tmp, XVECEXP (x, 0, i), verbose);\n+\t    cur = safe_concat (buf, cur, sep);\n+\t    cur = safe_concat (buf, cur, tmp);\n+\t    sep = \",\";\n \t  }\n-\tsprintf (buf, \"%s}\", t1);\n+\tcur = safe_concat (buf, cur, \"] \");\n+\tsprintf (tmp, \"%d\", XINT (x, 1));\n+\tcur = safe_concat (buf, cur, tmp);\n       }\n       break;\n     default:\n-/*    if (verbose) debug_rtx (x); else sprintf (buf, \"$$$\"); */\n-      sprintf (buf, \"$$$\");\n+/*    if (verbose) debug_rtx (x); */\n+      st[0] = GET_RTX_NAME (x);\n+      break;\n+    }\n+\n+  /* Print this as a function? */\n+  if (fun)\n+    {\n+      cur = safe_concat (buf, cur, fun);\n+      cur = safe_concat (buf, cur, \"(\");\n+    }\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      if (st[i])\n+\tcur = safe_concat (buf, cur, st[i]);\n+\n+      if (op[i])\n+\t{\n+\t  if (fun && i != 0)\n+\t    cur = safe_concat (buf, cur, \",\");\n+\n+\t  print_value (tmp, op[i], verbose);\n+\t  cur = safe_concat (buf, cur, tmp);\n+\t}\n     }\n-}\t\t\t\t/* print_exp */\n+\n+  if (fun)\n+    cur = safe_concat (buf, cur, \")\");\n+}\t\t/* print_exp */\n \n /* Prints rtxes, i customly classified as values. They're constants, */\n /* registers, labels, symbols and memory accesses.  */\n@@ -5911,60 +5937,84 @@ print_value (buf, x, verbose)\n      int verbose;\n {\n   char t[BUF_LEN];\n+  char *cur = buf;\n \n   switch (GET_CODE (x))\n     {\n     case CONST_INT:\n-      sprintf (buf, \"%Xh\", INTVAL (x));\n+      sprintf (t, \"0x%lx\", (long)INTVAL (x));\n+      cur = safe_concat (buf, cur, t);\n       break;\n     case CONST_DOUBLE:\n-      print_value (t, XEXP (x, 0), verbose);\n-      sprintf (buf, \"<%s>\", t);\n+      sprintf (t, \"<0x%lx,0x%lx>\", (long)XWINT (x, 2), (long)XWINT (x, 3));\n+      cur = safe_concat (buf, cur, t);\n       break;\n     case CONST_STRING:\n-      sprintf (buf, \"\\\"%s\\\"\", (char *) XEXP (x, 0));\n+      cur = safe_concat (buf, cur, \"\\\"\");\n+      cur = safe_concat (buf, cur, XSTR (x, 0));\n+      cur = safe_concat (buf, cur, \"\\\"\");\n       break;\n     case SYMBOL_REF:\n-      sprintf (buf, \"`%s'\", (char *) XEXP (x, 0));\n+      cur = safe_concat (buf, cur, \"`\");\n+      cur = safe_concat (buf, cur, XSTR (x, 0));\n+      cur = safe_concat (buf, cur, \"'\");\n       break;\n     case LABEL_REF:\n-      sprintf (buf, \"L%d\", INSN_UID (XEXP (x, 0)));\n+      sprintf (t, \"L%d\", INSN_UID (XEXP (x, 0)));\n+      cur = safe_concat (buf, cur, t);\n       break;\n     case CONST:\n-      print_value (buf, XEXP (x, 0), verbose);\n+      print_value (t, XEXP (x, 0), verbose);\n+      cur = safe_concat (buf, cur, \"const(\");\n+      cur = safe_concat (buf, cur, t);\n+      cur = safe_concat (buf, cur, \")\");\n       break;\n     case HIGH:\n-      print_value (buf, XEXP (x, 0), verbose);\n+      print_value (t, XEXP (x, 0), verbose);\n+      cur = safe_concat (buf, cur, \"high(\");\n+      cur = safe_concat (buf, cur, t);\n+      cur = safe_concat (buf, cur, \")\");\n       break;\n     case REG:\n-      if (GET_MODE (x) == SFmode\n-\t  || GET_MODE (x) == DFmode\n-\t  || GET_MODE (x) == XFmode\n-\t  || GET_MODE (x) == TFmode)\n-\tstrcpy (t, \"fr\");\n+      if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  int c = reg_names[ REGNO (x) ][0];\n+\t  if (c >= '0' && c <= '9')\n+\t    cur = safe_concat (buf, cur, \"%\");\n+\n+\t  cur = safe_concat (buf, cur, reg_names[ REGNO (x) ]);\n+\t}\n       else\n-\tstrcpy (t, \"r\");\n-      sprintf (buf, \"%s%d\", t, REGNO (x));\n+\t{\n+\t  sprintf (t, \"r%d\", REGNO (x));\n+\t  cur = safe_concat (buf, cur, t);\n+\t}\n       break;\n     case SUBREG:\n-      print_value (t, XEXP (x, 0), verbose);\n-      sprintf (buf, \"%s#%d\", t, SUBREG_WORD (x));\n+      print_value (t, SUBREG_REG (x), verbose);\n+      cur = safe_concat (buf, cur, t);\n+      sprintf (t, \"#%d\", t, SUBREG_WORD (x));\n+      cur = safe_concat (buf, cur, t);\n       break;\n     case SCRATCH:\n-      sprintf (buf, \"scratch\");\n+      cur = safe_concat (buf, cur, \"scratch\");\n       break;\n     case CC0:\n-      sprintf (buf, \"cc0\");\n+      cur = safe_concat (buf, cur, \"cc0\");\n       break;\n     case PC:\n-      sprintf (buf, \"pc\");\n+      cur = safe_concat (buf, cur, \"pc\");\n       break;\n     case MEM:\n       print_value (t, XEXP (x, 0), verbose);\n-      sprintf (buf, \"[%s]\", t);\n+      cur = safe_concat (buf, cur, \"[\");\n+      cur = safe_concat (buf, cur, t);\n+      cur = safe_concat (buf, cur, \"]\");\n       break;\n     default:\n-      print_exp (buf, x, verbose);\n+      print_exp (t, x, verbose);\n+      cur = safe_concat (buf, cur, t);\n+      break;\n     }\n }\t\t\t\t/* print_value */\n "}]}