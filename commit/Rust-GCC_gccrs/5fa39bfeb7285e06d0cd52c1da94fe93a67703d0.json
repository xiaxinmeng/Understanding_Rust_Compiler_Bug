{"sha": "5fa39bfeb7285e06d0cd52c1da94fe93a67703d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWZhMzliZmViNzI4NWUwNmQwY2Q1MmMxZGE5NGZlOTNhNjc3MDNkMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-11T19:31:10Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-08-11T19:31:10Z"}, "message": "* Integrate reload bugfix from Wilson which enables the PA port\n        to bootstrap again.\n        * reload1.c (reload): Sum needs for both OPADDR_ADDR and and\n        OPERAND_ADDRESS when computing how many registers an insn needs.\n        (reload_reg_free_p): OPADDR_ADDR and OPERAND_ADDRESS reloads do\n        conflict.\n        (reload_reg_free_before_p): Treat OPERAND_ADDRESS reloads just like\n        OPADDR_ADDR reload.\n        (reload_reg_reaches_end_p): For RELOAD_FOR_OPADDR_ADDR insns, registers\n        in reload_reg_use_in_op_addr do not reach the end.\n        do not reach the end.\n        (reloads_conflict): RELOAD_FOR_OPADDR_ADDR conflicts with\n        RELOAD_FOR_OPERAND_ADDRESS.\n\n\n\nStart a new ChangeLog for gcc3.\n\nFrom-SVN: r14767", "tree": {"sha": "9a73a8a74c825a512172d5eb5297e78ed4da80fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a73a8a74c825a512172d5eb5297e78ed4da80fa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0/comments", "author": null, "committer": null, "parents": [{"sha": "861bb6c1b0958236ad93717f98d347aa6152bd09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/861bb6c1b0958236ad93717f98d347aa6152bd09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/861bb6c1b0958236ad93717f98d347aa6152bd09"}], "stats": {"total": 21354, "additions": 10688, "deletions": 10666}, "files": [{"sha": "b23e805000211c6e0f16676512b8b19ca7cfaf5e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 10651, "changes": 10670, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5fa39bfeb7285e06d0cd52c1da94fe93a67703d0"}, {"sha": "29483ba26183aaa97276c481174bbb42d2a628a9", "filename": "gcc/ChangeLog.11", "status": "added", "additions": 10652, "deletions": 0, "changes": 10652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0/gcc%2FChangeLog.11", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0/gcc%2FChangeLog.11", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.11?ref=5fa39bfeb7285e06d0cd52c1da94fe93a67703d0"}, {"sha": "8067787478322be0b2d6148120418546ec553cf1", "filename": "gcc/reload1.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5fa39bfeb7285e06d0cd52c1da94fe93a67703d0/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=5fa39bfeb7285e06d0cd52c1da94fe93a67703d0", "patch": "@@ -1341,8 +1341,8 @@ reload (first, global, dumpfile)\n \t\t\t don't conflict with things needed to reload inputs or\n \t\t\t outputs.  */\n \n-\t\t      in_max = MAX (MAX (insn_needs.op_addr.regs[j][i],\n-\t\t\t\t\t insn_needs.op_addr_reload.regs[j][i]),\n+\t\t      in_max = MAX ((insn_needs.op_addr.regs[j][i]\n+\t\t\t\t     + insn_needs.op_addr_reload.regs[j][i]),\n \t\t\t\t    in_max);\n \n \t\t      out_max = MAX (out_max, insn_needs.insn.regs[j][i]);\n@@ -1374,8 +1374,8 @@ reload (first, global, dumpfile)\n \t\t\t= MAX (out_max, insn_needs.out_addr_addr[j].groups[i]);\n \t\t    }\n \n-\t\t  in_max = MAX (MAX (insn_needs.op_addr.groups[i],\n-\t\t\t\t     insn_needs.op_addr_reload.groups[i]),\n+\t\t  in_max = MAX ((insn_needs.op_addr.groups[i]\n+\t\t\t\t + insn_needs.op_addr_reload.groups[i]),\n \t\t\t\tin_max);\n \t\t  out_max = MAX (out_max, insn_needs.insn.groups[i]);\n \n@@ -4605,15 +4605,22 @@ reload_reg_free_p (regno, opnum, type)\n \tif (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n \t  return 0;\n \n+      /* ??? A OPADDR_ADDR reload does not conflict with the OPERAND_ADDRESS\n+\t reload that uses it.  However, the same operand can have multiple\n+\t OPERAND_ADDRESS reloads, and a OPADDR_ADDR reload does conflict with\n+\t other OPERAND_ADDRESS reloads for the same operand, hence we must\n+\t say that OPADDR_ADDR and OPERAND_ADDRESS reloads always conflict.  */\n       return (! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno)\n+\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno)\n \t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno));\n \n     case RELOAD_FOR_OPADDR_ADDR:\n       for (i = 0; i < reload_n_operands; i++)\n         if (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n           return 0;\n \n-      return (!TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno));\n+      return (! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno)\n+\t      && ! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno));\n \n     case RELOAD_FOR_OUTPUT:\n       /* This cannot share a register with RELOAD_FOR_INSN reloads, other\n@@ -4730,12 +4737,6 @@ reload_reg_free_before_p (regno, opnum, type)\n       return ! TEST_HARD_REG_BIT (reload_reg_used_in_other_addr, regno);\n \n     case RELOAD_FOR_OPERAND_ADDRESS:\n-      /* Earlier reloads include RELOAD_FOR_OPADDR_ADDR reloads.  */\n-      if (TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno))\n-\treturn 0;\n-\n-      /* ... fall through ...  */\n-\n     case RELOAD_FOR_OPADDR_ADDR:\n     case RELOAD_FOR_INSN:\n       /* These can't conflict with inputs, or each other, so all we have to\n@@ -4879,8 +4880,7 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \t    || TEST_HARD_REG_BIT (reload_reg_used_in_output[i], regno))\n \t  return 0;\n \n-      return (! TEST_HARD_REG_BIT (reload_reg_used_in_op_addr, regno)\n-\t      && !TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno));\n+      return (! TEST_HARD_REG_BIT (reload_reg_used_in_insn, regno));\n \n     case RELOAD_FOR_INSN:\n       /* These conflict with other outputs with RELOAD_OTHER.  So\n@@ -4955,11 +4955,13 @@ reloads_conflict (r1, r2)\n \n     case RELOAD_FOR_OPERAND_ADDRESS:\n       return (r2_type == RELOAD_FOR_INPUT || r2_type == RELOAD_FOR_INSN\n-\t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS);\n+\t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS\n+\t      || r2_type == RELOAD_FOR_OPADDR_ADDR);\n \n     case RELOAD_FOR_OPADDR_ADDR:\n       return (r2_type == RELOAD_FOR_INPUT \n-\t      || r2_type == RELOAD_FOR_OPADDR_ADDR);\n+\t      || r2_type == RELOAD_FOR_OPADDR_ADDR\n+\t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS);\n \n     case RELOAD_FOR_OUTPUT:\n       return (r2_type == RELOAD_FOR_INSN || r2_type == RELOAD_FOR_OUTPUT"}]}