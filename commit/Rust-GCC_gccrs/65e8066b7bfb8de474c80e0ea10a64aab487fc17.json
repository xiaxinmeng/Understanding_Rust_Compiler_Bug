{"sha": "65e8066b7bfb8de474c80e0ea10a64aab487fc17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVlODA2NmI3YmZiOGRlNDc0YzgwZTBlYTEwYTY0YWFiNDg3ZmMxNw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-08-15T21:26:35Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-08-15T21:26:35Z"}, "message": "Make-lang.in (JAVA_OBJS): Removed verify.o\n\n\t* Make-lang.in (JAVA_OBJS): Removed verify.o\n\t(java/verify.o): Removed.\n\t* verify.c: Removed.\n\t* lang.c (flag_new_verifier): Removed.\n\t(java_post_options): Updated.\n\t* java-tree.h (flag_new_verifier): Removed.\n\t(verify_jvm_instructions): Removed.\n\t* expr.c (pop_type_0): Assume flag_new_verifier is true.\n\t(build_java_check_indexed_type): Likewise.\n\t(expand_java_arraystore): Likewise.\n\t(expand_java_arrayload): Likewise.\n\t(pop_arguments): Likewise.\n\t(expand_byte_code): Likewise.\n\t(process_jvm_instruction): Likewise.\n\nFrom-SVN: r103126", "tree": {"sha": "a7dfaf22b9ba9062caa3d6e1bf37d287b59035c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7dfaf22b9ba9062caa3d6e1bf37d287b59035c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65e8066b7bfb8de474c80e0ea10a64aab487fc17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e8066b7bfb8de474c80e0ea10a64aab487fc17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65e8066b7bfb8de474c80e0ea10a64aab487fc17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e8066b7bfb8de474c80e0ea10a64aab487fc17/comments", "author": null, "committer": null, "parents": [{"sha": "30f86ec3fba12cb0574db51d75d3355f7264aa77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30f86ec3fba12cb0574db51d75d3355f7264aa77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30f86ec3fba12cb0574db51d75d3355f7264aa77"}], "stats": {"total": 1735, "additions": 53, "deletions": 1682}, "files": [{"sha": "dea76f53a170bef7b5483468f92d13db994f2e8f", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e8066b7bfb8de474c80e0ea10a64aab487fc17/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e8066b7bfb8de474c80e0ea10a64aab487fc17/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=65e8066b7bfb8de474c80e0ea10a64aab487fc17", "patch": "@@ -1,3 +1,20 @@\n+2005-08-15  Tom Tromey  <tromey@redhat.com>\n+\n+\t* Make-lang.in (JAVA_OBJS): Removed verify.o\n+\t(java/verify.o): Removed.\n+\t* verify.c: Removed.\n+\t* lang.c (flag_new_verifier): Removed.\n+\t(java_post_options): Updated.\n+\t* java-tree.h (flag_new_verifier): Removed.\n+\t(verify_jvm_instructions): Removed.\n+\t* expr.c (pop_type_0): Assume flag_new_verifier is true.\n+\t(build_java_check_indexed_type): Likewise.\n+\t(expand_java_arraystore): Likewise.\n+\t(expand_java_arrayload): Likewise.\n+\t(pop_arguments): Likewise.\n+\t(expand_byte_code): Likewise.\n+\t(process_jvm_instruction): Likewise.\n+\n 2005-08-10  Andrew Haley  <aph@redhat.com>\n \n \t* java-gimplify.c (java_gimplify_modify_expr): Fix any pointer"}, {"sha": "458d65b80ebbed0e622ad3e8b1ed4dfd365ac45a", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e8066b7bfb8de474c80e0ea10a64aab487fc17/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e8066b7bfb8de474c80e0ea10a64aab487fc17/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=65e8066b7bfb8de474c80e0ea10a64aab487fc17", "patch": "@@ -102,7 +102,7 @@ gt-java-builtins.h gtype-java.h gt-java-resource.h : s-gtype ; @true\n \n # Executables built by this Makefile:\n JAVA_OBJS = java/parse.o java/class.o java/decl.o java/expr.o \\\n-  java/constants.o java/lang.o java/typeck.o java/except.o java/verify.o \\\n+  java/constants.o java/lang.o java/typeck.o java/except.o \\\n   java/verify-glue.o java/verify-impl.o \\\n   java/zextract.o java/jcf-io.o java/win32-host.o java/jcf-parse.o java/mangle.o \\\n   java/mangle_name.o java/builtins.o java/resource.o \\\n@@ -349,9 +349,6 @@ java/resource.o: java/resource.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n java/typeck.o: java/typeck.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h \\\n   java/convert.h toplev.h $(SYSTEM_H) coretypes.h $(TM_H) $(GGC_H) real.h\n java/win32-host.o: java/win32-host.c $(CONFIG_H) $(SYSTEM_H) coretypes.h java/jcf.h\n-java/verify.o: java/verify.c $(CONFIG_H) $(JAVA_TREE_H) java/jcf.h \\\n-  java/javaop.h java/java-opcodes.h java/java-except.h toplev.h $(SYSTEM_H) \\\n-  coretypes.h $(TM_H)\n java/verify-glue.o: java/verify-glue.c $(CONFIG_H) $(SYSTEM_H) $(JAVA_TREE_H) \\\n   coretypes.h $(TM_H) java/verify.h toplev.h\n java/verify-impl.o: java/verify-impl.c $(CONFIG_H) java/verify.h $(SYSTEM_H) \\"}, {"sha": "c5e48a8406d96179824c8682bbb33418112307fe", "filename": "gcc/java/expr.c", "status": "modified", "additions": 35, "deletions": 91, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e8066b7bfb8de474c80e0ea10a64aab487fc17/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e8066b7bfb8de474c80e0ea10a64aab487fc17/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=65e8066b7bfb8de474c80e0ea10a64aab487fc17", "patch": "@@ -350,29 +350,12 @@ pop_type_0 (tree type, char **messagep)\n     return t;\n   if (TREE_CODE (type) == POINTER_TYPE && TREE_CODE (t) == POINTER_TYPE)\n     {\n-      if (flag_new_verifier)\n-\t{\n-\t  /* Since the verifier has already run, we know that any\n-\t     types we see will be compatible.  In BC mode, this fact\n-\t     may be checked at runtime, but if that is so then we can\n-\t     assume its truth here as well.  So, we always succeed\n-\t     here, with the expected type.  */\n-\t  return type;\n-\t}\n-      else\n-\t{\n-\t  if (type == ptr_type_node || type == object_ptr_type_node)\n-\t    return t;\n-\t  else if (t == ptr_type_node)  /* Special case for null reference. */\n-\t    return type;\n-\t  /* This is a kludge, but matches what Sun's verifier does.\n-\t     It can be tricked, but is safe as long as type errors\n-\t     (i.e. interface method calls) are caught at run-time. */\n-\t  else if (CLASS_INTERFACE (TYPE_NAME (TREE_TYPE (type))))\n-\t    return object_ptr_type_node;\n-\t  else if (can_widen_reference_to (t, type))\n-\t    return t;\n-\t}\n+      /* Since the verifier has already run, we know that any\n+\t types we see will be compatible.  In BC mode, this fact\n+\t may be checked at runtime, but if that is so then we can\n+\t assume its truth here as well.  So, we always succeed\n+\t here, with the expected type.  */\n+      return type;\n     }\n \n   if (! flag_verify_invocations && flag_indirect_dispatch\n@@ -1022,33 +1005,14 @@ build_java_arraystore_check (tree array, tree object)\n    return unchanged.  */\n \n static tree\n-build_java_check_indexed_type (tree array_node, tree indexed_type)\n+build_java_check_indexed_type (tree array_node ATTRIBUTE_UNUSED,\n+\t\t\t       tree indexed_type)\n {\n-  tree elt_type;\n-\n   /* We used to check to see if ARRAY_NODE really had array type.\n      However, with the new verifier, this is not necessary, as we know\n      that the object will be an array of the appropriate type.  */\n \n-  if (flag_new_verifier)\n-    return indexed_type;\n-\n-  if (!is_array_type_p (TREE_TYPE (array_node)))\n-    abort ();\n-\n-  elt_type = (TYPE_ARRAY_ELEMENT (TREE_TYPE (TREE_TYPE (array_node))));\n-\n-  if (indexed_type == ptr_type_node)\n-    return promote_type (elt_type);\n-\n-  /* BYTE/BOOLEAN store and load are used for both type */\n-  if (indexed_type == byte_type_node && elt_type == boolean_type_node)\n-    return boolean_type_node;\n-\n-  if (indexed_type != elt_type )\n-    abort ();\n-  else\n-    return indexed_type;\n+  return indexed_type;\n }\n \n /* newarray triggers a call to _Jv_NewPrimArray. This function should be \n@@ -1155,23 +1119,18 @@ expand_java_arraystore (tree rhs_type_node)\n   tree index = pop_value (int_type_node);\n   tree array_type, array;\n \n-  if (flag_new_verifier)\n+  /* If we're processing an `aaload' we might as well just pick\n+     `Object'.  */\n+  if (TREE_CODE (rhs_type_node) == POINTER_TYPE)\n     {\n-      /* If we're processing an `aaload' we might as well just pick\n-\t `Object'.  */\n-      if (TREE_CODE (rhs_type_node) == POINTER_TYPE)\n-\t{\n-\t  array_type = build_java_array_type (object_ptr_type_node, -1);\n-\t  rhs_type_node = object_ptr_type_node;\n-\t}\n-      else\n-\tarray_type = build_java_array_type (rhs_type_node, -1);\n+      array_type = build_java_array_type (object_ptr_type_node, -1);\n+      rhs_type_node = object_ptr_type_node;\n     }\n   else\n-    array_type = ptr_type_node;\n+    array_type = build_java_array_type (rhs_type_node, -1);\n+\n   array = pop_value (array_type);\n-  if (flag_new_verifier)\n-    array = build1 (NOP_EXPR, promote_type (array_type), array);\n+  array = build1 (NOP_EXPR, promote_type (array_type), array);\n \n   rhs_type_node    = build_java_check_indexed_type (array, rhs_type_node);\n \n@@ -1205,23 +1164,17 @@ expand_java_arrayload (tree lhs_type_node)\n   tree array_type;\n   tree array_node;\n \n-  if (flag_new_verifier)\n+  /* If we're processing an `aaload' we might as well just pick\n+     `Object'.  */\n+  if (TREE_CODE (lhs_type_node) == POINTER_TYPE)\n     {\n-      /* If we're processing an `aaload' we might as well just pick\n-\t `Object'.  */\n-      if (TREE_CODE (lhs_type_node) == POINTER_TYPE)\n-\t{\n-\t  array_type = build_java_array_type (object_ptr_type_node, -1);\n-\t  lhs_type_node = object_ptr_type_node;\n-\t}\n-      else\n-\tarray_type = build_java_array_type (lhs_type_node, -1);\n+      array_type = build_java_array_type (object_ptr_type_node, -1);\n+      lhs_type_node = object_ptr_type_node;\n     }\n   else\n-    array_type = ptr_type_node;\n+    array_type = build_java_array_type (lhs_type_node, -1);\n   array_node = pop_value (array_type);\n-  if (flag_new_verifier)\n-    array_node = build1 (NOP_EXPR, promote_type (array_type), array_node);\n+  array_node = build1 (NOP_EXPR, promote_type (array_type), array_node);\n \n   index_node = save_expr (index_node);\n   array_node = save_expr (array_node);\n@@ -1916,12 +1869,11 @@ pop_arguments (tree arg_types)\n       tree type = TREE_VALUE (arg_types);\n       tree arg = pop_value (type);\n \n-      /* With the new verifier we simply cast each argument to its\n-\t proper type.  This is needed since we lose type information\n-\t coming out of the verifier.  We also have to do this with the\n-\t old verifier when we pop an integer type that must be\n-\t promoted for the function call.  */\n-      if (flag_new_verifier && TREE_CODE (type) == POINTER_TYPE)\n+      /* We simply cast each argument to its proper type.  This is\n+\t needed since we lose type information coming out of the\n+\t verifier.  We also have to do this when we pop an integer\n+\t type that must be promoted for the function call.  */\n+      if (TREE_CODE (type) == POINTER_TYPE)\n \targ = build1 (NOP_EXPR, type, arg);\n       else if (targetm.calls.promote_prototypes (type)\n \t       && TYPE_PRECISION (type) < TYPE_PRECISION (integer_type_node)\n@@ -2943,16 +2895,8 @@ expand_byte_code (JCF *jcf, tree method)\n \t}\n     }  \n \n-  if (flag_new_verifier)\n-    {\n-      if (! verify_jvm_instructions_new (jcf, byte_ops, length))\n-        return;\n-    }\n-  else\n-    {\n-      if (! verify_jvm_instructions (jcf, byte_ops, length))\n-\treturn;\n-    }\n+  if (! verify_jvm_instructions_new (jcf, byte_ops, length))\n+    return;\n \n   promote_arguments ();\n \n@@ -3065,10 +3009,10 @@ process_jvm_instruction (int PC, const unsigned char* byte_ops,\n      replace the top of the stack with the thrown object reference */\n   if (instruction_bits [PC] & BCODE_EXCEPTION_TARGET)\n     {\n-      /* Note that the new verifier will not emit a type map at all\n-\t for dead exception handlers.  In this case we just ignore\n-\t the situation.  */\n-      if (! flag_new_verifier || (instruction_bits[PC] & BCODE_VERIFIED) != 0)\n+      /* Note that the verifier will not emit a type map at all for\n+\t dead exception handlers.  In this case we just ignore the\n+\t situation.  */\n+      if ((instruction_bits[PC] & BCODE_VERIFIED) != 0)\n \t{\n \t  tree type = pop_type (promote_type (throwable_type_node));\n \t  push_value (build_exception_object_ref (type));"}, {"sha": "b96e818584aa7110a5eac68d3caa5c44c00cfbd0", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e8066b7bfb8de474c80e0ea10a64aab487fc17/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e8066b7bfb8de474c80e0ea10a64aab487fc17/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=65e8066b7bfb8de474c80e0ea10a64aab487fc17", "patch": "@@ -219,9 +219,6 @@ extern int flag_indirect_dispatch;\n /* When zero, don't generate runtime array store checks. */\n extern int flag_store_check;\n \n-/* When nonzero, use the new bytecode verifier.  */\n-extern int flag_new_verifier;\n-\n /* Encoding used for source files.  */\n extern const char *current_encoding;\n \n@@ -1328,7 +1325,6 @@ extern void init_class_processing (void);\n extern void add_type_assertion (tree, int, tree, tree);\n extern int can_widen_reference_to (tree, tree);\n extern int class_depth (tree);\n-extern int verify_jvm_instructions (struct JCF *, const unsigned char *, long);\n extern int verify_jvm_instructions_new (struct JCF *, const unsigned char *,\n \t\t\t\t\tlong);\n extern void maybe_pushlevels (int);"}, {"sha": "4b7902f28250ff670f2caade23b0a614697f0d84", "filename": "gcc/java/lang.c", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65e8066b7bfb8de474c80e0ea10a64aab487fc17/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65e8066b7bfb8de474c80e0ea10a64aab487fc17/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=65e8066b7bfb8de474c80e0ea10a64aab487fc17", "patch": "@@ -133,9 +133,6 @@ int flag_deprecated = 1;\n /* Don't attempt to verify invocations.  */\n int flag_verify_invocations = 0; \n \n-/* True if the new bytecode verifier should be used.  */\n-int flag_new_verifier = 1;\n-\n /* When nonzero, print extra version information.  */\n static int v_flag = 0;\n \n@@ -606,12 +603,6 @@ java_post_options (const char **pfilename)\n      must always verify everything.  */\n   if (! flag_indirect_dispatch)\n     flag_verify_invocations = true;\n-  else\n-    {\n-      /* If we are using indirect dispatch, then we want the new\n-\t verifier as well.  */\n-      flag_new_verifier = 1;\n-    }\n \n   /* Open input file.  */\n "}, {"sha": "5b544b86f1face173a6a15d44da99233ae80d32e", "filename": "gcc/java/verify.c", "status": "removed", "additions": 0, "deletions": 1574, "changes": 1574, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30f86ec3fba12cb0574db51d75d3355f7264aa77/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30f86ec3fba12cb0574db51d75d3355f7264aa77/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=30f86ec3fba12cb0574db51d75d3355f7264aa77", "patch": "@@ -1,1574 +0,0 @@\n-/* Handle verification of bytecoded methods for the GNU compiler for \n-   the Java(TM) language.\n-   Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005\n-   Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 2, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING.  If not, write to\n-the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n-Boston, MA 02110-1301, USA.\n-\n-Java and all Java-based marks are trademarks or registered trademarks\n-of Sun Microsystems, Inc. in the United States and other countries.\n-The Free Software Foundation is independent of Sun Microsystems, Inc.  */\n-\n-/* This bytecode verifier is an implementation of the bytecode\n-verification process described in section 4.9 of \"The Java(TM) Virtual\n-Machine Specification\", Second Edition, by Tim Lindholm and Frank Yellin,\n-published by Addison-Wesley in 1999.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"tm.h\"\n-#include \"tree.h\"\n-#include \"java-tree.h\"\n-#include \"javaop.h\"\n-#include \"java-opcodes.h\"\n-#include \"jcf.h\"\n-#include \"java-except.h\"\n-#include \"toplev.h\"\n-\n-static void push_pending_label (tree);\n-static tree merge_types (tree, tree);\n-static const char *check_pending_block (tree);\n-static void type_stack_dup (int, int);\n-static int start_pc_cmp (const void *, const void *);\n-static char *pop_argument_types (tree);\n-\n-extern int stack_pointer;\n-\n-/* During verification, start of the current subroutine (jsr target). */\n-tree current_subr;\n-\n-/* A list of pending blocks, chained using  LABEL_PENDING_CHAIN.\n-   A pending block is one that has LABEL_CHANGED set, which means\n-   it requires (re-) verification. */\n-tree pending_blocks;\n-\n-/* Append TARGET_LABEL to the pending_block stack unless already in it. */\n-\n-static void\n-push_pending_label (tree target_label) \n-{\n-  if (! LABEL_CHANGED (target_label))\n-    {\n-      LABEL_PENDING_CHAIN (target_label) = pending_blocks;\n-      pending_blocks = target_label;\n-      LABEL_CHANGED (target_label) = 1;\n-    }\n-}\n-\n-/* Note that TARGET_LABEL is a possible successor instruction.\n-   Merge the type state etc.\n-   Return NULL on success, or an error message on failure. */\n-\n-static const char *\n-check_pending_block (tree target_label)\n-{\n-  int changed = merge_type_state (target_label);\n-\n-  if (changed)\n-    {\n-      if (changed < 0)\n-\treturn \"types could not be merged\";\n-      push_pending_label (target_label);\n-    }\n-\n-  if (current_subr == NULL_TREE)\n-    {\n-      if (LABEL_IN_SUBR (target_label))\n-\treturn \"might transfer control into subroutine\";\n-    }\n-  else\n-    {\n-      if (LABEL_IN_SUBR (target_label))\n-\t{\n-\t  if (LABEL_SUBR_START (target_label) != current_subr)\n-\t    return \"transfer out of subroutine\";\n-\t}\n-      else if (! LABEL_VERIFIED (target_label))\n-\t{\n-\t  LABEL_IN_SUBR (target_label) = 1;\n-\t  LABEL_SUBR_START (target_label) = current_subr;\n-\t}\n-      else\n-\treturn \"transfer out of subroutine\";\n-    }\n-  return NULL;\n-}\n-\n-/* Count the number of nested jsr calls needed to reach LABEL. */\n-\n-static int\n-subroutine_nesting (tree label)\n-{\n-  int nesting = 0;\n-  while (label != NULL_TREE && LABEL_IN_SUBR (label))\n-    {\n-      if (! LABEL_IS_SUBR_START (label))\n-\tlabel = LABEL_SUBR_START (label);\n-      label = LABEL_SUBR_CONTEXT (label);\n-      nesting++;\n-    }\n-  return nesting;\n-}\n-\n-/* Return the \"merged\" types of TYPE1 and TYPE2.\n-   If either is primitive, the other must match (after promotion to int).\n-   For reference types, return the common super-class.\n-   Return TYPE_UNKNOWN if the types cannot be merged. */   \n-\n-static tree\n-merge_types (tree type1, tree type2)\n-{\n-  if (type1 == type2)\n-    return type1;\n-  if (type1 == TYPE_UNKNOWN || type2 == TYPE_UNKNOWN\n-      || type1 == TYPE_RETURN_ADDR || type2 == TYPE_RETURN_ADDR)\n-    return TYPE_UNKNOWN;\n-  if (TREE_CODE (type1) == POINTER_TYPE && TREE_CODE (type2) == POINTER_TYPE)\n-    {\n-      int depth1, depth2;\n-      tree tt1, tt2;\n-      /* ptr_type_node is only used for a null reference,\n-\t which is compatible with any reference type. */\n-      if (type1 == ptr_type_node || type2 == object_ptr_type_node)\n-\treturn type2;\n-      if (type2 == ptr_type_node || type1 == object_ptr_type_node)\n-\treturn type1;\n-\n-      tt1 = TREE_TYPE (type1);\n-      tt2 = TREE_TYPE (type2);\n-\n-      /* If tt{1,2} haven't been properly loaded, now is a good time\n-         to do it. */\n-      if (!TYPE_SIZE (tt1))\n-\t{\n-\t  load_class (tt1, 1);\n-\t  safe_layout_class (tt1);\n-\t}\n-\n-      if (!TYPE_SIZE (tt2))\n-\t{\n-\t  load_class (tt2, 1);\n-\t  safe_layout_class (tt2);\n-\t}\n-\n-      if (TYPE_ARRAY_P (tt1) || TYPE_ARRAY_P (tt2))\n-\t{\n-\t  if (TYPE_ARRAY_P (tt1) == TYPE_ARRAY_P (tt2))\n-\t    {\n-\t      tree el_type1 = TYPE_ARRAY_ELEMENT (tt1);\n-\t      tree el_type2 = TYPE_ARRAY_ELEMENT (tt2);\n-\t      tree el_type = NULL_TREE;\n-\t      if (el_type1 == el_type2)\n-\t\tel_type = el_type1;\n-\t      else if (TREE_CODE (el_type1) == POINTER_TYPE\n-\t\t       && TREE_CODE (el_type2) == POINTER_TYPE)\n-\t\tel_type = merge_types (el_type1, el_type2);\n-\t      if (el_type != NULL_TREE)\n-\t\t{\n-\t\t  HOST_WIDE_INT len1 = java_array_type_length (tt1);\n-\t\t  HOST_WIDE_INT len2 = java_array_type_length (tt2);\n-\t\t  if (len1 != len2)\n-\t\t    len1 = -1;\n-\t\t  else if (el_type1 == el_type2)\n-\t\t    return type1;\n-\t\t  return promote_type (build_java_array_type (el_type, len1));\n-\t\t}\n-\t    }\n-\t  return object_ptr_type_node;\n-\t}\n-\n-      if (CLASS_INTERFACE (TYPE_NAME (tt1)))\n-\t{\n-\t  /* FIXME: should see if two interfaces have a common\n-\t     superinterface.  */\n-\t  if (CLASS_INTERFACE (TYPE_NAME (tt2)))\n-\t    {\n-\t      /* This is a kludge, but matches what Sun's verifier does.\n-\t\t It can be tricked, but is safe as long as type errors\n-\t\t (i.e. interface method calls) are caught at run-time. */\n-\t      return object_ptr_type_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      if (can_widen_reference_to (tt2, tt1))\n-\t\treturn type1;\n-\t      else\n-\t\treturn object_ptr_type_node;\n-\t    }\n-\t}\n-      else if (CLASS_INTERFACE (TYPE_NAME (tt2)))\n-\t{\n-\t  if (can_widen_reference_to (tt1, tt2))\n-\t    return type2;\n-\t  else\n-\t    return object_ptr_type_node;\n-\t}\n-\n-      type1 = tt1;\n-      type2 = tt2;\n-\n-      depth1 = class_depth (type1);\n-      depth2 = class_depth (type2);\n-      for ( ; depth1 > depth2;  depth1--)\n-\ttype1 = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type1), 0));\n-      for ( ; depth2 > depth1;  depth2--)\n-\ttype2 = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type2), 0));\n-      while (type1 != type2)\n-\t{\n-\t  type1 = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type1), 0));\n-\t  type2 = BINFO_TYPE (BINFO_BASE_BINFO (TYPE_BINFO (type2), 0));\n-\t}\n-      return promote_type (type1);\n-    }\n-  if (INTEGRAL_TYPE_P (type1) && INTEGRAL_TYPE_P (type2)\n-      && TYPE_PRECISION (type1) <= 32 && TYPE_PRECISION (type2) <= 32)\n-    return int_type_node;\n-  return TYPE_UNKNOWN;\n-}\n-\n-/* Merge the current type state with that at LABEL.\n-   Return -1 if the states are incompatible (i.e. on error),\n-   0 if there was no change, and 1 if there was a change. */\n-\n-int\n-merge_type_state (tree label)\n-{\n-  int nlocals = DECL_MAX_LOCALS (current_function_decl);\n-  int cur_length = stack_pointer + nlocals;\n-  tree vec = LABEL_TYPE_STATE (label);\n-  tree return_map;\n-  if (vec == NULL_TREE)\n-    {\n-      vec = make_tree_vec (cur_length);\n-      LABEL_TYPE_STATE (label) = vec;\n-\n-      while (--cur_length >= 0)\n-\tTREE_VEC_ELT (vec, cur_length) = type_map[cur_length];\n-      return 1;\n-    }\n-  else\n-    {\n-      int i;\n-      int changed = 0;\n-      if (LABEL_IS_SUBR_START (label) && LABEL_VERIFIED (label)\n-\t  && current_subr != label)\n-\treturn_map = LABEL_RETURN_TYPE_STATE (label);\n-      else\n-\treturn_map = NULL_TREE;\n-      if (TREE_VEC_LENGTH (vec) != cur_length)\n-\t{\n-\t  return -1;\n-\t}\n-      for (i = 0; i < cur_length; i++)\n-\t{\n-\t  tree old_type = TREE_VEC_ELT (vec, i);\n-\t  tree new_type = merge_types (old_type, type_map[i]);\n-\t  if (TREE_VEC_ELT (vec, i) != new_type)\n-\t    {\n-\t      /* If there has been a change, note that since we must re-verify.\n-\t\t However, if the label is the start of a subroutine,\n-\t\t we don't care about local variables that are neither\n-\t\t set nor used in the subroutine. */\n-\t      if (return_map == NULL_TREE || i >= nlocals\n-\t\t  || TREE_VEC_ELT (return_map, i) != TYPE_UNUSED\n-\t\t  || (TYPE_IS_WIDE (new_type)\n-\t\t      && TREE_VEC_ELT (return_map, i+1) != TYPE_UNUSED))\n-\t\tchanged = 1;\n-\t    }\n-\t  TREE_VEC_ELT (vec, i) = new_type;\n-\t  if (new_type == TYPE_UNKNOWN)\n-\t    {\n-\t      if (i >= nlocals)\n-\t\treturn -1;\n-\t    }\n-\t  else if (TYPE_IS_WIDE (new_type))\n-\t    i++;\n-\t}\n-      return changed;\n-    }\n-}\n-\n-/* Handle dup-like operations. */\n-\n-static void\n-type_stack_dup (int size, int offset)\n-{\n-  tree type[4];\n-  int index;\n-  for (index = 0;  index < size + offset; index++)\n-    {\n-      type[index] = stack_type_map[stack_pointer - 1];\n-      if (type[index] == void_type_node)\n-\t{\n-\t  index++;\n-\t  type[index] = stack_type_map[stack_pointer - 2];\n-\t  if (! TYPE_IS_WIDE (type[index]))\n-\t    abort ();\n-\t  if (index == size || index == size + offset)\n-\t    /* Dup operation splits 64-bit number.  */\n-\t    abort ();\n-\t}\n-      pop_type (type[index]);\n-    }\n-  for (index = size;  --index >= 0; )\n-    {\n-      if (type[index] != void_type_node)\n-\tpush_type (type[index]);\n-    }\n-\n-  for (index = size + offset;  --index >= 0; )\n-    {\n-      if (type[index] != void_type_node)\n-\tpush_type (type[index]);\n-    }\n-}\n-\n-/* This keeps track of a start PC and corresponding initial index.  */\n-struct pc_index\n-{\n-  int start_pc;\n-  int index;\n-};\n-\n-/* A helper that is used when sorting exception ranges.  */\n-static int\n-start_pc_cmp (const void *xp, const void *yp)\n-{\n-  const struct pc_index *x = (const struct pc_index *) xp;\n-  const struct pc_index *y = (const struct pc_index *) yp;\n-  return x->start_pc - y->start_pc;\n-}\n-\n-/* This causes the next iteration to ignore the next instruction\n-   and look for some other unhandled instruction. */\n-#define INVALIDATE_PC (prevpc = -1, oldpc = PC, PC = INVALID_PC)\n-#define INVALID_PC (-1)\n-\n-#define VERIFICATION_ERROR(MESSAGE) \\\n-  do { message = MESSAGE;  goto verify_error; } while (0)\n-\n-#define VERIFICATION_ERROR_WITH_INDEX(MESSAGE) \\\n-  do { message = MESSAGE;  goto error_with_index; } while (0)\n-\n-/* Recursive helper function to pop argument types during verification.\n-   ARG_TYPES is the list of formal parameter types.\n-   Return NULL on success and a freshly malloc'd error message on failure. */\n-\n-static char *\n-pop_argument_types (tree arg_types)\n-{\n-  if (arg_types == end_params_node)\n-    return NULL;\n-  if (TREE_CODE (arg_types) == TREE_LIST)\n-    {\n-      char *message = pop_argument_types (TREE_CHAIN (arg_types));\n-      if (message == NULL)\n-\tpop_type_0 (TREE_VALUE (arg_types), &message);\n-      return message;\n-    }\n-  abort ();\n-}\n-\n-#define POP_TYPE(TYPE, MESSAGE) \\\n-  do { pmessage = NULL;  pop_type_0 (TYPE, &pmessage); \\\n-       if (pmessage != NULL) goto pop_type_error; \\\n-  } while (0)\n-\n-#define POP_TYPE_CONV(TYPE, POPPED_TYPE, MESSAGE) \\\n-  do { pmessage = NULL;  POPPED_TYPE = pop_type_0 (TYPE, &pmessage); \\\n-       if (pmessage != NULL) goto pop_type_error; \\\n-  } while (0)\n-\n-#define PUSH_TYPE(TYPE) \\\n-  do { if (! push_type_0 (TYPE)) { goto stack_overflow; }} while (0)\n-\n-#define PUSH_PENDING(LABEL) \\\n-     do { tree tmplab = LABEL; \\\n-          if ((message = check_pending_block (tmplab)) != NULL) \\\n-            { oldpc = LABEL_PC (tmplab); goto verify_error; }} while (0)\n-\n-#ifdef __GNUC__\n-#define CHECK_PC_IN_RANGE(PC) __extension__ \\\n-  ({if (PC < 0 || PC > length) goto bad_pc; (void)1;})\n-#else\n-#define CHECK_PC_IN_RANGE(PC) (PC < 0 || PC > length ? (abort (), 0) : 1)\n-#endif\n-\n-#define BCODE byte_ops\n-\n-\f\n-/* Verify the bytecodes of the current method, with the instructions\n-   starting at BYTE_OPS and LENGTH in number, from the class file pointed to\n-   by JCF.\n-   Return 1 on success, 0 on failure.  */\n-int\n-verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n-{\n-  tree label;\n-  int wide = 0;\n-  int op_code;\n-  int PC;\n-  int oldpc = 0; /* PC of start of instruction. */\n-  int prevpc = 0;  /* If >= 0, PC of previous instruction. */\n-  const char *message = 0;\n-  char *pmessage;\n-  int i;\n-  int index;\n-  unsigned char *p;\n-  struct eh_range *prev_eh_ranges = NULL_EH_RANGE;\n-  struct eh_range *eh_ranges;\n-  tree return_type = TREE_TYPE (TREE_TYPE (current_function_decl));\n-  struct pc_index *starts;\n-  int eh_count;\n-\n-  jint int_value = -1;\n-\n-  pending_blocks = NULL_TREE;\n-\n-  current_subr = NULL_TREE;\n-\n-  /* Handle the exception table.  */\n-  method_init_exceptions ();\n-  JCF_SEEK (jcf, DECL_CODE_OFFSET (current_function_decl) + length);\n-  eh_count = JCF_readu2 (jcf);\n-\n-  /* We read the exception handlers in order of increasing start PC.\n-     To do this we first read and sort the start PCs.  */\n-  starts = xmalloc (eh_count * sizeof (struct pc_index));\n-  for (i = 0; i < eh_count; ++i)\n-    {\n-      starts[i].start_pc = GET_u2 (jcf->read_ptr + 8 * i);\n-      starts[i].index = i;\n-    }\n-  qsort (starts, eh_count, sizeof (struct pc_index), start_pc_cmp);\n-\n-  for (i = 0; i < eh_count; ++i)\n-    {\n-      int start_pc, end_pc, handler_pc, catch_type;\n-\n-      p = jcf->read_ptr + 8 * starts[i].index;\n-\n-      start_pc = GET_u2 (p);\n-      end_pc = GET_u2 (p+2);\n-      handler_pc = GET_u2 (p+4);\n-      catch_type = GET_u2 (p+6);\n-\n-      if (start_pc < 0 || start_pc >= length\n-\t  || end_pc < 0 || end_pc > length || start_pc >= end_pc\n-\t  || handler_pc < 0 || handler_pc >= length\n-\t  || ! (instruction_bits[start_pc] & BCODE_INSTRUCTION_START)\n-\t  || (end_pc < length &&\n-\t     ! (instruction_bits[end_pc] & BCODE_INSTRUCTION_START))\n-\t  || ! (instruction_bits[handler_pc] & BCODE_INSTRUCTION_START))\n-\t{\n-\t  error (\"bad pc in exception_table\");\n-\t  free (starts);\n-\t  return 0;\n-\t}\n-\n-      add_handler (start_pc, end_pc,\n-\t\t   lookup_label (handler_pc),\n-\t\t   catch_type == 0 ? NULL_TREE\n-\t\t   : get_class_constant (jcf, catch_type));\n-\n-      instruction_bits[handler_pc] |= BCODE_EXCEPTION_TARGET;\n-    }\n-\n-  free (starts);\n-\n-  for (PC = 0;;)\n-    {\n-      tree type, tmp;\n-\n-      if (((PC != INVALID_PC\n-\t   && instruction_bits[PC] & BCODE_TARGET) != 0)\n-\t  || PC == 0)\n-\t{\n-\t  PUSH_PENDING (lookup_label (PC));\n-\t  INVALIDATE_PC;\n-\t}\n-\n-      /* Check if there are any more pending blocks in the current\n-\t subroutine.  Because we push pending blocks in a\n-\t last-in-first-out order, and because we don't push anything\n-\t from our caller until we are done with this subroutine or\n-\t anything nested in it, we are done if the top of the\n-\t pending_blocks stack is not in a subroutine, or it is in our\n-\t caller. */\n-      if (current_subr && PC == INVALID_PC)\n-\t{\n-\t  if (pending_blocks == NULL_TREE\n-\t      || (subroutine_nesting (pending_blocks)\n-\t\t  < subroutine_nesting (current_subr)))\n-\t    {\n-\t      int size\n-                = DECL_MAX_LOCALS (current_function_decl) + stack_pointer;\n-\n-\t      tree ret_map = LABEL_RETURN_TYPE_STATE (current_subr);\n-\t      tmp = LABEL_RETURN_LABELS (current_subr);\n-\t      \n-\t      /* FIXME: If we exit a subroutine via a throw, we might\n-\t\t have returned to an earlier caller.  Obviously a\n-\t\t \"ret\" can only return one level, but a throw may\n-\t\t return many levels.  */\n-\t      current_subr = LABEL_SUBR_CONTEXT (current_subr);\n-\n-\t      if (RETURN_MAP_ADJUSTED (ret_map))\n-\t\t{\n-\t\t  /* Since we are done with this subroutine, set up\n-\t\t     the (so far known) return address as pending -\n-\t\t     with the merged type state.  */\n-\t\t  for ( ; tmp != NULL_TREE;  tmp = TREE_CHAIN (tmp))\n-\t\t    {\n-\t\t      tree return_label = TREE_VALUE (tmp);\n-\t\t      tree return_state = LABEL_TYPE_STATE (return_label);\n-\t\t      if (return_state == NULL_TREE)\n-\t\t\t{\n-\t\t\t  /* This means we had not verified the subroutine\n-                             earlier, so this is the first jsr to call it.\n-                             In this case, the type_map of the return\n-\t\t\t     address is just the current type_map - and that\n-\t\t\t     is handled by the following PUSH_PENDING.  */\n-\t\t\t}\n-\t\t      else\n-\t\t\t{\n-\t\t\t  /* In this case we have to do a merge.  But first\n-\t\t\t     restore the type_map for unused slots to those\n-\t\t\t     that were in effect at the jsr.  */\n-\t\t\t  for (index = size; --index >= 0; )\n-\t\t\t    {\n-\t\t\t      type_map[index]\n-                                = TREE_VEC_ELT (ret_map, index);\n-\n-\t\t\t      if (type_map[index] == TYPE_UNUSED)\n-\t\t\t\ttype_map[index]\n-\t\t\t\t  = TREE_VEC_ELT (return_state, index);\n-\t\t\t    }\n-\t\t\t}\n-\t\t      PUSH_PENDING (return_label);\n-\t\t    }\n-\t\t}\n-\t    }\n-\t}\n-\n-      if (PC == INVALID_PC)\n-\t{\n-\t  label = pending_blocks;\n-\n-\t  if (label == NULL_TREE)\n-\t    break;  /* We're done! */\n-\n-\t  pending_blocks = LABEL_PENDING_CHAIN (label);\n-\t  LABEL_CHANGED (label) = 0;\n-\n-\t  if (LABEL_IN_SUBR (label))\n-\t    current_subr = LABEL_SUBR_START (label);\n-\t  else\n-\t    current_subr = NULL_TREE;\n-\n-\t  /* Restore type_map and stack_pointer from\n-\t     LABEL_TYPE_STATE (label), and continue\n-\t     compiling from there.  */\n-\t  load_type_state (label);\n-\n-\t  PC = LABEL_PC (label);\n-\t}\n-      else if (PC >= length)\n-\tVERIFICATION_ERROR (\"falling through the end of the method\");\n-\n-\n-      oldpc = PC;\n-\n-      if (! (instruction_bits[PC] & BCODE_INSTRUCTION_START) && ! wide)\n-\tVERIFICATION_ERROR (\"PC not at instruction start\");\n-\n-      instruction_bits[PC] |= BCODE_VERIFIED;\n-\n-      eh_ranges = find_handler (oldpc);\n-\n-      op_code = byte_ops[PC++];\n-      switch (op_code)\n-\t{\n-\t  int is_static, is_putting;\n-\n-\tcase OPCODE_nop:\n-\t  break;\n-\n-\tcase OPCODE_iconst_m1:\n-\tcase OPCODE_iconst_0:\tcase OPCODE_iconst_1:\tcase OPCODE_iconst_2:\n-\tcase OPCODE_iconst_3:\tcase OPCODE_iconst_4:\tcase OPCODE_iconst_5:\n-\t  i = op_code - OPCODE_iconst_0;\n-\t  goto push_int;\n-\tpush_int:\n-\t  if (byte_ops[PC] == OPCODE_newarray\n-\t      || byte_ops[PC] == OPCODE_anewarray)\n-\t    int_value = i;\n-\t  PUSH_TYPE (int_type_node);  break;\n-\n-\tcase OPCODE_lconst_0:\tcase OPCODE_lconst_1:\n-\t  PUSH_TYPE (long_type_node);  break;\n-\n-\tcase OPCODE_fconst_0:\tcase OPCODE_fconst_1:\tcase OPCODE_fconst_2:\n-\t  PUSH_TYPE (float_type_node);  break;\n-\n-\tcase OPCODE_dconst_0:\tcase OPCODE_dconst_1:\n-\t  PUSH_TYPE (double_type_node);  break;\n-\n-\tcase OPCODE_bipush:\n-\t  i = IMMEDIATE_s1;\n-\t  goto push_int;\n-\n-\tcase OPCODE_sipush:\n-\t  i = IMMEDIATE_s2;\n-\t  goto push_int;\n-\n-\tcase OPCODE_iload:  type = int_type_node;  goto general_load;\n-\tcase OPCODE_lload:  type = long_type_node;  goto general_load;\n-\tcase OPCODE_fload:  type = float_type_node;  goto general_load;\n-\tcase OPCODE_dload:  type = double_type_node;  goto general_load;\n-\tcase OPCODE_aload:  type = ptr_type_node;  goto general_load;\n-\tgeneral_load:\n-\tindex = wide ? IMMEDIATE_u2 : IMMEDIATE_u1;\n-\twide = 0;\n-\tgoto load;\n-\tcase OPCODE_iload_0:  type = int_type_node;  index = 0; goto load;\n-\tcase OPCODE_iload_1:  type = int_type_node;  index = 1; goto load;\n-\tcase OPCODE_iload_2:  type = int_type_node;  index = 2; goto load;\n-\tcase OPCODE_iload_3:  type = int_type_node;  index = 3; goto load;\n-\tcase OPCODE_lload_0:  type = long_type_node; index = 0; goto load;\n-\tcase OPCODE_lload_1:  type = long_type_node; index = 1; goto load;\n-\tcase OPCODE_lload_2:  type = long_type_node; index = 2; goto load;\n-\tcase OPCODE_lload_3:  type = long_type_node; index = 3; goto load;\n-\tcase OPCODE_fload_0:  type = float_type_node; index = 0; goto load;\n-\tcase OPCODE_fload_1:  type = float_type_node; index = 1; goto load;\n-\tcase OPCODE_fload_2:  type = float_type_node; index = 2; goto load;\n-\tcase OPCODE_fload_3:  type = float_type_node; index = 3; goto load;\n-\tcase OPCODE_dload_0: type = double_type_node; index = 0; goto load;\n-\tcase OPCODE_dload_1: type = double_type_node; index = 1; goto load;\n-\tcase OPCODE_dload_2: type = double_type_node; index = 2; goto load;\n-\tcase OPCODE_dload_3: type = double_type_node; index = 3; goto load;\n-\tcase OPCODE_aload_0:  type = ptr_type_node;  index = 0;  goto load;\n-\tcase OPCODE_aload_1:  type = ptr_type_node;  index = 1;  goto load;\n-\tcase OPCODE_aload_2:  type = ptr_type_node;  index = 2;  goto load;\n-\tcase OPCODE_aload_3:  type = ptr_type_node;  index = 3;  goto load;\n-\tload:\n-\tif (index < 0\n-\t    || (index + TYPE_IS_WIDE (type)\n-\t\t>= DECL_MAX_LOCALS (current_function_decl)))\n-\t  VERIFICATION_ERROR_WITH_INDEX\n-\t    (\"invalid local variable index %d in load\");\n-\ttmp = type_map[index];\n-\tif (tmp == TYPE_UNKNOWN)\n-\t  VERIFICATION_ERROR_WITH_INDEX\n-\t    (\"loading local variable %d which has unknown type\");\n-\telse if (tmp == TYPE_SECOND\n-\t    || (TYPE_IS_WIDE (type)\n-\t\t&& type_map[index+1] != void_type_node)\n-\t    || (type == ptr_type_node\n-\t\t? TREE_CODE (tmp) != POINTER_TYPE\n-\t\t: type == int_type_node\n-\t\t? (! INTEGRAL_TYPE_P (tmp) || TYPE_PRECISION (tmp) > 32)\n-\t\t: type != tmp))\n-\t  VERIFICATION_ERROR_WITH_INDEX\n-\t    (\"loading local variable %d which has invalid type\");\n-\tPUSH_TYPE (tmp);\n-\tgoto note_used;\n-\tcase OPCODE_istore:  type = int_type_node;  goto general_store;\n-\tcase OPCODE_lstore:  type = long_type_node;  goto general_store;\n-\tcase OPCODE_fstore:  type = float_type_node;  goto general_store;\n-\tcase OPCODE_dstore:  type = double_type_node;  goto general_store;\n-\tcase OPCODE_astore:  type = object_ptr_type_node;  goto general_store;\n-\tgeneral_store:\n-\tindex = wide ? IMMEDIATE_u2 : IMMEDIATE_u1;\n-\twide = 0;\n-\tgoto store;\n-\tcase OPCODE_istore_0:  type = int_type_node; index = 0; goto store;\n-\tcase OPCODE_istore_1:  type = int_type_node; index = 1; goto store;\n-\tcase OPCODE_istore_2:  type = int_type_node; index = 2; goto store;\n-\tcase OPCODE_istore_3:  type = int_type_node; index = 3; goto store;\n-\tcase OPCODE_lstore_0:  type = long_type_node; index=0; goto store;\n-\tcase OPCODE_lstore_1:  type = long_type_node; index=1; goto store;\n-\tcase OPCODE_lstore_2:  type = long_type_node; index=2; goto store;\n-\tcase OPCODE_lstore_3:  type = long_type_node; index=3; goto store;\n-\tcase OPCODE_fstore_0:  type=float_type_node; index=0; goto store;\n-\tcase OPCODE_fstore_1:  type=float_type_node; index=1; goto store;\n-\tcase OPCODE_fstore_2:  type=float_type_node; index=2; goto store;\n-\tcase OPCODE_fstore_3:  type=float_type_node; index=3; goto store;\n-\tcase OPCODE_dstore_0:  type=double_type_node; index=0; goto store;\n-\tcase OPCODE_dstore_1:  type=double_type_node; index=1; goto store;\n-\tcase OPCODE_dstore_2:  type=double_type_node; index=2; goto store;\n-\tcase OPCODE_dstore_3:  type=double_type_node; index=3; goto store;\n-\tcase OPCODE_astore_0:  type = ptr_type_node; index = 0; goto store;\n-\tcase OPCODE_astore_1:  type = ptr_type_node; index = 1; goto store;\n-\tcase OPCODE_astore_2:  type = ptr_type_node; index = 2; goto store;\n-\tcase OPCODE_astore_3:  type = ptr_type_node; index = 3; goto store;\n-\tstore:\n-\tif (index < 0\n-\t    || (index + TYPE_IS_WIDE (type)\n-\t\t>= DECL_MAX_LOCALS (current_function_decl)))\n-\t  {\n-\t    VERIFICATION_ERROR_WITH_INDEX\n-\t      (\"invalid local variable index %d in store\");\n-\t    return 0;\n-\t  }\n-\tPOP_TYPE_CONV (type, type, NULL);\n-\ttype_map[index] = type;\n-\n-\t/* If a local variable has changed, we need to reconsider exception\n-        handlers.  */\n-\tprev_eh_ranges = NULL_EH_RANGE;\n-\n-\t/* Allocate decl for this variable now, so we get a temporary\n-! \t   that survives the whole method. */\n-\tfind_local_variable (index, type, oldpc);\n-\n-        if (TYPE_IS_WIDE (type))\n-          type_map[index+1] = TYPE_SECOND;\n-\n-\t/* ... fall through to note_used ... */\n-\tnote_used:\n-\t  /* For store or load, note that local variable INDEX is used.\n-\t     This is needed to verify try-finally subroutines. */\n-\t  if (current_subr)\n-\t    {\n-\t      tree vec = LABEL_RETURN_TYPE_STATE (current_subr);\n-\t      tree subr_vec = LABEL_TYPE_STATE (current_subr);\n-\t      int len = 1 + TYPE_IS_WIDE (type);\n-\t      while (--len >= 0)\n-\t\t{\n-\t\t  if (TREE_VEC_ELT (vec, index) == TYPE_UNUSED)\n-\t\t    TREE_VEC_ELT (vec, index) = TREE_VEC_ELT (subr_vec, index);\n-\t\t}\n-\t    }\n-\tbreak;\n-\tcase OPCODE_iadd:\n-\tcase OPCODE_iand:\n-\tcase OPCODE_idiv:\n-\tcase OPCODE_imul:\n-\tcase OPCODE_ior:\n-\tcase OPCODE_irem:\n-\tcase OPCODE_ishl:\n-\tcase OPCODE_ishr:\n-\tcase OPCODE_isub:\n-\tcase OPCODE_iushr:\n-\tcase OPCODE_ixor:\n-\t  type = int_type_node;  goto binop;\n-\tcase OPCODE_ineg:\n-\tcase OPCODE_i2c:\n-\tcase OPCODE_i2b:\n-\tcase OPCODE_i2s:\n-\t  type = int_type_node;  goto unop;\n-\tcase OPCODE_ladd:\n-\tcase OPCODE_land:\n-\tcase OPCODE_ldiv:\n-\tcase OPCODE_lsub:\n-\tcase OPCODE_lmul:\n-\tcase OPCODE_lrem:\n-\tcase OPCODE_lor:\n-\tcase OPCODE_lxor:\n-\t  type = long_type_node;  goto binop;\n-\tcase OPCODE_lneg:\n-\t  type = long_type_node;  goto unop;\n-\tcase OPCODE_fadd:\tcase OPCODE_fsub:\n-\tcase OPCODE_fmul:\tcase OPCODE_fdiv:\tcase OPCODE_frem:\n-\t  type = float_type_node;  goto binop;\n-\tcase OPCODE_fneg:\n-\t  type = float_type_node;  goto unop;\n-\tcase OPCODE_dadd:\tcase OPCODE_dsub:\n-\tcase OPCODE_dmul:\tcase OPCODE_ddiv:\tcase OPCODE_drem:\n-\t  type = double_type_node;  goto binop;\n-\tcase OPCODE_dneg:\n-\t  type = double_type_node;  goto unop;\n-\n-\tunop:\n-\t  pop_type (type);\n-\t  PUSH_TYPE (type);\n-\t  break;\n-\n-\tbinop:\n-\t  pop_type (type);\n-\t  pop_type (type);\n-\t  PUSH_TYPE (type);\n-\t  break;\n-\n-\tcase OPCODE_lshl:\n-\tcase OPCODE_lshr:\n-\tcase OPCODE_lushr:\n-\t  pop_type (int_type_node);\n-\t  pop_type (long_type_node);\n-\t  PUSH_TYPE (long_type_node);\n-\t  break;\n-\n-\tcase OPCODE_iinc:\n-\t  index = wide ? IMMEDIATE_u2 : IMMEDIATE_u1;\n-\t  PC += wide + 1;\n-\t  wide = 0;\n-\t  if (index < 0 || index >= DECL_MAX_LOCALS (current_function_decl))\n-\t    VERIFICATION_ERROR (\"invalid local variable index in iinc\");\n-\t  tmp = type_map[index];\n-\t  if (tmp == NULL_TREE\n-\t      || ! INTEGRAL_TYPE_P (tmp) || TYPE_PRECISION (tmp) > 32)\n-\t    VERIFICATION_ERROR (\"invalid local variable type in iinc\");\n-\t  break;\n-\n-\tcase OPCODE_i2l:\n-\t  pop_type (int_type_node);    PUSH_TYPE (long_type_node);   break;\n-\tcase OPCODE_i2f:\n-\t  pop_type (int_type_node);    PUSH_TYPE (float_type_node);  break;\n-\tcase OPCODE_i2d:\n-\t  pop_type (int_type_node);    PUSH_TYPE (double_type_node); break;\n-\tcase OPCODE_l2i:\n-\t  pop_type (long_type_node);   PUSH_TYPE (int_type_node);    break;\n-\tcase OPCODE_l2f:\n-\t  pop_type (long_type_node);   PUSH_TYPE (float_type_node);  break;\n-\tcase OPCODE_l2d:\n-\t  pop_type (long_type_node);   PUSH_TYPE (double_type_node); break;\n-\tcase OPCODE_f2i:\n-\t  pop_type (float_type_node);  PUSH_TYPE (int_type_node);    break;\n-\tcase OPCODE_f2l:\n-\t  pop_type (float_type_node);  PUSH_TYPE (long_type_node);   break;\n-\tcase OPCODE_f2d:\n-\t  pop_type (float_type_node);  PUSH_TYPE (double_type_node); break;\n-\tcase OPCODE_d2i:\n-\t  pop_type (double_type_node); PUSH_TYPE (int_type_node);    break;\n-\tcase OPCODE_d2l:\n-\t  pop_type (double_type_node); PUSH_TYPE (long_type_node);   break;\n-\tcase OPCODE_d2f:\n-\t  pop_type (double_type_node); PUSH_TYPE (float_type_node);  break;\n-\n-\tcase OPCODE_lcmp:\n-\t  type = long_type_node;  goto compare;\n-\tcase OPCODE_fcmpl:\n-\tcase OPCODE_fcmpg:\n-\t  type = float_type_node;  goto compare;\n-\tcase OPCODE_dcmpl:\n-\tcase OPCODE_dcmpg:\n-\t  type = double_type_node;  goto compare;\n-\tcompare:\n-\t  pop_type (type);  pop_type (type);\n-\t  PUSH_TYPE (int_type_node);  break;\n-\n-\tcase OPCODE_ifeq:\n-\tcase OPCODE_ifne:\n-\tcase OPCODE_iflt:\n-\tcase OPCODE_ifge:\n-\tcase OPCODE_ifgt:\n-\tcase OPCODE_ifle:\n-\t  pop_type (int_type_node);  goto cond;\n-\tcase OPCODE_ifnull:\n-\tcase OPCODE_ifnonnull:\n-\t  pop_type (ptr_type_node ); goto cond;\n-\tcase OPCODE_if_icmpeq:\n-\tcase OPCODE_if_icmpne:\n-\tcase OPCODE_if_icmplt:\n-\tcase OPCODE_if_icmpge:\n-\tcase OPCODE_if_icmpgt:\n-\tcase OPCODE_if_icmple:\n-\t  pop_type (int_type_node);  pop_type (int_type_node);  goto cond;\n-\tcase OPCODE_if_acmpeq:\n-\tcase OPCODE_if_acmpne:\n-\t  pop_type (object_ptr_type_node);  pop_type (object_ptr_type_node);\n-\t  goto cond;\n-\n-\tcond:\n-\t  PUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s2));\n-\t  break;\n-          \n-\tcase OPCODE_goto:\n-\t  PUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s2));\n-\t  INVALIDATE_PC;\n-\t  break;\n-\n-\tcase OPCODE_wide:\n-\t  switch (byte_ops[PC])\n-\t    {\n-\t    case OPCODE_iload:  case OPCODE_lload:\n-\t    case OPCODE_fload:  case OPCODE_dload:  case OPCODE_aload:\n-\t    case OPCODE_istore:  case OPCODE_lstore:\n-\t    case OPCODE_fstore:  case OPCODE_dstore:  case OPCODE_astore:\n-\t    case OPCODE_iinc:\n-\t    case OPCODE_ret:\n-\t      wide = 1;\n-\t      break;\n-\t    default:\n-\t      VERIFICATION_ERROR (\"invalid use of wide instruction\");\n-\t    }\n-\t  break;\n-\n-\tcase OPCODE_return:   type = void_type_node;   goto ret;\n-\tcase OPCODE_ireturn:\n-\t  if ((TREE_CODE (return_type) == BOOLEAN_TYPE\n-\t       || TREE_CODE (return_type) == CHAR_TYPE\n-\t       || TREE_CODE (return_type) == INTEGER_TYPE)\n-\t      && TYPE_PRECISION (return_type) <= 32)\n-\t    type = return_type;\n-\t  else\n-\t    type = NULL_TREE;\n-\t  goto ret;\n-\tcase OPCODE_lreturn:  type = long_type_node;   goto ret;\n-\tcase OPCODE_freturn:  type = float_type_node;  goto ret;\n-\tcase OPCODE_dreturn:  type = double_type_node; goto ret;\n-\tcase OPCODE_areturn:\n-\t  if (TREE_CODE (return_type) == POINTER_TYPE)\n-\t    type = return_type;\n-\t  else\n-\t    type = NULL_TREE;\n-\t  goto ret;\n-\n-\tret:\n-\t  if (type != return_type)\n-\t    VERIFICATION_ERROR (\"incorrect ?return opcode\");\n-\t  if (type != void_type_node)\n-\t    POP_TYPE (type, \"return value has wrong type\");\n-\t  INVALIDATE_PC;\n-\t  break;\n-\n-\tcase OPCODE_getstatic: is_putting = 0;  is_static = 1;  goto field;\n-\tcase OPCODE_putstatic: is_putting = 1;  is_static = 1;  goto field;\n-\tcase OPCODE_getfield:  is_putting = 0;  is_static = 0;  goto field;\n-\tcase OPCODE_putfield:  is_putting = 1;  is_static = 0;  goto field;\n-\tfield:\n-\t  {\n-\t    tree field_signature, field_type;\n-\t    index = IMMEDIATE_u2;\n-\n-\t    if (index <= 0 || index >= JPOOL_SIZE (current_jcf))\n-\t      VERIFICATION_ERROR_WITH_INDEX (\"bad constant pool index %d\");\n-\n-\t    if (JPOOL_TAG (current_jcf, index) != CONSTANT_Fieldref)\n-\t      VERIFICATION_ERROR\n-\t\t(\"field instruction does not reference a Fieldref\");\n-\n-\t    field_signature\n-              = COMPONENT_REF_SIGNATURE (&current_jcf->cpool, index);\n-\n-\t    field_type = get_type_from_signature (field_signature);\n-\n-\t    if (is_putting)\n-\t      POP_TYPE (field_type, \"incorrect type for field\");\n-\n-\t    if (! is_static)\n-\t      {\n-\t\tint clindex\n-                  = COMPONENT_REF_CLASS_INDEX (&current_jcf->cpool, index);\n-\n-\t\ttree self_type = get_class_constant (current_jcf, clindex);\n-\n-\t\t/* Defer actual checking until next pass. */\n-\t\tPOP_TYPE (self_type, \"incorrect type for field reference\");\n-\t      }\n-\n-\t    if (! is_putting)\n-\t      PUSH_TYPE (field_type);\n-\t    break;\n-\t  }\n-\n-\tcase OPCODE_new:\n-\t  PUSH_TYPE (get_class_constant (jcf, IMMEDIATE_u2));\n-\t  break;\n-\n-\tcase OPCODE_dup:     wide = 1; index = 0;  goto dup;\n-\tcase OPCODE_dup_x1:  wide = 1; index = 1;  goto dup;\n-\tcase OPCODE_dup_x2:  wide = 1; index = 2;  goto dup;\n-\tcase OPCODE_dup2:    wide = 2; index = 0;  goto dup;\n-\tcase OPCODE_dup2_x1: wide = 2; index = 1;  goto dup;\n-\tcase OPCODE_dup2_x2: wide = 2; index = 2;  goto dup;\n-\n-\tdup:\n-\t  if (wide + index > stack_pointer)\n-\t    VERIFICATION_ERROR (\"stack underflow - dup* operation\");\n-\t  type_stack_dup (wide, index);\n-\t  wide = 0;\n-\t  break;\n-\n-\tcase OPCODE_pop:  index = 1;  goto pop;\n-\tcase OPCODE_pop2: index = 2;  goto pop;\n-\n-\tpop:\n-\t  if (stack_pointer < index)\n-\t    VERIFICATION_ERROR (\"stack underflow\");\n-\t  stack_pointer -= index;\n-\t  break;\n-\n-\tcase OPCODE_swap:\n-\t  if (stack_pointer < 2)\n-\t    VERIFICATION_ERROR (\"stack underflow (in swap)\");\n-\t  else\n-\t    {\n-\t      tree type1 = stack_type_map[stack_pointer - 1];\n-\t      tree type2 = stack_type_map[stack_pointer - 2];\n-\n-\t      if (type1 == void_type_node || type2 == void_type_node)\n-\t\tVERIFICATION_ERROR (\"verifier (swap):  double or long value\");\n-\n-\t      stack_type_map[stack_pointer - 2] = type1;\n-\t      stack_type_map[stack_pointer - 1] = type2;\n-\t    }\n-\t  break;\n-\n-\tcase OPCODE_ldc:   index = IMMEDIATE_u1;  goto ldc;\n-\tcase OPCODE_ldc2_w:\n-\tcase OPCODE_ldc_w:\n-\t  index = IMMEDIATE_u2;  goto ldc;\n-\n-\tldc:\n-\t  if (index <= 0 || index >= JPOOL_SIZE (current_jcf))\n-\t    VERIFICATION_ERROR_WITH_INDEX (\"bad constant pool index %d in ldc\");\n-\n-\t  int_value = -1;\n-\t  switch (JPOOL_TAG (current_jcf, index) & ~CONSTANT_ResolvedFlag)\n-\t    {\n-\t    case CONSTANT_Integer:  type = int_type_node;  goto check_ldc;\n-\t    case CONSTANT_Float:    type = float_type_node;  goto check_ldc;\n-\t    case CONSTANT_String:   type = string_type_node; goto check_ldc;\n-\t    case CONSTANT_Long:    type = long_type_node;    goto check_ldc;\n-\t    case CONSTANT_Double:  type = double_type_node;  goto check_ldc;\n-\t    check_ldc:\n-\t      if (TYPE_IS_WIDE (type) == (op_code == OPCODE_ldc2_w))\n-\t\tbreak;\n-\t      /* ... else fall through ... */\n-\t    default:\n-\t      VERIFICATION_ERROR (\"bad constant pool tag in ldc\");\n-\t    }\n-\t  if (type == int_type_node)\n-\t    {\n-\t      i = TREE_INT_CST_LOW (get_constant (current_jcf, index));\n-\t      goto push_int;\n-\t    }\n-\t  PUSH_TYPE (type);\n-\t  break;\n-\n-\tcase OPCODE_invokevirtual:\n-\tcase OPCODE_invokespecial:\n-\tcase OPCODE_invokestatic:\n-\tcase OPCODE_invokeinterface:\n-\t  {\n-\t    tree sig, method_name, method_type, self_type;\n-\t    int self_is_interface, tag;\n-\t    index = IMMEDIATE_u2;\n-\n-\t    if (index <= 0 || index >= JPOOL_SIZE (current_jcf))\n-\t      VERIFICATION_ERROR_WITH_INDEX\n-\t\t(\"bad constant pool index %d for invoke\");\n-\n-\t    tag = JPOOL_TAG (current_jcf, index);\n-\n-\t    if (op_code == OPCODE_invokeinterface)\n-\t      {\n-\t\tif (tag != CONSTANT_InterfaceMethodref)\n-\t\t  VERIFICATION_ERROR\n-\t\t    (\"invokeinterface does not reference an InterfaceMethodref\");\n-\t      }\n-\t    else\n-\t      {\n-\t\tif (tag != CONSTANT_Methodref)\n-\t\t  VERIFICATION_ERROR (\"invoke does not reference a Methodref\");\n-\t      }\n-\n-\t    sig = COMPONENT_REF_SIGNATURE (&current_jcf->cpool, index);\n-\n-\t    self_type\n-              = get_class_constant (current_jcf,\n-                                    COMPONENT_REF_CLASS_INDEX\n-                                      (&current_jcf->cpool, index));\n-\n-\t    if (! CLASS_LOADED_P (self_type))\n-\t      load_class (self_type, 1);\n-\n-\t    self_is_interface = CLASS_INTERFACE (TYPE_NAME (self_type));\n-\t    method_name = COMPONENT_REF_NAME (&current_jcf->cpool, index);\n-\t    method_type = parse_signature_string ((const unsigned char *) IDENTIFIER_POINTER (sig),\n-\t\t\t\t\t\t  IDENTIFIER_LENGTH (sig));\n-\n-\t    if (TREE_CODE (method_type) != FUNCTION_TYPE)\n-\t      VERIFICATION_ERROR (\"bad method signature\");\n-\n-\t    pmessage = pop_argument_types (TYPE_ARG_TYPES (method_type));\n-\t    if (pmessage != NULL)\n-\t      {\n-\t\tmessage = \"invalid argument type\";\n-\t\tgoto pop_type_error;\n-\t      }\n-\n-\t    /* Can't invoke <clinit>.  */\n-\t    if (ID_CLINIT_P (method_name))\n-\t      VERIFICATION_ERROR (\"invoke opcode can't invoke <clinit>\");\n-\n-\t    /* Apart from invokespecial, can't invoke <init>.  */\n-\t    if (op_code != OPCODE_invokespecial && ID_INIT_P (method_name))\n-\t      VERIFICATION_ERROR (\"invoke opcode can't invoke <init>\");\n-\n-\t    if (op_code != OPCODE_invokestatic)\n-\t      POP_TYPE (self_type,\n-\t\t\t\"stack type not subclass of invoked method's class\");\n-\n-\t    switch (op_code)\n-\t      {\n-\t      case OPCODE_invokeinterface:\n-\t        {\n-\t\t  int nargs    = IMMEDIATE_u1;\n-\t\t  int notZero  = IMMEDIATE_u1;\n-\t\t\n-\t\t  if (!nargs || notZero)\n-\t\t      VERIFICATION_ERROR \n-\t\t        (\"invalid argument number in invokeinterface\");\n-\n-\t\t  /* If we verify/resolve the constant pool, as we should,\n-\t\t     this test (and the one just following) are redundant.  */\n-\t\t  if (! self_is_interface)\n-\t\t    VERIFICATION_ERROR\n-                      (\"invokeinterface calls method not in interface\");\n-\t\t  break;\n-\n-\t\tdefault:\n-\t\t  if (self_is_interface)\n-\t\t    VERIFICATION_ERROR (\"method in interface called\");\n-\t\t}\n-\t      }\n-\n-\t    if (TREE_TYPE (method_type) != void_type_node)\n-\t      PUSH_TYPE (TREE_TYPE (method_type));\n-\t    break;\n-\t  }\n-\n-\tcase OPCODE_arraylength:\n-\t    /* Type checking actually made during code generation.  */\n-\t    pop_type (ptr_type_node);\n-\t    PUSH_TYPE (int_type_node);\n-\t    break;\n-\t    \n-        /* Q&D verification *or* more checking done during code generation\n-\t   for byte/boolean/char/short, the value popped is a int coerced\n-\t   into the right type before being stored.  */\n-\tcase OPCODE_iastore: type = int_type_node;     goto astore;\n-\tcase OPCODE_lastore: type = long_type_node;    goto astore;\n-\tcase OPCODE_fastore: type = float_type_node;   goto astore;\n-\tcase OPCODE_dastore: type = double_type_node;  goto astore;\n-\tcase OPCODE_aastore: type = ptr_type_node;     goto astore;\n-\tcase OPCODE_bastore: type = int_type_node; goto astore;\n-\tcase OPCODE_castore: type = int_type_node; goto astore;\n-\tcase OPCODE_sastore: type = int_type_node; goto astore;\n-\n-\tastore:\n-\t  /* FIXME - need better verification here.  */\n-\t  pop_type (type);\t     /* new value */\n-\t  pop_type (int_type_node);  /* index */\n-\t  pop_type (ptr_type_node);  /* array */\n-\t  break;\n-\n-        /* Q&D verification *or* more checking done during code generation\n-\t   for byte/boolean/char/short, the value pushed is a int.  */\n-\tcase OPCODE_iaload: type = int_type_node;     goto aload;\n-\tcase OPCODE_laload: type = long_type_node;    goto aload;\n-\tcase OPCODE_faload: type = float_type_node;   goto aload;\n-\tcase OPCODE_daload: type = double_type_node;  goto aload;\n-\tcase OPCODE_aaload: type = ptr_type_node;     goto aload;\n-\tcase OPCODE_baload: type = promote_type (byte_type_node);  goto aload;\n-\tcase OPCODE_caload: type = promote_type (char_type_node);  goto aload;\n-\tcase OPCODE_saload: type = promote_type (short_type_node); goto aload;\n-\n-        aload:\n-\t  pop_type (int_type_node);\n-\t  tmp = pop_type (ptr_type_node);\n-\t  if (is_array_type_p (tmp))\n-\t    type = TYPE_ARRAY_ELEMENT (TREE_TYPE (tmp));\n-\t  else if (tmp != TYPE_NULL)\n-\t    VERIFICATION_ERROR (\"array load from non-array type\");\n-\t  PUSH_TYPE (type);\n-\t  break;\n-\n-\tcase OPCODE_anewarray:\n-\t  type = get_class_constant (current_jcf, IMMEDIATE_u2);\n-\t  type = promote_type (type);\n-\t  goto newarray;\n-\n-\tcase OPCODE_newarray:\n-\t  index = IMMEDIATE_u1;\n-\t  type = decode_newarray_type (index);\n-\t  if (type == NULL_TREE)\n-\t    VERIFICATION_ERROR (\"invalid type code in newarray opcode\");\n-\t  goto newarray;\n-\n-\tnewarray:\n-\t  if (int_value >= 0 && prevpc >= 0)\n-\t    {\n-\t      /* If the previous instruction pushed an int constant,\n-\t\t we want to use it. */\n-\t      switch (byte_ops[prevpc])\n-\t\t{\n-\t\tcase OPCODE_iconst_0: case OPCODE_iconst_1:\n-\t\tcase OPCODE_iconst_2: case OPCODE_iconst_3:\n-\t\tcase OPCODE_iconst_4: case OPCODE_iconst_5:\n-\t\tcase OPCODE_bipush:  case OPCODE_sipush:\n-\t\tcase OPCODE_ldc: case OPCODE_ldc_w:\n-\t\t  break;\n-\t\tdefault:\n-\t\t  int_value = -1;\n-\t\t}\n-\t    }\n-\t  else\n-\t    int_value = -1;\n-\n-\t  type = build_java_array_type (type, int_value);\n-\t  pop_type (int_type_node);\n-\t  PUSH_TYPE (type);\n-\t  break;\n-\n-\tcase OPCODE_multianewarray:\n-\t  {\n-\t    int ndim, i;\n-\t    index = IMMEDIATE_u2;\n-\t    ndim  = IMMEDIATE_u1;\n-\n-            if (ndim < 1)\n-              VERIFICATION_ERROR\n-                (\"number of dimension lower that 1 in multianewarray\" );\n-\n-\t    for (i = 0; i < ndim; i++)\n-\t      pop_type (int_type_node);\n-\n-\t    PUSH_TYPE (get_class_constant (current_jcf, index));\n-\t    break;\n-\t  }\n-\n-\tcase OPCODE_aconst_null:\n-\t  PUSH_TYPE (ptr_type_node);\n-\t  break;\n-\n-\tcase OPCODE_athrow:\n-\t  /* FIXME: athrow also empties the stack.  */\n-\t  POP_TYPE (throwable_type_node, \"missing throwable at athrow\" );\n-\t  INVALIDATE_PC;\n-\t  break;\n-\n-\tcase OPCODE_checkcast:\n-\t  POP_TYPE (object_ptr_type_node,\n-\t\t    \"checkcast operand is not a pointer\");\n-\t  type = get_class_constant (current_jcf, IMMEDIATE_u2);\n-\t  PUSH_TYPE (type);\n-\t  break;\n-\n-\tcase OPCODE_instanceof:\n-\t  POP_TYPE (object_ptr_type_node,\n-\t\t    \"instanceof operand is not a pointer\");\n-\t  get_class_constant (current_jcf, IMMEDIATE_u2);\n-\t  PUSH_TYPE (int_type_node);\n-\t  break;\n-\n-\tcase OPCODE_tableswitch:\n-\t  {\n-\t    jint low, high;\n-\n-\t    POP_TYPE (int_type_node, \"missing int for tableswitch\");\n-\n-\t    while (PC%4)\n-\t      {\n-\t        if (byte_ops[PC++])\n-\t\t  VERIFICATION_ERROR (\"bad alignment in tableswitch pad\");\n-\t      }\n-\n-\t    PUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s4));\n-\t    low  = IMMEDIATE_s4;\n-\t    high = IMMEDIATE_s4;\n-\n-\t    if (low > high)\n-\t      VERIFICATION_ERROR (\"unsorted low/high value in tableswitch\");\n-\n-\t    while (low++ <= high)\n-\t      PUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s4));\n-\n-\t    INVALIDATE_PC;\n-\t    break;\n-\t  }\n-\n-\tcase OPCODE_lookupswitch:\n-\t  {\n-\t    jint npairs, last = 0, not_registered = 1;\n-\n-\t    POP_TYPE (int_type_node, \"missing int for lookupswitch\");\n-\n-\t    while (PC%4)\n-\t      {\n-\t        if (byte_ops[PC++])\n-\t\t  VERIFICATION_ERROR (\"bad alignment in lookupswitch pad\");\n-\t      }\n-\n-\t    PUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s4));\n-\t    npairs = IMMEDIATE_s4;\n-\t    \n-\t    if (npairs < 0)\n-\t      VERIFICATION_ERROR (\"invalid number of targets in lookupswitch\");\n-\n-\t    while (npairs--)\n-\t      {\n-\t        int match = IMMEDIATE_s4;\n-\n-\t\tif (not_registered)\n-\t\t  not_registered = 0;\n-\t\telse if (last >= match)\n-\t\t  VERIFICATION_ERROR (\"unsorted match value in lookupswitch\");\n-\n-\t\tlast = match;\n-\t\tPUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s4));\n-\t      }\n-\t    INVALIDATE_PC;\n-\t    break;\n-\t  }\n-\n-\tcase OPCODE_monitorenter: \n-\t  /* fall thru */\n-\tcase OPCODE_monitorexit:\n-\t  pop_type (ptr_type_node);\n-\t  break;\n-\n-\tcase OPCODE_goto_w:\n-\t  PUSH_PENDING (lookup_label (oldpc + IMMEDIATE_s4));\n-\t  INVALIDATE_PC;\n-\t  break;\n-\n-\tcase OPCODE_jsr:\n-\t  {\n-\t    tree target = lookup_label (oldpc + IMMEDIATE_s2);\n-\t    tree return_label = lookup_label (PC);\n-\t    PUSH_TYPE (return_address_type_node);\n-\t    /* The return label chain will be null if this is the first\n-\t       time we've seen this jsr target.  */\n-            if (LABEL_RETURN_LABEL (target) == NULL_TREE)\n-\t      {\n-\t\ttree return_type_map;\n-\t\tint nlocals = DECL_MAX_LOCALS (current_function_decl);\n-\t\tindex = nlocals + DECL_MAX_STACK (current_function_decl);\n-\t\treturn_type_map = make_tree_vec (index);\n-\n-\t\twhile (index > nlocals)\n-\t\t  TREE_VEC_ELT (return_type_map, --index) = TYPE_UNKNOWN;\n-\n-\t\twhile (index > 0)\n-\t\t  TREE_VEC_ELT (return_type_map, --index) = TYPE_UNUSED;\n-\n-\t\tLABEL_RETURN_LABEL (target)\n-\t\t  = build_decl (LABEL_DECL, NULL_TREE, TREE_TYPE (target));\n-\t\tLABEL_PC (LABEL_RETURN_LABEL (target)) = INVALID_PC;\n-\t\tLABEL_RETURN_TYPE_STATE (target) = return_type_map;\n-\t\tLABEL_IS_SUBR_START (target) = 1;\n-\t\tLABEL_IN_SUBR (target) = 1;\n-\t\tLABEL_SUBR_START (target) = target;\n-\t\tLABEL_SUBR_CONTEXT (target) = current_subr;\n-\t      }\n-\t    else if (! LABEL_IS_SUBR_START (target)\n-\t\t     || LABEL_SUBR_CONTEXT (target) != current_subr)\n-\t      VERIFICATION_ERROR (\"label part of different subroutines\");\n-\n-\t    i = merge_type_state (target);\n-\t    if (i != 0)\n-\t      {\n-\t\tif (i < 0)\n-\t\t  VERIFICATION_ERROR (\"types could not be merged at jsr\");\n-\t\tpush_pending_label (target);\n-\t      }\n-\t    current_subr = target;\n-\n-\t    /* Chain return_pc onto LABEL_RETURN_LABELS (target) if needed. */\n-\t    if (! value_member (return_label, LABEL_RETURN_LABELS (target)))\n-\t      {\n-\t\tLABEL_RETURN_LABELS (target)\n-\t\t  = tree_cons (NULL_TREE, return_label,\n-\t\t\t       LABEL_RETURN_LABELS (target));\n-\t      }\n-\n-\t    if (LABEL_VERIFIED (target))\n-\t      {\n-\t\ttree return_map = LABEL_RETURN_TYPE_STATE (target);\n-\t\tint len = TREE_VEC_LENGTH (return_map);\n-\t\tstack_pointer = len - DECL_MAX_LOCALS (current_function_decl);\n-\t\twhile (--len >= 0)\n-\t\t  {\n-\t\t    if (TREE_VEC_ELT (return_map, len) != TYPE_UNUSED)\n-\t\t      type_map[len] = TREE_VEC_ELT (return_map, len);\n-\t\t  }\n-\t\tcurrent_subr = LABEL_SUBR_CONTEXT (target);\n-\t\tif (RETURN_MAP_ADJUSTED (return_map))\n-\t\t  PUSH_PENDING (return_label);\n-\t      }\n-\n-\t    INVALIDATE_PC;\n-\t  }\n-\t  break;\n-\n-\tcase OPCODE_ret:\n-\t  if (current_subr == NULL_TREE)\n-\t    VERIFICATION_ERROR (\"ret instruction not in a jsr subroutine\");\n-\t  else\n-\t    {\n-\t      tree ret_map = LABEL_RETURN_TYPE_STATE (current_subr);\n-\t      int size\n-                = DECL_MAX_LOCALS (current_function_decl) + stack_pointer;\n-\t      index = wide ? IMMEDIATE_u2 : IMMEDIATE_u1;\n-\t      wide = 0;\n-\t      INVALIDATE_PC;\n-\t      if (index < 0 || index >= DECL_MAX_LOCALS (current_function_decl)\n-\t\t  || type_map[index] != TYPE_RETURN_ADDR)\n-\t\tVERIFICATION_ERROR (\"invalid ret index\");\n-\n-\t      /* The next chunk of code is similar to an inlined version of\n-               merge_type_state (LABEL_RETURN_LABEL (current_subr)).\n-\t       The main differences are that LABEL_RETURN_LABEL is\n-\t       pre-allocated by the jsr (but we don't know the size then);\n-\t       and that we have to handle TYPE_UNUSED.  */\n-\n-\t      if (! RETURN_MAP_ADJUSTED (ret_map))\n-\t\t{\n-                  /* First return from this subroutine - fix stack\n-                  pointer.  */\n-\t\t  TREE_VEC_LENGTH (ret_map) = size;\n-\t\t  for (index = size;  --index >= 0; )\n-\t\t    {\n-\t\t      if (TREE_VEC_ELT (ret_map, index) != TYPE_UNUSED)\n-\t\t\tTREE_VEC_ELT (ret_map, index) = type_map[index];\n-\t\t    }\n-\t\t  RETURN_MAP_ADJUSTED (ret_map) = 1;\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  if (TREE_VEC_LENGTH (ret_map) != size)\n-\t\t    VERIFICATION_ERROR (\"inconsistent stack size on ret\");\n-\t\t  for (index = 0;  index < size;  index++)\n-\t\t    {\n-\t\t      tree type = TREE_VEC_ELT (ret_map, index);\n-\t\t      if (type != TYPE_UNUSED)\n-\t\t\t{\n-\t\t\t  type = merge_types (type, type_map[index]);\n-\t\t\t  TREE_VEC_ELT (ret_map, index) = type;\n-\t\t\t  if (type == TYPE_UNKNOWN)\n-\t\t\t    {\n-\t\t\t      if (index >= size - stack_pointer)\n-\t\t\t\tVERIFICATION_ERROR\n-\t\t\t\t  (\"inconsistent types on ret from jsr\");\n-\t\t\t    }\n-\t\t\t  else if (TYPE_IS_WIDE (type))\n-\t\t\t    index++;\n-\t\t\t}\n-\t\t    }\n-\t\t}\n-            }\n-          break;\n-\n-        case OPCODE_jsr_w:        \n-        case OPCODE_ret_w:\n-        default:\n-          error (\"unknown opcode %d@pc=%d during verification\", op_code, PC-1);\n-          return 0;\n-        }\n-\n-      prevpc = oldpc;\n-\n-      /* The following test is true if we have entered or exited an exception\n-\t handler range *or* we have done a store to a local variable.\n-\t In either case we need to consider any exception handlers that\n-\t might \"follow\" this instruction.  */\n-\n-      if (eh_ranges != prev_eh_ranges)\n-\t{\n-\t  int save_stack_pointer = stack_pointer;\n-\t  int index = DECL_MAX_LOCALS (current_function_decl);\n-\t  tree save_type = type_map[index];\n-\t  tree save_current_subr = current_subr;\n-\t  struct eh_range *ranges = find_handler (oldpc);\n-\t  stack_pointer = 1;\n-\n-\t  for ( ; ranges != NULL_EH_RANGE; ranges = ranges->outer)\n-\t    {\n-\t      tree chain = ranges->handlers;\n-\n-\t      /* We need to determine if the handler is part of current_subr.\n-\t\t The are two cases:  (1) The exception catch range\n-\t\t is entirely within current_subr.  In that case the handler\n-\t\t is also part of current_subr.\n-\t\t (2) Some of the catch range is not in current_subr.\n-\t\t In that case, the handler is *not* part of current_subr.\n-\n-\t\t Figuring out which is the case is not necessarily obvious,\n-\t\t in the presence of clever code generators (and obfuscators).\n-\t\t We make a simplifying assumption that in case (2) we\n-\t\t have that the current_subr is entirely within the catch range.\n-\t\t In that case we can assume if that if a caller (the jsr) of\n-\t\t a subroutine is within the catch range, then the handler is\n-\t\t *not* part of the subroutine, and vice versa.  */\n-\n-\t      current_subr = save_current_subr;\n-\t      for ( ; current_subr != NULL_TREE;\n-\t\t    current_subr = LABEL_SUBR_CONTEXT (current_subr))\n-\t\t{\n-\t\t  tree return_labels = LABEL_RETURN_LABELS (current_subr);\n-\t\t  /* There could be multiple return_labels, but\n-\t\t     we only need to check one.  */\n-\t\t  int return_pc = LABEL_PC (TREE_VALUE (return_labels));\n-\t\t  if (return_pc <= ranges->start_pc\n-\t\t      || return_pc > ranges->end_pc)\n-\t\t    break;\n-\t\t}\n-\n-\t      for ( ; chain != NULL_TREE; chain = TREE_CHAIN (chain))\n-\t\t{\n-\t\t  tree handler = TREE_VALUE (chain);\n-\t\t  tree type = TREE_PURPOSE (chain);\n-\n-\t\t  if (type == NULL_TREE)  /* a finally handler */\n-\t\t    type = throwable_type_node;\n-\n-\t\t  type_map[index] = promote_type (type);\n-\n-\t\t  PUSH_PENDING (handler);\n-\t\t}\n-\t    }\n-\t  stack_pointer = save_stack_pointer;\n-\t  current_subr = save_current_subr;\n-\t  type_map[index] = save_type;\n-\t  prev_eh_ranges = eh_ranges;\n-\t}\n-    }\n-\n-  return 1;\n-\n- pop_type_error:\n-  error (\"verification error at PC=%d\", oldpc);\n-  if (message != NULL)\n-    error (\"%s\", message);\n-  error (\"%s\", pmessage);\n-  free (pmessage);\n-  return 0;\n-\n- stack_overflow:\n-  message = \"stack overflow\";\n-  goto verify_error;\n-\n- bad_pc:\n-  message = \"program counter out of range\";\n-  goto verify_error;\n-\n- error_with_index:\n-  error (\"verification error at PC=%d\", oldpc);\n-  error (message, index);\n-  return 0;\n-\n- verify_error:\n-  error (\"verification error at PC=%d\", oldpc);\n-  error (\"%s\", message);\n-  return 0;\n-}"}]}