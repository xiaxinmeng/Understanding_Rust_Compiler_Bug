{"sha": "1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTY5NDkwNzIzOGViMTA2YmY3YWMwZTRlYWVkYWE3N2JjNzcxOWI2ZA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-11-04T10:56:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-11-04T10:56:22Z"}, "message": "tree.def (FMA_EXPR): New tree code.\n\n2010-11-04  Richard Guenther  <rguenther@suse.de>\n\tRichard Henderson  <rth@redhat.com>\n\n\t* tree.def (FMA_EXPR): New tree code.\n\t* expr.c (expand_expr_real_2): Add FMA_EXPR expansion code.\n\t* gimple.c (gimple_rhs_class_table): FMA_EXPR is a GIMPLE_TERNARY_RHS.\n\t* tree-cfg.c (verify_gimple_assign_ternary): Verify FMA_EXPR types.\n\t* tree-inline.c (estimate_operator_cost): Handle FMA_EXPR.\n\t* gimple-pretty-print.c (dump_ternary_rhs): Likewise.\n\t* tree-ssa-math-opts.c (convert_mult_to_fma): New function.\n\t(execute_optimize_widening_mul): Call it.  Reorganize to allow\n\tdead stmt removal.  Move TODO flags ...\n\t(pass_optimize_widening_mul): ... here.\n\t* flag-types.h (enum fp_contract_mode): New enum.\n\t* common.opt (flag_fp_contract_mode): New variable.\n\t(-ffp-contract): New option.\n\t* opts.c (common_handle_option): Handle it.\n\t* doc/invoke.texi (-ffp-contract): Document.\n\t* tree.h (fold_fma): Declare.\n\t* builtins.c (fold_fma): New function.\n\t(fold_builtin_fma): Likewise.\n\t(fold_builtin_3): Call it for fma.\n\t* fold-const.c (fold_ternary_loc): Fold FMA_EXPR.\n\t* optabs.c (optab_for_tree_code): Handle FMA_EXPR.\n\t* config/i386/sse.md (fms<mode>4, fnma<mode>, fnms<mode>4):\n\tNew expanders.\n\t* doc/md.texi (fms<mode>4, fnma<mode>, fnms<mode>4): Document new\n\tnamed patterns.\n\t* genopinit.c (optabs): Initialize fms_optab, fnma_optab and fnms_optab.\n\t* optabs.h (enum optab_index): Add OTI_fms, OTI_fnma and OTI_fnms.\n\t(fms_optab, fnma_optab, fnms_optab): New defines.\n\t* gimplify.c (gimplify_expr): Handle binary truth expressions\n\texplicitly.  Handle FMA_EXPR.\n\t* tree-vect-stmts.c (vectorizable_operation): Handle ternary\n\toperations.\n\n\t* gcc.target/i386/fma4-vector-2.c: New testcase.\n\nCo-Authored-By: Richard Henderson <rth@redhat.com>\n\nFrom-SVN: r166304", "tree": {"sha": "5b089e25b51a9c3914b5055c84f8d83414072dab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b089e25b51a9c3914b5055c84f8d83414072dab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "47853c73001ded810bfe6e4ca7f7ef34be600681", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47853c73001ded810bfe6e4ca7f7ef34be600681", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47853c73001ded810bfe6e4ca7f7ef34be600681"}], "stats": {"total": 566, "additions": 524, "deletions": 42}, "files": [{"sha": "7a3cdb0535cdc4205cc195b9ccf11d70c302ec61", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -1,3 +1,39 @@\n+2010-11-04  Richard Guenther  <rguenther@suse.de>\n+\tRichard Henderson  <rth@redhat.com>\n+\n+\t* tree.def (FMA_EXPR): New tree code.\n+\t* expr.c (expand_expr_real_2): Add FMA_EXPR expansion code.\n+\t* gimple.c (gimple_rhs_class_table): FMA_EXPR is a GIMPLE_TERNARY_RHS.\n+\t* tree-cfg.c (verify_gimple_assign_ternary): Verify FMA_EXPR types.\n+\t* tree-inline.c (estimate_operator_cost): Handle FMA_EXPR.\n+\t* gimple-pretty-print.c (dump_ternary_rhs): Likewise.\n+\t* tree-ssa-math-opts.c (convert_mult_to_fma): New function.\n+\t(execute_optimize_widening_mul): Call it.  Reorganize to allow\n+\tdead stmt removal.  Move TODO flags ...\n+\t(pass_optimize_widening_mul): ... here.\n+\t* flag-types.h (enum fp_contract_mode): New enum.\n+\t* common.opt (flag_fp_contract_mode): New variable.\n+\t(-ffp-contract): New option.\n+\t* opts.c (common_handle_option): Handle it.\n+\t* doc/invoke.texi (-ffp-contract): Document.\n+\t* tree.h (fold_fma): Declare.\n+\t* builtins.c (fold_fma): New function.\n+\t(fold_builtin_fma): Likewise.\n+\t(fold_builtin_3): Call it for fma.\n+\t* fold-const.c (fold_ternary_loc): Fold FMA_EXPR.\n+\t* optabs.c (optab_for_tree_code): Handle FMA_EXPR.\n+\t* config/i386/sse.md (fms<mode>4, fnma<mode>, fnms<mode>4):\n+\tNew expanders.\n+\t* doc/md.texi (fms<mode>4, fnma<mode>, fnms<mode>4): Document new\n+\tnamed patterns.\n+\t* genopinit.c (optabs): Initialize fms_optab, fnma_optab and fnms_optab.\n+\t* optabs.h (enum optab_index): Add OTI_fms, OTI_fnma and OTI_fnms.\n+\t(fms_optab, fnma_optab, fnms_optab): New defines.\n+\t* gimplify.c (gimplify_expr): Handle binary truth expressions\n+\texplicitly.  Handle FMA_EXPR.\n+\t* tree-vect-stmts.c (vectorizable_operation): Handle ternary\n+\toperations.\n+\n 2010-11-04  Artjoms Sinkarovs <artyom.shinakroff@gmail.com>\n \tRichard Guenther  <rguenther@suse.de>\n "}, {"sha": "e193791ccc76d69eb6c68474c92d79f3201ce1a6", "filename": "gcc/builtins.c", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -9266,6 +9266,40 @@ fold_builtin_abs (location_t loc, tree arg, tree type)\n   return fold_build1_loc (loc, ABS_EXPR, type, arg);\n }\n \n+/* Fold a fma operation with arguments ARG[012].  */\n+\n+tree\n+fold_fma (location_t loc ATTRIBUTE_UNUSED,\n+\t  tree type, tree arg0, tree arg1, tree arg2)\n+{\n+  if (TREE_CODE (arg0) == REAL_CST\n+      && TREE_CODE (arg1) == REAL_CST\n+      && TREE_CODE (arg2) == REAL_CST)\n+    return do_mpfr_arg3 (arg0, arg1, arg2, type, mpfr_fma);\n+\n+  return NULL_TREE;\n+}\n+\n+/* Fold a call to fma, fmaf, or fmal with arguments ARG[012].  */\n+\n+static tree\n+fold_builtin_fma (location_t loc, tree arg0, tree arg1, tree arg2, tree type)\n+{\n+  if (validate_arg (arg0, REAL_TYPE)\n+      && validate_arg(arg1, REAL_TYPE)\n+      && validate_arg(arg2, REAL_TYPE))\n+    {\n+      tree tem = fold_fma (loc, type, arg0, arg1, arg2);\n+      if (tem)\n+\treturn tem;\n+\n+      /* ??? Only expand to FMA_EXPR if it's directly supported.  */\n+      if (optab_handler (fma_optab, TYPE_MODE (type)) != CODE_FOR_nothing)\n+        return fold_build3_loc (loc, FMA_EXPR, type, arg0, arg1, arg2);\n+    }\n+  return NULL_TREE;\n+}\n+\n /* Fold a call to builtin fmin or fmax.  */\n \n static tree\n@@ -10540,10 +10574,7 @@ fold_builtin_3 (location_t loc, tree fndecl,\n       return fold_builtin_sincos (loc, arg0, arg1, arg2);\n \n     CASE_FLT_FN (BUILT_IN_FMA):\n-      if (validate_arg (arg0, REAL_TYPE)\n-\t  && validate_arg(arg1, REAL_TYPE)\n-\t  && validate_arg(arg2, REAL_TYPE))\n-\treturn do_mpfr_arg3 (arg0, arg1, arg2, type, mpfr_fma);\n+      return fold_builtin_fma (loc, arg0, arg1, arg2, type);\n     break;\n \n     CASE_FLT_FN (BUILT_IN_REMQUO):"}, {"sha": "551c3358f75e008663435e6d0383c6d78534830c", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -58,6 +58,10 @@ bool flag_warn_unused_result = false\n Variable\n int *param_values\n \n+; Floating-point contraction mode, fast by default.\n+Variable\n+enum fp_contract_mode flag_fp_contract_mode = FP_CONTRACT_FAST\n+\n ###\n Driver\n \n@@ -857,6 +861,10 @@ fforward-propagate\n Common Report Var(flag_forward_propagate) Optimization\n Perform a forward propagation pass on RTL\n \n+ffp-contract=\n+Common Joined RejectNegative\n+-ffp-contract=[off|on|fast] Perform floating-point expression contraction.\n+\n ; Nonzero means don't put addresses of constant functions in registers.\n ; Used for compiling the Unix kernel, where strange substitutions are\n ; done on the assembly output."}, {"sha": "717f7fe7c5bc131b06aecc0dc48732ea18c997e2", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 28, "deletions": 1, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -1859,7 +1859,7 @@\n \n ;; Intrinsic FMA operations.\n \n-;; The standard name for fma is only available with SSE math enabled.\n+;; The standard names for fma is only available with SSE math enabled.\n (define_expand \"fma<mode>4\"\n   [(set (match_operand:FMAMODE 0 \"register_operand\")\n \t(fma:FMAMODE\n@@ -1869,6 +1869,33 @@\n   \"(TARGET_FMA || TARGET_FMA4) && TARGET_SSE_MATH\"\n   \"\")\n \n+(define_expand \"fms<mode>4\"\n+  [(set (match_operand:FMAMODE 0 \"register_operand\")\n+\t(fma:FMAMODE\n+\t  (match_operand:FMAMODE 1 \"nonimmediate_operand\")\n+\t  (match_operand:FMAMODE 2 \"nonimmediate_operand\")\n+\t  (neg:FMAMODE (match_operand:FMAMODE 3 \"nonimmediate_operand\"))))]\n+  \"(TARGET_FMA || TARGET_FMA4) && TARGET_SSE_MATH\"\n+  \"\")\n+\n+(define_expand \"fnma<mode>4\"\n+  [(set (match_operand:FMAMODE 0 \"register_operand\")\n+\t(fma:FMAMODE\n+\t  (neg:FMAMODE (match_operand:FMAMODE 1 \"nonimmediate_operand\"))\n+\t  (match_operand:FMAMODE 2 \"nonimmediate_operand\")\n+\t  (match_operand:FMAMODE 3 \"nonimmediate_operand\")))]\n+  \"(TARGET_FMA || TARGET_FMA4) && TARGET_SSE_MATH\"\n+  \"\")\n+\n+(define_expand \"fnms<mode>4\"\n+  [(set (match_operand:FMAMODE 0 \"register_operand\")\n+\t(fma:FMAMODE\n+\t  (neg:FMAMODE (match_operand:FMAMODE 1 \"nonimmediate_operand\"))\n+\t  (match_operand:FMAMODE 2 \"nonimmediate_operand\")\n+\t  (neg:FMAMODE (match_operand:FMAMODE 3 \"nonimmediate_operand\"))))]\n+  \"(TARGET_FMA || TARGET_FMA4) && TARGET_SSE_MATH\"\n+  \"\")\n+\n ;; The builtin for fma4intrin.h is not constrained by SSE math enabled.\n (define_expand \"fma4i_fmadd_<mode>\"\n   [(set (match_operand:FMAMODE 0 \"register_operand\")"}, {"sha": "fda884b76eb0a4b9ad9d81ee7706a2db7760c2c7", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -343,7 +343,7 @@ Objective-C and Objective-C++ Dialects}.\n -fdelayed-branch -fdelete-null-pointer-checks -fdse -fdse @gol\n -fearly-inlining -fipa-sra -fexpensive-optimizations -ffast-math @gol\n -ffinite-math-only -ffloat-store -fexcess-precision=@var{style} @gol\n--fforward-propagate -ffunction-sections @gol\n+-fforward-propagate -ffp-contract=@var{style} -ffunction-sections @gol\n -fgcse -fgcse-after-reload -fgcse-las -fgcse-lm -fgraphite-identity @gol\n -fgcse-sm -fif-conversion -fif-conversion2 -findirect-inlining @gol\n -finline-functions -finline-functions-called-once -finline-limit=@var{n} @gol\n@@ -5992,6 +5992,18 @@ loop unrolling.\n This option is enabled by default at optimization levels @option{-O},\n @option{-O2}, @option{-O3}, @option{-Os}.\n \n+@item -ffp-contract=@var{style}\n+@opindex ffp-contract\n+@option{-ffp-contract=off} disables floating-point expression contraction.\n+@option{-ffp-contract=fast} enables floating-point expression contraction\n+such as forming of fused multiply-add operations if the target has\n+native support for them.\n+@option{-ffp-contract=on} enables floating-point expression contraction\n+if allowed by the language standard.  This is currently not implemented\n+and treated equal to @option{-ffp-contract=off}.\n+\n+The default is @option{-ffp-contract=fast}.\n+\n @item -fomit-frame-pointer\n @opindex fomit-frame-pointer\n Don't keep the frame pointer in a register for functions that"}, {"sha": "8418564d91c483dffdd116309c318ff0c7ea323b", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -3958,6 +3958,36 @@ pattern is used to implement the @code{fma}, @code{fmaf}, and\n multiply followed by the add if the machine does not perform a\n rounding step between the operations.\n \n+@cindex @code{fms@var{m}4} instruction pattern\n+@item @samp{fms@var{m}4}\n+Like @code{fma@var{m}4}, except operand 3 subtracted from the\n+product instead of added to the product.  This is represented\n+in the rtl as\n+\n+@smallexample\n+(fma:@var{m} @var{op1} @var{op2} (neg:@var{m} @var{op3}))\n+@end smallexample\n+\n+@cindex @code{fnma@var{m}4} instruction pattern\n+@item @samp{fnma@var{m}4}\n+Like @code{fma@var{m}4} except that the intermediate product\n+is negated before being added to operand 3.  This is represented\n+in the rtl as\n+\n+@smallexample\n+(fma:@var{m} (neg:@var{m} @var{op1}) @var{op2} @var{op3})\n+@end smallexample\n+\n+@cindex @code{fnms@var{m}4} instruction pattern\n+@item @samp{fnms@var{m}4}\n+Like @code{fms@var{m}4} except that the intermediate product\n+is negated before subtracting operand 3.  This is represented\n+in the rtl as\n+\n+@smallexample\n+(fma:@var{m} (neg:@var{m} @var{op1}) @var{op2} (neg:@var{m} @var{op3}))\n+@end smallexample\n+\n @cindex @code{min@var{m}3} instruction pattern\n @cindex @code{max@var{m}3} instruction pattern\n @item @samp{smin@var{m}3}, @samp{smax@var{m}3}"}, {"sha": "f29f6dc1244535a0cd0a000b00a59048852b1ebf", "filename": "gcc/expr.c", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -7254,7 +7254,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n   int ignore;\n   bool reduce_bit_field;\n   location_t loc = ops->location;\n-  tree treeop0, treeop1;\n+  tree treeop0, treeop1, treeop2;\n #define REDUCE_BIT_FIELD(expr)\t(reduce_bit_field\t\t\t  \\\n \t\t\t\t ? reduce_to_bit_field_precision ((expr), \\\n \t\t\t\t\t\t\t\t  target, \\\n@@ -7267,6 +7267,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \n   treeop0 = ops->op0;\n   treeop1 = ops->op1;\n+  treeop2 = ops->op2;\n \n   /* We should be called only on simple (binary or unary) expressions,\n      exactly those that are valid in gimple expressions that aren't\n@@ -7624,7 +7625,7 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n     case WIDEN_MULT_PLUS_EXPR:\n     case WIDEN_MULT_MINUS_EXPR:\n       expand_operands (treeop0, treeop1, NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n-      op2 = expand_normal (ops->op2);\n+      op2 = expand_normal (treeop2);\n       target = expand_widen_pattern_expr (ops, op0, op1, op2,\n \t\t\t\t\t  target, unsignedp);\n       return target;\n@@ -7711,6 +7712,46 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n       expand_operands (treeop0, treeop1, subtarget, &op0, &op1, EXPAND_NORMAL);\n       return REDUCE_BIT_FIELD (expand_mult (mode, op0, op1, target, unsignedp));\n \n+    case FMA_EXPR:\n+      {\n+\toptab opt = fma_optab;\n+\tgimple def0, def2;\n+\n+\tdef0 = get_def_for_expr (treeop0, NEGATE_EXPR);\n+\tdef2 = get_def_for_expr (treeop2, NEGATE_EXPR);\n+\n+\top0 = op2 = NULL;\n+\n+\tif (def0 && def2\n+\t    && optab_handler (fnms_optab, mode) != CODE_FOR_nothing)\n+\t  {\n+\t    opt = fnms_optab;\n+\t    op0 = expand_normal (gimple_assign_rhs1 (def0));\n+\t    op2 = expand_normal (gimple_assign_rhs1 (def2));\n+\t  }\n+\telse if (def0\n+\t\t && optab_handler (fnma_optab, mode) != CODE_FOR_nothing)\n+\t  {\n+\t    opt = fnma_optab;\n+\t    op0 = expand_normal (gimple_assign_rhs1 (def0));\n+\t  }\n+\telse if (def2\n+\t\t && optab_handler (fms_optab, mode) != CODE_FOR_nothing)\n+\t  {\n+\t    opt = fms_optab;\n+\t    op2 = expand_normal (gimple_assign_rhs1 (def2));\n+\t  }\n+\n+\tif (op0 == NULL)\n+\t  op0 = expand_expr (treeop0, subtarget, VOIDmode, EXPAND_NORMAL);\n+\tif (op2 == NULL)\n+\t  op2 = expand_normal (treeop2);\n+\top1 = expand_normal (treeop1);\n+\n+\treturn expand_ternary_op (TYPE_MODE (type), opt,\n+\t\t\t\t  op0, op1, op2, target, 0);\n+      }\n+\n     case MULT_EXPR:\n       /* If this is a fixed-point operation, then we cannot use the code\n \t below because \"expand_mult\" doesn't support sat/no-sat fixed-point"}, {"sha": "4259985b02a77bb0b070773879221c8a6c55b18d", "filename": "gcc/flag-types.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -152,4 +152,11 @@ enum warn_strict_overflow_code\n   WARN_STRICT_OVERFLOW_MAGNITUDE = 5\n };\n \n+/* Floating-point contraction mode.  */\n+enum fp_contract_mode {\n+  FP_CONTRACT_OFF = 0,\n+  FP_CONTRACT_ON = 1,\n+  FP_CONTRACT_FAST = 2\n+};\n+\n #endif /* ! GCC_FLAG_TYPES_H */"}, {"sha": "b6a9814fbe3ccdf79aab2d330b4536db2b543d26", "filename": "gcc/fold-const.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -13281,10 +13281,10 @@ contains_label_p (tree st)\n \n tree\n fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n-\t      tree op0, tree op1, tree op2)\n+\t\t  tree op0, tree op1, tree op2)\n {\n   tree tem;\n-  tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n+  tree arg0 = NULL_TREE, arg1 = NULL_TREE, arg2 = NULL_TREE;\n   enum tree_code_class kind = TREE_CODE_CLASS (code);\n \n   gcc_assert (IS_EXPR_CODE_CLASS (kind)\n@@ -13312,6 +13312,12 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n       STRIP_NOPS (arg1);\n     }\n \n+  if (op2)\n+    {\n+      arg2 = op2;\n+      STRIP_NOPS (arg2);\n+    }\n+\n   switch (code)\n     {\n     case COMPONENT_REF:\n@@ -13610,6 +13616,17 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \n       return NULL_TREE;\n \n+    case FMA_EXPR:\n+      /* For integers we can decompose the FMA if possible.  */\n+      if (TREE_CODE (arg0) == INTEGER_CST\n+\t  && TREE_CODE (arg1) == INTEGER_CST)\n+\treturn fold_build2_loc (loc, PLUS_EXPR, type,\n+\t\t\t\tconst_binop (MULT_EXPR, arg0, arg1), arg2);\n+      if (integer_zerop (arg2))\n+\treturn fold_build2_loc (loc, MULT_EXPR, type, arg0, arg1);\n+\n+      return fold_fma (loc, type, arg0, arg1, arg2);\n+\n     default:\n       return NULL_TREE;\n     } /* switch (code) */"}, {"sha": "eee9ef826da8f239c1dcf30e4384232cf7c07034", "filename": "gcc/genopinit.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -160,6 +160,9 @@ static const char * const optabs[] =\n   \"set_optab_handler (floor_optab, $A, CODE_FOR_$(floor$a2$))\",\n   \"set_convert_optab_handler (lfloor_optab, $B, $A, CODE_FOR_$(lfloor$F$a$I$b2$))\",\n   \"set_optab_handler (fma_optab, $A, CODE_FOR_$(fma$a4$))\",\n+  \"set_optab_handler (fms_optab, $A, CODE_FOR_$(fms$a4$))\",\n+  \"set_optab_handler (fnma_optab, $A, CODE_FOR_$(fnma$a4$))\",\n+  \"set_optab_handler (fnms_optab, $A, CODE_FOR_$(fnms$a4$))\",\n   \"set_optab_handler (ceil_optab, $A, CODE_FOR_$(ceil$a2$))\",\n   \"set_convert_optab_handler (lceil_optab, $B, $A, CODE_FOR_$(lceil$F$a$I$b2$))\",\n   \"set_optab_handler (round_optab, $A, CODE_FOR_$(round$a2$))\","}, {"sha": "057f35b98150409579fcbeac38318abfc6549708", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -400,6 +400,14 @@ dump_ternary_rhs (pretty_printer *buffer, gimple gs, int spc, int flags)\n       pp_character (buffer, '>');\n       break;\n \n+    case FMA_EXPR:\n+      dump_generic_node (buffer, gimple_assign_rhs1 (gs), spc, flags, false);\n+      pp_string (buffer, \" * \");\n+      dump_generic_node (buffer, gimple_assign_rhs2 (gs), spc, flags, false);\n+      pp_string (buffer, \" + \");\n+      dump_generic_node (buffer, gimple_assign_rhs3 (gs), spc, flags, false);\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "6704456c0cc88b4bca26d05144fc6c46c8739499", "filename": "gcc/gimple.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -2529,7 +2529,8 @@ get_gimple_rhs_num_ops (enum tree_code code)\n       || (SYM) == TRUTH_XOR_EXPR) ? GIMPLE_BINARY_RHS\t\t\t    \\\n    : (SYM) == TRUTH_NOT_EXPR ? GIMPLE_UNARY_RHS\t\t\t\t    \\\n    : ((SYM) == WIDEN_MULT_PLUS_EXPR\t\t\t\t\t    \\\n-      || (SYM) == WIDEN_MULT_MINUS_EXPR) ? GIMPLE_TERNARY_RHS\t\t    \\\n+      || (SYM) == WIDEN_MULT_MINUS_EXPR\t\t\t\t\t    \\\n+      || (SYM) == FMA_EXPR) ? GIMPLE_TERNARY_RHS\t\t\t    \\\n    : ((SYM) == COND_EXPR\t\t\t\t\t\t    \\\n       || (SYM) == CONSTRUCTOR\t\t\t\t\t\t    \\\n       || (SYM) == OBJ_TYPE_REF\t\t\t\t\t\t    \\"}, {"sha": "d5a633c1b5eff262e7f9d265a7c2c2a490024bc1", "filename": "gcc/gimplify.c", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -7170,6 +7170,16 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t  ret = gimplify_omp_atomic (expr_p, pre_p);\n \t  break;\n \n+\tcase TRUTH_AND_EXPR:\n+\tcase TRUTH_OR_EXPR:\n+\tcase TRUTH_XOR_EXPR:\n+\t  /* Classified as tcc_expression.  */\n+\t  goto expr_2;\n+\n+\tcase FMA_EXPR:\n+\t  /* Classified as tcc_expression.  */\n+\t  goto expr_3;\n+\n \tcase POINTER_PLUS_EXPR:\n           /* Convert ((type *)A)+offset into &A->field_of_type_and_offset.\n \t     The second is gimple immediate saving a need for extra statement.\n@@ -7249,16 +7259,28 @@ gimplify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n \t\tbreak;\n \t      }\n \n+\t    expr_3:\n+\t      {\n+\t\tenum gimplify_status r0, r1, r2;\n+\n+\t\tr0 = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p,\n+\t\t                    post_p, is_gimple_val, fb_rvalue);\n+\t\tr1 = gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p,\n+\t\t\t\t    post_p, is_gimple_val, fb_rvalue);\n+\t\tr2 = gimplify_expr (&TREE_OPERAND (*expr_p, 2), pre_p,\n+\t\t\t\t    post_p, is_gimple_val, fb_rvalue);\n+\n+\t\tret = MIN (MIN (r0, r1), r2);\n+\t\tbreak;\n+\t      }\n+\n \t    case tcc_declaration:\n \t    case tcc_constant:\n \t      ret = GS_ALL_DONE;\n \t      goto dont_recalculate;\n \n \t    default:\n-\t      gcc_assert (TREE_CODE (*expr_p) == TRUTH_AND_EXPR\n-\t\t\t  || TREE_CODE (*expr_p) == TRUTH_OR_EXPR\n-\t\t\t  || TREE_CODE (*expr_p) == TRUTH_XOR_EXPR);\n-\t      goto expr_2;\n+\t      gcc_unreachable ();\n \t    }\n \n \t  recalculate_side_effects (*expr_p);"}, {"sha": "a96eea1cdc83359d8559b3c242e193959be3fb1c", "filename": "gcc/optabs.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -374,6 +374,9 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n \t      : (TYPE_SATURATING (type)\n \t\t ? ssmsub_widen_optab : smsub_widen_optab));\n \n+    case FMA_EXPR:\n+      return fma_optab;\n+\n     case REDUC_MAX_EXPR:\n       return TYPE_UNSIGNED (type) ? reduc_umax_optab : reduc_smax_optab;\n "}, {"sha": "c4dfa60b83d31366ab030cbd88535b8bd0e2bab9", "filename": "gcc/optabs.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -192,6 +192,9 @@ enum optab_index\n   OTI_atan2,\n   /* Floating multiply/add */\n   OTI_fma,\n+  OTI_fms,\n+  OTI_fnma,\n+  OTI_fnms,\n \n   /* Move instruction.  */\n   OTI_mov,\n@@ -435,6 +438,9 @@ enum optab_index\n #define pow_optab (&optab_table[OTI_pow])\n #define atan2_optab (&optab_table[OTI_atan2])\n #define fma_optab (&optab_table[OTI_fma])\n+#define fms_optab (&optab_table[OTI_fms])\n+#define fnma_optab (&optab_table[OTI_fnma])\n+#define fnms_optab (&optab_table[OTI_fnms])\n \n #define mov_optab (&optab_table[OTI_mov])\n #define movstrict_optab (&optab_table[OTI_movstrict])"}, {"sha": "b2019c67a38cc39213a1fd377d00ad880342078d", "filename": "gcc/opts.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -1901,6 +1901,18 @@ common_handle_option (struct gcc_options *opts,\n \treturn false;\n       break;\n \n+    case OPT_ffp_contract_:\n+      if (!strcmp (arg, \"on\"))\n+\t/* Not implemented, fall back to conservative FP_CONTRACT_OFF.  */\n+\tflag_fp_contract_mode = FP_CONTRACT_OFF;\n+      else if (!strcmp (arg, \"off\"))\n+\tflag_fp_contract_mode = FP_CONTRACT_OFF;\n+      else if (!strcmp (arg, \"fast\"))\n+\tflag_fp_contract_mode = FP_CONTRACT_FAST;\n+      else\n+\terror (\"unknown floating point contraction style \\\"%s\\\"\", arg);\n+      break;\n+\n     case OPT_fexcess_precision_:\n       if (!strcmp (arg, \"fast\"))\n \tflag_excess_precision_cmdline = EXCESS_PRECISION_FAST;"}, {"sha": "a025ce4ba941937d8e75d44a38a4e4dd9b93a8f4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -1,3 +1,8 @@\n+2010-11-04  Richard Guenther  <rguenther@suse.de>\n+\tRichard Henderson  <rth@redhat.com>\n+\n+\t* gcc.target/i386/fma4-vector-2.c: New testcase.\n+\n 2010-11-04  Artjoms Sinkarovs <artyom.shinakroff@gmail.com>\n \tRichard Guenther  <rguenther@suse.de>\n "}, {"sha": "2f3ec96dc966a25ec40080a2075b44b0c81856cc", "filename": "gcc/testsuite/gcc.target/i386/fma4-vector-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-vector-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-vector-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Ffma4-vector-2.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O2 -mfma4 -ftree-vectorize -mtune=generic\" } */\n+\n+float r[256], s[256];\n+float x[256];\n+float y[256];\n+float z[256];\n+\n+void foo (void)\n+{\n+  int i;\n+  for (i = 0; i < 256; ++i)\n+    {\n+      r[i] = x[i] * y[i] - z[i];\n+      s[i] = x[i] * y[i] + z[i];\n+    }\n+}\n+\n+/* { dg-final { scan-assembler \"vfmaddps\" } } */\n+/* { dg-final { scan-assembler \"vfmsubps\" } } */"}, {"sha": "3b46283e7e6386aa3ce2fcb51c7963d61baa731b", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -3655,6 +3655,20 @@ verify_gimple_assign_ternary (gimple stmt)\n \t}\n       break;\n \n+    case FMA_EXPR:\n+      if (!useless_type_conversion_p (lhs_type, rhs1_type)\n+\t  || !useless_type_conversion_p (lhs_type, rhs2_type)\n+\t  || !useless_type_conversion_p (lhs_type, rhs3_type))\n+\t{\n+\t  error (\"type mismatch in fused multiply-add expression\");\n+\t  debug_generic_expr (lhs_type);\n+\t  debug_generic_expr (rhs1_type);\n+\t  debug_generic_expr (rhs2_type);\n+\t  debug_generic_expr (rhs3_type);\n+\t  return true;\n+\t}\n+      break;\n+\n     default:\n       gcc_unreachable ();\n     }"}, {"sha": "88806beddd3bf54f10cac610560ec1cdae47877a", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -3283,6 +3283,7 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n     case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n     case MULT_EXPR:\n+    case FMA_EXPR:\n \n     case ADDR_SPACE_CONVERT_EXPR:\n     case FIXED_CONVERT_EXPR:"}, {"sha": "96140f06f63d122599526d2eb08363777cbc9588", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 146, "deletions": 12, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -1494,38 +1494,169 @@ convert_plusminus_to_widen (gimple_stmt_iterator *gsi, gimple stmt,\n   return true;\n }\n \n+/* Combine the multiplication at MUL_STMT with uses in additions and\n+   subtractions to form fused multiply-add operations.  Returns true\n+   if successful and MUL_STMT should be removed.  */\n+\n+static bool\n+convert_mult_to_fma (gimple mul_stmt)\n+{\n+  tree mul_result = gimple_assign_lhs (mul_stmt);\n+  tree type = TREE_TYPE (mul_result);\n+  gimple use_stmt, fma_stmt;\n+  use_operand_p use_p;\n+  imm_use_iterator imm_iter;\n+\n+  if (FLOAT_TYPE_P (type)\n+      && flag_fp_contract_mode == FP_CONTRACT_OFF)\n+    return false;\n+\n+  /* We don't want to do bitfield reduction ops.  */\n+  if (INTEGRAL_TYPE_P (type)\n+      && (TYPE_PRECISION (type)\n+\t  != GET_MODE_PRECISION (TYPE_MODE (type))))\n+    return false;\n+\n+  /* If the target doesn't support it, don't generate it.  We assume that\n+     if fma isn't available then fms, fnma or fnms are not either.  */\n+  if (optab_handler (fma_optab, TYPE_MODE (type)) == CODE_FOR_nothing)\n+    return false;\n+\n+  /* Make sure that the multiplication statement becomes dead after\n+     the transformation, thus that all uses are transformed to FMAs.\n+     This means we assume that an FMA operation has the same cost\n+     as an addition.  */\n+  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, mul_result)\n+    {\n+      enum tree_code use_code;\n+\n+      use_stmt = USE_STMT (use_p);\n+\n+      if (!is_gimple_assign (use_stmt))\n+\treturn false;\n+      use_code = gimple_assign_rhs_code (use_stmt);\n+      /* ???  We need to handle NEGATE_EXPR to eventually form fnms.  */\n+      if (use_code != PLUS_EXPR\n+\t  && use_code != MINUS_EXPR)\n+\treturn false;\n+\n+      /* For now restrict this operations to single basic blocks.  In theory\n+\t we would want to support sinking the multiplication in\n+\t m = a*b;\n+\t if ()\n+\t   ma = m + c;\n+\t else\n+\t   d = m;\n+\t to form a fma in the then block and sink the multiplication to the\n+\t else block.  */\n+      if (gimple_bb (use_stmt) != gimple_bb (mul_stmt))\n+\treturn false;\n+\n+      /* We can't handle a * b + a * b.  */\n+      if (gimple_assign_rhs1 (use_stmt) == gimple_assign_rhs2 (use_stmt))\n+\treturn false;\n+\n+      /* If the target doesn't support a * b - c then drop the ball.  */\n+      if (gimple_assign_rhs1 (use_stmt) == mul_result\n+\t  && use_code == MINUS_EXPR\n+\t  && optab_handler (fms_optab, TYPE_MODE (type)) == CODE_FOR_nothing)\n+\treturn false;\n+\n+      /* If the target doesn't support -a * b + c then drop the ball.  */\n+      if (gimple_assign_rhs2 (use_stmt) == mul_result\n+\t  && use_code == MINUS_EXPR\n+\t  && optab_handler (fnma_optab, TYPE_MODE (type)) == CODE_FOR_nothing)\n+\treturn false;\n+\n+      /* We don't yet generate -a * b - c below yet.  */\n+    }\n+\n+  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, mul_result)\n+    {\n+      tree addop, mulop1;\n+      gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n+\n+      mulop1 = gimple_assign_rhs1 (mul_stmt);\n+      if (gimple_assign_rhs1 (use_stmt) == mul_result)\n+\t{\n+\t  addop = gimple_assign_rhs2 (use_stmt);\n+\t  /* a * b - c -> a * b + (-c)  */\n+\t  if (gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n+\t    addop = force_gimple_operand_gsi (&gsi,\n+\t\t\t\t\t      build1 (NEGATE_EXPR,\n+\t\t\t\t\t\t      type, addop),\n+\t\t\t\t\t      true, NULL_TREE, true,\n+\t\t\t\t\t      GSI_SAME_STMT);\n+\t}\n+      else\n+\t{\n+\t  addop = gimple_assign_rhs1 (use_stmt);\n+\t  /* a - b * c -> (-b) * c + a */\n+\t  if (gimple_assign_rhs_code (use_stmt) == MINUS_EXPR)\n+\t    mulop1 = force_gimple_operand_gsi (&gsi,\n+\t\t\t\t\t       build1 (NEGATE_EXPR,\n+\t\t\t\t\t\t       type, mulop1),\n+\t\t\t\t\t       true, NULL_TREE, true,\n+\t\t\t\t\t       GSI_SAME_STMT);\n+\t}\n+\n+      fma_stmt = gimple_build_assign_with_ops3 (FMA_EXPR,\n+\t\t\t\t\t\tgimple_assign_lhs (use_stmt),\n+\t\t\t\t\t\tmulop1,\n+\t\t\t\t\t\tgimple_assign_rhs2 (mul_stmt),\n+\t\t\t\t\t\taddop);\n+      gsi_replace (&gsi, fma_stmt, true);\n+    }\n+\n+  return true;\n+}\n+\n /* Find integer multiplications where the operands are extended from\n    smaller types, and replace the MULT_EXPR with a WIDEN_MULT_EXPR\n    where appropriate.  */\n \n static unsigned int\n execute_optimize_widening_mul (void)\n {\n-  bool changed = false;\n   basic_block bb;\n \n   FOR_EACH_BB (bb)\n     {\n       gimple_stmt_iterator gsi;\n \n-      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n         {\n \t  gimple stmt = gsi_stmt (gsi);\n \t  enum tree_code code;\n \n-\t  if (!is_gimple_assign (stmt))\n-\t    continue;\n+\t  if (is_gimple_assign (stmt))\n+\t    {\n+\t      code = gimple_assign_rhs_code (stmt);\n+\t      switch (code)\n+\t\t{\n+\t\tcase MULT_EXPR:\n+\t\t  if (!convert_mult_to_widen (stmt)\n+\t\t      && convert_mult_to_fma (stmt))\n+\t\t    {\n+\t\t      gsi_remove (&gsi, true);\n+\t\t      release_defs (stmt);\n+\t\t      continue;\n+\t\t    }\n+\t\t  break;\n+\n+\t\tcase PLUS_EXPR:\n+\t\tcase MINUS_EXPR:\n+\t\t  convert_plusminus_to_widen (&gsi, stmt, code);\n+\t\t  break;\n \n-\t  code = gimple_assign_rhs_code (stmt);\n-\t  if (code == MULT_EXPR)\n-\t    changed |= convert_mult_to_widen (stmt);\n-\t  else if (code == PLUS_EXPR || code == MINUS_EXPR)\n-\t    changed |= convert_plusminus_to_widen (&gsi, stmt, code);\n+\t\tdefault:;\n+\t\t}\n+\t    }\n+\t  gsi_next (&gsi);\n \t}\n     }\n \n-  return (changed ? TODO_dump_func | TODO_update_ssa | TODO_verify_ssa\n-\t  | TODO_verify_stmts : 0);\n+  return 0;\n }\n \n static bool\n@@ -1549,6 +1680,9 @@ struct gimple_opt_pass pass_optimize_widening_mul =\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */\n-  0                                     /* todo_flags_finish */\n+  TODO_verify_ssa\n+  | TODO_verify_stmts\n+  | TODO_dump_func\n+  | TODO_update_ssa                     /* todo_flags_finish */\n  }\n };"}, {"sha": "2dbc0353421f336834e9234578d7a6957265bbe8", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 51, "deletions": 15, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -2343,7 +2343,8 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n \n /* Function vectorizable_operation.\n \n-   Check if STMT performs a binary or unary operation that can be vectorized.\n+   Check if STMT performs a binary, unary or ternary operation that can\n+   be vectorized.\n    If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n    stmt to replace it, put it in VEC_STMT, and insert it at BSI.\n    Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n@@ -2354,7 +2355,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n {\n   tree vec_dest;\n   tree scalar_dest;\n-  tree op0, op1 = NULL;\n+  tree op0, op1 = NULL_TREE, op2 = NULL_TREE;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   tree vectype;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n@@ -2366,16 +2367,17 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   int icode;\n   tree def;\n   gimple def_stmt;\n-  enum vect_def_type dt[2] = {vect_unknown_def_type, vect_unknown_def_type};\n+  enum vect_def_type dt[3]\n+    = {vect_unknown_def_type, vect_unknown_def_type, vect_unknown_def_type};\n   gimple new_stmt = NULL;\n   stmt_vec_info prev_stmt_info;\n   int nunits_in;\n   int nunits_out;\n   tree vectype_out;\n   int ncopies;\n   int j, i;\n-  VEC(tree,heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL;\n-  tree vop0, vop1;\n+  VEC(tree,heap) *vec_oprnds0 = NULL, *vec_oprnds1 = NULL, *vec_oprnds2 = NULL;\n+  tree vop0, vop1, vop2;\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   int vf;\n \n@@ -2401,10 +2403,11 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \n   /* Support only unary or binary operations.  */\n   op_type = TREE_CODE_LENGTH (code);\n-  if (op_type != unary_op && op_type != binary_op)\n+  if (op_type != unary_op && op_type != binary_op && op_type != ternary_op)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"num. args = %d (not unary/binary op).\", op_type);\n+\tfprintf (vect_dump, \"num. args = %d (not unary/binary/ternary op).\",\n+\t\t op_type);\n       return false;\n     }\n \n@@ -2441,7 +2444,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   if (nunits_out != nunits_in)\n     return false;\n \n-  if (op_type == binary_op)\n+  if (op_type == binary_op || op_type == ternary_op)\n     {\n       op1 = gimple_assign_rhs2 (stmt);\n       if (!vect_is_simple_use (op1, loop_vinfo, bb_vinfo, &def_stmt, &def,\n@@ -2452,6 +2455,17 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t  return false;\n \t}\n     }\n+  if (op_type == ternary_op)\n+    {\n+      op2 = gimple_assign_rhs3 (stmt);\n+      if (!vect_is_simple_use (op2, loop_vinfo, bb_vinfo, &def_stmt, &def,\n+                               &dt[2]))\n+\t{\n+\t  if (vect_print_dump_info (REPORT_DETAILS))\n+\t    fprintf (vect_dump, \"use not simple.\");\n+\t  return false;\n+\t}\n+    }\n \n   if (loop_vinfo)\n     vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n@@ -2473,7 +2487,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       || code == RROTATE_EXPR)\n    return false;\n \n- optab = optab_for_tree_code (code, vectype, optab_default);\n+  optab = optab_for_tree_code (code, vectype, optab_default);\n \n   /* Supportable by target?  */\n   if (!optab)\n@@ -2534,8 +2548,10 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   if (!slp_node)\n     {\n       vec_oprnds0 = VEC_alloc (tree, heap, 1);\n-      if (op_type == binary_op)\n+      if (op_type == binary_op || op_type == ternary_op)\n         vec_oprnds1 = VEC_alloc (tree, heap, 1);\n+      if (op_type == ternary_op)\n+        vec_oprnds2 = VEC_alloc (tree, heap, 1);\n     }\n \n   /* In case the vectorization factor (VF) is bigger than the number\n@@ -2597,22 +2613,40 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       /* Handle uses.  */\n       if (j == 0)\n \t{\n-\t  if (op_type == binary_op)\n+\t  if (op_type == binary_op || op_type == ternary_op)\n \t    vect_get_vec_defs (op0, op1, stmt, &vec_oprnds0, &vec_oprnds1,\n \t\t\t       slp_node);\n \t  else\n \t    vect_get_vec_defs (op0, NULL_TREE, stmt, &vec_oprnds0, NULL,\n \t\t\t       slp_node);\n+\t  if (op_type == ternary_op)\n+\t    {\n+\t      vec_oprnds2 = VEC_alloc (tree, heap, 1);\n+\t      VEC_quick_push (tree, vec_oprnds2,\n+\t\t\t      vect_get_vec_def_for_operand (op2, stmt, NULL));\n+\t    }\n \t}\n       else\n-\tvect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, &vec_oprnds1);\n+\t{\n+\t  vect_get_vec_defs_for_stmt_copy (dt, &vec_oprnds0, &vec_oprnds1);\n+\t  if (op_type == ternary_op)\n+\t    {\n+\t      tree vec_oprnd = VEC_pop (tree, vec_oprnds2);\n+\t      VEC_quick_push (tree, vec_oprnds2,\n+\t\t\t      vect_get_vec_def_for_stmt_copy (dt[2],\n+\t\t\t\t\t\t\t      vec_oprnd));\n+\t    }\n+\t}\n \n       /* Arguments are ready.  Create the new vector stmt.  */\n       FOR_EACH_VEC_ELT (tree, vec_oprnds0, i, vop0)\n         {\n-\t  vop1 = ((op_type == binary_op)\n-\t\t  ? VEC_index (tree, vec_oprnds1, i) : NULL);\n-\t  new_stmt = gimple_build_assign_with_ops (code, vec_dest, vop0, vop1);\n+\t  vop1 = ((op_type == binary_op || op_type == ternary_op)\n+\t\t  ? VEC_index (tree, vec_oprnds1, i) : NULL_TREE);\n+\t  vop2 = ((op_type == ternary_op)\n+\t\t  ? VEC_index (tree, vec_oprnds2, i) : NULL_TREE);\n+\t  new_stmt = gimple_build_assign_with_ops3 (code, vec_dest,\n+\t\t\t\t\t\t    vop0, vop1, vop2);\n \t  new_temp = make_ssa_name (vec_dest, new_stmt);\n \t  gimple_assign_set_lhs (new_stmt, new_temp);\n \t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n@@ -2633,6 +2667,8 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n   VEC_free (tree, heap, vec_oprnds0);\n   if (vec_oprnds1)\n     VEC_free (tree, heap, vec_oprnds1);\n+  if (vec_oprnds2)\n+    VEC_free (tree, heap, vec_oprnds2);\n \n   return true;\n }"}, {"sha": "791d699a0c55acad06cab49e66d025e0c1b15963", "filename": "gcc/tree.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -1092,6 +1092,12 @@ DEFTREECODE (WIDEN_MULT_PLUS_EXPR, \"widen_mult_plus_expr\", tcc_expression, 3)\n    is subtracted from t3.  */\n DEFTREECODE (WIDEN_MULT_MINUS_EXPR, \"widen_mult_plus_expr\", tcc_expression, 3)\n \n+/* Fused multiply-add.\n+   All operands and the result are of the same type.  No intermediate\n+   rounding is performed after multiplying operand one with operand two\n+   before adding operand three.  */\n+DEFTREECODE (FMA_EXPR, \"fma_expr\", tcc_expression, 3)\n+\n /* Whole vector left/right shift in bits.\n    Operand 0 is a vector to be shifted.\n    Operand 1 is an integer shift amount in bits.  */"}, {"sha": "2392ada989781241527d3b467e3efa7f8ed8f724", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1694907238eb106bf7ac0e4eaedaa77bc7719b6d/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1694907238eb106bf7ac0e4eaedaa77bc7719b6d", "patch": "@@ -4954,6 +4954,7 @@ extern void fold_defer_overflow_warnings (void);\n extern void fold_undefer_overflow_warnings (bool, const_gimple, int);\n extern void fold_undefer_and_ignore_overflow_warnings (void);\n extern bool fold_deferring_overflow_warnings_p (void);\n+extern tree fold_fma (location_t, tree, tree, tree, tree);\n \n enum operand_equal_flag\n {"}]}