{"sha": "ca6b7410ddb84f2131a1754981a26238f3a6bf9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E2Yjc0MTBkZGI4NGYyMTMxYTE3NTQ5ODFhMjYyMzhmM2E2YmY5Zg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-06-07T07:41:18Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-06-07T07:41:18Z"}, "message": "re PR tree-optimization/69615 (0 to limit signed range checks don't always use unsigned compare)\n\n\tPR tree-optimization/69615\n\t* tree-ssa-reassoc.c (optimize_range_tests_var_bound): If rhs2 is lhs\n\tof a cast from a same precision integral SSA_NAME in a bb dominated\n\tby first_bb, retry with rhs2 set to the rhs1 of the cast.  Don't emit\n\tcast to utype if rhs2 has already a compatible type.\n\n\t* gcc.dg/tree-ssa/pr69615.c: New test.\n\nFrom-SVN: r261264", "tree": {"sha": "d71f8f027abe5bec0af61bcbb8445227c585517f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d71f8f027abe5bec0af61bcbb8445227c585517f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca6b7410ddb84f2131a1754981a26238f3a6bf9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca6b7410ddb84f2131a1754981a26238f3a6bf9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca6b7410ddb84f2131a1754981a26238f3a6bf9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca6b7410ddb84f2131a1754981a26238f3a6bf9f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b2bf82589273884743923aa780c9479965609070", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b2bf82589273884743923aa780c9479965609070", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b2bf82589273884743923aa780c9479965609070"}], "stats": {"total": 74, "additions": 61, "deletions": 13}, "files": [{"sha": "ccc02bafa41c6d2016c9c206a6f1332bb4b2ed3b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6b7410ddb84f2131a1754981a26238f3a6bf9f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6b7410ddb84f2131a1754981a26238f3a6bf9f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca6b7410ddb84f2131a1754981a26238f3a6bf9f", "patch": "@@ -1,3 +1,11 @@\n+2018-06-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/69615\n+\t* tree-ssa-reassoc.c (optimize_range_tests_var_bound): If rhs2 is lhs\n+\tof a cast from a same precision integral SSA_NAME in a bb dominated\n+\tby first_bb, retry with rhs2 set to the rhs1 of the cast.  Don't emit\n+\tcast to utype if rhs2 has already a compatible type.\n+\n 2018-06-07  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/85935"}, {"sha": "5015f598fa7bae145d952435ed52bd262207d54f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6b7410ddb84f2131a1754981a26238f3a6bf9f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6b7410ddb84f2131a1754981a26238f3a6bf9f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ca6b7410ddb84f2131a1754981a26238f3a6bf9f", "patch": "@@ -1,3 +1,8 @@\n+2018-06-07  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/69615\n+\t* gcc.dg/tree-ssa/pr69615.c: New test.\n+\n 2018-06-07  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/85935"}, {"sha": "f5c4d8a83dd1fc7d6c60b255e2c6e4c86c1ccffe", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr69615.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6b7410ddb84f2131a1754981a26238f3a6bf9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69615.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6b7410ddb84f2131a1754981a26238f3a6bf9f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69615.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr69615.c?ref=ca6b7410ddb84f2131a1754981a26238f3a6bf9f", "patch": "@@ -0,0 +1,16 @@\n+/* PR tree-optimization/69615 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-final { scan-tree-dump-not \" >= 0\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-not \" < 0\" \"optimized\" } } */\n+\n+extern void foo (void);\n+\n+void\n+bar (int z, unsigned int y)\n+{\n+  long long x = z;\n+  y &= 0xf;\n+  if (x >= 0 && x < (int) y)\n+    foo ();\n+}"}, {"sha": "48d402b99fb545c602b2bba7b41bbd9b3a6c28df", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 32, "deletions": 13, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca6b7410ddb84f2131a1754981a26238f3a6bf9f/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca6b7410ddb84f2131a1754981a26238f3a6bf9f/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=ca6b7410ddb84f2131a1754981a26238f3a6bf9f", "patch": "@@ -3172,7 +3172,7 @@ optimize_range_tests_var_bound (enum tree_code opcode, int first, int length,\n \t to (unsigned) k_32 < (unsigned) iftmp.0_44, then we would execute\n \t those stmts even for negative k_32 and the value ranges would be no\n \t longer guaranteed and so the optimization would be invalid.  */\n-      if (opcode == ERROR_MARK)\n+      while (opcode == ERROR_MARK)\n \t{\n \t  gimple *g = SSA_NAME_DEF_STMT (rhs2);\n \t  basic_block bb2 = gimple_bb (g);\n@@ -3182,21 +3182,37 @@ optimize_range_tests_var_bound (enum tree_code opcode, int first, int length,\n \t    {\n \t      /* As an exception, handle a few common cases.  */\n \t      if (gimple_assign_cast_p (g)\n-\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (g)))\n-\t\t  && TYPE_UNSIGNED (TREE_TYPE (gimple_assign_rhs1 (g)))\n-\t\t  && (TYPE_PRECISION (TREE_TYPE (rhs2))\n-\t\t      > TYPE_PRECISION (TREE_TYPE (gimple_assign_rhs1 (g)))))\n-\t\t/* Zero-extension is always ok.  */ ;\n+\t\t  && INTEGRAL_TYPE_P (TREE_TYPE (gimple_assign_rhs1 (g))))\n+\t\t{\n+\t\t  tree op0 = gimple_assign_rhs1 (g);\n+\t\t  if (TYPE_UNSIGNED (TREE_TYPE (op0))\n+\t\t      && (TYPE_PRECISION (TREE_TYPE (rhs2))\n+\t\t\t  > TYPE_PRECISION (TREE_TYPE (op0))))\n+\t\t    /* Zero-extension is always ok.  */\n+\t\t    break;\n+\t\t  else if (TYPE_PRECISION (TREE_TYPE (rhs2))\n+\t\t\t   == TYPE_PRECISION (TREE_TYPE (op0))\n+\t\t\t   && TREE_CODE (op0) == SSA_NAME)\n+\t\t    {\n+\t\t      /* Cast from signed to unsigned or vice versa.  Retry\n+\t\t\t with the op0 as new rhs2.  */\n+\t\t      rhs2 = op0;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n \t      else if (is_gimple_assign (g)\n \t\t       && gimple_assign_rhs_code (g) == BIT_AND_EXPR\n \t\t       && TREE_CODE (gimple_assign_rhs2 (g)) == INTEGER_CST\n \t\t       && !wi::neg_p (wi::to_wide (gimple_assign_rhs2 (g))))\n \t\t/* Masking with INTEGER_CST with MSB clear is always ok\n-\t\t   too.  */ ;\n-\t      else\n-\t\tcontinue;\n+\t\t   too.  */\n+\t\tbreak;\n+\t      rhs2 = NULL_TREE;\n \t    }\n+\t  break;\n \t}\n+      if (rhs2 == NULL_TREE)\n+\tcontinue;\n \n       wide_int nz = get_nonzero_bits (rhs2);\n       if (wi::neg_p (nz))\n@@ -3253,10 +3269,13 @@ optimize_range_tests_var_bound (enum tree_code opcode, int first, int length,\n       gimple_set_uid (g, uid);\n       rhs1 = gimple_assign_lhs (g);\n       gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n-      g = gimple_build_assign (make_ssa_name (utype), NOP_EXPR, rhs2);\n-      gimple_set_uid (g, uid);\n-      rhs2 = gimple_assign_lhs (g);\n-      gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+      if (!useless_type_conversion_p (utype, TREE_TYPE (rhs2)))\n+\t{\n+\t  g = gimple_build_assign (make_ssa_name (utype), NOP_EXPR, rhs2);\n+\t  gimple_set_uid (g, uid);\n+\t  rhs2 = gimple_assign_lhs (g);\n+\t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t}\n       if (tree_swap_operands_p (rhs1, rhs2))\n \t{\n \t  std::swap (rhs1, rhs2);"}]}