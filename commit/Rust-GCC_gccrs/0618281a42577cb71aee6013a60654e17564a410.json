{"sha": "0618281a42577cb71aee6013a60654e17564a410", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYxODI4MWE0MjU3N2NiNzFhZWU2MDEzYTYwNjU0ZTE3NTY0YTQxMA==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2007-03-02T19:05:57Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2007-03-02T19:05:57Z"}, "message": "AnnotationInvocationHandler.java: Generify in a few places.\n\n2007-03-02  Andrew Haley  <aph@redhat.com>\n\n        * sun/reflect/annotation/AnnotationInvocationHandler.java:\n        Generify in a few places.\n        (equals): Rewrite to use invoke on local proxy.\n        (deepToString): Remove most of it.\n        (toString): Make nonstatic.\n        (arrayClone): Delete.\n        (coerce): New method.\n        (invoke): Rewrite to handle gcj's structures correctly.\n        * java/lang/natClass.cc (getDeclaredAnnotations): Fix test for\n        null loader.\n        * sources.am: Regenerate.\n        * Makefile.am: Likewise.\n\nFrom-SVN: r122483", "tree": {"sha": "fa7dbba8055bf92572480812956e3f27f2774e19", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa7dbba8055bf92572480812956e3f27f2774e19"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0618281a42577cb71aee6013a60654e17564a410", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0618281a42577cb71aee6013a60654e17564a410", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0618281a42577cb71aee6013a60654e17564a410", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0618281a42577cb71aee6013a60654e17564a410/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "debac9f40daa8a953f770a0303e09f6d54d02c51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/debac9f40daa8a953f770a0303e09f6d54d02c51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/debac9f40daa8a953f770a0303e09f6d54d02c51"}], "stats": {"total": 216, "additions": 138, "deletions": 78}, "files": [{"sha": "bddc998630227975cda4b7470a0166fe907f465c", "filename": "libjava/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0618281a42577cb71aee6013a60654e17564a410/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0618281a42577cb71aee6013a60654e17564a410/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=0618281a42577cb71aee6013a60654e17564a410", "patch": "@@ -1,3 +1,18 @@\n+2007-03-02  Andrew Haley  <aph@redhat.com>\n+\n+\t* sun/reflect/annotation/AnnotationInvocationHandler.java:\n+\tGenerify in a few places.\n+\t(equals): Rewrite to use invoke on local proxy.\n+\t(deepToString): Remove most of it.\n+\t(toString): Make nonstatic.\n+\t(arrayClone): Delete.\n+\t(coerce): New method.\n+\t(invoke): Rewrite to handle gcj's structures correctly.\n+\t* java/lang/natClass.cc (getDeclaredAnnotations): Fix test for\n+\tnull loader.\n+\t* sources.am: Regenerate.\n+\t* Makefile.am: Likewise.\t\n+\n 2007-03-02  Andrew Haley  <aph@redhat.com>\n \n \t* sun/reflect/annotation/AnnotationInvocationHandler.java:"}, {"sha": "99433510638742d9c5af20b994bf9bf595ef9638", "filename": "libjava/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0618281a42577cb71aee6013a60654e17564a410/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0618281a42577cb71aee6013a60654e17564a410/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=0618281a42577cb71aee6013a60654e17564a410", "patch": "@@ -7194,7 +7194,7 @@ sun/reflect/Reflection.java\n \n sun_reflect_header_files = $(patsubst %.java,%.h,$(sun_reflect_source_files))\n sun_reflect_annotation_source_files = \\\n-classpath/sun/reflect/annotation/AnnotationInvocationHandler.java \\\n+sun/reflect/annotation/AnnotationInvocationHandler.java \\\n classpath/sun/reflect/annotation/AnnotationParser.java \\\n classpath/sun/reflect/annotation/AnnotationType.java \\\n classpath/sun/reflect/annotation/EnumConstantNotPresentExceptionProxy.java \\"}, {"sha": "2e3036326cd7ca9a73a09b9a126cfb5d9e205d46", "filename": "libjava/classpath/lib/sun/reflect/annotation/AnnotationInvocationHandler.class", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0618281a42577cb71aee6013a60654e17564a410/libjava%2Fclasspath%2Flib%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.class", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0618281a42577cb71aee6013a60654e17564a410/libjava%2Fclasspath%2Flib%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.class", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fclasspath%2Flib%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.class?ref=0618281a42577cb71aee6013a60654e17564a410"}, {"sha": "e9adc2178f7c3eb5b778923e1c43225cbdc7eb6a", "filename": "libjava/sources.am", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0618281a42577cb71aee6013a60654e17564a410/libjava%2Fsources.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0618281a42577cb71aee6013a60654e17564a410/libjava%2Fsources.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsources.am?ref=0618281a42577cb71aee6013a60654e17564a410", "patch": "@@ -8373,7 +8373,7 @@ sun/reflect.list: $(sun_reflect_source_files)\n \n \n sun_reflect_annotation_source_files = \\\n-classpath/sun/reflect/annotation/AnnotationInvocationHandler.java \\\n+sun/reflect/annotation/AnnotationInvocationHandler.java \\\n classpath/sun/reflect/annotation/AnnotationParser.java \\\n classpath/sun/reflect/annotation/AnnotationType.java \\\n classpath/sun/reflect/annotation/EnumConstantNotPresentExceptionProxy.java \\"}, {"sha": "356c8a029c8a4c8af6a1d4189fd31f23f1e8ecd8", "filename": "libjava/sun/reflect/annotation/AnnotationInvocationHandler.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0618281a42577cb71aee6013a60654e17564a410/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0618281a42577cb71aee6013a60654e17564a410/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.h?ref=0618281a42577cb71aee6013a60654e17564a410", "patch": "@@ -29,19 +29,19 @@ class sun::reflect::annotation::AnnotationInvocationHandler : public ::java::lan\n public:\n   AnnotationInvocationHandler(::java::lang::Class *, ::java::util::Map *);\n   static ::java::lang::annotation::Annotation * create(::java::lang::Class *, ::java::util::Map *);\n-  static jboolean equals(::java::lang::Class *, ::java::util::Map *, ::java::lang::Object *);\n+  jboolean equals(::java::lang::Object *, ::java::lang::Object *);\n private:\n   static jboolean deepEquals(::java::lang::Object *, ::java::lang::Object *);\n   static jint deepHashCode(::java::lang::Object *);\n public:\n-  static jint hashCode(::java::lang::Class *, ::java::util::Map *);\n+  jint hashCode();\n private:\n   static ::java::lang::String * deepToString(::java::lang::Object *);\n public:\n-  static ::java::lang::String * toString(::java::lang::Class *, ::java::util::Map *);\n+  ::java::lang::String * toString();\n private:\n   static ::java::lang::Class * getBoxedReturnType(::java::lang::reflect::Method *);\n-  ::java::lang::Object * arrayClone(::java::lang::Object *);\n+  ::java::lang::Object * coerce(::java::lang::Object *, ::java::lang::Class *);\n public:\n   ::java::lang::Object * invoke(::java::lang::Object *, ::java::lang::reflect::Method *, JArray< ::java::lang::Object * > *);\n private:"}, {"sha": "f883faa16ac4bb5b5716f19477dc8e21fe0de31a", "filename": "libjava/sun/reflect/annotation/AnnotationInvocationHandler.java", "status": "modified", "additions": 117, "deletions": 72, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0618281a42577cb71aee6013a60654e17564a410/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0618281a42577cb71aee6013a60654e17564a410/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fsun%2Freflect%2Fannotation%2FAnnotationInvocationHandler.java?ref=0618281a42577cb71aee6013a60654e17564a410", "patch": "@@ -1,5 +1,5 @@\n /* sun.reflect.annotation.AnnotationInvocationHandler\n-   Copyright (C) 2006\n+   Copyright (C) 2006, 2007\n    Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n@@ -8,7 +8,7 @@\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -43,9 +43,9 @@\n import java.lang.annotation.AnnotationTypeMismatchException;\n import java.lang.annotation.IncompleteAnnotationException;\n import java.lang.reflect.InvocationHandler;\n-import java.lang.reflect.InvocationTargetException;\n import java.lang.reflect.Method;\n import java.lang.reflect.Proxy;\n+import java.lang.reflect.Array;\n import java.util.Arrays;\n import java.util.Iterator;\n import java.util.Map;\n@@ -62,21 +62,21 @@\n   implements InvocationHandler, Serializable\n {\n   private static final long serialVersionUID = 6182022883658399397L;\n-  private final Class type;\n-  private final Map memberValues;\n+  private final Class<? extends Annotation> type;\n+  private final Map<String, ?> memberValues;\n \n   /**\n    * Construct a new invocation handler for an annotation proxy.\n    * Note that the VM is responsible for filling the memberValues map\n    * with the default values of all the annotation members.\n    */\n-  public AnnotationInvocationHandler(Class type, Map memberValues)\n+  public AnnotationInvocationHandler(Class<? extends Annotation> type, Map memberValues)\n   {\n     this.type = type;\n-    this.memberValues = memberValues;\n+    this.memberValues = (Map<String, ?>)memberValues;\n   }\n \n-  public static Annotation create(Class type, Map memberValues)\n+  public static Annotation create(Class<? extends Annotation> type, Map memberValues)\n   {\n     for (Method m : type.getDeclaredMethods())\n       {\n@@ -106,7 +106,7 @@ public static Annotation create(Class type, Map memberValues)\n    * (can) use different representations of annotations that reuse this\n    * method.\n    */\n-  public static boolean equals(Class type, Map memberValues, Object other)\n+  public boolean equals(Object proxy, Object other)\n   {\n     if (type.isInstance(other))\n       {\n@@ -118,20 +118,20 @@ public static boolean equals(Class type, Map memberValues, Object other)\n \t\tfor (int i = 0; i < methods.length; i++)\n \t\t  {\n \t\t    String key = methods[i].getName();\n-\t\t    Object val = methods[i].invoke(other, new Object[0]);\n-\t\t    if (! deepEquals(memberValues.get(key), val))\n+\t\t    Object val = methods[i].invoke(other, (Object[])null);\n+\t\t    Object thisVal\n+\t\t      = invoke(proxy,\n+\t\t\t       methods[i],\n+\t\t\t       (Object[])null);\n+\t\t    if (! deepEquals(thisVal, val))\n \t\t      {\n \t\t\treturn false;\n \t\t      }\n \t\t  }\n \t\treturn true;\n \t      }\n \t  }\n-\tcatch (IllegalAccessException _)\n-\t  {\n-\t    // Ignore exception, like the JDK\n-\t  }\n-\tcatch (InvocationTargetException _)\n+\tcatch (Throwable _)\n \t  {\n \t    // Ignore exception, like the JDK\n \t  }\n@@ -217,45 +217,30 @@ private static int deepHashCode(Object obj)\n    * (can) use different representations of annotations that reuse this\n    * method.\n    */\n-  public static int hashCode(Class type, Map memberValues)\n+  public int hashCode()\n   {\n     int h = 0;\n     Iterator iter = memberValues.keySet().iterator();\n     while (iter.hasNext())\n       {\n \tObject key = iter.next();\n-\tObject val = memberValues.get(key);\n-\th += deepHashCode(val) ^ 127 * key.hashCode();\n+\ttry\n+\t  {\n+\t    Object val\n+\t      = invoke(null,\n+\t\t       type.getDeclaredMethod((String)key, (Class[])null),\n+\t\t       (Object[])null);\n+\t    h += deepHashCode(val) ^ 127 * key.hashCode();\n+\t  }\n+\tcatch (Throwable _)\n+\t  {\n+\t  }\n       }\n     return h;\n   }\n \n   private static String deepToString(Object obj)\n   {\n-    if (obj instanceof boolean[])\n-      return Arrays.toString((boolean[]) obj);\n-\n-    if (obj instanceof byte[])\n-      return Arrays.toString((byte[]) obj);\n-\n-    if (obj instanceof char[])\n-      return Arrays.toString((char[]) obj);\n-\n-    if (obj instanceof short[])\n-      return Arrays.toString((short[]) obj);\n-\n-    if (obj instanceof int[])\n-      return Arrays.toString((int[]) obj);\n-\n-    if (obj instanceof float[])\n-      return Arrays.toString((float[]) obj);\n-\n-    if (obj instanceof long[])\n-      return Arrays.toString((long[]) obj);\n-\n-    if (obj instanceof double[])\n-      return Arrays.toString((double[]) obj);\n-\n     if (obj instanceof Object[])\n       return Arrays.toString((Object[]) obj);\n \n@@ -267,7 +252,7 @@ private static String deepToString(Object obj)\n    * (can) use different representations of annotations that reuse this\n    * method.\n    */\n-  public static String toString(Class type, Map memberValues)\n+  public String toString()\n   {\n     StringBuffer sb = new StringBuffer();\n     sb.append('@').append(type.getName()).append('(');\n@@ -284,6 +269,7 @@ public static String toString(Class type, Map memberValues)\n     return sb.toString();\n   }\n \n+\n   private static Class getBoxedReturnType(Method method)\n   {\n     Class returnType = method.getReturnType();\n@@ -315,51 +301,106 @@ private static Class getBoxedReturnType(Method method)\n     return returnType;\n   }\n \n-  private Object arrayClone(Object obj)\n+  // This is slightly awkward.  When the value of an annotation is an\n+  // array, libgcj constructs an Object[], but the value() method\n+  // returns an arrays of the appropriate primitive type.  We should\n+  // perhaps save the resulting array rather than the Object[].\n+\n+  private Object coerce(Object val, Class dstType)\n+    throws ArrayStoreException\n   {\n-    if (obj instanceof boolean[])\n-      return ((boolean[]) obj).clone();\n+    if (! val.getClass().isArray())\n+      return val;\n \n-    if (obj instanceof byte[])\n-      return ((byte[]) obj).clone();\n+    Object[] srcArray = (Object[])val;\n+    final int len = srcArray.length;\n \n-    if (obj instanceof char[])\n-      return ((char[]) obj).clone();\n+    if (dstType.getComponentType().isPrimitive())\n+      {\n+\tif (dstType == boolean[].class)\n+\t  {\n+\t    boolean[] dst = new boolean[len];\n+\t    for (int i = 0; i < len; i++)\n+\t      dst[i] = (Boolean)srcArray[i];\n+\t    return dst;\n+\t  }\n \n-    if (obj instanceof short[])\n-      return ((short[]) obj).clone();\n+\tif (dstType == byte[].class)\n+\t  {\n+\t    byte[] dst = new byte[len];\n+\t    for (int i = 0; i < len; i++)\n+\t      dst[i] = (Byte)srcArray[i];\n+\t    return dst;\n+\t  }\n \n-    if (obj instanceof int[])\n-      return ((int[]) obj).clone();\n+\tif (dstType == char[].class)\n+\t  {\n+\t    char[] dst = new char[len];\n+\t    for (int i = 0; i < len; i++)\n+\t      dst[i] = (Character)srcArray[i];\n+\t    return dst;\n+\t  }\n \n-    if (obj instanceof float[])\n-      return ((float[]) obj).clone();\n+\tif (dstType == short[].class)\n+\t  {\n+\t    short[] dst = new short[len];\n+\t    for (int i = 0; i < len; i++)\n+\t      dst[i] = (Short)srcArray[i];\n+\t    return dst;\n+\t  }\n \n-    if (obj instanceof long[])\n-      return ((long[]) obj).clone();\n+\tif (dstType == int[].class)\n+\t  {\n+\t    int[] dst = new int[len];\n+\t    for (int i = 0; i < len; i++)\n+\t      dst[i] = (Integer)srcArray[i];\n+\t    return dst;\n+\t  }\n \n-    if (obj instanceof double[])\n-      return ((double[]) obj).clone();\n+\tif (dstType == long[].class)\n+\t  {\n+\t    long[] dst = new long[len];\n+\t    for (int i = 0; i < len; i++)\n+\t      dst[i] = (Long)srcArray[i];\n+\t    return dst;\n+\t  }\n \n-    if (obj instanceof Object[])\n-      return ((Object[]) obj).clone();\n+\tif (dstType == float[].class)\n+\t  {\n+\t    float[] dst = new float[len];\n+\t    for (int i = 0; i < len; i++)\n+\t      dst[i] = (Float)srcArray[i];\n+\t    return dst;\n+\t  }\n \n-    return obj;\n+\tif (dstType == double[].class)\n+\t  {\n+\t    double[] dst = new double[len];\n+\t    for (int i = 0; i < len; i++)\n+\t      dst[i] = (Double)srcArray[i];\n+\t    return dst;\n+\t  }\n+      }\n+\n+    Object dst = Array.newInstance(dstType.getComponentType(), len);\n+    System.arraycopy((Object)srcArray, 0, dst, 0, len);\n+    return dst;\n   }\n \n   public Object invoke(Object proxy, Method method, Object[] args)\n     throws Throwable\n   {\n     String methodName = method.getName().intern();\n+\n     if (args == null || args.length == 0)\n       {\n \tif (methodName == \"toString\")\n \t  {\n-\t    return toString(type, memberValues);\n+\t    return toString();\n \t  }\n \telse if (methodName == \"hashCode\")\n \t  {\n-\t    return Integer.valueOf(hashCode(type, memberValues));\n+\t    return Integer.valueOf(hashCode());\n \t  }\n \telse if (methodName == \"annotationType\")\n \t  {\n@@ -372,23 +413,27 @@ else if (methodName == \"annotationType\")\n \t      {\n \t\tthrow new IncompleteAnnotationException(type, methodName);\n \t      }\n-\t    if (! getBoxedReturnType(method).isInstance(val))\n+\t    try\n \t      {\n-\t\tthrow new AnnotationTypeMismatchException(method,\n-\t\t\t\t\t\t\t  val.getClass().getName());\n+\t\tif (val.getClass().isArray())\n+\t\t  val = coerce((Object[])val, method.getReturnType());\n \t      }\n-\t    if (val.getClass().isArray())\n+\t    catch (ArrayStoreException _)\n \t      {\n-\t\tval = arrayClone(val);\n+\t\tthrow new AnnotationTypeMismatchException\n+\t\t  (method, val.getClass().getName());\n \t      }\n+\t    if (! getBoxedReturnType(method).isInstance(val))\n+\t      throw (new AnnotationTypeMismatchException\n+\t\t     (method, val.getClass().getName()));\n \t    return val;\n \t  }\n       }\n     else if (args.length == 1)\n       {\n \tif (methodName == \"equals\")\n \t  {\n-\t    return Boolean.valueOf(equals(type, memberValues, args[0]));\n+\t    return Boolean.valueOf(equals(proxy, args[0]));\n \t  }\n       }\n     throw new InternalError(\"Invalid annotation proxy\");"}]}