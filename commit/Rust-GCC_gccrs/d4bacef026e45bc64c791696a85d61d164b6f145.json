{"sha": "d4bacef026e45bc64c791696a85d61d164b6f145", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRiYWNlZjAyNmU0NWJjNjRjNzkxNjk2YTg1ZDYxZDE2NGI2ZjE0NQ==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2009-02-10T00:13:34Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2009-02-10T00:13:34Z"}, "message": "rs6000.md (allocate_stack): Always use an update form instruction to update the stack back chain word...\n\n\t* config/rs6000/rs6000.md (allocate_stack): Always use an update\n\tform instruction to update the stack back chain word, even if the\n\tuser has disabled the generation of update instructions.\n\t(movdi_<mode>_update_stack): New.\n\t(movsi_update_stack): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_emit_allocate_stack): Likewise,\n\talways use an update form instruction to update the stack back\n\tchain word.\n\nFrom-SVN: r144047", "tree": {"sha": "c6f7e1f3fb1d6f6224050f23778321aa235e49ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c6f7e1f3fb1d6f6224050f23778321aa235e49ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4bacef026e45bc64c791696a85d61d164b6f145", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4bacef026e45bc64c791696a85d61d164b6f145", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4bacef026e45bc64c791696a85d61d164b6f145", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4bacef026e45bc64c791696a85d61d164b6f145/comments", "author": null, "committer": null, "parents": [{"sha": "48965b7c6d095bd06be35733d84dba0e016e206d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48965b7c6d095bd06be35733d84dba0e016e206d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48965b7c6d095bd06be35733d84dba0e016e206d"}], "stats": {"total": 148, "additions": 81, "deletions": 67}, "files": [{"sha": "47e81993a9ba92984d45ff98b7e6d4daa0df5aea", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bacef026e45bc64c791696a85d61d164b6f145/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bacef026e45bc64c791696a85d61d164b6f145/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d4bacef026e45bc64c791696a85d61d164b6f145", "patch": "@@ -1,3 +1,14 @@\n+2009-02-10  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* config/rs6000/rs6000.md (allocate_stack): Always use an update\n+\tform instruction to update the stack back chain word, even if the\n+\tuser has disabled the generation of update instructions.\n+\t(movdi_<mode>_update_stack): New.\n+\t(movsi_update_stack): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_emit_allocate_stack): Likewise,\n+\talways use an update form instruction to update the stack back\n+\tchain word.\n+\n 2009-02-09  Sebastian Pop  <sebastian.pop@amd.com>\n \n \tPR middle-end/38953"}, {"sha": "966a0f760c493105b0e70dfbcba9d82bf4a0b809", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 27, "deletions": 41, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bacef026e45bc64c791696a85d61d164b6f145/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bacef026e45bc64c791696a85d61d164b6f145/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=d4bacef026e45bc64c791696a85d61d164b6f145", "patch": "@@ -15542,6 +15542,7 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12, int copy_r11)\n   rtx stack_reg = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n   rtx tmp_reg = gen_rtx_REG (Pmode, 0);\n   rtx todec = gen_int_mode (-size, Pmode);\n+  rtx par, set, mem;\n \n   if (INTVAL (todec) != -size)\n     {\n@@ -15585,54 +15586,39 @@ rs6000_emit_allocate_stack (HOST_WIDE_INT size, int copy_r12, int copy_r11)\n \twarning (0, \"stack limit expression is not supported\");\n     }\n \n-  if (copy_r12 || copy_r11 || ! TARGET_UPDATE)\n+  if (copy_r12 || copy_r11)\n     emit_move_insn (copy_r11\n                     ? gen_rtx_REG (Pmode, 11)\n                     : gen_rtx_REG (Pmode, 12),\n                     stack_reg);\n \n-  if (TARGET_UPDATE)\n-    {\n-      rtx par, set, mem;\n-\n-      if (size > 32767)\n-\t{\n-\t  /* Need a note here so that try_split doesn't get confused.  */\n-\t  if (get_last_insn () == NULL_RTX)\n-\t    emit_note (NOTE_INSN_DELETED);\n-\t  insn = emit_move_insn (tmp_reg, todec);\n-\t  try_split (PATTERN (insn), insn, 0);\n-\t  todec = tmp_reg;\n-\t}\n-\n-      insn = emit_insn (TARGET_32BIT\n-\t\t\t? gen_movsi_update (stack_reg, stack_reg,\n-\t\t\t\t\t    todec, stack_reg)\n-\t\t\t: gen_movdi_di_update (stack_reg, stack_reg,\n-\t\t\t\t\t    todec, stack_reg));\n-      /* Since we didn't use gen_frame_mem to generate the MEM, grab\n-\t it now and set the alias set/attributes. The above gen_*_update\n-\t calls will generate a PARALLEL with the MEM set being the first\n-\t operation. */\n-      par = PATTERN (insn);\n-      gcc_assert (GET_CODE (par) == PARALLEL);\n-      set = XVECEXP (par, 0, 0);\n-      gcc_assert (GET_CODE (set) == SET);\n-      mem = SET_DEST (set);\n-      gcc_assert (MEM_P (mem));\n-      MEM_NOTRAP_P (mem) = 1;\n-      set_mem_alias_set (mem, get_frame_alias_set ());\n-    }\n-  else\n+  if (size > 32767)\n     {\n-      insn = emit_insn (TARGET_32BIT\n-\t\t\t? gen_addsi3 (stack_reg, stack_reg, todec)\n-\t\t\t: gen_adddi3 (stack_reg, stack_reg, todec));\n-      emit_move_insn (gen_frame_mem (Pmode, stack_reg),\n-\t\t      copy_r11\n-                      ? gen_rtx_REG (Pmode, 11)\n-                      : gen_rtx_REG (Pmode, 12));\n+      /* Need a note here so that try_split doesn't get confused.  */\n+      if (get_last_insn () == NULL_RTX)\n+\temit_note (NOTE_INSN_DELETED);\n+      insn = emit_move_insn (tmp_reg, todec);\n+      try_split (PATTERN (insn), insn, 0);\n+      todec = tmp_reg;\n     }\n+  \n+  insn = emit_insn (TARGET_32BIT\n+\t\t    ? gen_movsi_update_stack (stack_reg, stack_reg,\n+\t\t\t\t\ttodec, stack_reg)\n+\t\t    : gen_movdi_di_update_stack (stack_reg, stack_reg,\n+\t\t\t\t\t   todec, stack_reg));\n+  /* Since we didn't use gen_frame_mem to generate the MEM, grab\n+     it now and set the alias set/attributes. The above gen_*_update\n+     calls will generate a PARALLEL with the MEM set being the first\n+     operation. */\n+  par = PATTERN (insn);\n+  gcc_assert (GET_CODE (par) == PARALLEL);\n+  set = XVECEXP (par, 0, 0);\n+  gcc_assert (GET_CODE (set) == SET);\n+  mem = SET_DEST (set);\n+  gcc_assert (MEM_P (mem));\n+  MEM_NOTRAP_P (mem) = 1;\n+  set_mem_alias_set (mem, get_frame_alias_set ());\n \n   RTX_FRAME_RELATED_P (insn) = 1;\n   REG_NOTES (insn) ="}, {"sha": "ffbc8ad861e594fa564529aec40ecce45b19a2c1", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 43, "deletions": 26, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4bacef026e45bc64c791696a85d61d164b6f145/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4bacef026e45bc64c791696a85d61d164b6f145/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=d4bacef026e45bc64c791696a85d61d164b6f145", "patch": "@@ -10079,6 +10079,20 @@\n    stdu %3,%2(%0)\"\n   [(set_attr \"type\" \"store_ux,store_u\")])\n \n+;; This pattern is only conditional on TARGET_POWERPC64, as it is\n+;; needed for stack allocation, even if the user passes -mno-update.\n+(define_insn \"movdi_<mode>_update_stack\"\n+  [(set (mem:DI (plus:P (match_operand:P 1 \"gpc_reg_operand\" \"0,0\")\n+\t\t\t (match_operand:P 2 \"reg_or_aligned_short_operand\" \"r,I\")))\n+\t(match_operand:DI 3 \"gpc_reg_operand\" \"r,r\"))\n+   (set (match_operand:P 0 \"gpc_reg_operand\" \"=b,b\")\n+\t(plus:P (match_dup 1) (match_dup 2)))]\n+  \"TARGET_POWERPC64\"\n+  \"@\n+   stdux %3,%0,%2\n+   stdu %3,%2(%0)\"\n+  [(set_attr \"type\" \"store_ux,store_u\")])\n+\n (define_insn \"*movsi_update1\"\n   [(set (match_operand:SI 3 \"gpc_reg_operand\" \"=r,r\")\n \t(mem:SI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n@@ -10121,6 +10135,20 @@\n    {stu|stwu} %3,%2(%0)\"\n   [(set_attr \"type\" \"store_ux,store_u\")])\n \n+;; This is an unconditional pattern; needed for stack allocation, even\n+;; if the user passes -mno-update.\n+(define_insn \"movsi_update_stack\"\n+  [(set (mem:SI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n+\t\t\t (match_operand:SI 2 \"reg_or_short_operand\" \"r,I\")))\n+\t(match_operand:SI 3 \"gpc_reg_operand\" \"r,r\"))\n+   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=b,b\")\n+\t(plus:SI (match_dup 1) (match_dup 2)))]\n+  \"\"\n+  \"@\n+   {stux|stwux} %3,%0,%2\n+   {stu|stwu} %3,%2(%0)\"\n+  [(set_attr \"type\" \"store_ux,store_u\")])\n+\n (define_insn \"*movhi_update1\"\n   [(set (match_operand:HI 3 \"gpc_reg_operand\" \"=r,r\")\n \t(mem:HI (plus:SI (match_operand:SI 1 \"gpc_reg_operand\" \"0,0\")\n@@ -10543,6 +10571,7 @@\n { rtx chain = gen_reg_rtx (Pmode);\n   rtx stack_bot = gen_rtx_MEM (Pmode, stack_pointer_rtx);\n   rtx neg_op0;\n+  rtx insn, par, set, mem;\n \n   emit_move_insn (chain, stack_bot);\n \n@@ -10569,34 +10598,22 @@\n   else\n     neg_op0 = GEN_INT (- INTVAL (operands[1]));\n \n-  if (TARGET_UPDATE)\n-    {\n-      rtx insn, par, set, mem;\n-\n-      insn = emit_insn ((* ((TARGET_32BIT) ? gen_movsi_update\n-\t\t\t\t\t   : gen_movdi_di_update))\n+  insn = emit_insn ((* ((TARGET_32BIT) ? gen_movsi_update\n+\t\t\t\t       : gen_movdi_di_update))\n \t\t\t(stack_pointer_rtx, stack_pointer_rtx, neg_op0,\n \t\t\t chain));\n-      /* Since we didn't use gen_frame_mem to generate the MEM, grab\n-         it now and set the alias set/attributes. The above gen_*_update\n-         calls will generate a PARALLEL with the MEM set being the first\n-         operation. */\n-      par = PATTERN (insn);\n-      gcc_assert (GET_CODE (par) == PARALLEL);\n-      set = XVECEXP (par, 0, 0);\n-      gcc_assert (GET_CODE (set) == SET);\n-      mem = SET_DEST (set);\n-      gcc_assert (MEM_P (mem));\n-      MEM_NOTRAP_P (mem) = 1;\n-      set_mem_alias_set (mem, get_frame_alias_set ());\n-    }\n-\n-  else\n-    {\n-      emit_insn ((* ((TARGET_32BIT) ? gen_addsi3 : gen_adddi3))\n-\t\t (stack_pointer_rtx, stack_pointer_rtx, neg_op0));\n-      emit_move_insn (gen_frame_mem (Pmode, stack_pointer_rtx), chain);\n-    }\n+  /* Since we didn't use gen_frame_mem to generate the MEM, grab\n+     it now and set the alias set/attributes. The above gen_*_update\n+     calls will generate a PARALLEL with the MEM set being the first\n+     operation. */\n+  par = PATTERN (insn);\n+  gcc_assert (GET_CODE (par) == PARALLEL);\n+  set = XVECEXP (par, 0, 0);\n+  gcc_assert (GET_CODE (set) == SET);\n+  mem = SET_DEST (set);\n+  gcc_assert (MEM_P (mem));\n+  MEM_NOTRAP_P (mem) = 1;\n+  set_mem_alias_set (mem, get_frame_alias_set ());\n \n   emit_move_insn (operands[0], virtual_stack_dynamic_rtx);\n   DONE;"}]}