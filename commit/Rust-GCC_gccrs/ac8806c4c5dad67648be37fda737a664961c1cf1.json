{"sha": "ac8806c4c5dad67648be37fda737a664961c1cf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWM4ODA2YzRjNWRhZDY3NjQ4YmUzN2ZkYTczN2E2NjQ5NjFjMWNmMQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-04-10T21:03:18Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-06-17T08:14:02Z"}, "message": "[Ada] Optimize length checks generated for slice assignments\n\n2020-06-17  Eric Botcazou  <ebotcazou@adacore.com>\n\ngcc/ada/\n\n\t* exp_attr.adb (Expand_N_Attribute_Reference) <Attribute_First>:\n\tReplace it with a direct reference to an entity which is not a\n\tdiscriminant for constrained array types.  Add same condition\n\tfor scalar types.\n\t<Attribute_Last>: Merge with above implementation.\n\t* exp_ch4.adb (Optimize_Length_Comparison): Be prepared for a\n\tsecond entity whose length is compared.  Rename Prepare_64 to\n\tConvert_To_Long_Long_Integer.  If the second entity is present,\n\tcompute the difference of the 'First attributes and compare the\n\tsum of 'Last of the second entity with this difference against\n\t'Last of the first entity.  Add a special case when the 'First\n\tattributes are equal.  Suppress overflow checks in all cases.", "tree": {"sha": "b56ea64b687e7e1b195cc9f07e5ea1f3a65ec53f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b56ea64b687e7e1b195cc9f07e5ea1f3a65ec53f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ac8806c4c5dad67648be37fda737a664961c1cf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8806c4c5dad67648be37fda737a664961c1cf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac8806c4c5dad67648be37fda737a664961c1cf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac8806c4c5dad67648be37fda737a664961c1cf1/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "137adce3902d54bce9a21add8a9a898ec067deca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/137adce3902d54bce9a21add8a9a898ec067deca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/137adce3902d54bce9a21add8a9a898ec067deca"}], "stats": {"total": 287, "additions": 172, "deletions": 115}, "files": [{"sha": "51cda8299eced833776bec012aeb273a2e0534b0", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 46, "deletions": 52, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8806c4c5dad67648be37fda737a664961c1cf1/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8806c4c5dad67648be37fda737a664961c1cf1/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=ac8806c4c5dad67648be37fda737a664961c1cf1", "patch": "@@ -3398,42 +3398,75 @@ package body Exp_Attr is\n          Analyze_And_Resolve (N, Typ);\n       end Finalization_Size;\n \n-      -----------\n-      -- First --\n-      -----------\n-\n-      when Attribute_First =>\n+      -----------------\n+      -- First, Last --\n+      -----------------\n \n+      when Attribute_First\n+         | Attribute_Last\n+      =>\n          --  If the prefix type is a constrained packed array type which\n          --  already has a Packed_Array_Impl_Type representation defined, then\n-         --  replace this attribute with a direct reference to 'First of the\n-         --  appropriate index subtype (since otherwise the back end will try\n-         --  to give us the value of 'First for this implementation type).\n+         --  replace this attribute with a direct reference to the attribute of\n+         --  the appropriate index subtype (since otherwise the back end will\n+         --  try to give us the value of 'First for this implementation type).\n \n          if Is_Constrained_Packed_Array (Ptyp) then\n             Rewrite (N,\n               Make_Attribute_Reference (Loc,\n-                Attribute_Name => Name_First,\n+                Attribute_Name => Attribute_Name (N),\n                 Prefix         =>\n                   New_Occurrence_Of (Get_Index_Subtype (N), Loc)));\n             Analyze_And_Resolve (N, Typ);\n \n+         --  For a constrained array type, if the bound is a reference to an\n+         --  entity which is not a discriminant, just replace with a direct\n+         --  reference. Note that this must be in keeping with what is done\n+         --  for scalar types in order for range checks to be elided in loops.\n+\n+         elsif Is_Array_Type (Ptyp) and then Is_Constrained (Ptyp) then\n+            declare\n+               Bnd : Node_Id;\n+\n+            begin\n+               if Id = Attribute_First then\n+                  Bnd := Type_Low_Bound (Get_Index_Subtype (N));\n+               else\n+                  Bnd := Type_High_Bound (Get_Index_Subtype (N));\n+               end if;\n+\n+               if Is_Entity_Name (Bnd)\n+                 and then Ekind (Entity (Bnd)) /= E_Discriminant\n+               then\n+                  Rewrite (N, New_Occurrence_Of (Entity (Bnd), Loc));\n+               end if;\n+            end;\n+\n          --  For access type, apply access check as needed\n \n          elsif Is_Access_Type (Ptyp) then\n             Apply_Access_Check (N);\n \n-         --  For scalar type, if low bound is a reference to an entity, just\n+         --  For scalar type, if the bound is a reference to an entity, just\n          --  replace with a direct reference. Note that we can only have a\n          --  reference to a constant entity at this stage, anything else would\n          --  have already been rewritten.\n \n          elsif Is_Scalar_Type (Ptyp) then\n             declare\n-               Lo : constant Node_Id := Type_Low_Bound (Ptyp);\n+               Bnd : Node_Id;\n+\n             begin\n-               if Is_Entity_Name (Lo) then\n-                  Rewrite (N, New_Occurrence_Of (Entity (Lo), Loc));\n+               if Id = Attribute_First then\n+                  Bnd := Type_Low_Bound (Ptyp);\n+               else\n+                  Bnd := Type_High_Bound (Ptyp);\n+               end if;\n+\n+               if Is_Entity_Name (Bnd)\n+                 and then Ekind (Entity (Bnd)) /= E_Discriminant\n+               then\n+                  Rewrite (N, New_Occurrence_Of (Entity (Bnd), Loc));\n                end if;\n             end;\n          end if;\n@@ -4103,45 +4136,6 @@ package body Exp_Attr is\n \n          Analyze_And_Resolve (N);\n \n-      ----------\n-      -- Last --\n-      ----------\n-\n-      when Attribute_Last =>\n-\n-         --  If the prefix type is a constrained packed array type which\n-         --  already has a Packed_Array_Impl_Type representation defined, then\n-         --  replace this attribute with a direct reference to 'Last of the\n-         --  appropriate index subtype (since otherwise the back end will try\n-         --  to give us the value of 'Last for this implementation type).\n-\n-         if Is_Constrained_Packed_Array (Ptyp) then\n-            Rewrite (N,\n-              Make_Attribute_Reference (Loc,\n-                Attribute_Name => Name_Last,\n-                Prefix => New_Occurrence_Of (Get_Index_Subtype (N), Loc)));\n-            Analyze_And_Resolve (N, Typ);\n-\n-         --  For access type, apply access check as needed\n-\n-         elsif Is_Access_Type (Ptyp) then\n-            Apply_Access_Check (N);\n-\n-         --  For scalar type, if high bound is a reference to an entity, just\n-         --  replace with a direct reference. Note that we can only have a\n-         --  reference to a constant entity at this stage, anything else would\n-         --  have already been rewritten.\n-\n-         elsif Is_Scalar_Type (Ptyp) then\n-            declare\n-               Hi : constant Node_Id := Type_High_Bound (Ptyp);\n-            begin\n-               if Is_Entity_Name (Hi) then\n-                  Rewrite (N, New_Occurrence_Of (Entity (Hi), Loc));\n-               end if;\n-            end;\n-         end if;\n-\n       --------------\n       -- Last_Bit --\n       --------------"}, {"sha": "42979975721e8df4225bdad6c0d5e01dd338b70a", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 126, "deletions": 63, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac8806c4c5dad67648be37fda737a664961c1cf1/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac8806c4c5dad67648be37fda737a664961c1cf1/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=ac8806c4c5dad67648be37fda737a664961c1cf1", "patch": "@@ -226,9 +226,10 @@ package body Exp_Ch4 is\n \n    procedure Optimize_Length_Comparison (N : Node_Id);\n    --  Given an expression, if it is of the form X'Length op N (or the other\n-   --  way round), where N is known at compile time to be 0 or 1, and X is a\n-   --  simple entity, and op is a comparison operator, optimizes it into a\n-   --  comparison of First and Last.\n+   --  way round), where N is known at compile time to be 0 or 1, or something\n+   --  else where the value is known to be positive and in the 32-bit range,\n+   --  and X is a simple entity, and op is a comparison operator, optimizes it\n+   --  into a comparison of X'First and X'Last.\n \n    procedure Process_If_Case_Statements (N : Node_Id; Stmts : List_Id);\n    --  Inspect and process statement list Stmt of if or case expression N for\n@@ -13783,66 +13784,73 @@ package body Exp_Ch4 is\n       Comp : Node_Id;\n       --  Comparison operand, set only if Is_Zero is false\n \n-      Ent : Entity_Id := Empty;\n-      --  Entity whose length is being compared\n+      Ent : array (Pos range 1 .. 2) of Entity_Id := (Empty, Empty);\n+      --  Entities whose length is being compared\n \n-      Index : Node_Id := Empty;\n-      --  Integer_Literal node for length attribute expression, or Empty\n+      Index : array (Pos range 1 .. 2) of Node_Id := (Empty, Empty);\n+      --  Integer_Literal nodes for length attribute expressions, or Empty\n       --  if there is no such expression present.\n \n-      Ityp  : Entity_Id;\n-      --  Type of array index to which 'Length is applied\n-\n       Op : Node_Kind := Nkind (N);\n       --  Kind of comparison operator, gets flipped if operands backwards\n \n+      function Convert_To_Long_Long_Integer (N : Node_Id) return Node_Id;\n+      --  Given a discrete expression, returns a Long_Long_Integer typed\n+      --  expression representing the underlying value of the expression.\n+      --  This is done with an unchecked conversion to Long_Long_Integer.\n+      --  We use unchecked conversion to handle the enumeration type case.\n+\n       function Is_Optimizable (N : Node_Id) return Boolean;\n       --  Tests N to see if it is an optimizable comparison value (defined as\n       --  constant zero or one, or something else where the value is known to\n-      --  be positive and in the range of 32-bits, and where the corresponding\n-      --  Length value is also known to be 32-bits. If result is true, sets\n-      --  Is_Zero, Ityp, and Comp accordingly.\n+      --  be positive and in the range of 32 bits and where the corresponding\n+      --  Length value is also known to be 32 bits). If result is true, sets\n+      --  Is_Zero and Comp accordingly.\n \n-      function Is_Entity_Length (N : Node_Id) return Boolean;\n+      function Is_Entity_Length (N : Node_Id; Num : Pos) return Boolean;\n       --  Tests if N is a length attribute applied to a simple entity. If so,\n       --  returns True, and sets Ent to the entity, and Index to the integer\n       --  literal provided as an attribute expression, or to Empty if none.\n+      --  Num is the index designating the relevant slot in Ent and Index.\n       --  Also returns True if the expression is a generated type conversion\n       --  whose expression is of the desired form. This latter case arises\n       --  when Apply_Universal_Integer_Attribute_Check installs a conversion\n       --  to check for being in range, which is not needed in this context.\n       --  Returns False if neither condition holds.\n \n-      function Prepare_64 (N : Node_Id) return Node_Id;\n-      --  Given a discrete expression, returns a Long_Long_Integer typed\n-      --  expression representing the underlying value of the expression.\n-      --  This is done with an unchecked conversion to the result type. We\n-      --  use unchecked conversion to handle the enumeration type case.\n+      ----------------------------------\n+      -- Convert_To_Long_Long_Integer --\n+      ----------------------------------\n+\n+      function Convert_To_Long_Long_Integer (N : Node_Id) return Node_Id is\n+      begin\n+         return Unchecked_Convert_To (Standard_Long_Long_Integer, N);\n+      end Convert_To_Long_Long_Integer;\n \n       ----------------------\n       -- Is_Entity_Length --\n       ----------------------\n \n-      function Is_Entity_Length (N : Node_Id) return Boolean is\n+      function Is_Entity_Length (N : Node_Id; Num : Pos) return Boolean is\n       begin\n          if Nkind (N) = N_Attribute_Reference\n            and then Attribute_Name (N) = Name_Length\n            and then Is_Entity_Name (Prefix (N))\n          then\n-            Ent := Entity (Prefix (N));\n+            Ent (Num) := Entity (Prefix (N));\n \n             if Present (Expressions (N)) then\n-               Index := First (Expressions (N));\n+               Index (Num) := First (Expressions (N));\n             else\n-               Index := Empty;\n+               Index (Num) := Empty;\n             end if;\n \n             return True;\n \n          elsif Nkind (N) = N_Type_Conversion\n            and then not Comes_From_Source (N)\n          then\n-            return Is_Entity_Length (Expression (N));\n+            return Is_Entity_Length (Expression (N), Num);\n \n          else\n             return False;\n@@ -13859,6 +13867,8 @@ package body Exp_Ch4 is\n          Lo   : Uint;\n          Hi   : Uint;\n          Indx : Node_Id;\n+         Dbl  : Boolean;\n+         Ityp : Entity_Id;\n \n       begin\n          if Compile_Time_Known_Value (N) then\n@@ -13887,37 +13897,36 @@ package body Exp_Ch4 is\n             return False;\n          end if;\n \n+         --  Tests if N is also a length attribute applied to a simple entity\n+\n+         Dbl := Is_Entity_Length (N, 2);\n+\n          --  Comparison value was within range, so now we must check the index\n-         --  value to make sure it is also within 32-bits.\n+         --  value to make sure it is also within 32 bits.\n \n-         Indx := First_Index (Etype (Ent));\n+         for K in Pos range 1 .. 2 loop\n+            Indx := First_Index (Etype (Ent (K)));\n \n-         if Present (Index) then\n-            for J in 2 .. UI_To_Int (Intval (Index)) loop\n-               Next_Index (Indx);\n-            end loop;\n-         end if;\n+            if Present (Index (K)) then\n+               for J in 2 .. UI_To_Int (Intval (Index (K))) loop\n+                  Next_Index (Indx);\n+               end loop;\n+            end if;\n \n-         Ityp := Etype (Indx);\n+            Ityp := Etype (Indx);\n \n-         if Esize (Ityp) > 32 then\n-            return False;\n-         end if;\n+            if Esize (Ityp) > 32 then\n+               return False;\n+            end if;\n+\n+            exit when not Dbl;\n+         end loop;\n \n          Is_Zero := False;\n          Comp := N;\n          return True;\n       end Is_Optimizable;\n \n-      ----------------\n-      -- Prepare_64 --\n-      ----------------\n-\n-      function Prepare_64 (N : Node_Id) return Node_Id is\n-      begin\n-         return Unchecked_Convert_To (Standard_Long_Long_Integer, N);\n-      end Prepare_64;\n-\n    --  Start of processing for Optimize_Length_Comparison\n \n    begin\n@@ -13935,14 +13944,14 @@ package body Exp_Ch4 is\n \n       --  Ent'Length op 0/1\n \n-      if Is_Entity_Length (Left_Opnd (N))\n+      if Is_Entity_Length (Left_Opnd (N), 1)\n         and then Is_Optimizable (Right_Opnd (N))\n       then\n          null;\n \n       --  0/1 op Ent'Length\n \n-      elsif Is_Entity_Length (Right_Opnd (N))\n+      elsif Is_Entity_Length (Right_Opnd (N), 1)\n         and then Is_Optimizable (Left_Opnd (N))\n       then\n          --  Flip comparison to opposite sense\n@@ -14036,41 +14045,96 @@ package body Exp_Ch4 is\n \n       Left :=\n         Make_Attribute_Reference (Loc,\n-          Prefix         => New_Occurrence_Of (Ent, Loc),\n+          Prefix         => New_Occurrence_Of (Ent (1), Loc),\n           Attribute_Name => Name_First);\n \n-      if Present (Index) then\n-         Set_Expressions (Left, New_List (New_Copy (Index)));\n+      if Present (Index (1)) then\n+         Set_Expressions (Left, New_List (New_Copy (Index (1))));\n       end if;\n \n       --  If general value case, then do the addition of (n - 1), and\n       --  also add the needed conversions to type Long_Long_Integer.\n \n+      --  If n = Y'Length, we rewrite X'First + (n - 1) op X'Last into:\n+\n+      --    Y'Last + (X'First - Y'First) op X'Last\n+\n+      --  in the hope that X'First - Y'First can be computed statically.\n+\n       if Present (Comp) then\n-         Left :=\n-           Make_Op_Add (Loc,\n-             Left_Opnd  => Prepare_64 (Left),\n-             Right_Opnd =>\n-               Make_Op_Subtract (Loc,\n-                 Left_Opnd  => Prepare_64 (Comp),\n-                 Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+         if Present (Ent (2)) then\n+            declare\n+               Y_First : constant Node_Id :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => New_Occurrence_Of (Ent (2), Loc),\n+                   Attribute_Name => Name_First);\n+               Y_Last : constant Node_Id :=\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => New_Occurrence_Of (Ent (2), Loc),\n+                   Attribute_Name => Name_Last);\n+               R : Compare_Result;\n+\n+            begin\n+               if Present (Index (2)) then\n+                  Set_Expressions (Y_First, New_List (New_Copy (Index (2))));\n+                  Set_Expressions (Y_Last,  New_List (New_Copy (Index (2))));\n+               end if;\n+\n+               Analyze (Left);\n+               Analyze (Y_First);\n+\n+               --  If X'First = Y'First, rewrite it into a direct comparison\n+               --  of Y'Last and X'Last without conversions.\n+\n+               R := Compile_Time_Compare (Left, Y_First, Assume_Valid => True);\n+\n+               if R = EQ then\n+                  Left := Y_Last;\n+                  Comp := Empty;\n+\n+               --  Otherwise, use the above formula\n+\n+               else\n+                  Left :=\n+                    Make_Op_Add (Loc,\n+                      Left_Opnd  => Convert_To_Long_Long_Integer (Y_Last),\n+                      Right_Opnd =>\n+                        Make_Op_Subtract (Loc,\n+                          Left_Opnd  =>\n+                            Convert_To_Long_Long_Integer (Left),\n+                          Right_Opnd =>\n+                            Convert_To_Long_Long_Integer (Y_First)));\n+               end if;\n+            end;\n+\n+         --  General value case\n+\n+         else\n+            Left :=\n+              Make_Op_Add (Loc,\n+                Left_Opnd  => Convert_To_Long_Long_Integer (Left),\n+                Right_Opnd =>\n+                  Make_Op_Subtract (Loc,\n+                    Left_Opnd  => Convert_To_Long_Long_Integer (Comp),\n+                    Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+         end if;\n       end if;\n \n       --  Build the Last reference we will use\n \n       Right :=\n         Make_Attribute_Reference (Loc,\n-          Prefix         => New_Occurrence_Of (Ent, Loc),\n+          Prefix         => New_Occurrence_Of (Ent (1), Loc),\n           Attribute_Name => Name_Last);\n \n-      if Present (Index) then\n-         Set_Expressions (Right, New_List (New_Copy (Index)));\n+      if Present (Index (1)) then\n+         Set_Expressions (Right, New_List (New_Copy (Index (1))));\n       end if;\n \n       --  If general operand, convert Last reference to Long_Long_Integer\n \n       if Present (Comp) then\n-         Right := Prepare_64 (Right);\n+         Right := Convert_To_Long_Long_Integer (Right);\n       end if;\n \n       --  Check for cases to optimize\n@@ -14147,11 +14211,10 @@ package body Exp_Ch4 is\n          raise Program_Error;\n       end if;\n \n-      --  Rewrite and finish up\n+      --  Rewrite and finish up (we can suppress overflow checks, see above)\n \n       Rewrite (N, Result);\n-      Analyze_And_Resolve (N, Typ);\n-      return;\n+      Analyze_And_Resolve (N, Typ, Suppress => Overflow_Check);\n    end Optimize_Length_Comparison;\n \n    --------------------------------"}]}