{"sha": "5904dc87e536fcf05c9135b23370527577c7951e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTkwNGRjODdlNTM2ZmNmMDVjOTEzNWIyMzM3MDUyNzU3N2M3OTUxZQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2002-01-20T23:48:11Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-01-20T23:48:11Z"}, "message": "i370.c: Fix comment formatting.\n\n\t* config/i370/i370.c: Fix comment formatting.\n\t* config/i370/i370.h: Likewise.\n\t* config/i370/i370.md: Likewise.\n\t* config/i370/linux.h: Likewise.\n\nFrom-SVN: r49023", "tree": {"sha": "1ac58b9768e74584652f3bfe22c428d00149a6dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1ac58b9768e74584652f3bfe22c428d00149a6dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5904dc87e536fcf05c9135b23370527577c7951e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5904dc87e536fcf05c9135b23370527577c7951e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5904dc87e536fcf05c9135b23370527577c7951e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5904dc87e536fcf05c9135b23370527577c7951e/comments", "author": null, "committer": null, "parents": [{"sha": "9702143f274f9dbaa4eecb55540b6e952a6903ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9702143f274f9dbaa4eecb55540b6e952a6903ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9702143f274f9dbaa4eecb55540b6e952a6903ad"}], "stats": {"total": 63, "additions": 35, "deletions": 28}, "files": [{"sha": "a266fa0b064394af144fcfb3f5d01f1688aa0c37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5904dc87e536fcf05c9135b23370527577c7951e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5904dc87e536fcf05c9135b23370527577c7951e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5904dc87e536fcf05c9135b23370527577c7951e", "patch": "@@ -1,3 +1,10 @@\n+2002-01-20  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* config/i370/i370.c: Fix comment formatting.\n+\t* config/i370/i370.h: Likewise.\n+\t* config/i370/i370.md: Likewise.\n+\t* config/i370/linux.h: Likewise.\n+\n Sun Jan 20 18:40:14 2002  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* dwarf2out.c (loc_descriptor_from_tree): Add TRUTH_*_EXPR cases."}, {"sha": "5ee6b23995173492180432373a8db805007e946d", "filename": "gcc/config/i370/i370.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5904dc87e536fcf05c9135b23370527577c7951e/gcc%2Fconfig%2Fi370%2Fi370.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5904dc87e536fcf05c9135b23370527577c7951e/gcc%2Fconfig%2Fi370%2Fi370.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.c?ref=5904dc87e536fcf05c9135b23370527577c7951e", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for System/370.\n-   Copyright (C) 1989, 1993, 1995, 1997, 1998, 1999, 2000\n+   Copyright (C) 1989, 1993, 1995, 1997, 1998, 1999, 2000, 2002\n    Free Software Foundation, Inc.\n    Contributed by Jan Stein (jan@cd.chalmers.se).\n    Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n@@ -52,7 +52,7 @@ extern FILE *asm_out_file;\n    The first_ref_page is the page on which the true first ref appears.\n    The label_addr is an estimate of its location in the current routine,\n    The label_first & last_ref are estimates of where the earliest and\n-      latest references to this label occur.                                     */\n+      latest references to this label occur.  */\n \n typedef struct label_node\n   {\n@@ -442,7 +442,7 @@ i370_label_scan ()\n        here += tablejump_offset;\n        INSN_ADDRESSES (INSN_UID (insn)) = here;\n \n-       /* check to see if this insn is a label ... */\n+       /* check to see if this insn is a label ...  */\n        if (CODE_LABEL == code)\n          {\n            int labelno = CODE_LABEL_NUMBER (insn);\n@@ -469,7 +469,7 @@ i370_label_scan ()\n \n            /* If there is no label for this jump, then this\n               had better be a ADDR_VEC or an ADDR_DIFF_VEC\n-              and there had better be a vector of labels.   */\n+              and there had better be a vector of labels.  */\n            if (!label) \n              {\n                int j;\n@@ -610,7 +610,7 @@ mvs_get_label (id)\n {\n   label_node_t *lp;\n \n-  /* first, lets see if we already go one, if so, use that. */\n+  /* first, lets see if we already go one, if so, use that.  */\n   for (lp = label_anchor; lp; lp = lp->label_next)\n     {\n       if (lp->label_id == id) return lp;\n@@ -655,7 +655,7 @@ mvs_add_label (id)\n   if ((-1 != lp->first_ref_page) && \n       (lp->first_ref_page != mvs_page_num)) \n     {\n-      /* Yep; the first label_ref was on a different page. */\n+      /* Yep; the first label_ref was on a different page.  */\n       mvs_need_base_reload ++;\n       return;\n     }\n@@ -776,7 +776,7 @@ mvs_check_page (file, code, lit)\n       fprintf (assembler_source, \"\\tDROP\\t%d\\n\", BASE_REGISTER);\n       mvs_page_num++;\n       /* Safe to use BASR not BALR, since we are\n-       * not switching addressing mode here ... */\n+       * not switching addressing mode here ...  */\n       fprintf (assembler_source, \"\\tBASR\\t%d,0\\n\", BASE_REGISTER);\n       fprintf (assembler_source, \"PG%d\\tEQU\\t*\\n\", mvs_page_num);\n       fprintf (assembler_source, \"\\tUSING\\t*,%d\\n\", BASE_REGISTER);\n@@ -812,7 +812,7 @@ mvs_check_page (file, code, lit)\n       fprintf (assembler_source, \"\\t.LTORG\\n\");\n       fprintf (assembler_source, \"\\t.balign\\t4\\n\");\n \n-      /* we continue execution here ... */\n+      /* we continue execution here ...  */\n       fprintf (assembler_source, \".LPGE%d:\\n\", mvs_page_num);\n       fprintf (assembler_source, \"\\t.DROP\\t%d\\n\", BASE_REGISTER);\n       mvs_page_num++;\n@@ -863,7 +863,7 @@ mvs_function_check (name)\n   return 0;\n }\n \n-/* Generate a hash for a given key. */\n+/* Generate a hash for a given key.  */\n \n #ifdef LONGEXTERNAL\n static int\n@@ -1460,7 +1460,7 @@ i370_output_function_prologue (f, frame_size)\n \n   fprintf (f, \"\\t.using\\t.,r15\\n\");\n \n-  /* Branch to exectuable part of prologue. */\n+  /* Branch to exectuable part of prologue.  */\n   fprintf (f, \"\\tB\\t.LFENT%03d\\n\", function_label_index);\n \n   /* write the length of the stackframe */\n@@ -1483,7 +1483,7 @@ i370_output_function_prologue (f, frame_size)\n   fprintf (f, \"\\tLR\\tr11,r2\\n\");\n \n   /* store callee stack pointer at 8(sp) */\n-  /* fprintf (f, \"\\tST\\tsp,8(,r3)\\n \");  wasted cycles, no one uses this ... */\n+  /* fprintf (f, \"\\tST\\tsp,8(,r3)\\n \");  wasted cycles, no one uses this ...  */\n \n   /* backchain -- store caller sp at 4(callee_sp)  */\n   fprintf (f, \"\\tST\\tr3,4(,sp)\\n \");\n@@ -1517,7 +1517,7 @@ i370_output_function_prologue (f, frame_size)\n    The function epilogue should not depend on the current stack\n    pointer!  It should use the frame pointer only.  This is mandatory\n    because of alloca; we also take advantage of it to omit stack\n-   adjustments before returning. */\n+   adjustments before returning.  */\n \n static void\n i370_output_function_epilogue (file, l)"}, {"sha": "145f115241d092000ce1ff7bc388b935247c9196", "filename": "gcc/config/i370/i370.h", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5904dc87e536fcf05c9135b23370527577c7951e/gcc%2Fconfig%2Fi370%2Fi370.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5904dc87e536fcf05c9135b23370527577c7951e/gcc%2Fconfig%2Fi370%2Fi370.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.h?ref=5904dc87e536fcf05c9135b23370527577c7951e", "patch": "@@ -997,7 +997,7 @@ enum reg_class\n \t      case MULT:  /* case UMULT: */ case DIV:      case UDIV: \t\\\n               /* and, or and xor set the cc's the wrong way !! */\t\\\n \t      case AND:   case IOR:    case XOR:  \t\t\t\\\n-              /* some shifts set the CC some don't. */\t\t\t\\\n+              /* some shifts set the CC some don't.  */\t\t\t\\\n               case ASHIFT: \t case ASHIFTRT:  \t\t\t\\\n                  do {} while (0);\t\t\t\t\t\\\n               default:\t\t\t\t\t\t\t\\\n@@ -1128,7 +1128,7 @@ enum reg_class\n \n /* Generate case label.  For HLASM we can change to the data CSECT\n    and put the vectors out of the code body. The assembler just\n-   concatenates CSECTs with the same name. */\n+   concatenates CSECTs with the same name.  */\n \n #define ASM_OUTPUT_CASE_LABEL(FILE, PREFIX, NUM, TABLE)\t\t\t\\\n   fprintf (FILE, \"\\tDS\\t0F\\n\");                                         \\\n@@ -1286,7 +1286,7 @@ enum reg_class\n \n /* Print operand XV (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and XV is null. */\n+   For `%' followed by punctuation, CODE is the punctuation and XV is null.  */\n \n #define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -1575,7 +1575,7 @@ enum reg_class\n \n /* Print operand XV (an rtx) in assembler syntax to file FILE.\n    CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n-   For `%' followed by punctuation, CODE is the punctuation and XV is null. */\n+   For `%' followed by punctuation, CODE is the punctuation and XV is null.  */\n \n #define PRINT_OPERAND(FILE, XV, CODE)\t\t\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -1690,7 +1690,7 @@ enum reg_class\n \t\tmvs_page_lit += 8;\t\t\t\t\t\\\n \t\tfprintf (FILE, \"=D'%s'\", buf);\t\t\t\t\\\n \t      }\t\t\t\t\t\t\t\t\\\n-\t    else /* VOIDmode !?!? strange but true ... */\t\t\\\n+\t    else /* VOIDmode !?!? strange but true ...  */\t\t\\\n \t      {\t\t\t\t\t\t\t\t\\\n \t\tmvs_page_lit += 8;\t\t\t\t\t\\\n \t\tfprintf (FILE, \"=XL8'%08X%08X'\", \t\t\t\\\n@@ -1855,7 +1855,7 @@ abort(); \\\n \n /* Generate internal label.  Since we can branch here from off page, we\n    must reload the base register.  Note that internal labels are generated\n-   for loops, goto's and case labels.   */\n+   for loops, goto's and case labels.  */\n #undef ASM_OUTPUT_INTERNAL_LABEL\n #define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM) \t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -1897,7 +1897,7 @@ abort(); \\\n    count is in %cl.  Some assemblers require %cl as an argument;\n    some don't.\n \n-   GAS requires the %cl argument, so override i386/unix.h. */\n+   GAS requires the %cl argument, so override i386/unix.h.  */\n \n #undef SHIFT_DOUBLE_OMITS_COUNT\n #define SHIFT_DOUBLE_OMITS_COUNT 0"}, {"sha": "9564cb3001ebbb7a7844f1945ba7209538c4c3e0", "filename": "gcc/config/i370/i370.md", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5904dc87e536fcf05c9135b23370527577c7951e/gcc%2Fconfig%2Fi370%2Fi370.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5904dc87e536fcf05c9135b23370527577c7951e/gcc%2Fconfig%2Fi370%2Fi370.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Fi370.md?ref=5904dc87e536fcf05c9135b23370527577c7951e", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for GNU compiler -- System/370 version.\n-;;  Copyright (C) 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000\n+;;  Copyright (C) 1989, 1993, 1994, 1995, 1997, 1998, 1999, 2000, 2002\n ;;  Free Software Foundation, Inc.\n ;;  Contributed by Jan Stein (jan@cd.chalmers.se).\n ;;  Modified for OS/390 LanguageEnvironment C by Dave Pitts (dpitts@cozx.com)\n@@ -168,7 +168,7 @@\n   check_label_emit ();\n   if (REG_P (operands[0]))\n     {\n-      /* an unsigned compare to zero is always zero/not-zero... */\n+      /* an unsigned compare to zero is always zero/not-zero...  */\n       mvs_check_page (0, 4, 4);\n       return \\\"N\t%0,=XL4'000000FF'\\\";\n     }\n@@ -187,7 +187,7 @@\n   check_label_emit ();\n   if (unsigned_jump_follows_p (insn))\n     {\n-      /* an unsigned compare to zero is always zero/not-zero... */\n+      /* an unsigned compare to zero is always zero/not-zero...  */\n       mvs_check_page (0, 4, 4);\n       return \\\"N\t%0,=XL4'000000FF'\\\";\n     }\n@@ -1683,7 +1683,7 @@ check_label_emit ();\n   \"*\n {\n   check_label_emit ();\n-  /* AND only sets zero/not-zero bits not the arithmetic bits ... */\n+  /* AND only sets zero/not-zero bits not the arithmetic bits ...  */\n   CC_STATUS_INIT;\n   mvs_check_page (0, 4, 4);\n   return \\\"N\t%1,=XL4'0000FFFF'\\\";\n@@ -1704,7 +1704,7 @@ check_label_emit ();\n   check_label_emit ();\n   if (REG_P (operands[1]))\n     {\n-      /* AND only sets zero/not-zero bits not the arithmetic bits ... */\n+      /* AND only sets zero/not-zero bits not the arithmetic bits ...  */\n       CC_STATUS_INIT;\n       mvs_check_page (0, 4, 4);\n       return \\\"N\t%0,=XL4'000000FF'\\\";\n@@ -1734,7 +1734,7 @@ check_label_emit ();\n   check_label_emit ();\n   if (REG_P (operands[1]))\n     {\n-      /* AND only sets zero/not-zero bits not the arithmetic bits ... */\n+      /* AND only sets zero/not-zero bits not the arithmetic bits ...  */\n       CC_STATUS_INIT;\n       mvs_check_page (0, 4, 4);\n       return \\\"N\t%0,=XL4'000000FF'\\\";"}, {"sha": "72c66189648fb38b337e3a6274c0c46716bc4351", "filename": "gcc/config/i370/linux.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5904dc87e536fcf05c9135b23370527577c7951e/gcc%2Fconfig%2Fi370%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5904dc87e536fcf05c9135b23370527577c7951e/gcc%2Fconfig%2Fi370%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi370%2Flinux.h?ref=5904dc87e536fcf05c9135b23370527577c7951e", "patch": "@@ -30,10 +30,10 @@ Boston, MA 02111-1307, USA.  */\n \n \n /* hack alert define to get dbx/gdb/dwarf to compile  */\n-/* problem is that host float format is not target float format. */\n+/* problem is that host float format is not target float format.  */\n /* define REAL_ARITHMETIC for software emulation of float to\n  * int conversion.  This seems to have somethings to do with \n- * cross-compiling ... */\n+ * cross-compiling ...  */\n #define REAL_ARITHMETIC\n \n /* Include system common definitions */\n@@ -45,7 +45,7 @@ Boston, MA 02111-1307, USA.  */\n #undef CPP_PREDEFINES\n #define CPP_PREDEFINES \"-DGCC -Dgcc -D__ELF__ -Dunix -Dlinux -Asystem=posix -Acpu=i370 -Amachine=i370\"\n \n-/* Options for this target machine. */\n+/* Options for this target machine.  */\n \n #define LIBGCC_SPEC \"libgcc.a%s\"\n "}]}