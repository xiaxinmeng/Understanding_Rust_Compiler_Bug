{"sha": "dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMwZmYxYzgwMmVmOGE5ZTgwNzVlNWE4ZjRkYTk4ODE4NDhlMDhhYg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-07-28T18:45:20Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-07-28T18:45:20Z"}, "message": "rtlanal.c (tablejump_p): False for returns.\n\n\t* rtlanal.c (tablejump_p): False for returns.\n\t* reorg.c (first_active_target_insn): New static function.\n\t(find_end_label): Set JUMP_LABEL for a new returnjump.\n\t(optimize_skip, get_jump_flags, rare_destination,\n\tmostly_true_jump, get_branch_condition,\n\tsteal_delay_list_from_target, own_thread_p,\n\tfill_simple_delay_slots, follow_jumps, fill_slots_from_thread,\n\tfill_eager_delay_slots, relax_delay_slots, make_return_insns,\n\tdbr_schedule): Adjust to handle ret_rtx in JUMP_LABELs.\n\t* jump.c (delete_related_insns): Likewise.\n\t(jump_to_label_p): New function.\n\t(redirect_target): New static function.\n\t(redirect_exp_1): Use it.  Adjust to handle ret_rtx in JUMP_LABELS.\n\t(redirect_jump_1): Assert that the new label is nonnull.\n\t(redirect_jump): Likewise.\n\t(redirect_jump_2): Check for ANY_RETURN_P rather than NULL labels.\n\t* ifcvt.c (find_if_case_1): Take care when redirecting jumps to the\n\texit block.\n\t(dead_or_predicable): Change NEW_DEST arg to DEST_EDGE.  All callers\n\tchanged.  Ensure that the right label is passed to redirect_jump.\n\t* function.c (emit_return_into_block,\n\tthread_prologue_and_epilogue_insns): Ensure new returnjumps have\n\tret_rtx in their JUMP_LABEL.\n\t* print-rtl.c (print_rtx): Handle ret_rtx in a JUMP_LABEL.\n\t* emit-rtl.c (skip_consecutive_labels): Allow the caller to\n\tpass ret_rtx as label.\n\t* cfglayout.c (fixup_reorder_chain): Use\n\tforce_nonfallthru_and_redirect rather than force_nonfallthru.\n\t(duplicate_insn_chain): Copy JUMP_LABELs for returns.\n\t* rtl.h (ANY_RETURN_P): New macro.\n\t(jump_to_label_p): Declare.\n\t* resource.c (find_dead_or_set_registers): Handle ret_rtx in\n\tJUMP_LABELs.\n\t(mark_target_live_regs): Likewise.\n\t* basic-block.h (force_nonfallthru_and_redirect): Declare.\n\t* cfgrtl.c (force_nonfallthru_and_redirect): No longer static.\n\t* config/alpha/alpha.c (alpha_tablejump_addr_vec,\n\talpha_tablejump_best_label): Remove functions.\n\t* config/alpha/alpha-protos.c (alpha_tablejump_addr_vec,\n\talpha_tablejump_best_label): Remove declarations.\n\t* config/sh/sh.c (barrier_align, split_branches): Adjust for\n\tret_rtx in JUMP_LABELs.\n\t* config/arm/arm.c (is_jump_table): Likewise.\n\nFrom-SVN: r176881", "tree": {"sha": "05341594c41a09d1c77b0330d5b66b0fcb4a9821", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/05341594c41a09d1c77b0330d5b66b0fcb4a9821"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/comments", "author": null, "committer": null, "parents": [{"sha": "a2e49bb27eba6fe675e6a6ceac8c2041218792e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2e49bb27eba6fe675e6a6ceac8c2041218792e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2e49bb27eba6fe675e6a6ceac8c2041218792e5"}], "stats": {"total": 392, "additions": 227, "deletions": 165}, "files": [{"sha": "8b6111e6630ea73705f39c01c52ecdd6e601aaa9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -1,3 +1,49 @@\n+2011-07-28  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* rtlanal.c (tablejump_p): False for returns.\n+\t* reorg.c (first_active_target_insn): New static function.\n+\t(find_end_label): Set JUMP_LABEL for a new returnjump.\n+\t(optimize_skip, get_jump_flags, rare_destination,\n+\tmostly_true_jump, get_branch_condition,\n+\tsteal_delay_list_from_target, own_thread_p,\n+\tfill_simple_delay_slots, follow_jumps, fill_slots_from_thread,\n+\tfill_eager_delay_slots, relax_delay_slots, make_return_insns,\n+\tdbr_schedule): Adjust to handle ret_rtx in JUMP_LABELs.\n+\t* jump.c (delete_related_insns): Likewise.\n+\t(jump_to_label_p): New function.\n+\t(redirect_target): New static function.\n+\t(redirect_exp_1): Use it.  Adjust to handle ret_rtx in JUMP_LABELS.\n+\t(redirect_jump_1): Assert that the new label is nonnull.\n+\t(redirect_jump): Likewise.\n+\t(redirect_jump_2): Check for ANY_RETURN_P rather than NULL labels.\n+\t* ifcvt.c (find_if_case_1): Take care when redirecting jumps to the\n+\texit block.\n+\t(dead_or_predicable): Change NEW_DEST arg to DEST_EDGE.  All callers\n+\tchanged.  Ensure that the right label is passed to redirect_jump.\n+\t* function.c (emit_return_into_block,\n+\tthread_prologue_and_epilogue_insns): Ensure new returnjumps have\n+\tret_rtx in their JUMP_LABEL.\n+\t* print-rtl.c (print_rtx): Handle ret_rtx in a JUMP_LABEL.\n+\t* emit-rtl.c (skip_consecutive_labels): Allow the caller to\n+\tpass ret_rtx as label.\n+\t* cfglayout.c (fixup_reorder_chain): Use\n+\tforce_nonfallthru_and_redirect rather than force_nonfallthru.\n+\t(duplicate_insn_chain): Copy JUMP_LABELs for returns.\n+\t* rtl.h (ANY_RETURN_P): New macro.\n+\t(jump_to_label_p): Declare.\n+\t* resource.c (find_dead_or_set_registers): Handle ret_rtx in\n+\tJUMP_LABELs.\n+\t(mark_target_live_regs): Likewise.\n+\t* basic-block.h (force_nonfallthru_and_redirect): Declare.\n+\t* cfgrtl.c (force_nonfallthru_and_redirect): No longer static.\n+\t* config/alpha/alpha.c (alpha_tablejump_addr_vec,\n+\talpha_tablejump_best_label): Remove functions.\n+\t* config/alpha/alpha-protos.c (alpha_tablejump_addr_vec,\n+\talpha_tablejump_best_label): Remove declarations.\n+\t* config/sh/sh.c (barrier_align, split_branches): Adjust for\n+\tret_rtx in JUMP_LABELs.\n+\t* config/arm/arm.c (is_jump_table): Likewise.\n+\n 2011-07-28  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/predicates.md (pic_32bit_opreand): Do not define as"}, {"sha": "41c35697a5f83c83da9418413a83708065585037", "filename": "gcc/basic-block.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -804,6 +804,7 @@ extern rtx block_label (basic_block);\n extern bool purge_all_dead_edges (void);\n extern bool purge_dead_edges (basic_block);\n extern bool fixup_abnormal_edges (void);\n+extern basic_block force_nonfallthru_and_redirect (edge, basic_block);\n \n /* In cfgbuild.c.  */\n extern void find_many_sub_basic_blocks (sbitmap);"}, {"sha": "c62138f6d88252ca10ac759da2026b324bcdbbe0", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -899,7 +899,7 @@ fixup_reorder_chain (void)\n \t Note force_nonfallthru can delete E_FALL and thus we have to\n \t save E_FALL->src prior to the call to force_nonfallthru.  */\n       src_bb = e_fall->src;\n-      nb = force_nonfallthru (e_fall);\n+      nb = force_nonfallthru_and_redirect (e_fall, e_fall->dest);\n       if (nb)\n \t{\n \t  nb->il.rtl->visited = 1;\n@@ -1195,6 +1195,9 @@ duplicate_insn_chain (rtx from, rtx to)\n \t      break;\n \t    }\n \t  copy = emit_copy_of_insn_after (insn, get_last_insn ());\n+\t  if (JUMP_P (insn) && JUMP_LABEL (insn) != NULL_RTX\n+\t      && ANY_RETURN_P (JUMP_LABEL (insn)))\n+\t    JUMP_LABEL (copy) = JUMP_LABEL (insn);\n           maybe_copy_prologue_epilogue_insn (insn, copy);\n \t  break;\n "}, {"sha": "69377957cd6df13fc8870119f5fc273d59af8cd7", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -1119,7 +1119,7 @@ rtl_redirect_edge_and_branch (edge e, basic_block target)\n /* Like force_nonfallthru below, but additionally performs redirection\n    Used by redirect_edge_and_branch_force.  */\n \n-static basic_block\n+basic_block\n force_nonfallthru_and_redirect (edge e, basic_block target)\n {\n   basic_block jump_block, new_bb = NULL, src = e->src;"}, {"sha": "13b5ce936b8543df6f108e1fef8dad419b694f3f", "filename": "gcc/config/alpha/alpha-protos.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fconfig%2Falpha%2Falpha-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha-protos.h?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -31,9 +31,6 @@ extern void alpha_expand_prologue (void);\n extern void alpha_expand_epilogue (void);\n extern void alpha_output_filename (FILE *, const char *);\n \n-extern rtx alpha_tablejump_addr_vec (rtx);\n-extern rtx alpha_tablejump_best_label (rtx);\n-\n extern bool alpha_legitimate_constant_p (enum machine_mode, rtx);\n extern rtx alpha_legitimize_reload_address (rtx, enum machine_mode,\n \t\t\t\t\t    int, int, int);"}, {"sha": "e390075f102daaf8d26e3518228e218e328c89ce", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -571,59 +571,6 @@ direct_return (void)\n \t  && crtl->args.pretend_args_size == 0);\n }\n \n-/* Return the ADDR_VEC associated with a tablejump insn.  */\n-\n-rtx\n-alpha_tablejump_addr_vec (rtx insn)\n-{\n-  rtx tmp;\n-\n-  tmp = JUMP_LABEL (insn);\n-  if (!tmp)\n-    return NULL_RTX;\n-  tmp = NEXT_INSN (tmp);\n-  if (!tmp)\n-    return NULL_RTX;\n-  if (JUMP_P (tmp)\n-      && GET_CODE (PATTERN (tmp)) == ADDR_DIFF_VEC)\n-    return PATTERN (tmp);\n-  return NULL_RTX;\n-}\n-\n-/* Return the label of the predicted edge, or CONST0_RTX if we don't know.  */\n-\n-rtx\n-alpha_tablejump_best_label (rtx insn)\n-{\n-  rtx jump_table = alpha_tablejump_addr_vec (insn);\n-  rtx best_label = NULL_RTX;\n-\n-  /* ??? Once the CFG doesn't keep getting completely rebuilt, look\n-     there for edge frequency counts from profile data.  */\n-\n-  if (jump_table)\n-    {\n-      int n_labels = XVECLEN (jump_table, 1);\n-      int best_count = -1;\n-      int i, j;\n-\n-      for (i = 0; i < n_labels; i++)\n-\t{\n-\t  int count = 1;\n-\n-\t  for (j = i + 1; j < n_labels; j++)\n-\t    if (XEXP (XVECEXP (jump_table, 1, i), 0)\n-\t\t== XEXP (XVECEXP (jump_table, 1, j), 0))\n-\t      count++;\n-\n-\t  if (count > best_count)\n-\t    best_count = count, best_label = XVECEXP (jump_table, 1, i);\n-\t}\n-    }\n-\n-  return best_label ? best_label : const0_rtx;\n-}\n-\n /* Return the TLS model to use for SYMBOL.  */\n \n static enum tls_model"}, {"sha": "4193515b3421115e00a1ca02f4ff70ae94b7c1d1", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -11477,8 +11477,7 @@ is_jump_table (rtx insn)\n {\n   rtx table;\n \n-  if (GET_CODE (insn) == JUMP_INSN\n-      && JUMP_LABEL (insn) != NULL\n+  if (jump_to_label_p (insn)\n       && ((table = next_real_insn (JUMP_LABEL (insn)))\n \t  == next_real_insn (insn))\n       && table != NULL"}, {"sha": "31d9cfce3ef6536da3472ac6bd0042fb7c3c27d4", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -5274,9 +5274,7 @@ barrier_align (rtx barrier_or_label)\n \t    slot = 0;\n \t  credit -= get_attr_length (prev);\n \t}\n-      if (prev\n-\t  && JUMP_P (prev)\n-\t  && JUMP_LABEL (prev))\n+      if (prev && jump_to_label_p (prev))\n \t{\n \t  rtx x;\n \t  if (jump_to_next\n@@ -5975,7 +5973,7 @@ split_branches (rtx first)\n \t\t\tJUMP_LABEL (insn) = far_label;\n \t\t\tLABEL_NUSES (far_label)++;\n \t\t      }\n-\t\t    redirect_jump (insn, NULL_RTX, 1);\n+\t\t    redirect_jump (insn, ret_rtx, 1);\n \t\t    far_label = 0;\n \t\t  }\n \t      }"}, {"sha": "99b02bae315eefb4966fe7259c163c0431d4101c", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -3322,14 +3322,17 @@ prev_label (rtx insn)\n   return insn;\n }\n \n-/* Return the last label to mark the same position as LABEL.  Return null\n-   if LABEL itself is null.  */\n+/* Return the last label to mark the same position as LABEL.  Return LABEL\n+   itself if it is null or any return rtx.  */\n \n rtx\n skip_consecutive_labels (rtx label)\n {\n   rtx insn;\n \n+  if (label && ANY_RETURN_P (label))\n+    return label;\n+\n   for (insn = label; insn != 0 && !INSN_P (insn); insn = NEXT_INSN (insn))\n     if (LABEL_P (insn))\n       label = insn;"}, {"sha": "c94680c76b7233df9a0d142403686f570a2c476f", "filename": "gcc/function.c", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -5305,7 +5305,8 @@ emit_use_return_register_into_block (basic_block bb)\n static void\n emit_return_into_block (basic_block bb)\n {\n-  emit_jump_insn_after (gen_return (), BB_END (bb));\n+  rtx jump = emit_jump_insn_after (gen_return (), BB_END (bb));\n+  JUMP_LABEL (jump) = ret_rtx;\n }\n #endif /* HAVE_return */\n \n@@ -5464,7 +5465,7 @@ thread_prologue_and_epilogue_insns (void)\n \t\t that with a conditional return instruction.  */\n \t      else if (condjump_p (jump))\n \t\t{\n-\t\t  if (! redirect_jump (jump, 0, 0))\n+\t\t  if (! redirect_jump (jump, ret_rtx, 0))\n \t\t    {\n \t\t      ei_next (&ei2);\n \t\t      continue;\n@@ -5547,6 +5548,8 @@ thread_prologue_and_epilogue_insns (void)\n #ifdef HAVE_epilogue\n   if (HAVE_epilogue)\n     {\n+      rtx returnjump;\n+\n       start_sequence ();\n       epilogue_end = emit_note (NOTE_INSN_EPILOGUE_BEG);\n       seq = gen_epilogue ();\n@@ -5557,11 +5560,25 @@ thread_prologue_and_epilogue_insns (void)\n       record_insns (seq, NULL, &epilogue_insn_hash);\n       set_insn_locators (seq, epilogue_locator);\n \n+      returnjump = get_last_insn ();\n       seq = get_insns ();\n       end_sequence ();\n \n       insert_insn_on_edge (seq, e);\n       inserted = true;\n+\n+      if (JUMP_P (returnjump))\n+\t{\n+\t  rtx pat = PATTERN (returnjump);\n+\t  if (GET_CODE (pat) == PARALLEL)\n+\t    pat = XVECEXP (pat, 0, 0);\n+\t  if (ANY_RETURN_P (pat))\n+\t    JUMP_LABEL (returnjump) = pat;\n+\t  else\n+\t    JUMP_LABEL (returnjump) = ret_rtx;\n+\t}\n+      else\n+\treturnjump = NULL_RTX;\n     }\n   else\n #endif"}, {"sha": "41bc01213160bee1d36a76d857b5f1cf69c5a78c", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -104,7 +104,7 @@ static int cond_exec_find_if_block (ce_if_block_t *);\n static int find_if_case_1 (basic_block, edge, edge);\n static int find_if_case_2 (basic_block, edge, edge);\n static int dead_or_predicable (basic_block, basic_block, basic_block,\n-\t\t\t       basic_block, int);\n+\t\t\t       edge, int);\n static void noce_emit_move_insn (rtx, rtx);\n static rtx block_has_only_trap (basic_block);\n \f\n@@ -3847,7 +3847,7 @@ find_if_case_1 (basic_block test_bb, edge then_edge, edge else_edge)\n \n   /* Registers set are dead, or are predicable.  */\n   if (! dead_or_predicable (test_bb, then_bb, else_bb,\n-\t\t\t    single_succ (then_bb), 1))\n+\t\t\t    single_succ_edge (then_bb), 1))\n     return FALSE;\n \n   /* Conversion went ok, including moving the insns and fixing up the\n@@ -3962,7 +3962,7 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n     return FALSE;\n \n   /* Registers set are dead, or are predicable.  */\n-  if (! dead_or_predicable (test_bb, else_bb, then_bb, else_succ->dest, 0))\n+  if (! dead_or_predicable (test_bb, else_bb, then_bb, else_succ, 0))\n     return FALSE;\n \n   /* Conversion went ok, including moving the insns and fixing up the\n@@ -3985,18 +3985,21 @@ find_if_case_2 (basic_block test_bb, edge then_edge, edge else_edge)\n    Return TRUE if successful.\n \n    TEST_BB is the block containing the conditional branch.  MERGE_BB\n-   is the block containing the code to manipulate.  NEW_DEST is the\n-   label TEST_BB should be branching to after the conversion.\n+   is the block containing the code to manipulate.  DEST_EDGE is an\n+   edge representing a jump to the join block; after the conversion,\n+   TEST_BB should be branching to its destination.\n    REVERSEP is true if the sense of the branch should be reversed.  */\n \n static int\n dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n-\t\t    basic_block other_bb, basic_block new_dest, int reversep)\n+\t\t    basic_block other_bb, edge dest_edge, int reversep)\n {\n-  rtx head, end, jump, earliest = NULL_RTX, old_dest, new_label = NULL_RTX;\n+  basic_block new_dest = dest_edge->dest;\n+  rtx head, end, jump, earliest = NULL_RTX, old_dest;\n   bitmap merge_set = NULL;\n   /* Number of pending changes.  */\n   int n_validated_changes = 0;\n+  rtx new_dest_label = NULL_RTX;\n \n   jump = BB_END (test_bb);\n \n@@ -4134,10 +4137,16 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n   old_dest = JUMP_LABEL (jump);\n   if (other_bb != new_dest)\n     {\n-      new_label = block_label (new_dest);\n+      if (JUMP_P (BB_END (dest_edge->src)))\n+\tnew_dest_label = JUMP_LABEL (BB_END (dest_edge->src));\n+      else if (new_dest == EXIT_BLOCK_PTR)\n+\tnew_dest_label = ret_rtx;\n+      else\n+\tnew_dest_label = block_label (new_dest);\n+\n       if (reversep\n-\t  ? ! invert_jump_1 (jump, new_label)\n-\t  : ! redirect_jump_1 (jump, new_label))\n+\t  ? ! invert_jump_1 (jump, new_dest_label)\n+\t  : ! redirect_jump_1 (jump, new_dest_label))\n \tgoto cancel;\n     }\n \n@@ -4148,7 +4157,7 @@ dead_or_predicable (basic_block test_bb, basic_block merge_bb,\n \n   if (other_bb != new_dest)\n     {\n-      redirect_jump_2 (jump, old_dest, new_label, 0, reversep);\n+      redirect_jump_2 (jump, old_dest, new_dest_label, 0, reversep);\n \n       redirect_edge_succ (BRANCH_EDGE (test_bb), new_dest);\n       if (reversep)"}, {"sha": "2026243fd29de87b3ecc89e3c366faf0fe18308e", "filename": "gcc/jump.c", "status": "modified", "additions": 42, "deletions": 30, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -970,6 +970,15 @@ onlyjump_p (const_rtx insn)\n   return 1;\n }\n \n+/* Return true iff INSN is a jump and its JUMP_LABEL is a label, not\n+   NULL or a return.  */\n+bool\n+jump_to_label_p (rtx insn)\n+{\n+  return (JUMP_P (insn)\n+\t  && JUMP_LABEL (insn) != NULL && !ANY_RETURN_P (JUMP_LABEL (insn)));\n+}\n+\n #ifdef HAVE_cc0\n \n /* Return nonzero if X is an RTX that only sets the condition codes\n@@ -1233,7 +1242,7 @@ delete_related_insns (rtx insn)\n   /* If deleting a jump, decrement the count of the label,\n      and delete the label if it is now unused.  */\n \n-  if (JUMP_P (insn) && JUMP_LABEL (insn))\n+  if (jump_to_label_p (insn))\n     {\n       rtx lab = JUMP_LABEL (insn), lab_next;\n \n@@ -1364,6 +1373,18 @@ delete_for_peephole (rtx from, rtx to)\n      is also an unconditional jump in that case.  */\n }\n \f\n+/* A helper function for redirect_exp_1; examines its input X and returns\n+   either a LABEL_REF around a label, or a RETURN if X was NULL.  */\n+static rtx\n+redirect_target (rtx x)\n+{\n+  if (x == NULL_RTX)\n+    return ret_rtx;\n+  if (!ANY_RETURN_P (x))\n+    return gen_rtx_LABEL_REF (Pmode, x);\n+  return x;\n+}\n+\n /* Throughout LOC, redirect OLABEL to NLABEL.  Treat null OLABEL or\n    NLABEL as a return.  Accrue modifications into the change group.  */\n \n@@ -1375,37 +1396,22 @@ redirect_exp_1 (rtx *loc, rtx olabel, rtx nlabel, rtx insn)\n   int i;\n   const char *fmt;\n \n-  if (code == LABEL_REF)\n+      if ((code == LABEL_REF && XEXP (x, 0) == olabel)\n+      || x == olabel)\n     {\n-      if (XEXP (x, 0) == olabel)\n-\t{\n-\t  rtx n;\n-\t  if (nlabel)\n-\t    n = gen_rtx_LABEL_REF (Pmode, nlabel);\n-\t  else\n-\t    n = ret_rtx;\n-\n-\t  validate_change (insn, loc, n, 1);\n-\t  return;\n-\t}\n-    }\n-  else if (code == RETURN && olabel == 0)\n-    {\n-      if (nlabel)\n-\tx = gen_rtx_LABEL_REF (Pmode, nlabel);\n-      else\n-\tx = ret_rtx;\n-      if (loc == &PATTERN (insn))\n-\tx = gen_rtx_SET (VOIDmode, pc_rtx, x);\n+      x = redirect_target (nlabel);\n+      if (GET_CODE (x) == LABEL_REF && loc == &PATTERN (insn))\n+ \tx = gen_rtx_SET (VOIDmode, pc_rtx, x);\n       validate_change (insn, loc, x, 1);\n       return;\n     }\n \n-  if (code == SET && nlabel == 0 && SET_DEST (x) == pc_rtx\n+  if (code == SET && SET_DEST (x) == pc_rtx\n+      && ANY_RETURN_P (nlabel)\n       && GET_CODE (SET_SRC (x)) == LABEL_REF\n       && XEXP (SET_SRC (x), 0) == olabel)\n     {\n-      validate_change (insn, loc, ret_rtx, 1);\n+      validate_change (insn, loc, nlabel, 1);\n       return;\n     }\n \n@@ -1442,6 +1448,7 @@ redirect_jump_1 (rtx jump, rtx nlabel)\n   int ochanges = num_validated_changes ();\n   rtx *loc, asmop;\n \n+  gcc_assert (nlabel != NULL_RTX);\n   asmop = extract_asm_operands (PATTERN (jump));\n   if (asmop)\n     {\n@@ -1463,17 +1470,20 @@ redirect_jump_1 (rtx jump, rtx nlabel)\n    jump target label is unused as a result, it and the code following\n    it may be deleted.\n \n-   If NLABEL is zero, we are to turn the jump into a (possibly conditional)\n-   RETURN insn.\n+   Normally, NLABEL will be a label, but it may also be a RETURN rtx;\n+   in that case we are to turn the jump into a (possibly conditional)\n+   return insn.\n \n    The return value will be 1 if the change was made, 0 if it wasn't\n-   (this can only occur for NLABEL == 0).  */\n+   (this can only occur when trying to produce return insns).  */\n \n int\n redirect_jump (rtx jump, rtx nlabel, int delete_unused)\n {\n   rtx olabel = JUMP_LABEL (jump);\n \n+  gcc_assert (nlabel != NULL_RTX);\n+\n   if (nlabel == olabel)\n     return 1;\n \n@@ -1501,13 +1511,14 @@ redirect_jump_2 (rtx jump, rtx olabel, rtx nlabel, int delete_unused,\n      about this.  */\n   gcc_assert (delete_unused >= 0);\n   JUMP_LABEL (jump) = nlabel;\n-  if (nlabel)\n+  if (!ANY_RETURN_P (nlabel))\n     ++LABEL_NUSES (nlabel);\n \n   /* Update labels in any REG_EQUAL note.  */\n   if ((note = find_reg_note (jump, REG_EQUAL, NULL_RTX)) != NULL_RTX)\n     {\n-      if (!nlabel || (invert && !invert_exp_1 (XEXP (note, 0), jump)))\n+      if (ANY_RETURN_P (nlabel)\n+\t  || (invert && !invert_exp_1 (XEXP (note, 0), jump)))\n \tremove_note (jump, note);\n       else\n \t{\n@@ -1516,7 +1527,8 @@ redirect_jump_2 (rtx jump, rtx olabel, rtx nlabel, int delete_unused,\n \t}\n     }\n \n-  if (olabel && --LABEL_NUSES (olabel) == 0 && delete_unused > 0\n+  if (!ANY_RETURN_P (olabel)\n+      && --LABEL_NUSES (olabel) == 0 && delete_unused > 0\n       /* Undefined labels will remain outside the insn stream.  */\n       && INSN_UID (olabel))\n     delete_related_insns (olabel);"}, {"sha": "9336f006aa5764e3b9d255bff64f7195fcfedd85", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -323,9 +323,14 @@ print_rtx (const_rtx in_rtx)\n \t      }\n \t  }\n \telse if (i == 8 && JUMP_P (in_rtx) && JUMP_LABEL (in_rtx) != NULL)\n-\t  /* Output the JUMP_LABEL reference.  */\n-\t  fprintf (outfile, \"\\n%s%*s -> %d\", print_rtx_head, indent * 2, \"\",\n-\t\t   INSN_UID (JUMP_LABEL (in_rtx)));\n+\t  {\n+\t    /* Output the JUMP_LABEL reference.  */\n+\t    fprintf (outfile, \"\\n%s%*s -> \", print_rtx_head, indent * 2, \"\");\n+\t    if (GET_CODE (JUMP_LABEL (in_rtx)) == RETURN)\n+\t      fprintf (outfile, \"return\");\n+\t    else\n+\t      fprintf (outfile, \"%d\", INSN_UID (JUMP_LABEL (in_rtx)));\n+\t  }\n \telse if (i == 0 && GET_CODE (in_rtx) == VALUE)\n \t  {\n #ifndef GENERATOR_FILE"}, {"sha": "97d02e934b5f8a8a76f63ede1a64179d07fb31cd", "filename": "gcc/reorg.c", "status": "modified", "additions": 59, "deletions": 45, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -220,6 +220,17 @@ static void relax_delay_slots (rtx);\n static void make_return_insns (rtx);\n #endif\n \f\n+/* A wrapper around next_active_insn which takes care to return ret_rtx\n+   unchanged.  */\n+\n+static rtx\n+first_active_target_insn (rtx insn)\n+{\n+  if (ANY_RETURN_P (insn))\n+    return insn;\n+  return next_active_insn (insn);\n+}\n+\f\n /* Return TRUE if this insn should stop the search for insn to fill delay\n    slots.  LABELS_P indicates that labels should terminate the search.\n    In all cases, jumps terminate the search.  */\n@@ -437,6 +448,7 @@ find_end_label (void)\n \t      /* The return we make may have delay slots too.  */\n \t      rtx insn = gen_return ();\n \t      insn = emit_jump_insn (insn);\n+\t      JUMP_LABEL (insn) = ret_rtx;\n \t      emit_barrier ();\n \t      if (num_delay_slots (insn) > 0)\n \t\tobstack_ptr_grow (&unfilled_slots_obstack, insn);\n@@ -824,7 +836,7 @@ optimize_skip (rtx insn)\n \t      || GET_CODE (PATTERN (next_trial)) == RETURN))\n \t{\n \t  rtx target_label = JUMP_LABEL (next_trial);\n-\t  if (target_label == 0)\n+\t  if (ANY_RETURN_P (target_label))\n \t    target_label = find_end_label ();\n \n \t  if (target_label)\n@@ -861,12 +873,12 @@ get_jump_flags (rtx insn, rtx label)\n      be INSNs, CALL_INSNs, or JUMP_INSNs.  Only JUMP_INSNs have branch\n      direction information, and only if they are conditional jumps.\n \n-     If LABEL is zero, then there is no way to determine the branch\n+     If LABEL is a return, then there is no way to determine the branch\n      direction.  */\n   if (JUMP_P (insn)\n       && (condjump_p (insn) || condjump_in_parallel_p (insn))\n+      && !ANY_RETURN_P (label)\n       && INSN_UID (insn) <= max_uid\n-      && label != 0\n       && INSN_UID (label) <= max_uid)\n     flags\n       = (uid_to_ruid[INSN_UID (label)] > uid_to_ruid[INSN_UID (insn)])\n@@ -921,7 +933,7 @@ rare_destination (rtx insn)\n   int jump_count = 0;\n   rtx next;\n \n-  for (; insn; insn = next)\n+  for (; insn && !ANY_RETURN_P (insn); insn = next)\n     {\n       if (NONJUMP_INSN_P (insn) && GET_CODE (PATTERN (insn)) == SEQUENCE)\n \tinsn = XVECEXP (PATTERN (insn), 0, 0);\n@@ -1017,7 +1029,7 @@ mostly_true_jump (rtx jump_insn, rtx condition)\n   /* Predict backward branches usually take, forward branches usually not.  If\n      we don't know whether this is forward or backward, assume the branch\n      will be taken, since most are.  */\n-  return (target_label == 0 || INSN_UID (jump_insn) > max_uid\n+  return (ANY_RETURN_P (target_label) || INSN_UID (jump_insn) > max_uid\n \t  || INSN_UID (target_label) > max_uid\n \t  || (uid_to_ruid[INSN_UID (jump_insn)]\n \t      > uid_to_ruid[INSN_UID (target_label)]));\n@@ -1037,27 +1049,23 @@ get_branch_condition (rtx insn, rtx target)\n   if (condjump_in_parallel_p (insn))\n     pat = XVECEXP (pat, 0, 0);\n \n-  if (GET_CODE (pat) == RETURN)\n-    return target == 0 ? const_true_rtx : 0;\n+  if (ANY_RETURN_P (pat))\n+    return pat == target ? const_true_rtx : 0;\n \n-  else if (GET_CODE (pat) != SET || SET_DEST (pat) != pc_rtx)\n+  if (GET_CODE (pat) != SET || SET_DEST (pat) != pc_rtx)\n     return 0;\n \n   src = SET_SRC (pat);\n   if (GET_CODE (src) == LABEL_REF && XEXP (src, 0) == target)\n     return const_true_rtx;\n \n   else if (GET_CODE (src) == IF_THEN_ELSE\n-\t   && ((target == 0 && GET_CODE (XEXP (src, 1)) == RETURN)\n-\t       || (GET_CODE (XEXP (src, 1)) == LABEL_REF\n-\t\t   && XEXP (XEXP (src, 1), 0) == target))\n+\t   && XEXP (XEXP (src, 1), 0) == target\n \t   && XEXP (src, 2) == pc_rtx)\n     return XEXP (src, 0);\n \n   else if (GET_CODE (src) == IF_THEN_ELSE\n-\t   && ((target == 0 && GET_CODE (XEXP (src, 2)) == RETURN)\n-\t       || (GET_CODE (XEXP (src, 2)) == LABEL_REF\n-\t\t   && XEXP (XEXP (src, 2), 0) == target))\n+\t   && XEXP (XEXP (src, 2), 0) == target\n \t   && XEXP (src, 1) == pc_rtx)\n     {\n       enum rtx_code rev;\n@@ -1318,7 +1326,7 @@ steal_delay_list_from_target (rtx insn, rtx condition, rtx seq,\n     }\n \n   /* Show the place to which we will be branching.  */\n-  *pnew_thread = next_active_insn (JUMP_LABEL (XVECEXP (seq, 0, 0)));\n+  *pnew_thread = first_active_target_insn (JUMP_LABEL (XVECEXP (seq, 0, 0)));\n \n   /* Add any new insns to the delay list and update the count of the\n      number of slots filled.  */\n@@ -1827,7 +1835,7 @@ own_thread_p (rtx thread, rtx label, int allow_fallthrough)\n   rtx insn;\n \n   /* We don't own the function end.  */\n-  if (thread == 0)\n+  if (thread == 0 || ANY_RETURN_P (thread))\n     return 0;\n \n   /* Get the first active insn, or THREAD, if it is an active insn.  */\n@@ -2245,7 +2253,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t  && (!JUMP_P (insn)\n \t      || ((condjump_p (insn) || condjump_in_parallel_p (insn))\n \t\t  && ! simplejump_p (insn)\n-\t\t  && JUMP_LABEL (insn) != 0)))\n+\t\t  && !ANY_RETURN_P (JUMP_LABEL (insn)))))\n \t{\n \t  /* Invariant: If insn is a JUMP_INSN, the insn's jump\n \t     label.  Otherwise, zero.  */\n@@ -2270,7 +2278,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t\ttarget = JUMP_LABEL (insn);\n \t    }\n \n-\t  if (target == 0)\n+\t  if (target == 0 || ANY_RETURN_P (target))\n \t    for (trial = next_nonnote_insn (insn); !stop_search_p (trial, 1);\n \t\t trial = next_trial)\n \t      {\n@@ -2343,7 +2351,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \t     Don't do this if the insn at the branch target is a branch.  */\n \t  if (slots_to_fill != slots_filled\n \t      && trial\n-\t      && JUMP_P (trial)\n+\t      && jump_to_label_p (trial)\n \t      && simplejump_p (trial)\n \t      && (target == 0 || JUMP_LABEL (trial) == target)\n \t      && (next_trial = next_active_insn (JUMP_LABEL (trial))) != 0\n@@ -2500,7 +2508,7 @@ fill_simple_delay_slots (int non_jumps_p)\n \f\n /* Follow any unconditional jump at LABEL;\n    return the ultimate label reached by any such chain of jumps.\n-   Return null if the chain ultimately leads to a return instruction.\n+   Return ret_rtx if the chain ultimately leads to a return instruction.\n    If LABEL is not followed by a jump, return LABEL.\n    If the chain loops or we can't find end, return LABEL,\n    since that tells caller to avoid changing the insn.  */\n@@ -2513,29 +2521,34 @@ follow_jumps (rtx label)\n   rtx value = label;\n   int depth;\n \n+  if (ANY_RETURN_P (label))\n+    return label;\n   for (depth = 0;\n        (depth < 10\n \t&& (insn = next_active_insn (value)) != 0\n \t&& JUMP_P (insn)\n-\t&& ((JUMP_LABEL (insn) != 0 && any_uncondjump_p (insn)\n-\t     && onlyjump_p (insn))\n+\t&& JUMP_LABEL (insn) != NULL_RTX\n+\t&& ((any_uncondjump_p (insn) && onlyjump_p (insn))\n \t    || GET_CODE (PATTERN (insn)) == RETURN)\n \t&& (next = NEXT_INSN (insn))\n \t&& BARRIER_P (next));\n        depth++)\n     {\n+      rtx this_label = JUMP_LABEL (insn);\n       rtx tem;\n \n       /* If we have found a cycle, make the insn jump to itself.  */\n-      if (JUMP_LABEL (insn) == label)\n+      if (this_label == label)\n \treturn label;\n-\n-      tem = next_active_insn (JUMP_LABEL (insn));\n-      if (tem && (GET_CODE (PATTERN (tem)) == ADDR_VEC\n-\t\t  || GET_CODE (PATTERN (tem)) == ADDR_DIFF_VEC))\n+      if (ANY_RETURN_P (this_label))\n+\treturn this_label;\n+      tem = next_active_insn (this_label);\n+      if (tem\n+\t  && (GET_CODE (PATTERN (tem)) == ADDR_VEC\n+\t      || GET_CODE (PATTERN (tem)) == ADDR_DIFF_VEC))\n \tbreak;\n \n-      value = JUMP_LABEL (insn);\n+      value = this_label;\n     }\n   if (depth == 10)\n     return label;\n@@ -2587,7 +2600,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \n   /* If our thread is the end of subroutine, we can't get any delay\n      insns from that.  */\n-  if (thread == 0)\n+  if (thread == NULL_RTX || ANY_RETURN_P (thread))\n     return delay_list;\n \n   /* If this is an unconditional branch, nothing is needed at the\n@@ -2757,7 +2770,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t\t\t      gcc_assert (REG_NOTE_KIND (note)\n \t\t\t\t\t  == REG_LABEL_OPERAND);\n \t\t\t  }\n-\t\t      if (JUMP_P (trial) && JUMP_LABEL (trial))\n+\t\t      if (jump_to_label_p (trial))\n \t\t\tLABEL_NUSES (JUMP_LABEL (trial))++;\n \n \t\t      delete_related_insns (trial);\n@@ -2776,7 +2789,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t\t\t      gcc_assert (REG_NOTE_KIND (note)\n \t\t\t\t\t  == REG_LABEL_OPERAND);\n \t\t\t  }\n-\t\t      if (JUMP_P (trial) && JUMP_LABEL (trial))\n+\t\t      if (jump_to_label_p (trial))\n \t\t\tLABEL_NUSES (JUMP_LABEL (trial))--;\n \t\t    }\n \t\t  else\n@@ -2897,7 +2910,8 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n      depend on the destination register.  If so, try to place the opposite\n      arithmetic insn after the jump insn and put the arithmetic insn in the\n      delay slot.  If we can't do this, return.  */\n-  if (delay_list == 0 && likely && new_thread\n+  if (delay_list == 0 && likely\n+      && new_thread && !ANY_RETURN_P (new_thread)\n       && NONJUMP_INSN_P (new_thread)\n       && GET_CODE (PATTERN (new_thread)) != ASM_INPUT\n       && asm_noperands (PATTERN (new_thread)) < 0)\n@@ -2990,7 +3004,7 @@ fill_slots_from_thread (rtx insn, rtx condition, rtx thread,\n \t\t\t\t\t      delay_list))\n \tnew_thread = follow_jumps (JUMP_LABEL (new_thread));\n \n-      if (new_thread == 0)\n+      if (ANY_RETURN_P (new_thread))\n \tlabel = find_end_label ();\n       else if (LABEL_P (new_thread))\n \tlabel = new_thread;\n@@ -3063,7 +3077,7 @@ fill_eager_delay_slots (void)\n \t them.  Then see whether the branch is likely true.  We don't need\n \t to do a lot of this for unconditional branches.  */\n \n-      insn_at_target = next_active_insn (target_label);\n+      insn_at_target = first_active_target_insn (target_label);\n       own_target = own_thread_p (target_label, target_label, 0);\n \n       if (condition == const_true_rtx)\n@@ -3098,7 +3112,7 @@ fill_eager_delay_slots (void)\n \t\t from the thread that was filled.  So we have to recompute\n \t\t the next insn at the target.  */\n \t      target_label = JUMP_LABEL (insn);\n-\t      insn_at_target = next_active_insn (target_label);\n+\t      insn_at_target = first_active_target_insn (target_label);\n \n \t      delay_list\n \t\t= fill_slots_from_thread (insn, condition, fallthrough_insn,\n@@ -3337,10 +3351,10 @@ relax_delay_slots (rtx first)\n \t group of consecutive labels.  */\n       if (JUMP_P (insn)\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n-\t  && (target_label = JUMP_LABEL (insn)) != 0)\n+\t  && !ANY_RETURN_P (target_label = JUMP_LABEL (insn)))\n \t{\n \t  target_label = skip_consecutive_labels (follow_jumps (target_label));\n-\t  if (target_label == 0)\n+\t  if (ANY_RETURN_P (target_label))\n \t    target_label = find_end_label ();\n \n \t  if (target_label && next_active_insn (target_label) == next\n@@ -3373,7 +3387,7 @@ relax_delay_slots (rtx first)\n \t\t invert_jump fails.  */\n \n \t      ++LABEL_NUSES (target_label);\n-\t      if (label)\n+\t      if (!ANY_RETURN_P (label))\n \t\t++LABEL_NUSES (label);\n \n \t      if (invert_jump (insn, label, 1))\n@@ -3382,7 +3396,7 @@ relax_delay_slots (rtx first)\n \t\t  next = insn;\n \t\t}\n \n-\t      if (label)\n+\t      if (!ANY_RETURN_P (label))\n \t\t--LABEL_NUSES (label);\n \n \t      if (--LABEL_NUSES (target_label) == 0)\n@@ -3485,12 +3499,12 @@ relax_delay_slots (rtx first)\n \n       target_label = JUMP_LABEL (delay_insn);\n \n-      if (target_label)\n+      if (!ANY_RETURN_P (target_label))\n \t{\n \t  /* If this jump goes to another unconditional jump, thread it, but\n \t     don't convert a jump into a RETURN here.  */\n \t  trial = skip_consecutive_labels (follow_jumps (target_label));\n-\t  if (trial == 0)\n+\t  if (ANY_RETURN_P (trial))\n \t    trial = find_end_label ();\n \n \t  if (trial && trial != target_label\n@@ -3540,7 +3554,7 @@ relax_delay_slots (rtx first)\n \t      && redundant_insn (XVECEXP (PATTERN (trial), 0, 1), insn, 0))\n \t    {\n \t      target_label = JUMP_LABEL (XVECEXP (PATTERN (trial), 0, 0));\n-\t      if (target_label == 0)\n+\t      if (ANY_RETURN_P (target_label))\n \t\ttarget_label = find_end_label ();\n \n \t      if (target_label\n@@ -3627,7 +3641,7 @@ relax_delay_slots (rtx first)\n \t  rtx label = JUMP_LABEL (next);\n \t  rtx old_label = JUMP_LABEL (delay_insn);\n \n-\t  if (label == 0)\n+\t  if (ANY_RETURN_P (label))\n \t    label = find_end_label ();\n \n \t  /* find_end_label can generate a new label. Check this first.  */\n@@ -3737,7 +3751,7 @@ make_return_insns (rtx first)\n \n       /* If we can't make the jump into a RETURN, try to redirect it to the best\n \t RETURN and go on to the next insn.  */\n-      if (! reorg_redirect_jump (jump_insn, NULL_RTX))\n+      if (! reorg_redirect_jump (jump_insn, ret_rtx))\n \t{\n \t  /* Make sure redirecting the jump will not invalidate the delay\n \t     slot insns.  */\n@@ -3866,7 +3880,7 @@ dbr_schedule (rtx first)\n       /* Ensure all jumps go to the last of a set of consecutive labels.  */\n       if (JUMP_P (insn)\n \t  && (condjump_p (insn) || condjump_in_parallel_p (insn))\n-\t  && JUMP_LABEL (insn) != 0\n+\t  && !ANY_RETURN_P (JUMP_LABEL (insn))\n \t  && ((target = skip_consecutive_labels (JUMP_LABEL (insn)))\n \t      != JUMP_LABEL (insn)))\n \tredirect_jump (insn, target, 1);"}, {"sha": "838011121134af858ffa05c3ff966de673f0568e", "filename": "gcc/resource.c", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -495,6 +495,8 @@ find_dead_or_set_registers (rtx target, struct resources *res,\n \t\t  || GET_CODE (PATTERN (this_jump_insn)) == RETURN)\n \t\t{\n \t\t  next = JUMP_LABEL (this_jump_insn);\n+\t\t  if (ANY_RETURN_P (next))\n+\t\t    next = NULL_RTX;\n \t\t  if (jump_insn == 0)\n \t\t    {\n \t\t      jump_insn = insn;\n@@ -562,9 +564,10 @@ find_dead_or_set_registers (rtx target, struct resources *res,\n \t\t  AND_COMPL_HARD_REG_SET (scratch, needed.regs);\n \t\t  AND_COMPL_HARD_REG_SET (fallthrough_res.regs, scratch);\n \n-\t\t  find_dead_or_set_registers (JUMP_LABEL (this_jump_insn),\n-\t\t\t\t\t      &target_res, 0, jump_count,\n-\t\t\t\t\t      target_set, needed);\n+\t\t  if (!ANY_RETURN_P (JUMP_LABEL (this_jump_insn)))\n+\t\t    find_dead_or_set_registers (JUMP_LABEL (this_jump_insn),\n+\t\t\t\t\t\t&target_res, 0, jump_count,\n+\t\t\t\t\t\ttarget_set, needed);\n \t\t  find_dead_or_set_registers (next,\n \t\t\t\t\t      &fallthrough_res, 0, jump_count,\n \t\t\t\t\t      set, needed);\n@@ -878,7 +881,7 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n   struct resources set, needed;\n \n   /* Handle end of function.  */\n-  if (target == 0)\n+  if (target == 0 || ANY_RETURN_P (target))\n     {\n       *res = end_of_function_needs;\n       return;\n@@ -1097,8 +1100,9 @@ mark_target_live_regs (rtx insns, rtx target, struct resources *res)\n       struct resources new_resources;\n       rtx stop_insn = next_active_insn (jump_insn);\n \n-      mark_target_live_regs (insns, next_active_insn (jump_target),\n-\t\t\t     &new_resources);\n+      if (!ANY_RETURN_P (jump_target))\n+\tjump_target = next_active_insn (jump_target);\n+      mark_target_live_regs (insns, jump_target, &new_resources);\n       CLEAR_RESOURCE (&set);\n       CLEAR_RESOURCE (&needed);\n "}, {"sha": "3156006c85d4e439f786b95fd7ad01ebfa33201d", "filename": "gcc/rtl.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -432,6 +432,9 @@ struct GTY((variable_size)) rtvec_def {\n   (JUMP_P (INSN) && (GET_CODE (PATTERN (INSN)) == ADDR_VEC || \\\n \t\t     GET_CODE (PATTERN (INSN)) == ADDR_DIFF_VEC))\n \n+/* Predicate yielding nonzero iff X is a return.  */\n+#define ANY_RETURN_P(X) ((X) == ret_rtx)\n+\n /* 1 if X is a unary operator.  */\n \n #define UNARY_P(X)   \\\n@@ -2341,6 +2344,7 @@ extern void check_for_inc_dec (rtx insn);\n \n /* In jump.c */\n extern int comparison_dominates_p (enum rtx_code, enum rtx_code);\n+extern bool jump_to_label_p (rtx);\n extern int condjump_p (const_rtx);\n extern int any_condjump_p (const_rtx);\n extern int any_uncondjump_p (const_rtx);"}, {"sha": "4b71b1ed879596679e45d2c1076032da7d1feb2d", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=dc0ff1c802ef8a9e8075e5a8f4da9881848e08ab", "patch": "@@ -2660,8 +2660,11 @@ tablejump_p (const_rtx insn, rtx *labelp, rtx *tablep)\n {\n   rtx label, table;\n \n-  if (JUMP_P (insn)\n-      && (label = JUMP_LABEL (insn)) != NULL_RTX\n+  if (!JUMP_P (insn))\n+    return false;\n+\n+  label = JUMP_LABEL (insn);\n+  if (label != NULL_RTX && !ANY_RETURN_P (label)\n       && (table = next_active_insn (label)) != NULL_RTX\n       && JUMP_TABLE_DATA_P (table))\n     {"}]}