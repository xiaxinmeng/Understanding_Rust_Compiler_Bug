{"sha": "3ad2180a02e9351700c8d46402d420f040c3d616", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FkMjE4MGEwMmU5MzUxNzAwYzhkNDY0MDJkNDIwZjA0MGMzZDYxNg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-28T01:19:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-06-28T01:19:42Z"}, "message": "(subst, apply_distributive_law): Use INTEGRAL_MODE_P and FLOAT_MODE_P.\n\n(reversible_comparison_p): Likewise.\nCan reverse if MODE_COMPLEX_INT or MODE_PARTIAL_INT.\n\nFrom-SVN: r4779", "tree": {"sha": "f7c52a4a03ca4a3f863fa287153d2e651c1119f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7c52a4a03ca4a3f863fa287153d2e651c1119f4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ad2180a02e9351700c8d46402d420f040c3d616", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad2180a02e9351700c8d46402d420f040c3d616", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ad2180a02e9351700c8d46402d420f040c3d616", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad2180a02e9351700c8d46402d420f040c3d616/comments", "author": null, "committer": null, "parents": [{"sha": "ae1ae48cdb444b210600c4b59d3a0524aee8a784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae1ae48cdb444b210600c4b59d3a0524aee8a784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae1ae48cdb444b210600c4b59d3a0524aee8a784"}], "stats": {"total": 14, "additions": 8, "deletions": 6}, "files": [{"sha": "d6c1ef81c78b1a5ed4152ed9499812232bddfa37", "filename": "gcc/combine.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad2180a02e9351700c8d46402d420f040c3d616/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad2180a02e9351700c8d46402d420f040c3d616/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=3ad2180a02e9351700c8d46402d420f040c3d616", "patch": "@@ -2945,7 +2945,7 @@ subst (x, from, to, in_dest, unique_copy)\n        || code == MULT || code == AND || code == IOR || code == XOR\n        || code == DIV || code == UDIV\n        || code == SMAX || code == SMIN || code == UMAX || code == UMIN)\n-      && GET_MODE_CLASS (mode) == MODE_INT)\n+      && INTEGRAL_MODE_P (mode))\n     {\n       if (GET_CODE (XEXP (x, 0)) == code)\n \t{\n@@ -3235,7 +3235,7 @@ subst (x, from, to, in_dest, unique_copy)\n \n       /* (neg (minus X Y)) can become (minus Y X).  */\n       if (GET_CODE (XEXP (x, 0)) == MINUS\n-\t  && (GET_MODE_CLASS (mode) != MODE_FLOAT\n+\t  && (! FLOAT_MODE_P (mode)\n \t      /* x-y != -(y-x) with IEEE floating point. */\n \t      || TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT))\n \t{\n@@ -3330,7 +3330,7 @@ subst (x, from, to, in_dest, unique_copy)\n \n       /* In IEEE floating point, x-0 is not the same as x.  */\n       if ((TARGET_FLOAT_FORMAT != IEEE_FLOAT_FORMAT\n-\t   || GET_MODE_CLASS (GET_MODE (XEXP (x, 0))) == MODE_INT)\n+\t   || ! FLOAT_MODE_P (GET_MODE (XEXP (x, 0))))\n \t  && XEXP (x, 1) == CONST0_RTX (GET_MODE (XEXP (x, 0))))\n \treturn XEXP (x, 0);\n       break;\n@@ -3703,7 +3703,7 @@ subst (x, from, to, in_dest, unique_copy)\n \n       /* Look for MIN or MAX.  */\n \n-      if (GET_MODE_CLASS (mode) == MODE_INT\n+      if (! FLOAT_MODE_P (mode)\n \t  && GET_RTX_CLASS (GET_CODE (XEXP (x, 0))) == '<'\n \t  && rtx_equal_p (XEXP (XEXP (x, 0), 0), XEXP (x, 1))\n \t  && rtx_equal_p (XEXP (XEXP (x, 0), 1), XEXP (x, 2))\n@@ -5773,7 +5773,7 @@ apply_distributive_law (x)\n   /* Distributivity is not true for floating point.\n      It can change the value.  So don't do it.\n      -- rms and moshier@world.std.com.  */\n-  if (GET_MODE_CLASS (GET_MODE (x)) == MODE_FLOAT)\n+  if (FLOAT_MODE_P (GET_MODE (x)))\n     return x;\n \n   /* The outer operation can only be one of the following:  */\n@@ -8923,12 +8923,14 @@ reversible_comparison_p (x)\n   switch (GET_MODE_CLASS (GET_MODE (XEXP (x, 0))))\n     {\n     case MODE_INT:\n+    case MODE_PARTIAL_INT:\n+    case MODE_COMPLEX_INT:\n       return 1;\n \n     case MODE_CC:\n       x = get_last_value (XEXP (x, 0));\n       return (x && GET_CODE (x) == COMPARE\n-\t      && GET_MODE_CLASS (GET_MODE (XEXP (x, 0))) == MODE_INT);\n+\t      && ! FLOAT_MODE_P (GET_MODE (XEXP (x, 0))));\n     }\n \n   return 0;"}]}