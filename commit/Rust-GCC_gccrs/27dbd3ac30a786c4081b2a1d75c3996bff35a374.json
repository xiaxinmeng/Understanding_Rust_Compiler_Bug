{"sha": "27dbd3ac30a786c4081b2a1d75c3996bff35a374", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjdkYmQzYWMzMGE3ODZjNDA4MWIyYTFkNzVjMzk5NmJmZjM1YTM3NA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2009-06-26T18:23:32Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2009-06-26T18:23:32Z"}, "message": "function.h (struct function): Add cannot_be_copied_reason, and cannot_be_copied_set.\n\n\t* function.h (struct function): Add cannot_be_copied_reason,\n\tand cannot_be_copied_set.\n\t* tree-inline.c (has_label_address_in_static_1): Rename from\n\tinline_forbidden_p_2; don't set inline_forbidden_reason here.\n\t(cannot_copy_type_1): Rename from inline_forbidden_p_op; likewise\n\tdon't set inline_forbidden_reason.\n\t(copy_forbidden): New function, split out of inline_forbidden_p.\n\t(inline_forbidden_p_stmt): Don't check for nonlocal labels here.\n\t(inline_forbidden_p): Use copy_forbidden.\n\t(tree_versionable_function_p): Likewise.\n\t(inlinable_function_p): Merge into tree_inlinable_function_p.\n\t(tree_function_versioning): Remap cfun->nonlocal_goto_save_area.\n\t* ipa-cp.c (ipcp_versionable_function_p): New function.\n\t(ipcp_cloning_candidate_p): Use it.\n\t(ipcp_node_modifiable_p): Likewise.\n\nFrom-SVN: r148981", "tree": {"sha": "6390d7426655b799c3e583c3c54f543275010601", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6390d7426655b799c3e583c3c54f543275010601"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/27dbd3ac30a786c4081b2a1d75c3996bff35a374", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27dbd3ac30a786c4081b2a1d75c3996bff35a374", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27dbd3ac30a786c4081b2a1d75c3996bff35a374", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27dbd3ac30a786c4081b2a1d75c3996bff35a374/comments", "author": null, "committer": null, "parents": [{"sha": "efb303b1e80ea45e0f4595cea31f2934d7af16f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efb303b1e80ea45e0f4595cea31f2934d7af16f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efb303b1e80ea45e0f4595cea31f2934d7af16f8"}], "stats": {"total": 279, "additions": 182, "deletions": 97}, "files": [{"sha": "b01fbdd2467e7772788565865a999758219501c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27dbd3ac30a786c4081b2a1d75c3996bff35a374/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27dbd3ac30a786c4081b2a1d75c3996bff35a374/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=27dbd3ac30a786c4081b2a1d75c3996bff35a374", "patch": "@@ -1,3 +1,21 @@\n+2009-06-26  Richard Henderson  <rth@redhat.com>\n+\n+\t* function.h (struct function): Add cannot_be_copied_reason,\n+\tand cannot_be_copied_set.\n+\t* tree-inline.c (has_label_address_in_static_1): Rename from\n+\tinline_forbidden_p_2; don't set inline_forbidden_reason here.\n+\t(cannot_copy_type_1): Rename from inline_forbidden_p_op; likewise\n+\tdon't set inline_forbidden_reason.\n+\t(copy_forbidden): New function, split out of inline_forbidden_p.\n+\t(inline_forbidden_p_stmt): Don't check for nonlocal labels here.\n+\t(inline_forbidden_p): Use copy_forbidden.\n+\t(tree_versionable_function_p): Likewise.\n+\t(inlinable_function_p): Merge into tree_inlinable_function_p.\n+\t(tree_function_versioning): Remap cfun->nonlocal_goto_save_area.\n+\t* ipa-cp.c (ipcp_versionable_function_p): New function.\n+\t(ipcp_cloning_candidate_p): Use it.\n+\t(ipcp_node_modifiable_p): Likewise.\n+\n 2009-06-26  Olatunji Ruwase  <tjruwase@google.com>\n \n \t* builtins.c (expand_builtin_alloca): Handle builtin alloca"}, {"sha": "8f69429d15043edd61427f34c57e1f8706ecfea0", "filename": "gcc/function.h", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27dbd3ac30a786c4081b2a1d75c3996bff35a374/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27dbd3ac30a786c4081b2a1d75c3996bff35a374/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=27dbd3ac30a786c4081b2a1d75c3996bff35a374", "patch": "@@ -524,11 +524,17 @@ struct GTY(()) function {\n   /* Properties used by the pass manager.  */\n   unsigned int curr_properties;\n   unsigned int last_verified;\n+\n   /* Interprocedural passes scheduled to have their transform functions\n      applied next time we execute local pass on them.  We maintain it\n      per-function in order to allow IPA passes to introduce new functions.  */\n   VEC(ipa_opt_pass,heap) * GTY((skip)) ipa_transforms_to_apply;\n \n+  /* Non-null if the function does something that would prevent it from\n+     being copied; this applies to both versioning and inlining.  Set to\n+     a string describing the reason for failure.  */\n+  const char * GTY((skip)) cannot_be_copied_reason;\n+\n   /* Collected bit flags.  */\n \n   /* Number of units of general registers that need saving in stdarg\n@@ -540,7 +546,6 @@ struct GTY(()) function {\n      function.  */\n   unsigned int va_list_fpr_size : 8;\n \n-\n   /* How commonly executed the function is.  Initialized during branch\n      probabilities pass.  */\n   ENUM_BITFIELD (function_frequency) function_frequency : 2;\n@@ -556,6 +561,11 @@ struct GTY(()) function {\n      from nested functions.  */\n   unsigned int has_nonlocal_label : 1;\n \n+  /* Nonzero if we've set cannot_be_copied_reason.  I.e. if \n+     (cannot_be_copied_set && !cannot_be_copied_reason), the function\n+     can in fact be copied.  */\n+  unsigned int cannot_be_copied_set : 1;\n+\n   /* Nonzero if current function uses stdarg.h or equivalent.  */\n   unsigned int stdarg : 1;\n "}, {"sha": "fe335c4f0fa4f4bd46c8695d54ae50c0c2cd68fe", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27dbd3ac30a786c4081b2a1d75c3996bff35a374/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27dbd3ac30a786c4081b2a1d75c3996bff35a374/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=27dbd3ac30a786c4081b2a1d75c3996bff35a374", "patch": "@@ -351,6 +351,45 @@ ipcp_print_all_lattices (FILE * f)\n     }\n }\n \n+/* Return true if ipcp algorithms would allow cloning NODE.  */\n+\n+static bool\n+ipcp_versionable_function_p (struct cgraph_node *node)\n+{\n+  tree decl = node->decl;\n+  basic_block bb;\n+\n+  /* There are a number of generic reasons functions cannot be versioned.  */\n+  if (!tree_versionable_function_p (decl))\n+    return false;\n+\n+  /* Removing arguments doesn't work if the function takes varargs.  */\n+  if (DECL_STRUCT_FUNCTION (decl)->stdarg)\n+    return false;\n+\n+  /* Removing arguments doesn't work if we use __builtin_apply_args.  */\n+  FOR_EACH_BB_FN (bb, DECL_STRUCT_FUNCTION (decl))\n+    {\n+      gimple_stmt_iterator gsi;\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t{\n+\t  const_gimple stmt = gsi_stmt (gsi);\n+\t  tree t;\n+\n+\t  if (!is_gimple_call (stmt))\n+\t    continue;\n+\t  t = gimple_call_fndecl (stmt);\n+\t  if (t == NULL_TREE)\n+\t    continue;\n+\t  if (DECL_BUILT_IN_CLASS (t) == BUILT_IN_NORMAL\n+\t      && DECL_FUNCTION_CODE (t) == BUILT_IN_APPLY_ARGS)\n+\t    return false;\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n /* Return true if this NODE is viable candidate for cloning.  */\n static bool\n ipcp_cloning_candidate_p (struct cgraph_node *node)\n@@ -374,7 +413,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n  \t         cgraph_node_name (node));\n       return false;\n     }\n-  if (!tree_versionable_function_p (node->decl))\n+  if (!ipcp_versionable_function_p (node))\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Not considering %s for cloning; body is not versionable.\\n\",\n@@ -677,7 +716,7 @@ ipcp_node_modifiable_p (struct cgraph_node *node)\n {\n   /* Once we will be able to do in-place replacement, we can be more\n      lax here.  */\n-  return tree_versionable_function_p (node->decl);\n+  return ipcp_versionable_function_p (node);\n }\n \n /* Print count scale data structures.  */"}, {"sha": "b97b9b2b7726d29a50e893e7ea743c8310ae355c", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 112, "deletions": 94, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/27dbd3ac30a786c4081b2a1d75c3996bff35a374/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/27dbd3ac30a786c4081b2a1d75c3996bff35a374/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=27dbd3ac30a786c4081b2a1d75c3996bff35a374", "patch": "@@ -119,7 +119,6 @@ eni_weights eni_time_weights;\n /* Prototypes.  */\n \n static tree declare_return_variable (copy_body_data *, tree, tree, tree *);\n-static bool inlinable_function_p (tree);\n static void remap_block (tree *, copy_body_data *);\n static void copy_bind_expr (tree *, int *, copy_body_data *);\n static tree mark_local_for_remap_r (tree *, int *, void *);\n@@ -2436,26 +2435,32 @@ declare_return_variable (copy_body_data *id, tree return_slot, tree modify_dest,\n   return var;\n }\n \n-/* Returns nonzero if a function can be inlined as a tree.  */\n+/* Callback through walk_tree.  Determine if a DECL_INITIAL makes reference\n+   to a local label.  */\n \n-bool\n-tree_inlinable_function_p (tree fn)\n+static tree\n+has_label_address_in_static_1 (tree *nodep, int *walk_subtrees, void *fnp)\n {\n-  return inlinable_function_p (fn);\n-}\n+  tree node = *nodep;\n+  tree fn = (tree) fnp;\n \n-static const char *inline_forbidden_reason;\n+  if (TREE_CODE (node) == LABEL_DECL && DECL_CONTEXT (node) == fn)\n+    return node;\n+\n+  if (TYPE_P (node))\n+    *walk_subtrees = 0;\n+\n+  return NULL_TREE;\n+}\n \n-/* A callback for walk_gimple_seq to handle tree operands.  Returns\n-   NULL_TREE if a function can be inlined, otherwise sets the reason\n-   why not and returns a tree representing the offending operand. */\n+/* Callback through walk_tree.  Determine if we've got an aggregate\n+   type that we can't support; return non-null if so.  */\n \n static tree\n-inline_forbidden_p_op (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n-                         void *fnp ATTRIBUTE_UNUSED)\n+cannot_copy_type_1 (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n+                    void *data ATTRIBUTE_UNUSED)\n {\n-  tree node = *nodep;\n-  tree t;\n+  tree t, node = *nodep;\n \n   if (TREE_CODE (node) == RECORD_TYPE || TREE_CODE (node) == UNION_TYPE)\n     {\n@@ -2474,21 +2479,78 @@ inline_forbidden_p_op (tree *nodep, int *walk_subtrees ATTRIBUTE_UNUSED,\n \t cycle to try to find out.  This should be checked for 4.1.  */\n       for (t = TYPE_FIELDS (node); t; t = TREE_CHAIN (t))\n \tif (variably_modified_type_p (TREE_TYPE (t), NULL))\n-\t  {\n-\t    inline_forbidden_reason\n-\t      = G_(\"function %q+F can never be inlined \"\n-\t\t   \"because it uses variable sized variables\");\n-\t    return node;\n-\t  }\n+\t  return node;\n     }\n \n   return NULL_TREE;\n }\n \n \n-/* A callback for walk_gimple_seq to handle statements.  Returns\n-   non-NULL iff a function can not be inlined.  Also sets the reason\n-   why. */\n+/* Determine if the function can be copied.  If so return NULL.  If\n+   not return a string describng the reason for failure.  */\n+\n+static const char *\n+copy_forbidden (struct function *fun, tree fndecl)\n+{\n+  const char *reason = fun->cannot_be_copied_reason;\n+  tree step;\n+\n+  /* Only examine the function once.  */\n+  if (fun->cannot_be_copied_set)\n+    return reason;\n+\n+  /* We cannot copy a function that receives a non-local goto\n+     because we cannot remap the destination label used in the\n+     function that is performing the non-local goto.  */\n+  /* ??? Actually, this should be possible, if we work at it.\n+     No doubt there's just a handful of places that simply\n+     assume it doesn't happen and don't substitute properly.  */\n+  if (fun->has_nonlocal_label)\n+    {\n+      reason = G_(\"function %q+F can never be copied \"\n+\t\t  \"because it receives a non-local goto\");\n+      goto fail;\n+    }\n+\n+  for (step = fun->local_decls; step; step = TREE_CHAIN (step))\n+    {\n+      tree decl = TREE_VALUE (step);\n+\n+      if (TREE_CODE (decl) == VAR_DECL\n+\t  && TREE_STATIC (decl)\n+\t  && !DECL_EXTERNAL (decl)\n+\t  && DECL_INITIAL (decl)\n+\t  && walk_tree_without_duplicates (&DECL_INITIAL (decl),\n+\t\t\t\t\t   has_label_address_in_static_1,\n+\t\t\t\t\t   fndecl))\n+\t{\n+\t  reason = G_(\"function %q+F can never be copied because it saves \"\n+\t\t      \"address of local label in a static variable\");\n+\t  goto fail;\n+\t}\n+\n+      if (!TREE_STATIC (decl) && !DECL_EXTERNAL (decl)\n+\t  && variably_modified_type_p (TREE_TYPE (decl), NULL)\n+\t  && walk_tree_without_duplicates (&TREE_TYPE (decl),\n+\t\t\t\t\t   cannot_copy_type_1, NULL))\n+\t{\n+\t  reason = G_(\"function %q+F can never be copied \"\n+\t\t      \"because it uses variable sized variables\");\n+\t  goto fail;\n+\t}\n+    }\n+\n+ fail:\n+  fun->cannot_be_copied_reason = reason;\n+  fun->cannot_be_copied_set = true;\n+  return reason;\n+}\n+\n+\n+static const char *inline_forbidden_reason;\n+\n+/* A callback for walk_gimple_seq to handle statements.  Returns non-null\n+   iff a function can not be inlined.  Also sets the reason why. */\n \n static tree\n inline_forbidden_p_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n@@ -2597,21 +2659,6 @@ inline_forbidden_p_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n \t}\n       break;\n \n-    case GIMPLE_LABEL:\n-      t = gimple_label_label (stmt);\n-      if (DECL_NONLOCAL (t))\n-\t{\n-\t  /* We cannot inline a function that receives a non-local goto\n-\t     because we cannot remap the destination label used in the\n-\t     function that is performing the non-local goto.  */\n-\t  inline_forbidden_reason\n-\t    = G_(\"function %q+F can never be inlined \"\n-\t\t \"because it receives a non-local goto\");\n-\t  *handled_ops_p = true;\n-\t  return t;\n-\t}\n-      break;\n-\n     default:\n       break;\n     }\n@@ -2620,41 +2667,25 @@ inline_forbidden_p_stmt (gimple_stmt_iterator *gsi, bool *handled_ops_p,\n   return NULL_TREE;\n }\n \n-\n-static tree\n-inline_forbidden_p_2 (tree *nodep, int *walk_subtrees,\n-\t\t      void *fnp)\n-{\n-  tree node = *nodep;\n-  tree fn = (tree) fnp;\n-\n-  if (TREE_CODE (node) == LABEL_DECL && DECL_CONTEXT (node) == fn)\n-    {\n-      inline_forbidden_reason\n-\t= G_(\"function %q+F can never be inlined \"\n-\t     \"because it saves address of local label in a static variable\");\n-      return node;\n-    }\n-\n-  if (TYPE_P (node))\n-    *walk_subtrees = 0;\n-\n-  return NULL_TREE;\n-}\n-\n /* Return true if FNDECL is a function that cannot be inlined into\n    another one.  */\n \n static bool\n inline_forbidden_p (tree fndecl)\n {\n   struct function *fun = DECL_STRUCT_FUNCTION (fndecl);\n-  tree step;\n   struct walk_stmt_info wi;\n   struct pointer_set_t *visited_nodes;\n   basic_block bb;\n   bool forbidden_p = false;\n \n+  /* First check for shared reasons not to copy the code.  */\n+  inline_forbidden_reason = copy_forbidden (fun, fndecl);\n+  if (inline_forbidden_reason != NULL)\n+    return true;\n+\n+  /* Next, walk the statements of the function looking for\n+     constraucts we can't handle, or are non-optimal for inlining.  */\n   visited_nodes = pointer_set_create ();\n   memset (&wi, 0, sizeof (wi));\n   wi.info = (void *) fndecl;\n@@ -2664,40 +2695,21 @@ inline_forbidden_p (tree fndecl)\n     {\n       gimple ret;\n       gimple_seq seq = bb_seq (bb);\n-      ret = walk_gimple_seq (seq, inline_forbidden_p_stmt,\n-\t\t\t     inline_forbidden_p_op, &wi);\n+      ret = walk_gimple_seq (seq, inline_forbidden_p_stmt, NULL, &wi);\n       forbidden_p = (ret != NULL);\n       if (forbidden_p)\n-\tgoto egress;\n-    }\n-\n-  for (step = fun->local_decls; step; step = TREE_CHAIN (step))\n-    {\n-      tree decl = TREE_VALUE (step);\n-      if (TREE_CODE (decl) == VAR_DECL\n-\t  && TREE_STATIC (decl)\n-\t  && !DECL_EXTERNAL (decl)\n-\t  && DECL_INITIAL (decl))\n-        {\n-\t  tree ret;\n-\t  ret = walk_tree_without_duplicates (&DECL_INITIAL (decl),\n-\t\t\t\t\t      inline_forbidden_p_2, fndecl);\n-\t  forbidden_p = (ret != NULL);\n-\t  if (forbidden_p)\n-\t    goto egress;\n-        }\n+\tbreak;\n     }\n \n-egress:\n   pointer_set_destroy (visited_nodes);\n   return forbidden_p;\n }\n \n /* Returns nonzero if FN is a function that does not have any\n    fundamental inline blocking properties.  */\n \n-static bool\n-inlinable_function_p (tree fn)\n+bool\n+tree_inlinable_function_p (tree fn)\n {\n   bool inlinable = true;\n   bool do_warning;\n@@ -4304,17 +4316,11 @@ copy_static_chain (tree static_chain, copy_body_data * id)\n \n /* Return true if the function is allowed to be versioned.\n    This is a guard for the versioning functionality.  */\n+\n bool\n tree_versionable_function_p (tree fndecl)\n {\n-  if (fndecl == NULL_TREE)\n-    return false;\n-  /* ??? There are cases where a function is\n-     uninlinable but can be versioned.  */\n-  if (!tree_inlinable_function_p (fndecl))\n-    return false;\n-  \n-  return true;\n+  return copy_forbidden (DECL_STRUCT_FUNCTION (fndecl), fndecl) == NULL;\n }\n \n /* Delete all unreachable basic blocks and update callgraph.\n@@ -4420,7 +4426,8 @@ delete_unreachable_blocks_update_callgraph (copy_body_data *id)\n    trees. If UPDATE_CLONES is set, the call_stmt fields\n    of edges of clones of the function will be updated.  */\n void\n-tree_function_versioning (tree old_decl, tree new_decl, VEC(ipa_replace_map_p,gc)* tree_map,\n+tree_function_versioning (tree old_decl, tree new_decl,\n+\t\t\t  VEC(ipa_replace_map_p,gc)* tree_map,\n \t\t\t  bool update_clones, bitmap args_to_skip)\n {\n   struct cgraph_node *old_version_node;\n@@ -4547,7 +4554,8 @@ tree_function_versioning (tree old_decl, tree new_decl, VEC(ipa_replace_map_p,gc\n       }\n   \n   /* Copy the Function's body.  */\n-  copy_body (&id, old_entry_block->count, old_entry_block->frequency, ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR);\n+  copy_body (&id, old_entry_block->count, old_entry_block->frequency,\n+\t     ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR);\n   \n   if (DECL_RESULT (old_decl) != NULL_TREE)\n     {\n@@ -4566,6 +4574,16 @@ tree_function_versioning (tree old_decl, tree new_decl, VEC(ipa_replace_map_p,gc\n \tinsert_init_stmt (bb, VEC_pop (gimple, init_stmts));\n     }\n \n+  /* Remap the nonlocal_goto_save_area, if any.  */\n+  if (cfun->nonlocal_goto_save_area)\n+    {\n+      struct walk_stmt_info wi;\n+\n+      memset (&wi, 0, sizeof (wi));\n+      wi.info = &id;\n+      walk_tree (&cfun->nonlocal_goto_save_area, remap_gimple_op_r, &wi, NULL);\n+    }\n+\n   /* Clean up.  */\n   pointer_map_destroy (id.decl_map);\n   free_dominance_info (CDI_DOMINATORS);"}]}