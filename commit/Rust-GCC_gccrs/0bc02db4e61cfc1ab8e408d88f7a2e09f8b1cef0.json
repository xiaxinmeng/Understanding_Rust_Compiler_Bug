{"sha": "0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJjMDJkYjRlNjFjZmMxYWI4ZTQwOGQ4OGY3YTJlMDlmOGIxY2VmMA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@wrs.com", "date": "1998-06-02T20:11:21Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-06-02T20:11:21Z"}, "message": "expr.c (expand_builtin_setjmp): Handle BUILTIN_SETJMP_FRAME_VALUE.\n\n        * expr.c (expand_builtin_setjmp): Handle BUILTIN_SETJMP_FRAME_VALUE.\n        * i960.h (SETUP_FRAME_ADDRESSES, BUILTIN_SETJMP_FRAME_VALUE): Define.\n        * i960.md (ret, flush_register_windows): Define.\n        (nonlocal_goto): Likewise.  Nested function nonlocal gotos don't\n        work yet.\n        * tm.texi (BUILTIN_SETJMP_FRAME_VALUE): Document new macro.\n\nFrom-SVN: r20192", "tree": {"sha": "149e177d352af6c612cef699a23f5ac907ea20ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/149e177d352af6c612cef699a23f5ac907ea20ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0/comments", "author": null, "committer": null, "parents": [{"sha": "666e0f5ad52098975ed535bc3f3a128aa5c8bf51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/666e0f5ad52098975ed535bc3f3a128aa5c8bf51", "html_url": "https://github.com/Rust-GCC/gccrs/commit/666e0f5ad52098975ed535bc3f3a128aa5c8bf51"}], "stats": {"total": 125, "additions": 121, "deletions": 4}, "files": [{"sha": "5e58c0f4f7055d2a0b3766713c0b4b93bb8fdcfb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0", "patch": "@@ -1,3 +1,12 @@\n+1998-06-02  Mike Stump  <mrs@wrs.com>\n+\n+\t* expr.c (expand_builtin_setjmp): Handle BUILTIN_SETJMP_FRAME_VALUE.\n+\t* i960.h (SETUP_FRAME_ADDRESSES, BUILTIN_SETJMP_FRAME_VALUE): Define.\n+\t* i960.md (ret, flush_register_windows): Define.\n+\t(nonlocal_goto): Likewise.  Nested function nonlocal gotos don't\n+\twork yet.\n+\t* tm.texi (BUILTIN_SETJMP_FRAME_VALUE): Document new macro.\n+\n Tue Jun  2 14:02:38 1998  Richard Henderson  <rth@cygnus.com>\n \n \t* alpha.md (divsi3, udivsi3, modsi3, umodsi3): Enable, and work"}, {"sha": "4102c0ff27914c839e1ac9d540af8d4b77425f6d", "filename": "gcc/config/i960/i960.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0/gcc%2Fconfig%2Fi960%2Fi960.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0/gcc%2Fconfig%2Fi960%2Fi960.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.h?ref=0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0", "patch": "@@ -1495,6 +1495,13 @@ extern struct rtx_def *gen_compare_reg ();\n \t\t  CXT);\t\t\t\t\t\t\t\\\n }\n \n+/* Generate RTL to flush the register windows so as to make arbitrary frames\n+   available.  */\n+#define SETUP_FRAME_ADDRESSES()\t\t\\\n+  emit_insn (gen_flush_register_windows ())\n+\n+#define BUILTIN_SETJMP_FRAME_VALUE hard_frame_pointer_rtx\n+\n #if 0\n /* Promote char and short arguments to ints, when want compatibility with\n    the iC960 compilers.  */"}, {"sha": "c99c6c1fdc9b541665e5f32de5a84a4409ae69d8", "filename": "gcc/config/i960/i960.md", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0/gcc%2Fconfig%2Fi960%2Fi960.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0/gcc%2Fconfig%2Fi960%2Fi960.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi960%2Fi960.md?ref=0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0", "patch": "@@ -2287,6 +2287,95 @@\n   \"* return i960_output_ret_insn (insn);\"\n   [(set_attr \"type\" \"branch\")])\n \n+;; A return instruction.  Used only by nonlocal_goto to change the\n+;; stack pointer, frame pointer, previous frame pointer and the return\n+;; instruction pointer.\n+(define_insn \"ret\"\n+  [(use (reg:SI 16))\n+   (unspec_volatile [(const_int 0)] 3)]\n+  \"\"\n+  \"ret\"\n+  [(set_attr \"type\" \"branch\")\n+   (set_attr \"length\" \"1\")])\n+\n+(define_expand \"nonlocal_goto\"\n+  [(match_operand:SI 0 \"\" \"\")\n+   (match_operand:SI 1 \"general_operand\" \"\")\n+   (match_operand:SI 2 \"general_operand\" \"\")\n+   (match_operand:SI 3 \"general_operand\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx fp = operands[1];\n+  rtx new_pc = operands[3];\n+  rtx stack = operands[2];\n+  rtx val = operands[0];\n+\n+  /* This code isn't sufficient to make nonlocal_gotos for nested\n+     functions to work fully.  Here we assume that the passed frame\n+     pointer is a real hard frame pointer, not a\n+     virtual_stack_vars_rtx type of frame.  */\n+\n+  /* We must restore the stack pointer, frame pointer, previous frame\n+     pointer and the return instruction pointer.  Since the ret\n+     instruction does all this for us with one instruction, we arrange\n+     everything so that ret will do everything we need done.  */\n+\n+  if (GET_CODE (fp) != REG)\n+    fp = force_reg (Pmode, fp);\n+  if (GET_CODE (val) != REG)\n+    val = force_reg (Pmode, val);\n+  if (GET_CODE (new_pc) != REG)\n+    new_pc = force_reg (Pmode, new_pc);\n+\n+\n+  /* First, we must flush the register windows, so that we can modify\n+     the saved local registers on the stack directly and because we\n+     are going to change the previous frame pointer.  */\n+\n+  emit_insn (gen_flush_register_windows ());\n+\n+  /* Next, we put the address that we want to transfer to, into the\n+     saved $rip value on the stack.  Once we ret below, that value\n+     will be loaded into the pc (IP).  */\n+\n+  emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t   plus_constant (fp, 8)),\n+\t\t  new_pc);\n+\n+  /* Next, we put the value into the static chain register's save\n+     area on the stack.  After the ret below, this will be loaded into\n+     r3 (the static chain).  */\n+     \n+  emit_move_insn (gen_rtx (MEM, SImode,\n+\t\t\t   plus_constant (fp, 12)),\n+\t\t  val);\n+\n+  /* We now load pfp (the previous frame pointer) with the value that\n+     we want fp to be.  */\n+\n+  emit_move_insn (gen_rtx (REG, SImode, 16), fp);\n+\n+  /* And finally, we can now just ret to get all the values saved\n+     above into all the right registers, and also, all the local\n+     register that were in use in the function, are restored from\n+     their saved values (from the call instruction) on the stack\n+     because we are very careful to ret from the exact save area in\n+     use during the original call.  */\n+\n+  emit_insn (gen_ret ());\n+  emit_barrier ();\n+  DONE;\n+}\")\n+\n+;; Special insn to flush register windows.\n+(define_insn \"flush_register_windows\"\n+  [(unspec_volatile [(const_int 0)] 1)]\n+  \"\"\n+  \"flushreg\"\n+  [(set_attr \"type\" \"misc\")\n+   (set_attr \"length\" \"1\")])\n+\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\""}, {"sha": "f6b52163e988f50de17e008e264c18f94cd1c33e", "filename": "gcc/expr.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0", "patch": "@@ -7725,11 +7725,15 @@ expand_builtin_setjmp (buf_addr, target, first_label, next_label)\n \n   emit_queue ();\n \n+#ifndef BUILTIN_SETJMP_FRAME_VALUE\n+#define BUILTIN_SETJMP_FRAME_VALUE virtual_stack_vars_rtx\n+#endif\n+\n   /* We store the frame pointer and the address of lab1 in the buffer\n      and use the rest of it for the stack save area, which is\n      machine-dependent.  */\n   emit_move_insn (gen_rtx_MEM (Pmode, buf_addr),\n-\t\t  virtual_stack_vars_rtx);\n+\t\t  BUILTIN_SETJMP_FRAME_VALUE);\n   emit_move_insn (validize_mem\n \t\t  (gen_rtx_MEM (Pmode,\n \t\t\t\tplus_constant (buf_addr,"}, {"sha": "b03e79100f0d838b7941e89c98ec16c95a7e61d3", "filename": "gcc/tm.texi", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0/gcc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0/gcc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftm.texi?ref=0bc02db4e61cfc1ab8e408d88f7a2e09f8b1cef0", "patch": "@@ -2188,12 +2188,20 @@ of @var{frameaddr}---that is, the stack frame address is also the\n address of the stack word that points to the previous frame.\n \n @findex SETUP_FRAME_ADDRESSES\n-@item SETUP_FRAME_ADDRESSES ()\n+@item SETUP_FRAME_ADDRESSES\n If defined, a C expression that produces the machine-specific code to\n setup the stack so that arbitrary frames can be accessed.  For example,\n on the Sparc, we must flush all of the register windows to the stack\n-before we can access arbitrary stack frames.\n-This macro will seldom need to be defined.\n+before we can access arbitrary stack frames.  You will seldom need to\n+define this macro.\n+\n+@findex BUILTIN_SETJMP_FRAME_VALUE\n+@item BUILTIN_SETJMP_FRAME_VALUE\n+If defined, a C expression that contains an rtx that is used to store\n+the address of the current frame into the built in @code{setjmp} buffer.\n+The default value, @code{virtual_stack_vars_rtx}, is correct for most\n+machines.  One reason you may need to define this macro is if\n+@code{hard_frame_pointer_rtx} is the appropriate value on your machine.\n \n @findex RETURN_ADDR_RTX\n @item RETURN_ADDR_RTX (@var{count}, @var{frameaddr})"}]}