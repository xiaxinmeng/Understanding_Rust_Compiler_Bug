{"sha": "74558dd9af65ab24f2cd45a1d0959562e6b14d41", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzQ1NThkZDlhZjY1YWIyNGYyY2Q0NWExZDA5NTk1NjJlNmIxNGQ0MQ==", "commit": {"author": {"name": "Balaji V. Iyer", "email": "balaji.v.iyer@intel.com", "date": "2014-01-23T15:21:42Z"}, "committer": {"name": "Balaji V. Iyer", "email": "bviyer@gcc.gnu.org", "date": "2014-01-23T15:21:42Z"}, "message": "Added support for Cilk Plus SIMD-enabled functions for C++.\n\ngcc/c/c-parser.c\n2014-01-23  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * c-parser.c (c_finish_omp_declare_simd): Made \"cilk simd function\"\n        attribute an attribute without value.\n\ngcc/cp/ChangeLog\n2014-01-23  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * parser.c (cp_parser_direct_declarator): When Cilk Plus is enabled\n        see if there is an attribute after function decl.  If so, then\n        parse them now.\n        (cp_parser_late_return_type_opt): Handle parsing of Cilk Plus SIMD\n        enabled function late parsing.\n        (cp_parser_gnu_attribute_list): Parse all the tokens for the vector\n        attribute for a SIMD-enabled function.\n        (cp_parser_omp_all_clauses): Skip parsing to the end of pragma when\n        the function is used by SIMD-enabled function (indicated by NULL\n        pragma token).   Added 3 new clauses: PRAGMA_CILK_CLAUSE_MASK,\n        PRAGMA_CILK_CLAUSE_NOMASK and PRAGMA_CILK_CLAUSE_VECTORLENGTH\n        (cp_parser_cilk_simd_vectorlength): Modified this function to handle\n        vectorlength clause in SIMD-enabled function and #pragma SIMD's\n        vectorlength clause.  Added a new bool parameter to differentiate\n        between the two.\n        (cp_parser_cilk_simd_fn_vector_attrs): New function.\n        (is_cilkplus_vector_p): Likewise.\n        (cp_parser_late_parsing_elem_fn_info): Likewise.\n        (cp_parser_omp_clause_name): Added a check for \"mask\", \"nomask\"\n        and \"vectorlength\" clauses when Cilk Plus is enabled.\n        (cp_parser_omp_clause_linear): Added a new parameter of type bool\n        and emit a sorry message when step size is a parameter.\n        * parser.h (cp_parser::cilk_simd_fn_info): New field.\n        * decl.c (grokfndecl): Added flag_enable_cilkplus along with\n        flag_openmp.\n        * pt.c (apply_late_template_attributes): Likewise.\n\ntestsuite/ChangeLog\n2014-01-23  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n\n        * g++.dg/cilk-plus/cilk-plus.exp: Called the C/C++ common tests for\n        SIMD enabled function.\n        * g++.dg/cilk-plus/ef_test.C: New test.\n        * c-c++-common/cilk-plus/ef_error3.c: Made certain messages C specific\n        and added C++ ones.\n        * c-c++-common/cilk-plus/vlength_errors.c: Added new dg-error tags\n        to differenciate C error messages from C++ ones.\n\nFrom-SVN: r206975", "tree": {"sha": "090a19da06b7855d39561e04b7b038b353fb2a9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/090a19da06b7855d39561e04b7b038b353fb2a9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74558dd9af65ab24f2cd45a1d0959562e6b14d41", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74558dd9af65ab24f2cd45a1d0959562e6b14d41", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74558dd9af65ab24f2cd45a1d0959562e6b14d41", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74558dd9af65ab24f2cd45a1d0959562e6b14d41/comments", "author": null, "committer": null, "parents": [{"sha": "d5ecead9406647c58e178bccc1f9d85259b087e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d5ecead9406647c58e178bccc1f9d85259b087e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d5ecead9406647c58e178bccc1f9d85259b087e5"}], "stats": {"total": 379, "additions": 344, "deletions": 35}, "files": [{"sha": "8230c86eb86dab8afce3fab89569a041822224f6", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -1,3 +1,8 @@\n+2014-01-23  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* c-parser.c (c_finish_omp_declare_simd): Made \"cilk simd function\"\n+\tattribute an attribute without value.\n+\n 2014-01-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/58809"}, {"sha": "bbf5287651eb5445e9aa153eb0fecca3c7bab26d", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -12924,7 +12924,8 @@ c_finish_omp_declare_simd (c_parser *parser, tree fndecl, tree parms,\n \tc = tree_cons (NULL_TREE, c, NULL_TREE);\n       if (is_cilkplus_cilk_simd_fn) \n \t{ \n-\t  tree k = build_tree_list (get_identifier (\"cilk simd function\"), c);\n+\t  tree k = build_tree_list (get_identifier (\"cilk simd function\"), \n+\t\t\t\t    NULL_TREE);\n \t  TREE_CHAIN (k) = DECL_ATTRIBUTES (fndecl);\n \t  DECL_ATTRIBUTES (fndecl) = k;\n \t} "}, {"sha": "3946901cfc1723adcb666cd5240b3160c0e116fe", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -1,3 +1,32 @@\n+2014-01-23  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* parser.c (cp_parser_direct_declarator): When Cilk Plus is enabled\n+\tsee if there is an attribute after function decl.  If so, then\n+\tparse them now.\n+\t(cp_parser_late_return_type_opt): Handle parsing of Cilk Plus SIMD\n+\tenabled function late parsing.\n+\t(cp_parser_gnu_attribute_list): Parse all the tokens for the vector\n+\tattribute for a SIMD-enabled function.\n+\t(cp_parser_omp_all_clauses): Skip parsing to the end of pragma when\n+\tthe function is used by SIMD-enabled function (indicated by NULL\n+\tpragma token).   Added 3 new clauses: PRAGMA_CILK_CLAUSE_MASK,\n+\tPRAGMA_CILK_CLAUSE_NOMASK and PRAGMA_CILK_CLAUSE_VECTORLENGTH\n+\t(cp_parser_cilk_simd_vectorlength): Modified this function to handle\n+\tvectorlength clause in SIMD-enabled function and #pragma SIMD's\n+\tvectorlength clause.  Added a new bool parameter to differentiate\n+\tbetween the two.\n+\t(cp_parser_cilk_simd_fn_vector_attrs): New function.\n+\t(is_cilkplus_vector_p): Likewise.\n+\t(cp_parser_late_parsing_elem_fn_info): Likewise.\n+\t(cp_parser_omp_clause_name): Added a check for \"mask\", \"nomask\"\n+\tand \"vectorlength\" clauses when Cilk Plus is enabled.\n+\t(cp_parser_omp_clause_linear): Added a new parameter of type bool\n+\tand emit a sorry message when step size is a parameter.\n+\t* parser.h (cp_parser::cilk_simd_fn_info): New field.\n+\t* decl.c (grokfndecl): Added flag_enable_cilkplus along with\n+\tflag_openmp.\n+\t* pt.c (apply_late_template_attributes): Likewise.\n+\n 2014-01-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/58809"}, {"sha": "9918416e552d03aec9872fb45f947e0a45a66731", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -7674,7 +7674,7 @@ grokfndecl (tree ctype,\n   if (TYPE_NOTHROW_P (type) || nothrow_libfn_p (decl))\n     TREE_NOTHROW (decl) = 1;\n \n-  if (flag_openmp)\n+  if (flag_openmp || flag_enable_cilkplus)\n     {\n       /* Adjust \"omp declare simd\" attributes.  */\n       tree ods = lookup_attribute (\"omp declare simd\", *attrlist);"}, {"sha": "29bfadf3fbb29609a256d5545e686a4f6dd60922", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 241, "deletions": 27, "changes": 268, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -241,6 +241,8 @@ static void cp_parser_cilk_simd\n   (cp_parser *, cp_token *);\n static bool cp_parser_omp_declare_reduction_exprs\n   (tree, cp_parser *);\n+static tree cp_parser_cilk_simd_vectorlength \n+  (cp_parser *, tree, bool);\n \n /* Manifest constants.  */\n #define CP_LEXER_BUFFER_SIZE ((256 * 1024) / sizeof (cp_token))\n@@ -2115,6 +2117,9 @@ static bool cp_parser_ctor_initializer_opt_and_function_body\n static tree cp_parser_late_parsing_omp_declare_simd\n   (cp_parser *, tree);\n \n+static tree cp_parser_late_parsing_cilk_simd_fn_info\n+  (cp_parser *, tree);\n+\n static tree synthesize_implicit_template_parm\n   (cp_parser *);\n static tree finish_fully_implicit_template\n@@ -17121,6 +17126,24 @@ cp_parser_direct_declarator (cp_parser* parser,\n \n \t\t  attrs = cp_parser_std_attribute_spec_seq (parser);\n \n+\t\t  /* In here, we handle cases where attribute is used after\n+\t\t     the function declaration.  For example:\n+\t\t     void func (int x) __attribute__((vector(..)));  */\n+\t\t  if (flag_enable_cilkplus\n+\t\t      && cp_next_tokens_can_be_gnu_attribute_p (parser))\n+\t\t    {\n+\t\t      cp_parser_parse_tentatively (parser);\n+\t\t      tree attr = cp_parser_gnu_attributes_opt (parser);\n+\t\t      if (cp_lexer_next_token_is_not (parser->lexer,\n+\t\t\t\t\t\t      CPP_SEMICOLON)\n+\t\t\t  && cp_lexer_next_token_is_not (parser->lexer,\n+\t\t\t\t\t\t\t CPP_OPEN_BRACE))\n+\t\t\tcp_parser_abort_tentative_parse (parser);\n+\t\t      else if (!cp_parser_parse_definitely (parser))\n+\t\t\t;\n+\t\t      else\n+\t\t\tattrs = chainon (attr, attrs);\n+\t\t    }\n \t\t  late_return = (cp_parser_late_return_type_opt\n \t\t\t\t (parser, declarator,\n \t\t\t\t  memfn ? cv_quals : -1));\n@@ -17829,7 +17852,7 @@ parsing_nsdmi (void)\n    Returns the type indicated by the type-id.\n \n    In addition to this this parses any queued up omp declare simd\n-   clauses.\n+   clauses and Cilk Plus SIMD-enabled function's vector attributes.\n \n    QUALS is either a bitmask of cv_qualifiers or -1 for a non-member\n    function.  */\n@@ -17844,10 +17867,13 @@ cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,\n \t\t\t && declarator\n \t\t\t && declarator->kind == cdk_id);\n \n+  bool cilk_simd_fn_vector_p = (parser->cilk_simd_fn_info \n+\t\t\t\t&& declarator && declarator->kind == cdk_id);\n+  \n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n   /* A late-specified return type is indicated by an initial '->'. */\n-  if (token->type != CPP_DEREF && !declare_simd_p)\n+  if (token->type != CPP_DEREF && !(declare_simd_p || cilk_simd_fn_vector_p))\n     return NULL_TREE;\n \n   tree save_ccp = current_class_ptr;\n@@ -17866,6 +17892,10 @@ cp_parser_late_return_type_opt (cp_parser* parser, cp_declarator *declarator,\n       type = cp_parser_trailing_type_id (parser);\n     }\n \n+  if (cilk_simd_fn_vector_p)\n+    declarator->std_attributes\n+      = cp_parser_late_parsing_cilk_simd_fn_info (parser,\n+\t\t\t\t\t\t  declarator->std_attributes);\n   if (declare_simd_p)\n     declarator->std_attributes\n       = cp_parser_late_parsing_omp_declare_simd (parser,\n@@ -21409,6 +21439,56 @@ cp_parser_attributes_opt (cp_parser *parser)\n   return cp_parser_std_attribute_spec_seq (parser);\n }\n \n+#define CILK_SIMD_FN_CLAUSE_MASK\t\t\t\t  \\\n+\t((OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_VECTORLENGTH)\t  \\\n+\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_LINEAR)\t  \\\n+\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_UNIFORM)\t  \\\n+\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_MASK)\t  \\\n+\t | (OMP_CLAUSE_MASK_1 << PRAGMA_CILK_CLAUSE_NOMASK))\n+\n+/* Parses the Cilk Plus SIMD-enabled function's attribute.  Syntax:\n+   vector [(<clauses>)]  */\n+\n+static void\n+cp_parser_cilk_simd_fn_vector_attrs (cp_parser *parser, cp_token *v_token)\n+{  \n+  bool first_p = parser->cilk_simd_fn_info == NULL;\n+  cp_token *token = v_token;\n+  if (first_p)\n+    {\n+      parser->cilk_simd_fn_info = XNEW (cp_omp_declare_simd_data);\n+      parser->cilk_simd_fn_info->error_seen = false;\n+      parser->cilk_simd_fn_info->fndecl_seen = false;\n+      parser->cilk_simd_fn_info->tokens = vNULL;\n+    }\n+  int paren_scope = 0;\n+  if (cp_lexer_next_token_is (parser->lexer, CPP_OPEN_PAREN))\n+    {\n+      cp_lexer_consume_token (parser->lexer);\n+      v_token = cp_lexer_peek_token (parser->lexer);\n+      paren_scope++;\n+    }\n+  while (paren_scope > 0)\n+    {\n+      token = cp_lexer_peek_token (parser->lexer);\n+      if (token->type == CPP_OPEN_PAREN)\n+\tparen_scope++;\n+      else if (token->type == CPP_CLOSE_PAREN)\n+\tparen_scope--;\n+      /* Do not push the last ')'  */\n+      if (!(token->type == CPP_CLOSE_PAREN && paren_scope == 0))\n+\tcp_lexer_consume_token (parser->lexer);\n+    }\n+\n+  token->type = CPP_PRAGMA_EOL;\n+  parser->lexer->next_token = token;\n+  cp_lexer_consume_token (parser->lexer);\n+\n+  struct cp_token_cache *cp\n+    = cp_token_cache_new (v_token, cp_lexer_peek_token (parser->lexer));\n+  parser->cilk_simd_fn_info->tokens.safe_push (cp);\n+}\n+\n /* Parse an (optional) series of attributes.\n \n    attributes:\n@@ -21467,6 +21547,17 @@ cp_parser_gnu_attributes_opt (cp_parser* parser)\n   return attributes;\n }\n \n+/* Returns true of NAME is an IDENTIFIER_NODE with identiifer \"vector,\"\n+   \"__vector\" or \"__vector__.\"  */\n+\n+static inline bool\n+is_cilkplus_vector_p (tree name)\n+{ \n+  if (flag_enable_cilkplus && is_attribute_p (\"vector\", name)) \n+    return true;\n+  return false;\n+}\n+\n /* Parse a GNU attribute-list.\n \n    attribute-list:\n@@ -21505,16 +21596,17 @@ cp_parser_gnu_attribute_list (cp_parser* parser)\n \t{\n \t  tree arguments = NULL_TREE;\n \n-\t  /* Consume the token.  */\n-\t  token = cp_lexer_consume_token (parser->lexer);\n+\t  /* Consume the token, but save it since we need it for the\n+\t     SIMD enabled function parsing.  */\n+\t  cp_token *id_token = cp_lexer_consume_token (parser->lexer);\n \n \t  /* Save away the identifier that indicates which attribute\n \t     this is.  */\n \t  identifier = (token->type == CPP_KEYWORD) \n \t    /* For keywords, use the canonical spelling, not the\n \t       parsed identifier.  */\n \t    ? ridpointers[(int) token->keyword]\n-\t    : token->u.value;\n+\t    : id_token->u.value;\n \t  \n \t  attribute = build_tree_list (identifier, NULL_TREE);\n \n@@ -21526,10 +21618,16 @@ cp_parser_gnu_attribute_list (cp_parser* parser)\n \t      vec<tree, va_gc> *vec;\n \t      int attr_flag = (attribute_takes_identifier_p (identifier)\n \t\t\t       ? id_attr : normal_attr);\n-\t      vec = cp_parser_parenthesized_expression_list\n-\t\t    (parser, attr_flag, /*cast_p=*/false,\n-\t\t     /*allow_expansion_p=*/false,\n-\t\t     /*non_constant_p=*/NULL);\n+\t      if (is_cilkplus_vector_p (identifier))\n+\t\t{\n+\t\t  cp_parser_cilk_simd_fn_vector_attrs (parser, id_token);\n+\t\t  continue;\n+\t\t}\n+\t      else\n+\t\tvec = cp_parser_parenthesized_expression_list \n+\t\t  (parser, attr_flag, /*cast_p=*/false, \n+\t\t   /*allow_expansion_p=*/false, \n+\t\t   /*non_constant_p=*/NULL);\n \t      if (vec == NULL)\n \t\targuments = error_mark_node;\n \t      else\n@@ -21540,6 +21638,11 @@ cp_parser_gnu_attribute_list (cp_parser* parser)\n \t      /* Save the arguments away.  */\n \t      TREE_VALUE (attribute) = arguments;\n \t    }\n+\t  else if (is_cilkplus_vector_p (identifier))\n+\t    {\n+\t      cp_parser_cilk_simd_fn_vector_attrs (parser, id_token);\n+\t      continue;\n+\t    }\n \n \t  if (arguments != error_mark_node)\n \t    {\n@@ -26819,12 +26922,16 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t    result = PRAGMA_OMP_CLAUSE_MAP;\n \t  else if (!strcmp (\"mergeable\", p))\n \t    result = PRAGMA_OMP_CLAUSE_MERGEABLE;\n+\t  else if (flag_enable_cilkplus && !strcmp (\"mask\", p))\n+\t    result = PRAGMA_CILK_CLAUSE_MASK;\n \t  break;\n \tcase 'n':\n \t  if (!strcmp (\"notinbranch\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOTINBRANCH;\n \t  else if (!strcmp (\"nowait\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NOWAIT;\n+\t  else if (flag_enable_cilkplus && !strcmp (\"nomask\", p))\n+\t    result = PRAGMA_CILK_CLAUSE_NOMASK;\n \t  else if (!strcmp (\"num_teams\", p))\n \t    result = PRAGMA_OMP_CLAUSE_NUM_TEAMS;\n \t  else if (!strcmp (\"num_threads\", p))\n@@ -26870,6 +26977,10 @@ cp_parser_omp_clause_name (cp_parser *parser)\n \t  else if (!strcmp (\"untied\", p))\n \t    result = PRAGMA_OMP_CLAUSE_UNTIED;\n \t  break;\n+\tcase 'v':\n+\t  if (flag_enable_cilkplus && !strcmp (\"vectorlength\", p))\n+\t    result = PRAGMA_CILK_CLAUSE_VECTORLENGTH;\n+\t  break;\n \t}\n     }\n \n@@ -27622,7 +27733,8 @@ cp_parser_omp_clause_aligned (cp_parser *parser, tree list)\n    linear ( variable-list : expression )  */\n \n static tree\n-cp_parser_omp_clause_linear (cp_parser *parser, tree list)\n+cp_parser_omp_clause_linear (cp_parser *parser, tree list, \n+\t\t\t     bool is_cilk_simd_fn)\n {\n   tree nlist, c, step = integer_one_node;\n   bool colon;\n@@ -27637,6 +27749,11 @@ cp_parser_omp_clause_linear (cp_parser *parser, tree list)\n     {\n       step = cp_parser_expression (parser, false, NULL);\n \n+      if (is_cilk_simd_fn && TREE_CODE (step) == PARM_DECL)\n+\t{\n+\t  sorry (\"using parameters for %<linear%> step is not supported yet\");\n+\t  step = integer_one_node;\n+\t}\n       if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n \tcp_parser_skip_to_closing_parenthesis (parser, /*recovering=*/true,\n \t\t\t\t\t       /*or_comma=*/false,\n@@ -27958,6 +28075,7 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n   tree clauses = NULL;\n   bool first = true;\n   cp_token *token = NULL;\n+  bool cilk_simd_fn = false;\n \n   while (cp_lexer_next_token_is_not (parser->lexer, CPP_PRAGMA_EOL))\n     {\n@@ -28054,11 +28172,13 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  c_name = \"untied\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_INBRANCH:\n+\tcase PRAGMA_CILK_CLAUSE_MASK:\n \t  clauses = cp_parser_omp_clause_branch (parser, OMP_CLAUSE_INBRANCH,\n \t\t\t\t\t\t clauses, token->location);\n \t  c_name = \"inbranch\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_NOTINBRANCH:\n+\tcase PRAGMA_CILK_CLAUSE_NOMASK:\n \t  clauses = cp_parser_omp_clause_branch (parser,\n \t\t\t\t\t\t OMP_CLAUSE_NOTINBRANCH,\n \t\t\t\t\t\t clauses, token->location);\n@@ -28127,7 +28247,9 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t  c_name = \"aligned\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_LINEAR:\n-\t  clauses = cp_parser_omp_clause_linear (parser, clauses);\n+\t  if (((mask >> PRAGMA_CILK_CLAUSE_VECTORLENGTH) & 1) != 0)\n+\t    cilk_simd_fn = true;\n+\t  clauses = cp_parser_omp_clause_linear (parser, clauses, cilk_simd_fn);\n \t  c_name = \"linear\";\n \t  break;\n \tcase PRAGMA_OMP_CLAUSE_DEPEND:\n@@ -28163,6 +28285,10 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t\t\t\t\t\t  token->location);\n \t  c_name = \"simdlen\";\n \t  break;\n+\tcase PRAGMA_CILK_CLAUSE_VECTORLENGTH:\n+\t  clauses = cp_parser_cilk_simd_vectorlength (parser, clauses, true);\n+\t  c_name = \"simdlen\";\n+\t  break;\n \tdefault:\n \t  cp_parser_error (parser, \"expected %<#pragma omp%> clause\");\n \t  goto saw_error;\n@@ -28179,7 +28305,10 @@ cp_parser_omp_all_clauses (cp_parser *parser, omp_clause_mask mask,\n \t}\n     }\n  saw_error:\n-  cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n+  /* In Cilk Plus SIMD enabled functions there is no pragma_token, so\n+     no reason to skip to the end.  */\n+  if (!(flag_enable_cilkplus && pragma_tok == NULL))\n+    cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n   if (finish_p)\n     return finish_omp_clauses (clauses);\n   return clauses;\n@@ -30181,6 +30310,63 @@ cp_parser_omp_declare_simd (cp_parser *parser, cp_token *pragma_tok,\n     }\n }\n \n+/* Handles the delayed parsing of the Cilk Plus SIMD-enabled function.  \n+   This function is modelled similar to the late parsing of omp declare \n+   simd.  */\n+\n+static tree\n+cp_parser_late_parsing_cilk_simd_fn_info (cp_parser *parser, tree attrs)\n+{\n+  struct cp_token_cache *ce;\n+  cp_omp_declare_simd_data *info = parser->cilk_simd_fn_info;\n+  int ii = 0;\n+\n+  if (parser->omp_declare_simd != NULL)\n+    {\n+      error (\"%<#pragma omp declare simd%> cannot be used in the same function\"\n+\t     \" marked as a Cilk Plus SIMD-enabled function\");\n+      XDELETE (parser->cilk_simd_fn_info);\n+      parser->cilk_simd_fn_info = NULL;\n+      return attrs;\n+    }\n+  if (!info->error_seen && info->fndecl_seen)\n+    {\n+      error (\"vector attribute not immediately followed by a single function\"\n+\t     \" declaration or definition\");\n+      info->error_seen = true;\n+    }\n+  if (info->error_seen)\n+    return attrs;\n+\n+  FOR_EACH_VEC_ELT (info->tokens, ii, ce)\n+    {\n+      tree c, cl;\n+\n+      cp_parser_push_lexer_for_tokens (parser, ce);\n+      parser->lexer->in_pragma = true;\n+      cl = cp_parser_omp_all_clauses (parser, CILK_SIMD_FN_CLAUSE_MASK,\n+\t\t\t\t      \"SIMD-enabled functions attribute\", \n+\t\t\t\t      NULL);\n+      cp_parser_pop_lexer (parser);\n+      if (cl)\n+\tcl = tree_cons (NULL_TREE, cl, NULL_TREE);\n+\n+      c = build_tree_list (get_identifier (\"cilk simd function\"), NULL_TREE);\n+      TREE_CHAIN (c) = attrs;\n+      attrs = c;\n+\n+      c = build_tree_list (get_identifier (\"omp declare simd\"), cl);\n+      TREE_CHAIN (c) = attrs;\n+      if (processing_template_decl)\n+\tATTR_IS_DEPENDENT (c) = 1;\n+      attrs = c;\n+    }\n+  info->fndecl_seen = true;\n+  XDELETE (parser->cilk_simd_fn_info);\n+  parser->cilk_simd_fn_info = NULL;\n+  return attrs;\n+}\n+\n /* Finalize #pragma omp declare simd clauses after direct declarator has\n    been parsed, and put that into \"omp declare simd\" attribute.  */\n \n@@ -31361,35 +31547,63 @@ c_parse_file (void)\n   the_parser = NULL;\n }\n \n-/* Parses the Cilk Plus #pragma simd vectorlength clause:\n+/* Parses the Cilk Plus #pragma simd and SIMD-enabled function attribute's \n+   vectorlength clause:\n    Syntax:\n    vectorlength ( constant-expression )  */\n \n static tree\n-cp_parser_cilk_simd_vectorlength (cp_parser *parser, tree clauses)\n+cp_parser_cilk_simd_vectorlength (cp_parser *parser, tree clauses,\n+\t\t\t\t  bool is_simd_fn)\n {\n   location_t loc = cp_lexer_peek_token (parser->lexer)->location;\n   tree expr;\n-  /* The vectorlength clause behaves exactly like OpenMP's safelen\n-     clause.  Thus, vectorlength is represented as OMP 4.0\n-     safelen.  */\n-  check_no_duplicate_clause (clauses, OMP_CLAUSE_SAFELEN, \"vectorlength\", loc);\n-  \n+  /* The vectorlength clause in #pragma simd behaves exactly like OpenMP's\n+     safelen clause.  Thus, vectorlength is represented as OMP 4.0\n+     safelen.  For SIMD-enabled function it is represented by OMP 4.0\n+     simdlen.  */\n+  if (!is_simd_fn)\n+    check_no_duplicate_clause (clauses, OMP_CLAUSE_SAFELEN, \"vectorlength\", \n+\t\t\t       loc);\n+  else\n+    check_no_duplicate_clause (clauses, OMP_CLAUSE_SIMDLEN, \"vectorlength\",\n+\t\t\t       loc);\n+\n   if (!cp_parser_require (parser, CPP_OPEN_PAREN, RT_OPEN_PAREN))\n     return error_mark_node;\n   \n   expr = cp_parser_constant_expression (parser, false, NULL);\n   expr = maybe_constant_value (expr);\n-\n-  if (TREE_CONSTANT (expr)\n+  \n+  /* If expr == error_mark_node, then don't emit any errors nor\n+     create a clause.  if any of the above functions returns\n+     error mark node then they would have emitted an error message.  */\n+  if (expr == error_mark_node)\n+    ;\n+  else if (!TREE_TYPE (expr)\n+\t   || !TREE_CONSTANT (expr)\n+\t   || !INTEGRAL_TYPE_P (TREE_TYPE (expr)))\n+    error_at (loc, \"vectorlength must be an integer constant\");\n+  else if (TREE_CONSTANT (expr)\n \t   && exact_log2 (TREE_INT_CST_LOW (expr)) == -1)\n     error_at (loc, \"vectorlength must be a power of 2\");\n-  else if (expr != error_mark_node)\n+  else \n     {\n-      tree c = build_omp_clause (loc, OMP_CLAUSE_SAFELEN);\n-      OMP_CLAUSE_SAFELEN_EXPR (c) = expr;\n-      OMP_CLAUSE_CHAIN (c) = clauses;\n-      clauses = c;\n+      tree c;\n+      if (!is_simd_fn)\n+\t{ \n+\t  c = build_omp_clause (loc, OMP_CLAUSE_SAFELEN); \n+\t  OMP_CLAUSE_SAFELEN_EXPR (c) = expr; \n+\t  OMP_CLAUSE_CHAIN (c) = clauses; \n+\t  clauses = c;\n+\t}\n+      else\n+\t{\n+\t  c = build_omp_clause (loc, OMP_CLAUSE_SIMDLEN);\n+\t  OMP_CLAUSE_SIMDLEN_EXPR (c) = expr;\n+\t  OMP_CLAUSE_CHAIN (c) = clauses;\n+\t  clauses = c;\n+\t}\n     }\n \n   if (!cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN))\n@@ -31552,7 +31766,7 @@ cp_parser_cilk_simd_all_clauses (cp_parser *parser, cp_token *pragma_token)\n       pragma_omp_clause c_kind;\n       c_kind = cp_parser_cilk_simd_clause_name (parser);\n       if (c_kind == PRAGMA_CILK_CLAUSE_VECTORLENGTH)\n-\tclauses = cp_parser_cilk_simd_vectorlength (parser, clauses);\n+\tclauses = cp_parser_cilk_simd_vectorlength (parser, clauses, false);\n       else if (c_kind == PRAGMA_CILK_CLAUSE_LINEAR)\n \tclauses = cp_parser_cilk_simd_linear (parser, clauses);\n       else if (c_kind == PRAGMA_CILK_CLAUSE_PRIVATE)"}, {"sha": "d558c607f4d0c49a9494bbd125c6581399ccde93", "filename": "gcc/cp/parser.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fcp%2Fparser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fcp%2Fparser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.h?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -362,6 +362,13 @@ typedef struct GTY(()) cp_parser {\n      data structure with everything needed for parsing the clauses.  */\n   cp_omp_declare_simd_data * GTY((skip)) omp_declare_simd;\n \n+  /* When parsing the vector attribute in Cilk Plus SIMD-enabled function,\n+     this is a pointer to data structure with everything needed for parsing\n+     the clauses.  The cp_omp_declare_simd_data struct will hold all the\n+     necessary information, so creating another struct for this is not\n+     necessary.  */\n+  cp_omp_declare_simd_data * GTY((skip)) cilk_simd_fn_info;\n+\n   /* Nonzero if parsing a parameter list where 'auto' should trigger an implicit\n      template parameter.  */\n   bool auto_is_implicit_function_template_parm_p;"}, {"sha": "a91df4cdab2f7b630e674f1191cff01040f5e1e5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -8613,7 +8613,7 @@ apply_late_template_attributes (tree *decl_p, tree attributes, int attr_flags,\n \t    {\n \t      *p = TREE_CHAIN (t);\n \t      TREE_CHAIN (t) = NULL_TREE;\n-\t      if (flag_openmp\n+\t      if ((flag_openmp || flag_enable_cilkplus)\n \t\t  && is_attribute_p (\"omp declare simd\",\n \t\t\t\t     get_attribute_name (t))\n \t\t  && TREE_VALUE (t))"}, {"sha": "f10db4772758d25d618d2335671254b1ad6d594e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -1,3 +1,13 @@\n+2014-01-23  Balaji V. Iyer  <balaji.v.iyer@intel.com>\n+\n+\t* g++.dg/cilk-plus/cilk-plus.exp: Called the C/C++ common tests for\n+\tSIMD enabled function.\n+\t* g++.dg/cilk-plus/ef_test.C: New test.\n+        * c-c++-common/cilk-plus/ef_error3.c: Made certain messages C specific\n+        and added C++ ones.\n+\t* c-c++-common/cilk-plus/vlength_errors.c: Added new dg-error tags\n+\tto differenciate C error messages from C++ ones.\n+\n 2014-01-23  Alex Velenko  <Alex.Velenko@arm.com>\n \n \t* gcc.target/aarch64/vld1-vst1_1.c: New test_case."}, {"sha": "195e9f1d7a661cea4c3fc01e8354993f6db84f3a", "filename": "gcc/testsuite/c-c++-common/cilk-plus/SE/ef_error3.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fef_error3.c?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -1,9 +1,9 @@\n /* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */\n /* { dg-options \"-fcilkplus -Wall\" } */\n \n-__attribute__((vector (linear (x:y))))\n+__attribute__((vector (linear (x:y)))) /* { dg-message \"parameter\" \"\" { target c++ } } */\n int func2 (int x, int y) \n-{ /* { dg-message \"using parameters for\" } */\n+{ /* { dg-message \"using parameters for\" \"\" { target c } } */\n   return (x+y);\n }\n "}, {"sha": "1bcf2a27ab90fb8e4f8870536046a63748a7bd5e", "filename": "gcc/testsuite/c-c++-common/cilk-plus/SE/vlength_errors.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fvlength_errors.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fvlength_errors.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fcilk-plus%2FSE%2Fvlength_errors.c?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -5,7 +5,8 @@\n \n int z = Q;\n \n-__attribute__ ((vector (uniform(x), vectorlength (), linear (y:1) ))) /* { dg-error \"expected expression\" } */\n+__attribute__ ((vector (uniform(x), vectorlength (), linear (y:1) ))) /* { dg-error \"expected expression\" \"\" { target c } } */ \n+     /* { dg-error \"expected primary-expression\" \"\" { target c++ }  8 } */ \n int func2 (int x, int y)\n {\n   int zq = 5;\n@@ -19,7 +20,8 @@ int func3 (int x, int y)\n   return x + (y*zq);\n }\n \n-__attribute__ ((vector (uniform(x), linear (y:1), vectorlength (z) ))) /* { dg-error \"vectorlength must be an integer\" } */\n+__attribute__ ((vector (uniform(x), linear (y:1), vectorlength (z) ))) /* { dg-error \"vectorlength must be an integer\" \"\" { target c } } */ \n+     /* { dg-error \"constant\" \"\" { target c++ } 23 } */\n int func4 (int x, int y)\n {\n   int zq = 5;\n@@ -33,7 +35,8 @@ int func5 (int x, int y)\n   return x + (y*zq);\n }\n \n-__attribute__ ((vector (uniform(x), vectorlength (z), linear (y:1)))) /* { dg-error \"vectorlength must be an integer\" } */\n+__attribute__ ((vector (uniform(x), vectorlength (z), linear (y:1)))) /* { dg-error \"vectorlength must be an integer\" \"\"  { target c } } */ \n+     /* { dg-error \"constant\" \"\" { target c++ }  38 } */\n int func6 (int x, int y)\n {\n   int zq = 5;"}, {"sha": "204a754585b8f97d06184e882a72a453358c279f", "filename": "gcc/testsuite/g++.dg/cilk-plus/cilk-plus.exp", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fcilk-plus.exp?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -33,6 +33,9 @@ set TEST_EXTRA_LIBS \"-L${library_var}/libcilkrts/.libs\"\n dg-init\n # Run the tests that are shared with C.\n g++-dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/PS/*.c]] \"\"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/SE/*.c]] \"-O3\" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/SE/*.c]] \" \" \" \"\n+dg-runtest [lsort [glob -nocomplain $srcdir/c-c++-common/cilk-plus/SE/*.c]] \"-g -O2\" \" \"\n # Run the C++ only tests.\n g++-dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.C]] \"\"\n dg-finish"}, {"sha": "3e75cbd925388c6ac3ed54a100cbc68c99f069f5", "filename": "gcc/testsuite/g++.dg/cilk-plus/ef_test.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fef_test.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74558dd9af65ab24f2cd45a1d0959562e6b14d41/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fef_test.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcilk-plus%2Fef_test.C?ref=74558dd9af65ab24f2cd45a1d0959562e6b14d41", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run }  */\n+/* { dg-options \"-fcilkplus\" } */\n+\n+\n+__attribute__((vector (nomask), vector(mask), vector(mask,linear(x:1))))\n+int func (int x)\n+{\n+  return x+5;\n+}\n+\n+\n+__attribute__((vector(mask,uniform (y), linear(x:1))))\n+__attribute__((vector (nomask, uniform (x), linear(y:1))))\n+int func2 (int x, int y)\n+{\n+  return x+y;\n+}\n+\n+int func4 (int x, int y) __attribute__((vector, vector (nomask), vector (uniform(y), linear(x:1))));\n+\n+\n+template <class T, class R>\n+__attribute__((vector, vector(mask,uniform (y), linear(x:1))))\n+T func3 (T x, R y)\n+{\n+  return x+(T)y;\n+}\n+\n+\n+\n+int main (void)\n+{\n+  if ((func3 (5, 4) + func2 (5, 4) + func (5) + (int) func3<long, int> (5, 4)) != \n+      (5 + 4) + (5 + 4) + (5 + 5) + (int) ((long)5 +(int)4))\n+    __builtin_abort ();\n+  return 0;\n+}"}]}