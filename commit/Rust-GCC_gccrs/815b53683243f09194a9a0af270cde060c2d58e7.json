{"sha": "815b53683243f09194a9a0af270cde060c2d58e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE1YjUzNjgzMjQzZjA5MTk0YTlhMGFmMjcwY2RlMDYwYzJkNThlNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2019-08-30T13:50:34Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2019-08-30T13:50:34Z"}, "message": "gigi.h (gigi_checking_assert): New macro.\n\n\t* gcc-interface/gigi.h (gigi_checking_assert): New macro.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Modular_Integer_Type>:\n\tRemove redundant test and adjust comments.  Minor tweaks.\n\t* gcc-interface/trans.c (Call_to_gnu): Do not generate range checks,\n\tinstead assert that the Do_Range_Check flag is not set.  Adjust call\n\tto convert_with_check.\n\t(gnat_to_gnu): Likewise.\n\t(assoc_to_constructor): Likewise.\n\t(pos_to_constructor): Likewise.  Remove GNAT_COMPONENT_TYPE parameter.\n\t(emit_range_check): Delete.\n\t(convert_with_check): Remove RANGE_P parameter and adjust.  Do a single\n\toverflow check for modular types.\n\nFrom-SVN: r275174", "tree": {"sha": "9e19d5a983504c5d22e0775588ca9c14f226c37c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9e19d5a983504c5d22e0775588ca9c14f226c37c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/815b53683243f09194a9a0af270cde060c2d58e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815b53683243f09194a9a0af270cde060c2d58e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/815b53683243f09194a9a0af270cde060c2d58e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/815b53683243f09194a9a0af270cde060c2d58e7/comments", "author": null, "committer": null, "parents": [{"sha": "3eefaaa9fe42837b1debc49575b4a5405bf0af3b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eefaaa9fe42837b1debc49575b4a5405bf0af3b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eefaaa9fe42837b1debc49575b4a5405bf0af3b"}], "stats": {"total": 229, "additions": 83, "deletions": 146}, "files": [{"sha": "923f4744a7bc52c23180b7711b5942c834081c42", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815b53683243f09194a9a0af270cde060c2d58e7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815b53683243f09194a9a0af270cde060c2d58e7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=815b53683243f09194a9a0af270cde060c2d58e7", "patch": "@@ -1,3 +1,18 @@\n+2019-08-30  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (gigi_checking_assert): New macro.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Modular_Integer_Type>:\n+\tRemove redundant test and adjust comments.  Minor tweaks.\n+\t* gcc-interface/trans.c (Call_to_gnu): Do not generate range checks,\n+\tinstead assert that the Do_Range_Check flag is not set.  Adjust call\n+\tto convert_with_check.\n+\t(gnat_to_gnu): Likewise.\n+\t(assoc_to_constructor): Likewise.\n+\t(pos_to_constructor): Likewise.  Remove GNAT_COMPONENT_TYPE parameter.\n+\t(emit_range_check): Delete.\n+\t(convert_with_check): Remove RANGE_P parameter and adjust.  Do a single\n+\toverflow check for modular types.\n+\n 2019-08-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/91283"}, {"sha": "54ceb8d323747a05750817d1b6048cb96a5d1988", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 17, "deletions": 22, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815b53683243f09194a9a0af270cde060c2d58e7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815b53683243f09194a9a0af270cde060c2d58e7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=815b53683243f09194a9a0af270cde060c2d58e7", "patch": "@@ -447,13 +447,13 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n      If we are not defining it, it must be a type or an entity that is defined\n      elsewhere or externally, otherwise we should have defined it already.  */\n   gcc_assert (definition\n-\t      || type_annotate_only\n \t      || is_type\n \t      || kind == E_Discriminant\n \t      || kind == E_Component\n \t      || kind == E_Label\n \t      || (kind == E_Constant && Present (Full_View (gnat_entity)))\n-\t      || Is_Public (gnat_entity));\n+\t      || Is_Public (gnat_entity)\n+\t      || type_annotate_only);\n \n   /* Get the name of the entity and set up the line number and filename of\n      the original definition for use in any decl we make.  Make sure we do\n@@ -1758,34 +1758,29 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \n     case E_Modular_Integer_Type:\n       {\n-\t/* For modular types, make the unsigned type of the proper number\n-\t   of bits and then set up the modulus, if required.  */\n-\ttree gnu_modulus, gnu_high = NULL_TREE;\n-\n \t/* Packed Array Impl. Types are supposed to be subtypes only.  */\n \tgcc_assert (!Is_Packed_Array_Impl_Type (gnat_entity));\n \n+\t/* For modular types, make the unsigned type of the proper number\n+\t   of bits and then set up the modulus, if required.  */\n \tgnu_type = make_unsigned_type (esize);\n \n-\t/* Get the modulus in this type.  If it overflows, assume it is because\n-\t   it is equal to 2**Esize.  Note that there is no overflow checking\n-\t   done on unsigned type, so we detect the overflow by looking for\n-\t   a modulus of zero, which is otherwise invalid.  */\n-\tgnu_modulus = UI_To_gnu (Modulus (gnat_entity), gnu_type);\n+\t/* Get the modulus in this type.  If the modulus overflows, assume\n+\t   that this is because it was equal to 2**Esize.  Note that there\n+\t   is no overflow checking done on unsigned types, so we detect the\n+\t   overflow by looking for a modulus of zero, which is invalid.  */\n+\ttree gnu_modulus = UI_To_gnu (Modulus (gnat_entity), gnu_type);\n \n+\t/* If the modulus is not 2**Esize, then this also means that the upper\n+\t   bound of the type, i.e. modulus - 1, is not maximal, so we create an\n+\t   extra subtype to carry it and set the modulus on the base type.  */\n \tif (!integer_zerop (gnu_modulus))\n \t  {\n+\t    TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"UMT\");\n \t    TYPE_MODULAR_P (gnu_type) = 1;\n \t    SET_TYPE_MODULUS (gnu_type, gnu_modulus);\n-\t    gnu_high = fold_build2 (MINUS_EXPR, gnu_type, gnu_modulus,\n-\t\t\t\t    build_int_cst (gnu_type, 1));\n-\t  }\n-\n-\t/* If the upper bound is not maximal, make an extra subtype.  */\n-\tif (gnu_high\n-\t    && !tree_int_cst_equal (gnu_high, TYPE_MAX_VALUE (gnu_type)))\n-\t  {\n-\t    TYPE_NAME (gnu_type) = create_concat_name (gnat_entity, \"UMT\");\n+\t    tree gnu_high = fold_build2 (MINUS_EXPR, gnu_type, gnu_modulus,\n+\t\t\t\t\t build_int_cst (gnu_type, 1));\n \t    gnu_type\n \t      = create_extra_subtype (gnu_type, TYPE_MIN_VALUE (gnu_type),\n \t\t\t\t      gnu_high);\n@@ -2987,8 +2982,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t\t|| Present (Record_Extension_Part (record_definition)))\n \t      record_definition = Record_Extension_Part (record_definition);\n \n-\t    gcc_assert (type_annotate_only\n-\t\t\t|| Present (Parent_Subtype (gnat_entity)));\n+\t    gcc_assert (Present (Parent_Subtype (gnat_entity))\n+\t\t        || type_annotate_only);\n \t  }\n \n \t/* Make a node for the record.  If we are not defining the record,"}, {"sha": "21af83ee7f80823f80ea57c7b4e1ddb9373dc8d1", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815b53683243f09194a9a0af270cde060c2d58e7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815b53683243f09194a9a0af270cde060c2d58e7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=815b53683243f09194a9a0af270cde060c2d58e7", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2018, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2019, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -1054,6 +1054,12 @@ extern void enumerate_modes (void (*f) (const char *, int, int, int, int, int,\n }\n #endif\n \n+/* Use gigi_checking_assert to test invariants in code generation mode.\n+   It's effective only if the compiler is configured with more checking\n+   than the release mode and can be disabled by means of -fchecking.  */\n+#define gigi_checking_assert(EXPR) \\\n+  gcc_checking_assert ((EXPR) || type_annotate_only)\n+\n /* If EXP's type is a VECTOR_TYPE, return EXP converted to the associated\n    TYPE_REPRESENTATIVE_ARRAY.  */\n "}, {"sha": "f21b9a84d940bd5ad2296273808d6bc13bde20e2", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 44, "deletions": 123, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/815b53683243f09194a9a0af270cde060c2d58e7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/815b53683243f09194a9a0af270cde060c2d58e7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=815b53683243f09194a9a0af270cde060c2d58e7", "patch": "@@ -231,14 +231,13 @@ static enum gimplify_status gnat_gimplify_stmt (tree *);\n static void elaborate_all_entities (Node_Id);\n static void process_freeze_entity (Node_Id);\n static void process_decls (List_Id, List_Id, Node_Id, bool, bool);\n-static tree emit_range_check (tree, Node_Id, Node_Id);\n static tree emit_check (tree, tree, int, Node_Id);\n static tree build_unary_op_trapv (enum tree_code, tree, tree, Node_Id);\n static tree build_binary_op_trapv (enum tree_code, tree, tree, tree, Node_Id);\n-static tree convert_with_check (Entity_Id, tree, bool, bool, bool, Node_Id);\n+static tree convert_with_check (Entity_Id, tree, bool, bool, Node_Id);\n static bool addressable_p (tree, tree);\n static tree assoc_to_constructor (Entity_Id, Node_Id, tree);\n-static tree pos_to_constructor (Node_Id, tree, Entity_Id);\n+static tree pos_to_constructor (Node_Id, tree);\n static void validate_unchecked_conversion (Node_Id);\n static Node_Id adjust_for_implicit_deref (Node_Id);\n static tree maybe_implicit_deref (tree);\n@@ -5407,11 +5406,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       else\n \tgnu_actual = convert (gnu_actual_type, gnu_actual);\n \n-      /* Make sure that the actual is in range of the formal's type.  */\n-      if (Ekind (gnat_formal) != E_Out_Parameter\n-\t  && Do_Range_Check (gnat_actual))\n-\tgnu_actual\n-\t  = emit_range_check (gnu_actual, gnat_formal_type, gnat_actual);\n+      gigi_checking_assert (!Do_Range_Check (gnat_actual));\n \n       /* First see if the parameter is passed by reference.  */\n       if (is_true_formal_parm && DECL_BY_REF_P (gnu_formal))\n@@ -5655,12 +5650,15 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t       conversion node and not from the inner Expression.  */\n \t    if (Nkind (gnat_actual) == N_Type_Conversion)\n \t      {\n+\t\tconst Node_Id gnat_expr = Expression (gnat_actual);\n+\n+\t\tgigi_checking_assert (!Do_Range_Check (gnat_expr));\n+\n \t\tgnu_result\n-\t\t  = convert_with_check\n-\t\t    (Etype (Expression (gnat_actual)), gnu_result,\n-\t\t     Do_Overflow_Check (gnat_actual),\n-\t\t     Do_Range_Check (Expression (gnat_actual)),\n-\t\t     Float_Truncate (gnat_actual), gnat_actual);\n+\t\t  = convert_with_check (Etype (gnat_expr), gnu_result,\n+\t\t\t\t\tDo_Overflow_Check (gnat_actual),\n+\t\t\t\t\tFloat_Truncate (gnat_actual),\n+\t\t\t\t\tgnat_actual);\n \n \t\tif (!Is_Composite_Type (Underlying_Type (Etype (gnat_formal))))\n \t\t  gnu_actual = convert (TREE_TYPE (gnu_result), gnu_actual);\n@@ -5676,10 +5674,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t\t\t\t\t      No_Truncation (gnat_actual));\n \t    else\n \t      {\n-\t\tif (Do_Range_Check (gnat_actual))\n-\t\t  gnu_result\n-\t\t    = emit_range_check (gnu_result, Etype (gnat_actual),\n-\t\t\t\t\tgnat_actual);\n+\t\tgigi_checking_assert (!Do_Range_Check (gnat_actual));\n \n \t\tif (!(!TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_actual)))\n \t\t      && TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_result)))))\n@@ -5736,11 +5731,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  Node_Id gnat_parent = Parent (gnat_node);\n \t  enum tree_code op_code;\n \n-\t  /* If range check is needed, emit code to generate it.  */\n-\t  if (Do_Range_Check (gnat_node))\n-\t    gnu_call\n-\t      = emit_range_check (gnu_call, Etype (Name (gnat_parent)),\n-\t\t\t\t  gnat_parent);\n+\t  gigi_checking_assert (!Do_Range_Check (gnat_node));\n \n \t  /* ??? If the return type has variable size, then force the return\n \t     slot optimization as we would not be able to create a temporary.\n@@ -7043,10 +7034,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  && (!type_annotate_only\n \t      || Compile_Time_Known_Value (Expression (gnat_node))))\n \t{\n+\t  gigi_checking_assert (!Do_Range_Check (Expression (gnat_node)));\n+\n \t  gnu_expr = gnat_to_gnu (Expression (gnat_node));\n-\t  if (Do_Range_Check (Expression (gnat_node)))\n-\t    gnu_expr\n-\t      = emit_range_check (gnu_expr, Etype (gnat_temp), gnat_node);\n \n \t  if (type_annotate_only && TREE_CODE (gnu_expr) == ERROR_MARK)\n \t    gnu_expr = NULL_TREE;\n@@ -7396,8 +7386,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t\t    gnu_aggr_type);\n \telse if (TREE_CODE (gnu_aggr_type) == ARRAY_TYPE)\n \t  gnu_result = pos_to_constructor (First (Expressions (gnat_node)),\n-\t\t\t\t\t   gnu_aggr_type,\n-\t\t\t\t\t   Component_Type (Etype (gnat_node)));\n+\t\t\t\t\t   gnu_aggr_type);\n \telse if (TREE_CODE (gnu_aggr_type) == COMPLEX_TYPE)\n \t  gnu_result\n \t    = build_binary_op\n@@ -7436,10 +7425,11 @@ gnat_to_gnu (Node_Id gnat_node)\n       if (kind == N_Qualified_Expression && Is_Tagged_Type (Etype (gnat_node)))\n \tused_types_insert (gnu_result_type);\n \n+      gigi_checking_assert (!Do_Range_Check (Expression (gnat_node)));\n+\n       gnu_result\n \t= convert_with_check (Etype (gnat_node), gnu_expr,\n \t\t\t      Do_Overflow_Check (gnat_node),\n-\t\t\t      Do_Range_Check (Expression (gnat_node)),\n \t\t\t      kind == N_Type_Conversion\n \t\t\t      && Float_Truncate (gnat_node), gnat_node);\n       break;\n@@ -7749,10 +7739,9 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \tgnat_temp = Expression (gnat_node);\n \n-\t/* The Expression operand can either be an N_Identifier or\n-\t   Expanded_Name, which must represent a type, or a\n-\t   N_Qualified_Expression, which contains both the object type and an\n-\t   initial value for the object.  */\n+\t/* The expression can be either an N_Identifier or an Expanded_Name,\n+\t   which must represent a type, or a N_Qualified_Expression, which\n+\t   contains both the type and an initial value for the object.  */\n \tif (Nkind (gnat_temp) == N_Identifier\n \t    || Nkind (gnat_temp) == N_Expanded_Name)\n \t  gnu_type = gnat_to_gnu_type (Entity (gnat_temp));\n@@ -7765,9 +7754,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_init = gnat_to_gnu (Expression (gnat_temp));\n \n \t    gnu_init = maybe_unconstrained_array (gnu_init);\n-\t    if (Do_Range_Check (Expression (gnat_temp)))\n-\t      gnu_init\n-\t\t= emit_range_check (gnu_init, gnat_desig_type, gnat_temp);\n+\n+\t    gigi_checking_assert (!Do_Range_Check (Expression (gnat_temp)));\n \n \t    if (Is_Elementary_Type (gnat_desig_type)\n \t\t|| Is_Constrained (gnat_desig_type))\n@@ -7873,10 +7861,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  else\n \t    gnu_rhs = maybe_unconstrained_array (gnat_to_gnu (gnat_expr));\n \n-\t  /* If range check is needed, emit code to generate it.  */\n-\t  if (Do_Range_Check (gnat_expr))\n-\t    gnu_rhs = emit_range_check (gnu_rhs, Etype (Name (gnat_node)),\n-\t\t\t\t\tgnat_node);\n+\t  gigi_checking_assert (!Do_Range_Check (gnat_expr));\n \n \t  /* If an outer atomic access is required on the LHS, build the load-\n \t     modify-store sequence.  */\n@@ -10086,58 +10071,6 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n   return emit_check (check, gnu_expr, CE_Overflow_Check_Failed, gnat_node);\n }\n \n-/* Emit code for a range check.  GNU_EXPR is the expression to be checked,\n-   GNAT_RANGE_TYPE the gnat type or subtype containing the bounds against\n-   which we have to check.  GNAT_NODE is the GNAT node conveying the source\n-   location for which the error should be signaled.  */\n-\n-static tree\n-emit_range_check (tree gnu_expr, Entity_Id gnat_range_type, Node_Id gnat_node)\n-{\n-  tree gnu_range_type = get_unpadded_type (gnat_range_type);\n-  tree gnu_compare_type = get_base_type (TREE_TYPE (gnu_expr));\n-\n-  /* If GNU_EXPR has GNAT_RANGE_TYPE as its base type, no check is needed.\n-     This can for example happen when translating 'Val or 'Value.  */\n-  if (gnu_compare_type == gnu_range_type)\n-    return gnu_expr;\n-\n-  /* Range checks can only be applied to types with ranges.  */\n-  gcc_assert (INTEGRAL_TYPE_P (gnu_range_type)\n-              || SCALAR_FLOAT_TYPE_P (gnu_range_type));\n-\n-  /* If GNU_EXPR has an integral type that is narrower than GNU_RANGE_TYPE,\n-     we can't do anything since we might be truncating the bounds.  No\n-     check is needed in this case.  */\n-  if (INTEGRAL_TYPE_P (TREE_TYPE (gnu_expr))\n-      && (TYPE_PRECISION (gnu_compare_type)\n-\t  < TYPE_PRECISION (get_base_type (gnu_range_type))))\n-    return gnu_expr;\n-\n-  /* Checked expressions must be evaluated only once.  */\n-  gnu_expr = gnat_protect_expr (gnu_expr);\n-\n-  /* Note that the form of the check is\n-\t(not (expr >= lo)) or (not (expr <= hi))\n-     the reason for this slightly convoluted form is that NaNs\n-     are not considered to be in range in the float case.  */\n-  return emit_check\n-    (build_binary_op (TRUTH_ORIF_EXPR, boolean_type_node,\n-\t\t      invert_truthvalue\n-\t\t      (build_binary_op (GE_EXPR, boolean_type_node,\n-\t\t\t\t        convert (gnu_compare_type, gnu_expr),\n-\t\t\t\t        convert (gnu_compare_type,\n-\t\t\t\t\t\t TYPE_MIN_VALUE\n-\t\t\t\t\t\t (gnu_range_type)))),\n-\t\t      invert_truthvalue\n-\t\t      (build_binary_op (LE_EXPR, boolean_type_node,\n-\t\t\t\t\tconvert (gnu_compare_type, gnu_expr),\n-\t\t\t\t\tconvert (gnu_compare_type,\n-\t\t\t\t\t\t TYPE_MAX_VALUE\n-\t\t\t\t\t\t (gnu_range_type))))),\n-     gnu_expr, CE_Range_Check_Failed, gnat_node);\n-}\n-\f\n /* GNU_COND contains the condition corresponding to an index, overflow or\n    range check of value GNU_EXPR.  Build a COND_EXPR that returns GNU_EXPR\n    if GNU_COND is false and raises a CONSTRAINT_ERROR if GNU_COND is true.\n@@ -10169,14 +10102,13 @@ emit_check (tree gnu_cond, tree gnu_expr, int reason, Node_Id gnat_node)\n }\n \f\n /* Return an expression that converts GNU_EXPR to GNAT_TYPE, doing overflow\n-   checks if OVERFLOW_P is true and range checks if RANGE_P is true.\n-   If TRUNCATE_P true, do a float-to-integer conversion with truncation,\n-   otherwise round.  GNAT_NODE is the GNAT node conveying the source location\n-   for which the error should be signaled.  */\n+   checks if OVERFLOW_P is true.  If TRUNCATE_P is true, do a fp-to-integer\n+   conversion with truncation, otherwise round.  GNAT_NODE is the GNAT node\n+   conveying the source location for which the error should be signaled.  */\n \n static tree\n convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflow_p,\n-\t\t    bool range_p, bool truncate_p, Node_Id gnat_node)\n+\t\t    bool truncate_p, Node_Id gnat_node)\n {\n   tree gnu_type = get_unpadded_type (gnat_type);\n   tree gnu_base_type = get_base_type (gnu_type);\n@@ -10187,8 +10119,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflow_p,\n   /* If we are not doing any checks, the output is an integral type and the\n      input is not a floating-point type, just do the conversion.  This is\n      required for packed array types and is simpler in all cases anyway.   */\n-  if (!range_p\n-      && !overflow_p\n+  if (!overflow_p\n       && INTEGRAL_TYPE_P (gnu_base_type)\n       && !FLOAT_TYPE_P (gnu_in_base_type))\n     return convert (gnu_type, gnu_expr);\n@@ -10221,7 +10152,13 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflow_p,\n       tree gnu_in_lb = TYPE_MIN_VALUE (gnu_in_base_type);\n       tree gnu_in_ub = TYPE_MAX_VALUE (gnu_in_base_type);\n       tree gnu_out_lb = TYPE_MIN_VALUE (gnu_base_type);\n-      tree gnu_out_ub = TYPE_MAX_VALUE (gnu_base_type);\n+      tree gnu_out_ub\n+\t= (TREE_CODE (gnu_base_type) == INTEGER_TYPE\n+\t   && TYPE_MODULAR_P (gnu_base_type))\n+\t  ? fold_build2 (MINUS_EXPR, gnu_base_type,\n+\t\t\t TYPE_MODULUS (gnu_base_type),\n+\t\t\t build_int_cst (gnu_base_type, 1))\n+\t  : TYPE_MAX_VALUE (gnu_base_type);\n \n       /* Convert the lower bounds to signed types, so we're sure we're\n \t comparing them properly.  Likewise, convert the upper bounds\n@@ -10346,14 +10283,6 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflow_p,\n   else\n     gnu_result = convert (gnu_base_type, gnu_result);\n \n-  /* Finally, do the range check if requested.  Note that if the result type\n-     is a modular type, the range check is actually an overflow check.  */\n-  if (range_p\n-      || (overflow_p\n-\t  && TREE_CODE (gnu_base_type) == INTEGER_TYPE\n-\t  && TYPE_MODULAR_P (gnu_base_type)))\n-    gnu_result = emit_range_check (gnu_result, gnat_type, gnat_node);\n-\n   return convert (gnu_type, gnu_result);\n }\n \f\n@@ -10682,7 +10611,8 @@ assoc_to_constructor (Entity_Id gnat_entity, Node_Id gnat_assoc, tree gnu_type)\n \n   for (; Present (gnat_assoc); gnat_assoc = Next (gnat_assoc))\n     {\n-      Node_Id gnat_field = First (Choices (gnat_assoc));\n+      const Node_Id gnat_field = First (Choices (gnat_assoc));\n+      const Node_Id gnat_expr = Expression (gnat_assoc);\n       tree gnu_field = gnat_to_gnu_field_decl (Entity (gnat_field));\n       tree gnu_expr = gnat_to_gnu (Expression (gnat_assoc));\n \n@@ -10702,11 +10632,9 @@ assoc_to_constructor (Entity_Id gnat_entity, Node_Id gnat_assoc, tree gnu_type)\n \t  && Is_Unchecked_Union (gnat_entity))\n \tcontinue;\n \n-      /* Before assigning a value in an aggregate make sure range checks\n-\t are done if required.  Then convert to the type of the field.  */\n-      if (Do_Range_Check (Expression (gnat_assoc)))\n-\tgnu_expr = emit_range_check (gnu_expr, Etype (gnat_field), Empty);\n+      gigi_checking_assert (!Do_Range_Check (gnat_expr));\n \n+      /* Convert to the type of the field.  */\n       gnu_expr = convert (TREE_TYPE (gnu_field), gnu_expr);\n \n       /* Add the field and expression to the list.  */\n@@ -10727,13 +10655,10 @@ assoc_to_constructor (Entity_Id gnat_entity, Node_Id gnat_assoc, tree gnu_type)\n \n /* Build a possibly nested constructor for array aggregates.  GNAT_EXPR is\n    the first element of an array aggregate.  It may itself be an aggregate.\n-   GNU_ARRAY_TYPE is the GCC type corresponding to the array aggregate.\n-   GNAT_COMPONENT_TYPE is the type of the array component; it is needed\n-   for range checking.  */\n+   GNU_ARRAY_TYPE is the GCC type corresponding to the array aggregate.  */\n \n static tree\n-pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n-\t\t    Entity_Id gnat_component_type)\n+pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type)\n {\n   tree gnu_index = TYPE_MIN_VALUE (TYPE_DOMAIN (gnu_array_type));\n   vec<constructor_elt, va_gc> *gnu_expr_vec = NULL;\n@@ -10749,8 +10674,7 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n \t  && TREE_CODE (TREE_TYPE (gnu_array_type)) == ARRAY_TYPE\n \t  && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_array_type)))\n \tgnu_expr = pos_to_constructor (First (Expressions (gnat_expr)),\n-\t\t\t\t       TREE_TYPE (gnu_array_type),\n-\t\t\t\t       gnat_component_type);\n+\t\t\t\t       TREE_TYPE (gnu_array_type));\n       else\n \t{\n \t  /* If the expression is a conversion to an unconstrained array type,\n@@ -10762,10 +10686,7 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n \t  else\n \t    gnu_expr = gnat_to_gnu (gnat_expr);\n \n-\t  /* Before assigning the element to the array, make sure it is\n-\t     in range.  */\n-\t  if (Do_Range_Check (gnat_expr))\n-\t    gnu_expr = emit_range_check (gnu_expr, gnat_component_type, Empty);\n+\t  gigi_checking_assert (!Do_Range_Check (gnat_expr));\n \t}\n \n       CONSTRUCTOR_APPEND_ELT (gnu_expr_vec, gnu_index,"}]}