{"sha": "14cfa01755a66afbae2539f8b5796c960ddcecc6", "node_id": "C_kwDOANBUbNoAKDE0Y2ZhMDE3NTVhNjZhZmJhZTI1MzlmOGI1Nzk2Yzk2MGRkY2VjYzY", "commit": {"author": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-08-25T21:02:57Z"}, "committer": {"name": "Joseph Myers", "email": "joseph@codesourcery.com", "date": "2022-08-25T21:04:12Z"}, "message": "c: Support C2x empty initializer braces\n\nISO C2x standardizes empty initializer braces {}.  Implement this\nfeature accordingly.  The basic case was already supported and so just\nneeded diagnostic adjustments.  However, the standard feature also\nincludes two cases that were not previously supported: empty\ninitializer braces for scalars, and empty initializer braces for\nVLAs.  Thus, add support for those features as well, updating existing\ntests that expected them to be diagnosed.\n\nThere was already some gimplifier support for converting\nvariable-sized initializations with empty CONSTRUCTORs to memset.\nHowever, it didn't apply here; code earlier in gimplify_modify_expr\nended up calling gimplify_init_constructor via\ngimplify_modify_expr_rhs, which ended up handling the CONSTRUCTOR in a\nway that generated an ICE later.  Add a check for this case earlier in\ngimplify_modify_expr to avoid that issue.\n\nBootstrapped with no regressions for x86_64-pc-linux-gnu.\n\ngcc/\n\t* gimplify.cc (gimplify_modify_expr): Convert initialization from\n\ta variable-size CONSTRUCTOR to memset before call to\n\tgimplify_modify_expr_rhs.\n\ngcc/c/\n\t* c-decl.cc (start_decl): Do not diagnose initialization of\n\tvariable-sized objects here.\n\t* c-parser.cc (c_parser_braced_init): Add argument DECL.  All\n\tcallers changed.\n\t(c_parser_initializer): Diagnose initialization of variable-sized\n\tobjects other than with braced initializer.\n\t(c_parser_braced_init): Use pedwarn_c11 for empty initializer\n\tbraces and update diagnostic text.  Diagnose initialization of\n\tvariable-sized objects with nonempty braces.\n\t* c-typeck.cc (digest_init): Update diagnostic for initialization\n\tof variable-sized objects.\n\t(really_start_incremental_init, set_designator)\n\t(process_init_element): Update comments.\n\t(pop_init_level): Allow scalar empty initializers.\n\ngcc/testsuite/\n\t* gcc.dg/c11-empty-init-1.c, gcc.dg/c11-empty-init-2.c,\n\tgcc.dg/c11-empty-init-3.c, gcc.dg/c2x-empty-init-1.c,\n\tgcc.dg/c2x-empty-init-2.c, gcc.dg/c2x-empty-init-3.c,\n\tgcc.dg/gnu2x-empty-init-1.c, gcc.dg/gnu2x-empty-init-2.c: New\n\ttests.\n\t* gcc.dg/torture/dfp-default-init-1.c: Also test empty\n\tinitializers.\n\t* gcc.dg/init-bad-1.c, gcc.dg/noncompile/pr71583.c,\n\tgcc.dg/pr61096-1.c, gcc.dg/vla-init-2.c, gcc.dg/vla-init-3.c,\n\tgcc.target/i386/sse2-bfloat16-scalar-typecheck.c: Update expected\n\tdiagnostics.\n\t* gcc.dg/ubsan/c-shift-1.c: Use nonempty initializers for VLA\n\tinitializations expected to be diagnosed.", "tree": {"sha": "c918ea16751a1e9d6478c032631a349c3842bfba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c918ea16751a1e9d6478c032631a349c3842bfba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14cfa01755a66afbae2539f8b5796c960ddcecc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14cfa01755a66afbae2539f8b5796c960ddcecc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14cfa01755a66afbae2539f8b5796c960ddcecc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14cfa01755a66afbae2539f8b5796c960ddcecc6/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "072d3115c0e297d91c133c4214b357b0a50557b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/072d3115c0e297d91c133c4214b357b0a50557b9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/072d3115c0e297d91c133c4214b357b0a50557b9"}], "stats": {"total": 352, "additions": 305, "deletions": 47}, "files": [{"sha": "1fe31e0113203c605394646739199f95c54ac17f", "filename": "gcc/c/c-decl.cc", "status": "modified", "additions": 3, "deletions": 17, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Fc%2Fc-decl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Fc%2Fc-decl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-decl.cc?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -5180,29 +5180,15 @@ start_decl (struct c_declarator *declarator, struct c_declspecs *declspecs,\n \t  initialized = false;\n \telse if (COMPLETE_TYPE_P (TREE_TYPE (decl)))\n \t  {\n-\t    /* A complete type is ok if size is fixed.  */\n-\n-\t    if (!poly_int_tree_p (TYPE_SIZE (TREE_TYPE (decl)))\n-\t\t|| C_DECL_VARIABLE_SIZE (decl))\n-\t      {\n-\t\terror (\"variable-sized object may not be initialized\");\n-\t\tinitialized = false;\n-\t      }\n+\t    /* A complete type is ok if size is fixed.  If the size is\n+\t       variable, an empty initializer is OK and nonempty\n+\t       initializers will be diagnosed in the parser.  */\n \t  }\n \telse if (TREE_CODE (TREE_TYPE (decl)) != ARRAY_TYPE)\n \t  {\n \t    error (\"variable %qD has initializer but incomplete type\", decl);\n \t    initialized = false;\n \t  }\n-\telse if (C_DECL_VARIABLE_SIZE (decl))\n-\t  {\n-\t    /* Although C99 is unclear about whether incomplete arrays\n-\t       of VLAs themselves count as VLAs, it does not make\n-\t       sense to permit them to be initialized given that\n-\t       ordinary VLAs may not be initialized.  */\n-\t    error (\"variable-sized object may not be initialized\");\n-\t    initialized = false;\n-\t  }\n       }\n \n   if (initialized)"}, {"sha": "1e8d9dca749478570f8bd424b6e897ffcb1c3688", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -1523,7 +1523,7 @@ static tree c_parser_simple_asm_expr (c_parser *);\n static tree c_parser_gnu_attributes (c_parser *);\n static struct c_expr c_parser_initializer (c_parser *, tree);\n static struct c_expr c_parser_braced_init (c_parser *, tree, bool,\n-\t\t\t\t\t   struct obstack *);\n+\t\t\t\t\t   struct obstack *, tree);\n static void c_parser_initelt (c_parser *, struct obstack *);\n static void c_parser_initval (c_parser *, struct c_expr *,\n \t\t\t      struct obstack *);\n@@ -5220,11 +5220,15 @@ static struct c_expr\n c_parser_initializer (c_parser *parser, tree decl)\n {\n   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE))\n-    return c_parser_braced_init (parser, NULL_TREE, false, NULL);\n+    return c_parser_braced_init (parser, NULL_TREE, false, NULL, decl);\n   else\n     {\n       struct c_expr ret;\n       location_t loc = c_parser_peek_token (parser)->location;\n+      if (decl != error_mark_node && C_DECL_VARIABLE_SIZE (decl))\n+\terror_at (loc,\n+\t\t  \"variable-sized object may not be initialized except \"\n+\t\t  \"with an empty initializer\");\n       ret = c_parser_expr_no_commas (parser, NULL);\n       /* This is handled mostly by gimplify.cc, but we have to deal with\n \t not warning about int x = x; as it is a GCC extension to turn off\n@@ -5251,11 +5255,12 @@ location_t last_init_list_comma;\n    compound literal, and NULL_TREE for other initializers and for\n    nested braced lists.  NESTED_P is true for nested braced lists,\n    false for the list of a compound literal or the list that is the\n-   top-level initializer in a declaration.  */\n+   top-level initializer in a declaration.  DECL is the declaration for\n+   the top-level initializer for a declaration, otherwise NULL_TREE.  */\n \n static struct c_expr\n c_parser_braced_init (c_parser *parser, tree type, bool nested_p,\n-\t\t      struct obstack *outer_obstack)\n+\t\t      struct obstack *outer_obstack, tree decl)\n {\n   struct c_expr ret;\n   struct obstack braced_init_obstack;\n@@ -5273,10 +5278,15 @@ c_parser_braced_init (c_parser *parser, tree type, bool nested_p,\n     really_start_incremental_init (type);\n   if (c_parser_next_token_is (parser, CPP_CLOSE_BRACE))\n     {\n-      pedwarn (brace_loc, OPT_Wpedantic, \"ISO C forbids empty initializer braces\");\n+      pedwarn_c11 (brace_loc, OPT_Wpedantic,\n+\t\t   \"ISO C forbids empty initializer braces before C2X\");\n     }\n   else\n     {\n+      if (decl && decl != error_mark_node && C_DECL_VARIABLE_SIZE (decl))\n+\terror_at (brace_loc,\n+\t\t  \"variable-sized object may not be initialized except \"\n+\t\t  \"with an empty initializer\");\n       /* Parse a non-empty initializer list, possibly with a trailing\n \t comma.  */\n       while (true)\n@@ -5532,7 +5542,7 @@ c_parser_initval (c_parser *parser, struct c_expr *after,\n \n   if (c_parser_next_token_is (parser, CPP_OPEN_BRACE) && !after)\n     init = c_parser_braced_init (parser, NULL_TREE, true,\n-\t\t\t\t braced_init_obstack);\n+\t\t\t\t braced_init_obstack, NULL_TREE);\n   else\n     {\n       init = c_parser_expr_no_commas (parser, after);\n@@ -10307,7 +10317,7 @@ c_parser_postfix_expression_after_paren_type (c_parser *parser,\n       error_at (type_loc, \"compound literal has variable size\");\n       type = error_mark_node;\n     }\n-  init = c_parser_braced_init (parser, type, false, NULL);\n+  init = c_parser_braced_init (parser, type, false, NULL, NULL_TREE);\n   finish_init ();\n   maybe_warn_string_init (type_loc, type, init);\n "}, {"sha": "0e37ab8695f5ee16f391bb3244f91938ac8e3001", "filename": "gcc/c/c-typeck.cc", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Fc%2Fc-typeck.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Fc%2Fc-typeck.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-typeck.cc?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -8291,7 +8291,9 @@ digest_init (location_t init_loc, tree type, tree init, tree origtype,\n \n   if (COMPLETE_TYPE_P (type) && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     {\n-      error_init (init_loc, \"variable-sized object may not be initialized\");\n+      error_init (init_loc,\n+\t\t  \"variable-sized object may not be initialized except \"\n+\t\t  \"with an empty initializer\");\n       return error_mark_node;\n     }\n \n@@ -8641,8 +8643,9 @@ really_start_incremental_init (tree type)\n \t    constructor_max_index = integer_minus_one_node;\n \n \t  /* constructor_max_index needs to be an INTEGER_CST.  Attempts\n-\t     to initialize VLAs will cause a proper error; avoid tree\n-\t     checking errors as well by setting a safe value.  */\n+\t     to initialize VLAs with a nonempty initializer will cause a\n+\t     proper error; avoid tree checking errors as well by setting a\n+\t     safe value.  */\n \t  if (constructor_max_index\n \t      && TREE_CODE (constructor_max_index) != INTEGER_CST)\n \t    constructor_max_index = integer_minus_one_node;\n@@ -9024,12 +9027,14 @@ pop_init_level (location_t loc, int implicit,\n \t   && !gnu_vector_type_p (constructor_type))\n     {\n       /* A nonincremental scalar initializer--just return\n-\t the element, after verifying there is just one.  */\n+\t the element, after verifying there is just one.\n+         Empty scalar initializers are supported in C2X.  */\n       if (vec_safe_is_empty (constructor_elements))\n \t{\n-\t  if (!constructor_erroneous && constructor_type != error_mark_node)\n-\t    error_init (loc, \"empty scalar initializer\");\n-\t  ret.value = error_mark_node;\n+\t  if (constructor_erroneous || constructor_type == error_mark_node)\n+\t    ret.value = error_mark_node;\n+\t  else\n+\t    ret.value = build_zero_cst (constructor_type);\n \t}\n       else if (vec_safe_length (constructor_elements) != 1)\n \t{\n@@ -9114,7 +9119,7 @@ set_designator (location_t loc, bool array,\n     return true;\n \n   /* Likewise for an initializer for a variable-size type.  Those are\n-     diagnosed in digest_init.  */\n+     diagnosed in the parser, except for empty initializer braces.  */\n   if (COMPLETE_TYPE_P (constructor_type)\n       && TREE_CODE (TYPE_SIZE (constructor_type)) != INTEGER_CST)\n     return true;\n@@ -10275,7 +10280,7 @@ process_init_element (location_t loc, struct c_expr value, bool implicit,\n     return;\n \n   /* Ignore elements of an initializer for a variable-size type.\n-     Those are diagnosed in digest_init.  */\n+     Those are diagnosed in the parser (empty initializer braces are OK).  */\n   if (COMPLETE_TYPE_P (constructor_type)\n       && !poly_int_tree_p (TYPE_SIZE (constructor_type)))\n     return;"}, {"sha": "b828ddbfe6c95e53e8d3e5bf891ef4857beb10e9", "filename": "gcc/gimplify.cc", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Fgimplify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Fgimplify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.cc?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -6031,6 +6031,21 @@ gimplify_modify_expr (tree *expr_p, gimple_seq *pre_p, gimple_seq *post_p,\n       return GS_ALL_DONE;\n     }\n \n+  /* Convert initialization from an empty variable-size CONSTRUCTOR to\n+     memset.  */\n+  if (TREE_TYPE (*from_p) != error_mark_node\n+      && TYPE_SIZE_UNIT (TREE_TYPE (*from_p))\n+      && !poly_int_tree_p (TYPE_SIZE_UNIT (TREE_TYPE (*from_p)))\n+      && TREE_CODE (*from_p) == CONSTRUCTOR\n+      && CONSTRUCTOR_NELTS (*from_p) == 0)\n+    {\n+      maybe_with_size_expr (from_p);\n+      gcc_assert (TREE_CODE (*from_p) == WITH_SIZE_EXPR);\n+      return gimplify_modify_expr_to_memset (expr_p,\n+\t\t\t\t\t     TREE_OPERAND (*from_p, 1),\n+\t\t\t\t\t     want_value, pre_p);\n+    }\n+\n   /* Insert pointer conversions required by the middle-end that are not\n      required by the frontend.  This fixes middle-end type checking for\n      for example gcc.dg/redecl-6.c.  */"}, {"sha": "120c282258eb066769f1c3fd2ec7714b11981c95", "filename": "gcc/testsuite/gcc.dg/c11-empty-init-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-empty-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-empty-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-empty-init-1.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -0,0 +1,25 @@\n+/* Test C11 does not support empty initializers.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+struct s { int a; };\n+struct s s = {}; /* { dg-error \"empty initializer\" } */\n+int x = {}; /* { dg-error \"empty initializer\" } */\n+float y = {}; /* { dg-error \"empty initializer\" } */\n+void *p = {}; /* { dg-error \"empty initializer\" } */\n+union u { int a; long b; };\n+union u z = {}; /* { dg-error \"empty initializer\" } */\n+int aa[2] = {}; /* { dg-error \"empty initializer\" } */\n+\n+void\n+f (int a)\n+{\n+  int vla[a] = {}; /* { dg-error \"empty initializer\" } */\n+  struct s as = {}; /* { dg-error \"empty initializer\" } */\n+  int ax = {}; /* { dg-error \"empty initializer\" } */\n+  float ay = {}; /* { dg-error \"empty initializer\" } */\n+  void *ap = {}; /* { dg-error \"empty initializer\" } */\n+  union u az = {}; /* { dg-error \"empty initializer\" } */\n+  int aaa[2] = {}; /* { dg-error \"empty initializer\" } */\n+  int t = (int) {}; /* { dg-error \"empty initializer\" } */\n+}"}, {"sha": "3ec7c512a84d59a3f25f0d5a928ad7bbd1a00055", "filename": "gcc/testsuite/gcc.dg/c11-empty-init-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-empty-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-empty-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-empty-init-2.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -0,0 +1,25 @@\n+/* Test C11 does not support empty initializers.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic\" } */\n+\n+struct s { int a; };\n+struct s s = {}; /* { dg-warning \"empty initializer\" } */\n+int x = {}; /* { dg-warning \"empty initializer\" } */\n+float y = {}; /* { dg-warning \"empty initializer\" } */\n+void *p = {}; /* { dg-warning \"empty initializer\" } */\n+union u { int a; long b; };\n+union u z = {}; /* { dg-warning \"empty initializer\" } */\n+int aa[2] = {}; /* { dg-warning \"empty initializer\" } */\n+\n+void\n+f (int a)\n+{\n+  int vla[a] = {}; /* { dg-warning \"empty initializer\" } */\n+  struct s as = {}; /* { dg-warning \"empty initializer\" } */\n+  int ax = {}; /* { dg-warning \"empty initializer\" } */\n+  float ay = {}; /* { dg-warning \"empty initializer\" } */\n+  void *ap = {}; /* { dg-warning \"empty initializer\" } */\n+  union u az = {}; /* { dg-warning \"empty initializer\" } */\n+  int aaa[2] = {}; /* { dg-warning \"empty initializer\" } */\n+  int t = (int) {}; /* { dg-warning \"empty initializer\" } */\n+}"}, {"sha": "fd43fa7890bb0e138568af57454ddf4a71c057c9", "filename": "gcc/testsuite/gcc.dg/c11-empty-init-3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-empty-init-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-empty-init-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-empty-init-3.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -0,0 +1,25 @@\n+/* Test C11 does not support empty initializers.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -Wc11-c2x-compat\" } */\n+\n+struct s { int a; };\n+struct s s = {}; /* { dg-warning \"empty initializer\" } */\n+int x = {}; /* { dg-warning \"empty initializer\" } */\n+float y = {}; /* { dg-warning \"empty initializer\" } */\n+void *p = {}; /* { dg-warning \"empty initializer\" } */\n+union u { int a; long b; };\n+union u z = {}; /* { dg-warning \"empty initializer\" } */\n+int aa[2] = {}; /* { dg-warning \"empty initializer\" } */\n+\n+void\n+f (int a)\n+{\n+  int vla[a] = {}; /* { dg-warning \"empty initializer\" } */\n+  struct s as = {}; /* { dg-warning \"empty initializer\" } */\n+  int ax = {}; /* { dg-warning \"empty initializer\" } */\n+  float ay = {}; /* { dg-warning \"empty initializer\" } */\n+  void *ap = {}; /* { dg-warning \"empty initializer\" } */\n+  union u az = {}; /* { dg-warning \"empty initializer\" } */\n+  int aaa[2] = {}; /* { dg-warning \"empty initializer\" } */\n+  int t = (int) {}; /* { dg-warning \"empty initializer\" } */\n+}"}, {"sha": "1487a2b23ab98ccd6ebb0dc4ca13891a2d25dd72", "filename": "gcc/testsuite/gcc.dg/c2x-empty-init-1.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-empty-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-empty-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-empty-init-1.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -0,0 +1,80 @@\n+/* Test C2X support for empty initializers: valid use cases.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+struct s { int a; };\n+struct s s = {};\n+int x = {};\n+float y = {};\n+void *p = {};\n+union u { int a; long b; };\n+union u z = {};\n+int aa[2] = {};\n+\n+void\n+f (int a)\n+{\n+  volatile int vla[a] = {};\n+  struct s as = {};\n+  int ax = {};\n+  float ay = {};\n+  void *ap = {};\n+  union u az = {};\n+  int aaa[2] = {};\n+  for (int i = 0; i < a; i++)\n+    if (vla[i] != 0)\n+      abort ();\n+  if (as.a != 0)\n+    abort ();\n+  if (ax != 0)\n+    abort ();\n+  if (ay != 0)\n+    abort ();\n+  if (ap != 0)\n+    abort ();\n+  if (az.a != 0)\n+    abort ();\n+  if (aaa[0] != 0)\n+    abort ();\n+  if (aaa[1] != 0)\n+    abort ();\n+  if ((int) {} != 0)\n+    abort ();\n+  if ((float) {} != 0)\n+    abort ();\n+  if ((struct s) {}.a != 0)\n+    abort ();\n+  if ((union u) {}.a != 0)\n+    abort ();\n+  if ((int [5]) {}[2] != 0)\n+    abort ();\n+  /* Overwrite contents of vla before second call to make it more likely stack\n+     contents are nonzero if proper initialization did not occur.  */\n+  for (int i = 0; i < a; i++)\n+    vla[i] = -1;\n+}\n+\n+int\n+main (void)\n+{\n+  f (100);\n+  f (100);\n+  if (s.a != 0)\n+    abort ();\n+  if (x != 0)\n+    abort ();\n+  if (y != 0)\n+    abort ();\n+  if (p != 0)\n+    abort ();\n+  if (z.a != 0)\n+    abort ();\n+  if (aa[0] != 0)\n+    abort ();\n+  if (aa[1] != 0)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "0dc81ce5b8ea08f271370ee0685266da98700487", "filename": "gcc/testsuite/gcc.dg/c2x-empty-init-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-empty-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-empty-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-empty-init-2.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -0,0 +1,18 @@\n+/* Test C2X support for empty initializers: invalid use cases.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -pedantic-errors\" } */\n+\n+/* Empty initialization is invalid for arrays of unknown size.  This is\n+   diagnosed via the diagnostic for zero-size arrays.  */\n+int x[] = {}; /* { dg-error \"zero or negative size array\" } */\n+\n+void\n+f (int a)\n+{\n+  int x1[] = {}; /* { dg-error \"zero or negative size array\" } */\n+  int x2[][a] = {}; /* { dg-error \"zero or negative size array\" } */\n+  /* Nonempty VLA initializers are still invalid.  */\n+  int x3[a] = { 0 }; /* { dg-error \"variable-sized object may not be initialized except with an empty initializer\" } */\n+  /* Variable-size compound literals are still invalid.  */\n+  (void) (int [a]) {}; /* { dg-error \"compound literal has variable size\" } */\n+}"}, {"sha": "472f8169c4122ad40ca44b5041458862dfba1b8d", "filename": "gcc/testsuite/gcc.dg/c2x-empty-init-3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-empty-init-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-empty-init-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc2x-empty-init-3.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -0,0 +1,25 @@\n+/* Test empty initializers diagnosed in C2X mode with -Wc11-c2x-compat.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c2x -Wc11-c2x-compat\" } */\n+\n+struct s { int a; };\n+struct s s = {}; /* { dg-warning \"empty initializer\" } */\n+int x = {}; /* { dg-warning \"empty initializer\" } */\n+float y = {}; /* { dg-warning \"empty initializer\" } */\n+void *p = {}; /* { dg-warning \"empty initializer\" } */\n+union u { int a; long b; };\n+union u z = {}; /* { dg-warning \"empty initializer\" } */\n+int aa[2] = {}; /* { dg-warning \"empty initializer\" } */\n+\n+void\n+f (int a)\n+{\n+  int vla[a] = {}; /* { dg-warning \"empty initializer\" } */\n+  struct s as = {}; /* { dg-warning \"empty initializer\" } */\n+  int ax = {}; /* { dg-warning \"empty initializer\" } */\n+  float ay = {}; /* { dg-warning \"empty initializer\" } */\n+  void *ap = {}; /* { dg-warning \"empty initializer\" } */\n+  union u az = {}; /* { dg-warning \"empty initializer\" } */\n+  int aaa[2] = {}; /* { dg-warning \"empty initializer\" } */\n+  int t = (int) {}; /* { dg-warning \"empty initializer\" } */\n+}"}, {"sha": "e7dc9dfde23297ca935bb6421f08eaf0a6f9d5f4", "filename": "gcc/testsuite/gcc.dg/gnu2x-empty-init-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-empty-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-empty-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-empty-init-1.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -0,0 +1,29 @@\n+/* Test C2X support for empty initializers: valid use cases with GNU\n+   extensions.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu2x\" } */\n+\n+extern void exit (int);\n+extern void abort (void);\n+\n+void\n+f (int a)\n+{\n+  struct s { volatile int x[a]; };\n+  struct s b = {};\n+  for (int i = 0; i < a; i++)\n+    if (b.x[i] != 0)\n+      abort ();\n+  /* Overwrite contents of b.x before second call to make it more likely stack\n+     contents are nonzero if proper initialization did not occur.  */\n+  for (int i = 0; i < a; i++)\n+    b.x[i] = -1;\n+}\n+\n+int\n+main (void)\n+{\n+  f (100);\n+  f (100);\n+  exit (0);\n+}"}, {"sha": "69ee4e36b11cd6a2ea367eabd156a0d46cd869a2", "filename": "gcc/testsuite/gcc.dg/gnu2x-empty-init-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-empty-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-empty-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgnu2x-empty-init-2.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -0,0 +1,16 @@\n+/* Test C2X support for empty initializers: invalid use cases with GNU\n+   extensions.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu2x\" } */\n+\n+void\n+f (int a)\n+{\n+  /* Make sure a non-braced initializer for a VLA-in-struct is still not\n+     allowed.  */\n+  struct s { int x[a]; };\n+  struct s b;\n+  for (int i = 0; i < a; i++)\n+    b.x[i] = 0;\n+  struct s c = b; /* { dg-error \"variable-sized object may not be initialized except with an empty initializer\" } */\n+}"}, {"sha": "0da10c31539a1645e53906fd5876d82c086f3f5e", "filename": "gcc/testsuite/gcc.dg/init-bad-1.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Finit-bad-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Finit-bad-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Finit-bad-1.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -21,8 +21,7 @@ char t1[1] = { \"xy\" }; /* { dg-warning \"initializer-string for array of 'char' i\n char u[1] = { \"x\", \"x\" }; /* { dg-error \"excess elements in 'char' array initializer\" } */\n /* { dg-message \"near init\" \"near\" { target *-*-* } .-1 } */\n \n-int i = { }; /* { dg-error \"empty scalar initializer\" } */\n-/* { dg-message \"near init\" \"near\" { target *-*-* } .-1 } */\n+int i = { };\n \n int j = { 1 };\n "}, {"sha": "fe6e556adfc877e596bfba4dea3e6f0a35c06bcc", "filename": "gcc/testsuite/gcc.dg/noncompile/pr71583.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fpr71583.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fpr71583.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnoncompile%2Fpr71583.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -5,7 +5,7 @@ void\n f (int i)\n {\n   (int (*)[++i]) { int }; /* { dg-error \"expected\" } */\n-  (int (*)[++i]) { }; /* { dg-error \"empty\" } */\n+  (int (*)[++i]) { };\n   (int (*)[++i]) { , }; /* { dg-error \"expected\" } */\n   (int (*)[++i]) { f () }; /* { dg-error \"too few\" } */\n }"}, {"sha": "f41789c5f527946fc014a391a1c6239aeeebbc16", "filename": "gcc/testsuite/gcc.dg/pr61096-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61096-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61096-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr61096-1.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -36,7 +36,7 @@ struct S s = { { 1 }, { 3 } }; /* { dg-error \"23:extra brace group at end of ini\n struct g g1 = { {0, { 1 } } }; /* { dg-error \"21:initialization of flexible array member in a nested context\" } */\n struct g g2 = { .f[0] = 1 }; /* { dg-error \"20:array index in non-array initializer\" } */\n \n-__extension__ int a8 = { }; /* { dg-error \"24:empty scalar initializer\" } */\n+__extension__ int a8 = { };\n int a9[10] = {[1.2] = 2 }; /* { dg-error \"16:array index in initializer not of integer type\" } */\n int a10[10] = {[e] = 2 }; /* { dg-error \"17:nonconstant array index in initializer\" } */\n __extension__ int a11[10] = {[1 ... e] = 1 }; /* { dg-error \"31:nonconstant array index in initializer\" } */"}, {"sha": "7bb903bc83b5e521c088623f8b74bc196ae144ed", "filename": "gcc/testsuite/gcc.dg/torture/dfp-default-init-1.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fdfp-default-init-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fdfp-default-init-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fdfp-default-init-1.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -19,6 +19,7 @@ int memcmp (const void *, const void *, __SIZE_TYPE__);\n TYPE zero_int = 0;\n TYPE zero_fp = ZEROFP;\n TYPE default_init;\n+TYPE empty_init = {};\n TYPE zero_bytes;\n TYPE x;\n \n@@ -64,6 +65,7 @@ main (void)\n     abort ();\n   CHECK_ZERO_BYTES (&zero_fp);\n   CHECK_ZERO_BYTES (&default_init);\n+  CHECK_ZERO_BYTES (&empty_init);\n   CHECK_ZERO_BYTES (&s_default_init.a);\n   CHECK_ZERO_BYTES (&s_default_init.b);\n   CHECK_ZERO_BYTES (&s_empty_init.a);"}, {"sha": "f88ee2de3793b012ac85903b017910cd4b5ae941", "filename": "gcc/testsuite/gcc.dg/ubsan/c-shift-1.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fc-shift-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fc-shift-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fubsan%2Fc-shift-1.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -7,12 +7,12 @@ int\n main (void)\n {\n   /* None of the following should pass.  */\n-  int A[1 >> -1] = {};    /* { dg-error \"variable-sized object may not be initialized\" } */\n-  int B[-1 >> -1] = {};   /* { dg-error \"variable-sized object may not be initialized\" } */\n-  int D[1 << -1] = {};    /* { dg-error \"variable-sized object may not be initialized\" } */\n-  int E[-1 << -1] = {};   /* { dg-error \"variable-sized object may not be initialized\" } */\n-  int F[-1 >> 200] = {};  /* { dg-error \"variable-sized object may not be initialized\" } */\n-  int G[1 << 200] = {};   /* { dg-error \"variable-sized object may not be initialized\" } */\n+  int A[1 >> -1] = { 0 };    /* { dg-error \"variable-sized object may not be initialized\" } */\n+  int B[-1 >> -1] = { 0 };   /* { dg-error \"variable-sized object may not be initialized\" } */\n+  int D[1 << -1] = { 0 };    /* { dg-error \"variable-sized object may not be initialized\" } */\n+  int E[-1 << -1] = { 0 };   /* { dg-error \"variable-sized object may not be initialized\" } */\n+  int F[-1 >> 200] = { 0 };  /* { dg-error \"variable-sized object may not be initialized\" } */\n+  int G[1 << 200] = { 0 };   /* { dg-error \"variable-sized object may not be initialized\" } */\n \n   return 0;\n }"}, {"sha": "f23630a36572a6d2f5131c761219a05efc781e3a", "filename": "gcc/testsuite/gcc.dg/vla-init-2.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-init-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-init-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-init-2.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -7,4 +7,3 @@\n \n const int i = 1;\n void foo() { char a[][i] = {\"\"}; } /* { dg-error \"variable-sized object may not be initialized\" } */\n-/* { dg-error \"array size missing in 'a'\" \"extra error\" { target *-*-* } .-1 } */"}, {"sha": "a854f1268e08b168ee9567ba75e966fc2e1d8dc3", "filename": "gcc/testsuite/gcc.dg/vla-init-3.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-init-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-init-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvla-init-3.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -6,4 +6,3 @@\n /* { dg-options \"\" } */\n \n void foo(int i) { char a[][i] = {\"\"}; } /* { dg-error \"variable-sized object may not be initialized\" } */\n-/* { dg-error \"array size missing in 'a'\" \"extra error\" { target *-*-* } .-1 } */"}, {"sha": "52b53b9ae854b09613517a148179d1986fd90655", "filename": "gcc/testsuite/gcc.target/i386/sse2-bfloat16-scalar-typecheck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-bfloat16-scalar-typecheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14cfa01755a66afbae2539f8b5796c960ddcecc6/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-bfloat16-scalar-typecheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fsse2-bfloat16-scalar-typecheck.c?ref=14cfa01755a66afbae2539f8b5796c960ddcecc6", "patch": "@@ -36,7 +36,7 @@ __bf16 footest (__bf16 scalar0)\n   short initi_1_4 = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n   double initi_1_5 = glob_bfloat; /* { dg-error {invalid conversion from type '__bf16'} } */\n \n-  __bf16 scalar2_1 = {}; /* { dg-error {empty scalar initializer} } */\n+  __bf16 scalar2_1 = {};\n   __bf16 scalar2_2 = { glob_bfloat };\n   __bf16 scalar2_3 = { 0 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n   __bf16 scalar2_4 = { 0.1 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n@@ -88,7 +88,7 @@ __bf16 footest (__bf16 scalar0)\n \n   /* Compound literals.  */\n \n-  (__bf16) {}; /* { dg-error {empty scalar initializer} } */\n+  (__bf16) {};\n   (__bf16) { glob_bfloat };\n   (__bf16) { 0 }; /* { dg-error {invalid conversion to type '__bf16'} } */\n   (__bf16) { 0.1 }; /* { dg-error {invalid conversion to type '__bf16'} } */"}]}