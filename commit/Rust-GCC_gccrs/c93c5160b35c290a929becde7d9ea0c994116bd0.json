{"sha": "c93c5160b35c290a929becde7d9ea0c994116bd0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkzYzUxNjBiMzVjMjkwYTkyOWJlY2RlN2Q5ZWEwYzk5NDExNmJkMA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-08-08T15:57:48Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-08-08T15:57:48Z"}, "message": "invoke.texi (-mcode-readable): Document.\n\ngcc/\n2007-08-08  Richard Sandiford  <richard@codesourcery.com>\n\t    Sandra Loosemore  <sandra@codesourcery.com>\n\t    Chao-ying Fu  <fu@mips.com>\n\t    Nigel Stephens  <nigel@mips.com>\n\t    David Ung  <davidu@mips.com>\n\n\t* doc/invoke.texi (-mcode-readable): Document.\n\t* config/mips/mips.opt (mcode-readable): New option.\n\t* config/mips/mips-protos.h (SYMBOL_32_HIGH): New symbol type.\n\t* config/mips/mips.h (mips_code_readable_setting): New enum.\n\t(mips_code_readable): Declare.\n\t(TARGET_MIPS16_TEXT_LOADS, TARGET_MIPS16_PCREL_LOADS): New macros.\n\t(TARGET_MIPS16_SHORT_JUMP_TABLES): New macro.\n\t(JUMP_TABLES_IN_TEXT_SECTION): Use it.\n\t(CASE_VECTOR_MODE, CASE_VECTOR_PC_RELATIVE): Likewise.  Remove\n\tboiler-plate comments.\n\t(ASM_OUTPUT_ADDR_DIFF_ELT): Use TARGET_MIPS16_SHORT_JUMP_TABLES.\n\t* config/mips/mips.c (mips_code_readable): New variable.\n\t(mips_classify_symbol): Only return SYMBOL_PC_RELATIVE for\n\tMIPS16 labels if TARGET_MIPS16_SHORT_JUMP_TABLES.  Use both the\n\tcontext and -mcode-readable setting to restrict the use of\n\tSYMBOL_PC_RELATIVE for MIPS16 constant pool references.\n\tOnly return TARGET_FORCE_TO_MEM if PC-relative loads are allowed.\n\t(mips_symbolic_constant_p): Handle SYMBOL_32_HIGH.\n\t(mips_blocks_for_constant_p): Only return false for\n\tTARGET_MIPS16_PCREL_LOADS.\n\t(mips_symbol_insns_1): Treat HIGHs as 2 extended instructions\n\tfor MIPS16.  Handle SYMBOL_32_HIGH.\n\t(mips_const_insns): Allow HIGHs for MIPS16 too.\n\t(mips_unspec_address_offset): New function, split out from...\n\t(mips_unspec_address): ...here.\n\t(mips_output_move): Handle MIPS16 HIGH moves.  Use \"li\" to load\n\t16-bit symbolic constants.  Assert approropiate conditions for\n\tusing the \"la\" and \"dla\" macros.\n\t(mips_handle_option): Handle -mcode-readable=.\n\t(override_options): Use %hi/%lo relocations for TARGET_MIPS16 too.\n\tSet up mips_lo_relocs[SYMBOL_32_HIGH].\n\t(mips_strip_unspec_address): New function, split out from...\n\t(print_operand_reloc): ...here.\n\t(print_operand): Pass constants through mips_strip_unspec_address.\n\t(print_operand_address): Likewise.\n\t(mips_output_mi_thunk): Remove guard of mips16_lay_out_constants.\n\t(mips_select_rtx_section): Remove MIPS16 handling.\n\t(mips16_gp_pseudo_reg): Check currently_expanding_to_rtl.\n\t(mips16_rewrite_pool_refs): Wrap the labels in an address UNSPEC.\n\t(mips16_lay_out_constants): Do nothing unless\n\tTARGET_MIPS16_PCREL_LOADS.\n\t(mips_avoid_hazards): Remove guard of mips16_lay_out_constants.\n\t* config/mips/mips.md: Split HIGHs for MIPS16.\n\t(tablejump): Use TARGET_MIPS16_SHORT_JUMP_TABLES.\n\ngcc/testsuite/\n\t* gcc.target/mips/code-readable-1.c: New test.\n\t* gcc.target/mips/code-readable-2.c: Likewise.\n\t* gcc.target/mips/code-readable-3.c: Likewise.\n\nCo-Authored-By: Chao-ying Fu <fu@mips.com>\nCo-Authored-By: David Ung <davidu@mips.com>\nCo-Authored-By: Nigel Stephens <nigel@mips.com>\nCo-Authored-By: Sandra Loosemore <sandra@codesourcery.com>\n\nFrom-SVN: r127300", "tree": {"sha": "b84e28dea878fc64f45ff885f52c8cce4df04460", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b84e28dea878fc64f45ff885f52c8cce4df04460"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c93c5160b35c290a929becde7d9ea0c994116bd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93c5160b35c290a929becde7d9ea0c994116bd0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c93c5160b35c290a929becde7d9ea0c994116bd0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c93c5160b35c290a929becde7d9ea0c994116bd0/comments", "author": null, "committer": null, "parents": [{"sha": "51e7252ad2e21f23d05f58a4e9bb224de387eeb2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/51e7252ad2e21f23d05f58a4e9bb224de387eeb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/51e7252ad2e21f23d05f58a4e9bb224de387eeb2"}], "stats": {"total": 419, "additions": 354, "deletions": 65}, "files": [{"sha": "6268b2d62f9d0f5180c9c09142136053d69027bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c93c5160b35c290a929becde7d9ea0c994116bd0", "patch": "@@ -1,3 +1,54 @@\n+2007-08-08  Richard Sandiford  <richard@codesourcery.com>\n+\t    Sandra Loosemore  <sandra@codesourcery.com>\n+\t    Chao-ying Fu  <fu@mips.com>\n+\t    Nigel Stephens  <nigel@mips.com>\n+\t    David Ung  <davidu@mips.com>\n+\n+\t* doc/invoke.texi (-mcode-readable): Document.\n+\t* config/mips/mips.opt (mcode-readable): New option.\n+\t* config/mips/mips-protos.h (SYMBOL_32_HIGH): New symbol type.\n+\t* config/mips/mips.h (mips_code_readable_setting): New enum.\n+\t(mips_code_readable): Declare.\n+\t(TARGET_MIPS16_TEXT_LOADS, TARGET_MIPS16_PCREL_LOADS): New macros.\n+\t(TARGET_MIPS16_SHORT_JUMP_TABLES): New macro.\n+\t(JUMP_TABLES_IN_TEXT_SECTION): Use it.\n+\t(CASE_VECTOR_MODE, CASE_VECTOR_PC_RELATIVE): Likewise.  Remove\n+\tboiler-plate comments.\n+\t(ASM_OUTPUT_ADDR_DIFF_ELT): Use TARGET_MIPS16_SHORT_JUMP_TABLES.\n+\t* config/mips/mips.c (mips_code_readable): New variable.\n+\t(mips_classify_symbol): Only return SYMBOL_PC_RELATIVE for\n+\tMIPS16 labels if TARGET_MIPS16_SHORT_JUMP_TABLES.  Use both the\n+\tcontext and -mcode-readable setting to restrict the use of\n+\tSYMBOL_PC_RELATIVE for MIPS16 constant pool references.\n+\tOnly return TARGET_FORCE_TO_MEM if PC-relative loads are allowed.\n+\t(mips_symbolic_constant_p): Handle SYMBOL_32_HIGH.\n+\t(mips_blocks_for_constant_p): Only return false for\n+\tTARGET_MIPS16_PCREL_LOADS.\n+\t(mips_symbol_insns_1): Treat HIGHs as 2 extended instructions\n+\tfor MIPS16.  Handle SYMBOL_32_HIGH.\n+\t(mips_const_insns): Allow HIGHs for MIPS16 too.\n+\t(mips_unspec_address_offset): New function, split out from...\n+\t(mips_unspec_address): ...here.\n+\t(mips_output_move): Handle MIPS16 HIGH moves.  Use \"li\" to load\n+\t16-bit symbolic constants.  Assert approropiate conditions for\n+\tusing the \"la\" and \"dla\" macros.\n+\t(mips_handle_option): Handle -mcode-readable=.\n+\t(override_options): Use %hi/%lo relocations for TARGET_MIPS16 too.\n+\tSet up mips_lo_relocs[SYMBOL_32_HIGH].\n+\t(mips_strip_unspec_address): New function, split out from...\n+\t(print_operand_reloc): ...here.\n+\t(print_operand): Pass constants through mips_strip_unspec_address.\n+\t(print_operand_address): Likewise.\n+\t(mips_output_mi_thunk): Remove guard of mips16_lay_out_constants.\n+\t(mips_select_rtx_section): Remove MIPS16 handling.\n+\t(mips16_gp_pseudo_reg): Check currently_expanding_to_rtl.\n+\t(mips16_rewrite_pool_refs): Wrap the labels in an address UNSPEC.\n+\t(mips16_lay_out_constants): Do nothing unless\n+\tTARGET_MIPS16_PCREL_LOADS.\n+\t(mips_avoid_hazards): Remove guard of mips16_lay_out_constants.\n+\t* config/mips/mips.md: Split HIGHs for MIPS16.\n+\t(tablejump): Use TARGET_MIPS16_SHORT_JUMP_TABLES.\n+\n 2007-08-08  Richard Sandiford  <richard@codesourcery.com>\n \n \t* config/mips/mips-protos.h (mips_emit_move): Declare."}, {"sha": "2fec3ed5f4f98f23eacda8772f40808b476b8b70", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=c93c5160b35c290a929becde7d9ea0c994116bd0", "patch": "@@ -93,6 +93,9 @@ enum mips_symbol_context {\n        UNSPEC wrappers around SYMBOL_TLS, corresponding to the\n        thread-local storage relocation operators.\n \n+   SYMBOL_32_HIGH\n+       For a 32-bit symbolic address X, this is the value of %hi(X).\n+\n    SYMBOL_64_HIGH\n        For a 64-bit symbolic address X, this is the value of\n        (%highest(X) << 16) + %higher(X).\n@@ -125,6 +128,7 @@ enum mips_symbol_type {\n   SYMBOL_DTPREL,\n   SYMBOL_GOTTPREL,\n   SYMBOL_TPREL,\n+  SYMBOL_32_HIGH,\n   SYMBOL_64_HIGH,\n   SYMBOL_64_MID,\n   SYMBOL_64_LOW,"}, {"sha": "7f09ff9e2a0b545b6a955b47275c598b2613e918", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 114, "deletions": 49, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=c93c5160b35c290a929becde7d9ea0c994116bd0", "patch": "@@ -616,6 +616,9 @@ int mips_abi = MIPS_ABI_DEFAULT;\n /* Cost information to use.  */\n const struct mips_rtx_cost_data *mips_cost;\n \n+/* The -mtext-loads setting.  */\n+enum mips_code_readable_setting mips_code_readable = CODE_READABLE_YES;\n+\n /* Whether we are generating mips16 hard float code.  In mips16 mode\n    we always set TARGET_SOFT_FLOAT; this variable is nonzero if\n    -msoft-float was not specified by the user, which means that we\n@@ -1444,7 +1447,10 @@ mips_classify_symbol (rtx x, enum mips_symbol_context context)\n \n   if (GET_CODE (x) == LABEL_REF)\n     {\n-      if (TARGET_MIPS16)\n+      /* LABEL_REFs are used for jump tables as well as text labels.\n+\t Only return SYMBOL_PC_RELATIVE if we know the label is in\n+\t the text section.  */\n+      if (TARGET_MIPS16_SHORT_JUMP_TABLES)\n \treturn SYMBOL_PC_RELATIVE;\n       if (TARGET_ABICALLS && !TARGET_ABSOLUTE_ABICALLS)\n \treturn SYMBOL_GOT_PAGE_OFST;\n@@ -1458,7 +1464,10 @@ mips_classify_symbol (rtx x, enum mips_symbol_context context)\n \n   if (CONSTANT_POOL_ADDRESS_P (x))\n     {\n-      if (TARGET_MIPS16)\n+      if (TARGET_MIPS16_TEXT_LOADS)\n+\treturn SYMBOL_PC_RELATIVE;\n+\n+      if (TARGET_MIPS16_PCREL_LOADS && context == SYMBOL_CONTEXT_MEM)\n \treturn SYMBOL_PC_RELATIVE;\n \n       if (!TARGET_EMBEDDED_DATA\n@@ -1502,7 +1511,7 @@ mips_classify_symbol (rtx x, enum mips_symbol_context context)\n       return SYMBOL_GOT_PAGE_OFST;\n     }\n \n-  if (TARGET_MIPS16 && context != SYMBOL_CONTEXT_CALL)\n+  if (TARGET_MIPS16_PCREL_LOADS && context != SYMBOL_CONTEXT_CALL)\n     return SYMBOL_FORCE_TO_MEM;\n   return SYMBOL_ABSOLUTE;\n }\n@@ -1560,6 +1569,7 @@ mips_symbolic_constant_p (rtx x, enum mips_symbol_context context,\n     {\n     case SYMBOL_ABSOLUTE:\n     case SYMBOL_FORCE_TO_MEM:\n+    case SYMBOL_32_HIGH:\n     case SYMBOL_64_HIGH:\n     case SYMBOL_64_MID:\n     case SYMBOL_64_LOW:\n@@ -1774,14 +1784,14 @@ mips_cannot_force_const_mem (rtx x)\n   return false;\n }\n \n-/* Implement TARGET_USE_BLOCKS_FOR_CONSTANT_P.  MIPS16 uses per-function\n-   constant pools, but normal-mode code doesn't need to.  */\n+/* Implement TARGET_USE_BLOCKS_FOR_CONSTANT_P.  We can't use blocks for\n+   constants when we're using a per-function constant pool.  */\n \n static bool\n mips_use_blocks_for_constant_p (enum machine_mode mode ATTRIBUTE_UNUSED,\n \t\t\t\trtx x ATTRIBUTE_UNUSED)\n {\n-  return !TARGET_MIPS16;\n+  return !TARGET_MIPS16_PCREL_LOADS;\n }\n \f\n /* Like mips_symbol_insns, but treat extended MIPS16 instructions as a\n@@ -1805,8 +1815,9 @@ mips_symbol_insns_1 (enum mips_symbol_type type, enum machine_mode mode)\n \t     dsll    $at,$at,16\n \n \t The final address is then $at + %lo(symbol).  With 32-bit\n-\t symbols we just need a preparatory lui.  */\n-      return ABI_HAS_64BIT_SYMBOLS ? 6 : 2;\n+\t symbols we just need a preparatory lui for normal mode and\n+\t a preparatory \"li; sll\" for MIPS16.  */\n+      return ABI_HAS_64BIT_SYMBOLS ? 6 : TARGET_MIPS16 ? 3 : 2;\n \n     case SYMBOL_GP_RELATIVE:\n       /* Treat GP-relative accesses as taking a single instruction on\n@@ -1863,6 +1874,7 @@ mips_symbol_insns_1 (enum mips_symbol_type type, enum machine_mode mode)\n     case SYMBOL_GOTOFF_DISP:\n     case SYMBOL_GOTOFF_CALL:\n     case SYMBOL_GOTOFF_LOADGP:\n+    case SYMBOL_32_HIGH:\n     case SYMBOL_64_HIGH:\n     case SYMBOL_64_MID:\n     case SYMBOL_64_LOW:\n@@ -1875,7 +1887,7 @@ mips_symbol_insns_1 (enum mips_symbol_type type, enum machine_mode mode)\n       /* A 16-bit constant formed by a single relocation, or a 32-bit\n \t constant formed from a high 16-bit relocation and a low 16-bit\n \t relocation.  Use mips_split_p to determine which.  */\n-      return mips_split_p[type] ? 2 : 1;\n+      return !mips_split_p[type] ? 1 : TARGET_MIPS16 ? 3 : 2;\n \n     case SYMBOL_TLS:\n       /* We don't treat a bare TLS symbol as a constant.  */\n@@ -1989,13 +2001,14 @@ mips_const_insns (rtx x)\n   switch (GET_CODE (x))\n     {\n     case HIGH:\n-      if (TARGET_MIPS16\n-\t  || !mips_symbolic_constant_p (XEXP (x, 0), SYMBOL_CONTEXT_LEA,\n-\t\t\t\t\t&symbol_type)\n+      if (!mips_symbolic_constant_p (XEXP (x, 0), SYMBOL_CONTEXT_LEA,\n+\t\t\t\t     &symbol_type)\n \t  || !mips_split_p[symbol_type])\n \treturn 0;\n \n-      return 1;\n+      /* This is simply an lui for normal mode.  It is an extended\n+\t \"li\" followed by an extended \"sll\" for MIPS16.  */\n+      return TARGET_MIPS16 ? 4 : 1;\n \n     case CONST_INT:\n       if (TARGET_MIPS16)\n@@ -2173,6 +2186,20 @@ mips_split_symbol (rtx temp, rtx addr, enum machine_mode mode, rtx *lo_sum_out)\n }\n \n \n+/* Wrap symbol or label BASE in an unspec address of type SYMBOL_TYPE\n+   and add CONST_INT OFFSET to the result.  */\n+\n+static rtx\n+mips_unspec_address_offset (rtx base, rtx offset,\n+\t\t\t    enum mips_symbol_type symbol_type)\n+{\n+  base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base),\n+\t\t\t UNSPEC_ADDRESS_FIRST + symbol_type);\n+  if (offset != const0_rtx)\n+    base = gen_rtx_PLUS (Pmode, base, offset);\n+  return gen_rtx_CONST (Pmode, base);\n+}\n+\n /* Return an UNSPEC address with underlying address ADDRESS and symbol\n    type SYMBOL_TYPE.  */\n \n@@ -2182,11 +2209,7 @@ mips_unspec_address (rtx address, enum mips_symbol_type symbol_type)\n   rtx base, offset;\n \n   split_const (address, &base, &offset);\n-  base = gen_rtx_UNSPEC (Pmode, gen_rtvec (1, base),\n-\t\t\t UNSPEC_ADDRESS_FIRST + symbol_type);\n-  if (offset != const0_rtx)\n-    base = gen_rtx_PLUS (Pmode, base, offset);\n-  return gen_rtx_CONST (Pmode, base);\n+  return mips_unspec_address_offset (base, offset, symbol_type);\n }\n \n \n@@ -3130,6 +3153,7 @@ const char *\n mips_output_move (rtx dest, rtx src)\n {\n   enum rtx_code dest_code, src_code;\n+  enum mips_symbol_type symbol_type;\n   bool dbl_p;\n \n   dest_code = GET_CODE (dest);\n@@ -3217,13 +3241,27 @@ mips_output_move (rtx dest, rtx src)\n \t}\n \n       if (src_code == HIGH)\n-\treturn \"lui\\t%0,%h1\";\n+\treturn TARGET_MIPS16 ? \"#\" : \"lui\\t%0,%h1\";\n \n       if (CONST_GP_P (src))\n \treturn \"move\\t%0,%1\";\n \n+      if (mips_symbolic_constant_p (src, SYMBOL_CONTEXT_LEA, &symbol_type)\n+\t  && mips_lo_relocs[symbol_type] != 0)\n+\t{\n+\t  /* A signed 16-bit constant formed by applying a relocation\n+\t     operator to a symbolic address.  */\n+\t  gcc_assert (!mips_split_p[symbol_type]);\n+\t  return \"li\\t%0,%R1\";\n+\t}\n+\n       if (symbolic_operand (src, VOIDmode))\n-\treturn (dbl_p ? \"dla\\t%0,%1\" : \"la\\t%0,%1\");\n+\t{\n+\t  gcc_assert (TARGET_MIPS16\n+\t\t      ? TARGET_MIPS16_TEXT_LOADS\n+\t\t      : !TARGET_EXPLICIT_RELOCS);\n+\t  return (dbl_p ? \"dla\\t%0,%1\" : \"la\\t%0,%1\");\n+\t}\n     }\n   if (src_code == REG && FP_REG_P (REGNO (src)))\n     {\n@@ -5007,6 +5045,17 @@ mips_handle_option (size_t code, const char *arg, int value ATTRIBUTE_UNUSED)\n       mips_cache_flush_func = NULL;\n       return true;\n \n+    case OPT_mcode_readable_:\n+      if (strcmp (arg, \"yes\") == 0)\n+\tmips_code_readable = CODE_READABLE_YES;\n+      else if (strcmp (arg, \"pcrel\") == 0)\n+\tmips_code_readable = CODE_READABLE_PCREL;\n+      else if (strcmp (arg, \"no\") == 0)\n+\tmips_code_readable = CODE_READABLE_NO;\n+      else\n+\treturn false;\n+      return true;\n+\n     default:\n       return true;\n     }\n@@ -5456,11 +5505,13 @@ override_options (void)\n     }\n   else\n     {\n-      if (TARGET_EXPLICIT_RELOCS || mips_split_addresses)\n+      if (TARGET_EXPLICIT_RELOCS || mips_split_addresses || TARGET_MIPS16)\n \t{\n \t  mips_split_p[SYMBOL_ABSOLUTE] = true;\n \t  mips_hi_relocs[SYMBOL_ABSOLUTE] = \"%hi(\";\n \t  mips_lo_relocs[SYMBOL_ABSOLUTE] = \"%lo(\";\n+\n+\t  mips_lo_relocs[SYMBOL_32_HIGH] = \"%hi(\";\n \t}\n     }\n \n@@ -5718,6 +5769,20 @@ mips_debugger_offset (rtx addr, HOST_WIDE_INT offset)\n   return offset;\n }\n \f\n+/* If OP is an UNSPEC address, return the address to which it refers,\n+   otherwise return OP itself.  */\n+\n+static rtx\n+mips_strip_unspec_address (rtx op)\n+{\n+  rtx base, offset;\n+\n+  split_const (op, &base, &offset);\n+  if (UNSPEC_ADDRESS_P (base))\n+    op = plus_constant (UNSPEC_ADDRESS (base), INTVAL (offset));\n+  return op;\n+}\n+\n /* Implement the PRINT_OPERAND macro.  The MIPS-specific operand codes are:\n \n    'X'  OP is CONST_INT, prints 32 bits in hexadecimal format = \"0x%08x\",\n@@ -6055,7 +6120,7 @@ print_operand (FILE *file, rtx op, int letter)\n     fputs (reg_names[GLOBAL_POINTER_REGNUM], file);\n \n   else\n-    output_addr_const (file, op);\n+    output_addr_const (file, mips_strip_unspec_address (op));\n }\n \n \n@@ -6068,19 +6133,13 @@ print_operand_reloc (FILE *file, rtx op, enum mips_symbol_context context,\n {\n   enum mips_symbol_type symbol_type;\n   const char *p;\n-  rtx base, offset;\n \n   if (!mips_symbolic_constant_p (op, context, &symbol_type)\n       || relocs[symbol_type] == 0)\n     fatal_insn (\"PRINT_OPERAND, invalid operand for relocation\", op);\n \n-  /* If OP uses an UNSPEC address, we want to print the inner symbol.  */\n-  split_const (op, &base, &offset);\n-  if (UNSPEC_ADDRESS_P (base))\n-    op = plus_constant (UNSPEC_ADDRESS (base), INTVAL (offset));\n-\n   fputs (relocs[symbol_type], file);\n-  output_addr_const (file, op);\n+  output_addr_const (file, mips_strip_unspec_address (op));\n   for (p = relocs[symbol_type]; *p != 0; p++)\n     if (*p == '(')\n       fputc (')', file);\n@@ -6113,7 +6172,7 @@ print_operand_address (FILE *file, rtx x)\n \treturn;\n \n       case ADDRESS_SYMBOLIC:\n-\toutput_addr_const (file, x);\n+\toutput_addr_const (file, mips_strip_unspec_address (x));\n \treturn;\n       }\n   gcc_unreachable ();\n@@ -8192,8 +8251,7 @@ mips_output_mi_thunk (FILE *file, tree thunk_fndecl ATTRIBUTE_UNUSED,\n   insn = get_insns ();\n   insn_locators_alloc ();\n   split_all_insns_noflow ();\n-  if (TARGET_MIPS16)\n-    mips16_lay_out_constants ();\n+  mips16_lay_out_constants ();\n   shorten_branches (insn);\n   final_start_function (insn, file, 1);\n   final (insn, file, 1);\n@@ -8232,14 +8290,7 @@ static section *\n mips_select_rtx_section (enum machine_mode mode, rtx x,\n \t\t\t unsigned HOST_WIDE_INT align)\n {\n-  if (TARGET_MIPS16)\n-    {\n-      /* In mips16 mode, the constant table always goes in the same section\n-         as the function, so that constants can be loaded using PC relative\n-         addressing.  */\n-      return function_section (current_function_decl);\n-    }\n-  else if (TARGET_EMBEDDED_DATA)\n+  if (TARGET_EMBEDDED_DATA)\n     {\n       /* For embedded applications, always put constants in read-only data,\n \t in order to reduce RAM usage.  */\n@@ -8827,7 +8878,7 @@ mips16_gp_pseudo_reg (void)\n   /* Don't initialize the pseudo register if we are being called from\n      the tree optimizers' cost-calculation routines.  */\n   if (!cfun->machine->initialized_mips16_gp_pseudo_p\n-      && current_ir_type () != IR_GIMPLE)\n+      && (current_ir_type () != IR_GIMPLE || currently_expanding_to_rtl))\n     {\n       rtx insn, scan;\n \n@@ -9546,11 +9597,23 @@ static int\n mips16_rewrite_pool_refs (rtx *x, void *data)\n {\n   struct mips16_constant_pool *pool = data;\n-  if (GET_CODE (*x) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (*x))\n-    *x = gen_rtx_LABEL_REF (Pmode, add_constant (pool,\n-\t\t\t\t\t\t get_pool_constant (*x),\n-\t\t\t\t\t\t get_pool_mode (*x)));\n-  return 0;\n+  rtx base, offset, label;\n+\n+  if (MEM_P (*x))\n+    x = &XEXP (*x, 0);\n+  else if (!TARGET_MIPS16_TEXT_LOADS)\n+    return 0;\n+\n+  split_const (*x, &base, &offset);\n+  if (GET_CODE (base) == SYMBOL_REF && CONSTANT_POOL_ADDRESS_P (base))\n+    {\n+      label = add_constant (pool, get_pool_constant (base),\n+\t\t\t    get_pool_mode (base));\n+      base = gen_rtx_LABEL_REF (Pmode, label);\n+      *x = mips_unspec_address_offset (base, offset, SYMBOL_PC_RELATIVE);\n+      return -1;\n+    }\n+  return GET_CODE (*x) == CONST ? -1 : 0;\n }\n \n /* Build MIPS16 constant pools.  */\n@@ -9561,6 +9624,9 @@ mips16_lay_out_constants (void)\n   struct mips16_constant_pool pool;\n   rtx insn, barrier;\n \n+  if (!TARGET_MIPS16_PCREL_LOADS)\n+    return;\n+\n   barrier = 0;\n   memset (&pool, 0, sizeof (pool));\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -10117,9 +10183,8 @@ mips_avoid_hazards (void)\n static void\n mips_reorg (void)\n {\n-  if (TARGET_MIPS16)\n-    mips16_lay_out_constants ();\n-  else if (TARGET_EXPLICIT_RELOCS)\n+  mips16_lay_out_constants ();\n+  if (TARGET_EXPLICIT_RELOCS)\n     {\n       if (mips_flag_delayed_branch)\n \tdbr_schedule (get_insns ());"}, {"sha": "9a55f02fc7c823090f14ae2e4409560848a73435", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=c93c5160b35c290a929becde7d9ea0c994116bd0", "patch": "@@ -114,6 +114,13 @@ struct mips_cpu_info {\n   int isa;\n };\n \n+/* Enumerates the setting of the -mcode-readable option.  */\n+enum mips_code_readable_setting {\n+  CODE_READABLE_NO,\n+  CODE_READABLE_PCREL,\n+  CODE_READABLE_YES\n+};\n+\n #ifndef USED_FOR_TARGET\n extern char mips_print_operand_punct[256]; /* print_operand punctuation chars */\n extern const char *current_function_file; /* filename current function is in */\n@@ -138,6 +145,7 @@ extern const struct mips_cpu_info mips_cpu_info_table[];\n extern const struct mips_cpu_info *mips_arch_info;\n extern const struct mips_cpu_info *mips_tune_info;\n extern const struct mips_rtx_cost_data *mips_cost;\n+extern enum mips_code_readable_setting mips_code_readable;\n #endif\n \n /* Macros to silence warnings about numbers being signed in traditional\n@@ -214,6 +222,16 @@ extern const struct mips_rtx_cost_data *mips_cost;\n /* Generate mips16e register save/restore sequences.  */\n #define GENERATE_MIPS16E_SAVE_RESTORE (GENERATE_MIPS16E && mips_abi == ABI_32)\n \n+/* True if we're generating a form of MIPS16 code in which general\n+   text loads are allowed.  */\n+#define TARGET_MIPS16_TEXT_LOADS \\\n+  (TARGET_MIPS16 && mips_code_readable == CODE_READABLE_YES)\n+\n+/* True if we're generating a form of MIPS16 code in which PC-relative\n+   loads are allowed.  */\n+#define TARGET_MIPS16_PCREL_LOADS \\\n+  (TARGET_MIPS16 && mips_code_readable >= CODE_READABLE_PCREL)\n+\n /* Generic ISA defines.  */\n #define ISA_MIPS1\t\t    (mips_isa == 1)\n #define ISA_MIPS2\t\t    (mips_isa == 2)\n@@ -2270,17 +2288,18 @@ typedef struct mips_args {\n #define SYMBOL_REF_LONG_CALL_P(X)\t\t\t\t\t\\\n   ((SYMBOL_REF_FLAGS (X) & SYMBOL_FLAG_LONG_CALL) != 0)\n \n-/* Specify the machine mode that this machine uses\n-   for the index in the tablejump instruction.\n-   ??? Using HImode in mips16 mode can cause overflow.  */\n-#define CASE_VECTOR_MODE \\\n-  (TARGET_MIPS16 ? HImode : ptr_mode)\n+/* True if we're generating a form of MIPS16 code in which jump tables\n+   are stored in the text section and encoded as 16-bit PC-relative\n+   offsets.  This is only possible when general text loads are allowed,\n+   since the table access itself will be an \"lh\" instruction.  */\n+/* ??? 16-bit offsets can overflow in large functions.  */\n+#define TARGET_MIPS16_SHORT_JUMP_TABLES TARGET_MIPS16_TEXT_LOADS\n \n-/* Define as C expression which evaluates to nonzero if the tablejump\n-   instruction expects the table to contain offsets from the address of the\n-   table.\n-   Do not define this if the table should contain absolute addresses.  */\n-#define CASE_VECTOR_PC_RELATIVE (TARGET_MIPS16)\n+#define JUMP_TABLES_IN_TEXT_SECTION TARGET_MIPS16_SHORT_JUMP_TABLES\n+\n+#define CASE_VECTOR_MODE (TARGET_MIPS16_SHORT_JUMP_TABLES ? HImode : ptr_mode)\n+\n+#define CASE_VECTOR_PC_RELATIVE TARGET_MIPS16_SHORT_JUMP_TABLES\n \n /* Define this as 1 if `char' should by default be signed; else as 0.  */\n #ifndef DEFAULT_SIGNED_CHAR\n@@ -2650,7 +2669,7 @@ while (0)\n \n #define ASM_OUTPUT_ADDR_DIFF_ELT(STREAM, BODY, VALUE, REL)\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n-  if (TARGET_MIPS16)\t\t\t\t\t\t\t\\\n+  if (TARGET_MIPS16_SHORT_JUMP_TABLES)\t\t\t\t\t\\\n     fprintf (STREAM, \"\\t.half\\t%sL%d-%sL%d\\n\",\t\t\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE, LOCAL_LABEL_PREFIX, REL);\t\\\n   else if (TARGET_GPWORD)\t\t\t\t\t\t\\\n@@ -2673,10 +2692,6 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t     LOCAL_LABEL_PREFIX, VALUE);\t\t\t\t\\\n } while (0)\n \n-/* When generating MIPS16 code, we want the jump table to be in the text\n-   section so that we can load its address using a PC-relative addition.  */\n-#define JUMP_TABLES_IN_TEXT_SECTION TARGET_MIPS16\n-\n /* This is how to output an assembler line\n    that says to advance the location counter\n    to a multiple of 2**LOG bytes.  */"}, {"sha": "6ec22354d0d26ce47695f1e12afa667fd08b8c41", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=c93c5160b35c290a929becde7d9ea0c994116bd0", "patch": "@@ -3181,6 +3181,22 @@\n }\n   [(set_attr \"length\" \"24\")])\n \n+;; Split HIGHs into:\n+;;\n+;;\tli op0,%hi(sym)\n+;;\tsll op0,16\n+;;\n+;; on MIPS16 targets.\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+\t(high:SI (match_operand:SI 1 \"absolute_symbolic_operand\" \"\")))]\n+  \"TARGET_MIPS16 && reload_completed\"\n+  [(set (match_dup 0) (match_dup 2))\n+   (set (match_dup 0) (ashift:SI (match_dup 0) (const_int 16)))]\n+{\n+  operands[2] = mips_unspec_address (operands[1], SYMBOL_32_HIGH);\n+})\n+\n ;; Insns to fetch a symbol from a big GOT.\n \n (define_insn_and_split \"*xgot_hi<mode>\"\n@@ -5050,7 +5066,7 @@\n    (use (label_ref (match_operand 1 \"\")))]\n   \"\"\n {\n-  if (TARGET_MIPS16)\n+  if (TARGET_MIPS16_SHORT_JUMP_TABLES)\n     operands[0] = expand_binop (Pmode, add_optab,\n \t\t\t\tconvert_to_mode (Pmode, operands[0], false),\n \t\t\t\tgen_rtx_LABEL_REF (Pmode, operands[1]),"}, {"sha": "afb3301f07601542019ac0ef13d13be129c314f9", "filename": "gcc/config/mips/mips.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fconfig%2Fmips%2Fmips.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fconfig%2Fmips%2Fmips.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.opt?ref=c93c5160b35c290a929becde7d9ea0c994116bd0", "patch": "@@ -228,6 +228,10 @@ msym32\n Target Report Var(TARGET_SYM32)\n Assume all symbols have 32-bit values\n \n+mcode-readable=\n+Target RejectNegative Joined\n+-mcode-readable=SETTING\tSpecify when instructions are allowed to access code\n+\n mtune=\n Target RejectNegative Joined Var(mips_tune_string)\n -mtune=PROCESSOR\tOptimize the output for PROCESSOR"}, {"sha": "944cb4631a2f24d2313b4344d961d76293534baf", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=c93c5160b35c290a929becde7d9ea0c994116bd0", "patch": "@@ -628,6 +628,7 @@ Objective-C and Objective-C++ Dialects}.\n -mlong64  -mlong32  -msym32  -mno-sym32 @gol\n -G@var{num}  -membedded-data  -mno-embedded-data @gol\n -muninit-const-in-rodata  -mno-uninit-const-in-rodata @gol\n+-mcode-readable=@var{setting} @gol\n -msplit-addresses  -mno-split-addresses @gol\n -mexplicit-relocs  -mno-explicit-relocs @gol\n -mcheck-zero-division  -mno-check-zero-division @gol\n@@ -11779,6 +11780,31 @@ when executing, and thus may be preferred for some embedded systems.\n Put uninitialized @code{const} variables in the read-only data section.\n This option is only meaningful in conjunction with @option{-membedded-data}.\n \n+@item -mcode-readable=@var{setting}\n+@opindex mcode-readable\n+Specify whether GCC may generate code that reads from executable sections.\n+There are three possible settings:\n+\n+@table @gcctabopt\n+@item -mcode-readable=yes\n+Instructions may freely access executable sections.  This is the\n+default setting.\n+\n+@item -mcode-readable=pcrel\n+MIPS16 PC-relative load instructions can access executable sections,\n+but other instructions must not do so.  This option is useful on 4KSc\n+and 4KSd processors when the code TLBs have the Read Inhibit bit set.\n+It is also useful on processors that can be configured to have a dual\n+instruction/data SRAM interface and that, like the M4K, automatically\n+redirect PC-relative loads to the instruction RAM.\n+\n+@item -mcode-readable=no\n+Instructions must not access executable sections.  This option can be\n+useful on targets that are configured to have a dual instruction/data\n+SRAM interface but that (unlike the M4K) do not automatically redirect\n+PC-relative loads to the instruction RAM.\n+@end table\n+\n @item -msplit-addresses\n @itemx -mno-split-addresses\n @opindex msplit-addresses"}, {"sha": "5dd66c3f72cbda6ca3aca358c60c1101a0ca8d6e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c93c5160b35c290a929becde7d9ea0c994116bd0", "patch": "@@ -1,3 +1,9 @@\n+2007-08-08  Richard Sandiford  <richard@codesourcery.com>\n+\n+\t* gcc.target/mips/code-readable-1.c: New test.\n+\t* gcc.target/mips/code-readable-2.c: Likewise.\n+\t* gcc.target/mips/code-readable-3.c: Likewise.\n+\n 2007-08-08  Vladimir Yanovsky  <yanov@il.ibm.com>\n             Revital Eres  <eres@il.ibm.com>\n  "}, {"sha": "75a34cd49c00fda5a6c803dac4f2180d0ec86408", "filename": "gcc/testsuite/gcc.target/mips/code-readable-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcode-readable-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcode-readable-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcode-readable-1.c?ref=c93c5160b35c290a929becde7d9ea0c994116bd0", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-mips-options \"-mips16 -mcode-readable=yes -mgp32\" } */\n+\n+int\n+foo (int i)\n+{\n+  switch (i)\n+    {\n+    case 1: return 40;\n+    case 2: return 11;\n+    case 3: return 29;\n+    case 4: return 10;\n+    case 5: return 12;\n+    case 6: return 35;\n+    case 7: return 23;\n+    default: return 0;\n+    }\n+}\n+\n+extern int k[];\n+\n+int *\n+bar (void)\n+{\n+  return k;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tla\\t\" } } */\n+/* { dg-final { scan-assembler \"\\t\\.half\\t\" } } */\n+/* { dg-final { scan-assembler-not \"%hi\\\\(\\[^)\\]*L\" } } */\n+/* { dg-final { scan-assembler-not \"%lo\\\\(\\[^)\\]*L\" } } */\n+\n+/* { dg-final { scan-assembler \"\\t\\.word\\tk\\n\" } } */\n+/* { dg-final { scan-assembler-not \"%hi\\\\(k\\\\)\" } } */\n+/* { dg-final { scan-assembler-not \"%lo\\\\(k\\\\)\" } } */"}, {"sha": "17ec4d771987950f1eae230772eb2529e1cc8867", "filename": "gcc/testsuite/gcc.target/mips/code-readable-2.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcode-readable-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcode-readable-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcode-readable-2.c?ref=c93c5160b35c290a929becde7d9ea0c994116bd0", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-mips-options \"-mips16 -mcode-readable=pcrel -mgp32\" } */\n+\n+int\n+foo (int i)\n+{\n+  switch (i)\n+    {\n+    case 1: return 40;\n+    case 2: return 11;\n+    case 3: return 29;\n+    case 4: return 10;\n+    case 5: return 12;\n+    case 6: return 35;\n+    case 7: return 23;\n+    default: return 0;\n+    }\n+}\n+\n+extern int k[];\n+\n+int *\n+bar (void)\n+{\n+  return k;\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tla\\t\" } } */\n+/* { dg-final { scan-assembler-not \"\\t\\.half\\t\" } } */\n+/* { dg-final { scan-assembler \"%hi\\\\(\\[^)\\]*L\" } } */\n+/* { dg-final { scan-assembler \"%lo\\\\(\\[^)\\]*L\" } } */\n+\n+/* { dg-final { scan-assembler \"\\t\\.word\\tk\\n\" } } */\n+/* { dg-final { scan-assembler-not \"%hi\\\\(k\\\\)\" } } */\n+/* { dg-final { scan-assembler-not \"%lo\\\\(k\\\\)\" } } */"}, {"sha": "edb4214c22f11d83a42a10060cce0a0947a70e63", "filename": "gcc/testsuite/gcc.target/mips/code-readable-3.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcode-readable-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c93c5160b35c290a929becde7d9ea0c994116bd0/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcode-readable-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fcode-readable-3.c?ref=c93c5160b35c290a929becde7d9ea0c994116bd0", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-mips-options \"-mips16 -mcode-readable=no -mgp32\" } */\n+\n+int\n+foo (int i)\n+{\n+  switch (i)\n+    {\n+    case 1: return 40;\n+    case 2: return 11;\n+    case 3: return 29;\n+    case 4: return 10;\n+    case 5: return 12;\n+    case 6: return 35;\n+    case 7: return 23;\n+    default: return 0;\n+    }\n+}\n+\n+extern int k[];\n+\n+int *\n+bar (void)\n+{\n+  return k;\n+}\n+\n+/* { dg-final { scan-assembler-not \"\\tla\\t\" } } */\n+/* { dg-final { scan-assembler-not \"\\t\\.half\\t\" } } */\n+/* { dg-final { scan-assembler \"%hi\\\\(\\[^)\\]*L\" } } */\n+/* { dg-final { scan-assembler \"%lo\\\\(\\[^)\\]*L\" } } */\n+\n+/* { dg-final { scan-assembler-not \"\\t\\.word\\tk\\n\" } } */\n+/* { dg-final { scan-assembler \"%hi\\\\(k\\\\)\" } } */\n+/* { dg-final { scan-assembler \"%lo\\\\(k\\\\)\" } } */"}]}