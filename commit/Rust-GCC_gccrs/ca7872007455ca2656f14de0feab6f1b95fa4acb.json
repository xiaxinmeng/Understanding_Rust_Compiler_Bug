{"sha": "ca7872007455ca2656f14de0feab6f1b95fa4acb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E3ODcyMDA3NDU1Y2EyNjU2ZjE0ZGUwZmVhYjZmMWI5NWZhNGFjYg==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2006-08-09T06:46:22Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2006-08-09T06:46:22Z"}, "message": "var-tracking.c (enum micro_operation_type): Add MO_COPY.\n\n* var-tracking.c (enum micro_operation_type): Add MO_COPY.\n(var_debug_decl): New function.\n(var_reg_set): Follow debug decl link.  Add location even if\nreg is already known to hold some other variable.\n(var_mem_set): Follow debug decl link.\n(var_reg_delete_and_set, var_mem_delete_and_set): Follow debug\ndecl link.  Delete other known locations of the variable part\nif requested.\n(var_reg_delete, var_mem_delete): Delete other known locations\nof the variable part if requested.\n(same_variable_part_p): New function.\n(add_stores): Select MO_COPY when appropriate.\n(vt_initialize): Handle it.\n(compute_bb_dataflow, emit_notes_in_bb): Likewise.  Delete\nknown locations for MO_SET and MO_CLOBBER.\n(find_variable_location_part): New function.\n(set_variable_part, delete_variable_part): Use it.\n(clobber_variable_part): New function.\n* dwarf2out.c (dwarf2out_var_location): Do not follow debug\ndecl link.\n\nFrom-SVN: r116031", "tree": {"sha": "dd5e27500927e9429cbe93fc977c40e9e7bbfe34", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dd5e27500927e9429cbe93fc977c40e9e7bbfe34"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca7872007455ca2656f14de0feab6f1b95fa4acb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca7872007455ca2656f14de0feab6f1b95fa4acb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca7872007455ca2656f14de0feab6f1b95fa4acb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca7872007455ca2656f14de0feab6f1b95fa4acb/comments", "author": null, "committer": null, "parents": [{"sha": "88f2d703c749f50a6bc01aab3bf04b508400ddc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f2d703c749f50a6bc01aab3bf04b508400ddc5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88f2d703c749f50a6bc01aab3bf04b508400ddc5"}], "stats": {"total": 364, "additions": 295, "deletions": 69}, "files": [{"sha": "b0119e11d125cd0e875c0537b345b5fe67ff6f78", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7872007455ca2656f14de0feab6f1b95fa4acb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7872007455ca2656f14de0feab6f1b95fa4acb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca7872007455ca2656f14de0feab6f1b95fa4acb", "patch": "@@ -1,3 +1,26 @@\n+2006-08-09  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\t* var-tracking.c (enum micro_operation_type): Add MO_COPY.\n+\t(var_debug_decl): New function.\n+\t(var_reg_set): Follow debug decl link.  Add location even if\n+\treg is already known to hold some other variable.\n+\t(var_mem_set): Follow debug decl link.\n+\t(var_reg_delete_and_set, var_mem_delete_and_set): Follow debug\n+\tdecl link.  Delete other known locations of the variable part\n+\tif requested.\n+\t(var_reg_delete, var_mem_delete): Delete other known locations\n+\tof the variable part if requested.\n+\t(same_variable_part_p): New function.\n+\t(add_stores): Select MO_COPY when appropriate.\n+\t(vt_initialize): Handle it.\n+\t(compute_bb_dataflow, emit_notes_in_bb): Likewise.  Delete\n+\tknown locations for MO_SET and MO_CLOBBER.\n+\t(find_variable_location_part): New function.\n+\t(set_variable_part, delete_variable_part): Use it.\n+\t(clobber_variable_part): New function.\n+\t* dwarf2out.c (dwarf2out_var_location): Do not follow debug\n+\tdecl link.\n+\n 2006-08-07  Victor Kaplansky <victork@il.ibm.com>\n \n         PR tree-optimization/26969"}, {"sha": "896f85386b64ed324fa94ce7f2f31aab369b31ec", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7872007455ca2656f14de0feab6f1b95fa4acb/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7872007455ca2656f14de0feab6f1b95fa4acb/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=ca7872007455ca2656f14de0feab6f1b95fa4acb", "patch": "@@ -13551,9 +13551,6 @@ dwarf2out_var_location (rtx loc_note)\n   last_insn = loc_note;\n   last_label = newloc->label;\n   decl = NOTE_VAR_LOCATION_DECL (loc_note);\n-  if (DECL_DEBUG_EXPR_IS_FROM (decl) && DECL_DEBUG_EXPR (decl) \n-      && DECL_P (DECL_DEBUG_EXPR (decl)))\n-    decl = DECL_DEBUG_EXPR (decl); \n   add_var_loc_to_decl (decl, newloc);\n }\n "}, {"sha": "d966389ba5a26b988fc11a536fa3e4145b7c5b9e", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 272, "deletions": 66, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca7872007455ca2656f14de0feab6f1b95fa4acb/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca7872007455ca2656f14de0feab6f1b95fa4acb/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=ca7872007455ca2656f14de0feab6f1b95fa4acb", "patch": "@@ -114,6 +114,8 @@ enum micro_operation_type\n   MO_USE_NO_VAR,/* Use location which is not associated with a variable\n \t\t   or the variable is not trackable.  */\n   MO_SET,\t/* Set location.  */\n+  MO_COPY,\t/* Copy the same portion of a variable from one\n+\t\t   loation to another.  */\n   MO_CLOBBER,\t/* Clobber location.  */\n   MO_CALL,\t/* Call insn.  */\n   MO_ADJUST\t/* Adjust stack pointer.  */\n@@ -295,13 +297,14 @@ static void vars_clear (htab_t);\n static variable unshare_variable (dataflow_set *set, variable var);\n static int vars_copy_1 (void **, void *);\n static void vars_copy (htab_t, htab_t);\n+static tree var_debug_decl (tree);\n static void var_reg_set (dataflow_set *, rtx);\n-static void var_reg_delete_and_set (dataflow_set *, rtx);\n-static void var_reg_delete (dataflow_set *, rtx);\n+static void var_reg_delete_and_set (dataflow_set *, rtx, bool);\n+static void var_reg_delete (dataflow_set *, rtx, bool);\n static void var_regno_delete (dataflow_set *, int);\n static void var_mem_set (dataflow_set *, rtx);\n-static void var_mem_delete_and_set (dataflow_set *, rtx);\n-static void var_mem_delete (dataflow_set *, rtx);\n+static void var_mem_delete_and_set (dataflow_set *, rtx, bool);\n+static void var_mem_delete (dataflow_set *, rtx, bool);\n \n static void dataflow_set_init (dataflow_set *, int);\n static void dataflow_set_clear (dataflow_set *);\n@@ -318,6 +321,7 @@ static void dataflow_set_destroy (dataflow_set *);\n \n static bool contains_symbol_ref (rtx);\n static bool track_expr_p (tree);\n+static bool same_variable_part_p (rtx, tree, HOST_WIDE_INT);\n static int count_uses (rtx *, void *);\n static void count_uses_1 (rtx *, void *);\n static void count_stores (rtx, rtx, void *);\n@@ -335,6 +339,7 @@ static void dump_dataflow_sets (void);\n \n static void variable_was_changed (variable, htab_t);\n static void set_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT);\n+static void clobber_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT);\n static void delete_variable_part (dataflow_set *, rtx, tree, HOST_WIDE_INT);\n static int emit_note_insn_var_location (void **, void *);\n static void emit_notes_for_changes (rtx, enum emit_note_where);\n@@ -798,30 +803,55 @@ vars_copy (htab_t dst, htab_t src)\n   htab_traverse (src, vars_copy_1, dst);\n }\n \n+/* Map a decl to its main debug decl.  */\n+\n+static inline tree\n+var_debug_decl (tree decl)\n+{\n+  if (decl && DECL_P (decl)\n+      && DECL_DEBUG_EXPR_IS_FROM (decl) && DECL_DEBUG_EXPR (decl)\n+      && DECL_P (DECL_DEBUG_EXPR (decl)))\n+    decl = DECL_DEBUG_EXPR (decl);\n+\n+  return decl;\n+}\n+\n /* Set the register to contain REG_EXPR (LOC), REG_OFFSET (LOC).  */\n \n static void\n var_reg_set (dataflow_set *set, rtx loc)\n {\n   tree decl = REG_EXPR (loc);\n   HOST_WIDE_INT offset = REG_OFFSET (loc);\n+  attrs node;\n+\n+  decl = var_debug_decl (decl);\n \n-  if (set->regs[REGNO (loc)] == NULL)\n+  for (node = set->regs[REGNO (loc)]; node; node = node->next)\n+    if (node->decl == decl && node->offset == offset)\n+      break;\n+  if (!node)\n     attrs_list_insert (&set->regs[REGNO (loc)], decl, offset, loc);\n   set_variable_part (set, loc, decl, offset);\n }\n \n-/* Delete current content of register LOC in dataflow set SET\n-   and set the register to contain REG_EXPR (LOC), REG_OFFSET (LOC).  */\n+/* Delete current content of register LOC in dataflow set SET and set\n+   the register to contain REG_EXPR (LOC), REG_OFFSET (LOC).  If\n+   MODIFY is true, any other live copies of the same variable part are\n+   also deleted from the dataflow set, otherwise the variable part is\n+   assumed to be copied from another location holding the same\n+   part.  */\n \n static void\n-var_reg_delete_and_set (dataflow_set *set, rtx loc)\n+var_reg_delete_and_set (dataflow_set *set, rtx loc, bool modify)\n {\n   tree decl = REG_EXPR (loc);\n   HOST_WIDE_INT offset = REG_OFFSET (loc);\n   attrs node, next;\n   attrs *nextp;\n \n+  decl = var_debug_decl (decl);\n+\n   nextp = &set->regs[REGNO (loc)];\n   for (node = *nextp; node; node = next)\n     {\n@@ -838,17 +868,31 @@ var_reg_delete_and_set (dataflow_set *set, rtx loc)\n \t  nextp = &node->next;\n \t}\n     }\n+  if (modify)\n+    clobber_variable_part (set, loc, decl, offset);\n   var_reg_set (set, loc);\n }\n \n-/* Delete current content of register LOC in dataflow set SET.  */\n+/* Delete current content of register LOC in dataflow set SET.  If\n+   CLOBBER is true, also delete any other live copies of the same\n+   variable part.  */\n \n static void\n-var_reg_delete (dataflow_set *set, rtx loc)\n+var_reg_delete (dataflow_set *set, rtx loc, bool clobber)\n {\n   attrs *reg = &set->regs[REGNO (loc)];\n   attrs node, next;\n \n+  if (clobber)\n+    {\n+      tree decl = REG_EXPR (loc);\n+      HOST_WIDE_INT offset = REG_OFFSET (loc);\n+\n+      decl = var_debug_decl (decl);\n+\n+      clobber_variable_part (set, NULL, decl, offset);\n+    }\n+\n   for (node = *reg; node; node = next)\n     {\n       next = node->next;\n@@ -885,28 +929,44 @@ var_mem_set (dataflow_set *set, rtx loc)\n   tree decl = MEM_EXPR (loc);\n   HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n \n+  decl = var_debug_decl (decl);\n+\n   set_variable_part (set, loc, decl, offset);\n }\n \n-/* Delete and set the location part of variable MEM_EXPR (LOC)\n-   in dataflow set SET to LOC.\n+/* Delete and set the location part of variable MEM_EXPR (LOC) in\n+   dataflow set SET to LOC.  If MODIFY is true, any other live copies\n+   of the same variable part are also deleted from the dataflow set,\n+   otherwise the variable part is assumed to be copied from another\n+   location holding the same part.\n    Adjust the address first if it is stack pointer based.  */\n \n static void\n-var_mem_delete_and_set (dataflow_set *set, rtx loc)\n+var_mem_delete_and_set (dataflow_set *set, rtx loc, bool modify)\n {\n+  tree decl = MEM_EXPR (loc);\n+  HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n+\n+  decl = var_debug_decl (decl);\n+\n+  if (modify)\n+    clobber_variable_part (set, NULL, decl, offset);\n   var_mem_set (set, loc);\n }\n \n-/* Delete the location part LOC from dataflow set SET.\n+/* Delete the location part LOC from dataflow set SET.  If CLOBBER is\n+   true, also delete any other live copies of the same variable part.\n    Adjust the address first if it is stack pointer based.  */\n \n static void\n-var_mem_delete (dataflow_set *set, rtx loc)\n+var_mem_delete (dataflow_set *set, rtx loc, bool clobber)\n {\n   tree decl = MEM_EXPR (loc);\n   HOST_WIDE_INT offset = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n \n+  decl = var_debug_decl (decl);\n+  if (clobber)\n+    clobber_variable_part (set, NULL, decl, offset);\n   delete_variable_part (set, loc, decl, offset);\n }\n \n@@ -1479,6 +1539,41 @@ track_expr_p (tree expr)\n   return 1;\n }\n \n+/* Determine whether a given LOC refers to the same variable part as\n+   EXPR+OFFSET.  */\n+\n+static bool\n+same_variable_part_p (rtx loc, tree expr, HOST_WIDE_INT offset)\n+{\n+  tree expr2;\n+  HOST_WIDE_INT offset2;\n+\n+  if (! DECL_P (expr))\n+    return false;\n+\n+  if (REG_P (loc))\n+    {\n+      expr2 = REG_EXPR (loc);\n+      offset2 = REG_OFFSET (loc);\n+    }\n+  else if (MEM_P (loc))\n+    {\n+      expr2 = MEM_EXPR (loc);\n+      offset2 = MEM_OFFSET (loc) ? INTVAL (MEM_OFFSET (loc)) : 0;\n+    }\n+  else\n+    return false;\n+\n+  if (! expr2 || ! DECL_P (expr2))\n+    return false;\n+\n+  expr = var_debug_decl (expr);\n+  expr2 = var_debug_decl (expr2);\n+\n+  return (expr == expr2 && offset == offset2);\n+}\n+\n+\n /* Count uses (register and memory references) LOC which will be tracked.\n    INSN is instruction which the LOC is part of.  */\n \n@@ -1570,9 +1665,18 @@ add_stores (rtx loc, rtx expr, void *insn)\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n-      mo->type = ((GET_CODE (expr) != CLOBBER && REG_EXPR (loc)\n-\t\t   && track_expr_p (REG_EXPR (loc)))\n-\t\t  ? MO_SET : MO_CLOBBER);\n+      if (GET_CODE (expr) == CLOBBER\n+\t  || ! REG_EXPR (loc)\n+\t  || ! track_expr_p (REG_EXPR (loc)))\n+\tmo->type = MO_CLOBBER;\n+      else if (GET_CODE (expr) == SET\n+\t       && SET_DEST (expr) == loc\n+\t       && same_variable_part_p (SET_SRC (expr),\n+\t\t\t\t\tREG_EXPR (loc),\n+\t\t\t\t\tREG_OFFSET (loc)))\n+\tmo->type = MO_COPY;\n+      else\n+\tmo->type = MO_SET;\n       mo->u.loc = loc;\n       mo->insn = NEXT_INSN ((rtx) insn);\n     }\n@@ -1583,7 +1687,17 @@ add_stores (rtx loc, rtx expr, void *insn)\n       basic_block bb = BLOCK_FOR_INSN ((rtx) insn);\n       micro_operation *mo = VTI (bb)->mos + VTI (bb)->n_mos++;\n \n-      mo->type = GET_CODE (expr) == CLOBBER ? MO_CLOBBER : MO_SET;\n+      if (GET_CODE (expr) == CLOBBER)\n+\tmo->type = MO_CLOBBER;\n+      else if (GET_CODE (expr) == SET\n+\t       && SET_DEST (expr) == loc\n+\t       && same_variable_part_p (SET_SRC (expr),\n+\t\t\t\t\tMEM_EXPR (loc),\n+\t\t\t\t\tMEM_OFFSET (loc)\n+\t\t\t\t\t? INTVAL (MEM_OFFSET (loc)) : 0))\n+\tmo->type = MO_COPY;\n+      else\n+\tmo->type = MO_SET;\n       mo->u.loc = loc;\n       mo->insn = NEXT_INSN ((rtx) insn);\n     }\n@@ -1631,21 +1745,42 @@ compute_bb_dataflow (basic_block bb)\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n \n \t      if (REG_P (loc))\n-\t\tvar_reg_delete_and_set (out, loc);\n+\t\tvar_reg_delete_and_set (out, loc, true);\n+\t      else if (MEM_P (loc))\n+\t\tvar_mem_delete_and_set (out, loc, true);\n+\t    }\n+\t    break;\n+\n+\t  case MO_COPY:\n+\t    {\n+\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\n+\t      if (REG_P (loc))\n+\t\tvar_reg_delete_and_set (out, loc, false);\n \t      else if (MEM_P (loc))\n-\t\tvar_mem_delete_and_set (out, loc);\n+\t\tvar_mem_delete_and_set (out, loc, false);\n \t    }\n \t    break;\n \n \t  case MO_USE_NO_VAR:\n+\t    {\n+\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\n+\t      if (REG_P (loc))\n+\t\tvar_reg_delete (out, loc, false);\n+\t      else if (MEM_P (loc))\n+\t\tvar_mem_delete (out, loc, false);\n+\t    }\n+\t    break;\n+\n \t  case MO_CLOBBER:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n \n \t      if (REG_P (loc))\n-\t\tvar_reg_delete (out, loc);\n+\t\tvar_reg_delete (out, loc, true);\n \t      else if (MEM_P (loc))\n-\t\tvar_mem_delete (out, loc);\n+\t\tvar_mem_delete (out, loc, true);\n \t    }\n \t    break;\n \n@@ -1903,14 +2038,47 @@ variable_was_changed (variable var, htab_t htab)\n     }\n }\n \n+/* Look for the index in VAR->var_part corresponding to OFFSET.\n+   Return -1 if not found.  If INSERTION_POINT is non-NULL, the\n+   referenced int will be set to the index that the part has or should\n+   have, if it should be inserted.  */\n+\n+static inline int\n+find_variable_location_part (variable var, HOST_WIDE_INT offset,\n+\t\t\t     int *insertion_point)\n+{\n+  int pos, low, high;\n+\n+  /* Find the location part.  */\n+  low = 0;\n+  high = var->n_var_parts;\n+  while (low != high)\n+    {\n+      pos = (low + high) / 2;\n+      if (var->var_part[pos].offset < offset)\n+\tlow = pos + 1;\n+      else\n+\thigh = pos;\n+    }\n+  pos = low;\n+\n+  if (insertion_point)\n+    *insertion_point = pos;\n+\n+  if (pos < var->n_var_parts && var->var_part[pos].offset == offset)\n+    return pos;\n+\n+  return -1;\n+}\n+\n /* Set the part of variable's location in the dataflow set SET.  The variable\n    part is specified by variable's declaration DECL and offset OFFSET and the\n    part's location by LOC.  */\n \n static void\n set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n {\n-  int pos, low, high;\n+  int pos;\n   location_chain node, next;\n   location_chain *nextp;\n   variable var;\n@@ -1933,22 +2101,13 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n     }\n   else\n     {\n+      int inspos = 0;\n+\n       var = (variable) *slot;\n \n-      /* Find the location part.  */\n-      low = 0;\n-      high = var->n_var_parts;\n-      while (low != high)\n-\t{\n-\t  pos = (low + high) / 2;\n-\t  if (var->var_part[pos].offset < offset)\n-\t    low = pos + 1;\n-\t  else\n-\t    high = pos;\n-\t}\n-      pos = low;\n+      pos = find_variable_location_part (var, offset, &inspos);\n \n-      if (pos < var->n_var_parts && var->var_part[pos].offset == offset)\n+      if (pos >= 0)\n \t{\n \t  node = var->var_part[pos].loc_chain;\n \n@@ -1980,10 +2139,10 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n \t     thus there are at most MAX_VAR_PARTS different offsets.  */\n \t  gcc_assert (var->n_var_parts < MAX_VAR_PARTS);\n \n-\t  /* We have to move the elements of array starting at index low to the\n-\t     next position.  */\n-\t  for (high = var->n_var_parts; high > low; high--)\n-\t    var->var_part[high] = var->var_part[high - 1];\n+\t  /* We have to move the elements of array starting at index\n+\t     inspos to the next position.  */\n+\t  for (pos = var->n_var_parts; pos > inspos; pos--)\n+\t    var->var_part[pos] = var->var_part[pos - 1];\n \n \t  var->n_var_parts++;\n \t  var->var_part[pos].offset = offset;\n@@ -2023,6 +2182,43 @@ set_variable_part (dataflow_set *set, rtx loc, tree decl, HOST_WIDE_INT offset)\n     }\n }\n \n+/* Remove all recorded register locations for the given variable part\n+   from dataflow set SET, except for those that are identical to loc.\n+   The variable part is specified by variable's declaration DECL and\n+   offset OFFSET.  */\n+\n+static void\n+clobber_variable_part (dataflow_set *set, rtx loc, tree decl,\n+\t\t      HOST_WIDE_INT offset)\n+{\n+  void **slot;\n+\n+  if (! decl || ! DECL_P (decl))\n+    return;\n+\n+  slot = htab_find_slot_with_hash (set->vars, decl, VARIABLE_HASH_VAL (decl),\n+\t\t\t\t   NO_INSERT);\n+  if (slot)\n+    {\n+      variable var = (variable) *slot;\n+      int pos = find_variable_location_part (var, offset, NULL);\n+\n+      if (pos >= 0)\n+\t{\n+\t  location_chain node, next;\n+\n+\t  /* Remove the register locations from the dataflow set.  */\n+\t  next = var->var_part[pos].loc_chain;\n+\t  for (node = next; node; node = next)\n+\t    {\n+\t      next = node->next;\n+\t      if (REG_P (node->loc) && node->loc != loc)\n+\t\tvar_reg_delete (set, node->loc, false);\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Delete the part of variable's location from dataflow set SET.  The variable\n    part is specified by variable's declaration DECL and offset OFFSET and the\n    part's location by LOC.  */\n@@ -2031,29 +2227,16 @@ static void\n delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t\t      HOST_WIDE_INT offset)\n {\n-  int pos, low, high;\n   void **slot;\n     \n   slot = htab_find_slot_with_hash (set->vars, decl, VARIABLE_HASH_VAL (decl),\n \t\t\t\t   NO_INSERT);\n   if (slot)\n     {\n       variable var = (variable) *slot;\n+      int pos = find_variable_location_part (var, offset, NULL);\n \n-      /* Find the location part.  */\n-      low = 0;\n-      high = var->n_var_parts;\n-      while (low != high)\n-\t{\n-\t  pos = (low + high) / 2;\n-\t  if (var->var_part[pos].offset < offset)\n-\t    low = pos + 1;\n-\t  else\n-\t    high = pos;\n-\t}\n-      pos = low;\n-\n-      if (pos < var->n_var_parts && var->var_part[pos].offset == offset)\n+      if (pos >= 0)\n \t{\n \t  location_chain node, next;\n \t  location_chain *nextp;\n@@ -2119,7 +2302,7 @@ delete_variable_part (dataflow_set *set, rtx loc, tree decl,\n \t\t}\n \t    }\n \t  if (changed)\n-\t      variable_was_changed (var, set->vars);\n+\t    variable_was_changed (var, set->vars);\n \t}\n     }\n }\n@@ -2410,28 +2593,50 @@ emit_notes_in_bb (basic_block bb)\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n \n \t      if (REG_P (loc))\n-\t\tvar_reg_delete_and_set (&set, loc);\n+\t\tvar_reg_delete_and_set (&set, loc, true);\n \t      else\n-\t\tvar_mem_delete_and_set (&set, loc);\n+\t\tvar_mem_delete_and_set (&set, loc, true);\n+\n+\t      emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n+\t    }\n+\t    break;\n+\n+\t  case MO_COPY:\n+\t    {\n+\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\n+\t      if (REG_P (loc))\n+\t\tvar_reg_delete_and_set (&set, loc, false);\n+\t      else\n+\t\tvar_mem_delete_and_set (&set, loc, false);\n \n \t      emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n \t    }\n \t    break;\n \n \t  case MO_USE_NO_VAR:\n-\t  case MO_CLOBBER:\n \t    {\n \t      rtx loc = VTI (bb)->mos[i].u.loc;\n \n \t      if (REG_P (loc))\n-\t\tvar_reg_delete (&set, loc);\n+\t\tvar_reg_delete (&set, loc, false);\n \t      else\n-\t\tvar_mem_delete (&set, loc);\n+\t\tvar_mem_delete (&set, loc, false);\n+\n+\t      emit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n+\t    }\n+\t    break;\n \n-\t      if (VTI (bb)->mos[i].type == MO_USE_NO_VAR)\n-\t\temit_notes_for_changes (insn, EMIT_NOTE_AFTER_INSN);\n+\t  case MO_CLOBBER:\n+\t    {\n+\t      rtx loc = VTI (bb)->mos[i].u.loc;\n+\n+\t      if (REG_P (loc))\n+\t\tvar_reg_delete (&set, loc, true);\n \t      else\n-\t\temit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n+\t\tvar_mem_delete (&set, loc, true);\n+\n+\t      emit_notes_for_changes (insn, EMIT_NOTE_BEFORE_INSN);\n \t    }\n \t    break;\n \n@@ -2655,7 +2860,8 @@ vt_initialize (void)\n \t\t{\n \t\t  while (n1 < n2 && VTI (bb)->mos[n1].type == MO_CLOBBER)\n \t\t    n1++;\n-\t\t  while (n1 < n2 && VTI (bb)->mos[n2].type == MO_SET)\n+\t\t  while (n1 < n2 && (VTI (bb)->mos[n2].type == MO_SET\n+\t\t\t\t     || VTI (bb)->mos[n2].type == MO_COPY))\n \t\t    n2--;\n \t\t  if (n1 < n2)\n \t\t    {"}]}