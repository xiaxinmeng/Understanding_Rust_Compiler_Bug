{"sha": "ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmZhZjFlMDVkZDAyNGNjNTdhMjFjZWEyMzcyMmUwZTM3ZTVkOGViYg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2009-01-07T20:43:01Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2009-01-07T20:43:01Z"}, "message": "re PR c++/35297 (Compiling error with variadic template with fixed parameter with default type.)\n\n        PR c++/35297\n        PR c++/35477\n        PR c++/35784\n        PR c++/36846\n        PR c++/38276\n        * pt.c (check_default_tmpl_args): Don't complain about\n        out-of-order parameter packs in the enclosing class\n        or parameter packs after default args.\n        (coerce_template_parms): If we have more than one\n        parameter pack, don't flatten argument packs.\n        (template_args_equal): Handle argument packs.\n        (comp_template_args): Don't flatten argument packs.\n        (check_instantiated_arg): Split out from...\n        (check_instantiated_args): Here.  Handle arg packs.\n        (convert_template_argument): Just check that nontype argument\n        packs have the right type.\n\nFrom-SVN: r143166", "tree": {"sha": "bae01ef9b1a395e476eaa1c3ade6dd59e43205c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bae01ef9b1a395e476eaa1c3ade6dd59e43205c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "30af0edbf4637051e029063027052b843dbe8aac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30af0edbf4637051e029063027052b843dbe8aac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30af0edbf4637051e029063027052b843dbe8aac"}], "stats": {"total": 320, "additions": 243, "deletions": 77}, "files": [{"sha": "e1539c5d07b21cfa6141a7b2817a78028e90dd4e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "patch": "@@ -1,3 +1,22 @@\n+2009-01-06  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/35297\n+\tPR c++/35477\n+\tPR c++/35784\n+\tPR c++/36846\n+\tPR c++/38276\n+\t* pt.c (check_default_tmpl_args): Don't complain about\n+\tout-of-order parameter packs in the enclosing class\n+\tor parameter packs after default args.\n+\t(coerce_template_parms): If we have more than one\n+\tparameter pack, don't flatten argument packs.\n+\t(template_args_equal): Handle argument packs.\n+\t(comp_template_args): Don't flatten argument packs.\n+\t(check_instantiated_arg): Split out from...\n+\t(check_instantiated_args): Here.  Handle arg packs.\n+\t(convert_template_argument): Just check that nontype argument\n+\tpacks have the right type.\n+\n 2009-01-05  Dodji Seketeli  <dodji@redhat.com>\n \n \tPR c++/38472"}, {"sha": "410641de80d808d30e1bd8139d65e0ffeb2ed0d9", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 133, "deletions": 72, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "patch": "@@ -3590,7 +3590,8 @@ check_default_tmpl_args (tree decl, tree parms, int is_primary,\n \n               if (TREE_PURPOSE (parm))\n                 seen_def_arg_p = 1;\n-              else if (seen_def_arg_p)\n+              else if (seen_def_arg_p\n+\t\t       && !template_parameter_pack_p (TREE_VALUE (parm)))\n                 {\n                   error (\"no default argument for %qD\", TREE_VALUE (parm));\n                   /* For better subsequent error-recovery, we indicate that\n@@ -3601,6 +3602,9 @@ check_default_tmpl_args (tree decl, tree parms, int is_primary,\n \t      else if (is_primary\n \t\t       && !is_partial\n \t\t       && !is_friend_decl\n+\t\t       /* Don't complain about an enclosing partial\n+\t\t\t  specialization.  */\n+\t\t       && parm_level == parms\n \t\t       && TREE_CODE (decl) == TYPE_DECL\n \t\t       && i < ntparms - 1\n \t\t       && template_parameter_pack_p (TREE_VALUE (parm)))\n@@ -5060,7 +5064,19 @@ convert_template_argument (tree parm,\n       if (invalid_nontype_parm_type_p (t, complain))\n \treturn error_mark_node;\n \n-      if (!uses_template_parms (orig_arg) && !uses_template_parms (t))\n+      if (template_parameter_pack_p (parm) && ARGUMENT_PACK_P (orig_arg))\n+\t{\n+\t  if (same_type_p (t, TREE_TYPE (orig_arg)))\n+\t    val = orig_arg;\n+\t  else\n+\t    {\n+\t      /* Not sure if this is reachable, but it doesn't hurt\n+\t\t to be robust.  */\n+\t      error (\"type mismatch in nontype parameter pack\");\n+\t      val = error_mark_node;\n+\t    }\n+\t}\n+      else if (!uses_template_parms (orig_arg) && !uses_template_parms (t))\n \t/* We used to call digest_init here.  However, digest_init\n \t   will report errors, which we don't want when complain\n \t   is zero.  More importantly, digest_init will try too\n@@ -5233,24 +5249,29 @@ coerce_template_parms (tree parms,\n      parameters.  */\n   int variadic_p = 0;\n \n-  inner_args \n-    = expand_template_argument_pack (INNERMOST_TEMPLATE_ARGS (args));\n-\n-  nargs = inner_args ? NUM_TMPL_ARGS (inner_args) : 0;\n   nparms = TREE_VEC_LENGTH (parms);\n \n   /* Determine if there are any parameter packs.  */\n   for (parm_idx = 0; parm_idx < nparms; ++parm_idx)\n     {\n       tree tparm = TREE_VALUE (TREE_VEC_ELT (parms, parm_idx));\n       if (template_parameter_pack_p (tparm))\n-        {\n-          variadic_p = 1;\n-          break;\n-        }\n+\t++variadic_p;\n     }\n \n-  if ((nargs > nparms - variadic_p && !variadic_p)\n+  inner_args = INNERMOST_TEMPLATE_ARGS (args);\n+  /* If there are 0 or 1 parameter packs, we need to expand any argument\n+     packs so that we can deduce a parameter pack from some non-packed args\n+     followed by an argument pack, as in variadic85.C.  If there are more\n+     than that, we need to leave argument packs intact so the arguments are\n+     assigned to the right parameter packs.  This should only happen when\n+     dealing with a nested class inside a partial specialization of a class\n+     template, as in variadic92.C.  */\n+  if (variadic_p <= 1)\n+    inner_args = expand_template_argument_pack (inner_args);\n+\n+  nargs = inner_args ? NUM_TMPL_ARGS (inner_args) : 0;\n+  if ((nargs > nparms && !variadic_p)\n       || (nargs < nparms - variadic_p\n \t  && require_all_args\n \t  && (!use_default_args\n@@ -5297,42 +5318,48 @@ coerce_template_parms (tree parms,\n       }\n \n       /* Calculate the next argument.  */\n-      if (template_parameter_pack_p (TREE_VALUE (parm)))\n+      if (arg_idx < nargs)\n+\targ = TREE_VEC_ELT (inner_args, arg_idx);\n+      else\n+\targ = NULL_TREE;\n+\n+      if (template_parameter_pack_p (TREE_VALUE (parm))\n+\t  && !(arg && ARGUMENT_PACK_P (arg)))\n         {\n-          /* All remaining arguments will be placed in the\n-             template parameter pack PARM.  */\n-          arg = coerce_template_parameter_pack (parms, parm_idx, args, \n-                                                inner_args, arg_idx,\n-                                                new_args, &lost,\n-                                                in_decl, complain);\n-          \n+\t  /* All remaining arguments will be placed in the\n+\t     template parameter pack PARM.  */\n+\t  arg = coerce_template_parameter_pack (parms, parm_idx, args, \n+\t\t\t\t\t\tinner_args, arg_idx,\n+\t\t\t\t\t\tnew_args, &lost,\n+\t\t\t\t\t\tin_decl, complain);\n+\n           /* Store this argument.  */\n           if (arg == error_mark_node)\n             lost++;\n           TREE_VEC_ELT (new_inner_args, parm_idx) = arg;\n \n-          /* We are done with all of the arguments.  */\n-          arg_idx = nargs;\n-\n+\t  /* We are done with all of the arguments.  */\n+\t  arg_idx = nargs;\n+          \n           continue;\n         }\n-      else if (arg_idx < nargs)\n-        {\n-          arg = TREE_VEC_ELT (inner_args, arg_idx);\n-\n-          if (arg && PACK_EXPANSION_P (arg))\n+      else if (arg)\n+\t{\n+          if (PACK_EXPANSION_P (arg))\n             {\n \t      if (complain & tf_error)\n \t\t{\n+\t\t  /* FIXME this restriction was removed by N2555; see\n+\t\t     bug 35722.  */\n \t\t  /* If ARG is a pack expansion, but PARM is not a\n \t\t     template parameter pack (if it were, we would have\n \t\t     handled it above), we're trying to expand into a\n \t\t     fixed-length argument list.  */\n \t\t  if (TREE_CODE (arg) == EXPR_PACK_EXPANSION)\n-\t\t    error (\"cannot expand %<%E%> into a fixed-length \"\n+\t\t    sorry (\"cannot expand %<%E%> into a fixed-length \"\n \t\t\t   \"argument list\", arg);\n \t\t  else\n-\t\t    error (\"cannot expand %<%T%> into a fixed-length \"\n+\t\t    sorry (\"cannot expand %<%T%> into a fixed-length \"\n \t\t\t   \"argument list\", arg);\n \t\t}\n \t      return error_mark_node;\n@@ -5389,6 +5416,25 @@ template_args_equal (tree ot, tree nt)\n     return PACK_EXPANSION_P (nt) \n       && template_args_equal (PACK_EXPANSION_PATTERN (ot),\n                               PACK_EXPANSION_PATTERN (nt));\n+  else if (ARGUMENT_PACK_P (ot))\n+    {\n+      int i, len;\n+      tree opack, npack;\n+\n+      if (!ARGUMENT_PACK_P (nt))\n+\treturn 0;\n+\n+      opack = ARGUMENT_PACK_ARGS (ot);\n+      npack = ARGUMENT_PACK_ARGS (nt);\n+      len = TREE_VEC_LENGTH (opack);\n+      if (TREE_VEC_LENGTH (npack) != len)\n+\treturn 0;\n+      for (i = 0; i < len; ++i)\n+\tif (!template_args_equal (TREE_VEC_ELT (opack, i),\n+\t\t\t\t  TREE_VEC_ELT (npack, i)))\n+\t  return 0;\n+      return 1;\n+    }\n   else if (TYPE_P (nt))\n     return TYPE_P (ot) && same_type_p (ot, nt);\n   else if (TREE_CODE (ot) == TREE_VEC || TYPE_P (ot))\n@@ -5405,9 +5451,6 @@ comp_template_args (tree oldargs, tree newargs)\n {\n   int i;\n \n-  oldargs = expand_template_argument_pack (oldargs);\n-  newargs = expand_template_argument_pack (newargs);\n-\n   if (TREE_VEC_LENGTH (oldargs) != TREE_VEC_LENGTH (newargs))\n     return 0;\n \n@@ -11707,58 +11750,76 @@ tsubst_copy_and_build (tree t,\n    Emit an error under control of COMPLAIN, and return TRUE on error.  */\n \n static bool\n-check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n+check_instantiated_arg (tree tmpl, tree t, tsubst_flags_t complain)\n {\n-  int ix, len = DECL_NTPARMS (tmpl);\n-  bool result = false;\n+  if (ARGUMENT_PACK_P (t))\n+    {\n+      tree vec = ARGUMENT_PACK_ARGS (t);\n+      int len = TREE_VEC_LENGTH (vec);\n+      bool result = false;\n+      int i;\n \n-  for (ix = 0; ix != len; ix++)\n+      for (i = 0; i < len; ++i)\n+\tif (check_instantiated_arg (tmpl, TREE_VEC_ELT (vec, i), complain))\n+\t  result = true;\n+      return result;\n+    }\n+  else if (TYPE_P (t))\n     {\n-      tree t = TREE_VEC_ELT (args, ix);\n+      /* [basic.link]: A name with no linkage (notably, the name\n+\t of a class or enumeration declared in a local scope)\n+\t shall not be used to declare an entity with linkage.\n+\t This implies that names with no linkage cannot be used as\n+\t template arguments.  */\n+      tree nt = no_linkage_check (t, /*relaxed_p=*/false);\n \n-      if (TYPE_P (t))\n+      if (nt)\n \t{\n-\t  /* [basic.link]: A name with no linkage (notably, the name\n-\t     of a class or enumeration declared in a local scope)\n-\t     shall not be used to declare an entity with linkage.\n-\t     This implies that names with no linkage cannot be used as\n-\t     template arguments.  */\n-\t  tree nt = no_linkage_check (t, /*relaxed_p=*/false);\n-\n-\t  if (nt)\n-\t    {\n-\t      /* DR 488 makes use of a type with no linkage cause\n-\t\t type deduction to fail.  */\n-\t      if (complain & tf_error)\n-\t\t{\n-\t\t  if (TYPE_ANONYMOUS_P (nt))\n-\t\t    error (\"%qT is/uses anonymous type\", t);\n-\t\t  else\n-\t\t    error (\"template argument for %qD uses local type %qT\",\n-\t\t\t   tmpl, t);\n-\t\t}\n-\t      result = true;\n-\t    }\n-\t  /* In order to avoid all sorts of complications, we do not\n-\t     allow variably-modified types as template arguments.  */\n-\t  else if (variably_modified_type_p (t, NULL_TREE))\n+\t  /* DR 488 makes use of a type with no linkage cause\n+\t     type deduction to fail.  */\n+\t  if (complain & tf_error)\n \t    {\n-\t      if (complain & tf_error)\n-\t\terror (\"%qT is a variably modified type\", t);\n-\t      result = true;\n+\t      if (TYPE_ANONYMOUS_P (nt))\n+\t\terror (\"%qT is/uses anonymous type\", t);\n+\t      else\n+\t\terror (\"template argument for %qD uses local type %qT\",\n+\t\t       tmpl, t);\n \t    }\n+\t  return true;\n \t}\n-      /* A non-type argument of integral or enumerated type must be a\n-\t constant.  */\n-      else if (TREE_TYPE (t)\n-\t       && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (t))\n-\t       && !TREE_CONSTANT (t))\n+      /* In order to avoid all sorts of complications, we do not\n+\t allow variably-modified types as template arguments.  */\n+      else if (variably_modified_type_p (t, NULL_TREE))\n \t{\n \t  if (complain & tf_error)\n-\t    error (\"integral expression %qE is not constant\", t);\n-\t  result = true;\n+\t    error (\"%qT is a variably modified type\", t);\n+\t  return true;\n \t}\n     }\n+  /* A non-type argument of integral or enumerated type must be a\n+     constant.  */\n+  else if (TREE_TYPE (t)\n+\t   && INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (t))\n+\t   && !TREE_CONSTANT (t))\n+    {\n+      if (complain & tf_error)\n+\terror (\"integral expression %qE is not constant\", t);\n+      return true;\n+    }\n+  return false;\n+}\n+\n+static bool\n+check_instantiated_args (tree tmpl, tree args, tsubst_flags_t complain)\n+{\n+  int ix, len = DECL_NTPARMS (tmpl);\n+  bool result = false;\n+\n+  for (ix = 0; ix != len; ix++)\n+    {\n+      if (check_instantiated_arg (tmpl, TREE_VEC_ELT (args, ix), complain))\n+\tresult = true;\n+    }\n   if (result && (complain & tf_error))\n     error (\"  trying to instantiate %qD\", tmpl);\n   return result;"}, {"sha": "0e605d0e98f13b4e69d5a75e24a4a2d8e2304376", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "patch": "@@ -1,3 +1,8 @@\n+2009-01-07  Jason Merrill  <jason@redhat.com>\n+\n+\t* g++.dg/cpp0x/variadic92.C: New test.\n+\t* g++.dg/cpp0x/variadic93.C: New test.\n+\n 2009-01-07  Janis Johnson  <janis187@us.ibm.com>\n \n \t* lib/target-supports-dg.exp (current_compiler_flags): New."}, {"sha": "1c815d1d90f0b78c438cd4d17e490c24e81b74cd", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic65.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic65.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic65.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic65.C?ref=ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "patch": "@@ -5,4 +5,4 @@ template<typename T1 = unused, typename T2 = unused, typename T3 = unused,\n struct tuple {};\n \n template<typename... Args>\n-void foo(tuple<Args...>) { } // { dg-error \"cannot expand\" }\n+void foo(tuple<Args...>) { } // { dg-bogus \"cannot expand\" \"\" { xfail *-*-* } }"}, {"sha": "fb3ddb3c9b9cba3165393501d66b8abf756c13ea", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic82.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic82.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic82.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic82.C?ref=ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "patch": "@@ -3,9 +3,9 @@\n \n template<typename> struct A;\n \n-template<typename... T> struct A<T*...> // { dg-error \"cannot expand\" }\n+template<typename... T> struct A<T*...> // { dg-bogus \"cannot expand\" \"\" { xfail *-*-* } }\n {\n   struct B;\n };\n \n-A<void*> a; // { dg-error \"incomplete type\" }\n+A<void*> a; // { dg-bogus \"incomplete type\" \"\" { xfail *-*-* } }"}, {"sha": "2613d625f09eef958209945734f911973447327d", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic83.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic83.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic83.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic83.C?ref=ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "patch": "@@ -3,6 +3,6 @@\n \n template<typename> struct A;\n \n-template<typename... T> struct A<T...> { }; // { dg-error \"cannot expand\" }\n+template<typename... T> struct A<T...> { }; // { dg-bogus \"cannot expand\" \"\" { xfail *-*-* } }\n \n-A<int> a; // { dg-error \"incomplete type\" }\n+A<int> a; // { dg-bogus \"incomplete type\" \"\" { xfail *-*-* } }"}, {"sha": "d382912c91f3e300af97f229daec36f54875f52c", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic92.C", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic92.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic92.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic92.C?ref=ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "patch": "@@ -0,0 +1,70 @@\n+// Various tests for variadic templates and partial specialization.\n+// { dg-options \"-std=c++0x\" }\n+\n+// PR c++/36846\n+template<typename A, typename B>\n+struct pair;\n+\n+template<typename... T>\n+struct pairs;\n+\n+template<typename... AS, typename... BS>\n+struct pairs<pair<AS, BS>...> {\n+  struct mismatched_packs {};\n+};\n+\n+template class pairs<\n+  pair<int, int>,\n+  pair<int, int>\n+>;\n+\n+template<int A, int B>\n+struct point;\n+\n+template<typename... T>\n+struct points;\n+\n+template<int... AS, int... BS>\n+struct points<point<AS, BS>...> {\n+  struct mismatched_packs {};\n+};\n+\n+template class points<\n+  point<0, 1>,\n+  point<0, 1>\n+>;\n+\n+// PR c++/35477\n+template <class...ARGS> struct tuple {};\n+template <class A, class B> struct test {};\n+template <class... ARGS, class B> struct test<B, tuple<ARGS...>>\n+{\n+    template <class T> struct inside {};\n+};\n+\n+// PR c++/38276\n+template<typename...> struct A;\n+\n+template<typename, typename> struct B;\n+\n+template<typename... T, typename... U> struct B<A<T...>, A<U...> >\n+{\n+  static int i;\n+};\n+\n+B<A<>, A<int> > b1;\n+\n+B<A<int>, A<> > b2;\n+\n+// PR c++/35784\n+template <typename...> struct p;\n+\n+template <typename, typename> struct d;\n+\n+template <typename... A, typename... B>\n+struct d<p<A...>, p<B...> > { typedef int t; };\n+\n+typedef d<p<>, p<int, float> >::t q;\n+typedef d<q, d<p<int>, p<float> >::t> r; // *\n+\n+typedef d<d<p<>, p<int, float> >::t, d<p<>, p<> >::t> s;"}, {"sha": "7d8c3298e618bbe488917bdb24adf3c890c50cd6", "filename": "gcc/testsuite/g++.dg/cpp0x/variadic93.C", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic93.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic93.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fvariadic93.C?ref=ffaf1e05dd024cc57a21cea23722e0e37e5d8ebb", "patch": "@@ -0,0 +1,11 @@\n+// PR c++/35297\n+// { dg-options \"-std=c++0x\" }\n+\n+template <class T=int, class... ARGS> \n+struct test2 {};\n+\n+int main()\n+{\n+        test2<> a;\n+        return 0;\n+}"}]}