{"sha": "db24eb1f4fcc6fa8330376179278261e02b717b5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIyNGViMWY0ZmNjNmZhODMzMDM3NjE3OTI3ODI2MWUwMmI3MTdiNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-12-08T08:36:09Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-12-08T08:36:09Z"}, "message": "re PR c++/18803 (rejects access to operator() in template)\n\ncp:\n\tPR c++/18803\n\t* cp-tree.h (REFERENCE_REF_P): New.\n\t(CPTI_TYPE_INFO_TYPE): Rename to ...\n\t(CPTI_CONST_TYPE_INFO_TYPE): ... here.\n\t(CPTI_TYPE_INFO_REF_TYPE): Remove.\n\t(type_info_type_node): Rename to ...\n\t(const_type_info_type_node): ... here.\n\t(type_info_ref_type): Remove.\n\t* call.c (build_user_type_conversion): Reformat.\n\t(resolve_args): Do not convert_from_reference.\n\t(build_object_call): Call convert_from_reference.\n\t(prep_operand): Do not convert_from_reference.\n\t(build_new_method_call): Likewise.\n\t* class.c (build_vfield_ref): Likewise.\n\t* cvt.c (convert_to_reference): Likewise.\n\t(convert_from_reference): Build INDIRECT_REF here, not with\n\tbuild_indirect_ref.\n\t(convert_force): Do not convert_from_reference.\n\t(build_expr_type_conversion): Likewise.\n\t* decl.c (grok_reference_init): Likewise.\n\t* decl2.c (delete_sanity): Likewise.\n\t* except.c (initialize_handler_parm): Use POINTER_TYPE_P.\n\t* init.c (build_dtor_call): Do not convert_from_reference.\n\t* parser.c (cp_parser_template_argument): Unwrap indirected\n\treference. Allow TEMPLATE_PARM_INDEX as an object parm.\n\t* pt.c (tsubst_copy_and_build) <case INDIRECT_REF>: Use\n\tconvert_from_reference, if indicated.\n\t<case CALL_EXPR>: Do not convert_from_reference.\n\t<case PARM_DECL, VAR_DECL>: Convert_from_reference if needed.\n\t(tsubst_initializer_list): Do not convert_from_reference.\n\t* rtti.c (init_rtti_processing): Adjust node creation.\n\t(throw_bad_typeid): Use const_type_info_type_node.\n\tDo not convert_from_reference.\n\t(typeid_ok_p): Use const_type_info_type_node.\n\t(build_typeid, get_typeid): Always return type_info typed node.\n\t(build_dynamic_cast_1): Dont convert_from_reference. Refactor.\n\t* semantics.c (finish_stmt_expr_expr): Do not\n\tconvert_from_reference.\n\t(finish_id_expression): Convert_from_reference as appropriate.\n\t* typeck.c (decay_conversion): Do not convert_from_reference.\n\t(finish_class_member_access_expr): Likewise.\n\t(build_indirect_ref): Use POINTER_TYPE_P.\n\t(convert_arguments): Do not convert_from_reference.\n\t(build_modify_expr): Likewise.\n\t(convert_for_initialization): Likewise.\n\t* typeck2.c (build_x_arrow): Likewise.\ntestsuite:\n\tPR c++/18803\n\t* g++.dg/template/operator5.C: New.\n\nFrom-SVN: r91863", "tree": {"sha": "9d5171ca690b8c2e8078b4b944da983e3de547f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9d5171ca690b8c2e8078b4b944da983e3de547f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db24eb1f4fcc6fa8330376179278261e02b717b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db24eb1f4fcc6fa8330376179278261e02b717b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db24eb1f4fcc6fa8330376179278261e02b717b5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db24eb1f4fcc6fa8330376179278261e02b717b5/comments", "author": null, "committer": null, "parents": [{"sha": "89b17498044f87f7bc14f56782434c062730db8d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89b17498044f87f7bc14f56782434c062730db8d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89b17498044f87f7bc14f56782434c062730db8d"}], "stats": {"total": 293, "additions": 174, "deletions": 119}, "files": [{"sha": "c0da0a102c77ea4a07170c27e8330554457a0ad7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -1,3 +1,52 @@\n+2004-12-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/18803\n+\t* cp-tree.h (REFERENCE_REF_P): New.\n+\t(CPTI_TYPE_INFO_TYPE): Rename to ...\n+\t(CPTI_CONST_TYPE_INFO_TYPE): ... here.\n+\t(CPTI_TYPE_INFO_REF_TYPE): Remove.\n+\t(type_info_type_node): Rename to ...\n+\t(const_type_info_type_node): ... here.\n+\t(type_info_ref_type): Remove.\n+\t* call.c (build_user_type_conversion): Reformat.\n+\t(resolve_args): Do not convert_from_reference.\n+\t(build_object_call): Call convert_from_reference.\n+\t(prep_operand): Do not convert_from_reference.\n+\t(build_new_method_call): Likewise.\n+\t* class.c (build_vfield_ref): Likewise.\n+\t* cvt.c (convert_to_reference): Likewise.\n+\t(convert_from_reference): Build INDIRECT_REF here, not with\n+\tbuild_indirect_ref.\n+\t(convert_force): Do not convert_from_reference.\n+\t(build_expr_type_conversion): Likewise.\n+\t* decl.c (grok_reference_init): Likewise.\n+\t* decl2.c (delete_sanity): Likewise.\n+\t* except.c (initialize_handler_parm): Use POINTER_TYPE_P.\n+\t* init.c (build_dtor_call): Do not convert_from_reference.\n+\t* parser.c (cp_parser_template_argument): Unwrap indirected\n+\treference. Allow TEMPLATE_PARM_INDEX as an object parm.\n+\t* pt.c (tsubst_copy_and_build) <case INDIRECT_REF>: Use\n+\tconvert_from_reference, if indicated.\n+\t<case CALL_EXPR>: Do not convert_from_reference.\n+\t<case PARM_DECL, VAR_DECL>: Convert_from_reference if needed.\n+\t(tsubst_initializer_list): Do not convert_from_reference.\n+\t* rtti.c (init_rtti_processing): Adjust node creation.\n+\t(throw_bad_typeid): Use const_type_info_type_node.\n+\tDo not convert_from_reference.\n+\t(typeid_ok_p): Use const_type_info_type_node.\n+\t(build_typeid, get_typeid): Always return type_info typed node.\n+\t(build_dynamic_cast_1): Dont convert_from_reference. Refactor.\n+\t* semantics.c (finish_stmt_expr_expr): Do not\n+\tconvert_from_reference.\n+\t(finish_id_expression): Convert_from_reference as appropriate.\n+\t* typeck.c (decay_conversion): Do not convert_from_reference.\n+\t(finish_class_member_access_expr): Likewise.\n+\t(build_indirect_ref): Use POINTER_TYPE_P.\n+\t(convert_arguments): Do not convert_from_reference.\n+\t(build_modify_expr): Likewise.\n+\t(convert_for_initialization): Likewise.\n+\t* typeck2.c (build_x_arrow): Likewise.\n+\n 2004-12-07  Ziemowit Laski  <zlaski@apple.com>\n \n \t* cp-tree.h (struct lang_type_class): Rename 'objc_protocols'"}, {"sha": "ab31c99a51ed54f58bbfa5d375f911f067aa5f4f", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -2650,7 +2650,8 @@ build_user_type_conversion (tree totype, tree expr, int flags)\n     {\n       if (cand->second_conv->kind == ck_ambig)\n \treturn error_mark_node;\n-      return convert_from_reference (convert_like (cand->second_conv, expr));\n+      expr = convert_like (cand->second_conv, expr);\n+      return convert_from_reference (expr);\n     }\n   return NULL_TREE;\n }\n@@ -2672,8 +2673,6 @@ resolve_args (tree args)\n \t  error (\"invalid use of void expression\");\n \t  return error_mark_node;\n \t}\n-      arg = convert_from_reference (arg);\n-      TREE_VALUE (t) = arg;\n     }\n   return args;\n }\n@@ -2979,6 +2978,7 @@ build_object_call (tree obj, tree args)\n       else\n \t{\n \t  obj = convert_like_with_context (cand->convs[0], obj, cand->fn, -1);\n+\t  obj = convert_from_reference (obj);\n \t  result = build_function_call (obj, args);\n \t}\n     }\n@@ -3475,7 +3475,6 @@ prep_operand (tree operand)\n {\n   if (operand)\n     {\n-      operand = convert_from_reference (operand);\n       if (CLASS_TYPE_P (TREE_TYPE (operand))\n \t  && CLASSTYPE_TEMPLATE_INSTANTIATION (TREE_TYPE (operand)))\n \t/* Make sure the template type is instantiated now.  */\n@@ -5198,8 +5197,6 @@ build_new_method_call (tree instance, tree fns, tree args,\n   if (args == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n-    instance = convert_from_reference (instance);\n   basetype = TYPE_MAIN_VARIANT (TREE_TYPE (instance));\n   instance_ptr = build_this (instance);\n "}, {"sha": "886d301f1603377bcdb10f38c4ae29634d5f7ee5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -492,9 +492,6 @@ build_vfield_ref (tree datum, tree type)\n   if (datum == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (TREE_TYPE (datum)) == REFERENCE_TYPE)\n-    datum = convert_from_reference (datum);\n-\n   /* First, convert to the requested type.  */\n   if (!same_type_ignoring_top_level_qualifiers_p (TREE_TYPE (datum), type))\n     datum = convert_to_base (datum, type, /*check_access=*/false,"}, {"sha": "668aa68575495f8478d93736de8637490a000a2b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -48,6 +48,7 @@ struct diagnostic_context;\n       EXPR_STMT_STMT_EXPR_RESULT (in EXPR_STMT)\n       BIND_EXPR_TRY_BLOCK (in BIND_EXPR)\n       TYPENAME_IS_ENUM_P (in TYPENAME_TYPE)\n+      REFERENCE_REF_P (in INDIRECT_EXPR)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -483,9 +484,8 @@ enum cp_tree_index\n     CPTI_VTBL_PTR_TYPE,\n     CPTI_STD,\n     CPTI_ABI,\n-    CPTI_TYPE_INFO_TYPE,\n+    CPTI_CONST_TYPE_INFO_TYPE,\n     CPTI_TYPE_INFO_PTR_TYPE,\n-    CPTI_TYPE_INFO_REF_TYPE,\n     CPTI_ABORT_FNDECL,\n     CPTI_GLOBAL_DELETE_FNDECL,\n     CPTI_AGGR_TAG,\n@@ -561,9 +561,8 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n #define vtbl_ptr_type_node\t\tcp_global_trees[CPTI_VTBL_PTR_TYPE]\n #define std_node\t\t\tcp_global_trees[CPTI_STD]\n #define abi_node                        cp_global_trees[CPTI_ABI]\n-#define type_info_type_node\t\tcp_global_trees[CPTI_TYPE_INFO_TYPE]\n+#define const_type_info_type_node\tcp_global_trees[CPTI_CONST_TYPE_INFO_TYPE]\n #define type_info_ptr_type\t\tcp_global_trees[CPTI_TYPE_INFO_PTR_TYPE]\n-#define type_info_ref_type              cp_global_trees[CPTI_TYPE_INFO_REF_TYPE]\n #define abort_fndecl\t\t\tcp_global_trees[CPTI_ABORT_FNDECL]\n #define global_delete_fndecl\t\tcp_global_trees[CPTI_GLOBAL_DELETE_FNDECL]\n #define current_aggr\t\t\tcp_global_trees[CPTI_AGGR_TAG]\n@@ -2224,6 +2223,10 @@ struct lang_decl GTY(())\n   (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (NODE))\t\\\n    ->u.f.u.saved_language_function)\n \n+/* Indicates an indirect_expr is for converting a reference.  */\n+#define REFERENCE_REF_P(NODE) \\\n+  TREE_LANG_FLAG_0 (INDIRECT_REF_CHECK (NODE))\n+\n #define NEW_EXPR_USE_GLOBAL(NODE) \\\n   TREE_LANG_FLAG_0 (NEW_EXPR_CHECK (NODE))\n #define DELETE_EXPR_USE_GLOBAL(NODE) \\"}, {"sha": "7039bfe6fd0fc8b9f1fb2dd58c1567cb41b852db", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -451,8 +451,6 @@ convert_to_reference (tree reftype, tree expr, int convtype,\n     expr = instantiate_type (type, expr, \n \t\t\t     (flags & LOOKUP_COMPLAIN)\n \t\t\t     ? tf_error | tf_warning : tf_none);\n-  else\n-    expr = convert_from_reference (expr);\n \n   if (expr == error_mark_node)\n     return error_mark_node;\n@@ -553,7 +551,21 @@ tree\n convert_from_reference (tree val)\n {\n   if (TREE_CODE (TREE_TYPE (val)) == REFERENCE_TYPE)\n-    return build_indirect_ref (val, NULL);\n+    {\n+      tree t = canonical_type_variant (TREE_TYPE (TREE_TYPE (val)));\n+      tree ref = build1 (INDIRECT_REF, t, val);\n+      \n+       /* We *must* set TREE_READONLY when dereferencing a pointer to const,\n+\t  so that we get the proper error message if the result is used\n+\t  to assign to.  Also, &* is supposed to be a no-op.  */\n+      TREE_READONLY (ref) = CP_TYPE_CONST_P (t);\n+      TREE_THIS_VOLATILE (ref) = CP_TYPE_VOLATILE_P (t);\n+      TREE_SIDE_EFFECTS (ref)\n+\t= (TREE_THIS_VOLATILE (ref) || TREE_SIDE_EFFECTS (val));\n+      REFERENCE_REF_P (ref) = 1;\n+      val = ref;\n+    }\n+  \n   return val;\n }\n \n@@ -956,8 +968,6 @@ convert_force (tree type, tree expr, int convtype)\n     return (fold_if_not_in_template \n \t    (convert_to_reference (type, e, CONV_C_CAST, LOOKUP_COMPLAIN,\n \t\t\t\t   NULL_TREE)));\n-  else if (TREE_CODE (TREE_TYPE (e)) == REFERENCE_TYPE)\n-    e = convert_from_reference (e);\n \n   if (code == POINTER_TYPE)\n     return fold_if_not_in_template (convert_to_pointer_force (type, e));\n@@ -1012,7 +1022,6 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n       && !(desires & WANT_NULL))\n     warning (\"converting NULL to non-pointer type\");\n     \n-  expr = convert_from_reference (expr);\n   basetype = TREE_TYPE (expr);\n \n   if (basetype == error_mark_node)"}, {"sha": "22fcc7cda93aa5986e80bf61237df1542873fe64", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -3972,9 +3972,6 @@ grok_reference_init (tree decl, tree type, tree init, tree *cleanup)\n   if (TREE_CODE (init) == TREE_LIST)\n     init = build_x_compound_expr_from_list (init, \"initializer\");\n \n-  if (TREE_CODE (TREE_TYPE (init)) == REFERENCE_TYPE)\n-    init = convert_from_reference (init);\n-\n   if (TREE_CODE (TREE_TYPE (type)) != ARRAY_TYPE\n       && TREE_CODE (TREE_TYPE (init)) == ARRAY_TYPE)\n     /* Note: default conversion is only called in very special cases.  */"}, {"sha": "c7d28e502aedef0539c1ba3e13d2f244dc316b92", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -419,8 +419,6 @@ delete_sanity (tree exp, tree size, bool doing_vec, int use_global_delete)\n       return t;\n     }\n \n-  exp = convert_from_reference (exp);\n-\n   /* An array can't have been allocated by new, so complain.  */\n   if (TREE_CODE (exp) == VAR_DECL\n       && TREE_CODE (TREE_TYPE (exp)) == ARRAY_TYPE)"}, {"sha": "649fab79105d422dc4adb6a538a59cf81ee502a1", "filename": "gcc/cp/except.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -337,8 +337,7 @@ initialize_handler_parm (tree decl, tree exp)\n      adjusted by value from __cxa_begin_catch.  Others are returned by \n      reference.  */\n   init_type = TREE_TYPE (decl);\n-  if (! TYPE_PTR_P (init_type)\n-      && TREE_CODE (init_type) != REFERENCE_TYPE)\n+  if (!POINTER_TYPE_P (init_type))\n     init_type = build_reference_type (init_type);\n \n   choose_personality_routine (decl_is_java_type (init_type, 0)"}, {"sha": "95b57b2e8efb93b61b7e1caa93a46d88362019c2", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -2675,8 +2675,6 @@ build_dtor_call (tree exp, special_function_kind dtor_kind, int flags)\n     default:\n       gcc_unreachable ();\n     }\n-\n-  exp = convert_from_reference (exp);\n   fn = lookup_fnfields (TREE_TYPE (exp), name, /*protect=*/2);\n   return build_new_method_call (exp, fn, \n \t\t\t\t/*args=*/NULL_TREE,"}, {"sha": "dae68f36578e16025c9cb1cb8ddcd9702cfde462", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -8813,6 +8813,7 @@ cp_parser_template_argument (cp_parser* parser)\n       if (cp_parser_parse_definitely (parser))\n \treturn argument;\n     }\n+\n   /* If the next token is \"&\", the argument must be the address of an\n      object or function with external linkage.  */\n   address_p = cp_lexer_next_token_is (parser->lexer, CPP_AND);\n@@ -8835,6 +8836,12 @@ cp_parser_template_argument (cp_parser* parser)\n \tcp_parser_abort_tentative_parse (parser);\n       else\n \t{\n+\t  if (TREE_CODE (argument) == INDIRECT_REF)\n+\t    {\n+\t      gcc_assert (REFERENCE_REF_P (argument));\n+\t      argument = TREE_OPERAND (argument, 0);\n+\t    }\n+\t  \n \t  if (qualifying_class)\n \t    argument = finish_qualified_id_expr (qualifying_class,\n \t\t\t\t\t\t argument,\n@@ -8858,6 +8865,8 @@ cp_parser_template_argument (cp_parser* parser)\n \t\t       || TREE_CODE (argument) == SCOPE_REF))\n \t    /* A pointer-to-member.  */\n \t    ;\n+\t  else if (TREE_CODE (argument) == TEMPLATE_PARM_INDEX)\n+\t    ;\n \t  else\n \t    cp_parser_simulate_error (parser);\n \n@@ -8876,6 +8885,7 @@ cp_parser_template_argument (cp_parser* parser)\n       cp_parser_error (parser, \"invalid non-type template argument\");\n       return error_mark_node;\n     }\n+\n   /* If the argument wasn't successfully parsed as a type-id followed\n      by '>>', the argument can only be a constant expression now.\n      Otherwise, we try parsing the constant-expression tentatively,"}, {"sha": "6e34ba6926cf8a8e31ef3957c1a640ae0bb6cef1", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -8390,7 +8390,18 @@ tsubst_copy_and_build (tree t,\n       }\n \n     case INDIRECT_REF:\n-      return build_x_indirect_ref (RECUR (TREE_OPERAND (t, 0)), \"unary *\");\n+      {\n+\ttree r = RECUR (TREE_OPERAND (t, 0));\n+\n+\tif (REFERENCE_REF_P (t))\n+\t  {\n+\t    gcc_assert (TREE_CODE (TREE_TYPE (r)) == REFERENCE_TYPE);\n+\t    r = convert_from_reference (r);\n+\t  }\n+\telse\n+\t  r = build_x_indirect_ref (r, \"unary *\");\n+\treturn r;\n+      }\n \n     case NOP_EXPR:\n       return build_nop\n@@ -8626,8 +8637,6 @@ tsubst_copy_and_build (tree t,\n \tif (DECL_P (function))\n \t  mark_used (function);\n \n-\tfunction = convert_from_reference (function);\n-\n \tif (TREE_CODE (function) == OFFSET_REF)\n \t  return build_offset_ref_call_from_tree (function, call_args);\n \tif (TREE_CODE (function) == COMPONENT_REF)\n@@ -8815,13 +8824,21 @@ tsubst_copy_and_build (tree t,\n \treturn build_typeid (operand_0);\n       }\n \n-    case PARM_DECL:\n-      return convert_from_reference (tsubst_copy (t, args, complain, in_decl));\n-\n     case VAR_DECL:\n-      if (args)\n-\tt = tsubst_copy (t, args, complain, in_decl);\n-      return convert_from_reference (t);\n+      if (!args)\n+\treturn t;\n+      /* Fall through */\n+      \n+    case PARM_DECL:\n+      {\n+\ttree r = tsubst_copy (t, args, complain, in_decl);\n+\t\n+\tif (TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE)\n+\t  /* If the original type was a reference, we'll be wrapped in\n+\t     the appropriate INDIRECT_REF.  */\n+\t  r = convert_from_reference (r);\n+\treturn r;\n+      }\n \n     case VA_ARG_EXPR:\n       return build_x_va_arg (RECUR (TREE_OPERAND (t, 0)),\n@@ -11560,7 +11577,6 @@ tsubst_initializer_list (tree t, tree argvec)\n     {\n       tree decl;\n       tree init;\n-      tree val;\n \n       decl = tsubst_copy (TREE_PURPOSE (t), argvec, tf_error | tf_warning,\n \t\t\t  NULL_TREE);\n@@ -11570,14 +11586,6 @@ tsubst_initializer_list (tree t, tree argvec)\n       \n       init = tsubst_expr (TREE_VALUE (t), argvec, tf_error | tf_warning,\n \t\t\t  NULL_TREE);\n-      if (!init)\n-\t;\n-      else if (TREE_CODE (init) == TREE_LIST)\n-\tfor (val = init; val; val = TREE_CHAIN (val))\n-\t  TREE_VALUE (val) = convert_from_reference (TREE_VALUE (val));\n-      else if (init != void_type_node)\n-\tinit = convert_from_reference (init);\n-\n       in_base_initializer = 0;\n \n       if (decl)"}, {"sha": "c113e1c349d3750f38f8c64df1877fc8d0743a5e", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 21, "deletions": 27, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -108,17 +108,15 @@ static int doing_runtime = 0;\n void\n init_rtti_processing (void)\n {\n-  tree const_type_info_type;\n-\n+  tree type_info_type;\n+  \n   push_namespace (std_identifier);\n-  type_info_type_node \n-    = xref_tag (class_type, get_identifier (\"type_info\"),\n-\t\t/*tag_scope=*/ts_global, false);\n+  type_info_type = xref_tag (class_type, get_identifier (\"type_info\"),\n+\t\t\t     /*tag_scope=*/ts_global, false);\n   pop_namespace ();\n-  const_type_info_type = build_qualified_type (type_info_type_node, \n-\t\t\t\t\t       TYPE_QUAL_CONST);\n-  type_info_ptr_type = build_pointer_type (const_type_info_type);\n-  type_info_ref_type = build_reference_type (const_type_info_type);\n+  const_type_info_type_node\n+    = build_qualified_type (type_info_type, TYPE_QUAL_CONST);\n+  type_info_ptr_type = build_pointer_type (const_type_info_type_node);\n \n   unemitted_tinfo_decls = VEC_alloc (tree, 124);\n   \n@@ -182,12 +180,14 @@ throw_bad_typeid (void)\n   tree fn = get_identifier (\"__cxa_bad_typeid\");\n   if (!get_global_value_if_present (fn, &fn))\n     {\n-      tree t = build_qualified_type (type_info_type_node, TYPE_QUAL_CONST);\n-      t = build_function_type (build_reference_type (t), void_list_node);\n+      tree t;\n+\n+      t = build_reference_type (const_type_info_type_node);\n+      t = build_function_type (t, void_list_node);\n       fn = push_throw_library_fn (fn, t);\n     }\n \n-  return convert_from_reference (build_cxx_call (fn, NULL_TREE));\n+  return build_cxx_call (fn, NULL_TREE);\n }\n \f\n /* Return an lvalue expression whose type is \"const std::type_info\"\n@@ -244,7 +244,7 @@ typeid_ok_p (void)\n       return false;\n     }\n   \n-  if (!COMPLETE_TYPE_P (type_info_type_node))\n+  if (!COMPLETE_TYPE_P (const_type_info_type_node))\n     {\n       error (\"must #include <typeinfo> before using typeid\");\n       return false;\n@@ -266,7 +266,7 @@ build_typeid (tree exp)\n     return error_mark_node;\n \n   if (processing_template_decl)\n-    return build_min (TYPEID_EXPR, type_info_ref_type, exp);\n+    return build_min (TYPEID_EXPR, const_type_info_type_node, exp);\n \n   if (TREE_CODE (exp) == INDIRECT_REF\n       && TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == POINTER_TYPE\n@@ -390,7 +390,7 @@ get_typeid (tree type)\n     return error_mark_node;\n   \n   if (processing_template_decl)\n-    return build_min (TYPEID_EXPR, type_info_ref_type, type);\n+    return build_min (TYPEID_EXPR, const_type_info_type_node, type);\n \n   /* If the type of the type-id is a reference type, the result of the\n      typeid expression refers to a type_info object representing the\n@@ -441,6 +441,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n     case POINTER_TYPE:\n       if (TREE_CODE (TREE_TYPE (type)) == VOID_TYPE)\n \tbreak;\n+      /* Fall through.  */\n     case REFERENCE_TYPE:\n       if (! IS_AGGR_TYPE (TREE_TYPE (type)))\n \t{\n@@ -459,18 +460,6 @@ build_dynamic_cast_1 (tree type, tree expr)\n       goto fail;\n     }\n \n-  if (tc == POINTER_TYPE)\n-    expr = convert_from_reference (expr);\n-  else if (TREE_CODE (exprtype) != REFERENCE_TYPE)\n-    {\n-      /* Apply trivial conversion T -> T& for dereferenced ptrs.  */\n-      exprtype = build_reference_type (exprtype);\n-      expr = convert_to_reference (exprtype, expr, CONV_IMPLICIT,\n-\t\t\t\t   LOOKUP_NORMAL, NULL_TREE);\n-    }\n-\n-  exprtype = TREE_TYPE (expr);\n-\n   if (tc == POINTER_TYPE)\n     {\n       /* If T is a pointer type, v shall be an rvalue of a pointer to\n@@ -494,6 +483,11 @@ build_dynamic_cast_1 (tree type, tree expr)\n     }\n   else\n     {\n+      /* Apply trivial conversion T -> T& for dereferenced ptrs.  */\n+      exprtype = build_reference_type (exprtype);\n+      expr = convert_to_reference (exprtype, expr, CONV_IMPLICIT,\n+\t\t\t\t   LOOKUP_NORMAL, NULL_TREE);\n+\n       /* T is a reference type, v shall be an lvalue of a complete class\n \t type, and the result is an lvalue of the type referred to by T.  */\n "}, {"sha": "956bf04c1635ee34b2904742fb280bdd62d72e26", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -1505,7 +1505,6 @@ finish_stmt_expr_expr (tree expr, tree stmt_expr)\n \t      || TREE_CODE (type) == FUNCTION_TYPE)\n \t    expr = decay_conversion (expr);\n \n-\t  expr = convert_from_reference (expr);\n \t  expr = require_complete_type (expr);\n \n \t  type = TREE_TYPE (expr);\n@@ -2430,20 +2429,24 @@ finish_id_expression (tree id_expression,\n   if ((TREE_CODE (decl) == CONST_DECL && DECL_TEMPLATE_PARM_P (decl))\n       || TREE_CODE (decl) == TEMPLATE_PARM_INDEX)\n     {\n+      tree r;\n+      \n       *idk = CP_ID_KIND_NONE;\n       if (TREE_CODE (decl) == TEMPLATE_PARM_INDEX)\n \tdecl = TEMPLATE_PARM_DECL (decl);\n+      r = convert_from_reference (DECL_INITIAL (decl));\n+      \n       if (integral_constant_expression_p \n \t  && !dependent_type_p (TREE_TYPE (decl))\n-\t  && !INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (decl))) \n+\t  && !(INTEGRAL_OR_ENUMERATION_TYPE_P (TREE_TYPE (r))))\n \t{\n \t  if (!allow_non_integral_constant_expression_p)\n \t    error (\"template parameter %qD of type %qT is not allowed in \"\n \t\t   \"an integral constant expression because it is not of \"\n \t\t   \"integral or enumeration type\", decl, TREE_TYPE (decl));\n \t  *non_integral_constant_expression_p = true;\n \t}\n-      return DECL_INITIAL (decl);\n+      return r;\n     }\n   /* Similarly, we resolve enumeration constants to their \n      underlying values.  */\n@@ -2550,10 +2553,10 @@ finish_id_expression (tree id_expression,\n \t      if (TYPE_P (scope) && dependent_type_p (scope))\n \t\treturn build_nt (SCOPE_REF, scope, id_expression);\n \t      else if (TYPE_P (scope) && DECL_P (decl))\n-\t\treturn build2 (SCOPE_REF, TREE_TYPE (decl), scope,\n-\t\t\t       id_expression);\n+\t\treturn convert_from_reference\n+\t\t  (build2 (SCOPE_REF, TREE_TYPE (decl), scope, id_expression));\n \t      else\n-\t\treturn decl;\n+\t\treturn convert_from_reference (decl);\n \t    }\n \t  /* A TEMPLATE_ID already contains all the information we\n \t     need.  */\n@@ -2570,7 +2573,7 @@ finish_id_expression (tree id_expression,\n \t     (or an instantiation thereof).  */\n \t  if (TREE_CODE (decl) == VAR_DECL\n \t      || TREE_CODE (decl) == PARM_DECL)\n-\t    return decl;\n+\t    return convert_from_reference (decl);\n \t  /* The same is true for FIELD_DECL, but we also need to\n \t     make sure that the syntax is correct.  */\n \t  else if (TREE_CODE (decl) == FIELD_DECL)\n@@ -2581,8 +2584,8 @@ finish_id_expression (tree id_expression,\n \t}\n \n       /* Only certain kinds of names are allowed in constant\n-       expression.  Enumerators and template parameters \n-       have already been handled above.  */\n+         expression.  Enumerators and template parameters have already\n+         been handled above.  */\n       if (integral_constant_expression_p\n \t  && !DECL_INTEGRAL_CONSTANT_VAR_P (decl))\n \t{\n@@ -2630,10 +2633,15 @@ finish_id_expression (tree id_expression,\n \n \t  if (TREE_CODE (decl) == FIELD_DECL || BASELINK_P (decl))\n \t    *qualifying_class = scope;\n-\t  else if (!processing_template_decl)\n-\t    decl = convert_from_reference (decl);\n-\t  else if (TYPE_P (scope))\n-\t    decl = build2 (SCOPE_REF, TREE_TYPE (decl), scope, decl);\n+\t  else\n+\t    {\n+\t      tree r = convert_from_reference (decl);\n+\t      \n+\t      if (processing_template_decl\n+\t\t  && TYPE_P (scope))\n+\t\tr = build2 (SCOPE_REF, TREE_TYPE (r), scope, decl);\n+\t      decl = r;\n+\t    }\n \t}\n       else if (TREE_CODE (decl) == FIELD_DECL)\n \tdecl = finish_non_static_data_member (decl, current_class_ref,\n@@ -2686,8 +2694,7 @@ finish_id_expression (tree id_expression,\n \t      perform_or_defer_access_check (TYPE_BINFO (path), decl);\n \t    }\n \t  \n-\t  if (! processing_template_decl)\n-\t    decl = convert_from_reference (decl);\n+\t  decl = convert_from_reference (decl);\n \t}\n       \n       /* Resolve references to variables of anonymous unions"}, {"sha": "a06101c42f00a2311c761b40afd1a6c1dff26b8a", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -1343,13 +1343,6 @@ decay_conversion (tree exp)\n   type = TREE_TYPE (exp);\n   code = TREE_CODE (type);\n \n-  if (code == REFERENCE_TYPE)\n-    {\n-      exp = convert_from_reference (exp);\n-      type = TREE_TYPE (exp);\n-      code = TREE_CODE (type);\n-    }\n-\n   if (type == error_mark_node)\n     return error_mark_node;\n \n@@ -1905,12 +1898,6 @@ finish_class_member_access_expr (tree object, tree name)\n       object = build_non_dependent_expr (object);\n     }\n   \n-  if (TREE_CODE (object_type) == REFERENCE_TYPE)\n-    {\n-      object = convert_from_reference (object);\n-      object_type = TREE_TYPE (object);\n-    }\n-\n   /* [expr.ref]\n \n      The type of the first expression shall be \"class object\" (of a\n@@ -2102,7 +2089,7 @@ build_indirect_ref (tree ptr, const char *errorstring)\n \t     ? ptr : decay_conversion (ptr));\n   type = TREE_TYPE (pointer);\n \n-  if (TYPE_PTR_P (type) || TREE_CODE (type) == REFERENCE_TYPE)\n+  if (POINTER_TYPE_P (type))\n     {\n       /* [expr.unary.op]\n \t \n@@ -2627,9 +2614,6 @@ convert_arguments (tree typelist, tree values, tree fndecl, int flags)\n \t}\n       else\n \t{\n-\t  if (TREE_CODE (TREE_TYPE (val)) == REFERENCE_TYPE)\n-\t    val = convert_from_reference (val);\n-\n \t  if (fndecl && DECL_BUILT_IN (fndecl)\n \t      && DECL_FUNCTION_CODE (fndecl) == BUILT_IN_CONSTANT_P)\n \t    /* Don't do ellipsis conversion for __built_in_constant_p\n@@ -5372,11 +5356,6 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n     }\n   else\n     {\n-      if (TREE_CODE (lhstype) == REFERENCE_TYPE)\n-\t{\n-\t  lhs = convert_from_reference (lhs);\n-\t  olhstype = lhstype = TREE_TYPE (lhs);\n-\t}\n       lhs = require_complete_type (lhs);\n       if (lhs == error_mark_node)\n \treturn error_mark_node;\n@@ -6025,9 +6004,6 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n       || (TREE_CODE (rhs) == TREE_LIST && TREE_VALUE (rhs) == error_mark_node))\n     return error_mark_node;\n \n-  if (TREE_CODE (TREE_TYPE (rhs)) == REFERENCE_TYPE)\n-    rhs = convert_from_reference (rhs);\n-\n   if ((TREE_CODE (TREE_TYPE (rhs)) == ARRAY_TYPE\n        && TREE_CODE (type) != ARRAY_TYPE\n        && (TREE_CODE (type) != REFERENCE_TYPE"}, {"sha": "8d97e451c6deaf2742f6a8f8c505dd994d64cd11", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -1212,12 +1212,6 @@ build_x_arrow (tree expr)\n       expr = build_non_dependent_expr (expr);\n     }\n \n-  if (TREE_CODE (type) == REFERENCE_TYPE)\n-    {\n-      expr = convert_from_reference (expr);\n-      type = TREE_TYPE (expr);\n-    }\n-\n   if (IS_AGGR_TYPE (type))\n     {\n       while ((expr = build_new_op (COMPONENT_REF, LOOKUP_NORMAL, expr,"}, {"sha": "eac55dfa82dcbc4f9c485141f5913bec91867fd8", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -1,3 +1,8 @@\n+2004-12-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/18803\n+\t* g++.dg/template/operator5.C: New.\n+\n 2004-12-08  Hans-Peter Nilsson  <hp@bitrange.com>\n \n \tPR c/18867"}, {"sha": "1c0c29231914b0c746017111fb60c2830e76eb75", "filename": "gcc/testsuite/g++.dg/template/operator5.C", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db24eb1f4fcc6fa8330376179278261e02b717b5/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Foperator5.C?ref=db24eb1f4fcc6fa8330376179278261e02b717b5", "patch": "@@ -0,0 +1,14 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 7 Dec 2004 <nathan@codesourcery.com>\n+\n+// PR 18803: reject legal\n+// Origin: Wolfgang Bangerth <bangerth@dealii.org>\n+\n+struct A { \n+  int operator() (); \n+}; \n+ \n+template <int> void foo () { \n+  A &a = *new A(); \n+  const int i = a(); \n+} "}]}