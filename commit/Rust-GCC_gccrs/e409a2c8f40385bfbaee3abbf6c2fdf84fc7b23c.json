{"sha": "e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQwOWEyYzhmNDAzODViZmJhZWUzYWJiZjZjMmZkZjg0ZmM3YjIzYw==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "1999-09-01T22:02:20Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "1999-09-01T22:02:20Z"}, "message": "Modifier.java (ALL_FLAGS): New constant.\n\n\t* java/lang/reflect/Modifier.java (ALL_FLAGS): New constant.\n\t* resolve.cc: Removed constants defined by\n\tjava.lang.reflect.Modifier.\n\tInclude <java/lang/reflect/Modifier.h>.\n\t(_Jv_ResolvePoolEntry): Use values from Modifier.\n\t(_Jv_DetermineVTableIndex): Likewise.\n\t(_Jv_PrepareClass): Likewise.\n\t(ncode): Likewise.\n\t* defineclass.cc (_Jv_ClassReader): Removed constants defined by\n\tjava.lang.reflect.Modifier.\n\tInclude <java/lang/reflect/Modifier.h>.\n\t(checkExtends): Use values from Modifier.\n\t(checkImplements): Likewise.\n\t(handleField): Likewise.\n\t(handleConstantValueAttribute): Likewise.\n\t(handleFieldsEnd): Likewise.\n\t(handleMethod ): Likewise.\n\t(handleMethodsEnd): Likewise.\n\t(handleClassBegin): Likewise.\n\t* interpret.cc: Removed constants defined by\n\tjava.lang.reflect.Modifier.\n\t(continue1): Use values from Modifier.\n\t* java/lang/natClassLoader.cc: Removed constants defined by\n\tjava.lang.reflect.Modifier.\n\nFrom-SVN: r29037", "tree": {"sha": "938e916f1eee2f10d36f75b0391a97ffba828a5b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/938e916f1eee2f10d36f75b0391a97ffba828a5b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/comments", "author": null, "committer": null, "parents": [{"sha": "c7f9c6f5e30e4bc6e6b1baa083f76edb8cec2403", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7f9c6f5e30e4bc6e6b1baa083f76edb8cec2403", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7f9c6f5e30e4bc6e6b1baa083f76edb8cec2403"}], "stats": {"total": 227, "additions": 122, "deletions": 105}, "files": [{"sha": "59f7e94aa6ccf527ee0c3fa20318e1c0b082d855", "filename": "libjava/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c", "patch": "@@ -1,5 +1,30 @@\n 1999-09-01  Tom Tromey  <tromey@cygnus.com>\n \n+\t* java/lang/reflect/Modifier.java (ALL_FLAGS): New constant.\n+\t* resolve.cc: Removed constants defined by\n+\tjava.lang.reflect.Modifier.\n+\tInclude <java/lang/reflect/Modifier.h>.\n+\t(_Jv_ResolvePoolEntry): Use values from Modifier.\n+\t(_Jv_DetermineVTableIndex): Likewise.\n+\t(_Jv_PrepareClass): Likewise.\n+\t(ncode): Likewise.\n+\t* defineclass.cc (_Jv_ClassReader): Removed constants defined by\n+\tjava.lang.reflect.Modifier.\n+\tInclude <java/lang/reflect/Modifier.h>.\n+\t(checkExtends): Use values from Modifier.\n+\t(checkImplements): Likewise.\n+\t(handleField): Likewise.\n+\t(handleConstantValueAttribute): Likewise.\n+\t(handleFieldsEnd): Likewise.\n+\t(handleMethod ): Likewise.\n+\t(handleMethodsEnd): Likewise.\n+\t(handleClassBegin): Likewise.\n+\t* interpret.cc: Removed constants defined by\n+\tjava.lang.reflect.Modifier.\n+\t(continue1): Use values from Modifier.\n+\t* java/lang/natClassLoader.cc: Removed constants defined by\n+\tjava.lang.reflect.Modifier.\n+\n \t* java/lang/natClassLoader.cc (_Jv_NewClass): Use\n \tJV_STATE_NOTHING, not `0'.\n \t* java/lang/Class.h: Replaced JV_STATE_ defines with enum."}, {"sha": "d1b2be046d744be1040aa1142d4e35ff49cd46d5", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 44, "deletions": 34, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c", "patch": "@@ -36,6 +36,7 @@ details.  */\n #include <java/lang/ClassCircularityError.h>\n #include <java/lang/ClassNotFoundException.h>\n #include <java/lang/IncompatibleClassChangeError.h>\n+#include <java/lang/reflect/Modifier.h>\n \n #define ClassClass _CL_Q34java4lang5Class\n extern java::lang::Class ClassClass;\n@@ -246,20 +247,6 @@ struct _Jv_ClassReader {\n    * could be implemented in prims.cc (_Jv_makeUtf8Const), since it\n    * computes the hash value anyway.\n    */\n-\n-  static const int PUBLIC       = 0x001;\n-  static const int PRIVATE      = 0x002;\n-  static const int PROTECTED    = 0x004;\n-  static const int STATIC       = 0x008;\n-  static const int FINAL        = 0x010;\n-  static const int SYNCHRONIZED = 0x020;\n-  static const int VOLATILE     = 0x040;\n-  static const int TRANSIENT    = 0x080;\n-  static const int NATIVE       = 0x100;\n-  static const int INTERFACE    = 0x200;\n-  static const int ABSTRACT     = 0x400;\n-  static const int ALL_FLAGS    = 0x7FF; \n-\n };\n \n /* This is used for the isJavaIdentifierStart & isJavaIdentifierPart\n@@ -825,6 +812,8 @@ void\n _Jv_ClassReader::handleClassBegin\n   (int access_flags, int this_class, int super_class)\n {\n+  using namespace java::lang::reflect;\n+\n   unsigned char *pool_tags = (unsigned char*) def->constants.tags;\n   _Jv_word      *pool_data = def->constants.data;\n \n@@ -870,7 +859,7 @@ _Jv_ClassReader::handleClassBegin\n   if (super_class == 0)\n     {\n       // interfaces have java.lang.Object as super.\n-      if (access_flags & INTERFACE)\n+      if (access_flags & Modifier::INTERFACE)\n \t{\n \t  def->superclass = (jclass)&ClassObject;\n \t}\n@@ -919,14 +908,16 @@ _Jv_ClassReader::handleClassBegin\n void\n _Jv_ClassReader::checkExtends (jclass sub, jclass super)\n {\n+  using namespace java::lang::reflect;\n+\n   // having an interface or a final class as a superclass is no good\n-  if ((super->accflags & (INTERFACE | FINAL)) != 0)\n+  if ((super->accflags & (Modifier::INTERFACE | Modifier::FINAL)) != 0)\n     {\n       throw_incompatible_class_change_error (sub->getName ());\n     }\n \n   // if the super class is not public, we need to check some more\n-  if ((super->accflags & PUBLIC) == 0)\n+  if ((super->accflags & Modifier::PUBLIC) == 0)\n     {\n       // With package scope, the classes must have the same\n       // class loader.\n@@ -986,15 +977,17 @@ void _Jv_ClassReader::handleInterface (int if_number, int offset)\n void\n _Jv_ClassReader::checkImplements (jclass sub, jclass super)\n {\n+  using namespace java::lang::reflect;\n+\n   // well, it *must* be an interface\n-  if ((super->accflags & INTERFACE) == 0)\n+  if ((super->accflags & Modifier::INTERFACE) == 0)\n     {\n       throw_incompatible_class_change_error (sub->getName ());\n     }\n \n   // if it has package scope, it must also be defined by the \n   // same loader.\n-  if ((super->accflags & PUBLIC) == 0)\n+  if ((super->accflags & Modifier::PUBLIC) == 0)\n     {\n       if (    sub->loader != super->loader\n \t  || !_Jv_ClassNameSamePackage (sub->name, super->name))\n@@ -1026,6 +1019,8 @@ void _Jv_ClassReader::handleField (int field_no,\n \t\t\t\t   int name,\n \t\t\t\t   int desc)\n {\n+  using namespace java::lang::reflect;\n+\n   _Jv_word *pool_data = def->constants.data;\n \n   _Jv_Field *field = &def->fields[field_no];\n@@ -1041,16 +1036,19 @@ void _Jv_ClassReader::handleField (int field_no,\n     _Jv_VerifyIdentifier (field_name);\n \n   // ignore flags we don't know about.  \n-  field->flags = flags & ALL_FLAGS;\n+  field->flags = flags & Modifier::ALL_FLAGS;\n \n   if (verify)\n     {\n-      if (field->flags & (SYNCHRONIZED|NATIVE|INTERFACE|ABSTRACT))\n+      if (field->flags & (Modifier::SYNCHRONIZED\n+\t\t\t  | Modifier::NATIVE\n+\t\t\t  | Modifier::INTERFACE\n+\t\t\t  | Modifier::ABSTRACT))\n \tthrow_class_format_error (\"erroneous field access flags\");\n       \n-      if (1 < ( ((field->flags & PUBLIC) ? 1 : 0)\n-\t\t+((field->flags & PRIVATE) ? 1 : 0)\n-\t\t+((field->flags & PROTECTED) ? 1 : 0)))\n+      if (1 < ( ((field->flags & Modifier::PUBLIC) ? 1 : 0)\n+\t\t+((field->flags & Modifier::PRIVATE) ? 1 : 0)\n+\t\t+((field->flags & Modifier::PROTECTED) ? 1 : 0)))\n \tthrow_class_format_error (\"erroneous field access flags\");\n     }\n \n@@ -1070,9 +1068,13 @@ void _Jv_ClassReader::handleField (int field_no,\n void _Jv_ClassReader::handleConstantValueAttribute (int field_index, \n \t\t\t\t\t\t    int value)\n {\n+  using namespace java::lang::reflect;\n+\n   _Jv_Field *field = &def->fields[field_index];\n \n-  if ((field->flags & (STATIC|FINAL|PRIVATE)) == 0)\n+  if ((field->flags & (Modifier::STATIC\n+\t\t       | Modifier::FINAL\n+\t\t       | Modifier::PRIVATE)) == 0)\n     {\n       // Ignore, as per vmspec #4.7.2\n       return;\n@@ -1095,6 +1097,8 @@ void _Jv_ClassReader::handleConstantValueAttribute (int field_index,\n \n void _Jv_ClassReader::handleFieldsEnd ()\n {\n+  using namespace java::lang::reflect;\n+\n   // We need to reorganize the fields so that the static ones are first,\n   // to conform to GCJ class layout.\n \n@@ -1107,11 +1111,11 @@ void _Jv_ClassReader::handleFieldsEnd ()\n   while (low < high)\n     {\n       // go forward on low, while it's a static\n-      while (low < high && (fields[low].flags & STATIC) != 0)\n+      while (low < high && (fields[low].flags & Modifier::STATIC) != 0)\n \tlow++;\n       \n       // go backwards on high, while it's a non-static\n-      while (low < high && (fields[high].flags & STATIC) == 0)\n+      while (low < high && (fields[high].flags & Modifier::STATIC) == 0)\n \thigh--;\n \n       if (low==high)\n@@ -1130,7 +1134,7 @@ void _Jv_ClassReader::handleFieldsEnd ()\n       low  += 1;\n     }\n   \n-  if ((fields[low].flags & STATIC) != 0) \n+  if ((fields[low].flags & Modifier::STATIC) != 0) \n     low += 1;\n \n   def->static_field_count = low;\n@@ -1156,6 +1160,8 @@ void _Jv_ClassReader::handleMethodsBegin (int count)\n void _Jv_ClassReader::handleMethod \n     (int mth_index, int accflags, int name, int desc)\n { \n+  using namespace java::lang::reflect;\n+\n   _Jv_word *pool_data = def->constants.data;\n   _Jv_Method *method = &def->methods[mth_index];\n \n@@ -1168,7 +1174,7 @@ void _Jv_ClassReader::handleMethod\n   method->signature = pool_data[desc].utf8;\n \n   // ignore unknown flags\n-  method->accflags = accflags & ALL_FLAGS;\n+  method->accflags = accflags & Modifier::ALL_FLAGS;\n \n   // intialize...\n   method->ncode = 0;\n@@ -1183,12 +1189,14 @@ void _Jv_ClassReader::handleMethod\n \n       _Jv_VerifyMethodSignature (method->signature);\n \n-      if (method->accflags & (VOLATILE|TRANSIENT|INTERFACE))\n+      if (method->accflags & (Modifier::VOLATILE\n+\t\t\t      | Modifier::TRANSIENT\n+\t\t\t      | Modifier::INTERFACE))\n \tthrow_class_format_error (\"erroneous method access flags\");\n       \n-      if (1 < ( ((method->accflags & PUBLIC) ? 1 : 0)\n-\t\t+((method->accflags & PRIVATE) ? 1 : 0)\n-\t\t+((method->accflags & PROTECTED) ? 1 : 0)))\n+      if (1 < ( ((method->accflags & Modifier::PUBLIC) ? 1 : 0)\n+\t\t+((method->accflags & Modifier::PRIVATE) ? 1 : 0)\n+\t\t+((method->accflags & Modifier::PROTECTED) ? 1 : 0)))\n \tthrow_class_format_error (\"erroneous method access flags\");\n     }\n }\n@@ -1233,10 +1241,12 @@ void _Jv_ClassReader::handleExceptionTableEntry\n \n void _Jv_ClassReader::handleMethodsEnd ()\n {\n+  using namespace java::lang::reflect;\n+\n   for (int i = 0; i < def->method_count; i++)\n     {\n       _Jv_Method *method = &def->methods[i];\n-      if (method->accflags & (NATIVE|ABSTRACT))\n+      if (method->accflags & (Modifier::NATIVE | Modifier::ABSTRACT))\n \t{\n \t  if (def->interpreted_methods[i] != 0)\n \t    throw_class_format_error (\"code provided \""}, {"sha": "ca38d3ba0af34dc34b9259df69d9fdb15d98bfda", "filename": "libjava/interpret.cc", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2Finterpret.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2Finterpret.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finterpret.cc?ref=e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c", "patch": "@@ -53,19 +53,6 @@ gnu::gcj::runtime::MethodInvocation::continue1 (gnu::gcj::RawData *,\n #define ClassError _CL_Q34java4lang5Error\n extern java::lang::Class ClassError;\n \n-static const int PUBLIC       = 0x001;\n-static const int PRIVATE      = 0x002;\n-static const int PROTECTED    = 0x004;\n-static const int STATIC       = 0x008;\n-static const int FINAL        = 0x010;\n-static const int SYNCHRONIZED = 0x020;\n-static const int VOLATILE     = 0x040;\n-static const int TRANSIENT    = 0x080;\n-static const int NATIVE       = 0x100;\n-static const int INTERFACE    = 0x200;\n-static const int ABSTRACT     = 0x400;\n-static const int ALL_FLAGS    = 0x7FF; \n-\n static _Jv_Utf8Const *init_name = _Jv_makeUtf8Const (\"<init>\", 6);\n \n static void throw_internal_error (char *msg)\n@@ -426,6 +413,8 @@ gnu::gcj::runtime::MethodInvocation::continue1 (gnu::gcj::RawData *meth,\n \n void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n {\n+  using namespace java::lang::reflect;\n+\n   register _Jv_word      *sp                  = inv->sp;\n   register unsigned char *pc PC_REGISTER_ASM  = inv->pc;\n   _Jv_word               *locals              = inv->local_base ();\n@@ -2001,7 +1990,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \n-\tif ((field->flags & STATIC) == 0)\n+\tif ((field->flags & Modifier::STATIC) == 0)\n \t  throw_incompatible_class_change_error \n \t    (JvNewStringLatin1 (\"field no longer static\"));\n \n@@ -2048,7 +2037,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \t_Jv_ResolvePoolEntry (defining_class, fieldref_index);\n \t_Jv_Field *field = pool_data[fieldref_index].field;\n \n-\tif ((field->flags & STATIC) != 0)\n+\tif ((field->flags & Modifier::STATIC) != 0)\n \t  throw_incompatible_class_change_error \n \t    (JvNewStringLatin1 (\"field is static\"));\n \n@@ -2104,7 +2093,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \tjclass type = field->type;\n \n \t// ResolvePoolEntry cannot check this\n-\tif ((field->flags & STATIC) == 0)\n+\tif ((field->flags & Modifier::STATIC) == 0)\n \t  throw_incompatible_class_change_error \n \t    (JvNewStringLatin1 (\"field no longer static\"));\n \n@@ -2153,7 +2142,7 @@ void _Jv_InterpMethod::continue1 (_Jv_InterpMethodInvocation *inv)\n \n \tjclass type = field->type;\n \n-\tif ((field->flags & STATIC) != 0)\n+\tif ((field->flags & Modifier::STATIC) != 0)\n \t  throw_incompatible_class_change_error \n \t    (JvNewStringLatin1 (\"field is static\"));\n "}, {"sha": "4172a44e263ed5c576ff977afdfe274250acb9c3", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c", "patch": "@@ -205,19 +205,6 @@ java::lang::ClassLoader::findLoadedClass (jstring name)\n   return _Jv_FindClassInCache (_Jv_makeUtf8Const (name), this);\n }\n \n-static const int PUBLIC       = 0x001;\n-static const int PRIVATE      = 0x002;\n-static const int PROTECTED    = 0x004;\n-static const int STATIC       = 0x008;\n-static const int FINAL        = 0x010;\n-static const int SYNCHRONIZED = 0x020;\n-static const int VOLATILE     = 0x040;\n-static const int TRANSIENT    = 0x080;\n-static const int NATIVE       = 0x100;\n-static const int INTERFACE    = 0x200;\n-static const int ABSTRACT     = 0x400;\n-static const int ALL_FLAGS    = 0x7FF; \n-\n \n /** This function does class-preparation for compiled classes.  \n     NOTE: It contains replicated functionality from"}, {"sha": "51285318df78e4d88cc956d609e993b49a70a27e", "filename": "libjava/java/lang/reflect/Modifier.java", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2Fjava%2Flang%2Freflect%2FModifier.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2Fjava%2Flang%2Freflect%2FModifier.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2Freflect%2FModifier.java?ref=e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c", "patch": "@@ -35,6 +35,9 @@\n   public static final int INTERFACE = 0x200;\n   public static final int ABSTRACT  = 0x400;\n \n+  // This is only used by the C++ code, so it is not public.\n+  static final int ALL_FLAGS = 0x7ff;\n+\n   public static boolean isAbstract (int mod)\n   {\n     return (mod & ABSTRACT) != 0;"}, {"sha": "f13dff68d2cf9845dfb0e66c3740f7d26d39ecde", "filename": "libjava/resolve.cc", "status": "modified", "additions": 44, "deletions": 41, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2Fresolve.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c/libjava%2Fresolve.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fresolve.cc?ref=e409a2c8f40385bfbaee3abbf6c2fdf84fc7b23c", "patch": "@@ -27,6 +27,7 @@ details.  */\n #include <java/lang/AbstractMethodError.h>\n #include <java/lang/ClassNotFoundException.h>\n #include <java/lang/IncompatibleClassChangeError.h>\n+#include <java/lang/reflect/Modifier.h>\n \n #ifdef INTERPRETER\n \n@@ -54,19 +55,6 @@ _Jv_BuildResolvedMethod (_Jv_Method*,\n \t\t\t jint);\n \n \n-static const int PUBLIC       = 0x001;\n-static const int PRIVATE      = 0x002;\n-static const int PROTECTED    = 0x004;\n-static const int STATIC       = 0x008;\n-static const int FINAL        = 0x010;\n-static const int SYNCHRONIZED = 0x020;\n-static const int VOLATILE     = 0x040;\n-static const int TRANSIENT    = 0x080;\n-static const int NATIVE       = 0x100;\n-static const int INTERFACE    = 0x200;\n-static const int ABSTRACT     = 0x400;\n-static const int ALL_FLAGS    = 0x7FF; \n-\n // We need to know the name of a constructor.\n static _Jv_Utf8Const *init_name = _Jv_makeUtf8Const (\"<init>\", 6);\n \n@@ -78,6 +66,8 @@ static void throw_incompatible_class_change_error (jstring msg)\n _Jv_word\n _Jv_ResolvePoolEntry (jclass klass, int index)\n {\n+  using namespace java::lang::reflect;\n+\n   _Jv_Constants *pool = &klass->constants;\n \n   if ((pool->tags[index] & JV_CONSTANT_ResolvedFlag) != 0)\n@@ -101,7 +91,7 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n \t  JvThrow (new java::lang::ClassNotFoundException (str));\n \t}\n \n-      if ((found->accflags & PUBLIC) == PUBLIC\n+      if ((found->accflags & Modifier::PUBLIC) == Modifier::PUBLIC\n \t  || (_Jv_ClassNameSamePackage (found->name,\n \t\t\t\t\tklass->name)))\n \t{\n@@ -171,10 +161,10 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n \t      // now, check field access. \n \n \t      if (   (cls == klass)\n-\t\t  || ((field->flags & PUBLIC) != 0)\n-\t\t  || (((field->flags & PROTECTED) != 0)\n+\t\t  || ((field->flags & Modifier::PUBLIC) != 0)\n+\t\t  || (((field->flags & Modifier::PROTECTED) != 0)\n \t\t      && cls->isAssignableFrom (klass))\n-\t\t  || (((field->flags & PRIVATE) == 0)\n+\t\t  || (((field->flags & Modifier::PRIVATE) == 0)\n \t\t      && _Jv_ClassNameSamePackage (cls->name,\n \t\t\t\t\t\t   klass->name)))\n \t\t{\n@@ -255,10 +245,10 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n \t\tcontinue;\n \n \t      if (cls == klass \n-\t\t  || ((method->accflags & PUBLIC) != 0)\n-\t\t  || (((method->accflags & PROTECTED) != 0)\n+\t\t  || ((method->accflags & Modifier::PUBLIC) != 0)\n+\t\t  || (((method->accflags & Modifier::PROTECTED) != 0)\n \t\t      && cls->isAssignableFrom (klass))\n-\t\t  || (((method->accflags & PRIVATE) == 0)\n+\t\t  || (((method->accflags & Modifier::PRIVATE) == 0)\n \t\t      && _Jv_ClassNameSamePackage (cls->name,\n \t\t\t\t\t\t   klass->name)))\n \t\t{\n@@ -306,7 +296,7 @@ _Jv_ResolvePoolEntry (jclass klass, int index)\n       pool->data[index].rmethod = \n \t_Jv_BuildResolvedMethod(the_method,\n \t\t\t\tfound_class,\n-\t\t\t\t((the_method->accflags & STATIC) != 0),\n+\t\t\t\t(the_method->accflags & Modifier::STATIC) != 0,\n \t\t\t\tvtable_index);\n       pool->tags[index] |= JV_CONSTANT_ResolvedFlag;\n     }\n@@ -357,6 +347,8 @@ _Jv_DetermineVTableIndex (jclass klass,\n \t\t\t  _Jv_Utf8Const *name,\n \t\t\t  _Jv_Utf8Const *signature)\n {\n+  using namespace java::lang::reflect;\n+\n   jclass super_class = klass->getSuperclass ();\n \n   if (super_class != NULL)\n@@ -390,8 +382,10 @@ _Jv_DetermineVTableIndex (jclass klass,\n    * 3) it is the method <init>\n    */\n \n-  if (   (meth->accflags & (STATIC|PRIVATE|FINAL)) != 0\n-      || (klass->accflags & FINAL) != 0\n+  if ((meth->accflags & (Modifier::STATIC\n+\t\t\t | Modifier::PRIVATE\n+\t\t\t | Modifier::FINAL)) != 0\n+      || (klass->accflags & Modifier::FINAL) != 0\n       || _Jv_equalUtf8Consts (name, init_name))\n     return -1;\n \n@@ -422,7 +416,7 @@ _Jv_DetermineVTableIndex (jclass klass,\n       /* fist some checks for things that surely do not go in the\n        * vtable */\n \n-      if ((m->accflags & (STATIC|PRIVATE)) != 0)\n+      if ((m->accflags & (Modifier::STATIC | Modifier::PRIVATE)) != 0)\n \tcontinue;\n       if (_Jv_equalUtf8Consts (m->name, init_name))\n \tcontinue;\n@@ -439,7 +433,7 @@ _Jv_DetermineVTableIndex (jclass klass,\n \n       /* but if it is final, and not declared in the super class,\n        * then we also skip it */\n-      if ((m->accflags & FINAL) != 0)\n+      if ((m->accflags & Modifier::FINAL) != 0)\n \tcontinue;\n \n       /* finally, we can assign the index of this method */\n@@ -460,6 +454,8 @@ _Jv_abstractMethodError ()\n void \n _Jv_PrepareClass(jclass klass)\n {\n+  using namespace java::lang::reflect;\n+\n  /*\n   * The job of this function is to: 1) assign storage to fields, and 2)\n   * build the vtable.  static fields are assigned real memory, instance\n@@ -527,7 +523,7 @@ _Jv_PrepareClass(jclass klass)\n       field->bsize = field_size;\n #endif\n \n-      if (field->flags & STATIC)\n+      if (field->flags & Modifier::STATIC)\n \t{\n \t  /* this computes an offset into a region we'll allocate \n \t     shortly, and then add this offset to the start address */\n@@ -558,7 +554,7 @@ _Jv_PrepareClass(jclass klass)\n \t{\n \t  _Jv_Field *field = &clz->fields[i];\n \n-\t  if ((field->flags & STATIC) != 0)\n+\t  if ((field->flags & Modifier::STATIC) != 0)\n \t    {\n \t      field->u.addr  = static_data + field->u.boffset;\n \t\t\t    \n@@ -590,7 +586,7 @@ _Jv_PrepareClass(jclass klass)\n \t}\n       else\n \t{\n-\t  if ((clz->methods[i].accflags & NATIVE) != 0)\n+\t  if ((clz->methods[i].accflags & Modifier::NATIVE) != 0)\n \t    {\n \t      JvThrow\n \t\t(new java::lang::VirtualMachineError\n@@ -600,7 +596,7 @@ _Jv_PrepareClass(jclass klass)\n \t}\n     }\n \n-  if (clz->accflags & INTERFACE)\n+  if (clz->accflags & Modifier::INTERFACE)\n     {\n       clz->state = JV_STATE_PREPARED;\n       clz->notifyAll ();\n@@ -627,7 +623,7 @@ _Jv_PrepareClass(jclass klass)\n     {\n       _Jv_Method *this_meth = &clz->methods[i];\n \n-      if ((this_meth->accflags & (STATIC|PRIVATE)) != 0\n+      if ((this_meth->accflags & (Modifier::STATIC | Modifier::PRIVATE)) != 0\n \t  || _Jv_equalUtf8Consts (this_meth->name, init_name))\n \t{\n \t  /* skip this, it doesn't go in the vtable */\n@@ -641,17 +637,19 @@ _Jv_PrepareClass(jclass klass)\n       if (orig_meth == 0)\n \t{\n \t  // new methods that are final, also don't go in the vtable\n-\t  if ((this_meth->accflags & FINAL) != 0)\n+\t  if ((this_meth->accflags & Modifier::FINAL) != 0)\n \t    continue;\n \n \t  new_method_count += 1;\n \t  continue;\n \t}\n \n-      if ((orig_meth->accflags & (STATIC|PRIVATE|FINAL)) != 0\n-\t  || ((orig_meth->accflags & ABSTRACT) == 0\n-\t      && (this_meth->accflags & ABSTRACT) != 0\n-\t      && (klass->accflags & ABSTRACT) == 0))\n+      if ((orig_meth->accflags & (Modifier::STATIC\n+\t\t\t\t  | Modifier::PRIVATE\n+\t\t\t\t  | Modifier::FINAL)) != 0\n+\t  || ((orig_meth->accflags & Modifier::ABSTRACT) == 0\n+\t      && (this_meth->accflags & Modifier::ABSTRACT) != 0\n+\t      && (klass->accflags & Modifier::ABSTRACT) == 0))\n \t{\n \t  clz->state = JV_STATE_ERROR;\n \t  clz->notifyAll ();\n@@ -715,6 +713,8 @@ _Jv_PrepareClass(jclass klass)\n void\n _Jv_InitField (jobject obj, jclass klass, int index)\n {\n+  using namespace java::lang::reflect;\n+\n   if (obj != 0 && klass == 0)\n     klass = obj->getClass ();\n \n@@ -738,12 +738,12 @@ _Jv_InitField (jobject obj, jclass klass, int index)\n   if (! field->isResolved ())\n     throw_internal_error (\"initializing unresolved field\");\n \n-  if (obj==0 && ((field->flags & STATIC) == 0))\n+  if (obj==0 && ((field->flags & Modifier::STATIC) == 0))\n     throw_internal_error (\"initializing non-static field with no object\");\n \n   void *addr = 0;\n \n-  if ((field->flags & STATIC) != 0)\n+  if ((field->flags & Modifier::STATIC) != 0)\n     addr = (void*) field->u.addr;\n   else\n     addr = (void*) (((char*)obj) + field->u.boffset);\n@@ -1002,12 +1002,15 @@ typedef struct {\n \n typedef void (*ffi_closure_fun) (ffi_cif*,void*,ffi_raw*,void*);\n \n-void* _Jv_InterpMethod::ncode ()\n+void *\n+_Jv_InterpMethod::ncode ()\n {\n+  using namespace java::lang::reflect;\n+\n   if (self->ncode != 0)\n     return self->ncode;\n \n-  jboolean staticp = (self->accflags & STATIC) != 0;\n+  jboolean staticp = (self->accflags & Modifier::STATIC) != 0;\n   int arg_count = count_arguments (self->signature, staticp);\n \n   ncode_closure *closure =\n@@ -1024,7 +1027,7 @@ void* _Jv_InterpMethod::ncode ()\n \n   args_raw_size = ffi_raw_size (&closure->cif);\n \n-  if ((self->accflags & SYNCHRONIZED) != 0)\n+  if ((self->accflags & Modifier::SYNCHRONIZED) != 0)\n     {\n       if (staticp)\n \tfun = (ffi_closure_fun)&_Jv_InterpMethod::run_synch_class;\n@@ -1098,4 +1101,4 @@ throw_internal_error (char *msg)\n }\n \n \n-#endif\n+#endif /* INTERPRETER */"}]}