{"sha": "3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2RhMzlmNTJmZjc0MGFkNDI2M2EwMDBjNDhmZDVhNmQ5YWZkMThmZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2018-11-27T00:55:28Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2018-11-27T00:55:28Z"}, "message": "Fix missing dump_impl_location_t values, using a new dump_metadata_t\n\nThe dump_* API attempts to capture emission location metadata for the\nvarious dump messages, but looking in -fsave-optimization-record shows\nthat many dump messages are lacking useful impl_location values, instead\nhaving this location within dumpfile.c:\n\n            \"impl_location\": {\n                \"file\": \"../../src/gcc/dumpfile.c\",\n                \"function\": \"ensure_pending_optinfo\",\n                \"line\": 1169\n            },\n\nThe problem is that the auto-capturing of dump_impl_location_t is tied to\ndump_location_t, and this is tied to the dump_*_loc calls.  If a message\ncomes from a dump_* call without a \"_loc\" suffix (e.g. dump_printf), the\ncurrent code synthesizes the dump_location_t within\ndump_context::ensure_pending_optinfo, and thus saves the useless\nimpl_location seen above.\n\nThis patch fixes things by changing the dump_* API so that, rather than\ntaking a dump_flags_t, they take a new class dump_metadata_t, which is\nconstructed from a dump_flags_t, but captures the emission location.\n\nHence e.g.:\n\n  dump_printf (MSG_NOTE, \"some message\\n\");\n\nimplicitly builds a dump_metadata_t wrapping the MSG_NOTE and the\nemission location.  If there are several dump_printf calls without\na dump_*_loc call, the emission location within the optinfo is that\nof the first dump call within it.\n\nThe patch updates selftest::test_capture_of_dump_calls to verify\nthat the impl location of various dump_* calls is captured.  I also\nverified things manually.\n\ngcc/ChangeLog:\n\t* dump-context.h (dump_context::dump_loc): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.  Convert 2nd param from\n\tconst dump_location_t & to const dump_user_location_t &.\n\t(dump_context::dump_loc_immediate): Convert 2nd param from\n\tconst dump_location_t & to const dump_user_location_t &.\n\t(dump_context::dump_gimple_stmt): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.\n\t(dump_context::void dump_gimple_stmt_loc): Likewise; convert\n\t2nd param from const dump_location_t & to\n\tconst dump_user_location_t &.\n\t(dump_context::dump_gimple_expr): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.\n\t(dump_context::dump_gimple_expr_loc): Likewise; convert\n\t2nd param from const dump_location_t & to\n\tconst dump_user_location_t &.\n\t(dump_context::dump_generic_expr): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.\n\t(dump_context::dump_generic_expr_loc): Likewise; convert\n\t2nd param from const dump_location_t & to\n\tconst dump_user_location_t &.\n\t(dump_context::dump_printf_va): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.\n\t(dump_context::dump_printf_loc_va): Likewise; convert\n\t2nd param from const dump_location_t & to\n\tconst dump_user_location_t &.\n\t(dump_context::dump_dec): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.\n\t(dump_context::dump_symtab_node): Likewise.\n\t(dump_context::begin_scope): Split out 2nd param into\n\tuser and impl locations.\n\t(dump_context::ensure_pending_optinfo): Add metadata param.\n\t(dump_context::begin_next_optinfo): Replace dump_location_t param\n\twith metadata and user location.\n\t* dumpfile.c (dump_context::dump_loc): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.  Convert 2nd param from\n\tconst dump_location_t & to const dump_user_location_t &.\n\t(dump_context::dump_loc_immediate): Convert 2nd param from\n\tconst dump_location_t & to const dump_user_location_t &.\n\t(dump_context::dump_gimple_stmt): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.\n\t(dump_context::void dump_gimple_stmt_loc): Likewise; convert\n\t2nd param from const dump_location_t & to\n\tconst dump_user_location_t &.\n\t(dump_context::dump_gimple_expr): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.\n\t(dump_context::dump_gimple_expr_loc): Likewise; convert\n\t2nd param from const dump_location_t & to\n\tconst dump_user_location_t &.\n\t(dump_context::dump_generic_expr): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.\n\t(dump_context::dump_generic_expr_loc): Likewise; convert\n\t2nd param from const dump_location_t & to\n\tconst dump_user_location_t &.\n\t(dump_context::dump_printf_va): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.\n\t(dump_context::dump_printf_loc_va): Likewise; convert\n\t2nd param from const dump_location_t & to\n\tconst dump_user_location_t &.\n\t(dump_context::dump_dec): Convert 1st param from\n\tdump_flags_t to const dump_metadata_t &.\n\t(dump_context::dump_symtab_node): Likewise.\n\t(dump_context::begin_scope): Split out 2nd param into\n\tuser and impl locations.\n\t(dump_context::ensure_pending_optinfo): Add metadata param.\n\t(dump_context::begin_next_optinfo): Replace dump_location_t param\n\twith metadata and user location.\n\t(dump_gimple_stmt): Convert 1st param from dump_flags_t to\n\tconst dump_metadata_t &.\n\t(dump_gimple_stmt_loc): Likewise; convert 2nd param from\n\tconst dump_location_t & to const dump_user_location_t &.\n\t(dump_gimple_expr): Convert 1st param from dump_flags_t to\n\tconst dump_metadata_t &.\n\t(dump_gimple_expr_loc): Likewise; convert 2nd param from\n\tconst dump_location_t & to const dump_user_location_t &.\n\t(dump_generic_expr): Convert 1st param from dump_flags_t to\n\tconst dump_metadata_t &.\n\t(dump_generic_expr_loc): Likewise; convert 2nd param from\n\tconst dump_location_t & to const dump_user_location_t &.\n\t(dump_printf): Convert 1st param from dump_flags_t to\n\tconst dump_metadata_t &.\n\t(dump_printf_loc): Likewise; convert 2nd param from\n\tconst dump_location_t & to const dump_user_location_t &.\n\t(dump_dec): Convert 1st param from dump_flags_t to\n\tconst dump_metadata_t &.\n\t(dump_symtab_node): Likewise.\n\t(dump_begin_scope): Split out 2nd param into user and impl\n\tlocations.\n\t(selftest::assert_impl_location_eq): New function.\n\t(ASSERT_IMPL_LOCATION_EQ): New macro.\n\t(selftest::test_impl_location): Update to use\n\tASSERT_IMPL_LOCATION_EQ.\n\t(selftest::test_capture_of_dump_calls): Convert \"loc\" to\n\tdump_user_location_t.  Add ASSERT_IMPL_LOCATION_EQ throughout,\n\tverifying line numbers of dump emissions.\n\t* dumpfile.h (class dump_metadata_t): New class.\n\t(dump_printf): Convert 1st param from dump_flags_t to\n\tconst dump_metadata_t &.\n\t(dump_printf_loc): Likewise; convert 2nd param from\n\tconst dump_location_t & to const dump_user_location_t &.\n\t(dump_generic_expr_loc): Likewise.\n\t(dump_generic_expr): Convert 1st param from dump_flags_t to\n\tconst dump_metadata_t &.\n\t(dump_gimple_stmt_loc): Likewise; convert 2nd param from\n\tconst dump_location_t & to const dump_user_location_t &.\n\t(dump_gimple_stmt): Convert 1st param from dump_flags_t to\n\tconst dump_metadata_t &.\n\t(dump_gimple_expr_loc): Likewise; convert 2nd param from\n\tconst dump_location_t & to const dump_user_location_t &.\n\t(dump_gimple_expr): Convert 1st param from dump_flags_t to\n\tconst dump_metadata_t &.\n\t(dump_symtab_node): Likewise.\n\t(dump_dec): Likewise.\n\t(dump_begin_scope): Split out 2nd param into user and impl\n\tlocations.\n\t(auto_dump_scope::auto_dump_scope): Split \"loc\" param into a user\n\tlocation and impl_location, and capture the impl_location.\n\t(AUTO_DUMP_SCOPE): Rename param from LOC to USER_LOC.\n\t* loop-unroll.c (report_unroll): Update for changes to\n\tdump_printf_loc and dump_printf.\n\t* opt-problem.cc (opt_problem::opt_problem): Update for change to\n\tdump_loc.\n\t* optinfo-emit-json.cc\n\t(selftest::test_building_json_from_dump_calls): Convert \"loc\" from\n\tdump_location_t to dump_user_location_t.\n\t* optinfo.cc (optinfo::emit_for_opt_problem): Update for change in\n\tdump_loc_immediate.\n\t* profile.c (compute_branch_probabilities): Update for change to\n\tdump_printf_loc.\n\t* selftest.h (ASSERT_STR_CONTAINS_AT): New macro.\n\t* tree-vect-slp.c (vect_print_slp_tree): Update for change to\n\tdump_printf_loc.\n\nFrom-SVN: r266501", "tree": {"sha": "1bf30cfb819f615b76e6a2fdbaa3a2d58e4d8edb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1bf30cfb819f615b76e6a2fdbaa3a2d58e4d8edb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "27c16e61cb99796a912d491ad5d77ed7873a4eed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/27c16e61cb99796a912d491ad5d77ed7873a4eed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/27c16e61cb99796a912d491ad5d77ed7873a4eed"}], "stats": {"total": 564, "additions": 426, "deletions": 138}, "files": [{"sha": "c4ec55654086def59b84fbdf332d57a79daace9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "patch": "@@ -1,3 +1,137 @@\n+2018-11-26  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* dump-context.h (dump_context::dump_loc): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.  Convert 2nd param from\n+\tconst dump_location_t & to const dump_user_location_t &.\n+\t(dump_context::dump_loc_immediate): Convert 2nd param from\n+\tconst dump_location_t & to const dump_user_location_t &.\n+\t(dump_context::dump_gimple_stmt): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.\n+\t(dump_context::void dump_gimple_stmt_loc): Likewise; convert\n+\t2nd param from const dump_location_t & to\n+\tconst dump_user_location_t &.\n+\t(dump_context::dump_gimple_expr): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.\n+\t(dump_context::dump_gimple_expr_loc): Likewise; convert\n+\t2nd param from const dump_location_t & to\n+\tconst dump_user_location_t &.\n+\t(dump_context::dump_generic_expr): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.\n+\t(dump_context::dump_generic_expr_loc): Likewise; convert\n+\t2nd param from const dump_location_t & to\n+\tconst dump_user_location_t &.\n+\t(dump_context::dump_printf_va): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.\n+\t(dump_context::dump_printf_loc_va): Likewise; convert\n+\t2nd param from const dump_location_t & to\n+\tconst dump_user_location_t &.\n+\t(dump_context::dump_dec): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.\n+\t(dump_context::dump_symtab_node): Likewise.\n+\t(dump_context::begin_scope): Split out 2nd param into\n+\tuser and impl locations.\n+\t(dump_context::ensure_pending_optinfo): Add metadata param.\n+\t(dump_context::begin_next_optinfo): Replace dump_location_t param\n+\twith metadata and user location.\n+\t* dumpfile.c (dump_context::dump_loc): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.  Convert 2nd param from\n+\tconst dump_location_t & to const dump_user_location_t &.\n+\t(dump_context::dump_loc_immediate): Convert 2nd param from\n+\tconst dump_location_t & to const dump_user_location_t &.\n+\t(dump_context::dump_gimple_stmt): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.\n+\t(dump_context::void dump_gimple_stmt_loc): Likewise; convert\n+\t2nd param from const dump_location_t & to\n+\tconst dump_user_location_t &.\n+\t(dump_context::dump_gimple_expr): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.\n+\t(dump_context::dump_gimple_expr_loc): Likewise; convert\n+\t2nd param from const dump_location_t & to\n+\tconst dump_user_location_t &.\n+\t(dump_context::dump_generic_expr): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.\n+\t(dump_context::dump_generic_expr_loc): Likewise; convert\n+\t2nd param from const dump_location_t & to\n+\tconst dump_user_location_t &.\n+\t(dump_context::dump_printf_va): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.\n+\t(dump_context::dump_printf_loc_va): Likewise; convert\n+\t2nd param from const dump_location_t & to\n+\tconst dump_user_location_t &.\n+\t(dump_context::dump_dec): Convert 1st param from\n+\tdump_flags_t to const dump_metadata_t &.\n+\t(dump_context::dump_symtab_node): Likewise.\n+\t(dump_context::begin_scope): Split out 2nd param into\n+\tuser and impl locations.\n+\t(dump_context::ensure_pending_optinfo): Add metadata param.\n+\t(dump_context::begin_next_optinfo): Replace dump_location_t param\n+\twith metadata and user location.\n+\t(dump_gimple_stmt): Convert 1st param from dump_flags_t to\n+\tconst dump_metadata_t &.\n+\t(dump_gimple_stmt_loc): Likewise; convert 2nd param from\n+\tconst dump_location_t & to const dump_user_location_t &.\n+\t(dump_gimple_expr): Convert 1st param from dump_flags_t to\n+\tconst dump_metadata_t &.\n+\t(dump_gimple_expr_loc): Likewise; convert 2nd param from\n+\tconst dump_location_t & to const dump_user_location_t &.\n+\t(dump_generic_expr): Convert 1st param from dump_flags_t to\n+\tconst dump_metadata_t &.\n+\t(dump_generic_expr_loc): Likewise; convert 2nd param from\n+\tconst dump_location_t & to const dump_user_location_t &.\n+\t(dump_printf): Convert 1st param from dump_flags_t to\n+\tconst dump_metadata_t &.\n+\t(dump_printf_loc): Likewise; convert 2nd param from\n+\tconst dump_location_t & to const dump_user_location_t &.\n+\t(dump_dec): Convert 1st param from dump_flags_t to\n+\tconst dump_metadata_t &.\n+\t(dump_symtab_node): Likewise.\n+\t(dump_begin_scope): Split out 2nd param into user and impl\n+\tlocations.\n+\t(selftest::assert_impl_location_eq): New function.\n+\t(ASSERT_IMPL_LOCATION_EQ): New macro.\n+\t(selftest::test_impl_location): Update to use\n+\tASSERT_IMPL_LOCATION_EQ.\n+\t(selftest::test_capture_of_dump_calls): Convert \"loc\" to\n+\tdump_user_location_t.  Add ASSERT_IMPL_LOCATION_EQ throughout,\n+\tverifying line numbers of dump emissions.\n+\t* dumpfile.h (class dump_metadata_t): New class.\n+\t(dump_printf): Convert 1st param from dump_flags_t to\n+\tconst dump_metadata_t &.\n+\t(dump_printf_loc): Likewise; convert 2nd param from\n+\tconst dump_location_t & to const dump_user_location_t &.\n+\t(dump_generic_expr_loc): Likewise.\n+\t(dump_generic_expr): Convert 1st param from dump_flags_t to\n+\tconst dump_metadata_t &.\n+\t(dump_gimple_stmt_loc): Likewise; convert 2nd param from\n+\tconst dump_location_t & to const dump_user_location_t &.\n+\t(dump_gimple_stmt): Convert 1st param from dump_flags_t to\n+\tconst dump_metadata_t &.\n+\t(dump_gimple_expr_loc): Likewise; convert 2nd param from\n+\tconst dump_location_t & to const dump_user_location_t &.\n+\t(dump_gimple_expr): Convert 1st param from dump_flags_t to\n+\tconst dump_metadata_t &.\n+\t(dump_symtab_node): Likewise.\n+\t(dump_dec): Likewise.\n+\t(dump_begin_scope): Split out 2nd param into user and impl\n+\tlocations.\n+\t(auto_dump_scope::auto_dump_scope): Split \"loc\" param into a user\n+\tlocation and impl_location, and capture the impl_location.\n+\t(AUTO_DUMP_SCOPE): Rename param from LOC to USER_LOC.\n+\t* loop-unroll.c (report_unroll): Update for changes to\n+\tdump_printf_loc and dump_printf.\n+\t* opt-problem.cc (opt_problem::opt_problem): Update for change to\n+\tdump_loc.\n+\t* optinfo-emit-json.cc\n+\t(selftest::test_building_json_from_dump_calls): Convert \"loc\" from\n+\tdump_location_t to dump_user_location_t.\n+\t* optinfo.cc (optinfo::emit_for_opt_problem): Update for change in\n+\tdump_loc_immediate.\n+\t* profile.c (compute_branch_probabilities): Update for change to\n+\tdump_printf_loc.\n+\t* selftest.h (ASSERT_STR_CONTAINS_AT): New macro.\n+\t* tree-vect-slp.c (vect_print_slp_tree): Update for change to\n+\tdump_printf_loc.\n+\n 2018-11-27  Jozef Lawrynowicz  <jozef.l@mittosystems.com>\n \n \t* doc/sourcebuild.texi: Document check_effective_target_int_eq_float"}, {"sha": "26bed1e577b443b3a6e4dbb272236d690754937c", "filename": "gcc/dump-context.h", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fdump-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fdump-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdump-context.h?ref=3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "patch": "@@ -50,51 +50,57 @@ class dump_context\n \n   void refresh_dumps_are_enabled ();\n \n-  void dump_loc (dump_flags_t dump_kind, const dump_location_t &loc);\n-  void dump_loc_immediate (dump_flags_t dump_kind, const dump_location_t &loc);\n+  void dump_loc (const dump_metadata_t &metadata,\n+\t\t const dump_user_location_t &loc);\n+  void dump_loc_immediate (dump_flags_t dump_kind,\n+\t\t\t   const dump_user_location_t &loc);\n \n-  void dump_gimple_stmt (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n+  void dump_gimple_stmt (const dump_metadata_t &metadata,\n+\t\t\t dump_flags_t extra_dump_flags,\n \t\t\t gimple *gs, int spc);\n \n-  void dump_gimple_stmt_loc (dump_flags_t dump_kind,\n-\t\t\t     const dump_location_t &loc,\n+  void dump_gimple_stmt_loc (const dump_metadata_t &metadata,\n+\t\t\t     const dump_user_location_t &loc,\n \t\t\t     dump_flags_t extra_dump_flags,\n \t\t\t     gimple *gs, int spc);\n \n-  void dump_gimple_expr (dump_flags_t dump_kind,\n+  void dump_gimple_expr (const dump_metadata_t &metadata,\n \t\t\t dump_flags_t extra_dump_flags,\n \t\t\t gimple *gs, int spc);\n \n-  void dump_gimple_expr_loc (dump_flags_t dump_kind,\n-\t\t\t    const dump_location_t &loc,\n-\t\t\t    dump_flags_t extra_dump_flags,\n-\t\t\t    gimple *gs,\n-\t\t\t    int spc);\n+  void dump_gimple_expr_loc (const dump_metadata_t &metadata,\n+\t\t\t     const dump_user_location_t &loc,\n+\t\t\t     dump_flags_t extra_dump_flags,\n+\t\t\t     gimple *gs,\n+\t\t\t     int spc);\n \n-  void dump_generic_expr (dump_flags_t dump_kind,\n+  void dump_generic_expr (const dump_metadata_t &metadata,\n \t\t\t  dump_flags_t extra_dump_flags,\n \t\t\t  tree t);\n \n-  void dump_generic_expr_loc (dump_flags_t dump_kind,\n-\t\t\t      const dump_location_t &loc,\n+  void dump_generic_expr_loc (const dump_metadata_t &metadata,\n+\t\t\t      const dump_user_location_t &loc,\n \t\t\t      dump_flags_t extra_dump_flags,\n \t\t\t      tree t);\n \n-  void dump_printf_va (dump_flags_t dump_kind, const char *format,\n+  void dump_printf_va (const dump_metadata_t &metadata, const char *format,\n \t\t       va_list *ap) ATTRIBUTE_GCC_DUMP_PRINTF (3, 0);\n \n-  void dump_printf_loc_va (dump_flags_t dump_kind, const dump_location_t &loc,\n+  void dump_printf_loc_va (const dump_metadata_t &metadata,\n+\t\t\t   const dump_user_location_t &loc,\n \t\t\t   const char *format, va_list *ap)\n     ATTRIBUTE_GCC_DUMP_PRINTF (4, 0);\n \n   template<unsigned int N, typename C>\n-  void dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value);\n+  void dump_dec (const dump_metadata_t &metadata, const poly_int<N, C> &value);\n \n-  void dump_symtab_node (dump_flags_t dump_kind, symtab_node *node);\n+  void dump_symtab_node (const dump_metadata_t &metadata, symtab_node *node);\n \n   /* Managing nested scopes.  */\n   unsigned int get_scope_depth () const;\n-  void begin_scope (const char *name, const dump_location_t &loc);\n+  void begin_scope (const char *name,\n+\t\t    const dump_user_location_t &user_location,\n+\t\t    const dump_impl_location_t &impl_location);\n   void end_scope ();\n \n   /* Should optinfo instances be created?\n@@ -117,8 +123,9 @@ class dump_context\n   bool apply_dump_filter_p (dump_flags_t dump_kind, dump_flags_t filter) const;\n \n  private:\n-  optinfo &ensure_pending_optinfo ();\n-  optinfo &begin_next_optinfo (const dump_location_t &loc);\n+  optinfo &ensure_pending_optinfo (const dump_metadata_t &metadata);\n+  optinfo &begin_next_optinfo (const dump_metadata_t &metadata,\n+\t\t\t       const dump_user_location_t &loc);\n \n   /* The current nesting depth of dump scopes, for showing nesting\n      via indentation).  */"}, {"sha": "5005f5e96b6cf660c9a5cfc7f6aa11d883a7da2e", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 186, "deletions": 91, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "patch": "@@ -580,24 +580,22 @@ dump_context::apply_dump_filter_p (dump_flags_t dump_kind,\n    If optinfos are enabled, begin a new optinfo.  */\n \n void\n-dump_context::dump_loc (dump_flags_t dump_kind, const dump_location_t &loc)\n+dump_context::dump_loc (const dump_metadata_t &metadata,\n+\t\t\tconst dump_user_location_t &loc)\n {\n   end_any_optinfo ();\n \n-  dump_loc_immediate (dump_kind, loc);\n+  dump_loc_immediate (metadata.get_dump_flags (), loc);\n \n   if (optinfo_enabled_p ())\n-    {\n-      optinfo &info = begin_next_optinfo (loc);\n-      info.handle_dump_file_kind (dump_kind);\n-    }\n+    begin_next_optinfo (metadata, loc);\n }\n \n /* As dump_loc above, but without starting a new optinfo. */\n \n void\n dump_context::dump_loc_immediate (dump_flags_t dump_kind,\n-\t\t\t\t  const dump_location_t &loc)\n+\t\t\t\t  const dump_user_location_t &loc)\n {\n   location_t srcloc = loc.get_location_t ();\n \n@@ -632,18 +630,17 @@ make_item_for_dump_gimple_stmt (gimple *stmt, int spc, dump_flags_t dump_flags)\n    EXTRA_DUMP_FLAGS on the dump streams if DUMP_KIND is enabled.  */\n \n void\n-dump_context::dump_gimple_stmt (dump_flags_t dump_kind,\n+dump_context::dump_gimple_stmt (const dump_metadata_t &metadata,\n \t\t\t\tdump_flags_t extra_dump_flags,\n \t\t\t\tgimple *gs, int spc)\n {\n   optinfo_item *item\n     = make_item_for_dump_gimple_stmt (gs, spc, dump_flags | extra_dump_flags);\n-  emit_item (item, dump_kind);\n+  emit_item (item, metadata.get_dump_flags ());\n \n   if (optinfo_enabled_p ())\n     {\n-      optinfo &info = ensure_pending_optinfo ();\n-      info.handle_dump_file_kind (dump_kind);\n+      optinfo &info = ensure_pending_optinfo (metadata);\n       info.add_item (item);\n     }\n   else\n@@ -653,13 +650,13 @@ dump_context::dump_gimple_stmt (dump_flags_t dump_kind,\n /* Similar to dump_gimple_stmt, except additionally print source location.  */\n \n void\n-dump_context::dump_gimple_stmt_loc (dump_flags_t dump_kind,\n-\t\t\t\t    const dump_location_t &loc,\n+dump_context::dump_gimple_stmt_loc (const dump_metadata_t &metadata,\n+\t\t\t\t    const dump_user_location_t &loc,\n \t\t\t\t    dump_flags_t extra_dump_flags,\n \t\t\t\t    gimple *gs, int spc)\n {\n-  dump_loc (dump_kind, loc);\n-  dump_gimple_stmt (dump_kind, extra_dump_flags, gs, spc);\n+  dump_loc (metadata, loc);\n+  dump_gimple_stmt (metadata, extra_dump_flags, gs, spc);\n }\n \n /* Make an item for the given dump call, equivalent to print_gimple_expr.  */\n@@ -683,18 +680,17 @@ make_item_for_dump_gimple_expr (gimple *stmt, int spc, dump_flags_t dump_flags)\n    Do not terminate with a newline or semicolon.  */\n \n void\n-dump_context::dump_gimple_expr (dump_flags_t dump_kind,\n+dump_context::dump_gimple_expr (const dump_metadata_t &metadata,\n \t\t\t\tdump_flags_t extra_dump_flags,\n \t\t\t\tgimple *gs, int spc)\n {\n   optinfo_item *item\n     = make_item_for_dump_gimple_expr (gs, spc, dump_flags | extra_dump_flags);\n-  emit_item (item, dump_kind);\n+  emit_item (item, metadata.get_dump_flags ());\n \n   if (optinfo_enabled_p ())\n     {\n-      optinfo &info = ensure_pending_optinfo ();\n-      info.handle_dump_file_kind (dump_kind);\n+      optinfo &info = ensure_pending_optinfo (metadata);\n       info.add_item (item);\n     }\n   else\n@@ -704,14 +700,14 @@ dump_context::dump_gimple_expr (dump_flags_t dump_kind,\n /* Similar to dump_gimple_expr, except additionally print source location.  */\n \n void\n-dump_context::dump_gimple_expr_loc (dump_flags_t dump_kind,\n-\t\t\t\t    const dump_location_t &loc,\n+dump_context::dump_gimple_expr_loc (const dump_metadata_t &metadata,\n+\t\t\t\t    const dump_user_location_t &loc,\n \t\t\t\t    dump_flags_t extra_dump_flags,\n \t\t\t\t    gimple *gs,\n \t\t\t\t    int spc)\n {\n-  dump_loc (dump_kind, loc);\n-  dump_gimple_expr (dump_kind, extra_dump_flags, gs, spc);\n+  dump_loc (metadata, loc);\n+  dump_gimple_expr (metadata, extra_dump_flags, gs, spc);\n }\n \n /* Make an item for the given dump call, equivalent to print_generic_expr.  */\n@@ -738,18 +734,17 @@ make_item_for_dump_generic_expr (tree node, dump_flags_t dump_flags)\n    DUMP_KIND is enabled.  */\n \n void\n-dump_context::dump_generic_expr (dump_flags_t dump_kind,\n+dump_context::dump_generic_expr (const dump_metadata_t &metadata,\n \t\t\t\t dump_flags_t extra_dump_flags,\n \t\t\t\t tree t)\n {\n   optinfo_item *item\n     = make_item_for_dump_generic_expr (t, dump_flags | extra_dump_flags);\n-  emit_item (item, dump_kind);\n+  emit_item (item, metadata.get_dump_flags ());\n \n   if (optinfo_enabled_p ())\n     {\n-      optinfo &info = ensure_pending_optinfo ();\n-      info.handle_dump_file_kind (dump_kind);\n+      optinfo &info = ensure_pending_optinfo (metadata);\n       info.add_item (item);\n     }\n   else\n@@ -761,13 +756,13 @@ dump_context::dump_generic_expr (dump_flags_t dump_kind,\n    location.  */\n \n void\n-dump_context::dump_generic_expr_loc (dump_flags_t dump_kind,\n-\t\t\t\t     const dump_location_t &loc,\n+dump_context::dump_generic_expr_loc (const dump_metadata_t &metadata,\n+\t\t\t\t     const dump_user_location_t &loc,\n \t\t\t\t     dump_flags_t extra_dump_flags,\n \t\t\t\t     tree t)\n {\n-  dump_loc (dump_kind, loc);\n-  dump_generic_expr (dump_kind, extra_dump_flags, t);\n+  dump_loc (metadata, loc);\n+  dump_generic_expr (metadata, extra_dump_flags, t);\n }\n \n /* Make an item for the given dump call.  */\n@@ -987,10 +982,10 @@ dump_pretty_printer::decode_format (text_info *text, const char *spec,\n /* Output a formatted message using FORMAT on appropriate dump streams.  */\n \n void\n-dump_context::dump_printf_va (dump_flags_t dump_kind, const char *format,\n+dump_context::dump_printf_va (const dump_metadata_t &metadata, const char *format,\n \t\t\t      va_list *ap)\n {\n-  dump_pretty_printer pp (this, dump_kind);\n+  dump_pretty_printer pp (this, metadata.get_dump_flags ());\n \n   text_info text;\n   text.err_no = errno;\n@@ -1003,8 +998,7 @@ dump_context::dump_printf_va (dump_flags_t dump_kind, const char *format,\n   /* Phase 3.  */\n   if (optinfo_enabled_p ())\n     {\n-      optinfo &info = ensure_pending_optinfo ();\n-      info.handle_dump_file_kind (dump_kind);\n+      optinfo &info = ensure_pending_optinfo (metadata);\n       pp.emit_items (&info);\n     }\n   else\n@@ -1015,12 +1009,12 @@ dump_context::dump_printf_va (dump_flags_t dump_kind, const char *format,\n    dump location captured.  */\n \n void\n-dump_context::dump_printf_loc_va (dump_flags_t dump_kind,\n-\t\t\t\t  const dump_location_t &loc,\n+dump_context::dump_printf_loc_va (const dump_metadata_t &metadata,\n+\t\t\t\t  const dump_user_location_t &loc,\n \t\t\t\t  const char *format, va_list *ap)\n {\n-  dump_loc (dump_kind, loc);\n-  dump_printf_va (dump_kind, format, ap);\n+  dump_loc (metadata, loc);\n+  dump_printf_va (metadata, format, ap);\n }\n \n /* Make an item for the given dump call, equivalent to print_dec.  */\n@@ -1056,15 +1050,14 @@ make_item_for_dump_dec (const poly_int<N, C> &value)\n \n template<unsigned int N, typename C>\n void\n-dump_context::dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value)\n+dump_context::dump_dec (const dump_metadata_t &metadata, const poly_int<N, C> &value)\n {\n   optinfo_item *item = make_item_for_dump_dec (value);\n-  emit_item (item, dump_kind);\n+  emit_item (item, metadata.get_dump_flags ());\n \n   if (optinfo_enabled_p ())\n     {\n-      optinfo &info = ensure_pending_optinfo ();\n-      info.handle_dump_file_kind (dump_kind);\n+      optinfo &info = ensure_pending_optinfo (metadata);\n       info.add_item (item);\n     }\n   else\n@@ -1074,15 +1067,14 @@ dump_context::dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value)\n /* Output the name of NODE on appropriate dump streams.  */\n \n void\n-dump_context::dump_symtab_node (dump_flags_t dump_kind, symtab_node *node)\n+dump_context::dump_symtab_node (const dump_metadata_t &metadata, symtab_node *node)\n {\n   optinfo_item *item = make_item_for_dump_symtab_node (node);\n-  emit_item (item, dump_kind);\n+  emit_item (item, metadata.get_dump_flags ());\n \n   if (optinfo_enabled_p ())\n     {\n-      optinfo &info = ensure_pending_optinfo ();\n-      info.handle_dump_file_kind (dump_kind);\n+      optinfo &info = ensure_pending_optinfo (metadata);\n       info.add_item (item);\n     }\n   else\n@@ -1105,19 +1097,23 @@ dump_context::get_scope_depth () const\n    Emit a \"scope\" optinfo if optinfos are enabled.  */\n \n void\n-dump_context::begin_scope (const char *name, const dump_location_t &loc)\n+dump_context::begin_scope (const char *name,\n+\t\t\t   const dump_user_location_t &user_location,\n+\t\t\t   const dump_impl_location_t &impl_location)\n {\n   m_scope_depth++;\n \n+  location_t src_loc = user_location.get_location_t ();\n+\n   if (dump_file && apply_dump_filter_p (MSG_NOTE, pflags))\n-    ::dump_loc (MSG_NOTE, dump_file, loc.get_location_t ());\n+    ::dump_loc (MSG_NOTE, dump_file, src_loc);\n \n   if (alt_dump_file && apply_dump_filter_p (MSG_NOTE, alt_flags))\n-    ::dump_loc (MSG_NOTE, alt_dump_file, loc.get_location_t ());\n+    ::dump_loc (MSG_NOTE, alt_dump_file, src_loc);\n \n   /* Support for temp_dump_context in selftests.  */\n   if (m_test_pp && apply_dump_filter_p (MSG_NOTE, m_test_pp_flags))\n-    ::dump_loc (MSG_NOTE, m_test_pp, loc.get_location_t ());\n+    ::dump_loc (MSG_NOTE, m_test_pp, src_loc);\n \n   pretty_printer pp;\n   pp_printf (&pp, \"=== %s ===\\n\", name);\n@@ -1128,7 +1124,9 @@ dump_context::begin_scope (const char *name, const dump_location_t &loc)\n \n   if (optinfo_enabled_p ())\n     {\n-      optinfo &info = begin_next_optinfo (loc);\n+      optinfo &info\n+\t= begin_next_optinfo (dump_metadata_t (MSG_NOTE, impl_location),\n+\t\t\t      user_location);\n       info.m_kind = OPTINFO_KIND_SCOPE;\n       info.add_item (item);\n       end_any_optinfo ();\n@@ -1163,22 +1161,25 @@ dump_context::optinfo_enabled_p () const\n    necessary.  */\n \n optinfo &\n-dump_context::ensure_pending_optinfo ()\n+dump_context::ensure_pending_optinfo (const dump_metadata_t &metadata)\n {\n   if (!m_pending)\n-    return begin_next_optinfo (dump_location_t (dump_user_location_t ()));\n+    return begin_next_optinfo (metadata, dump_user_location_t ());\n   return *m_pending;\n }\n \n /* Start a new optinfo and return it, ending any optinfo that was already\n    accumulated.  */\n \n optinfo &\n-dump_context::begin_next_optinfo (const dump_location_t &loc)\n+dump_context::begin_next_optinfo (const dump_metadata_t &metadata,\n+\t\t\t\t  const dump_user_location_t &user_loc)\n {\n   end_any_optinfo ();\n   gcc_assert (m_pending == NULL);\n+  dump_location_t loc (user_loc, metadata.get_impl_location ());\n   m_pending = new optinfo (loc, OPTINFO_KIND_NOTE, current_pass);\n+  m_pending->handle_dump_file_kind (metadata.get_dump_flags ());\n   return *m_pending;\n }\n \n@@ -1248,21 +1249,22 @@ dump_context dump_context::s_default;\n    EXTRA_DUMP_FLAGS on the dump streams if DUMP_KIND is enabled.  */\n \n void\n-dump_gimple_stmt (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n+dump_gimple_stmt (const dump_metadata_t &metadata, dump_flags_t extra_dump_flags,\n \t\t  gimple *gs, int spc)\n {\n   VERIFY_DUMP_ENABLED_P;\n-  dump_context::get ().dump_gimple_stmt (dump_kind, extra_dump_flags, gs, spc);\n+  dump_context::get ().dump_gimple_stmt (metadata, extra_dump_flags, gs, spc);\n }\n \n /* Similar to dump_gimple_stmt, except additionally print source location.  */\n \n void\n-dump_gimple_stmt_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n+dump_gimple_stmt_loc (const dump_metadata_t &metadata,\n+\t\t      const dump_user_location_t &loc,\n \t\t      dump_flags_t extra_dump_flags, gimple *gs, int spc)\n {\n   VERIFY_DUMP_ENABLED_P;\n-  dump_context::get ().dump_gimple_stmt_loc (dump_kind, loc, extra_dump_flags,\n+  dump_context::get ().dump_gimple_stmt_loc (metadata, loc, extra_dump_flags,\n \t\t\t\t\t     gs, spc);\n }\n \n@@ -1271,88 +1273,92 @@ dump_gimple_stmt_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n    Do not terminate with a newline or semicolon.  */\n \n void\n-dump_gimple_expr (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n+dump_gimple_expr (const dump_metadata_t &metadata,\n+\t\t  dump_flags_t extra_dump_flags,\n \t\t  gimple *gs, int spc)\n {\n   VERIFY_DUMP_ENABLED_P;\n-  dump_context::get ().dump_gimple_expr (dump_kind, extra_dump_flags, gs, spc);\n+  dump_context::get ().dump_gimple_expr (metadata, extra_dump_flags, gs, spc);\n }\n \n /* Similar to dump_gimple_expr, except additionally print source location.  */\n \n void\n-dump_gimple_expr_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n+dump_gimple_expr_loc (const dump_metadata_t &metadata,\n+\t\t      const dump_user_location_t &loc,\n \t\t      dump_flags_t extra_dump_flags, gimple *gs, int spc)\n {\n   VERIFY_DUMP_ENABLED_P;\n-  dump_context::get ().dump_gimple_expr_loc (dump_kind, loc, extra_dump_flags,\n+  dump_context::get ().dump_gimple_expr_loc (metadata, loc, extra_dump_flags,\n \t\t\t\t\t     gs, spc);\n }\n \n /* Dump expression tree T using EXTRA_DUMP_FLAGS on dump streams if\n    DUMP_KIND is enabled.  */\n \n void\n-dump_generic_expr (dump_flags_t dump_kind, dump_flags_t extra_dump_flags,\n+dump_generic_expr (const dump_metadata_t &metadata, dump_flags_t extra_dump_flags,\n \t\t   tree t)\n {\n   VERIFY_DUMP_ENABLED_P;\n-  dump_context::get ().dump_generic_expr (dump_kind, extra_dump_flags, t);\n+  dump_context::get ().dump_generic_expr (metadata, extra_dump_flags, t);\n }\n \n /* Similar to dump_generic_expr, except additionally print the source\n    location.  */\n \n void\n-dump_generic_expr_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n+dump_generic_expr_loc (const dump_metadata_t &metadata,\n+\t\t       const dump_user_location_t &loc,\n \t\t       dump_flags_t extra_dump_flags, tree t)\n {\n   VERIFY_DUMP_ENABLED_P;\n-  dump_context::get ().dump_generic_expr_loc (dump_kind, loc, extra_dump_flags,\n+  dump_context::get ().dump_generic_expr_loc (metadata, loc, extra_dump_flags,\n \t\t\t\t\t      t);\n }\n \n /* Output a formatted message using FORMAT on appropriate dump streams.  */\n \n void\n-dump_printf (dump_flags_t dump_kind, const char *format, ...)\n+dump_printf (const dump_metadata_t &metadata, const char *format, ...)\n {\n   VERIFY_DUMP_ENABLED_P;\n   va_list ap;\n   va_start (ap, format);\n-  dump_context::get ().dump_printf_va (dump_kind, format, &ap);\n+  dump_context::get ().dump_printf_va (metadata, format, &ap);\n   va_end (ap);\n }\n \n /* Similar to dump_printf, except source location is also printed, and\n    dump location captured.  */\n \n void\n-dump_printf_loc (dump_flags_t dump_kind, const dump_location_t &loc,\n+dump_printf_loc (const dump_metadata_t &metadata,\n+\t\t const dump_user_location_t &loc,\n \t\t const char *format, ...)\n {\n   VERIFY_DUMP_ENABLED_P;\n   va_list ap;\n   va_start (ap, format);\n-  dump_context::get ().dump_printf_loc_va (dump_kind, loc, format, &ap);\n+  dump_context::get ().dump_printf_loc_va (metadata, loc, format, &ap);\n   va_end (ap);\n }\n \n /* Output VALUE in decimal to appropriate dump streams.  */\n \n template<unsigned int N, typename C>\n void\n-dump_dec (dump_flags_t dump_kind, const poly_int<N, C> &value)\n+dump_dec (const dump_metadata_t &metadata, const poly_int<N, C> &value)\n {\n   VERIFY_DUMP_ENABLED_P;\n-  dump_context::get ().dump_dec (dump_kind, value);\n+  dump_context::get ().dump_dec (metadata, value);\n }\n \n-template void dump_dec (dump_flags_t, const poly_uint16 &);\n-template void dump_dec (dump_flags_t, const poly_int64 &);\n-template void dump_dec (dump_flags_t, const poly_uint64 &);\n-template void dump_dec (dump_flags_t, const poly_offset_int &);\n-template void dump_dec (dump_flags_t, const poly_widest_int &);\n+template void dump_dec (const dump_metadata_t &metadata, const poly_uint16 &);\n+template void dump_dec (const dump_metadata_t &metadata, const poly_int64 &);\n+template void dump_dec (const dump_metadata_t &metadata, const poly_uint64 &);\n+template void dump_dec (const dump_metadata_t &metadata, const poly_offset_int &);\n+template void dump_dec (const dump_metadata_t &metadata, const poly_widest_int &);\n \n void\n dump_dec (dump_flags_t dump_kind, const poly_wide_int &value, signop sgn)\n@@ -1394,10 +1400,10 @@ dumpfile_ensure_any_optinfo_are_flushed ()\n /* Output the name of NODE on appropriate dump streams.  */\n \n void\n-dump_symtab_node (dump_flags_t dump_kind, symtab_node *node)\n+dump_symtab_node (const dump_metadata_t &metadata, symtab_node *node)\n {\n   VERIFY_DUMP_ENABLED_P;\n-  dump_context::get ().dump_symtab_node (dump_kind, node);\n+  dump_context::get ().dump_symtab_node (metadata, node);\n }\n \n /* Get the current dump scope-nesting depth.\n@@ -1416,9 +1422,11 @@ get_dump_scope_depth ()\n    Increment the scope depth.  */\n \n void\n-dump_begin_scope (const char *name, const dump_location_t &loc)\n+dump_begin_scope (const char *name,\n+\t\t  const dump_user_location_t &user_location,\n+\t\t  const dump_impl_location_t &impl_location)\n {\n-  dump_context::get ().begin_scope (name, loc);\n+  dump_context::get ().begin_scope (name, user_location, impl_location);\n }\n \n /* Pop a nested dump scope.  */\n@@ -2083,38 +2091,66 @@ temp_dump_context::get_dumped_text ()\n   return pp_formatted_text (&m_pp);\n }\n \n+/* Verify that IMPL_LOC is within EXPECTED_FILE at EXPECTED_LINE,\n+   from EXPECTED_FUNCTION, using LOC for the location of any failure,\n+   provided that the build compiler is sufficiently recent.  */\n+\n+static void\n+assert_impl_location_eq (const location &loc ATTRIBUTE_UNUSED,\n+\t\t\t const dump_impl_location_t &impl_loc ATTRIBUTE_UNUSED,\n+\t\t\t const char *expected_file ATTRIBUTE_UNUSED,\n+\t\t\t int expected_line ATTRIBUTE_UNUSED,\n+\t\t\t const char *expected_function ATTRIBUTE_UNUSED)\n+{\n+#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n+  ASSERT_STR_CONTAINS_AT (loc, impl_loc.m_file, expected_file);\n+  ASSERT_EQ_AT (loc, impl_loc.m_line, expected_line);\n+  ASSERT_STR_CONTAINS_AT (loc, impl_loc.m_function, expected_function);\n+#endif\n+}\n+\n+/* Verify that IMPL_LOC is within EXPECTED_FILE at EXPECTED_LINE,\n+   from EXPECTED_FUNCTION, provided that the build compiler is\n+   sufficiently recent.  */\n+\n+#define ASSERT_IMPL_LOCATION_EQ(IMPL_LOC, EXPECTED_FILE, EXPECTED_LINE, \\\n+\t\t\t\tEXPECTED_FUNCTION)\t\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+    assert_impl_location_eq (SELFTEST_LOCATION, IMPL_LOC,\t\t\\\n+\t\t\t     EXPECTED_FILE, EXPECTED_LINE,\t\t\\\n+\t\t\t     EXPECTED_FUNCTION);\t\t\t\\\n+  SELFTEST_END_STMT\n+\n /* Verify that the dump_location_t constructors capture the source location\n    at which they were called (provided that the build compiler is sufficiently\n    recent).  */\n \n static void\n test_impl_location ()\n {\n-#if __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 8)\n   /* Default ctor.  */\n   {\n     dump_location_t loc;\n     const int expected_line = __LINE__ - 1;\n-    ASSERT_STR_CONTAINS (loc.get_impl_location ().m_file, \"dumpfile.c\");\n-    ASSERT_EQ (loc.get_impl_location ().m_line, expected_line);\n+    ASSERT_IMPL_LOCATION_EQ (loc.get_impl_location (),\n+\t\t\t     \"dumpfile.c\", expected_line, \"test_impl_location\");\n   }\n \n   /* Constructing from a gimple.  */\n   {\n     dump_location_t loc ((gimple *)NULL);\n     const int expected_line = __LINE__ - 1;\n-    ASSERT_STR_CONTAINS (loc.get_impl_location ().m_file, \"dumpfile.c\");\n-    ASSERT_EQ (loc.get_impl_location ().m_line, expected_line);\n+    ASSERT_IMPL_LOCATION_EQ (loc.get_impl_location (),\n+\t\t\t     \"dumpfile.c\", expected_line, \"test_impl_location\");\n   }\n \n   /* Constructing from an rtx_insn.  */\n   {\n     dump_location_t loc ((rtx_insn *)NULL);\n     const int expected_line = __LINE__ - 1;\n-    ASSERT_STR_CONTAINS (loc.get_impl_location ().m_file, \"dumpfile.c\");\n-    ASSERT_EQ (loc.get_impl_location ().m_line, expected_line);\n+    ASSERT_IMPL_LOCATION_EQ (loc.get_impl_location (),\n+\t\t\t     \"dumpfile.c\", expected_line, \"test_impl_location\");\n   }\n-#endif\n }\n \n /* Verify that the text dumped so far in CONTEXT equals\n@@ -2161,7 +2197,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n   if (stmt_loc > LINE_MAP_MAX_LOCATION_WITH_COLS)\n     return;\n \n-  dump_location_t loc = dump_location_t::from_location_t (stmt_loc);\n+  dump_user_location_t loc = dump_user_location_t::from_location_t (stmt_loc);\n \n   gimple *stmt = gimple_build_return (NULL);\n   gimple_set_location (stmt, stmt_loc);\n@@ -2188,6 +2224,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf (MSG_NOTE, \"int: %i str: %s\", 42, \"foo\");\n+\tconst int expected_impl_line = __LINE__ - 1;\n \n \tASSERT_DUMPED_TEXT_EQ (tmp, \"int: 42 str: foo\");\n \tif (with_optinfo)\n@@ -2197,6 +2234,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n \t    ASSERT_EQ (info->num_items (), 1);\n \t    ASSERT_IS_TEXT (info->get_item (0), \"int: 42 str: foo\");\n+\t    ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t     \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t     \"test_capture_of_dump_calls\");\n \t  }\n       }\n \n@@ -2205,6 +2245,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf (MSG_NOTE, \"tree: %T\", integer_zero_node);\n+\tconst int expected_impl_line = __LINE__ - 1;\n \n \tASSERT_DUMPED_TEXT_EQ (tmp, \"tree: 0\");\n \tif (with_optinfo)\n@@ -2215,6 +2256,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_EQ (info->num_items (), 2);\n \t    ASSERT_IS_TEXT (info->get_item (0), \"tree: \");\n \t    ASSERT_IS_TREE (info->get_item (1), UNKNOWN_LOCATION, \"0\");\n+\t    ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t     \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t     \"test_capture_of_dump_calls\");\n \t  }\n       }\n \n@@ -2223,6 +2267,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf (MSG_NOTE, \"gimple: %E\", stmt);\n+\tconst int expected_impl_line = __LINE__ - 1;\n \n \tASSERT_DUMPED_TEXT_EQ (tmp, \"gimple: return;\");\n \tif (with_optinfo)\n@@ -2233,6 +2278,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_EQ (info->num_items (), 2);\n \t    ASSERT_IS_TEXT (info->get_item (0), \"gimple: \");\n \t    ASSERT_IS_GIMPLE (info->get_item (1), stmt_loc, \"return;\");\n+\t    ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t     \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t     \"test_capture_of_dump_calls\");\n \t  }\n       }\n \n@@ -2241,6 +2289,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf (MSG_NOTE, \"gimple: %G\", stmt);\n+\tconst int expected_impl_line = __LINE__ - 1;\n \n \tASSERT_DUMPED_TEXT_EQ (tmp, \"gimple: return;\\n\");\n \tif (with_optinfo)\n@@ -2251,6 +2300,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_EQ (info->num_items (), 2);\n \t    ASSERT_IS_TEXT (info->get_item (0), \"gimple: \");\n \t    ASSERT_IS_GIMPLE (info->get_item (1), stmt_loc, \"return;\\n\");\n+\t    ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t     \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t     \"test_capture_of_dump_calls\");\n \t  }\n       }\n \n@@ -2259,6 +2311,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf (MSG_NOTE, \"node: %C\", node);\n+\tconst int expected_impl_line = __LINE__ - 1;\n \n \tASSERT_DUMPED_TEXT_EQ (tmp, \"node: test_decl/0\");\n \tif (with_optinfo)\n@@ -2269,6 +2322,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_EQ (info->num_items (), 2);\n \t    ASSERT_IS_TEXT (info->get_item (0), \"node: \");\n \t    ASSERT_IS_SYMTAB_NODE (info->get_item (1), decl_loc, \"test_decl/0\");\n+\t    ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t     \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t     \"test_capture_of_dump_calls\");\n \t  }\n       }\n \n@@ -2302,6 +2358,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_IS_GIMPLE (info->get_item (5), stmt_loc, \"return;\");\n \t    ASSERT_IS_GIMPLE (info->get_item (6), stmt_loc, \"return;\");\n \t    ASSERT_IS_TEXT (info->get_item (7), \" after\\n\");\n+\t    /* We don't ASSERT_IMPL_LOCATION_EQ here, to avoid having to\n+\t       enforce at which exact line the multiline dump_printf_loc\n+\t       occurred.  */\n \t  }\n       }\n \n@@ -2310,6 +2369,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_printf_loc (MSG_NOTE, loc, \"test of tree: \");\n+\tconst int expected_impl_line = __LINE__ - 1;\n \tdump_generic_expr (MSG_NOTE, TDF_SLIM, integer_zero_node);\n \n \tASSERT_DUMPED_TEXT_EQ (tmp, \"test.txt:5:10: note: test of tree: 0\");\n@@ -2322,6 +2382,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_EQ (info->num_items (), 2);\n \t    ASSERT_IS_TEXT (info->get_item (0), \"test of tree: \");\n \t    ASSERT_IS_TREE (info->get_item (1), UNKNOWN_LOCATION, \"0\");\n+\t    ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t     \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t     \"test_capture_of_dump_calls\");\n \t  }\n       }\n \n@@ -2330,6 +2393,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_generic_expr_loc (MSG_NOTE, loc, TDF_SLIM, integer_one_node);\n+\tconst int expected_impl_line = __LINE__ - 1;\n \n \tASSERT_DUMPED_TEXT_EQ (tmp, \"test.txt:5:10: note: 1\");\n \tif (with_optinfo)\n@@ -2340,6 +2404,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n \t    ASSERT_EQ (info->num_items (), 1);\n \t    ASSERT_IS_TREE (info->get_item (0), UNKNOWN_LOCATION, \"1\");\n+\t    ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t     \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t     \"test_capture_of_dump_calls\");\n \t  }\n       }\n \n@@ -2350,6 +2417,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t  temp_dump_context tmp (with_optinfo, true,\n \t\t\t\t MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \t  dump_gimple_stmt_loc (MSG_NOTE, loc, TDF_SLIM, stmt, 2);\n+\t  const int expected_impl_line = __LINE__ - 1;\n \n \t  ASSERT_DUMPED_TEXT_EQ (tmp, \"test.txt:5:10: note: return;\\n\");\n \t  if (with_optinfo)\n@@ -2358,6 +2426,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t      ASSERT_TRUE (info != NULL);\n \t      ASSERT_EQ (info->num_items (), 1);\n \t      ASSERT_IS_GIMPLE (info->get_item (0), stmt_loc, \"return;\\n\");\n+\t      ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t       \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t       \"test_capture_of_dump_calls\");\n \t    }\n \t}\n \n@@ -2366,6 +2437,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t  temp_dump_context tmp (with_optinfo, true,\n \t\t\t\t MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 2);\n+\t  const int expected_impl_line = __LINE__ - 1;\n \n \t  ASSERT_DUMPED_TEXT_EQ (tmp, \"return;\\n\");\n \t  if (with_optinfo)\n@@ -2374,6 +2446,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t      ASSERT_TRUE (info != NULL);\n \t      ASSERT_EQ (info->num_items (), 1);\n \t      ASSERT_IS_GIMPLE (info->get_item (0), stmt_loc, \"return;\\n\");\n+\t      ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t       \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t       \"test_capture_of_dump_calls\");\n \t    }\n \t}\n \n@@ -2382,6 +2457,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t  temp_dump_context tmp (with_optinfo, true,\n \t\t\t\t MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \t  dump_gimple_expr_loc (MSG_NOTE, loc, TDF_SLIM, stmt, 2);\n+\t  const int expected_impl_line = __LINE__ - 1;\n \n \t  ASSERT_DUMPED_TEXT_EQ (tmp, \"test.txt:5:10: note: return;\");\n \t  if (with_optinfo)\n@@ -2390,6 +2466,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t      ASSERT_TRUE (info != NULL);\n \t      ASSERT_EQ (info->num_items (), 1);\n \t      ASSERT_IS_GIMPLE (info->get_item (0), stmt_loc, \"return;\");\n+\t      ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t       \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t       \"test_capture_of_dump_calls\");\n \t    }\n \t}\n \n@@ -2398,6 +2477,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t  temp_dump_context tmp (with_optinfo, true,\n \t\t\t\t MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \t  dump_gimple_expr (MSG_NOTE, TDF_SLIM, stmt, 2);\n+\t  const int expected_impl_line = __LINE__ - 1;\n \n \t  ASSERT_DUMPED_TEXT_EQ (tmp, \"return;\");\n \t  if (with_optinfo)\n@@ -2406,6 +2486,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t      ASSERT_TRUE (info != NULL);\n \t      ASSERT_EQ (info->num_items (), 1);\n \t      ASSERT_IS_GIMPLE (info->get_item (0), stmt_loc, \"return;\");\n+\t      ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t       \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t       \"test_capture_of_dump_calls\");\n \t    }\n \t}\n       }\n@@ -2415,6 +2498,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_symtab_node (MSG_NOTE, node);\n+\tconst int expected_impl_line = __LINE__ - 1;\n \n \tASSERT_DUMPED_TEXT_EQ (tmp, \"test_decl/0\");\n \tif (with_optinfo)\n@@ -2424,6 +2508,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_EQ (info->get_kind (), OPTINFO_KIND_NOTE);\n \t    ASSERT_EQ (info->num_items (), 1);\n \t    ASSERT_IS_SYMTAB_NODE (info->get_item (0), decl_loc, \"test_decl/0\");\n+\t    ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t     \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t     \"test_capture_of_dump_calls\");\n \t  }\n       }\n \n@@ -2432,6 +2519,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \ttemp_dump_context tmp (with_optinfo, true,\n \t\t\t       MSG_ALL_KINDS | MSG_PRIORITY_USER_FACING);\n \tdump_dec (MSG_NOTE, poly_int64 (42));\n+\tconst int expected_impl_line = __LINE__ - 1;\n \n \tASSERT_DUMPED_TEXT_EQ (tmp, \"42\");\n \tif (with_optinfo)\n@@ -2440,6 +2528,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    ASSERT_TRUE (info != NULL);\n \t    ASSERT_EQ (info->num_items (), 1);\n \t    ASSERT_IS_TEXT (info->get_item (0), \"42\");\n+\t    ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t     \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t     \"test_capture_of_dump_calls\");\n \t  }\n       }\n \n@@ -2476,6 +2567,7 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t    dump_printf_loc (MSG_NOTE, stmt, \"msg 6\\n\");\n \t  }\n \t  dump_printf_loc (MSG_NOTE, stmt, \"msg 7\\n\");\n+\t  const int expected_impl_line = __LINE__ - 1;\n \n \t  switch (dump_filter & MSG_ALL_PRIORITIES)\n \t    {\n@@ -2527,6 +2619,9 @@ test_capture_of_dump_calls (const line_table_case &case_)\n \t      ASSERT_TRUE (info != NULL);\n \t      ASSERT_EQ (info->num_items (), 1);\n \t      ASSERT_IS_TEXT (info->get_item (0), \"msg 7\\n\");\n+\t      ASSERT_IMPL_LOCATION_EQ (info->get_impl_location (),\n+\t\t\t\t       \"dumpfile.c\", expected_impl_line,\n+\t\t\t\t       \"test_capture_of_dump_calls\");\n \t    }\n \t}\n     }"}, {"sha": "d51e4ceaf114ab5f6f253ef9ea39385de421f066", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 56, "deletions": 16, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "patch": "@@ -385,6 +385,38 @@ struct dump_impl_location_t\n   const char *m_function;\n };\n \n+/* A bundle of metadata for describing a dump message:\n+   (a) the dump_flags\n+   (b) the source location within the compiler/plugin.\n+\n+   The constructors use default parameters so that (b) gets sets up\n+   automatically.\n+\n+   Hence you can pass in e.g. MSG_NOTE, and the dump call\n+   will automatically record where in GCC's source code the\n+   dump was emitted from.  */\n+\n+class dump_metadata_t\n+{\n+ public:\n+  dump_metadata_t (dump_flags_t dump_flags,\n+\t\t   const dump_impl_location_t &impl_location\n+\t\t     = dump_impl_location_t ())\n+  : m_dump_flags (dump_flags),\n+    m_impl_location (impl_location)\n+  {\n+  }\n+\n+  dump_flags_t get_dump_flags () const { return m_dump_flags; }\n+\n+  const dump_impl_location_t &\n+  get_impl_location () const { return m_impl_location; }\n+\n+ private:\n+  dump_flags_t m_dump_flags;\n+  dump_impl_location_t m_impl_location;\n+};\n+\n /* A bundle of information for describing the location of a dump message:\n    (a) the source location and hotness within the user's code, together with\n    (b) the source location within the compiler/plugin.\n@@ -521,27 +553,30 @@ dump_enabled_p (void)\n    to minimize the work done for the common case where dumps\n    are disabled.  */\n \n-extern void dump_printf (dump_flags_t, const char *, ...)\n+extern void dump_printf (const dump_metadata_t &, const char *, ...)\n   ATTRIBUTE_GCC_DUMP_PRINTF (2, 3);\n \n-extern void dump_printf_loc (dump_flags_t, const dump_location_t &,\n+extern void dump_printf_loc (const dump_metadata_t &, const dump_user_location_t &,\n \t\t\t     const char *, ...)\n   ATTRIBUTE_GCC_DUMP_PRINTF (3, 0);\n extern void dump_function (int phase, tree fn);\n extern void dump_basic_block (dump_flags_t, basic_block, int);\n-extern void dump_generic_expr_loc (dump_flags_t, const dump_location_t &,\n+extern void dump_generic_expr_loc (const dump_metadata_t &,\n+\t\t\t\t   const dump_user_location_t &,\n \t\t\t\t   dump_flags_t, tree);\n-extern void dump_generic_expr (dump_flags_t, dump_flags_t, tree);\n-extern void dump_gimple_stmt_loc (dump_flags_t, const dump_location_t &,\n+extern void dump_generic_expr (const dump_metadata_t &, dump_flags_t, tree);\n+extern void dump_gimple_stmt_loc (const dump_metadata_t &,\n+\t\t\t\t  const dump_user_location_t &,\n \t\t\t\t  dump_flags_t, gimple *, int);\n-extern void dump_gimple_stmt (dump_flags_t, dump_flags_t, gimple *, int);\n-extern void dump_gimple_expr_loc (dump_flags_t, const dump_location_t &,\n+extern void dump_gimple_stmt (const dump_metadata_t &, dump_flags_t, gimple *, int);\n+extern void dump_gimple_expr_loc (const dump_metadata_t &,\n+\t\t\t\t  const dump_user_location_t &,\n \t\t\t\t  dump_flags_t, gimple *, int);\n-extern void dump_gimple_expr (dump_flags_t, dump_flags_t, gimple *, int);\n-extern void dump_symtab_node (dump_flags_t, symtab_node *);\n+extern void dump_gimple_expr (const dump_metadata_t &, dump_flags_t, gimple *, int);\n+extern void dump_symtab_node (const dump_metadata_t &, symtab_node *);\n \n template<unsigned int N, typename C>\n-void dump_dec (dump_flags_t, const poly_int<N, C> &);\n+void dump_dec (const dump_metadata_t &, const poly_int<N, C> &);\n extern void dump_dec (dump_flags_t, const poly_wide_int &, signop);\n extern void dump_hex (dump_flags_t, const poly_wide_int &);\n \n@@ -551,7 +586,9 @@ extern void dumpfile_ensure_any_optinfo_are_flushed ();\n    leading to a dump message.  */\n \n extern unsigned int get_dump_scope_depth ();\n-extern void dump_begin_scope (const char *name, const dump_location_t &loc);\n+extern void dump_begin_scope (const char *name,\n+\t\t\t      const dump_user_location_t &user_location,\n+\t\t\t      const dump_impl_location_t &impl_location);\n extern void dump_end_scope ();\n \n /* Implementation detail of the AUTO_DUMP_SCOPE macro below.\n@@ -563,10 +600,13 @@ extern void dump_end_scope ();\n class auto_dump_scope\n {\n  public:\n-  auto_dump_scope (const char *name, dump_location_t loc)\n+  auto_dump_scope (const char *name,\n+\t\t   const dump_user_location_t &user_location,\n+\t\t   const dump_impl_location_t &impl_location\n+\t\t   = dump_impl_location_t ())\n   {\n     if (dump_enabled_p ())\n-      dump_begin_scope (name, loc);\n+      dump_begin_scope (name, user_location, impl_location);\n   }\n   ~auto_dump_scope ()\n   {\n@@ -576,7 +616,7 @@ class auto_dump_scope\n };\n \n /* A macro for calling:\n-     dump_begin_scope (NAME, LOC);\n+     dump_begin_scope (NAME, USER_LOC);\n    via an RAII object, thus printing \"=== MSG ===\\n\" to the dumpfile etc,\n    and then calling\n      dump_end_scope ();\n@@ -587,8 +627,8 @@ class auto_dump_scope\n    top level implicitly default to MSG_PRIORITY_USER_FACING, whereas those\n    in a nested scope implicitly default to MSG_PRIORITY_INTERNALS.  */\n \n-#define AUTO_DUMP_SCOPE(NAME, LOC) \\\n-  auto_dump_scope scope (NAME, LOC)\n+#define AUTO_DUMP_SCOPE(NAME, USER_LOC) \\\n+  auto_dump_scope scope (NAME, USER_LOC)\n \n extern void dump_function (int phase, tree fn);\n extern void print_combine_total_stats (void);"}, {"sha": "5b37052b5485ed10efc63deb91c2df6ad7ab8015", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "patch": "@@ -199,15 +199,16 @@ report_unroll (struct loop *loop, dump_location_t locus)\n   if (!dump_enabled_p ())\n     return;\n \n-  dump_printf_loc (report_flags, locus,\n+  dump_metadata_t metadata (report_flags, locus.get_impl_location ());\n+  dump_printf_loc (metadata, locus.get_user_location (),\n                    \"loop unrolled %d times\",\n                    loop->lpt_decision.times);\n   if (profile_info && loop->header->count.initialized_p ())\n-    dump_printf (report_flags,\n+    dump_printf (metadata,\n                  \" (header execution count %d)\",\n                  (int)loop->header->count.to_gcov_type ());\n \n-  dump_printf (report_flags, \"\\n\");\n+  dump_printf (metadata, \"\\n\");\n }\n \n /* Decide whether unroll loops and how much.  */"}, {"sha": "c781ee33237ff513b7efbdfd2d288b2412f5c8ab", "filename": "gcc/opt-problem.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fopt-problem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fopt-problem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopt-problem.cc?ref=3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "patch": "@@ -54,7 +54,7 @@ opt_problem::opt_problem (const dump_location_t &loc,\n \n   /* Print the location to the \"immediate\" dump destinations.  */\n   dump_context &dc = dump_context::get ();\n-  dc.dump_loc (MSG_MISSED_OPTIMIZATION, loc);\n+  dc.dump_loc (MSG_MISSED_OPTIMIZATION, loc.get_user_location ());\n \n   /* Print the formatted string to this opt_problem's optinfo, dumping\n      the items to the \"immediate\" dump destinations, and storing items"}, {"sha": "f28a0e3cb5b7f3f57f4f09fb39ab3df98228d8df", "filename": "gcc/optinfo-emit-json.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Foptinfo-emit-json.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Foptinfo-emit-json.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo-emit-json.cc?ref=3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "patch": "@@ -453,7 +453,7 @@ static void\n test_building_json_from_dump_calls ()\n {\n   temp_dump_context tmp (true, true, MSG_NOTE);\n-  dump_location_t loc;\n+  dump_user_location_t loc;\n   dump_printf_loc (MSG_NOTE, loc, \"test of tree: \");\n   dump_generic_expr (MSG_NOTE, TDF_SLIM, integer_zero_node);\n   optinfo *info = tmp.get_pending_optinfo ();"}, {"sha": "314fcbf3e226846dec6bdde0d9d954d0c694793c", "filename": "gcc/optinfo.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Foptinfo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Foptinfo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptinfo.cc?ref=3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "patch": "@@ -118,7 +118,7 @@ optinfo::emit_for_opt_problem () const\n   dump_kind |= MSG_PRIORITY_REEMITTED;\n \n   /* Re-emit to \"immediate\" destinations, without creating a new optinfo.  */\n-  dump_context::get ().dump_loc_immediate (dump_kind, get_dump_location ());\n+  dump_context::get ().dump_loc_immediate (dump_kind, get_user_location ());\n   unsigned i;\n   optinfo_item *item;\n   FOR_EACH_VEC_ELT (m_items, i, item)"}, {"sha": "be6d3b8af7e105c41e7758f8cb5ee53e695728a8", "filename": "gcc/profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "patch": "@@ -577,7 +577,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n            {\n              informed = 1;\n              dump_printf_loc (MSG_NOTE,\n-\t\t\t      dump_location_t::from_location_t (input_location),\n+\t\t\t      dump_user_location_t::from_location_t (input_location),\n                               \"correcting inconsistent profile data\\n\");\n            }\n          correct_negative_edge_counts ();"}, {"sha": "2d7cc3b55e3f79b7c2c6039ece46766e6e533ce5", "filename": "gcc/selftest.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fselftest.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Fselftest.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fselftest.h?ref=3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "patch": "@@ -436,6 +436,15 @@ extern int num_passes;\n \t\t\t\t   (HAYSTACK), (NEEDLE));\t\t\\\n   SELFTEST_END_STMT\n \n+/* Like ASSERT_STR_CONTAINS, but treat LOC as the effective location of the\n+   selftest.  */\n+\n+#define ASSERT_STR_CONTAINS_AT(LOC, HAYSTACK, NEEDLE)\t\t\t\\\n+  SELFTEST_BEGIN_STMT\t\t\t\t\t\t\t\\\n+  ::selftest::assert_str_contains (LOC, #HAYSTACK, #NEEDLE,\t\t\\\n+\t\t\t\t   (HAYSTACK), (NEEDLE));\t\t\\\n+  SELFTEST_END_STMT\n+\n /* Evaluate STR and PREFIX and determine if STR starts with PREFIX.\n      ::selftest::pass if STR does start with PREFIX.\n      ::selftest::fail if does not, or either is NULL.  */"}, {"sha": "40c4584d6258f28c294ff18da6715772a0866c4a", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3da39f52ff740ad4263a000c48fd5a6d9afd18fd/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=3da39f52ff740ad4263a000c48fd5a6d9afd18fd", "patch": "@@ -1457,14 +1457,16 @@ vect_print_slp_tree (dump_flags_t dump_kind, dump_location_t loc,\n   if (visited.add (node))\n     return;\n \n-  dump_printf_loc (dump_kind, loc, \"node%s %p\\n\",\n+  dump_metadata_t metadata (dump_kind, loc.get_impl_location ());\n+  dump_user_location_t user_loc = loc.get_user_location ();\n+  dump_printf_loc (metadata, user_loc, \"node%s %p\\n\",\n \t\t   SLP_TREE_DEF_TYPE (node) != vect_internal_def\n \t\t   ? \" (external)\" : \"\", node);\n   FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n-    dump_printf_loc (dump_kind, loc, \"\\tstmt %d %G\", i, stmt_info->stmt);\n+    dump_printf_loc (metadata, user_loc, \"\\tstmt %d %G\", i, stmt_info->stmt);\n   if (SLP_TREE_CHILDREN (node).is_empty ())\n     return;\n-  dump_printf_loc (dump_kind, loc, \"\\tchildren\");\n+  dump_printf_loc (metadata, user_loc, \"\\tchildren\");\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     dump_printf (dump_kind, \" %p\", (void *)child);\n   dump_printf (dump_kind, \"\\n\");"}]}