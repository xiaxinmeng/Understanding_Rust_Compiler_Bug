{"sha": "14ea9f928340edb0812a0f3492563939fe9c9817", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTRlYTlmOTI4MzQwZWRiMDgxMmEwZjM0OTI1NjM5MzlmZTljOTgxNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-10T12:31:05Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-10T12:31:05Z"}, "message": "fold-const.c (distribute_bit_expr): Remove.\n\n2015-07-10  Richard Biener  <rguenther@suse.de>\n\n\t* fold-const.c (distribute_bit_expr): Remove.\n\t(fold_binary_loc): Move simplifying (A & C1) + (B & C2)\n\tto (A & C1) | (B & C2), distributing (A & B) | (A & C)\n\tto A & (B | C) and simplifying A << C1 << C2 to ...\n\t* match.pd: ... patterns here.\n\nFrom-SVN: r225670", "tree": {"sha": "cd41208aa52a6631034a5aa10e6e3c96f077fc6e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd41208aa52a6631034a5aa10e6e3c96f077fc6e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/14ea9f928340edb0812a0f3492563939fe9c9817", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14ea9f928340edb0812a0f3492563939fe9c9817", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14ea9f928340edb0812a0f3492563939fe9c9817", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14ea9f928340edb0812a0f3492563939fe9c9817/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "53021678c582ec1afd38f0ed03fde6c433d639df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53021678c582ec1afd38f0ed03fde6c433d639df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53021678c582ec1afd38f0ed03fde6c433d639df"}], "stats": {"total": 165, "additions": 51, "deletions": 114}, "files": [{"sha": "5cfac4e9278fcd73c2b59b508fc43636c1026c03", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14ea9f928340edb0812a0f3492563939fe9c9817/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14ea9f928340edb0812a0f3492563939fe9c9817/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=14ea9f928340edb0812a0f3492563939fe9c9817", "patch": "@@ -1,3 +1,11 @@\n+2015-07-10  Richard Biener  <rguenther@suse.de>\n+\n+\t* fold-const.c (distribute_bit_expr): Remove.\n+\t(fold_binary_loc): Move simplifying (A & C1) + (B & C2)\n+\tto (A & C1) | (B & C2), distributing (A & B) | (A & C)\n+\tto A & (B | C) and simplifying A << C1 << C2 to ...\n+\t* match.pd: ... patterns here.\n+\n 2015-07-10  Jiong Wang  <jiong.wang@arm.com>\n \n \t* config/aarch64/aarch64.c (aarch64_load_symref_appropriately): Mark mem"}, {"sha": "7078edb16346a7abd8c02f2fd832d52a13a2a90f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14ea9f928340edb0812a0f3492563939fe9c9817/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14ea9f928340edb0812a0f3492563939fe9c9817/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=14ea9f928340edb0812a0f3492563939fe9c9817", "patch": "@@ -118,7 +118,6 @@ static enum tree_code compcode_to_comparison (enum comparison_code);\n static int operand_equal_for_comparison_p (tree, tree, tree);\n static int twoval_comparison_p (tree, tree *, tree *, int *);\n static tree eval_subst (location_t, tree, tree, tree, tree, tree);\n-static tree distribute_bit_expr (location_t, enum tree_code, tree, tree, tree);\n static tree make_bit_field_ref (location_t, tree, tree,\n \t\t\t\tHOST_WIDE_INT, HOST_WIDE_INT, int);\n static tree optimize_bit_field_compare (location_t, enum tree_code,\n@@ -3550,62 +3549,6 @@ invert_truthvalue_loc (location_t loc, tree arg)\n \t\t\t  type, arg);\n }\n \n-/* Given a bit-wise operation CODE applied to ARG0 and ARG1, see if both\n-   operands are another bit-wise operation with a common input.  If so,\n-   distribute the bit operations to save an operation and possibly two if\n-   constants are involved.  For example, convert\n-\t(A | B) & (A | C) into A | (B & C)\n-   Further simplification will occur if B and C are constants.\n-\n-   If this optimization cannot be done, 0 will be returned.  */\n-\n-static tree\n-distribute_bit_expr (location_t loc, enum tree_code code, tree type,\n-\t\t     tree arg0, tree arg1)\n-{\n-  tree common;\n-  tree left, right;\n-\n-  if (TREE_CODE (arg0) != TREE_CODE (arg1)\n-      || TREE_CODE (arg0) == code\n-      || (TREE_CODE (arg0) != BIT_AND_EXPR\n-\t  && TREE_CODE (arg0) != BIT_IOR_EXPR))\n-    return 0;\n-\n-  if (operand_equal_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg1, 0), 0))\n-    {\n-      common = TREE_OPERAND (arg0, 0);\n-      left = TREE_OPERAND (arg0, 1);\n-      right = TREE_OPERAND (arg1, 1);\n-    }\n-  else if (operand_equal_p (TREE_OPERAND (arg0, 0), TREE_OPERAND (arg1, 1), 0))\n-    {\n-      common = TREE_OPERAND (arg0, 0);\n-      left = TREE_OPERAND (arg0, 1);\n-      right = TREE_OPERAND (arg1, 0);\n-    }\n-  else if (operand_equal_p (TREE_OPERAND (arg0, 1), TREE_OPERAND (arg1, 0), 0))\n-    {\n-      common = TREE_OPERAND (arg0, 1);\n-      left = TREE_OPERAND (arg0, 0);\n-      right = TREE_OPERAND (arg1, 1);\n-    }\n-  else if (operand_equal_p (TREE_OPERAND (arg0, 1), TREE_OPERAND (arg1, 1), 0))\n-    {\n-      common = TREE_OPERAND (arg0, 1);\n-      left = TREE_OPERAND (arg0, 0);\n-      right = TREE_OPERAND (arg1, 0);\n-    }\n-  else\n-    return 0;\n-\n-  common = fold_convert_loc (loc, type, common);\n-  left = fold_convert_loc (loc, type, left);\n-  right = fold_convert_loc (loc, type, right);\n-  return fold_build2_loc (loc, TREE_CODE (arg0), type, common,\n-\t\t      fold_build2_loc (loc, code, type, left, right));\n-}\n-\n /* Knowing that ARG0 and ARG1 are both RDIV_EXPRs, simplify a binary operation\n    with code CODE.  This optimization is unsafe.  */\n static tree\n@@ -9575,21 +9518,6 @@ fold_binary_loc (location_t loc,\n \n       if (! FLOAT_TYPE_P (type))\n \t{\n-\t  /* If we are adding two BIT_AND_EXPR's, both of which are and'ing\n-\t     with a constant, and the two constants have no bits in common,\n-\t     we should treat this as a BIT_IOR_EXPR since this may produce more\n-\t     simplifications.  */\n-\t  if (TREE_CODE (arg0) == BIT_AND_EXPR\n-\t      && TREE_CODE (arg1) == BIT_AND_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (arg0, 1)) == INTEGER_CST\n-\t      && TREE_CODE (TREE_OPERAND (arg1, 1)) == INTEGER_CST\n-\t      && wi::bit_and (TREE_OPERAND (arg0, 1),\n-\t\t\t      TREE_OPERAND (arg1, 1)) == 0)\n-\t    {\n-\t      code = BIT_IOR_EXPR;\n-\t      goto bit_ior;\n-\t    }\n-\n \t  /* Reassociate (plus (plus (mult) (foo)) (mult)) as\n \t     (plus (plus (mult) (mult)) (foo)) so that we can\n \t     take advantage of the factoring cases below.  */\n@@ -10423,7 +10351,6 @@ fold_binary_loc (location_t loc,\n       goto associate;\n \n     case BIT_IOR_EXPR:\n-    bit_ior:\n       /* Canonicalize (X & C1) | C2.  */\n       if (TREE_CODE (arg0) == BIT_AND_EXPR\n \t  && TREE_CODE (arg1) == INTEGER_CST\n@@ -10494,10 +10421,6 @@ fold_binary_loc (location_t loc,\n \t    return fold_build2_loc (loc, BIT_XOR_EXPR, type, l0, n1);\n \t}\n \n-      t1 = distribute_bit_expr (loc, code, type, arg0, arg1);\n-      if (t1 != NULL_TREE)\n-\treturn t1;\n-\n       /* See if this can be simplified into a rotate first.  If that\n \t is unsuccessful continue in the association code.  */\n       goto bit_rotate;\n@@ -10760,9 +10683,6 @@ fold_binary_loc (location_t loc,\n \t    }\n \t}\n \n-      t1 = distribute_bit_expr (loc, code, type, arg0, arg1);\n-      if (t1 != NULL_TREE)\n-\treturn t1;\n       /* Simplify ((int)c & 0377) into (int)c, if c is unsigned char.  */\n       if (TREE_CODE (arg1) == INTEGER_CST && TREE_CODE (arg0) == NOP_EXPR\n \t  && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (arg0, 0))))\n@@ -11111,32 +11031,6 @@ fold_binary_loc (location_t loc,\n \n       prec = element_precision (type);\n \n-      /* Turn (a OP c1) OP c2 into a OP (c1+c2).  */\n-      if (TREE_CODE (op0) == code && tree_fits_uhwi_p (arg1)\n-\t  && tree_to_uhwi (arg1) < prec\n-\t  && tree_fits_uhwi_p (TREE_OPERAND (arg0, 1))\n-\t  && tree_to_uhwi (TREE_OPERAND (arg0, 1)) < prec)\n-\t{\n-\t  unsigned int low = (tree_to_uhwi (TREE_OPERAND (arg0, 1))\n-\t\t\t      + tree_to_uhwi (arg1));\n-\n-\t  /* Deal with a OP (c1 + c2) being undefined but (a OP c1) OP c2\n-\t     being well defined.  */\n-\t  if (low >= prec)\n-\t    {\n-\t      if (code == LROTATE_EXPR || code == RROTATE_EXPR)\n-\t        low = low % prec;\n-\t      else if (TYPE_UNSIGNED (type) || code == LSHIFT_EXPR)\n-\t\treturn omit_one_operand_loc (loc, type, build_zero_cst (type),\n-\t\t\t\t\t TREE_OPERAND (arg0, 0));\n-\t      else\n-\t\tlow = prec - 1;\n-\t    }\n-\n-\t  return fold_build2_loc (loc, code, type, TREE_OPERAND (arg0, 0),\n-\t\t\t\t  build_int_cst (TREE_TYPE (arg1), low));\n-\t}\n-\n       /* Transform (x >> c) << c into x & (-1<<c), or transform (x << c) >> c\n          into x & ((unsigned)-1 >> c) for unsigned types.  */\n       if (((code == LSHIFT_EXPR && TREE_CODE (arg0) == RSHIFT_EXPR)"}, {"sha": "b991008b47f8ea77f4c1be40cd65b18343ae4fb1", "filename": "gcc/match.pd", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/14ea9f928340edb0812a0f3492563939fe9c9817/gcc%2Fmatch.pd", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/14ea9f928340edb0812a0f3492563939fe9c9817/gcc%2Fmatch.pd", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatch.pd?ref=14ea9f928340edb0812a0f3492563939fe9c9817", "patch": "@@ -419,17 +419,18 @@ along with GCC; see the file COPYING3.  If not see\n        && tree_nop_conversion_p (type, TREE_TYPE (@1)))\n    (bit_not (rop (convert @0) (convert @1))))))\n \n-/* If we are XORing two BIT_AND_EXPR's, both of which are and'ing\n+/* If we are XORing or adding two BIT_AND_EXPR's, both of which are and'ing\n    with a constant, and the two constants have no bits in common,\n    we should treat this as a BIT_IOR_EXPR since this may produce more\n    simplifications.  */\n-(simplify\n- (bit_xor (convert1? (bit_and@4 @0 INTEGER_CST@1))\n-          (convert2? (bit_and@5 @2 INTEGER_CST@3)))\n- (if (tree_nop_conversion_p (type, TREE_TYPE (@0))\n-      && tree_nop_conversion_p (type, TREE_TYPE (@2))\n-      && wi::bit_and (@1, @3) == 0)\n-  (bit_ior (convert @4) (convert @5))))\n+(for op (bit_xor plus)\n+ (simplify\n+  (op (convert1? (bit_and@4 @0 INTEGER_CST@1))\n+      (convert2? (bit_and@5 @2 INTEGER_CST@3)))\n+  (if (tree_nop_conversion_p (type, TREE_TYPE (@0))\n+       && tree_nop_conversion_p (type, TREE_TYPE (@2))\n+       && wi::bit_and (@1, @3) == 0)\n+   (bit_ior (convert @4) (convert @5)))))\n \n /* (X | Y) ^ X -> Y & ~ X*/\n (simplify\n@@ -455,6 +456,19 @@ along with GCC; see the file COPYING3.  If not see\n  (bit_xor:c (bit_and:c @0 @1) @1)\n  (bit_and (bit_not @0) @1))\n \n+/* Given a bit-wise operation CODE applied to ARG0 and ARG1, see if both\n+   operands are another bit-wise operation with a common input.  If so,\n+   distribute the bit operations to save an operation and possibly two if\n+   constants are involved.  For example, convert\n+     (A | B) & (A | C) into A | (B & C)\n+   Further simplification will occur if B and C are constants.  */\n+(for op (bit_and bit_ior)\n+     rop (bit_ior bit_and)\n+ (simplify\n+  (op (convert? (rop:c @0 @1)) (convert? (rop @0 @2)))\n+  (if (tree_nop_conversion_p (type, TREE_TYPE (@0)))\n+   (rop (convert @0) (op (convert @1) (convert @2))))))\n+\n \n (simplify\n  (abs (abs@1 @0))\n@@ -880,6 +894,27 @@ along with GCC; see the file COPYING3.  If not see\n \t\t\t    build_int_cst (TREE_TYPE (@1),\n \t\t\t\t\t   element_precision (type)), @1); }))\n \n+/* Turn (a OP c1) OP c2 into a OP (c1+c2).  */\n+(for op (lrotate rrotate rshift lshift)\n+ (simplify\n+  (op (op @0 INTEGER_CST@1) INTEGER_CST@2)\n+  (with { unsigned int prec = element_precision (type); }\n+   (if (wi::ge_p (@1, 0, TYPE_SIGN (TREE_TYPE (@1)))\n+        && wi::lt_p (@1, prec, TYPE_SIGN (TREE_TYPE (@1)))\n+        && wi::ge_p (@2, 0, TYPE_SIGN (TREE_TYPE (@2)))\n+\t&& wi::lt_p (@2, prec, TYPE_SIGN (TREE_TYPE (@2))))\n+    (with { unsigned int low = wi::add (@1, @2).to_uhwi (); }\n+     /* Deal with a OP (c1 + c2) being undefined but (a OP c1) OP c2\n+        being well defined.  */\n+     (if (low >= prec)\n+      (if (op == LROTATE_EXPR || op == RROTATE_EXPR)\n+       (op @0 { build_int_cst (TREE_TYPE (@1), low % prec); }))\n+      (if (TYPE_UNSIGNED (type) || code == LSHIFT_EXPR)\n+       { build_zero_cst (type); })\n+      (op @0 { build_int_cst (TREE_TYPE (@1), prec - 1); }))\n+     (op @0 { build_int_cst (TREE_TYPE (@1), low); }))))))\n+\n+\n /* ((1 << A) & 1) != 0 -> A == 0\n    ((1 << A) & 1) == 0 -> A != 0 */\n (for cmp (ne eq)"}]}