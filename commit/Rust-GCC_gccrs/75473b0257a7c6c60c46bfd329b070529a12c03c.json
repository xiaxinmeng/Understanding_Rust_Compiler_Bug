{"sha": "75473b0257a7c6c60c46bfd329b070529a12c03c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzU0NzNiMDI1N2E3YzZjNjBjNDZiZmQzMjliMDcwNTI5YTEyYzAzYw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-11-02T17:59:46Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-11-02T17:59:46Z"}, "message": "cfgloop.h (struct loop): Update comment.\n\n\t* cfgloop.h (struct loop): Update comment.\n\t* cse.c (cse_main): Remove obsolete comment.\n\n\t* expr.h (gen_cond_trap): Move prototype under functions provided\n\tby optabs.c.\n\t(canonicalize_condition, get_condition): Move to...\n\t* rtl.h (canonicalize_condition, get_condition): ...here.\n\t(branch_target_load_optimize): Add comment that this function is\n\tin bt-load.c.\n\t* loop.c (canonicalize_condition, get_condition): Move to...\n\t* rtlanal.c (canonicalize_condition, get_condition): ...here.\n\t* sched-deps.c (get_condition): Rename to sched_get_condition.\n\t(add_dependence): Update this caller.\n\nFrom-SVN: r89995", "tree": {"sha": "ce74266679e739b6b67a76a1605aab9369fb1ee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce74266679e739b6b67a76a1605aab9369fb1ee5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75473b0257a7c6c60c46bfd329b070529a12c03c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75473b0257a7c6c60c46bfd329b070529a12c03c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75473b0257a7c6c60c46bfd329b070529a12c03c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75473b0257a7c6c60c46bfd329b070529a12c03c/comments", "author": null, "committer": null, "parents": [{"sha": "65e9700cc0554d17492c4d28abd1e9bf68454c9a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65e9700cc0554d17492c4d28abd1e9bf68454c9a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65e9700cc0554d17492c4d28abd1e9bf68454c9a"}], "stats": {"total": 686, "additions": 350, "deletions": 336}, "files": [{"sha": "f6c687404fe96c72fc71fec8e0214deda69d201f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=75473b0257a7c6c60c46bfd329b070529a12c03c", "patch": "@@ -1,3 +1,19 @@\n+2004-11-02  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* cfgloop.h (struct loop): Update comment.\n+\t* cse.c (cse_main): Remove obsolete comment.\n+\n+\t* expr.h (gen_cond_trap): Move prototype under functions provided\n+\tby optabs.c.\n+\t(canonicalize_condition, get_condition): Move to...\n+\t* rtl.h (canonicalize_condition, get_condition): ...here.\n+\t(branch_target_load_optimize): Add comment that this function is\n+\tin bt-load.c.\n+\t* loop.c (canonicalize_condition, get_condition): Move to...\n+\t* rtlanal.c (canonicalize_condition, get_condition): ...here.\n+\t* sched-deps.c (get_condition): Rename to sched_get_condition.\n+\t(add_dependence): Update this caller.\n+ \n 2004-11-02  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/16808"}, {"sha": "3261adb8e2d8a5db68f024e4e93f34760d1d103f", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=75473b0257a7c6c60c46bfd329b070529a12c03c", "patch": "@@ -144,7 +144,7 @@ struct loop\n   void *aux;\n \n   /* The following are currently used by loop.c but they are likely to\n-     disappear as loop.c is converted to use the CFG.  */\n+     disappear when loop.c is replaced and removed.  */\n \n   /* The NOTE_INSN_LOOP_BEG.  */\n   rtx start;"}, {"sha": "19e7f7145cf94f6c9434642ffa77c61a822d19d7", "filename": "gcc/cse.c", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=75473b0257a7c6c60c46bfd329b070529a12c03c", "patch": "@@ -6775,11 +6775,7 @@ cse_main (rtx f, int nregs, FILE *file)\n \n /* Process a single basic block.  FROM and TO and the limits of the basic\n    block.  NEXT_BRANCH points to the branch path when following jumps or\n-   a null path when not following jumps.\n-\n-   AROUND_LOOP is nonzero if we are to try to cse around to the start of a\n-   loop.  This is true when we are being called for the last time on a\n-   block and this CSE pass is before loop.c.  */\n+   a null path when not following jumps.  */\n \n static rtx\n cse_basic_block (rtx from, rtx to, struct branch_path *next_branch)"}, {"sha": "b5ec33f02bf28843110e579439d2c22646f8ba93", "filename": "gcc/expr.h", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=75473b0257a7c6c60c46bfd329b070529a12c03c", "patch": "@@ -298,6 +298,9 @@ extern void emit_cmp_and_jump_insns (rtx, rtx, enum rtx_code, rtx,\n /* Generate code to indirectly jump to a location given in the rtx LOC.  */\n extern void emit_indirect_jump (rtx);\n \n+/* Generate a conditional trap instruction.  */\n+extern rtx gen_cond_trap (enum rtx_code, rtx, rtx, rtx);\n+\n #include \"insn-config.h\"\n \n #ifdef HAVE_conditional_move\n@@ -329,19 +332,6 @@ extern rtx emit_store_flag (rtx, enum rtx_code, rtx, rtx, enum machine_mode,\n /* Like emit_store_flag, but always succeeds.  */\n extern rtx emit_store_flag_force (rtx, enum rtx_code, rtx, rtx,\n \t\t\t\t  enum machine_mode, int, int);\n-\n-/* Functions from loop.c:  */\n-\n-/* Given an insn and condition, return a canonical description of\n-   the test being made.  */\n-extern rtx canonicalize_condition (rtx, rtx, int, rtx *, rtx, int, int);\n-\n-/* Given a JUMP_INSN, return a canonical description of the test\n-   being made.  */\n-extern rtx get_condition (rtx, rtx *, int, int);\n-\n-/* Generate a conditional trap instruction.  */\n-extern rtx gen_cond_trap (enum rtx_code, rtx, rtx, rtx);\n \f\n /* Functions from builtins.c:  */\n extern rtx expand_builtin (tree, rtx, rtx, enum machine_mode, int);"}, {"sha": "08b85293b8aa9df19bda8884a87f63fed62a6334", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 313, "changes": 315, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=75473b0257a7c6c60c46bfd329b070529a12c03c", "patch": "@@ -10438,319 +10438,8 @@ update_reg_last_use (rtx x, rtx insn)\n     }\n }\n \f\n-/* Given an insn INSN and condition COND, return the condition in a\n-   canonical form to simplify testing by callers.  Specifically:\n-\n-   (1) The code will always be a comparison operation (EQ, NE, GT, etc.).\n-   (2) Both operands will be machine operands; (cc0) will have been replaced.\n-   (3) If an operand is a constant, it will be the second operand.\n-   (4) (LE x const) will be replaced with (LT x <const+1>) and similarly\n-       for GE, GEU, and LEU.\n-\n-   If the condition cannot be understood, or is an inequality floating-point\n-   comparison which needs to be reversed, 0 will be returned.\n-\n-   If REVERSE is nonzero, then reverse the condition prior to canonizing it.\n-\n-   If EARLIEST is nonzero, it is a pointer to a place where the earliest\n-   insn used in locating the condition was found.  If a replacement test\n-   of the condition is desired, it should be placed in front of that\n-   insn and we will be sure that the inputs are still valid.\n-\n-   If WANT_REG is nonzero, we wish the condition to be relative to that\n-   register, if possible.  Therefore, do not canonicalize the condition\n-   further.  If ALLOW_CC_MODE is nonzero, allow the condition returned \n-   to be a compare to a CC mode register.\n-\n-   If VALID_AT_INSN_P, the condition must be valid at both *EARLIEST\n-   and at INSN.  */\n-\n-rtx\n-canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n-\t\t\trtx want_reg, int allow_cc_mode, int valid_at_insn_p)\n-{\n-  enum rtx_code code;\n-  rtx prev = insn;\n-  rtx set;\n-  rtx tem;\n-  rtx op0, op1;\n-  int reverse_code = 0;\n-  enum machine_mode mode;\n-\n-  code = GET_CODE (cond);\n-  mode = GET_MODE (cond);\n-  op0 = XEXP (cond, 0);\n-  op1 = XEXP (cond, 1);\n-\n-  if (reverse)\n-    code = reversed_comparison_code (cond, insn);\n-  if (code == UNKNOWN)\n-    return 0;\n-\n-  if (earliest)\n-    *earliest = insn;\n-\n-  /* If we are comparing a register with zero, see if the register is set\n-     in the previous insn to a COMPARE or a comparison operation.  Perform\n-     the same tests as a function of STORE_FLAG_VALUE as find_comparison_args\n-     in cse.c  */\n-\n-  while ((GET_RTX_CLASS (code) == RTX_COMPARE\n-\t  || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n-\t && op1 == CONST0_RTX (GET_MODE (op0))\n-\t && op0 != want_reg)\n-    {\n-      /* Set nonzero when we find something of interest.  */\n-      rtx x = 0;\n-\n-#ifdef HAVE_cc0\n-      /* If comparison with cc0, import actual comparison from compare\n-\t insn.  */\n-      if (op0 == cc0_rtx)\n-\t{\n-\t  if ((prev = prev_nonnote_insn (prev)) == 0\n-\t      || !NONJUMP_INSN_P (prev)\n-\t      || (set = single_set (prev)) == 0\n-\t      || SET_DEST (set) != cc0_rtx)\n-\t    return 0;\n-\n-\t  op0 = SET_SRC (set);\n-\t  op1 = CONST0_RTX (GET_MODE (op0));\n-\t  if (earliest)\n-\t    *earliest = prev;\n-\t}\n-#endif\n-\n-      /* If this is a COMPARE, pick up the two things being compared.  */\n-      if (GET_CODE (op0) == COMPARE)\n-\t{\n-\t  op1 = XEXP (op0, 1);\n-\t  op0 = XEXP (op0, 0);\n-\t  continue;\n-\t}\n-      else if (!REG_P (op0))\n-\tbreak;\n-\n-      /* Go back to the previous insn.  Stop if it is not an INSN.  We also\n-\t stop if it isn't a single set or if it has a REG_INC note because\n-\t we don't want to bother dealing with it.  */\n-\n-      if ((prev = prev_nonnote_insn (prev)) == 0\n-\t  || !NONJUMP_INSN_P (prev)\n-\t  || FIND_REG_INC_NOTE (prev, NULL_RTX))\n-\tbreak;\n-\n-      set = set_of (op0, prev);\n-\n-      if (set\n-\t  && (GET_CODE (set) != SET\n-\t      || !rtx_equal_p (SET_DEST (set), op0)))\n-\tbreak;\n-\n-      /* If this is setting OP0, get what it sets it to if it looks\n-\t relevant.  */\n-      if (set)\n-\t{\n-\t  enum machine_mode inner_mode = GET_MODE (SET_DEST (set));\n-#ifdef FLOAT_STORE_FLAG_VALUE\n-\t  REAL_VALUE_TYPE fsfv;\n-#endif\n-\n-\t  /* ??? We may not combine comparisons done in a CCmode with\n-\t     comparisons not done in a CCmode.  This is to aid targets\n-\t     like Alpha that have an IEEE compliant EQ instruction, and\n-\t     a non-IEEE compliant BEQ instruction.  The use of CCmode is\n-\t     actually artificial, simply to prevent the combination, but\n-\t     should not affect other platforms.\n-\n-\t     However, we must allow VOIDmode comparisons to match either\n-\t     CCmode or non-CCmode comparison, because some ports have\n-\t     modeless comparisons inside branch patterns.\n-\n-\t     ??? This mode check should perhaps look more like the mode check\n-\t     in simplify_comparison in combine.  */\n-\n-\t  if ((GET_CODE (SET_SRC (set)) == COMPARE\n-\t       || (((code == NE\n-\t\t     || (code == LT\n-\t\t\t && GET_MODE_CLASS (inner_mode) == MODE_INT\n-\t\t\t && (GET_MODE_BITSIZE (inner_mode)\n-\t\t\t     <= HOST_BITS_PER_WIDE_INT)\n-\t\t\t && (STORE_FLAG_VALUE\n-\t\t\t     & ((HOST_WIDE_INT) 1\n-\t\t\t\t<< (GET_MODE_BITSIZE (inner_mode) - 1))))\n-#ifdef FLOAT_STORE_FLAG_VALUE\n-\t\t     || (code == LT\n-\t\t\t && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n-\t\t\t && (fsfv = FLOAT_STORE_FLAG_VALUE (inner_mode),\n-\t\t\t     REAL_VALUE_NEGATIVE (fsfv)))\n-#endif\n-\t\t     ))\n-\t\t   && COMPARISON_P (SET_SRC (set))))\n-\t      && (((GET_MODE_CLASS (mode) == MODE_CC)\n-\t\t   == (GET_MODE_CLASS (inner_mode) == MODE_CC))\n-\t\t  || mode == VOIDmode || inner_mode == VOIDmode))\n-\t    x = SET_SRC (set);\n-\t  else if (((code == EQ\n-\t\t     || (code == GE\n-\t\t\t && (GET_MODE_BITSIZE (inner_mode)\n-\t\t\t     <= HOST_BITS_PER_WIDE_INT)\n-\t\t\t && GET_MODE_CLASS (inner_mode) == MODE_INT\n-\t\t\t && (STORE_FLAG_VALUE\n-\t\t\t     & ((HOST_WIDE_INT) 1\n-\t\t\t\t<< (GET_MODE_BITSIZE (inner_mode) - 1))))\n-#ifdef FLOAT_STORE_FLAG_VALUE\n-\t\t     || (code == GE\n-\t\t\t && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n-\t\t\t && (fsfv = FLOAT_STORE_FLAG_VALUE (inner_mode),\n-\t\t\t     REAL_VALUE_NEGATIVE (fsfv)))\n-#endif\n-\t\t     ))\n-\t\t   && COMPARISON_P (SET_SRC (set))\n-\t\t   && (((GET_MODE_CLASS (mode) == MODE_CC)\n-\t\t\t== (GET_MODE_CLASS (inner_mode) == MODE_CC))\n-\t\t       || mode == VOIDmode || inner_mode == VOIDmode))\n-\n-\t    {\n-\t      reverse_code = 1;\n-\t      x = SET_SRC (set);\n-\t    }\n-\t  else\n-\t    break;\n-\t}\n-\n-      else if (reg_set_p (op0, prev))\n-\t/* If this sets OP0, but not directly, we have to give up.  */\n-\tbreak;\n-\n-      if (x)\n-\t{\n-\t  /* If the caller is expecting the condition to be valid at INSN,\n-\t     make sure X doesn't change before INSN.  */\n-\t  if (valid_at_insn_p)\n-\t    if (modified_in_p (x, prev) || modified_between_p (x, prev, insn))\n-\t      break;\n-\t  if (COMPARISON_P (x))\n-\t    code = GET_CODE (x);\n-\t  if (reverse_code)\n-\t    {\n-\t      code = reversed_comparison_code (x, prev);\n-\t      if (code == UNKNOWN)\n-\t\treturn 0;\n-\t      reverse_code = 0;\n-\t    }\n-\n-\t  op0 = XEXP (x, 0), op1 = XEXP (x, 1);\n-\t  if (earliest)\n-\t    *earliest = prev;\n-\t}\n-    }\n-\n-  /* If constant is first, put it last.  */\n-  if (CONSTANT_P (op0))\n-    code = swap_condition (code), tem = op0, op0 = op1, op1 = tem;\n-\n-  /* If OP0 is the result of a comparison, we weren't able to find what\n-     was really being compared, so fail.  */\n-  if (!allow_cc_mode\n-      && GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n-    return 0;\n-\n-  /* Canonicalize any ordered comparison with integers involving equality\n-     if we can do computations in the relevant mode and we do not\n-     overflow.  */\n-\n-  if (GET_MODE_CLASS (GET_MODE (op0)) != MODE_CC\n-      && GET_CODE (op1) == CONST_INT\n-      && GET_MODE (op0) != VOIDmode\n-      && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT)\n-    {\n-      HOST_WIDE_INT const_val = INTVAL (op1);\n-      unsigned HOST_WIDE_INT uconst_val = const_val;\n-      unsigned HOST_WIDE_INT max_val\n-\t= (unsigned HOST_WIDE_INT) GET_MODE_MASK (GET_MODE (op0));\n-\n-      switch (code)\n-\t{\n-\tcase LE:\n-\t  if ((unsigned HOST_WIDE_INT) const_val != max_val >> 1)\n-\t    code = LT, op1 = gen_int_mode (const_val + 1, GET_MODE (op0));\n-\t  break;\n-\n-\t/* When cross-compiling, const_val might be sign-extended from\n-\t   BITS_PER_WORD to HOST_BITS_PER_WIDE_INT */\n-\tcase GE:\n-\t  if ((HOST_WIDE_INT) (const_val & max_val)\n-\t      != (((HOST_WIDE_INT) 1\n-\t\t   << (GET_MODE_BITSIZE (GET_MODE (op0)) - 1))))\n-\t    code = GT, op1 = gen_int_mode (const_val - 1, GET_MODE (op0));\n-\t  break;\n-\n-\tcase LEU:\n-\t  if (uconst_val < max_val)\n-\t    code = LTU, op1 = gen_int_mode (uconst_val + 1, GET_MODE (op0));\n-\t  break;\n-\n-\tcase GEU:\n-\t  if (uconst_val != 0)\n-\t    code = GTU, op1 = gen_int_mode (uconst_val - 1, GET_MODE (op0));\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-\n-  /* Never return CC0; return zero instead.  */\n-  if (CC0_P (op0))\n-    return 0;\n-\n-  return gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n-}\n-\n-/* Given a jump insn JUMP, return the condition that will cause it to branch\n-   to its JUMP_LABEL.  If the condition cannot be understood, or is an\n-   inequality floating-point comparison which needs to be reversed, 0 will\n-   be returned.\n-\n-   If EARLIEST is nonzero, it is a pointer to a place where the earliest\n-   insn used in locating the condition was found.  If a replacement test\n-   of the condition is desired, it should be placed in front of that\n-   insn and we will be sure that the inputs are still valid.  If EARLIEST\n-   is null, the returned condition will be valid at INSN.\n-\n-   If ALLOW_CC_MODE is nonzero, allow the condition returned to be a\n-   compare CC mode register.\n-\n-   VALID_AT_INSN_P is the same as for canonicalize_condition.  */\n-\n-rtx\n-get_condition (rtx jump, rtx *earliest, int allow_cc_mode, int valid_at_insn_p)\n-{\n-  rtx cond;\n-  int reverse;\n-  rtx set;\n-\n-  /* If this is not a standard conditional jump, we can't parse it.  */\n-  if (!JUMP_P (jump)\n-      || ! any_condjump_p (jump))\n-    return 0;\n-  set = pc_set (jump);\n-\n-  cond = XEXP (SET_SRC (set), 0);\n-\n-  /* If this branches to JUMP_LABEL when the condition is false, reverse\n-     the condition.  */\n-  reverse\n-    = GET_CODE (XEXP (SET_SRC (set), 2)) == LABEL_REF\n-      && XEXP (XEXP (SET_SRC (set), 2), 0) == JUMP_LABEL (jump);\n-\n-  return canonicalize_condition (jump, cond, reverse, earliest, NULL_RTX,\n-\t\t\t\t allow_cc_mode, valid_at_insn_p);\n-}\n-\n-/* Similar to above routine, except that we also put an invariant last\n-   unless both operands are invariants.  */\n+/* Similar to rtlanal.c:get_condition, except that we also put an\n+   invariant last unless both operands are invariants.  */\n \n static rtx\n get_condition_for_loop (const struct loop *loop, rtx x)"}, {"sha": "67eea8b04b9dbd235334d943b1dddecf255257db", "filename": "gcc/rtl.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=75473b0257a7c6c60c46bfd329b070529a12c03c", "patch": "@@ -1657,6 +1657,15 @@ extern bool keep_with_call_p (rtx);\n extern bool label_is_jump_target_p (rtx, rtx);\n extern int insn_rtx_cost (rtx);\n \n+/* Given an insn and condition, return a canonical description of\n+   the test being made.  */\n+extern rtx canonicalize_condition (rtx, rtx, int, rtx *, rtx, int, int);\n+\n+/* Given a JUMP_INSN, return a canonical description of the test\n+   being made.  */\n+extern rtx get_condition (rtx, rtx *, int, int);\n+\n+\n /* flow.c */\n \n extern rtx find_use_as_address (rtx, rtx, HOST_WIDE_INT);\n@@ -2017,6 +2026,8 @@ extern void print_inline_rtx (FILE *, rtx, int);\n /* In loop.c */\n extern void init_loop (void);\n extern void loop_optimize (rtx, FILE *, int);\n+\n+/* In bt-load.c */\n extern void branch_target_load_optimize (bool);\n \n /* In function.c */"}, {"sha": "8ada3974c1b232ea5ed52095228174aa6accd340", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 312, "deletions": 0, "changes": 312, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=75473b0257a7c6c60c46bfd329b070529a12c03c", "patch": "@@ -4333,3 +4333,315 @@ insn_rtx_cost (rtx pat)\n   cost = rtx_cost (SET_SRC (set), SET);\n   return cost > 0 ? cost : COSTS_N_INSNS (1);\n }\n+\n+/* Given an insn INSN and condition COND, return the condition in a\n+   canonical form to simplify testing by callers.  Specifically:\n+\n+   (1) The code will always be a comparison operation (EQ, NE, GT, etc.).\n+   (2) Both operands will be machine operands; (cc0) will have been replaced.\n+   (3) If an operand is a constant, it will be the second operand.\n+   (4) (LE x const) will be replaced with (LT x <const+1>) and similarly\n+       for GE, GEU, and LEU.\n+\n+   If the condition cannot be understood, or is an inequality floating-point\n+   comparison which needs to be reversed, 0 will be returned.\n+\n+   If REVERSE is nonzero, then reverse the condition prior to canonizing it.\n+\n+   If EARLIEST is nonzero, it is a pointer to a place where the earliest\n+   insn used in locating the condition was found.  If a replacement test\n+   of the condition is desired, it should be placed in front of that\n+   insn and we will be sure that the inputs are still valid.\n+\n+   If WANT_REG is nonzero, we wish the condition to be relative to that\n+   register, if possible.  Therefore, do not canonicalize the condition\n+   further.  If ALLOW_CC_MODE is nonzero, allow the condition returned \n+   to be a compare to a CC mode register.\n+\n+   If VALID_AT_INSN_P, the condition must be valid at both *EARLIEST\n+   and at INSN.  */\n+\n+rtx\n+canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n+\t\t\trtx want_reg, int allow_cc_mode, int valid_at_insn_p)\n+{\n+  enum rtx_code code;\n+  rtx prev = insn;\n+  rtx set;\n+  rtx tem;\n+  rtx op0, op1;\n+  int reverse_code = 0;\n+  enum machine_mode mode;\n+\n+  code = GET_CODE (cond);\n+  mode = GET_MODE (cond);\n+  op0 = XEXP (cond, 0);\n+  op1 = XEXP (cond, 1);\n+\n+  if (reverse)\n+    code = reversed_comparison_code (cond, insn);\n+  if (code == UNKNOWN)\n+    return 0;\n+\n+  if (earliest)\n+    *earliest = insn;\n+\n+  /* If we are comparing a register with zero, see if the register is set\n+     in the previous insn to a COMPARE or a comparison operation.  Perform\n+     the same tests as a function of STORE_FLAG_VALUE as find_comparison_args\n+     in cse.c  */\n+\n+  while ((GET_RTX_CLASS (code) == RTX_COMPARE\n+\t  || GET_RTX_CLASS (code) == RTX_COMM_COMPARE)\n+\t && op1 == CONST0_RTX (GET_MODE (op0))\n+\t && op0 != want_reg)\n+    {\n+      /* Set nonzero when we find something of interest.  */\n+      rtx x = 0;\n+\n+#ifdef HAVE_cc0\n+      /* If comparison with cc0, import actual comparison from compare\n+\t insn.  */\n+      if (op0 == cc0_rtx)\n+\t{\n+\t  if ((prev = prev_nonnote_insn (prev)) == 0\n+\t      || !NONJUMP_INSN_P (prev)\n+\t      || (set = single_set (prev)) == 0\n+\t      || SET_DEST (set) != cc0_rtx)\n+\t    return 0;\n+\n+\t  op0 = SET_SRC (set);\n+\t  op1 = CONST0_RTX (GET_MODE (op0));\n+\t  if (earliest)\n+\t    *earliest = prev;\n+\t}\n+#endif\n+\n+      /* If this is a COMPARE, pick up the two things being compared.  */\n+      if (GET_CODE (op0) == COMPARE)\n+\t{\n+\t  op1 = XEXP (op0, 1);\n+\t  op0 = XEXP (op0, 0);\n+\t  continue;\n+\t}\n+      else if (!REG_P (op0))\n+\tbreak;\n+\n+      /* Go back to the previous insn.  Stop if it is not an INSN.  We also\n+\t stop if it isn't a single set or if it has a REG_INC note because\n+\t we don't want to bother dealing with it.  */\n+\n+      if ((prev = prev_nonnote_insn (prev)) == 0\n+\t  || !NONJUMP_INSN_P (prev)\n+\t  || FIND_REG_INC_NOTE (prev, NULL_RTX))\n+\tbreak;\n+\n+      set = set_of (op0, prev);\n+\n+      if (set\n+\t  && (GET_CODE (set) != SET\n+\t      || !rtx_equal_p (SET_DEST (set), op0)))\n+\tbreak;\n+\n+      /* If this is setting OP0, get what it sets it to if it looks\n+\t relevant.  */\n+      if (set)\n+\t{\n+\t  enum machine_mode inner_mode = GET_MODE (SET_DEST (set));\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t  REAL_VALUE_TYPE fsfv;\n+#endif\n+\n+\t  /* ??? We may not combine comparisons done in a CCmode with\n+\t     comparisons not done in a CCmode.  This is to aid targets\n+\t     like Alpha that have an IEEE compliant EQ instruction, and\n+\t     a non-IEEE compliant BEQ instruction.  The use of CCmode is\n+\t     actually artificial, simply to prevent the combination, but\n+\t     should not affect other platforms.\n+\n+\t     However, we must allow VOIDmode comparisons to match either\n+\t     CCmode or non-CCmode comparison, because some ports have\n+\t     modeless comparisons inside branch patterns.\n+\n+\t     ??? This mode check should perhaps look more like the mode check\n+\t     in simplify_comparison in combine.  */\n+\n+\t  if ((GET_CODE (SET_SRC (set)) == COMPARE\n+\t       || (((code == NE\n+\t\t     || (code == LT\n+\t\t\t && GET_MODE_CLASS (inner_mode) == MODE_INT\n+\t\t\t && (GET_MODE_BITSIZE (inner_mode)\n+\t\t\t     <= HOST_BITS_PER_WIDE_INT)\n+\t\t\t && (STORE_FLAG_VALUE\n+\t\t\t     & ((HOST_WIDE_INT) 1\n+\t\t\t\t<< (GET_MODE_BITSIZE (inner_mode) - 1))))\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t\t     || (code == LT\n+\t\t\t && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n+\t\t\t && (fsfv = FLOAT_STORE_FLAG_VALUE (inner_mode),\n+\t\t\t     REAL_VALUE_NEGATIVE (fsfv)))\n+#endif\n+\t\t     ))\n+\t\t   && COMPARISON_P (SET_SRC (set))))\n+\t      && (((GET_MODE_CLASS (mode) == MODE_CC)\n+\t\t   == (GET_MODE_CLASS (inner_mode) == MODE_CC))\n+\t\t  || mode == VOIDmode || inner_mode == VOIDmode))\n+\t    x = SET_SRC (set);\n+\t  else if (((code == EQ\n+\t\t     || (code == GE\n+\t\t\t && (GET_MODE_BITSIZE (inner_mode)\n+\t\t\t     <= HOST_BITS_PER_WIDE_INT)\n+\t\t\t && GET_MODE_CLASS (inner_mode) == MODE_INT\n+\t\t\t && (STORE_FLAG_VALUE\n+\t\t\t     & ((HOST_WIDE_INT) 1\n+\t\t\t\t<< (GET_MODE_BITSIZE (inner_mode) - 1))))\n+#ifdef FLOAT_STORE_FLAG_VALUE\n+\t\t     || (code == GE\n+\t\t\t && GET_MODE_CLASS (inner_mode) == MODE_FLOAT\n+\t\t\t && (fsfv = FLOAT_STORE_FLAG_VALUE (inner_mode),\n+\t\t\t     REAL_VALUE_NEGATIVE (fsfv)))\n+#endif\n+\t\t     ))\n+\t\t   && COMPARISON_P (SET_SRC (set))\n+\t\t   && (((GET_MODE_CLASS (mode) == MODE_CC)\n+\t\t\t== (GET_MODE_CLASS (inner_mode) == MODE_CC))\n+\t\t       || mode == VOIDmode || inner_mode == VOIDmode))\n+\n+\t    {\n+\t      reverse_code = 1;\n+\t      x = SET_SRC (set);\n+\t    }\n+\t  else\n+\t    break;\n+\t}\n+\n+      else if (reg_set_p (op0, prev))\n+\t/* If this sets OP0, but not directly, we have to give up.  */\n+\tbreak;\n+\n+      if (x)\n+\t{\n+\t  /* If the caller is expecting the condition to be valid at INSN,\n+\t     make sure X doesn't change before INSN.  */\n+\t  if (valid_at_insn_p)\n+\t    if (modified_in_p (x, prev) || modified_between_p (x, prev, insn))\n+\t      break;\n+\t  if (COMPARISON_P (x))\n+\t    code = GET_CODE (x);\n+\t  if (reverse_code)\n+\t    {\n+\t      code = reversed_comparison_code (x, prev);\n+\t      if (code == UNKNOWN)\n+\t\treturn 0;\n+\t      reverse_code = 0;\n+\t    }\n+\n+\t  op0 = XEXP (x, 0), op1 = XEXP (x, 1);\n+\t  if (earliest)\n+\t    *earliest = prev;\n+\t}\n+    }\n+\n+  /* If constant is first, put it last.  */\n+  if (CONSTANT_P (op0))\n+    code = swap_condition (code), tem = op0, op0 = op1, op1 = tem;\n+\n+  /* If OP0 is the result of a comparison, we weren't able to find what\n+     was really being compared, so fail.  */\n+  if (!allow_cc_mode\n+      && GET_MODE_CLASS (GET_MODE (op0)) == MODE_CC)\n+    return 0;\n+\n+  /* Canonicalize any ordered comparison with integers involving equality\n+     if we can do computations in the relevant mode and we do not\n+     overflow.  */\n+\n+  if (GET_MODE_CLASS (GET_MODE (op0)) != MODE_CC\n+      && GET_CODE (op1) == CONST_INT\n+      && GET_MODE (op0) != VOIDmode\n+      && GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT)\n+    {\n+      HOST_WIDE_INT const_val = INTVAL (op1);\n+      unsigned HOST_WIDE_INT uconst_val = const_val;\n+      unsigned HOST_WIDE_INT max_val\n+\t= (unsigned HOST_WIDE_INT) GET_MODE_MASK (GET_MODE (op0));\n+\n+      switch (code)\n+\t{\n+\tcase LE:\n+\t  if ((unsigned HOST_WIDE_INT) const_val != max_val >> 1)\n+\t    code = LT, op1 = gen_int_mode (const_val + 1, GET_MODE (op0));\n+\t  break;\n+\n+\t/* When cross-compiling, const_val might be sign-extended from\n+\t   BITS_PER_WORD to HOST_BITS_PER_WIDE_INT */\n+\tcase GE:\n+\t  if ((HOST_WIDE_INT) (const_val & max_val)\n+\t      != (((HOST_WIDE_INT) 1\n+\t\t   << (GET_MODE_BITSIZE (GET_MODE (op0)) - 1))))\n+\t    code = GT, op1 = gen_int_mode (const_val - 1, GET_MODE (op0));\n+\t  break;\n+\n+\tcase LEU:\n+\t  if (uconst_val < max_val)\n+\t    code = LTU, op1 = gen_int_mode (uconst_val + 1, GET_MODE (op0));\n+\t  break;\n+\n+\tcase GEU:\n+\t  if (uconst_val != 0)\n+\t    code = GTU, op1 = gen_int_mode (uconst_val - 1, GET_MODE (op0));\n+\t  break;\n+\n+\tdefault:\n+\t  break;\n+\t}\n+    }\n+\n+  /* Never return CC0; return zero instead.  */\n+  if (CC0_P (op0))\n+    return 0;\n+\n+  return gen_rtx_fmt_ee (code, VOIDmode, op0, op1);\n+}\n+\n+/* Given a jump insn JUMP, return the condition that will cause it to branch\n+   to its JUMP_LABEL.  If the condition cannot be understood, or is an\n+   inequality floating-point comparison which needs to be reversed, 0 will\n+   be returned.\n+\n+   If EARLIEST is nonzero, it is a pointer to a place where the earliest\n+   insn used in locating the condition was found.  If a replacement test\n+   of the condition is desired, it should be placed in front of that\n+   insn and we will be sure that the inputs are still valid.  If EARLIEST\n+   is null, the returned condition will be valid at INSN.\n+\n+   If ALLOW_CC_MODE is nonzero, allow the condition returned to be a\n+   compare CC mode register.\n+\n+   VALID_AT_INSN_P is the same as for canonicalize_condition.  */\n+\n+rtx\n+get_condition (rtx jump, rtx *earliest, int allow_cc_mode, int valid_at_insn_p)\n+{\n+  rtx cond;\n+  int reverse;\n+  rtx set;\n+\n+  /* If this is not a standard conditional jump, we can't parse it.  */\n+  if (!JUMP_P (jump)\n+      || ! any_condjump_p (jump))\n+    return 0;\n+  set = pc_set (jump);\n+\n+  cond = XEXP (SET_SRC (set), 0);\n+\n+  /* If this branches to JUMP_LABEL when the condition is false, reverse\n+     the condition.  */\n+  reverse\n+    = GET_CODE (XEXP (SET_SRC (set), 2)) == LABEL_REF\n+      && XEXP (XEXP (SET_SRC (set), 2), 0) == JUMP_LABEL (jump);\n+\n+  return canonicalize_condition (jump, cond, reverse, earliest, NULL_RTX,\n+\t\t\t\t allow_cc_mode, valid_at_insn_p);\n+}\n+"}, {"sha": "ef53ea602aaabbb077116698e7e9cd248e7320f6", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75473b0257a7c6c60c46bfd329b070529a12c03c/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=75473b0257a7c6c60c46bfd329b070529a12c03c", "patch": "@@ -101,7 +101,7 @@ static void sched_analyze_1 (struct deps *, rtx, rtx);\n static void sched_analyze_2 (struct deps *, rtx, rtx);\n static void sched_analyze_insn (struct deps *, rtx, rtx, rtx);\n \n-static rtx get_condition (rtx);\n+static rtx sched_get_condition (rtx);\n static int conditions_mutex_p (rtx, rtx);\n \f\n /* Return nonzero if a load of the memory reference MEM can cause a trap.  */\n@@ -138,7 +138,7 @@ find_insn_list (rtx insn, rtx list)\n /* Find the condition under which INSN is executed.  */\n \n static rtx\n-get_condition (rtx insn)\n+sched_get_condition (rtx insn)\n {\n   rtx pat = PATTERN (insn);\n   rtx src;\n@@ -218,8 +218,8 @@ add_dependence (rtx insn, rtx elem, enum reg_note dep_type)\n      be dependent.  */\n   if (!CALL_P (insn) && !CALL_P (elem))\n     {\n-      cond1 = get_condition (insn);\n-      cond2 = get_condition (elem);\n+      cond1 = sched_get_condition (insn);\n+      cond2 = sched_get_condition (elem);\n       if (cond1 && cond2\n \t  && conditions_mutex_p (cond1, cond2)\n \t  /* Make sure first instruction doesn't affect condition of second"}]}