{"sha": "4ab561180caefa229eaae824dee8d910c069f5ee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFiNTYxMTgwY2FlZmEyMjllYWFlODI0ZGVlOGQ5MTBjMDY5ZjVlZQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-08T10:51:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-02-08T10:51:58Z"}, "message": "Allow passing nonaligned BLKmode structs in regs.\n\n(struct arg_data): New fields aligned_regs and n_aligned_regs.\n(expand_call): Set and use these fields when required.\n(store_one_arg): Don't pass reg to emit_push_insn if we have previously\nformed aligned registers.\n\nFrom-SVN: r3440", "tree": {"sha": "096f0b584f4b1c0501ebb45297ef544b115baa20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/096f0b584f4b1c0501ebb45297ef544b115baa20"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ab561180caefa229eaae824dee8d910c069f5ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab561180caefa229eaae824dee8d910c069f5ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ab561180caefa229eaae824dee8d910c069f5ee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ab561180caefa229eaae824dee8d910c069f5ee/comments", "author": null, "committer": null, "parents": [{"sha": "cd048831883f3b3acdd4dc315cc44df8aea04ed0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd048831883f3b3acdd4dc315cc44df8aea04ed0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd048831883f3b3acdd4dc315cc44df8aea04ed0"}], "stats": {"total": 89, "additions": 85, "deletions": 4}, "files": [{"sha": "bd1229351427a3431d76816238d6148ec19a4ccb", "filename": "gcc/calls.c", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ab561180caefa229eaae824dee8d910c069f5ee/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ab561180caefa229eaae824dee8d910c069f5ee/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=4ab561180caefa229eaae824dee8d910c069f5ee", "patch": "@@ -84,6 +84,14 @@ struct arg_data\n   /* Place that this stack area has been saved, if needed.  */\n   rtx save_area;\n #endif\n+#ifdef STRICT_ALIGNMENT\n+  /* If an argument's alignment does not permit direct copying into registers,\n+     copy in smaller-sized pieces into pseudos.  These are stored in a\n+     block pointed to by this field.  The next field says how many\n+     word-sized pseudos we made.  */\n+  rtx *aligned_regs;\n+  int n_aligned_regs;\n+#endif\n };\n \n #ifdef ACCUMULATE_OUTGOING_ARGS\n@@ -514,7 +522,7 @@ expand_call (exp, target, ignore)\n   rtx use_insns = 0;\n \n   register tree p;\n-  register int i;\n+  register int i, j;\n \n   /* See if we can find a DECL-node for the actual function.\n      As a result, decide whether this is a call to an integrable function.  */\n@@ -625,8 +633,6 @@ expand_call (exp, target, ignore)\n       /* If inlining succeeded, return.  */\n       if ((HOST_WIDE_INT) temp != -1)\n \t{\n-\t  int i;\n-\n \t  /* Perform all cleanups needed for the arguments of this call\n \t     (i.e. destructors in C++).  It is ok if these destructors\n \t     clobber RETURN_VALUE_REG, because the only time we care about\n@@ -1529,6 +1535,63 @@ expand_call (exp, target, ignore)\n       store_one_arg (&args[i], argblock, may_be_alloca,\n \t\t     args_size.var != 0, fndecl, reg_parm_stack_space);\n \n+#ifdef STRICT_ALIGNMENT\n+  /* If we have a parm that is passed in registers but not in memory\n+     and whose alignment does not permit a direct copy into registers,\n+     make a group of pseudos that correspond to each register that we\n+     will later fill.  */\n+\n+  for (i = 0; i < num_actuals; i++)\n+    if (args[i].reg != 0 && ! args[i].pass_on_stack\n+\t&& args[i].mode == BLKmode\n+\t&& (TYPE_ALIGN (TREE_TYPE (args[i].tree_value))\n+\t    < MIN (BIGGEST_ALIGNMENT, BITS_PER_WORD)))\n+      {\n+\tint bytes = int_size_in_bytes (TREE_TYPE (args[i].tree_value));\n+\n+\targs[i].n_aligned_regs\n+\t  = args[i].partial ? args[i].partial\n+\t    : (bytes + (UNITS_PER_WORD - 1)) / UNITS_PER_WORD;\n+\n+\targs[i].aligned_regs = (rtx *) alloca (sizeof (rtx)\n+\t\t\t\t\t       * args[i].n_aligned_regs);\n+\n+\tfor (j = 0; j < args[i].n_aligned_regs; j++)\n+\t  {\n+\t    rtx reg = gen_reg_rtx (word_mode);\n+\t    rtx word = operand_subword_force (args[i].value, j, BLKmode);\n+\t    int bitsize = TYPE_ALIGN (TREE_TYPE (args[i].tree_value));\n+\t    int bitpos;\n+\n+\t    args[i].aligned_regs[j] = reg;\n+\n+\t    /* Clobber REG and move each partword into it.  Ensure we don't\n+\t       go past the end of the structure.  Note that the loop below\n+\t       works because we've already verified that padding\n+\t       and endianness are compatible.  */\n+\n+\t    emit_insn (gen_rtx (CLOBBER, VOIDmode, reg));\n+\n+\t    for (bitpos = 0;\n+\t\t bitpos < BITS_PER_WORD && bytes >= 0;\n+\t\t bitpos += bitsize, bytes -= bitsize / BITS_PER_UNIT)\n+\t      {\n+\t\tint xbitpos = (BYTES_BIG_ENDIAN\n+\t\t\t       ? bitpos = BITS_PER_WORD - bitpos - bitsize\n+\t\t\t       : bitpos);\n+\n+\t\tstore_bit_field (reg, bitsize, xbitpos, word_mode,\n+\t\t\t\t extract_bit_field (word, bitsize, xbitpos, 1,\n+\t\t\t\t\t\t    NULL_RTX, word_mode,\n+\t\t\t\t\t\t    word_mode,\n+\t\t\t\t\t\t    bitsize / BITS_PER_UNIT,\n+\t\t\t\t\t\t    BITS_PER_WORD),\n+\t\t\t\t bitsize / BITS_PER_UNIT, BITS_PER_WORD);\n+\t      }\n+\t  }\n+      }\n+#endif\n+\n   /* Now store any partially-in-registers parm.\n      This is the last place a block-move can happen.  */\n   if (reg_parm_seen)\n@@ -1609,6 +1672,17 @@ expand_call (exp, target, ignore)\n \n \t  if (nregs == 0)\n \t    emit_move_insn (reg, args[i].value);\n+\n+#ifdef STRICT_ALIGNMENT\n+\t  /* If we have pre-computed the values to put in the registers in\n+\t     the case of non-aligned structures, copy them in now.  */\n+\n+\t  else if (args[i].n_aligned_regs != 0)\n+\t    for (j = 0; j < args[i].n_aligned_regs; j++)\n+\t      emit_move_insn (gen_rtx (REG, word_mode, REGNO (reg) + j),\n+\t\t\t      args[i].aligned_regs[j]);\n+#endif\n+\n \t  else if (args[i].partial == 0 || args[i].pass_on_stack)\n \t    move_block_to_reg (REGNO (reg),\n \t\t\t       validize_mem (args[i].value), nregs,\n@@ -1989,13 +2063,20 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n        this case.   */\n     abort ();\n \n+#ifdef STRICT_ALIGNMENT\n+  /* If this arg needs special alignment, don't load the registers\n+     here.  */\n+  if (arg->n_aligned_regs != 0)\n+    reg = 0;\n+#endif\n+  \n   /* If this is being partially passed in a register, but multiple locations\n      are specified, we assume that the one partially used is the one that is\n      listed first.  */\n   if (reg && GET_CODE (reg) == EXPR_LIST)\n     reg = XEXP (reg, 0);\n \n-  /* If this is being passes partially in a register, we can't evaluate\n+  /* If this is being passed partially in a register, we can't evaluate\n      it directly into its stack slot.  Otherwise, we can.  */\n   if (arg->value == 0)\n     {"}]}