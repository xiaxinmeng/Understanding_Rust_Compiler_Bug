{"sha": "405ca10418216fc078ecb29ff13a39c911e8d806", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDA1Y2ExMDQxODIxNmZjMDc4ZWNiMjlmZjEzYTM5YzkxMWU4ZDgwNg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-07T17:09:10Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-04-07T17:09:10Z"}, "message": "libgo: Update to current Go library.\n\nFrom-SVN: r172106", "tree": {"sha": "39c2c0da7b6c220dd344f134fae07fba0d0266b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/39c2c0da7b6c220dd344f134fae07fba0d0266b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/405ca10418216fc078ecb29ff13a39c911e8d806", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405ca10418216fc078ecb29ff13a39c911e8d806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/405ca10418216fc078ecb29ff13a39c911e8d806", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/405ca10418216fc078ecb29ff13a39c911e8d806/comments", "author": null, "committer": null, "parents": [{"sha": "a751005d50fa7347131660e562c5fd9ce3dff75d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a751005d50fa7347131660e562c5fd9ce3dff75d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a751005d50fa7347131660e562c5fd9ce3dff75d"}], "stats": {"total": 7746, "additions": 4609, "deletions": 3137}, "files": [{"sha": "237a0c2565e7516932cd575d4427af7677d6e13f", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -1,4 +1,4 @@\n-342e3b11f21a\n+f618e5e0991d\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "3c9433101821a267e5baf81a060b9620934e2bfb", "filename": "libgo/Makefile.am", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -177,10 +177,10 @@ toolexeclibgocryptodir = $(toolexeclibgodir)/crypto\n \n toolexeclibgocrypto_DATA = \\\n \tcrypto/aes.gox \\\n-\tcrypto/block.gox \\\n \tcrypto/blowfish.gox \\\n \tcrypto/cast5.gox \\\n \tcrypto/cipher.gox \\\n+\tcrypto/des.gox \\\n \tcrypto/dsa.gox \\\n \tcrypto/ecdsa.gox \\\n \tcrypto/elliptic.gox \\\n@@ -727,9 +727,12 @@ go_os_files = \\\n \tgo/os/env.go \\\n \tgo/os/env_unix.go \\\n \tgo/os/error.go \\\n+\tgo/os/error_posix.go \\\n \tgo/os/exec.go \\\n+\tgo/os/exec_posix.go \\\n \tgo/os/exec_unix.go \\\n \tgo/os/file.go \\\n+\tgo/os/file_posix.go \\\n \tgo/os/file_unix.go \\\n \tgo/os/getwd.go \\\n \tgo/os/path.go \\\n@@ -932,16 +935,6 @@ go_crypto_aes_files = \\\n \tgo/crypto/aes/block.go \\\n \tgo/crypto/aes/cipher.go \\\n \tgo/crypto/aes/const.go\n-go_crypto_block_files = \\\n-\tgo/crypto/block/cbc.go \\\n-\tgo/crypto/block/cfb.go \\\n-\tgo/crypto/block/cmac.go \\\n-\tgo/crypto/block/cipher.go \\\n-\tgo/crypto/block/ctr.go \\\n-\tgo/crypto/block/eax.go \\\n-\tgo/crypto/block/ecb.go \\\n-\tgo/crypto/block/ofb.go \\\n-\tgo/crypto/block/xor.go\n go_crypto_blowfish_files = \\\n \tgo/crypto/blowfish/block.go \\\n \tgo/crypto/blowfish/const.go \\\n@@ -956,6 +949,10 @@ go_crypto_cipher_files = \\\n \tgo/crypto/cipher/io.go \\\n \tgo/crypto/cipher/ocfb.go \\\n \tgo/crypto/cipher/ofb.go\n+go_crypto_des_files = \\\n+\tgo/crypto/des/block.go \\\n+\tgo/crypto/des/cipher.go \\\n+\tgo/crypto/des/const.go\n go_crypto_dsa_files = \\\n \tgo/crypto/dsa/dsa.go\n go_crypto_ecdsa_files = \\\n@@ -1428,10 +1425,10 @@ libgo_go_objs = \\\n \tcontainer/ring.lo \\\n \tcontainer/vector.lo \\\n \tcrypto/aes.lo \\\n-\tcrypto/block.lo \\\n \tcrypto/blowfish.lo \\\n \tcrypto/cast5.lo \\\n \tcrypto/cipher.lo \\\n+\tcrypto/des.lo \\\n \tcrypto/dsa.lo \\\n \tcrypto/ecdsa.lo \\\n \tcrypto/elliptic.lo \\\n@@ -2026,13 +2023,6 @@ crypto/aes/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/aes/check\n \n-crypto/block.lo: $(go_crypto_block_files) fmt.gox io.gox os.gox strconv.gox\n-\t$(BUILDPACKAGE)\n-crypto/block/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/block\n-\t@$(CHECK)\n-.PHONY: crypto/block/check\n-\n crypto/blowfish.lo: $(go_crypto_blowfish_files) os.gox strconv.gox\n \t$(BUILDPACKAGE)\n crypto/blowfish/check: $(CHECK_DEPS)\n@@ -2054,6 +2044,13 @@ crypto/cipher/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/cipher/check\n \n+crypto/des.lo: $(go_crypto_des_files) encoding/binary.gox os.gox strconv.gox\n+\t$(BUILDPACKAGE)\n+crypto/des/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/des\n+\t@$(CHECK)\n+.PHONY: crypto/des/check\n+\n crypto/dsa.lo: $(go_crypto_dsa_files) big.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/dsa/check: $(CHECK_DEPS)\n@@ -2139,7 +2136,8 @@ crypto/ripemd160/check: $(CHECK_DEPS)\n .PHONY: crypto/ripemd160/check\n \n crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto.gox crypto/sha1.gox \\\n-\t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox\n+\t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox \\\n+\t\tsync.gox\n \t$(BUILDPACKAGE)\n crypto/rsa/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rsa\n@@ -2475,8 +2473,8 @@ http/cgi/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: http/cgi/check\n \n-http/httptest.lo: $(go_http_httptest_files) bytes.gox fmt.gox http.gox \\\n-\t\tnet.gox os.gox\n+http/httptest.lo: $(go_http_httptest_files) bytes.gox crypto/rand.gox \\\n+\t\tcrypto/tls.gox fmt.gox http.gox net.gox os.gox time.gox\n \t$(BUILDPACKAGE)\n http/httptest/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) http/httptest\n@@ -2767,14 +2765,14 @@ container/vector.gox: container/vector.lo\n \n crypto/aes.gox: crypto/aes.lo\n \t$(BUILDGOX)\n-crypto/block.gox: crypto/block.lo\n-\t$(BUILDGOX)\n crypto/blowfish.gox: crypto/blowfish.lo\n \t$(BUILDGOX)\n crypto/cast5.gox: crypto/cast5.lo\n \t$(BUILDGOX)\n crypto/cipher.gox: crypto/cipher.lo\n \t$(BUILDGOX)\n+crypto/des.gox: crypto/des.lo\n+\t$(BUILDGOX)\n crypto/dsa.gox: crypto/dsa.lo\n \t$(BUILDGOX)\n crypto/ecdsa.gox: crypto/ecdsa.lo\t\n@@ -3002,10 +3000,10 @@ TEST_PACKAGES = \\\n \tcontainer/ring/check \\\n \tcontainer/vector/check \\\n \tcrypto/aes/check \\\n-\tcrypto/block/check \\\n \tcrypto/blowfish/check \\\n \tcrypto/cast5/check \\\n \tcrypto/cipher/check \\\n+\tcrypto/des/check \\\n \tcrypto/dsa/check \\\n \tcrypto/ecdsa/check \\\n \tcrypto/elliptic/check \\"}, {"sha": "da881d574360951b9e4e5b6875a95cfb5ab2e8f1", "filename": "libgo/Makefile.in", "status": "modified", "additions": 48, "deletions": 51, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -140,31 +140,30 @@ am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n \tarchive/zip.lo compress/bzip2.lo compress/flate.lo \\\n \tcompress/gzip.lo compress/lzw.lo compress/zlib.lo \\\n \tcontainer/heap.lo container/list.lo container/ring.lo \\\n-\tcontainer/vector.lo crypto/aes.lo crypto/block.lo \\\n-\tcrypto/blowfish.lo crypto/cast5.lo crypto/cipher.lo \\\n-\tcrypto/dsa.lo crypto/ecdsa.lo crypto/elliptic.lo \\\n-\tcrypto/hmac.lo crypto/md4.lo crypto/md5.lo crypto/ocsp.lo \\\n-\tcrypto/openpgp.lo crypto/rand.lo crypto/rc4.lo \\\n-\tcrypto/ripemd160.lo crypto/rsa.lo crypto/sha1.lo \\\n-\tcrypto/sha256.lo crypto/sha512.lo crypto/subtle.lo \\\n-\tcrypto/tls.lo crypto/twofish.lo crypto/x509.lo crypto/xtea.lo \\\n-\tcrypto/openpgp/armor.lo crypto/openpgp/error.lo \\\n-\tcrypto/openpgp/packet.lo crypto/openpgp/s2k.lo debug/dwarf.lo \\\n-\tdebug/elf.lo debug/gosym.lo debug/macho.lo debug/pe.lo \\\n-\tdebug/proc.lo encoding/ascii85.lo encoding/base32.lo \\\n-\tencoding/base64.lo encoding/binary.lo encoding/git85.lo \\\n-\tencoding/hex.lo encoding/line.lo encoding/pem.lo \\\n-\texp/datafmt.lo exp/draw.lo exp/eval.lo go/ast.lo go/doc.lo \\\n-\tgo/parser.lo go/printer.lo go/scanner.lo go/token.lo \\\n-\tgo/typechecker.lo hash/adler32.lo hash/crc32.lo hash/crc64.lo \\\n-\thash/fnv.lo http/cgi.lo http/httptest.lo http/pprof.lo \\\n-\timage/jpeg.lo image/png.lo index/suffixarray.lo io/ioutil.lo \\\n-\tmime/multipart.lo net/dict.lo net/textproto.lo \\\n-\t$(am__DEPENDENCIES_1) os/signal.lo path/filepath.lo \\\n-\trpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n-\tsync/atomic.lo sync/atomic_c.lo syscalls/syscall.lo \\\n-\tsyscalls/errno.lo testing/testing.lo testing/iotest.lo \\\n-\ttesting/quick.lo testing/script.lo\n+\tcontainer/vector.lo crypto/aes.lo crypto/blowfish.lo \\\n+\tcrypto/cast5.lo crypto/cipher.lo crypto/des.lo crypto/dsa.lo \\\n+\tcrypto/ecdsa.lo crypto/elliptic.lo crypto/hmac.lo \\\n+\tcrypto/md4.lo crypto/md5.lo crypto/ocsp.lo crypto/openpgp.lo \\\n+\tcrypto/rand.lo crypto/rc4.lo crypto/ripemd160.lo crypto/rsa.lo \\\n+\tcrypto/sha1.lo crypto/sha256.lo crypto/sha512.lo \\\n+\tcrypto/subtle.lo crypto/tls.lo crypto/twofish.lo \\\n+\tcrypto/x509.lo crypto/xtea.lo crypto/openpgp/armor.lo \\\n+\tcrypto/openpgp/error.lo crypto/openpgp/packet.lo \\\n+\tcrypto/openpgp/s2k.lo debug/dwarf.lo debug/elf.lo \\\n+\tdebug/gosym.lo debug/macho.lo debug/pe.lo debug/proc.lo \\\n+\tencoding/ascii85.lo encoding/base32.lo encoding/base64.lo \\\n+\tencoding/binary.lo encoding/git85.lo encoding/hex.lo \\\n+\tencoding/line.lo encoding/pem.lo exp/datafmt.lo exp/draw.lo \\\n+\texp/eval.lo go/ast.lo go/doc.lo go/parser.lo go/printer.lo \\\n+\tgo/scanner.lo go/token.lo go/typechecker.lo hash/adler32.lo \\\n+\thash/crc32.lo hash/crc64.lo hash/fnv.lo http/cgi.lo \\\n+\thttp/httptest.lo http/pprof.lo image/jpeg.lo image/png.lo \\\n+\tindex/suffixarray.lo io/ioutil.lo mime/multipart.lo \\\n+\tnet/dict.lo net/textproto.lo $(am__DEPENDENCIES_1) \\\n+\tos/signal.lo path/filepath.lo rpc/jsonrpc.lo runtime/debug.lo \\\n+\truntime/pprof.lo sync/atomic.lo sync/atomic_c.lo \\\n+\tsyscalls/syscall.lo syscalls/errno.lo testing/testing.lo \\\n+\ttesting/iotest.lo testing/quick.lo testing/script.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n@@ -624,10 +623,10 @@ toolexeclibgocontainer_DATA = \\\n toolexeclibgocryptodir = $(toolexeclibgodir)/crypto\n toolexeclibgocrypto_DATA = \\\n \tcrypto/aes.gox \\\n-\tcrypto/block.gox \\\n \tcrypto/blowfish.gox \\\n \tcrypto/cast5.gox \\\n \tcrypto/cipher.gox \\\n+\tcrypto/des.gox \\\n \tcrypto/dsa.gox \\\n \tcrypto/ecdsa.gox \\\n \tcrypto/elliptic.gox \\\n@@ -1087,9 +1086,12 @@ go_os_files = \\\n \tgo/os/env.go \\\n \tgo/os/env_unix.go \\\n \tgo/os/error.go \\\n+\tgo/os/error_posix.go \\\n \tgo/os/exec.go \\\n+\tgo/os/exec_posix.go \\\n \tgo/os/exec_unix.go \\\n \tgo/os/file.go \\\n+\tgo/os/file_posix.go \\\n \tgo/os/file_unix.go \\\n \tgo/os/getwd.go \\\n \tgo/os/path.go \\\n@@ -1279,17 +1281,6 @@ go_crypto_aes_files = \\\n \tgo/crypto/aes/cipher.go \\\n \tgo/crypto/aes/const.go\n \n-go_crypto_block_files = \\\n-\tgo/crypto/block/cbc.go \\\n-\tgo/crypto/block/cfb.go \\\n-\tgo/crypto/block/cmac.go \\\n-\tgo/crypto/block/cipher.go \\\n-\tgo/crypto/block/ctr.go \\\n-\tgo/crypto/block/eax.go \\\n-\tgo/crypto/block/ecb.go \\\n-\tgo/crypto/block/ofb.go \\\n-\tgo/crypto/block/xor.go\n-\n go_crypto_blowfish_files = \\\n \tgo/crypto/blowfish/block.go \\\n \tgo/crypto/blowfish/const.go \\\n@@ -1307,6 +1298,11 @@ go_crypto_cipher_files = \\\n \tgo/crypto/cipher/ocfb.go \\\n \tgo/crypto/cipher/ofb.go\n \n+go_crypto_des_files = \\\n+\tgo/crypto/des/block.go \\\n+\tgo/crypto/des/cipher.go \\\n+\tgo/crypto/des/const.go\n+\n go_crypto_dsa_files = \\\n \tgo/crypto/dsa/dsa.go\n \n@@ -1766,10 +1762,10 @@ libgo_go_objs = \\\n \tcontainer/ring.lo \\\n \tcontainer/vector.lo \\\n \tcrypto/aes.lo \\\n-\tcrypto/block.lo \\\n \tcrypto/blowfish.lo \\\n \tcrypto/cast5.lo \\\n \tcrypto/cipher.lo \\\n+\tcrypto/des.lo \\\n \tcrypto/dsa.lo \\\n \tcrypto/ecdsa.lo \\\n \tcrypto/elliptic.lo \\\n@@ -2008,10 +2004,10 @@ TEST_PACKAGES = \\\n \tcontainer/ring/check \\\n \tcontainer/vector/check \\\n \tcrypto/aes/check \\\n-\tcrypto/block/check \\\n \tcrypto/blowfish/check \\\n \tcrypto/cast5/check \\\n \tcrypto/cipher/check \\\n+\tcrypto/des/check \\\n \tcrypto/dsa/check \\\n \tcrypto/ecdsa/check \\\n \tcrypto/elliptic/check \\\n@@ -4436,13 +4432,6 @@ crypto/aes/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/aes/check\n \n-crypto/block.lo: $(go_crypto_block_files) fmt.gox io.gox os.gox strconv.gox\n-\t$(BUILDPACKAGE)\n-crypto/block/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/block\n-\t@$(CHECK)\n-.PHONY: crypto/block/check\n-\n crypto/blowfish.lo: $(go_crypto_blowfish_files) os.gox strconv.gox\n \t$(BUILDPACKAGE)\n crypto/blowfish/check: $(CHECK_DEPS)\n@@ -4464,6 +4453,13 @@ crypto/cipher/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/cipher/check\n \n+crypto/des.lo: $(go_crypto_des_files) encoding/binary.gox os.gox strconv.gox\n+\t$(BUILDPACKAGE)\n+crypto/des/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/des\n+\t@$(CHECK)\n+.PHONY: crypto/des/check\n+\n crypto/dsa.lo: $(go_crypto_dsa_files) big.gox io.gox os.gox\n \t$(BUILDPACKAGE)\n crypto/dsa/check: $(CHECK_DEPS)\n@@ -4549,7 +4545,8 @@ crypto/ripemd160/check: $(CHECK_DEPS)\n .PHONY: crypto/ripemd160/check\n \n crypto/rsa.lo: $(go_crypto_rsa_files) big.gox crypto.gox crypto/sha1.gox \\\n-\t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox\n+\t\tcrypto/subtle.gox encoding/hex.gox hash.gox io.gox os.gox \\\n+\t\tsync.gox\n \t$(BUILDPACKAGE)\n crypto/rsa/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/rsa\n@@ -4885,8 +4882,8 @@ http/cgi/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: http/cgi/check\n \n-http/httptest.lo: $(go_http_httptest_files) bytes.gox fmt.gox http.gox \\\n-\t\tnet.gox os.gox\n+http/httptest.lo: $(go_http_httptest_files) bytes.gox crypto/rand.gox \\\n+\t\tcrypto/tls.gox fmt.gox http.gox net.gox os.gox time.gox\n \t$(BUILDPACKAGE)\n http/httptest/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) http/httptest\n@@ -5172,14 +5169,14 @@ container/vector.gox: container/vector.lo\n \n crypto/aes.gox: crypto/aes.lo\n \t$(BUILDGOX)\n-crypto/block.gox: crypto/block.lo\n-\t$(BUILDGOX)\n crypto/blowfish.gox: crypto/blowfish.lo\n \t$(BUILDGOX)\n crypto/cast5.gox: crypto/cast5.lo\n \t$(BUILDGOX)\n crypto/cipher.gox: crypto/cipher.lo\n \t$(BUILDGOX)\n+crypto/des.gox: crypto/des.lo\n+\t$(BUILDGOX)\n crypto/dsa.gox: crypto/dsa.lo\n \t$(BUILDGOX)\n crypto/ecdsa.gox: crypto/ecdsa.lo\t"}, {"sha": "1b41196a999a03344957477e906bbffaae958aae", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -95,7 +95,7 @@ func (tr *Reader) skipUnread() {\n \tnr := tr.nb + tr.pad // number of bytes to skip\n \ttr.nb, tr.pad = 0, 0\n \tif sr, ok := tr.r.(io.Seeker); ok {\n-\t\tif _, err := sr.Seek(nr, 1); err == nil {\n+\t\tif _, err := sr.Seek(nr, os.SEEK_CUR); err == nil {\n \t\t\treturn\n \t\t}\n \t}"}, {"sha": "32fc8f9151a61addfece5f36c7b01c9a5523ed46", "filename": "libgo/go/archive/tar/reader_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -113,7 +113,7 @@ var untarTests = []*untarTest{\n func TestReader(t *testing.T) {\n testLoop:\n \tfor i, test := range untarTests {\n-\t\tf, err := os.Open(test.file, os.O_RDONLY, 0444)\n+\t\tf, err := os.Open(test.file)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"test %d: Unexpected error: %v\", i, err)\n \t\t\tcontinue\n@@ -143,7 +143,7 @@ testLoop:\n }\n \n func TestPartialRead(t *testing.T) {\n-\tf, err := os.Open(\"testdata/gnu.tar\", os.O_RDONLY, 0444)\n+\tf, err := os.Open(\"testdata/gnu.tar\")\n \tif err != nil {\n \t\tt.Fatalf(\"Unexpected error: %v\", err)\n \t}\n@@ -181,7 +181,7 @@ func TestPartialRead(t *testing.T) {\n \n func TestIncrementalRead(t *testing.T) {\n \ttest := gnuTarTest\n-\tf, err := os.Open(test.file, os.O_RDONLY, 0444)\n+\tf, err := os.Open(test.file)\n \tif err != nil {\n \t\tt.Fatalf(\"Unexpected error: %v\", err)\n \t}\n@@ -235,7 +235,7 @@ func TestIncrementalRead(t *testing.T) {\n \n func TestNonSeekable(t *testing.T) {\n \ttest := gnuTarTest\n-\tf, err := os.Open(test.file, os.O_RDONLY, 0444)\n+\tf, err := os.Open(test.file)\n \tif err != nil {\n \t\tt.Fatalf(\"Unexpected error: %v\", err)\n \t}"}, {"sha": "543007abfe058405b931cf41d2ab7fddc338ce83", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -49,7 +49,7 @@ func (f *File) hasDataDescriptor() bool {\n \n // OpenReader will open the Zip file specified by name and return a Reader.\n func OpenReader(name string) (*Reader, os.Error) {\n-\tf, err := os.Open(name, os.O_RDONLY, 0644)\n+\tf, err := os.Open(name)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -73,7 +73,7 @@ func NewReader(r io.ReaderAt, size int64) (*Reader, os.Error) {\n \t\tComment: end.comment,\n \t}\n \trs := io.NewSectionReader(r, 0, size)\n-\tif _, err = rs.Seek(int64(end.directoryOffset), 0); err != nil {\n+\tif _, err = rs.Seek(int64(end.directoryOffset), os.SEEK_SET); err != nil {\n \t\treturn nil, err\n \t}\n \tbuf := bufio.NewReader(rs)\n@@ -94,7 +94,7 @@ func (f *File) Open() (rc io.ReadCloser, err os.Error) {\n \t\tif err = readFileHeader(f, r); err != nil {\n \t\t\treturn\n \t\t}\n-\t\tif f.bodyOffset, err = r.Seek(0, 1); err != nil {\n+\t\tif f.bodyOffset, err = r.Seek(0, os.SEEK_CUR); err != nil {\n \t\t\treturn\n \t\t}\n \t}"}, {"sha": "cd08be31b6ac93f65eda92cd9cd539f14190c4f1", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 27, "deletions": 41, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -415,38 +415,27 @@ func (b *Writer) Buffered() int { return b.n }\n // If nn < len(p), it also returns an error explaining\n // why the write is short.\n func (b *Writer) Write(p []byte) (nn int, err os.Error) {\n-\tif b.err != nil {\n-\t\treturn 0, b.err\n-\t}\n-\tnn = 0\n-\tfor len(p) > 0 {\n-\t\tn := b.Available()\n-\t\tif n <= 0 {\n-\t\t\tif b.Flush(); b.err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tn = b.Available()\n-\t\t}\n-\t\tif b.Buffered() == 0 && len(p) >= len(b.buf) {\n+\tfor len(p) > b.Available() && b.err == nil {\n+\t\tvar n int\n+\t\tif b.Buffered() == 0 {\n \t\t\t// Large write, empty buffer.\n \t\t\t// Write directly from p to avoid copy.\n \t\t\tn, b.err = b.wr.Write(p)\n-\t\t\tnn += n\n-\t\t\tp = p[n:]\n-\t\t\tif b.err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\tif n > len(p) {\n-\t\t\tn = len(p)\n+\t\t} else {\n+\t\t\tn = copy(b.buf[b.n:], p)\n+\t\t\tb.n += n\n+\t\t\tb.Flush()\n \t\t}\n-\t\tcopy(b.buf[b.n:b.n+n], p[0:n])\n-\t\tb.n += n\n \t\tnn += n\n \t\tp = p[n:]\n \t}\n-\treturn nn, b.err\n+\tif b.err != nil {\n+\t\treturn nn, b.err\n+\t}\n+\tn := copy(b.buf[b.n:], p)\n+\tb.n += n\n+\tnn += n\n+\treturn nn, nil\n }\n \n // WriteByte writes a single byte.\n@@ -496,24 +485,21 @@ func (b *Writer) WriteRune(rune int) (size int, err os.Error) {\n // If the count is less than len(s), it also returns an error explaining\n // why the write is short.\n func (b *Writer) WriteString(s string) (int, os.Error) {\n-\tif b.err != nil {\n-\t\treturn 0, b.err\n-\t}\n-\t// Common case, worth making fast.\n-\tif b.Available() >= len(s) || len(b.buf) >= len(s) && b.Flush() == nil {\n-\t\tfor i := 0; i < len(s); i++ { // loop over bytes, not runes.\n-\t\t\tb.buf[b.n] = s[i]\n-\t\t\tb.n++\n-\t\t}\n-\t\treturn len(s), nil\n+\tnn := 0\n+\tfor len(s) > b.Available() && b.err == nil {\n+\t\tn := copy(b.buf[b.n:], s)\n+\t\tb.n += n\n+\t\tnn += n\n+\t\ts = s[n:]\n+\t\tb.Flush()\n \t}\n-\tfor i := 0; i < len(s); i++ { // loop over bytes, not runes.\n-\t\tb.WriteByte(s[i])\n-\t\tif b.err != nil {\n-\t\t\treturn i, b.err\n-\t\t}\n+\tif b.err != nil {\n+\t\treturn nn, b.err\n \t}\n-\treturn len(s), nil\n+\tn := copy(b.buf[b.n:], s)\n+\tb.n += n\n+\tnn += n\n+\treturn nn, nil\n }\n \n // buffered input and output"}, {"sha": "e5815a03d5d628353ac33dca133217f3c24d0308", "filename": "libgo/go/compress/lzw/writer_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -21,15 +21,15 @@ var filenames = []string{\n // the given options yields equivalent bytes to the original file.\n func testFile(t *testing.T, fn string, order Order, litWidth int) {\n \t// Read the file, as golden output.\n-\tgolden, err := os.Open(fn, os.O_RDONLY, 0400)\n+\tgolden, err := os.Open(fn)\n \tif err != nil {\n \t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err)\n \t\treturn\n \t}\n \tdefer golden.Close()\n \n \t// Read the file again, and push it through a pipe that compresses at the write end, and decompresses at the read end.\n-\traw, err := os.Open(fn, os.O_RDONLY, 0400)\n+\traw, err := os.Open(fn)\n \tif err != nil {\n \t\tt.Errorf(\"%s (order=%d litWidth=%d): %v\", fn, order, litWidth, err)\n \t\treturn"}, {"sha": "7eb1cd494978d5e41cc997993980c114e2163aa2", "filename": "libgo/go/compress/zlib/writer_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fzlib%2Fwriter_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -20,15 +20,15 @@ var filenames = []string{\n // yields equivalent bytes to the original file.\n func testFileLevel(t *testing.T, fn string, level int) {\n \t// Read the file, as golden output.\n-\tgolden, err := os.Open(fn, os.O_RDONLY, 0444)\n+\tgolden, err := os.Open(fn)\n \tif err != nil {\n \t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err)\n \t\treturn\n \t}\n \tdefer golden.Close()\n \n \t// Read the file again, and push it through a pipe that compresses at the write end, and decompresses at the read end.\n-\traw, err := os.Open(fn, os.O_RDONLY, 0444)\n+\traw, err := os.Open(fn)\n \tif err != nil {\n \t\tt.Errorf(\"%s (level=%d): %v\", fn, level, err)\n \t\treturn"}, {"sha": "23229c09f70681f97d42563f9efb282b2b7e227f", "filename": "libgo/go/crypto/block/cbc.go", "status": "removed", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcbc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcbc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fcbc.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,71 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Cipher block chaining (CBC) mode.\n-\n-// CBC provides confidentiality by xoring (chaining) each plaintext block\n-// with the previous ciphertext block before applying the block cipher.\n-\n-// See NIST SP 800-38A, pp 10-11\n-\n-package block\n-\n-import (\n-\t\"io\"\n-)\n-\n-type cbcCipher struct {\n-\tc         Cipher\n-\tblockSize int\n-\tiv        []byte\n-\ttmp       []byte\n-}\n-\n-func newCBC(c Cipher, iv []byte) *cbcCipher {\n-\tn := c.BlockSize()\n-\tx := new(cbcCipher)\n-\tx.c = c\n-\tx.blockSize = n\n-\tx.iv = dup(iv)\n-\tx.tmp = make([]byte, n)\n-\treturn x\n-}\n-\n-func (x *cbcCipher) BlockSize() int { return x.blockSize }\n-\n-func (x *cbcCipher) Encrypt(dst, src []byte) {\n-\tfor i := 0; i < x.blockSize; i++ {\n-\t\tx.iv[i] ^= src[i]\n-\t}\n-\tx.c.Encrypt(x.iv, x.iv)\n-\tfor i := 0; i < x.blockSize; i++ {\n-\t\tdst[i] = x.iv[i]\n-\t}\n-}\n-\n-func (x *cbcCipher) Decrypt(dst, src []byte) {\n-\tx.c.Decrypt(x.tmp, src)\n-\tfor i := 0; i < x.blockSize; i++ {\n-\t\tx.tmp[i] ^= x.iv[i]\n-\t\tx.iv[i] = src[i]\n-\t\tdst[i] = x.tmp[i]\n-\t}\n-}\n-\n-// NewCBCDecrypter returns a reader that reads data from r and decrypts it using c\n-// in cipher block chaining (CBC) mode with the initialization vector iv.\n-// The returned Reader does not buffer or read ahead except\n-// as required by the cipher's block size.\n-func NewCBCDecrypter(c Cipher, iv []byte, r io.Reader) io.Reader {\n-\treturn NewECBDecrypter(newCBC(c, iv), r)\n-}\n-\n-// NewCBCEncrypter returns a writer that encrypts data using c\n-// in cipher block chaining (CBC) mode with the initialization vector iv\n-// and writes the encrypted data to w.\n-// The returned Writer does no buffering except as required\n-// by the cipher's block size, so there is no need for a Flush method.\n-func NewCBCEncrypter(c Cipher, iv []byte, w io.Writer) io.Writer {\n-\treturn NewECBEncrypter(newCBC(c, iv), w)\n-}"}, {"sha": "f20c0a04f66819274fba8f31b93170ee506b9af0", "filename": "libgo/go/crypto/block/cfb.go", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcfb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcfb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fcfb.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,96 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Cipher feedback (CFB) mode.\n-\n-// CFB provides confidentiality by feeding a fraction of\n-// the previous ciphertext in as the plaintext for the next\n-// block operation.\n-\n-// See NIST SP 800-38A, pp 11-13\n-\n-package block\n-\n-import (\n-\t\"io\"\n-)\n-\n-type cfbCipher struct {\n-\tc          Cipher\n-\tblockSize  int // our block size (s/8)\n-\tcipherSize int // underlying cipher block size\n-\tiv         []byte\n-\ttmp        []byte\n-}\n-\n-func newCFB(c Cipher, s int, iv []byte) *cfbCipher {\n-\tif s == 0 || s%8 != 0 {\n-\t\tpanic(\"crypto/block: invalid CFB mode\")\n-\t}\n-\tb := c.BlockSize()\n-\tx := new(cfbCipher)\n-\tx.c = c\n-\tx.blockSize = s / 8\n-\tx.cipherSize = b\n-\tx.iv = dup(iv)\n-\tx.tmp = make([]byte, b)\n-\treturn x\n-}\n-\n-func (x *cfbCipher) BlockSize() int { return x.blockSize }\n-\n-func (x *cfbCipher) Encrypt(dst, src []byte) {\n-\t// Encrypt old IV and xor prefix with src to make dst.\n-\tx.c.Encrypt(x.tmp, x.iv)\n-\tfor i := 0; i < x.blockSize; i++ {\n-\t\tdst[i] = src[i] ^ x.tmp[i]\n-\t}\n-\n-\t// Slide unused IV pieces down and insert dst at end.\n-\tfor i := 0; i < x.cipherSize-x.blockSize; i++ {\n-\t\tx.iv[i] = x.iv[i+x.blockSize]\n-\t}\n-\toff := x.cipherSize - x.blockSize\n-\tfor i := off; i < x.cipherSize; i++ {\n-\t\tx.iv[i] = dst[i-off]\n-\t}\n-}\n-\n-func (x *cfbCipher) Decrypt(dst, src []byte) {\n-\t// Encrypt [sic] old IV and xor prefix with src to make dst.\n-\tx.c.Encrypt(x.tmp, x.iv)\n-\tfor i := 0; i < x.blockSize; i++ {\n-\t\tdst[i] = src[i] ^ x.tmp[i]\n-\t}\n-\n-\t// Slide unused IV pieces down and insert src at top.\n-\tfor i := 0; i < x.cipherSize-x.blockSize; i++ {\n-\t\tx.iv[i] = x.iv[i+x.blockSize]\n-\t}\n-\toff := x.cipherSize - x.blockSize\n-\tfor i := off; i < x.cipherSize; i++ {\n-\t\t// Reconstruct src = dst ^ x.tmp\n-\t\t// in case we overwrote src (src == dst).\n-\t\tx.iv[i] = dst[i-off] ^ x.tmp[i-off]\n-\t}\n-}\n-\n-// NewCFBDecrypter returns a reader that reads data from r and decrypts it using c\n-// in s-bit cipher feedback (CFB) mode with the initialization vector iv.\n-// The returned Reader does not buffer or read ahead except\n-// as required by the cipher's block size.\n-// Modes for s not a multiple of 8 are unimplemented.\n-func NewCFBDecrypter(c Cipher, s int, iv []byte, r io.Reader) io.Reader {\n-\treturn NewECBDecrypter(newCFB(c, s, iv), r)\n-}\n-\n-// NewCFBEncrypter returns a writer that encrypts data using c\n-// in s-bit cipher feedback (CFB) mode with the initialization vector iv\n-// and writes the encrypted data to w.\n-// The returned Writer does no buffering except as required\n-// by the cipher's block size, so there is no need for a Flush method.\n-// Modes for s not a multiple of 8 are unimplemented.\n-func NewCFBEncrypter(c Cipher, s int, iv []byte, w io.Writer) io.Writer {\n-\treturn NewECBEncrypter(newCFB(c, s, iv), w)\n-}"}, {"sha": "e400c182a28cf8e58db6194dacf5d799bef4eae9", "filename": "libgo/go/crypto/block/cfb_aes_test.go", "status": "removed", "additions": 0, "deletions": 311, "changes": 311, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcfb_aes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcfb_aes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fcfb_aes_test.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,311 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// CFB AES test vectors.\n-\n-// See U.S. National Institute of Standards and Technology (NIST)\n-// Special Publication 800-38A, ``Recommendation for Block Cipher\n-// Modes of Operation,'' 2001 Edition, pp. 29-52.\n-\n-package block\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/aes\"\n-\t\"io\"\n-\t\"testing\"\n-)\n-\n-type cfbTest struct {\n-\tname string\n-\ts    int\n-\tkey  []byte\n-\tiv   []byte\n-\tin   []byte\n-\tout  []byte\n-}\n-\n-var cfbAESTests = []cfbTest{\n-\t{\n-\t\t\"CFB1-AES128\",\n-\t\t1,\n-\t\tcommonKey128,\n-\t\tcommonIV,\n-\t\t[]byte{\n-\t\t\t0<<7 | 1<<6 | 1<<5 | 0<<4 | 1<<3 | 0<<2 | 1<<1,\n-\t\t\t1<<7 | 1<<6 | 0<<5 | 0<<4 | 0<<3 | 0<<2 | 0<<1,\n-\t\t},\n-\t\t[]byte{\n-\t\t\t0<<7 | 1<<6 | 1<<5 | 0<<4 | 1<<3 | 0<<2 | 0<<1,\n-\t\t\t1<<7 | 0<<6 | 1<<5 | 1<<4 | 0<<3 | 0<<2 | 1<<1,\n-\t\t},\n-\t},\n-\t{\n-\t\t\"CFB1-AES192\",\n-\t\t1,\n-\t\tcommonKey192,\n-\t\tcommonIV,\n-\t\t[]byte{\n-\t\t\t0<<7 | 1<<6 | 1<<5 | 0<<4 | 1<<3 | 0<<2 | 1<<1,\n-\t\t\t1<<7 | 1<<6 | 0<<5 | 0<<4 | 0<<3 | 0<<2 | 0<<1,\n-\t\t},\n-\t\t[]byte{\n-\t\t\t1<<7 | 0<<6 | 0<<5 | 1<<4 | 0<<3 | 0<<2 | 1<<1,\n-\t\t\t0<<7 | 1<<6 | 0<<5 | 1<<4 | 1<<3 | 0<<2 | 0<<1,\n-\t\t},\n-\t},\n-\t{\n-\t\t\"CFB1-AES256\",\n-\t\t1,\n-\t\tcommonKey256,\n-\t\tcommonIV,\n-\t\t[]byte{\n-\t\t\t0<<7 | 1<<6 | 1<<5 | 0<<4 | 1<<3 | 0<<2 | 1<<1,\n-\t\t\t1<<7 | 1<<6 | 0<<5 | 0<<4 | 0<<3 | 0<<2 | 0<<1,\n-\t\t},\n-\t\t[]byte{\n-\t\t\t1<<7 | 0<<6 | 0<<5 | 1<<4 | 0<<3 | 0<<2 | 0<<1,\n-\t\t\t0<<7 | 0<<6 | 1<<5 | 0<<4 | 1<<3 | 0<<2 | 0<<1,\n-\t\t},\n-\t},\n-\n-\t{\n-\t\t\"CFB8-AES128\",\n-\t\t8,\n-\t\tcommonKey128,\n-\t\tcommonIV,\n-\t\t[]byte{\n-\t\t\t0x6b,\n-\t\t\t0xc1,\n-\t\t\t0xbe,\n-\t\t\t0xe2,\n-\t\t\t0x2e,\n-\t\t\t0x40,\n-\t\t\t0x9f,\n-\t\t\t0x96,\n-\t\t\t0xe9,\n-\t\t\t0x3d,\n-\t\t\t0x7e,\n-\t\t\t0x11,\n-\t\t\t0x73,\n-\t\t\t0x93,\n-\t\t\t0x17,\n-\t\t\t0x2a,\n-\t\t\t0xae,\n-\t\t\t0x2d,\n-\t\t},\n-\t\t[]byte{\n-\t\t\t0x3b,\n-\t\t\t0x79,\n-\t\t\t0x42,\n-\t\t\t0x4c,\n-\t\t\t0x9c,\n-\t\t\t0x0d,\n-\t\t\t0xd4,\n-\t\t\t0x36,\n-\t\t\t0xba,\n-\t\t\t0xce,\n-\t\t\t0x9e,\n-\t\t\t0x0e,\n-\t\t\t0xd4,\n-\t\t\t0x58,\n-\t\t\t0x6a,\n-\t\t\t0x4f,\n-\t\t\t0x32,\n-\t\t\t0xb9,\n-\t\t},\n-\t},\n-\n-\t{\n-\t\t\"CFB8-AES192\",\n-\t\t8,\n-\t\tcommonKey192,\n-\t\tcommonIV,\n-\t\t[]byte{\n-\t\t\t0x6b,\n-\t\t\t0xc1,\n-\t\t\t0xbe,\n-\t\t\t0xe2,\n-\t\t\t0x2e,\n-\t\t\t0x40,\n-\t\t\t0x9f,\n-\t\t\t0x96,\n-\t\t\t0xe9,\n-\t\t\t0x3d,\n-\t\t\t0x7e,\n-\t\t\t0x11,\n-\t\t\t0x73,\n-\t\t\t0x93,\n-\t\t\t0x17,\n-\t\t\t0x2a,\n-\t\t\t0xae,\n-\t\t\t0x2d,\n-\t\t},\n-\t\t[]byte{\n-\t\t\t0xcd,\n-\t\t\t0xa2,\n-\t\t\t0x52,\n-\t\t\t0x1e,\n-\t\t\t0xf0,\n-\t\t\t0xa9,\n-\t\t\t0x05,\n-\t\t\t0xca,\n-\t\t\t0x44,\n-\t\t\t0xcd,\n-\t\t\t0x05,\n-\t\t\t0x7c,\n-\t\t\t0xbf,\n-\t\t\t0x0d,\n-\t\t\t0x47,\n-\t\t\t0xa0,\n-\t\t\t0x67,\n-\t\t\t0x8a,\n-\t\t},\n-\t},\n-\n-\t{\n-\t\t\"CFB8-AES256\",\n-\t\t8,\n-\t\tcommonKey256,\n-\t\tcommonIV,\n-\t\t[]byte{\n-\t\t\t0x6b,\n-\t\t\t0xc1,\n-\t\t\t0xbe,\n-\t\t\t0xe2,\n-\t\t\t0x2e,\n-\t\t\t0x40,\n-\t\t\t0x9f,\n-\t\t\t0x96,\n-\t\t\t0xe9,\n-\t\t\t0x3d,\n-\t\t\t0x7e,\n-\t\t\t0x11,\n-\t\t\t0x73,\n-\t\t\t0x93,\n-\t\t\t0x17,\n-\t\t\t0x2a,\n-\t\t\t0xae,\n-\t\t\t0x2d,\n-\t\t},\n-\t\t[]byte{\n-\t\t\t0xdc,\n-\t\t\t0x1f,\n-\t\t\t0x1a,\n-\t\t\t0x85,\n-\t\t\t0x20,\n-\t\t\t0xa6,\n-\t\t\t0x4d,\n-\t\t\t0xb5,\n-\t\t\t0x5f,\n-\t\t\t0xcc,\n-\t\t\t0x8a,\n-\t\t\t0xc5,\n-\t\t\t0x54,\n-\t\t\t0x84,\n-\t\t\t0x4e,\n-\t\t\t0x88,\n-\t\t\t0x97,\n-\t\t\t0x00,\n-\t\t},\n-\t},\n-\n-\t{\n-\t\t\"CFB128-AES128\",\n-\t\t128,\n-\t\tcommonKey128,\n-\t\tcommonIV,\n-\t\t[]byte{\n-\t\t\t0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n-\t\t\t0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n-\t\t\t0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n-\t\t\t0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,\n-\t\t},\n-\t\t[]byte{\n-\t\t\t0x3b, 0x3f, 0xd9, 0x2e, 0xb7, 0x2d, 0xad, 0x20, 0x33, 0x34, 0x49, 0xf8, 0xe8, 0x3c, 0xfb, 0x4a,\n-\t\t\t0xc8, 0xa6, 0x45, 0x37, 0xa0, 0xb3, 0xa9, 0x3f, 0xcd, 0xe3, 0xcd, 0xad, 0x9f, 0x1c, 0xe5, 0x8b,\n-\t\t\t0x26, 0x75, 0x1f, 0x67, 0xa3, 0xcb, 0xb1, 0x40, 0xb1, 0x80, 0x8c, 0xf1, 0x87, 0xa4, 0xf4, 0xdf,\n-\t\t\t0xc0, 0x4b, 0x05, 0x35, 0x7c, 0x5d, 0x1c, 0x0e, 0xea, 0xc4, 0xc6, 0x6f, 0x9f, 0xf7, 0xf2, 0xe6,\n-\t\t},\n-\t},\n-\n-\t{\n-\t\t\"CFB128-AES192\",\n-\t\t128,\n-\t\tcommonKey192,\n-\t\tcommonIV,\n-\t\t[]byte{\n-\t\t\t0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n-\t\t\t0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n-\t\t\t0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n-\t\t\t0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,\n-\t\t},\n-\t\t[]byte{\n-\t\t\t0xcd, 0xc8, 0x0d, 0x6f, 0xdd, 0xf1, 0x8c, 0xab, 0x34, 0xc2, 0x59, 0x09, 0xc9, 0x9a, 0x41, 0x74,\n-\t\t\t0x67, 0xce, 0x7f, 0x7f, 0x81, 0x17, 0x36, 0x21, 0x96, 0x1a, 0x2b, 0x70, 0x17, 0x1d, 0x3d, 0x7a,\n-\t\t\t0x2e, 0x1e, 0x8a, 0x1d, 0xd5, 0x9b, 0x88, 0xb1, 0xc8, 0xe6, 0x0f, 0xed, 0x1e, 0xfa, 0xc4, 0xc9,\n-\t\t\t0xc0, 0x5f, 0x9f, 0x9c, 0xa9, 0x83, 0x4f, 0xa0, 0x42, 0xae, 0x8f, 0xba, 0x58, 0x4b, 0x09, 0xff,\n-\t\t},\n-\t},\n-\n-\t{\n-\t\t\"CFB128-AES256\",\n-\t\t128,\n-\t\tcommonKey256,\n-\t\tcommonIV,\n-\t\t[]byte{\n-\t\t\t0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n-\t\t\t0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n-\t\t\t0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n-\t\t\t0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,\n-\t\t},\n-\t\t[]byte{\n-\t\t\t0xdc, 0x7e, 0x84, 0xbf, 0xda, 0x79, 0x16, 0x4b, 0x7e, 0xcd, 0x84, 0x86, 0x98, 0x5d, 0x38, 0x60,\n-\t\t\t0x39, 0xff, 0xed, 0x14, 0x3b, 0x28, 0xb1, 0xc8, 0x32, 0x11, 0x3c, 0x63, 0x31, 0xe5, 0x40, 0x7b,\n-\t\t\t0xdf, 0x10, 0x13, 0x24, 0x15, 0xe5, 0x4b, 0x92, 0xa1, 0x3e, 0xd0, 0xa8, 0x26, 0x7a, 0xe2, 0xf9,\n-\t\t\t0x75, 0xa3, 0x85, 0x74, 0x1a, 0xb9, 0xce, 0xf8, 0x20, 0x31, 0x62, 0x3d, 0x55, 0xb1, 0xe4, 0x71,\n-\t\t},\n-\t},\n-}\n-\n-func TestCFB_AES(t *testing.T) {\n-\tfor _, tt := range cfbAESTests {\n-\t\ttest := tt.name\n-\n-\t\tif tt.s == 1 {\n-\t\t\t// 1-bit CFB not implemented\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tc, err := aes.NewCipher(tt.key)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%s: NewCipher(%d bytes) = %s\", test, len(tt.key), err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tvar crypt bytes.Buffer\n-\t\tw := NewCFBEncrypter(c, tt.s, tt.iv, &crypt)\n-\t\tvar r io.Reader = bytes.NewBuffer(tt.in)\n-\t\tn, err := io.Copy(w, r)\n-\t\tif n != int64(len(tt.in)) || err != nil {\n-\t\t\tt.Errorf(\"%s: CFBEncrypter io.Copy = %d, %v want %d, nil\", test, n, err, len(tt.in))\n-\t\t} else if d := crypt.Bytes(); !same(tt.out, d) {\n-\t\t\tt.Errorf(\"%s: CFBEncrypter\\nhave %x\\nwant %x\", test, d, tt.out)\n-\t\t}\n-\n-\t\tvar plain bytes.Buffer\n-\t\tr = NewCFBDecrypter(c, tt.s, tt.iv, bytes.NewBuffer(tt.out))\n-\t\tw = &plain\n-\t\tn, err = io.Copy(w, r)\n-\t\tif n != int64(len(tt.out)) || err != nil {\n-\t\t\tt.Errorf(\"%s: CFBDecrypter io.Copy = %d, %v want %d, nil\", test, n, err, len(tt.out))\n-\t\t} else if d := plain.Bytes(); !same(tt.in, d) {\n-\t\t\tt.Errorf(\"%s: CFBDecrypter\\nhave %x\\nwant %x\", test, d, tt.in)\n-\t\t}\n-\n-\t\tif t.Failed() {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-}"}, {"sha": "e1099e9a104d1e048280719eb1168a581b6a5416", "filename": "libgo/go/crypto/block/cipher.go", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fcipher.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,57 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// The block package is deprecated, use cipher instead.\n-// The block package implements standard block cipher modes\n-// that can be wrapped around low-level block cipher implementations.\n-// See http://csrc.nist.gov/groups/ST/toolkit/BCM/current_modes.html\n-// and NIST Special Publication 800-38A.\n-package block\n-\n-// A Cipher represents an implementation of block cipher\n-// using a given key.  It provides the capability to encrypt\n-// or decrypt individual blocks.  The mode implementations\n-// extend that capability to streams of blocks.\n-type Cipher interface {\n-\t// BlockSize returns the cipher's block size.\n-\tBlockSize() int\n-\n-\t// Encrypt encrypts the first block in src into dst.\n-\t// Src and dst may point at the same memory.\n-\tEncrypt(dst, src []byte)\n-\n-\t// Decrypt decrypts the first block in src into dst.\n-\t// Src and dst may point at the same memory.\n-\tDecrypt(dst, src []byte)\n-}\n-\n-// Utility routines\n-\n-func shift1(dst, src []byte) byte {\n-\tvar b byte\n-\tfor i := len(src) - 1; i >= 0; i-- {\n-\t\tbb := src[i] >> 7\n-\t\tdst[i] = src[i]<<1 | b\n-\t\tb = bb\n-\t}\n-\treturn b\n-}\n-\n-func same(p, q []byte) bool {\n-\tif len(p) != len(q) {\n-\t\treturn false\n-\t}\n-\tfor i := 0; i < len(p); i++ {\n-\t\tif p[i] != q[i] {\n-\t\t\treturn false\n-\t\t}\n-\t}\n-\treturn true\n-}\n-\n-func dup(p []byte) []byte {\n-\tq := make([]byte, len(p))\n-\tcopy(q, p)\n-\treturn q\n-}"}, {"sha": "b85cde72e1213d2fd7d599a49fc171b288ed2fc6", "filename": "libgo/go/crypto/block/cmac.go", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcmac.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcmac.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fcmac.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,105 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// CMAC message authentication code, defined in\n-// NIST Special Publication SP 800-38B.\n-\n-package block\n-\n-import (\n-\t\"hash\"\n-\t\"os\"\n-)\n-\n-const (\n-\t// minimal irreducible polynomial of degree b\n-\tr64  = 0x1b\n-\tr128 = 0x87\n-)\n-\n-type cmac struct {\n-\tk1, k2, ci, digest []byte\n-\tp                  int // position in ci\n-\tc                  Cipher\n-}\n-\n-// TODO(rsc): Should this return an error instead of panic?\n-\n-// NewCMAC returns a new instance of a CMAC message authentication code\n-// digest using the given Cipher.\n-func NewCMAC(c Cipher) hash.Hash {\n-\tvar r byte\n-\tn := c.BlockSize()\n-\tswitch n {\n-\tcase 64 / 8:\n-\t\tr = r64\n-\tcase 128 / 8:\n-\t\tr = r128\n-\tdefault:\n-\t\tpanic(\"crypto/block: NewCMAC: invalid cipher block size\")\n-\t}\n-\n-\td := new(cmac)\n-\td.c = c\n-\td.k1 = make([]byte, n)\n-\td.k2 = make([]byte, n)\n-\td.ci = make([]byte, n)\n-\td.digest = make([]byte, n)\n-\n-\t// Subkey generation, p. 7\n-\tc.Encrypt(d.k1, d.k1)\n-\tif shift1(d.k1, d.k1) != 0 {\n-\t\td.k1[n-1] ^= r\n-\t}\n-\tif shift1(d.k2, d.k1) != 0 {\n-\t\td.k2[n-1] ^= r\n-\t}\n-\n-\treturn d\n-}\n-\n-// Reset clears the digest state, starting a new digest.\n-func (d *cmac) Reset() {\n-\tfor i := range d.ci {\n-\t\td.ci[i] = 0\n-\t}\n-\td.p = 0\n-}\n-\n-// Write adds the given data to the digest state.\n-func (d *cmac) Write(p []byte) (n int, err os.Error) {\n-\t// Xor input into ci.\n-\tfor _, c := range p {\n-\t\t// If ci is full, encrypt and start over.\n-\t\tif d.p >= len(d.ci) {\n-\t\t\td.c.Encrypt(d.ci, d.ci)\n-\t\t\td.p = 0\n-\t\t}\n-\t\td.ci[d.p] ^= c\n-\t\td.p++\n-\t}\n-\treturn len(p), nil\n-}\n-\n-// Sum returns the CMAC digest, one cipher block in length,\n-// of the data written with Write.\n-func (d *cmac) Sum() []byte {\n-\t// Finish last block, mix in key, encrypt.\n-\t// Don't edit ci, in case caller wants\n-\t// to keep digesting after call to Sum.\n-\tk := d.k1\n-\tif d.p < len(d.digest) {\n-\t\tk = d.k2\n-\t}\n-\tfor i := 0; i < len(d.ci); i++ {\n-\t\td.digest[i] = d.ci[i] ^ k[i]\n-\t}\n-\tif d.p < len(d.digest) {\n-\t\td.digest[d.p] ^= 0x80\n-\t}\n-\td.c.Encrypt(d.digest, d.digest)\n-\treturn d.digest\n-}\n-\n-func (d *cmac) Size() int { return len(d.digest) }"}, {"sha": "0a4a1a418e9b99ca489bd3c42215a5f3216a1697", "filename": "libgo/go/crypto/block/cmac_aes_test.go", "status": "removed", "additions": 0, "deletions": 130, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcmac_aes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fcmac_aes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fcmac_aes_test.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,130 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// CMAC test vectors.  See NIST SP 800-38B, Appendix D.\n-\n-package block\n-\n-import (\n-\t\"crypto/aes\"\n-\t\"testing\"\n-)\n-\n-type cmacAESTest struct {\n-\tkey    []byte\n-\tin     []byte\n-\tdigest []byte\n-}\n-\n-var cmacAESTests = []cmacAESTest{\n-\t{\n-\t\tcommonKey128,\n-\t\tnil,\n-\t\t[]byte{0xbb, 0x1d, 0x69, 0x29, 0xe9, 0x59, 0x37, 0x28, 0x7f, 0xa3, 0x7d, 0x12, 0x9b, 0x75, 0x67, 0x46},\n-\t},\n-\t{\n-\t\tcommonKey128,\n-\t\t[]byte{0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a},\n-\t\t[]byte{0x07, 0x0a, 0x16, 0xb4, 0x6b, 0x4d, 0x41, 0x44, 0xf7, 0x9b, 0xdd, 0x9d, 0xd0, 0x4a, 0x28, 0x7c},\n-\t},\n-\t{\n-\t\tcommonKey128,\n-\t\t[]byte{\n-\t\t\t0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n-\t\t\t0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n-\t\t\t0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,\n-\t\t},\n-\t\t[]byte{0xdf, 0xa6, 0x67, 0x47, 0xde, 0x9a, 0xe6, 0x30, 0x30, 0xca, 0x32, 0x61, 0x14, 0x97, 0xc8, 0x27},\n-\t},\n-\t{\n-\t\tcommonKey128,\n-\t\t[]byte{\n-\t\t\t0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n-\t\t\t0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n-\t\t\t0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n-\t\t\t0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,\n-\t\t},\n-\t\t[]byte{0x51, 0xf0, 0xbe, 0xbf, 0x7e, 0x3b, 0x9d, 0x92, 0xfc, 0x49, 0x74, 0x17, 0x79, 0x36, 0x3c, 0xfe},\n-\t},\n-\t{\n-\t\tcommonKey192,\n-\t\tnil,\n-\t\t[]byte{0xd1, 0x7d, 0xdf, 0x46, 0xad, 0xaa, 0xcd, 0xe5, 0x31, 0xca, 0xc4, 0x83, 0xde, 0x7a, 0x93, 0x67},\n-\t},\n-\t{\n-\t\tcommonKey192,\n-\t\t[]byte{0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a},\n-\t\t[]byte{0x9e, 0x99, 0xa7, 0xbf, 0x31, 0xe7, 0x10, 0x90, 0x06, 0x62, 0xf6, 0x5e, 0x61, 0x7c, 0x51, 0x84},\n-\t},\n-\t{\n-\t\tcommonKey192,\n-\t\t[]byte{\n-\t\t\t0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n-\t\t\t0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n-\t\t\t0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,\n-\t\t},\n-\t\t[]byte{0x8a, 0x1d, 0xe5, 0xbe, 0x2e, 0xb3, 0x1a, 0xad, 0x08, 0x9a, 0x82, 0xe6, 0xee, 0x90, 0x8b, 0x0e},\n-\t},\n-\t{\n-\t\tcommonKey192,\n-\t\t[]byte{\n-\t\t\t0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n-\t\t\t0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n-\t\t\t0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n-\t\t\t0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,\n-\t\t},\n-\t\t[]byte{0xa1, 0xd5, 0xdf, 0x0e, 0xed, 0x79, 0x0f, 0x79, 0x4d, 0x77, 0x58, 0x96, 0x59, 0xf3, 0x9a, 0x11},\n-\t},\n-\t{\n-\t\tcommonKey256,\n-\t\tnil,\n-\t\t[]byte{0x02, 0x89, 0x62, 0xf6, 0x1b, 0x7b, 0xf8, 0x9e, 0xfc, 0x6b, 0x55, 0x1f, 0x46, 0x67, 0xd9, 0x83},\n-\t},\n-\t{\n-\t\tcommonKey256,\n-\t\t[]byte{0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a},\n-\t\t[]byte{0x28, 0xa7, 0x02, 0x3f, 0x45, 0x2e, 0x8f, 0x82, 0xbd, 0x4b, 0xf2, 0x8d, 0x8c, 0x37, 0xc3, 0x5c},\n-\t},\n-\t{\n-\t\tcommonKey256,\n-\t\t[]byte{\n-\t\t\t0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n-\t\t\t0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n-\t\t\t0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11,\n-\t\t},\n-\t\t[]byte{0xaa, 0xf3, 0xd8, 0xf1, 0xde, 0x56, 0x40, 0xc2, 0x32, 0xf5, 0xb1, 0x69, 0xb9, 0xc9, 0x11, 0xe6},\n-\t},\n-\t{\n-\t\tcommonKey256,\n-\t\t[]byte{\n-\t\t\t0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n-\t\t\t0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n-\t\t\t0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n-\t\t\t0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,\n-\t\t},\n-\t\t[]byte{0xe1, 0x99, 0x21, 0x90, 0x54, 0x9f, 0x6e, 0xd5, 0x69, 0x6a, 0x2c, 0x05, 0x6c, 0x31, 0x54, 0x10},\n-\t},\n-}\n-\n-func TestCMAC_AES(t *testing.T) {\n-\tfor i, tt := range cmacAESTests {\n-\t\tc, err := aes.NewCipher(tt.key)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"test %d: NewCipher: %s\", i, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\td := NewCMAC(c)\n-\t\tn, err := d.Write(tt.in)\n-\t\tif err != nil || n != len(tt.in) {\n-\t\t\tt.Errorf(\"test %d: Write %d: %d, %s\", i, len(tt.in), n, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tsum := d.Sum()\n-\t\tif !same(sum, tt.digest) {\n-\t\t\tx := d.(*cmac)\n-\t\t\tt.Errorf(\"test %d: digest mismatch\\n\\twant %x\\n\\thave %x\\n\\tk1 %x\\n\\tk2 %x\", i, tt.digest, sum, x.k1, x.k2)\n-\t\t\tcontinue\n-\t\t}\n-\t}\n-}"}, {"sha": "5d65c0c9a9e9e0ef50bae8200483b07debc02c12", "filename": "libgo/go/crypto/block/ctr.go", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fctr.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fctr.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fctr.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Counter (CTR) mode.\n-\n-// CTR converts a block cipher into a stream cipher by\n-// repeatedly encrypting an incrementing counter and\n-// xoring the resulting stream of data with the input.\n-\n-// See NIST SP 800-38A, pp 13-15\n-\n-package block\n-\n-import (\n-\t\"io\"\n-)\n-\n-type ctrStream struct {\n-\tc   Cipher\n-\tctr []byte\n-\tout []byte\n-}\n-\n-func newCTRStream(c Cipher, ctr []byte) *ctrStream {\n-\tx := new(ctrStream)\n-\tx.c = c\n-\tx.ctr = dup(ctr)\n-\tx.out = make([]byte, len(ctr))\n-\treturn x\n-}\n-\n-func (x *ctrStream) Next() []byte {\n-\t// Next block is encryption of counter.\n-\tx.c.Encrypt(x.out, x.ctr)\n-\n-\t// Increment counter\n-\tfor i := len(x.ctr) - 1; i >= 0; i-- {\n-\t\tx.ctr[i]++\n-\t\tif x.ctr[i] != 0 {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\n-\treturn x.out\n-}\n-\n-// NewCTRReader returns a reader that reads data from r, decrypts (or encrypts)\n-// it using c in counter (CTR) mode with the initialization vector iv.\n-// The returned Reader does not buffer and has no block size.\n-// In CTR mode, encryption and decryption are the same operation:\n-// a CTR reader applied to an encrypted stream produces a decrypted\n-// stream and vice versa.\n-func NewCTRReader(c Cipher, iv []byte, r io.Reader) io.Reader {\n-\treturn newXorReader(newCTRStream(c, iv), r)\n-}\n-\n-// NewCTRWriter returns a writer that encrypts (or decrypts) data using c\n-// in counter (CTR) mode with the initialization vector iv\n-// and writes the encrypted data to w.\n-// The returned Writer does not buffer and has no block size.\n-// In CTR mode, encryption and decryption are the same operation:\n-// a CTR writer applied to an decrypted stream produces an encrypted\n-// stream and vice versa.\n-func NewCTRWriter(c Cipher, iv []byte, w io.Writer) io.Writer {\n-\treturn newXorWriter(newCTRStream(c, iv), w)\n-}"}, {"sha": "3f3b96431e70140c477caca8ac40a0735306b971", "filename": "libgo/go/crypto/block/eax.go", "status": "removed", "additions": 0, "deletions": 253, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Feax.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Feax.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Feax.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,253 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// EAX mode, not a NIST standard (yet).\n-// EAX provides encryption and authentication.\n-// EAX targets the same uses as NIST's CCM mode,\n-// but EAX adds the ability to run in streaming mode.\n-\n-// See\n-// http://csrc.nist.gov/groups/ST/toolkit/BCM/documents/proposedmodes/eax/eax-spec.pdf\n-// http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf\n-// What those papers call OMAC is now called CMAC.\n-\n-package block\n-\n-import (\n-\t\"fmt\"\n-\t\"hash\"\n-\t\"io\"\n-\t\"os\"\n-)\n-\n-// An EAXTagError is returned when the message has failed to authenticate,\n-// because the tag at the end of the message stream (Read) does not match\n-// the tag computed from the message itself (Computed).\n-type EAXTagError struct {\n-\tRead     []byte\n-\tComputed []byte\n-}\n-\n-func (e *EAXTagError) String() string {\n-\treturn fmt.Sprintf(\"crypto/block: EAX tag mismatch: read %x but computed %x\", e.Read, e.Computed)\n-}\n-\n-func setupEAX(c Cipher, iv, hdr []byte, tagBytes int) (ctrIV, tag []byte, cmac hash.Hash) {\n-\tn := len(iv)\n-\tif n != c.BlockSize() {\n-\t\tpanic(fmt.Sprintln(\"crypto/block: EAX: iv length\", n, \"!=\", c.BlockSize()))\n-\t}\n-\tbuf := make([]byte, n) // zeroed\n-\n-\t// tag = CMAC(0 + iv) ^ CMAC(1 + hdr) ^ CMAC(2 + data)\n-\tcmac = NewCMAC(c)\n-\tcmac.Write(buf) // 0\n-\tcmac.Write(iv)\n-\tsum := cmac.Sum()\n-\tctrIV = dup(sum)\n-\ttag = dup(sum[0:tagBytes])\n-\n-\tcmac.Reset()\n-\tbuf[n-1] = 1\n-\tcmac.Write(buf) // 1\n-\tcmac.Write(hdr)\n-\tsum = cmac.Sum()\n-\tfor i := 0; i < tagBytes; i++ {\n-\t\ttag[i] ^= sum[i]\n-\t}\n-\n-\tcmac.Reset()\n-\tbuf[n-1] = 2 // 2\n-\tcmac.Write(buf)\n-\n-\treturn\n-}\n-\n-func finishEAX(tag []byte, cmac hash.Hash) {\n-\t// Finish CMAC #2 and xor into tag.\n-\tsum := cmac.Sum()\n-\tfor i := range tag {\n-\t\ttag[i] ^= sum[i]\n-\t}\n-}\n-\n-// Writer adapter.  Tees writes into both w and cmac.\n-// Knows that cmac never returns write errors.\n-type cmacWriter struct {\n-\tw    io.Writer\n-\tcmac hash.Hash\n-}\n-\n-func (cw *cmacWriter) Write(p []byte) (n int, err os.Error) {\n-\tn, err = cw.w.Write(p)\n-\tcw.cmac.Write(p[0:n])\n-\treturn\n-}\n-\n-// An eaxEncrypter implements the EAX encryption mode.\n-type eaxEncrypter struct {\n-\tctr io.Writer  // CTR encrypter\n-\tcw  cmacWriter // CTR's output stream\n-\ttag []byte\n-}\n-\n-// NewEAXEncrypter creates and returns a new EAX encrypter\n-// using the given cipher c, initialization vector iv, associated data hdr,\n-// and tag length tagBytes.  The encrypter's Write method encrypts\n-// the data it receives and writes that data to w.\n-// The encrypter's Close method writes a final authenticating tag to w.\n-func NewEAXEncrypter(c Cipher, iv []byte, hdr []byte, tagBytes int, w io.Writer) io.WriteCloser {\n-\tx := new(eaxEncrypter)\n-\n-\t// Create new CTR instance writing to both\n-\t// w for encrypted output and cmac for digesting.\n-\tx.cw.w = w\n-\tvar ctrIV []byte\n-\tctrIV, x.tag, x.cw.cmac = setupEAX(c, iv, hdr, tagBytes)\n-\tx.ctr = NewCTRWriter(c, ctrIV, &x.cw)\n-\treturn x\n-}\n-\n-func (x *eaxEncrypter) Write(p []byte) (n int, err os.Error) {\n-\treturn x.ctr.Write(p)\n-}\n-\n-func (x *eaxEncrypter) Close() os.Error {\n-\tx.ctr = nil // crash if Write is called again\n-\n-\t// Write tag.\n-\tfinishEAX(x.tag, x.cw.cmac)\n-\tn, err := x.cw.w.Write(x.tag)\n-\tif n != len(x.tag) && err == nil {\n-\t\terr = io.ErrShortWrite\n-\t}\n-\n-\treturn err\n-}\n-\n-// Reader adapter.  Returns data read from r but hangs\n-// on to the last len(tag) bytes for itself (returns EOF len(tag)\n-// bytes early).  Also tees all data returned from Read into\n-// the cmac digest.  The \"don't return the last t bytes\"\n-// and the \"tee into digest\" functionality could be separated,\n-// but the latter half is trivial.\n-type cmacReader struct {\n-\tr    io.Reader\n-\tcmac hash.Hash\n-\ttag  []byte\n-\ttmp  []byte\n-}\n-\n-func (cr *cmacReader) Read(p []byte) (n int, err os.Error) {\n-\t// TODO(rsc): Maybe fall back to simpler code if\n-\t// we recognize the underlying r as a ByteBuffer\n-\t// or ByteReader.  Then we can just take the last piece\n-\t// off at the start.\n-\n-\t// First, read a tag-sized chunk.\n-\t// It's probably not the tag (unless there's no data).\n-\ttag := cr.tag\n-\tif len(tag) < cap(tag) {\n-\t\tnt := len(tag)\n-\t\tnn, err1 := io.ReadFull(cr.r, tag[nt:cap(tag)])\n-\t\ttag = tag[0 : nt+nn]\n-\t\tcr.tag = tag\n-\t\tif err1 != nil {\n-\t\t\treturn 0, err1\n-\t\t}\n-\t}\n-\n-\ttagBytes := len(tag)\n-\tif len(p) > 4*tagBytes {\n-\t\t// If p is big, try to read directly into p to avoid a copy.\n-\t\tn, err = cr.r.Read(p[tagBytes:])\n-\t\tif n == 0 {\n-\t\t\tgoto out\n-\t\t}\n-\t\t// copy old tag into p\n-\t\tfor i := 0; i < tagBytes; i++ {\n-\t\t\tp[i] = tag[i]\n-\t\t}\n-\t\t// copy new tag out of p\n-\t\tfor i := 0; i < tagBytes; i++ {\n-\t\t\ttag[i] = p[n+i]\n-\t\t}\n-\t\tgoto out\n-\t}\n-\n-\t// Otherwise, read into p and then slide data\n-\tn, err = cr.r.Read(p)\n-\tif n == 0 {\n-\t\tgoto out\n-\t}\n-\n-\t// copy tag+p into p+tmp and then swap tmp, tag\n-\ttmp := cr.tmp\n-\tfor i := n + tagBytes - 1; i >= 0; i-- {\n-\t\tvar c byte\n-\t\tif i < tagBytes {\n-\t\t\tc = tag[i]\n-\t\t} else {\n-\t\t\tc = p[i-tagBytes]\n-\t\t}\n-\t\tif i < n {\n-\t\t\tp[i] = c\n-\t\t} else {\n-\t\t\ttmp[i] = c\n-\t\t}\n-\t}\n-\tcr.tmp, cr.tag = tag, tmp\n-\n-out:\n-\tcr.cmac.Write(p[0:n])\n-\treturn\n-}\n-\n-type eaxDecrypter struct {\n-\tctr io.Reader\n-\tcr  cmacReader\n-\ttag []byte\n-}\n-\n-// NewEAXDecrypter creates and returns a new EAX decrypter\n-// using the given cipher c, initialization vector iv, associated data hdr,\n-// and tag length tagBytes.  The encrypter's Read method decrypts and\n-// returns data read from r.  At r's EOF, the encrypter checks the final\n-// authenticating tag and returns an EAXTagError if the tag is invalid.\n-// In that case, the message should be discarded.\n-// Note that the data stream returned from Read cannot be\n-// assumed to be valid, authenticated data until Read returns\n-// 0, nil to signal the end of the data.\n-func NewEAXDecrypter(c Cipher, iv []byte, hdr []byte, tagBytes int, r io.Reader) io.Reader {\n-\tx := new(eaxDecrypter)\n-\n-\tx.cr.r = r\n-\tx.cr.tag = make([]byte, 0, tagBytes)\n-\tx.cr.tmp = make([]byte, 0, tagBytes)\n-\tvar ctrIV []byte\n-\tctrIV, x.tag, x.cr.cmac = setupEAX(c, iv, hdr, tagBytes)\n-\tx.ctr = NewCTRReader(c, ctrIV, &x.cr)\n-\treturn x\n-}\n-\n-func (x *eaxDecrypter) checkTag() os.Error {\n-\tx.ctr = nil // crash if Read is called again\n-\n-\tfinishEAX(x.tag, x.cr.cmac)\n-\tif !same(x.tag, x.cr.tag) {\n-\t\te := new(EAXTagError)\n-\t\te.Computed = dup(x.tag)\n-\t\te.Read = dup(x.cr.tag)\n-\t\treturn e\n-\t}\n-\treturn nil\n-}\n-\n-func (x *eaxDecrypter) Read(p []byte) (n int, err os.Error) {\n-\tn, err = x.ctr.Read(p)\n-\tif n == 0 && err == nil {\n-\t\terr = x.checkTag()\n-\t}\n-\treturn n, err\n-}"}, {"sha": "93aa771be88806c519e809d5d449484fd5fc659e", "filename": "libgo/go/crypto/block/eax_aes_test.go", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Feax_aes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Feax_aes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Feax_aes_test.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,140 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package block\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/aes\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"testing\"\n-)\n-\n-// Test vectors from http://www.cs.ucdavis.edu/~rogaway/papers/eax.pdf\n-\n-type eaxAESTest struct {\n-\tmsg    []byte\n-\tkey    []byte\n-\tnonce  []byte\n-\theader []byte\n-\tcipher []byte\n-}\n-\n-var eaxAESTests = []eaxAESTest{\n-\t{\n-\t\t[]byte{},\n-\t\t[]byte{0x23, 0x39, 0x52, 0xDE, 0xE4, 0xD5, 0xED, 0x5F, 0x9B, 0x9C, 0x6D, 0x6F, 0xF8, 0x0F, 0xF4, 0x78},\n-\t\t[]byte{0x62, 0xEC, 0x67, 0xF9, 0xC3, 0xA4, 0xA4, 0x07, 0xFC, 0xB2, 0xA8, 0xC4, 0x90, 0x31, 0xA8, 0xB3},\n-\t\t[]byte{0x6B, 0xFB, 0x91, 0x4F, 0xD0, 0x7E, 0xAE, 0x6B},\n-\t\t[]byte{0xE0, 0x37, 0x83, 0x0E, 0x83, 0x89, 0xF2, 0x7B, 0x02, 0x5A, 0x2D, 0x65, 0x27, 0xE7, 0x9D, 0x01},\n-\t},\n-\t{\n-\t\t[]byte{0xF7, 0xFB},\n-\t\t[]byte{0x91, 0x94, 0x5D, 0x3F, 0x4D, 0xCB, 0xEE, 0x0B, 0xF4, 0x5E, 0xF5, 0x22, 0x55, 0xF0, 0x95, 0xA4},\n-\t\t[]byte{0xBE, 0xCA, 0xF0, 0x43, 0xB0, 0xA2, 0x3D, 0x84, 0x31, 0x94, 0xBA, 0x97, 0x2C, 0x66, 0xDE, 0xBD},\n-\t\t[]byte{0xFA, 0x3B, 0xFD, 0x48, 0x06, 0xEB, 0x53, 0xFA},\n-\t\t[]byte{0x19, 0xDD, 0x5C, 0x4C, 0x93, 0x31, 0x04, 0x9D, 0x0B, 0xDA, 0xB0, 0x27, 0x74, 0x08, 0xF6, 0x79, 0x67, 0xE5},\n-\t},\n-\t{\n-\t\t[]byte{0x1A, 0x47, 0xCB, 0x49, 0x33},\n-\t\t[]byte{0x01, 0xF7, 0x4A, 0xD6, 0x40, 0x77, 0xF2, 0xE7, 0x04, 0xC0, 0xF6, 0x0A, 0xDA, 0x3D, 0xD5, 0x23},\n-\t\t[]byte{0x70, 0xC3, 0xDB, 0x4F, 0x0D, 0x26, 0x36, 0x84, 0x00, 0xA1, 0x0E, 0xD0, 0x5D, 0x2B, 0xFF, 0x5E},\n-\t\t[]byte{0x23, 0x4A, 0x34, 0x63, 0xC1, 0x26, 0x4A, 0xC6},\n-\t\t[]byte{0xD8, 0x51, 0xD5, 0xBA, 0xE0, 0x3A, 0x59, 0xF2, 0x38, 0xA2, 0x3E, 0x39, 0x19, 0x9D, 0xC9, 0x26, 0x66, 0x26, 0xC4, 0x0F, 0x80},\n-\t},\n-\t{\n-\t\t[]byte{0x48, 0x1C, 0x9E, 0x39, 0xB1},\n-\t\t[]byte{0xD0, 0x7C, 0xF6, 0xCB, 0xB7, 0xF3, 0x13, 0xBD, 0xDE, 0x66, 0xB7, 0x27, 0xAF, 0xD3, 0xC5, 0xE8},\n-\t\t[]byte{0x84, 0x08, 0xDF, 0xFF, 0x3C, 0x1A, 0x2B, 0x12, 0x92, 0xDC, 0x19, 0x9E, 0x46, 0xB7, 0xD6, 0x17},\n-\t\t[]byte{0x33, 0xCC, 0xE2, 0xEA, 0xBF, 0xF5, 0xA7, 0x9D},\n-\t\t[]byte{0x63, 0x2A, 0x9D, 0x13, 0x1A, 0xD4, 0xC1, 0x68, 0xA4, 0x22, 0x5D, 0x8E, 0x1F, 0xF7, 0x55, 0x93, 0x99, 0x74, 0xA7, 0xBE, 0xDE},\n-\t},\n-\t{\n-\t\t[]byte{0x40, 0xD0, 0xC0, 0x7D, 0xA5, 0xE4},\n-\t\t[]byte{0x35, 0xB6, 0xD0, 0x58, 0x00, 0x05, 0xBB, 0xC1, 0x2B, 0x05, 0x87, 0x12, 0x45, 0x57, 0xD2, 0xC2},\n-\t\t[]byte{0xFD, 0xB6, 0xB0, 0x66, 0x76, 0xEE, 0xDC, 0x5C, 0x61, 0xD7, 0x42, 0x76, 0xE1, 0xF8, 0xE8, 0x16},\n-\t\t[]byte{0xAE, 0xB9, 0x6E, 0xAE, 0xBE, 0x29, 0x70, 0xE9},\n-\t\t[]byte{0x07, 0x1D, 0xFE, 0x16, 0xC6, 0x75, 0xCB, 0x06, 0x77, 0xE5, 0x36, 0xF7, 0x3A, 0xFE, 0x6A, 0x14, 0xB7, 0x4E, 0xE4, 0x98, 0x44, 0xDD},\n-\t},\n-\t{\n-\t\t[]byte{0x4D, 0xE3, 0xB3, 0x5C, 0x3F, 0xC0, 0x39, 0x24, 0x5B, 0xD1, 0xFB, 0x7D},\n-\t\t[]byte{0xBD, 0x8E, 0x6E, 0x11, 0x47, 0x5E, 0x60, 0xB2, 0x68, 0x78, 0x4C, 0x38, 0xC6, 0x2F, 0xEB, 0x22},\n-\t\t[]byte{0x6E, 0xAC, 0x5C, 0x93, 0x07, 0x2D, 0x8E, 0x85, 0x13, 0xF7, 0x50, 0x93, 0x5E, 0x46, 0xDA, 0x1B},\n-\t\t[]byte{0xD4, 0x48, 0x2D, 0x1C, 0xA7, 0x8D, 0xCE, 0x0F},\n-\t\t[]byte{0x83, 0x5B, 0xB4, 0xF1, 0x5D, 0x74, 0x3E, 0x35, 0x0E, 0x72, 0x84, 0x14, 0xAB, 0xB8, 0x64, 0x4F, 0xD6, 0xCC, 0xB8, 0x69, 0x47, 0xC5, 0xE1, 0x05, 0x90, 0x21, 0x0A, 0x4F},\n-\t},\n-\t{\n-\t\t[]byte{0x8B, 0x0A, 0x79, 0x30, 0x6C, 0x9C, 0xE7, 0xED, 0x99, 0xDA, 0xE4, 0xF8, 0x7F, 0x8D, 0xD6, 0x16, 0x36},\n-\t\t[]byte{0x7C, 0x77, 0xD6, 0xE8, 0x13, 0xBE, 0xD5, 0xAC, 0x98, 0xBA, 0xA4, 0x17, 0x47, 0x7A, 0x2E, 0x7D},\n-\t\t[]byte{0x1A, 0x8C, 0x98, 0xDC, 0xD7, 0x3D, 0x38, 0x39, 0x3B, 0x2B, 0xF1, 0x56, 0x9D, 0xEE, 0xFC, 0x19},\n-\t\t[]byte{0x65, 0xD2, 0x01, 0x79, 0x90, 0xD6, 0x25, 0x28},\n-\t\t[]byte{0x02, 0x08, 0x3E, 0x39, 0x79, 0xDA, 0x01, 0x48, 0x12, 0xF5, 0x9F, 0x11, 0xD5, 0x26, 0x30, 0xDA, 0x30, 0x13, 0x73, 0x27, 0xD1, 0x06, 0x49, 0xB0, 0xAA, 0x6E, 0x1C, 0x18, 0x1D, 0xB6, 0x17, 0xD7, 0xF2},\n-\t},\n-\t{\n-\t\t[]byte{0x1B, 0xDA, 0x12, 0x2B, 0xCE, 0x8A, 0x8D, 0xBA, 0xF1, 0x87, 0x7D, 0x96, 0x2B, 0x85, 0x92, 0xDD, 0x2D, 0x56},\n-\t\t[]byte{0x5F, 0xFF, 0x20, 0xCA, 0xFA, 0xB1, 0x19, 0xCA, 0x2F, 0xC7, 0x35, 0x49, 0xE2, 0x0F, 0x5B, 0x0D},\n-\t\t[]byte{0xDD, 0xE5, 0x9B, 0x97, 0xD7, 0x22, 0x15, 0x6D, 0x4D, 0x9A, 0xFF, 0x2B, 0xC7, 0x55, 0x98, 0x26},\n-\t\t[]byte{0x54, 0xB9, 0xF0, 0x4E, 0x6A, 0x09, 0x18, 0x9A},\n-\t\t[]byte{0x2E, 0xC4, 0x7B, 0x2C, 0x49, 0x54, 0xA4, 0x89, 0xAF, 0xC7, 0xBA, 0x48, 0x97, 0xED, 0xCD, 0xAE, 0x8C, 0xC3, 0x3B, 0x60, 0x45, 0x05, 0x99, 0xBD, 0x02, 0xC9, 0x63, 0x82, 0x90, 0x2A, 0xEF, 0x7F, 0x83, 0x2A},\n-\t},\n-\t{\n-\t\t[]byte{0x6C, 0xF3, 0x67, 0x20, 0x87, 0x2B, 0x85, 0x13, 0xF6, 0xEA, 0xB1, 0xA8, 0xA4, 0x44, 0x38, 0xD5, 0xEF, 0x11},\n-\t\t[]byte{0xA4, 0xA4, 0x78, 0x2B, 0xCF, 0xFD, 0x3E, 0xC5, 0xE7, 0xEF, 0x6D, 0x8C, 0x34, 0xA5, 0x61, 0x23},\n-\t\t[]byte{0xB7, 0x81, 0xFC, 0xF2, 0xF7, 0x5F, 0xA5, 0xA8, 0xDE, 0x97, 0xA9, 0xCA, 0x48, 0xE5, 0x22, 0xEC},\n-\t\t[]byte{0x89, 0x9A, 0x17, 0x58, 0x97, 0x56, 0x1D, 0x7E},\n-\t\t[]byte{0x0D, 0xE1, 0x8F, 0xD0, 0xFD, 0xD9, 0x1E, 0x7A, 0xF1, 0x9F, 0x1D, 0x8E, 0xE8, 0x73, 0x39, 0x38, 0xB1, 0xE8, 0xE7, 0xF6, 0xD2, 0x23, 0x16, 0x18, 0x10, 0x2F, 0xDB, 0x7F, 0xE5, 0x5F, 0xF1, 0x99, 0x17, 0x00},\n-\t},\n-\t{\n-\t\t[]byte{0xCA, 0x40, 0xD7, 0x44, 0x6E, 0x54, 0x5F, 0xFA, 0xED, 0x3B, 0xD1, 0x2A, 0x74, 0x0A, 0x65, 0x9F, 0xFB, 0xBB, 0x3C, 0xEA, 0xB7},\n-\t\t[]byte{0x83, 0x95, 0xFC, 0xF1, 0xE9, 0x5B, 0xEB, 0xD6, 0x97, 0xBD, 0x01, 0x0B, 0xC7, 0x66, 0xAA, 0xC3},\n-\t\t[]byte{0x22, 0xE7, 0xAD, 0xD9, 0x3C, 0xFC, 0x63, 0x93, 0xC5, 0x7E, 0xC0, 0xB3, 0xC1, 0x7D, 0x6B, 0x44},\n-\t\t[]byte{0x12, 0x67, 0x35, 0xFC, 0xC3, 0x20, 0xD2, 0x5A},\n-\t\t[]byte{0xCB, 0x89, 0x20, 0xF8, 0x7A, 0x6C, 0x75, 0xCF, 0xF3, 0x96, 0x27, 0xB5, 0x6E, 0x3E, 0xD1, 0x97, 0xC5, 0x52, 0xD2, 0x95, 0xA7, 0xCF, 0xC4, 0x6A, 0xFC, 0x25, 0x3B, 0x46, 0x52, 0xB1, 0xAF, 0x37, 0x95, 0xB1, 0x24, 0xAB, 0x6E},\n-\t},\n-}\n-\n-func TestEAXEncrypt_AES(t *testing.T) {\n-\tb := new(bytes.Buffer)\n-\tfor i, tt := range eaxAESTests {\n-\t\ttest := fmt.Sprintf(\"test %d\", i)\n-\t\tc, err := aes.NewCipher(tt.key)\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"%s: NewCipher(%d bytes) = %s\", test, len(tt.key), err)\n-\t\t}\n-\t\tb.Reset()\n-\t\tenc := NewEAXEncrypter(c, tt.nonce, tt.header, 16, b)\n-\t\tn, err := io.Copy(enc, bytes.NewBuffer(tt.msg))\n-\t\tif n != int64(len(tt.msg)) || err != nil {\n-\t\t\tt.Fatalf(\"%s: io.Copy into encrypter: %d, %s\", test, n, err)\n-\t\t}\n-\t\terr = enc.Close()\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"%s: enc.Close: %s\", test, err)\n-\t\t}\n-\t\tif d := b.Bytes(); !same(d, tt.cipher) {\n-\t\t\tt.Fatalf(\"%s: got %x want %x\", test, d, tt.cipher)\n-\t\t}\n-\t}\n-}\n-\n-func TestEAXDecrypt_AES(t *testing.T) {\n-\tb := new(bytes.Buffer)\n-\tfor i, tt := range eaxAESTests {\n-\t\ttest := fmt.Sprintf(\"test %d\", i)\n-\t\tc, err := aes.NewCipher(tt.key)\n-\t\tif err != nil {\n-\t\t\tt.Fatalf(\"%s: NewCipher(%d bytes) = %s\", test, len(tt.key), err)\n-\t\t}\n-\t\tb.Reset()\n-\t\tdec := NewEAXDecrypter(c, tt.nonce, tt.header, 16, bytes.NewBuffer(tt.cipher))\n-\t\tn, err := io.Copy(b, dec)\n-\t\tif n != int64(len(tt.msg)) || err != nil {\n-\t\t\tt.Fatalf(\"%s: io.Copy into decrypter: %d, %s\", test, n, err)\n-\t\t}\n-\t\tif d := b.Bytes(); !same(d, tt.msg) {\n-\t\t\tt.Fatalf(\"%s: got %x want %x\", test, d, tt.msg)\n-\t\t}\n-\t}\n-}"}, {"sha": "cf09f7cb3fbda150b899fd96249a6d2be8c26d94", "filename": "libgo/go/crypto/block/ecb.go", "status": "removed", "additions": 0, "deletions": 270, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fecb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fecb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fecb.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,270 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Electronic codebook (ECB) mode.\n-// ECB is a fancy name for ``encrypt and decrypt each block separately.''\n-// It's a pretty bad thing to do for any large amount of data (more than one block),\n-// because the individual blocks can still be identified, duplicated, and reordered.\n-// The ECB implementation exists mainly to provide buffering for\n-// the other modes, which wrap it by providing modified Ciphers.\n-\n-// See NIST SP 800-38A, pp 9-10\n-\n-package block\n-\n-import (\n-\t\"io\"\n-\t\"os\"\n-\t\"strconv\"\n-)\n-\n-type ecbDecrypter struct {\n-\tc         Cipher\n-\tr         io.Reader\n-\tblockSize int // block size\n-\n-\t// Buffered data.\n-\t// The buffer buf is used as storage for both\n-\t// plain or crypt; at least one of those is nil at any given time.\n-\tbuf   []byte\n-\tplain []byte // plain text waiting to be read\n-\tcrypt []byte // ciphertext waiting to be decrypted\n-}\n-\n-// Read into x.crypt until it has a full block or EOF or an error happens.\n-func (x *ecbDecrypter) fillCrypt() os.Error {\n-\tvar err os.Error\n-\tfor len(x.crypt) < x.blockSize {\n-\t\toff := len(x.crypt)\n-\t\tvar m int\n-\t\tm, err = x.r.Read(x.crypt[off:x.blockSize])\n-\t\tx.crypt = x.crypt[0 : off+m]\n-\t\tif m == 0 {\n-\t\t\tbreak\n-\t\t}\n-\n-\t\t// If an error happened but we got enough\n-\t\t// data to do some decryption, we can decrypt\n-\t\t// first and report the error (with some data) later.\n-\t\t// But if we don't have enough to decrypt,\n-\t\t// have to stop now.\n-\t\tif err != nil && len(x.crypt) < x.blockSize {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\treturn err\n-}\n-\n-// Read from plain text buffer into p.\n-func (x *ecbDecrypter) readPlain(p []byte) int {\n-\tn := len(x.plain)\n-\tif n > len(p) {\n-\t\tn = len(p)\n-\t}\n-\tfor i := 0; i < n; i++ {\n-\t\tp[i] = x.plain[i]\n-\t}\n-\tif n < len(x.plain) {\n-\t\tx.plain = x.plain[n:]\n-\t} else {\n-\t\tx.plain = nil\n-\t}\n-\treturn n\n-}\n-\n-type ecbFragmentError int\n-\n-func (n ecbFragmentError) String() string {\n-\treturn \"crypto/block: \" + strconv.Itoa(int(n)) + \"-byte fragment at EOF\"\n-}\n-\n-func (x *ecbDecrypter) Read(p []byte) (n int, err os.Error) {\n-\tif len(p) == 0 {\n-\t\treturn\n-\t}\n-\n-\t// If there's no plaintext waiting and p is not big enough\n-\t// to hold a whole cipher block, we'll have to work in the\n-\t// cipher text buffer.  Set it to non-nil so that the\n-\t// code below will fill it.\n-\tif x.plain == nil && len(p) < x.blockSize && x.crypt == nil {\n-\t\tx.crypt = x.buf[0:0]\n-\t}\n-\n-\t// If there is a leftover cipher text buffer,\n-\t// try to accumulate a full block.\n-\tif x.crypt != nil {\n-\t\terr = x.fillCrypt()\n-\t\tif err != nil || len(x.crypt) == 0 {\n-\t\t\treturn\n-\t\t}\n-\t\tx.c.Decrypt(x.crypt, x.crypt)\n-\t\tx.plain = x.crypt\n-\t\tx.crypt = nil\n-\t}\n-\n-\t// If there is a leftover plain text buffer, read from it.\n-\tif x.plain != nil {\n-\t\tn = x.readPlain(p)\n-\t\treturn\n-\t}\n-\n-\t// Read and decrypt directly in caller's buffer.\n-\tn, err = io.ReadAtLeast(x.r, p, x.blockSize)\n-\tif err == os.EOF && n > 0 {\n-\t\t// EOF is only okay on block boundary\n-\t\terr = os.ErrorString(\"block fragment at EOF during decryption\")\n-\t\treturn\n-\t}\n-\tvar i int\n-\tfor i = 0; i+x.blockSize <= n; i += x.blockSize {\n-\t\ta := p[i : i+x.blockSize]\n-\t\tx.c.Decrypt(a, a)\n-\t}\n-\n-\t// There might be an encrypted fringe remaining.\n-\t// Save it for next time.\n-\tif i < n {\n-\t\tp = p[i:n]\n-\t\tcopy(x.buf, p)\n-\t\tx.crypt = x.buf[0:len(p)]\n-\t\tn = i\n-\t}\n-\n-\treturn\n-}\n-\n-// NewECBDecrypter returns a reader that reads data from r and decrypts it using c.\n-// It decrypts by calling c.Decrypt on each block in sequence;\n-// this mode is known as electronic codebook mode, or ECB.\n-// The returned Reader does not buffer or read ahead except\n-// as required by the cipher's block size.\n-func NewECBDecrypter(c Cipher, r io.Reader) io.Reader {\n-\tx := new(ecbDecrypter)\n-\tx.c = c\n-\tx.r = r\n-\tx.blockSize = c.BlockSize()\n-\tx.buf = make([]byte, x.blockSize)\n-\treturn x\n-}\n-\n-type ecbEncrypter struct {\n-\tc         Cipher\n-\tw         io.Writer\n-\tblockSize int\n-\n-\t// Buffered data.\n-\t// The buffer buf is used as storage for both\n-\t// plain or crypt.  If both are non-nil, plain\n-\t// follows crypt in buf.\n-\tbuf   []byte\n-\tplain []byte // plain text waiting to be encrypted\n-\tcrypt []byte // encrypted text waiting to be written\n-}\n-\n-// Flush the x.crypt buffer to x.w.\n-func (x *ecbEncrypter) flushCrypt() os.Error {\n-\tif len(x.crypt) == 0 {\n-\t\treturn nil\n-\t}\n-\tn, err := x.w.Write(x.crypt)\n-\tif n < len(x.crypt) {\n-\t\tx.crypt = x.crypt[n:]\n-\t\tif err == nil {\n-\t\t\terr = io.ErrShortWrite\n-\t\t}\n-\t}\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tx.crypt = nil\n-\treturn nil\n-}\n-\n-// Slide x.plain down to the beginning of x.buf.\n-// Plain is known to have less than one block of data,\n-// so this is cheap enough.\n-func (x *ecbEncrypter) slidePlain() {\n-\tif len(x.plain) == 0 {\n-\t\tx.plain = x.buf[0:0]\n-\t} else if cap(x.plain) < cap(x.buf) {\n-\t\tcopy(x.buf, x.plain)\n-\t\tx.plain = x.buf[0:len(x.plain)]\n-\t}\n-}\n-\n-// Fill x.plain from the data in p.\n-// Return the number of bytes copied.\n-func (x *ecbEncrypter) fillPlain(p []byte) int {\n-\toff := len(x.plain)\n-\tn := len(p)\n-\tif max := cap(x.plain) - off; n > max {\n-\t\tn = max\n-\t}\n-\tx.plain = x.plain[0 : off+n]\n-\tfor i := 0; i < n; i++ {\n-\t\tx.plain[off+i] = p[i]\n-\t}\n-\treturn n\n-}\n-\n-// Encrypt x.plain; record encrypted range as x.crypt.\n-func (x *ecbEncrypter) encrypt() {\n-\tvar i int\n-\tn := len(x.plain)\n-\tfor i = 0; i+x.blockSize <= n; i += x.blockSize {\n-\t\ta := x.plain[i : i+x.blockSize]\n-\t\tx.c.Encrypt(a, a)\n-\t}\n-\tx.crypt = x.plain[0:i]\n-\tx.plain = x.plain[i:n]\n-}\n-\n-func (x *ecbEncrypter) Write(p []byte) (n int, err os.Error) {\n-\tfor {\n-\t\t// If there is data waiting to be written, write it.\n-\t\t// This can happen on the first iteration\n-\t\t// if a write failed in an earlier call.\n-\t\tif err = x.flushCrypt(); err != nil {\n-\t\t\treturn\n-\t\t}\n-\n-\t\t// Now that encrypted data is gone (flush ran),\n-\t\t// perhaps we need to slide the plaintext down.\n-\t\tx.slidePlain()\n-\n-\t\t// Fill plaintext buffer from p.\n-\t\tm := x.fillPlain(p)\n-\t\tif m == 0 {\n-\t\t\tbreak\n-\t\t}\n-\t\tn += m\n-\t\tp = p[m:]\n-\n-\t\t// Encrypt, adjusting crypt and plain.\n-\t\tx.encrypt()\n-\n-\t\t// Write x.crypt.\n-\t\tif err = x.flushCrypt(); err != nil {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-// NewECBEncrypter returns a writer that encrypts data using c and writes it to w.\n-// It encrypts by calling c.Encrypt on each block in sequence;\n-// this mode is known as electronic codebook mode, or ECB.\n-// The returned Writer does no buffering except as required\n-// by the cipher's block size, so there is no need for a Flush method.\n-func NewECBEncrypter(c Cipher, w io.Writer) io.Writer {\n-\tx := new(ecbEncrypter)\n-\tx.c = c\n-\tx.w = w\n-\tx.blockSize = c.BlockSize()\n-\n-\t// Create a buffer that is an integral number of blocks.\n-\tx.buf = make([]byte, 8192/x.blockSize*x.blockSize)\n-\treturn x\n-}"}, {"sha": "14481d09693bc6651e8d6d07d62e787916cb483f", "filename": "libgo/go/crypto/block/ecb_aes_test.go", "status": "removed", "additions": 0, "deletions": 127, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fecb_aes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fecb_aes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fecb_aes_test.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,127 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// ECB AES test vectors.\n-\n-// See U.S. National Institute of Standards and Technology (NIST)\n-// Special Publication 800-38A, ``Recommendation for Block Cipher\n-// Modes of Operation,'' 2001 Edition, pp. 24-27.\n-\n-package block\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/aes\"\n-\t\"io\"\n-\t\"testing\"\n-)\n-\n-type ecbTest struct {\n-\tname string\n-\tkey  []byte\n-\tin   []byte\n-\tout  []byte\n-}\n-\n-var commonInput = []byte{\n-\t0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96, 0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,\n-\t0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c, 0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51,\n-\t0x30, 0xc8, 0x1c, 0x46, 0xa3, 0x5c, 0xe4, 0x11, 0xe5, 0xfb, 0xc1, 0x19, 0x1a, 0x0a, 0x52, 0xef,\n-\t0xf6, 0x9f, 0x24, 0x45, 0xdf, 0x4f, 0x9b, 0x17, 0xad, 0x2b, 0x41, 0x7b, 0xe6, 0x6c, 0x37, 0x10,\n-}\n-\n-var commonKey128 = []byte{0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6, 0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c}\n-\n-var commonKey192 = []byte{\n-\t0x8e, 0x73, 0xb0, 0xf7, 0xda, 0x0e, 0x64, 0x52, 0xc8, 0x10, 0xf3, 0x2b, 0x80, 0x90, 0x79, 0xe5,\n-\t0x62, 0xf8, 0xea, 0xd2, 0x52, 0x2c, 0x6b, 0x7b,\n-}\n-\n-var commonKey256 = []byte{\n-\t0x60, 0x3d, 0xeb, 0x10, 0x15, 0xca, 0x71, 0xbe, 0x2b, 0x73, 0xae, 0xf0, 0x85, 0x7d, 0x77, 0x81,\n-\t0x1f, 0x35, 0x2c, 0x07, 0x3b, 0x61, 0x08, 0xd7, 0x2d, 0x98, 0x10, 0xa3, 0x09, 0x14, 0xdf, 0xf4,\n-}\n-\n-var commonIV = []byte{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f}\n-\n-var ecbAESTests = []ecbTest{\n-\t// FIPS 197, Appendix B, C\n-\t{\n-\t\t\"FIPS-197 Appendix B\",\n-\t\tcommonKey128,\n-\t\t[]byte{0x32, 0x43, 0xf6, 0xa8, 0x88, 0x5a, 0x30, 0x8d, 0x31, 0x31, 0x98, 0xa2, 0xe0, 0x37, 0x07, 0x34},\n-\t\t[]byte{0x39, 0x25, 0x84, 0x1d, 0x02, 0xdc, 0x09, 0xfb, 0xdc, 0x11, 0x85, 0x97, 0x19, 0x6a, 0x0b, 0x32},\n-\t},\n-\n-\t// NIST SP 800-38A pp 24-27\n-\t{\n-\t\t\"ECB-AES128\",\n-\t\tcommonKey128,\n-\t\tcommonInput,\n-\t\t[]byte{\n-\t\t\t0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60, 0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,\n-\t\t\t0xf5, 0xd3, 0xd5, 0x85, 0x03, 0xb9, 0x69, 0x9d, 0xe7, 0x85, 0x89, 0x5a, 0x96, 0xfd, 0xba, 0xaf,\n-\t\t\t0x43, 0xb1, 0xcd, 0x7f, 0x59, 0x8e, 0xce, 0x23, 0x88, 0x1b, 0x00, 0xe3, 0xed, 0x03, 0x06, 0x88,\n-\t\t\t0x7b, 0x0c, 0x78, 0x5e, 0x27, 0xe8, 0xad, 0x3f, 0x82, 0x23, 0x20, 0x71, 0x04, 0x72, 0x5d, 0xd4,\n-\t\t},\n-\t},\n-\t{\n-\t\t\"ECB-AES192\",\n-\t\tcommonKey192,\n-\t\tcommonInput,\n-\t\t[]byte{\n-\t\t\t0xbd, 0x33, 0x4f, 0x1d, 0x6e, 0x45, 0xf2, 0x5f, 0xf7, 0x12, 0xa2, 0x14, 0x57, 0x1f, 0xa5, 0xcc,\n-\t\t\t0x97, 0x41, 0x04, 0x84, 0x6d, 0x0a, 0xd3, 0xad, 0x77, 0x34, 0xec, 0xb3, 0xec, 0xee, 0x4e, 0xef,\n-\t\t\t0xef, 0x7a, 0xfd, 0x22, 0x70, 0xe2, 0xe6, 0x0a, 0xdc, 0xe0, 0xba, 0x2f, 0xac, 0xe6, 0x44, 0x4e,\n-\t\t\t0x9a, 0x4b, 0x41, 0xba, 0x73, 0x8d, 0x6c, 0x72, 0xfb, 0x16, 0x69, 0x16, 0x03, 0xc1, 0x8e, 0x0e,\n-\t\t},\n-\t},\n-\t{\n-\t\t\"ECB-AES256\",\n-\t\tcommonKey256,\n-\t\tcommonInput,\n-\t\t[]byte{\n-\t\t\t0xf3, 0xee, 0xd1, 0xbd, 0xb5, 0xd2, 0xa0, 0x3c, 0x06, 0x4b, 0x5a, 0x7e, 0x3d, 0xb1, 0x81, 0xf8,\n-\t\t\t0x59, 0x1c, 0xcb, 0x10, 0xd4, 0x10, 0xed, 0x26, 0xdc, 0x5b, 0xa7, 0x4a, 0x31, 0x36, 0x28, 0x70,\n-\t\t\t0xb6, 0xed, 0x21, 0xb9, 0x9c, 0xa6, 0xf4, 0xf9, 0xf1, 0x53, 0xe7, 0xb1, 0xbe, 0xaf, 0xed, 0x1d,\n-\t\t\t0x23, 0x30, 0x4b, 0x7a, 0x39, 0xf9, 0xf3, 0xff, 0x06, 0x7d, 0x8d, 0x8f, 0x9e, 0x24, 0xec, 0xc7,\n-\t\t},\n-\t},\n-}\n-\n-func TestECB_AES(t *testing.T) {\n-\tfor _, tt := range ecbAESTests {\n-\t\ttest := tt.name\n-\n-\t\tc, err := aes.NewCipher(tt.key)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%s: NewCipher(%d bytes) = %s\", test, len(tt.key), err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tvar crypt bytes.Buffer\n-\t\tw := NewECBEncrypter(c, &crypt)\n-\t\tvar r io.Reader = bytes.NewBuffer(tt.in)\n-\t\tn, err := io.Copy(w, r)\n-\t\tif n != int64(len(tt.in)) || err != nil {\n-\t\t\tt.Errorf(\"%s: ECBReader io.Copy = %d, %v want %d, nil\", test, n, err, len(tt.in))\n-\t\t} else if d := crypt.Bytes(); !same(tt.out, d) {\n-\t\t\tt.Errorf(\"%s: ECBReader\\nhave %x\\nwant %x\", test, d, tt.out)\n-\t\t}\n-\n-\t\tvar plain bytes.Buffer\n-\t\tr = NewECBDecrypter(c, bytes.NewBuffer(tt.out))\n-\t\tw = &plain\n-\t\tn, err = io.Copy(w, r)\n-\t\tif n != int64(len(tt.out)) || err != nil {\n-\t\t\tt.Errorf(\"%s: ECBWriter io.Copy = %d, %v want %d, nil\", test, n, err, len(tt.out))\n-\t\t} else if d := plain.Bytes(); !same(tt.in, d) {\n-\t\t\tt.Errorf(\"%s: ECBWriter\\nhave %x\\nwant %x\", test, d, tt.in)\n-\t\t}\n-\n-\t\tif t.Failed() {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-}"}, {"sha": "6f79d929a6e56511e73b0c5a1daffce84a6972ff", "filename": "libgo/go/crypto/block/ecb_test.go", "status": "removed", "additions": 0, "deletions": 181, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fecb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fecb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fecb_test.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,181 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package block\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"testing\"\n-\t\"testing/iotest\"\n-)\n-\n-// Simple Cipher for testing: adds an incrementing amount\n-// to each byte in each\n-type IncCipher struct {\n-\tblockSize  int\n-\tdelta      byte\n-\tencrypting bool\n-}\n-\n-func (c *IncCipher) BlockSize() int { return c.blockSize }\n-\n-func (c *IncCipher) Encrypt(dst, src []byte) {\n-\tif !c.encrypting {\n-\t\tpanic(\"encrypt: not encrypting\")\n-\t}\n-\tif len(src) != c.blockSize || len(dst) != c.blockSize {\n-\t\tpanic(fmt.Sprintln(\"encrypt: wrong block size\", c.blockSize, len(src), len(dst)))\n-\t}\n-\tc.delta++\n-\tfor i, b := range src {\n-\t\tdst[i] = b + c.delta\n-\t}\n-}\n-\n-func (c *IncCipher) Decrypt(dst, src []byte) {\n-\tif c.encrypting {\n-\t\tpanic(\"decrypt: not decrypting\")\n-\t}\n-\tif len(src) != c.blockSize || len(dst) != c.blockSize {\n-\t\tpanic(fmt.Sprintln(\"decrypt: wrong block size \", c.blockSize, \" \", len(src), \" \", len(dst)))\n-\t}\n-\tc.delta--\n-\tfor i, b := range src {\n-\t\tdst[i] = b + c.delta\n-\t}\n-}\n-\n-func TestECBEncrypter(t *testing.T) {\n-\tvar plain, crypt [256]byte\n-\tfor i := 0; i < len(plain); i++ {\n-\t\tplain[i] = byte(i)\n-\t}\n-\tb := new(bytes.Buffer)\n-\tfor block := 1; block <= 64; block *= 2 {\n-\t\t// compute encrypted version\n-\t\tdelta := byte(0)\n-\t\tfor i := 0; i < len(crypt); i++ {\n-\t\t\tif i%block == 0 {\n-\t\t\t\tdelta++\n-\t\t\t}\n-\t\t\tcrypt[i] = plain[i] + delta\n-\t\t}\n-\n-\t\tfor frag := 0; frag < 2; frag++ {\n-\t\t\tc := &IncCipher{block, 0, true}\n-\t\t\tb.Reset()\n-\t\t\tr := bytes.NewBuffer(plain[0:])\n-\t\t\tw := NewECBEncrypter(c, b)\n-\n-\t\t\t// copy plain into w in increasingly large chunks: 1, 1, 2, 4, 8, ...\n-\t\t\t// if frag != 0, move the 1 to the end to cause fragmentation.\n-\t\t\tif frag == 0 {\n-\t\t\t\t_, err := io.Copyn(w, r, 1)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Errorf(\"block=%d frag=0: first Copyn: %s\", block, err)\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tfor n := 1; n <= len(plain)/2; n *= 2 {\n-\t\t\t\t_, err := io.Copyn(w, r, int64(n))\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Errorf(\"block=%d frag=%d: Copyn %d: %s\", block, frag, n, err)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tif frag != 0 {\n-\t\t\t\t_, err := io.Copyn(w, r, 1)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Errorf(\"block=%d frag=1: last Copyn: %s\", block, err)\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// check output\n-\t\t\tdata := b.Bytes()\n-\t\t\tif len(data) != len(crypt) {\n-\t\t\t\tt.Errorf(\"block=%d frag=%d: want %d bytes, got %d\", block, frag, len(crypt), len(data))\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\tif string(data) != string(crypt[0:]) {\n-\t\t\t\tt.Errorf(\"block=%d frag=%d: want %x got %x\", block, frag, data, crypt)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func testECBDecrypter(t *testing.T, maxio int) {\n-\tvar readers = []func(io.Reader) io.Reader{\n-\t\tfunc(r io.Reader) io.Reader { return r },\n-\t\tiotest.OneByteReader,\n-\t\tiotest.HalfReader,\n-\t}\n-\tvar plain, crypt [256]byte\n-\tfor i := 0; i < len(plain); i++ {\n-\t\tplain[i] = byte(255 - i)\n-\t}\n-\tb := new(bytes.Buffer)\n-\tfor block := 1; block <= 64 && block <= maxio; block *= 2 {\n-\t\t// compute encrypted version\n-\t\tdelta := byte(0)\n-\t\tfor i := 0; i < len(crypt); i++ {\n-\t\t\tif i%block == 0 {\n-\t\t\t\tdelta++\n-\t\t\t}\n-\t\t\tcrypt[i] = plain[i] + delta\n-\t\t}\n-\n-\t\tfor mode := 0; mode < len(readers); mode++ {\n-\t\t\tfor frag := 0; frag < 2; frag++ {\n-\t\t\t\ttest := fmt.Sprintf(\"block=%d mode=%d frag=%d maxio=%d\", block, mode, frag, maxio)\n-\t\t\t\tc := &IncCipher{block, 0, false}\n-\t\t\t\tb.Reset()\n-\t\t\t\tr := NewECBDecrypter(c, readers[mode](bytes.NewBuffer(crypt[0:maxio])))\n-\n-\t\t\t\t// read from crypt in increasingly large chunks: 1, 1, 2, 4, 8, ...\n-\t\t\t\t// if frag == 1, move the 1 to the end to cause fragmentation.\n-\t\t\t\tif frag == 0 {\n-\t\t\t\t\t_, err := io.Copyn(b, r, 1)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tt.Errorf(\"%s: first Copyn: %s\", test, err)\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tfor n := 1; n <= maxio/2; n *= 2 {\n-\t\t\t\t\t_, err := io.Copyn(b, r, int64(n))\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tt.Errorf(\"%s: Copyn %d: %s\", test, n, err)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif frag != 0 {\n-\t\t\t\t\t_, err := io.Copyn(b, r, 1)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tt.Errorf(\"%s: last Copyn: %s\", test, err)\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// check output\n-\t\t\t\tdata := b.Bytes()\n-\t\t\t\tif len(data) != maxio {\n-\t\t\t\t\tt.Errorf(\"%s: want %d bytes, got %d\", test, maxio, len(data))\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\n-\t\t\t\tif string(data) != string(plain[0:maxio]) {\n-\t\t\t\t\tt.Errorf(\"%s: input=%x want %x got %x\", test, crypt[0:maxio], plain[0:maxio], data)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func TestECBDecrypter(t *testing.T) {\n-\t// Do shorter I/O sizes first; they're easier to debug.\n-\tfor n := 1; n <= 256 && !t.Failed(); n *= 2 {\n-\t\ttestECBDecrypter(t, n)\n-\t}\n-}"}, {"sha": "11aaaa4d71947274496c85830ec43c38d8135dad", "filename": "libgo/go/crypto/block/ofb.go", "status": "removed", "additions": 0, "deletions": 60, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fofb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fofb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fofb.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,60 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Output feedback (OFB) mode.\n-\n-// OFB converts a block cipher into a stream cipher by\n-// repeatedly encrypting an initialization vector and\n-// xoring the resulting stream of data with the input.\n-\n-// See NIST SP 800-38A, pp 13-15\n-\n-package block\n-\n-import (\n-\t\"fmt\"\n-\t\"io\"\n-)\n-\n-type ofbStream struct {\n-\tc  Cipher\n-\tiv []byte\n-}\n-\n-func newOFBStream(c Cipher, iv []byte) *ofbStream {\n-\tx := new(ofbStream)\n-\tx.c = c\n-\tn := len(iv)\n-\tif n != c.BlockSize() {\n-\t\tpanic(fmt.Sprintln(\"crypto/block: newOFBStream: invalid iv size\", n, \"!=\", c.BlockSize()))\n-\t}\n-\tx.iv = dup(iv)\n-\treturn x\n-}\n-\n-func (x *ofbStream) Next() []byte {\n-\tx.c.Encrypt(x.iv, x.iv)\n-\treturn x.iv\n-}\n-\n-// NewOFBReader returns a reader that reads data from r, decrypts (or encrypts)\n-// it using c in output feedback (OFB) mode with the initialization vector iv.\n-// The returned Reader does not buffer and has no block size.\n-// In OFB mode, encryption and decryption are the same operation:\n-// an OFB reader applied to an encrypted stream produces a decrypted\n-// stream and vice versa.\n-func NewOFBReader(c Cipher, iv []byte, r io.Reader) io.Reader {\n-\treturn newXorReader(newOFBStream(c, iv), r)\n-}\n-\n-// NewOFBWriter returns a writer that encrypts (or decrypts) data using c\n-// in cipher feedback (OFB) mode with the initialization vector iv\n-// and writes the encrypted data to w.\n-// The returned Writer does not buffer and has no block size.\n-// In OFB mode, encryption and decryption are the same operation:\n-// an OFB writer applied to an decrypted stream produces an encrypted\n-// stream and vice versa.\n-func NewOFBWriter(c Cipher, iv []byte, w io.Writer) io.Writer {\n-\treturn newXorWriter(newOFBStream(c, iv), w)\n-}"}, {"sha": "9c527a6b3785a4001696d3ebcfec6528335ead71", "filename": "libgo/go/crypto/block/ofb_aes_test.go", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fofb_aes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fofb_aes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fofb_aes_test.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,108 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// OFB AES test vectors.\n-\n-// See U.S. National Institute of Standards and Technology (NIST)\n-// Special Publication 800-38A, ``Recommendation for Block Cipher\n-// Modes of Operation,'' 2001 Edition, pp. 52-55.\n-\n-package block\n-\n-import (\n-\t\"bytes\"\n-\t\"crypto/aes\"\n-\t\"io\"\n-\t\"testing\"\n-)\n-\n-type ofbTest struct {\n-\tname string\n-\tkey  []byte\n-\tiv   []byte\n-\tin   []byte\n-\tout  []byte\n-}\n-\n-var ofbAESTests = []ofbTest{\n-\t// NIST SP 800-38A pp 52-55\n-\t{\n-\t\t\"OFB-AES128\",\n-\t\tcommonKey128,\n-\t\tcommonIV,\n-\t\tcommonInput,\n-\t\t[]byte{\n-\t\t\t0x3b, 0x3f, 0xd9, 0x2e, 0xb7, 0x2d, 0xad, 0x20, 0x33, 0x34, 0x49, 0xf8, 0xe8, 0x3c, 0xfb, 0x4a,\n-\t\t\t0x77, 0x89, 0x50, 0x8d, 0x16, 0x91, 0x8f, 0x03, 0xf5, 0x3c, 0x52, 0xda, 0xc5, 0x4e, 0xd8, 0x25,\n-\t\t\t0x97, 0x40, 0x05, 0x1e, 0x9c, 0x5f, 0xec, 0xf6, 0x43, 0x44, 0xf7, 0xa8, 0x22, 0x60, 0xed, 0xcc,\n-\t\t\t0x30, 0x4c, 0x65, 0x28, 0xf6, 0x59, 0xc7, 0x78, 0x66, 0xa5, 0x10, 0xd9, 0xc1, 0xd6, 0xae, 0x5e,\n-\t\t},\n-\t},\n-\t{\n-\t\t\"OFB-AES192\",\n-\t\tcommonKey192,\n-\t\tcommonIV,\n-\t\tcommonInput,\n-\t\t[]byte{\n-\t\t\t0xcd, 0xc8, 0x0d, 0x6f, 0xdd, 0xf1, 0x8c, 0xab, 0x34, 0xc2, 0x59, 0x09, 0xc9, 0x9a, 0x41, 0x74,\n-\t\t\t0xfc, 0xc2, 0x8b, 0x8d, 0x4c, 0x63, 0x83, 0x7c, 0x09, 0xe8, 0x17, 0x00, 0xc1, 0x10, 0x04, 0x01,\n-\t\t\t0x8d, 0x9a, 0x9a, 0xea, 0xc0, 0xf6, 0x59, 0x6f, 0x55, 0x9c, 0x6d, 0x4d, 0xaf, 0x59, 0xa5, 0xf2,\n-\t\t\t0x6d, 0x9f, 0x20, 0x08, 0x57, 0xca, 0x6c, 0x3e, 0x9c, 0xac, 0x52, 0x4b, 0xd9, 0xac, 0xc9, 0x2a,\n-\t\t},\n-\t},\n-\t{\n-\t\t\"OFB-AES256\",\n-\t\tcommonKey256,\n-\t\tcommonIV,\n-\t\tcommonInput,\n-\t\t[]byte{\n-\t\t\t0xdc, 0x7e, 0x84, 0xbf, 0xda, 0x79, 0x16, 0x4b, 0x7e, 0xcd, 0x84, 0x86, 0x98, 0x5d, 0x38, 0x60,\n-\t\t\t0x4f, 0xeb, 0xdc, 0x67, 0x40, 0xd2, 0x0b, 0x3a, 0xc8, 0x8f, 0x6a, 0xd8, 0x2a, 0x4f, 0xb0, 0x8d,\n-\t\t\t0x71, 0xab, 0x47, 0xa0, 0x86, 0xe8, 0x6e, 0xed, 0xf3, 0x9d, 0x1c, 0x5b, 0xba, 0x97, 0xc4, 0x08,\n-\t\t\t0x01, 0x26, 0x14, 0x1d, 0x67, 0xf3, 0x7b, 0xe8, 0x53, 0x8f, 0x5a, 0x8b, 0xe7, 0x40, 0xe4, 0x84,\n-\t\t},\n-\t},\n-}\n-\n-func TestOFB_AES(t *testing.T) {\n-\tfor _, tt := range ofbAESTests {\n-\t\ttest := tt.name\n-\n-\t\tc, err := aes.NewCipher(tt.key)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"%s: NewCipher(%d bytes) = %s\", test, len(tt.key), err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tfor j := 0; j <= 5; j += 5 {\n-\t\t\tvar crypt bytes.Buffer\n-\t\t\tin := tt.in[0 : len(tt.in)-j]\n-\t\t\tw := NewOFBWriter(c, tt.iv, &crypt)\n-\t\t\tvar r io.Reader = bytes.NewBuffer(in)\n-\t\t\tn, err := io.Copy(w, r)\n-\t\t\tif n != int64(len(in)) || err != nil {\n-\t\t\t\tt.Errorf(\"%s/%d: OFBWriter io.Copy = %d, %v want %d, nil\", test, len(in), n, err, len(in))\n-\t\t\t} else if d, out := crypt.Bytes(), tt.out[0:len(in)]; !same(out, d) {\n-\t\t\t\tt.Errorf(\"%s/%d: OFBWriter\\ninpt %x\\nhave %x\\nwant %x\", test, len(in), in, d, out)\n-\t\t\t}\n-\t\t}\n-\n-\t\tfor j := 0; j <= 7; j += 7 {\n-\t\t\tvar plain bytes.Buffer\n-\t\t\tout := tt.out[0 : len(tt.out)-j]\n-\t\t\tr := NewOFBReader(c, tt.iv, bytes.NewBuffer(out))\n-\t\t\tw := &plain\n-\t\t\tn, err := io.Copy(w, r)\n-\t\t\tif n != int64(len(out)) || err != nil {\n-\t\t\t\tt.Errorf(\"%s/%d: OFBReader io.Copy = %d, %v want %d, nil\", test, len(out), n, err, len(out))\n-\t\t\t} else if d, in := plain.Bytes(), tt.in[0:len(out)]; !same(in, d) {\n-\t\t\t\tt.Errorf(\"%s/%d: OFBReader\\nhave %x\\nwant %x\", test, len(out), d, in)\n-\t\t\t}\n-\t\t}\n-\n-\t\tif t.Failed() {\n-\t\t\tbreak\n-\t\t}\n-\t}\n-}"}, {"sha": "9d8b1722400ded5d2980153a848298585cd1d48d", "filename": "libgo/go/crypto/block/xor.go", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fxor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fxor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fxor.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,124 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// Encrypt/decrypt data by xor with a pseudo-random data stream.\n-\n-package block\n-\n-import (\n-\t\"io\"\n-\t\"os\"\n-)\n-\n-// A dataStream is an interface to an unending stream of data,\n-// used by XorReader and XorWriter to model a pseudo-random generator.\n-// Calls to Next() return sequential blocks of data from the stream.\n-// Each call must return at least one byte: there is no EOF.\n-type dataStream interface {\n-\tNext() []byte\n-}\n-\n-type xorReader struct {\n-\tr    io.Reader\n-\trand dataStream // pseudo-random\n-\tbuf  []byte     // data available from last call to rand\n-}\n-\n-func newXorReader(rand dataStream, r io.Reader) io.Reader {\n-\tx := new(xorReader)\n-\tx.r = r\n-\tx.rand = rand\n-\treturn x\n-}\n-\n-func (x *xorReader) Read(p []byte) (n int, err os.Error) {\n-\tn, err = x.r.Read(p)\n-\n-\t// xor input with stream.\n-\tbp := 0\n-\tbuf := x.buf\n-\tfor i := 0; i < n; i++ {\n-\t\tif bp >= len(buf) {\n-\t\t\tbuf = x.rand.Next()\n-\t\t\tbp = 0\n-\t\t}\n-\t\tp[i] ^= buf[bp]\n-\t\tbp++\n-\t}\n-\tx.buf = buf[bp:]\n-\treturn n, err\n-}\n-\n-type xorWriter struct {\n-\tw     io.Writer\n-\trand  dataStream // pseudo-random\n-\tbuf   []byte     // last buffer returned by rand\n-\textra []byte     // extra random data (use before buf)\n-\twork  []byte     // work space\n-}\n-\n-func newXorWriter(rand dataStream, w io.Writer) io.Writer {\n-\tx := new(xorWriter)\n-\tx.w = w\n-\tx.rand = rand\n-\tx.work = make([]byte, 4096)\n-\treturn x\n-}\n-\n-func (x *xorWriter) Write(p []byte) (n int, err os.Error) {\n-\tfor len(p) > 0 {\n-\t\t// Determine next chunk of random data\n-\t\t// and xor with p into x.work.\n-\t\tvar chunk []byte\n-\t\tm := len(p)\n-\t\tif nn := len(x.extra); nn > 0 {\n-\t\t\t// extra points into work, so edit directly\n-\t\t\tif m > nn {\n-\t\t\t\tm = nn\n-\t\t\t}\n-\t\t\tfor i := 0; i < m; i++ {\n-\t\t\t\tx.extra[i] ^= p[i]\n-\t\t\t}\n-\t\t\tchunk = x.extra[0:m]\n-\t\t} else {\n-\t\t\t// xor p ^ buf into work, refreshing buf as needed\n-\t\t\tif nn := len(x.work); m > nn {\n-\t\t\t\tm = nn\n-\t\t\t}\n-\t\t\tbp := 0\n-\t\t\tbuf := x.buf\n-\t\t\tfor i := 0; i < m; i++ {\n-\t\t\t\tif bp >= len(buf) {\n-\t\t\t\t\tbuf = x.rand.Next()\n-\t\t\t\t\tbp = 0\n-\t\t\t\t}\n-\t\t\t\tx.work[i] = buf[bp] ^ p[i]\n-\t\t\t\tbp++\n-\t\t\t}\n-\t\t\tx.buf = buf[bp:]\n-\t\t\tchunk = x.work[0:m]\n-\t\t}\n-\n-\t\t// Write chunk.\n-\t\tvar nn int\n-\t\tnn, err = x.w.Write(chunk)\n-\t\tif nn != len(chunk) && err == nil {\n-\t\t\terr = io.ErrShortWrite\n-\t\t}\n-\t\tif nn < len(chunk) {\n-\t\t\t// Reconstruct the random bits from the unwritten\n-\t\t\t// data and save them for next time.\n-\t\t\tfor i := nn; i < m; i++ {\n-\t\t\t\tchunk[i] ^= p[i]\n-\t\t\t}\n-\t\t\tx.extra = chunk[nn:]\n-\t\t}\n-\t\tn += nn\n-\t\tif err != nil {\n-\t\t\treturn\n-\t\t}\n-\t\tp = p[m:]\n-\t}\n-\treturn\n-}"}, {"sha": "50f6bb08df4d930f39d9df675be8534c77a3e770", "filename": "libgo/go/crypto/block/xor_test.go", "status": "removed", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fxor_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a751005d50fa7347131660e562c5fd9ce3dff75d/libgo%2Fgo%2Fcrypto%2Fblock%2Fxor_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fblock%2Fxor_test.go?ref=a751005d50fa7347131660e562c5fd9ce3dff75d", "patch": "@@ -1,168 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package block\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"testing\"\n-\t\"testing/iotest\"\n-)\n-\n-// Simple \"pseudo-random\" stream for testing.\n-type incStream struct {\n-\tbuf []byte\n-\tn   byte\n-}\n-\n-func newIncStream(blockSize int) *incStream {\n-\tx := new(incStream)\n-\tx.buf = make([]byte, blockSize)\n-\treturn x\n-}\n-\n-func (x *incStream) Next() []byte {\n-\tx.n++\n-\tfor i := range x.buf {\n-\t\tx.buf[i] = x.n\n-\t\tx.n++\n-\t}\n-\treturn x.buf\n-}\n-\n-func testXorWriter(t *testing.T, maxio int) {\n-\tvar plain, crypt [256]byte\n-\tfor i := 0; i < len(plain); i++ {\n-\t\tplain[i] = byte(i)\n-\t}\n-\tb := new(bytes.Buffer)\n-\tfor block := 1; block <= 64 && block <= maxio; block *= 2 {\n-\t\t// compute encrypted version\n-\t\tn := byte(0)\n-\t\tfor i := 0; i < len(crypt); i++ {\n-\t\t\tif i%block == 0 {\n-\t\t\t\tn++\n-\t\t\t}\n-\t\t\tcrypt[i] = plain[i] ^ n\n-\t\t\tn++\n-\t\t}\n-\n-\t\tfor frag := 0; frag < 2; frag++ {\n-\t\t\ttest := fmt.Sprintf(\"block=%d frag=%d maxio=%d\", block, frag, maxio)\n-\t\t\tb.Reset()\n-\t\t\tr := bytes.NewBuffer(plain[0:])\n-\t\t\ts := newIncStream(block)\n-\t\t\tw := newXorWriter(s, b)\n-\n-\t\t\t// copy plain into w in increasingly large chunks: 1, 1, 2, 4, 8, ...\n-\t\t\t// if frag != 0, move the 1 to the end to cause fragmentation.\n-\t\t\tif frag == 0 {\n-\t\t\t\t_, err := io.Copyn(w, r, 1)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Errorf(\"%s: first Copyn: %s\", test, err)\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tfor n := 1; n <= len(plain)/2; n *= 2 {\n-\t\t\t\t_, err := io.Copyn(w, r, int64(n))\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Errorf(\"%s: Copyn %d: %s\", test, n, err)\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\t// check output\n-\t\t\tcrypt := crypt[0 : len(crypt)-frag]\n-\t\t\tdata := b.Bytes()\n-\t\t\tif len(data) != len(crypt) {\n-\t\t\t\tt.Errorf(\"%s: want %d bytes, got %d\", test, len(crypt), len(data))\n-\t\t\t\tcontinue\n-\t\t\t}\n-\n-\t\t\tif string(data) != string(crypt) {\n-\t\t\t\tt.Errorf(\"%s: want %x got %x\", test, data, crypt)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-\n-func TestXorWriter(t *testing.T) {\n-\t// Do shorter I/O sizes first; they're easier to debug.\n-\tfor n := 1; n <= 256 && !t.Failed(); n *= 2 {\n-\t\ttestXorWriter(t, n)\n-\t}\n-}\n-\n-func testXorReader(t *testing.T, maxio int) {\n-\tvar readers = []func(io.Reader) io.Reader{\n-\t\tfunc(r io.Reader) io.Reader { return r },\n-\t\tiotest.OneByteReader,\n-\t\tiotest.HalfReader,\n-\t}\n-\tvar plain, crypt [256]byte\n-\tfor i := 0; i < len(plain); i++ {\n-\t\tplain[i] = byte(255 - i)\n-\t}\n-\tb := new(bytes.Buffer)\n-\tfor block := 1; block <= 64 && block <= maxio; block *= 2 {\n-\t\t// compute encrypted version\n-\t\tn := byte(0)\n-\t\tfor i := 0; i < len(crypt); i++ {\n-\t\t\tif i%block == 0 {\n-\t\t\t\tn++\n-\t\t\t}\n-\t\t\tcrypt[i] = plain[i] ^ n\n-\t\t\tn++\n-\t\t}\n-\n-\t\tfor mode := 0; mode < len(readers); mode++ {\n-\t\t\tfor frag := 0; frag < 2; frag++ {\n-\t\t\t\ttest := fmt.Sprintf(\"block=%d mode=%d frag=%d maxio=%d\", block, mode, frag, maxio)\n-\t\t\t\ts := newIncStream(block)\n-\t\t\t\tb.Reset()\n-\t\t\t\tr := newXorReader(s, readers[mode](bytes.NewBuffer(crypt[0:maxio])))\n-\n-\t\t\t\t// read from crypt in increasingly large chunks: 1, 1, 2, 4, 8, ...\n-\t\t\t\t// if frag == 1, move the 1 to the end to cause fragmentation.\n-\t\t\t\tif frag == 0 {\n-\t\t\t\t\t_, err := io.Copyn(b, r, 1)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tt.Errorf(\"%s: first Copyn: %s\", test, err)\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tfor n := 1; n <= maxio/2; n *= 2 {\n-\t\t\t\t\t_, err := io.Copyn(b, r, int64(n))\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\tt.Errorf(\"%s: Copyn %d: %s\", test, n, err)\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\t// check output\n-\t\t\t\tdata := b.Bytes()\n-\t\t\t\tcrypt := crypt[0 : maxio-frag]\n-\t\t\t\tplain := plain[0 : maxio-frag]\n-\t\t\t\tif len(data) != len(plain) {\n-\t\t\t\t\tt.Errorf(\"%s: want %d bytes, got %d\", test, len(plain), len(data))\n-\t\t\t\t\tcontinue\n-\t\t\t\t}\n-\n-\t\t\t\tif string(data) != string(plain) {\n-\t\t\t\t\tt.Errorf(\"%s: input=%x want %x got %x\", test, crypt, plain, data)\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func TestXorReader(t *testing.T) {\n-\t// Do shorter I/O sizes first; they're easier to debug.\n-\tfor n := 1; n <= 256 && !t.Failed(); n *= 2 {\n-\t\ttestXorReader(t, n)\n-\t}\n-}\n-\n-// TODO(rsc): Test handling of writes after write errors."}, {"sha": "e18eaedf58055ee7a5659cd41130d1e52c1cd321", "filename": "libgo/go/crypto/des/block.go", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fblock.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package des\n+\n+import (\n+\t\"encoding/binary\"\n+)\n+\n+func cryptBlock(subkeys []uint64, dst, src []byte, decrypt bool) {\n+\tb := binary.BigEndian.Uint64(src)\n+\tb = permuteBlock(b, initialPermutation[:])\n+\tleft, right := uint32(b>>32), uint32(b)\n+\n+\tvar subkey uint64\n+\tfor i := 0; i < 16; i++ {\n+\t\tif decrypt {\n+\t\t\tsubkey = subkeys[15-i]\n+\t\t} else {\n+\t\t\tsubkey = subkeys[i]\n+\t\t}\n+\n+\t\tleft, right = right, left^feistel(right, subkey)\n+\t}\n+\t// switch left & right and perform final permutation\n+\tpreOutput := (uint64(right) << 32) | uint64(left)\n+\tbinary.BigEndian.PutUint64(dst, permuteBlock(preOutput, finalPermutation[:]))\n+}\n+\n+// Encrypt one block from src into dst, using the subkeys.\n+func encryptBlock(subkeys []uint64, dst, src []byte) {\n+\tcryptBlock(subkeys, dst, src, false)\n+}\n+\n+// Decrypt one block from src into dst, using the subkeys.\n+func decryptBlock(subkeys []uint64, dst, src []byte) {\n+\tcryptBlock(subkeys, dst, src, true)\n+}\n+\n+// DES Feistel function\n+func feistel(right uint32, key uint64) (result uint32) {\n+\tsBoxLocations := key ^ permuteBlock(uint64(right), expansionFunction[:])\n+\tvar sBoxResult uint32\n+\tfor i := uint8(0); i < 8; i++ {\n+\t\tsBoxLocation := uint8(sBoxLocations>>42) & 0x3f\n+\t\tsBoxLocations <<= 6\n+\t\t// row determined by 1st and 6th bit\n+\t\trow := (sBoxLocation & 0x1) | ((sBoxLocation & 0x20) >> 4)\n+\t\t// column is middle four bits\n+\t\tcolumn := (sBoxLocation >> 1) & 0xf\n+\t\tsBoxResult |= uint32(sBoxes[i][row][column]) << (4 * (7 - i))\n+\t}\n+\treturn uint32(permuteBlock(uint64(sBoxResult), permutationFunction[:]))\n+}\n+\n+// general purpose function to perform DES block permutations\n+func permuteBlock(src uint64, permutation []uint8) (block uint64) {\n+\tfor position, n := range permutation {\n+\t\tbit := (src >> n) & 1\n+\t\tblock |= bit << uint((len(permutation)-1)-position)\n+\t}\n+\treturn\n+}\n+\n+// creates 16 28-bit blocks rotated according\n+// to the rotation schedule\n+func ksRotate(in uint32) (out []uint32) {\n+\tout = make([]uint32, 16)\n+\tlast := in\n+\tfor i := 0; i < 16; i++ {\n+\t\t// 28-bit circular left shift\n+\t\tleft := (last << (4 + ksRotations[i])) >> 4\n+\t\tright := (last << 4) >> (32 - ksRotations[i])\n+\t\tout[i] = left | right\n+\t\tlast = out[i]\n+\t}\n+\treturn\n+}\n+\n+// creates 16 56-bit subkeys from the original key\n+func (c *Cipher) generateSubkeys(keyBytes []byte) {\n+\t// apply PC1 permutation to key\n+\tkey := binary.BigEndian.Uint64(keyBytes)\n+\tpermutedKey := permuteBlock(key, permutedChoice1[:])\n+\n+\t// rotate halves of permuted key according to the rotation schedule\n+\tleftRotations := ksRotate(uint32(permutedKey >> 28))\n+\trightRotations := ksRotate(uint32(permutedKey<<4) >> 4)\n+\n+\t// generate subkeys\n+\tfor i := 0; i < 16; i++ {\n+\t\t// combine halves to form 56-bit input to PC2\n+\t\tpc2Input := uint64(leftRotations[i])<<28 | uint64(rightRotations[i])\n+\t\t// apply PC2 permutation to 7 byte input\n+\t\tc.subkeys[i] = permuteBlock(pc2Input, permutedChoice2[:])\n+\t}\n+}"}, {"sha": "d17a1a783a178074b834f4603351bd61561b8e79", "filename": "libgo/go/crypto/des/cipher.go", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fcipher.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package des\n+\n+import (\n+\t\"os\"\n+\t\"strconv\"\n+)\n+\n+// The DES block size in bytes.\n+const BlockSize = 8\n+\n+type KeySizeError int\n+\n+func (k KeySizeError) String() string {\n+\treturn \"crypto/des: invalid key size \" + strconv.Itoa(int(k))\n+}\n+\n+// Cipher is an instance of DES encryption.\n+type Cipher struct {\n+\tsubkeys [16]uint64\n+}\n+\n+// NewCipher creates and returns a new Cipher.\n+func NewCipher(key []byte) (*Cipher, os.Error) {\n+\tif len(key) != 8 {\n+\t\treturn nil, KeySizeError(len(key))\n+\t}\n+\n+\tc := new(Cipher)\n+\tc.generateSubkeys(key)\n+\treturn c, nil\n+}\n+\n+// BlockSize returns the DES block size, 8 bytes.\n+func (c *Cipher) BlockSize() int { return BlockSize }\n+\n+// Encrypts the 8-byte buffer src and stores the result in dst.\n+// Note that for amounts of data larger than a block,\n+// it is not safe to just call Encrypt on successive blocks;\n+// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n+func (c *Cipher) Encrypt(dst, src []byte) { encryptBlock(c.subkeys[:], dst, src) }\n+\n+// Decrypts the 8-byte buffer src and stores the result in dst.\n+func (c *Cipher) Decrypt(dst, src []byte) { decryptBlock(c.subkeys[:], dst, src) }\n+\n+// Reset zeros the key data, so that it will no longer\n+// appear in the process's memory.\n+func (c *Cipher) Reset() {\n+\tfor i := 0; i < len(c.subkeys); i++ {\n+\t\tc.subkeys[i] = 0\n+\t}\n+}\n+\n+// A TripleDESCipher is an instance of TripleDES encryption.\n+type TripleDESCipher struct {\n+\tcipher1, cipher2, cipher3 Cipher\n+}\n+\n+// NewCipher creates and returns a new Cipher.\n+func NewTripleDESCipher(key []byte) (*TripleDESCipher, os.Error) {\n+\tif len(key) != 24 {\n+\t\treturn nil, KeySizeError(len(key))\n+\t}\n+\n+\tc := new(TripleDESCipher)\n+\tc.cipher1.generateSubkeys(key[:8])\n+\tc.cipher2.generateSubkeys(key[8:16])\n+\tc.cipher3.generateSubkeys(key[16:])\n+\treturn c, nil\n+}\n+\n+// BlockSize returns the TripleDES block size, 8 bytes.\n+// It is necessary to satisfy the Block interface in the\n+// package \"crypto/cipher\".\n+func (c *TripleDESCipher) BlockSize() int { return BlockSize }\n+\n+// Encrypts the 8-byte buffer src and stores the result in dst.\n+// Note that for amounts of data larger than a block,\n+// it is not safe to just call Encrypt on successive blocks;\n+// instead, use an encryption mode like CBC (see crypto/cipher/cbc.go).\n+func (c *TripleDESCipher) Encrypt(dst, src []byte) {\n+\tc.cipher1.Encrypt(dst, src)\n+\tc.cipher2.Decrypt(dst, dst)\n+\tc.cipher3.Encrypt(dst, dst)\n+}\n+\n+// Decrypts the 8-byte buffer src and stores the result in dst.\n+func (c *TripleDESCipher) Decrypt(dst, src []byte) {\n+\tc.cipher3.Decrypt(dst, src)\n+\tc.cipher2.Encrypt(dst, dst)\n+\tc.cipher1.Decrypt(dst, dst)\n+}\n+\n+// Reset zeros the key data, so that it will no longer\n+// appear in the process's memory.\n+func (c *TripleDESCipher) Reset() {\n+\tc.cipher1.Reset()\n+\tc.cipher2.Reset()\n+\tc.cipher3.Reset()\n+}"}, {"sha": "2bd485ee80e00022abd145944fc1eaa959d6469d", "filename": "libgo/go/crypto/des/const.go", "status": "added", "additions": 139, "deletions": 0, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fdes%2Fconst.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fdes%2Fconst.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fconst.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,139 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package des implements the Data Encryption Standard (DES) and the\n+// Triple Data Encryption Algorithm (TDEA) as defined\n+// in U.S. Federal Information Processing Standards Publication 46-3.\n+package des\n+\n+// Used to perform an initial permutation of a 64-bit input block.\n+var initialPermutation = [64]byte{\n+\t6, 14, 22, 30, 38, 46, 54, 62,\n+\t4, 12, 20, 28, 36, 44, 52, 60,\n+\t2, 10, 18, 26, 34, 42, 50, 58,\n+\t0, 8, 16, 24, 32, 40, 48, 56,\n+\t7, 15, 23, 31, 39, 47, 55, 63,\n+\t5, 13, 21, 29, 37, 45, 53, 61,\n+\t3, 11, 19, 27, 35, 43, 51, 59,\n+\t1, 9, 17, 25, 33, 41, 49, 57,\n+}\n+\n+// Used to perform a final permutation of a 4-bit preoutput block. This is the\n+// inverse of initialPermutation\n+var finalPermutation = [64]byte{\n+\t24, 56, 16, 48, 8, 40, 0, 32,\n+\t25, 57, 17, 49, 9, 41, 1, 33,\n+\t26, 58, 18, 50, 10, 42, 2, 34,\n+\t27, 59, 19, 51, 11, 43, 3, 35,\n+\t28, 60, 20, 52, 12, 44, 4, 36,\n+\t29, 61, 21, 53, 13, 45, 5, 37,\n+\t30, 62, 22, 54, 14, 46, 6, 38,\n+\t31, 63, 23, 55, 15, 47, 7, 39,\n+}\n+\n+// Used to expand an input block of 32 bits, producing an output block of 48\n+// bits.\n+var expansionFunction = [48]byte{\n+\t0, 31, 30, 29, 28, 27, 28, 27,\n+\t26, 25, 24, 23, 24, 23, 22, 21,\n+\t20, 19, 20, 19, 18, 17, 16, 15,\n+\t16, 15, 14, 13, 12, 11, 12, 11,\n+\t10, 9, 8, 7, 8, 7, 6, 5,\n+\t4, 3, 4, 3, 2, 1, 0, 31,\n+}\n+\n+// Yields a 32-bit output from a 32-bit input\n+var permutationFunction = [32]byte{\n+\t16, 25, 12, 11, 3, 20, 4, 15,\n+\t31, 17, 9, 6, 27, 14, 1, 22,\n+\t30, 24, 8, 18, 0, 5, 29, 23,\n+\t13, 19, 2, 26, 10, 21, 28, 7,\n+}\n+\n+// Used in the key schedule to select 56 bits\n+// from a 64-bit input.\n+var permutedChoice1 = [56]byte{\n+\t7, 15, 23, 31, 39, 47, 55, 63,\n+\t6, 14, 22, 30, 38, 46, 54, 62,\n+\t5, 13, 21, 29, 37, 45, 53, 61,\n+\t4, 12, 20, 28, 1, 9, 17, 25,\n+\t33, 41, 49, 57, 2, 10, 18, 26,\n+\t34, 42, 50, 58, 3, 11, 19, 27,\n+\t35, 43, 51, 59, 36, 44, 52, 60,\n+}\n+\n+// Used in the key schedule to produce each subkey by selecting 48 bits from\n+// the 56-bit input\n+var permutedChoice2 = [48]byte{\n+\t42, 39, 45, 32, 55, 51, 53, 28,\n+\t41, 50, 35, 46, 33, 37, 44, 52,\n+\t30, 48, 40, 49, 29, 36, 43, 54,\n+\t15, 4, 25, 19, 9, 1, 26, 16,\n+\t5, 11, 23, 8, 12, 7, 17, 0,\n+\t22, 3, 10, 14, 6, 20, 27, 24,\n+}\n+\n+// 8 S-boxes composed of 4 rows and 16 columns\n+// Used in the DES cipher function\n+var sBoxes = [8][4][16]uint8{\n+\t// S-box 1\n+\t{\n+\t\t{14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7},\n+\t\t{0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8},\n+\t\t{4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0},\n+\t\t{15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13},\n+\t},\n+\t// S-box 2\n+\t{\n+\t\t{15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10},\n+\t\t{3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5},\n+\t\t{0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15},\n+\t\t{13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9},\n+\t},\n+\t// S-box 3\n+\t{\n+\t\t{10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8},\n+\t\t{13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1},\n+\t\t{13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7},\n+\t\t{1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12},\n+\t},\n+\t// S-box 4\n+\t{\n+\t\t{7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15},\n+\t\t{13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9},\n+\t\t{10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4},\n+\t\t{3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14},\n+\t},\n+\t// S-box 5\n+\t{\n+\t\t{2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9},\n+\t\t{14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6},\n+\t\t{4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14},\n+\t\t{11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3},\n+\t},\n+\t// S-box 6\n+\t{\n+\t\t{12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11},\n+\t\t{10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8},\n+\t\t{9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6},\n+\t\t{4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13},\n+\t},\n+\t// S-box 7\n+\t{\n+\t\t{4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1},\n+\t\t{13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6},\n+\t\t{1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2},\n+\t\t{6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12},\n+\t},\n+\t// S-box 8\n+\t{\n+\t\t{13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7},\n+\t\t{1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2},\n+\t\t{7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8},\n+\t\t{2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11},\n+\t},\n+}\n+\n+// Size of left rotation per round in each half of the key schedule\n+var ksRotations = [16]uint8{1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1}"}, {"sha": "d1f3aa71ac4e061c4c20e27a6acec2298dc96297", "filename": "libgo/go/crypto/des/des_test.go", "status": "added", "additions": 1497, "deletions": 0, "changes": 1497, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fdes%2Fdes_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,1497 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package des\n+\n+import (\n+\t\"bytes\"\n+\t\"testing\"\n+)\n+\n+type CryptTest struct {\n+\tkey []byte\n+\tin  []byte\n+\tout []byte\n+}\n+\n+// some custom tests for DES\n+var encryptDESTests = []CryptTest{\n+\t{\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x8c, 0xa6, 0x4d, 0xe9, 0xc1, 0xb1, 0x23, 0xa7}},\n+\t{\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0x35, 0x55, 0x50, 0xb2, 0x15, 0x0e, 0x24, 0x51}},\n+\t{\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},\n+\t\t[]byte{0x61, 0x7b, 0x3a, 0x0c, 0xe8, 0xf0, 0x71, 0x00}},\n+\t{\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},\n+\t\t[]byte{0x92, 0x31, 0xf2, 0x36, 0xff, 0x9a, 0xa9, 0x5c}},\n+\t{\n+\t\t[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xca, 0xaa, 0xaf, 0x4d, 0xea, 0xf1, 0xdb, 0xae}},\n+\t{\n+\t\t[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0x73, 0x59, 0xb2, 0x16, 0x3e, 0x4e, 0xdc, 0x58}},\n+\t{\n+\t\t[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},\n+\t\t[]byte{0x6d, 0xce, 0x0d, 0xc9, 0x00, 0x65, 0x56, 0xa3}},\n+\t{\n+\t\t[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},\n+\t\t[]byte{0x9e, 0x84, 0xc5, 0xf3, 0x17, 0x0f, 0x8e, 0xff}},\n+\t{\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xd5, 0xd4, 0x4f, 0xf7, 0x20, 0x68, 0x3d, 0x0d}},\n+\t{\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},\n+\t\t[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0x59, 0x73, 0x23, 0x56, 0xf3, 0x6f, 0xde, 0x06}},\n+\t{\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},\n+\t\t[]byte{0x56, 0xcc, 0x09, 0xe7, 0xcf, 0xdc, 0x4c, 0xef}},\n+\t{\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},\n+\t\t[]byte{0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},\n+\t\t[]byte{0x12, 0xc6, 0x26, 0xaf, 0x05, 0x8b, 0x43, 0x3b}},\n+\t{\n+\t\t[]byte{0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xa6, 0x8c, 0xdc, 0xa9, 0x0c, 0x90, 0x21, 0xf9}},\n+\t{\n+\t\t[]byte{0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},\n+\t\t[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0x2a, 0x2b, 0xb0, 0x08, 0xdf, 0x97, 0xc2, 0xf2}},\n+\t{\n+\t\t[]byte{0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},\n+\t\t[]byte{0xed, 0x39, 0xd9, 0x50, 0xfa, 0x74, 0xbc, 0xc4}},\n+\t{\n+\t\t[]byte{0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},\n+\t\t[]byte{0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10},\n+\t\t[]byte{0xa9, 0x33, 0xf6, 0x18, 0x30, 0x23, 0xb3, 0x10}},\n+\t{\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},\n+\t\t[]byte{0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11},\n+\t\t[]byte{0x17, 0x66, 0x8d, 0xfc, 0x72, 0x92, 0x53, 0x2d}},\n+\t{\n+\t\t[]byte{0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef},\n+\t\t[]byte{0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\t[]byte{0xb4, 0xfd, 0x23, 0x16, 0x47, 0xa5, 0xbe, 0xc0}},\n+\t{\n+\t\t[]byte{0x0e, 0x32, 0x92, 0x32, 0xea, 0x6d, 0x0d, 0x73},\n+\t\t[]byte{0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87, 0x87},\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}},\n+\t{\n+\t\t[]byte{0x73, 0x65, 0x63, 0x52, 0x33, 0x74, 0x24, 0x3b}, // \"secR3t$;\"\n+\t\t[]byte{0x61, 0x20, 0x74, 0x65, 0x73, 0x74, 0x31, 0x32}, // \"a test12\"\n+\t\t[]byte{0x37, 0x0d, 0xee, 0x2c, 0x1f, 0xb4, 0xf7, 0xa5}},\n+\t{\n+\t\t[]byte{0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68}, // \"abcdefgh\"\n+\t\t[]byte{0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68}, // \"abcdefgh\"\n+\t\t[]byte{0x2a, 0x8d, 0x69, 0xde, 0x9d, 0x5f, 0xdf, 0xf9}},\n+\t{\n+\t\t[]byte{0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68}, // \"abcdefgh\"\n+\t\t[]byte{0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38}, // \"12345678\"\n+\t\t[]byte{0x21, 0xc6, 0x0d, 0xa5, 0x34, 0x24, 0x8b, 0xce}},\n+\t{\n+\t\t[]byte{0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38}, // \"12345678\"\n+\t\t[]byte{0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68}, // \"abcdefgh\"\n+\t\t[]byte{0x94, 0xd4, 0x43, 0x6b, 0xc3, 0xb5, 0xb6, 0x93}},\n+\t{\n+\t\t[]byte{0x1f, 0x79, 0x90, 0x5f, 0x88, 0x01, 0xc8, 0x88}, // random\n+\t\t[]byte{0xc7, 0x46, 0x18, 0x73, 0xaf, 0x48, 0x5f, 0xb3}, // random\n+\t\t[]byte{0xb0, 0x93, 0x50, 0x88, 0xf9, 0x92, 0x44, 0x6a}},\n+\t{\n+\t\t[]byte{0xe6, 0xf4, 0xf2, 0xdb, 0x31, 0x42, 0x53, 0x01}, // random\n+\t\t[]byte{0xff, 0x3d, 0x25, 0x50, 0x12, 0xe3, 0x4a, 0xc5}, // random\n+\t\t[]byte{0x86, 0x08, 0xd3, 0xd1, 0x6c, 0x2f, 0xd2, 0x55}},\n+\t{\n+\t\t[]byte{0x69, 0xc1, 0x9d, 0xc1, 0x15, 0xc5, 0xfb, 0x2b}, // random\n+\t\t[]byte{0x1a, 0x22, 0x5c, 0xaf, 0x1f, 0x1d, 0xa3, 0xf9}, // random\n+\t\t[]byte{0x64, 0xba, 0x31, 0x67, 0x56, 0x91, 0x1e, 0xa7}},\n+\t{\n+\t\t[]byte{0x6e, 0x5e, 0xe2, 0x47, 0xc4, 0xbf, 0xf6, 0x51}, // random\n+\t\t[]byte{0x11, 0xc9, 0x57, 0xff, 0x66, 0x89, 0x0e, 0xf0}, // random\n+\t\t[]byte{0x94, 0xc5, 0x35, 0xb2, 0xc5, 0x8b, 0x39, 0x72}},\n+}\n+\n+var weakKeyTests = []CryptTest{\n+\t{\n+\t\t[]byte{0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\t[]byte{0x55, 0x74, 0xc0, 0xbd, 0x7c, 0xdf, 0xf7, 0x39}, // random\n+\t\tnil},\n+\t{\n+\t\t[]byte{0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe},\n+\t\t[]byte{0xe8, 0xe1, 0xa7, 0xc1, 0xde, 0x11, 0x89, 0xaa}, // random\n+\t\tnil},\n+\t{\n+\t\t[]byte{0xe0, 0xe0, 0xe0, 0xe0, 0xf1, 0xf1, 0xf1, 0xf1},\n+\t\t[]byte{0x50, 0x6a, 0x4b, 0x94, 0x3b, 0xed, 0x7d, 0xdc}, // random\n+\t\tnil},\n+\t{\n+\t\t[]byte{0x1f, 0x1f, 0x1f, 0x1f, 0x0e, 0x0e, 0x0e, 0x0e},\n+\t\t[]byte{0x88, 0x81, 0x56, 0x38, 0xec, 0x3b, 0x1c, 0x97}, // random\n+\t\tnil},\n+\t{\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x17, 0xa0, 0x83, 0x62, 0x32, 0xfe, 0x9a, 0x0b}, // random\n+\t\tnil},\n+\t{\n+\t\t[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0xca, 0x8f, 0xca, 0x1f, 0x50, 0xc5, 0x7b, 0x49}, // random\n+\t\tnil},\n+\t{\n+\t\t[]byte{0xe1, 0xe1, 0xe1, 0xe1, 0xf0, 0xf0, 0xf0, 0xf0},\n+\t\t[]byte{0xb1, 0xea, 0xad, 0x7d, 0xe7, 0xc3, 0x7a, 0x43}, // random\n+\t\tnil},\n+\t{\n+\t\t[]byte{0x1e, 0x1e, 0x1e, 0x1e, 0x0f, 0x0f, 0x0f, 0x0f},\n+\t\t[]byte{0xae, 0x74, 0x7d, 0x6f, 0xef, 0x16, 0xbb, 0x81}, // random\n+\t\tnil},\n+}\n+\n+var semiWeakKeyTests = []CryptTest{\n+\t// key and out contain the semi-weak key pair\n+\t{\n+\t\t[]byte{0x01, 0x1f, 0x01, 0x1f, 0x01, 0x0e, 0x01, 0x0e},\n+\t\t[]byte{0x12, 0xfa, 0x31, 0x16, 0xf9, 0xc5, 0x0a, 0xe4}, // random\n+\t\t[]byte{0x1f, 0x01, 0x1f, 0x01, 0x0e, 0x01, 0x0e, 0x01}},\n+\t{\n+\t\t[]byte{0x01, 0xe0, 0x01, 0xe0, 0x01, 0xf1, 0x01, 0xf1},\n+\t\t[]byte{0xb0, 0x4c, 0x7a, 0xee, 0xd2, 0xe5, 0x4d, 0xb7}, // random\n+\t\t[]byte{0xe0, 0x01, 0xe0, 0x01, 0xf1, 0x01, 0xf1, 0x01}},\n+\t{\n+\t\t[]byte{0x01, 0xfe, 0x01, 0xfe, 0x01, 0xfe, 0x01, 0xfe},\n+\t\t[]byte{0xa4, 0x81, 0xcd, 0xb1, 0x64, 0x6f, 0xd3, 0xbc}, // random\n+\t\t[]byte{0xfe, 0x01, 0xfe, 0x01, 0xfe, 0x01, 0xfe, 0x01}},\n+\t{\n+\t\t[]byte{0x1f, 0xe0, 0x1f, 0xe0, 0x0e, 0xf1, 0x0e, 0xf1},\n+\t\t[]byte{0xee, 0x27, 0xdd, 0x88, 0x4c, 0x22, 0xcd, 0xce}, // random\n+\t\t[]byte{0xe0, 0x1f, 0xe0, 0x1f, 0xf1, 0x0e, 0xf1, 0x0e}},\n+\t{\n+\t\t[]byte{0x1f, 0xfe, 0x1f, 0xfe, 0x0e, 0xfe, 0x0e, 0xfe},\n+\t\t[]byte{0x19, 0x3d, 0xcf, 0x97, 0x70, 0xfb, 0xab, 0xe1}, // random\n+\t\t[]byte{0xfe, 0x1f, 0xfe, 0x1f, 0xfe, 0x0e, 0xfe, 0x0e}},\n+\t{\n+\t\t[]byte{0xe0, 0xfe, 0xe0, 0xfe, 0xf1, 0xfe, 0xf1, 0xfe},\n+\t\t[]byte{0x7c, 0x82, 0x69, 0xe4, 0x1e, 0x86, 0x99, 0xd7}, // random\n+\t\t[]byte{0xfe, 0xe0, 0xfe, 0xe0, 0xfe, 0xf1, 0xfe, 0xf1}},\n+}\n+\n+// some custom tests for TripleDES\n+var encryptTripleDESTests = []CryptTest{\n+\t{\n+\t\t[]byte{\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x92, 0x95, 0xb5, 0x9b, 0xb3, 0x84, 0x73, 0x6e}},\n+\t{\n+\t\t[]byte{\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0xc1, 0x97, 0xf5, 0x58, 0x74, 0x8a, 0x20, 0xe7}},\n+\t{\n+\t\t[]byte{\n+\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x3e, 0x68, 0x0a, 0xa7, 0x8b, 0x75, 0xdf, 0x18}},\n+\t{\n+\t\t[]byte{\n+\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff},\n+\t\t[]byte{0x6d, 0x6a, 0x4a, 0x64, 0x4c, 0x7b, 0x8c, 0x91}},\n+\t{\n+\t\t[]byte{ // \"abcdefgh12345678ABCDEFGH\"\n+\t\t\t0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,\n+\t\t\t0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,\n+\t\t\t0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48},\n+\t\t[]byte{0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30}, // \"00000000\"\n+\t\t[]byte{0xe4, 0x61, 0xb7, 0x59, 0x68, 0x8b, 0xff, 0x66}},\n+\t{\n+\t\t[]byte{ // \"abcdefgh12345678ABCDEFGH\"\n+\t\t\t0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,\n+\t\t\t0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,\n+\t\t\t0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48},\n+\t\t[]byte{0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38}, // \"12345678\"\n+\t\t[]byte{0xdb, 0xd0, 0x92, 0xde, 0xf8, 0x34, 0xff, 0x58}},\n+\t{\n+\t\t[]byte{ // \"abcdefgh12345678ABCDEFGH\"\n+\t\t\t0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68,\n+\t\t\t0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38,\n+\t\t\t0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48},\n+\t\t[]byte{0xf0, 0xc5, 0x82, 0x22, 0xd3, 0xe6, 0x12, 0xd2}, // random\n+\t\t[]byte{0xba, 0xe4, 0x41, 0xb1, 0x3c, 0x37, 0x4d, 0xf4}},\n+\t{\n+\t\t[]byte{ // random\n+\t\t\t0xd3, 0x7d, 0x45, 0xee, 0x22, 0xe9, 0xcf, 0x52,\n+\t\t\t0xf4, 0x65, 0xa2, 0x4f, 0x70, 0xd1, 0x81, 0x8a,\n+\t\t\t0x3d, 0xbe, 0x2f, 0x39, 0xc7, 0x71, 0xd2, 0xe9},\n+\t\t[]byte{0x49, 0x53, 0xc3, 0xe9, 0x78, 0xdf, 0x9f, 0xaf}, // random\n+\t\t[]byte{0x53, 0x40, 0x51, 0x24, 0xd8, 0x3c, 0xf9, 0x88}},\n+\t{\n+\t\t[]byte{ // random\n+\t\t\t0xcb, 0x10, 0x7d, 0xda, 0x7e, 0x96, 0x57, 0x0a,\n+\t\t\t0xe8, 0xeb, 0xe8, 0x07, 0x8e, 0x87, 0xd3, 0x57,\n+\t\t\t0xb2, 0x61, 0x12, 0xb8, 0x2a, 0x90, 0xb7, 0x2f},\n+\t\t[]byte{0xa3, 0xc2, 0x60, 0xb1, 0x0b, 0xb7, 0x28, 0x6e}, // random\n+\t\t[]byte{0x56, 0x73, 0x7d, 0xfb, 0xb5, 0xa1, 0xc3, 0xde}},\n+}\n+\n+// NIST Special Publication 800-20, Appendix A\n+// Key for use with Table A.1 tests\n+var tableA1Key = []byte{\n+\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+}\n+\n+// Table A.1 Resulting Ciphertext from the Variable Plaintext Known Answer Test\n+var tableA1Tests = []CryptTest{\n+\t{nil, // 0\n+\t\t[]byte{0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x95, 0xf8, 0xa5, 0xe5, 0xdd, 0x31, 0xd9, 0x00}},\n+\t{nil, // 1\n+\t\t[]byte{0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xdd, 0x7f, 0x12, 0x1c, 0xa5, 0x01, 0x56, 0x19}},\n+\t{nil, // 2\n+\t\t[]byte{0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x2e, 0x86, 0x53, 0x10, 0x4f, 0x38, 0x34, 0xea}},\n+\t{nil, // 3\n+\t\t[]byte{0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x4b, 0xd3, 0x88, 0xff, 0x6c, 0xd8, 0x1d, 0x4f}},\n+\t{nil, // 4\n+\t\t[]byte{0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x20, 0xb9, 0xe7, 0x67, 0xb2, 0xfb, 0x14, 0x56}},\n+\t{nil, // 5\n+\t\t[]byte{0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x55, 0x57, 0x93, 0x80, 0xd7, 0x71, 0x38, 0xef}},\n+\t{nil, // 6\n+\t\t[]byte{0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x6c, 0xc5, 0xde, 0xfa, 0xaf, 0x04, 0x51, 0x2f}},\n+\t{nil, // 7\n+\t\t[]byte{0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x0d, 0x9f, 0x27, 0x9b, 0xa5, 0xd8, 0x72, 0x60}},\n+\t{nil, // 8\n+\t\t[]byte{0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xd9, 0x03, 0x1b, 0x02, 0x71, 0xbd, 0x5a, 0x0a}},\n+\t{nil, // 9\n+\t\t[]byte{0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x42, 0x42, 0x50, 0xb3, 0x7c, 0x3d, 0xd9, 0x51}},\n+\t{nil, // 10\n+\t\t[]byte{0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xb8, 0x06, 0x1b, 0x7e, 0xcd, 0x9a, 0x21, 0xe5}},\n+\t{nil, // 11\n+\t\t[]byte{0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xf1, 0x5d, 0x0f, 0x28, 0x6b, 0x65, 0xbd, 0x28}},\n+\t{nil, // 12\n+\t\t[]byte{0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xad, 0xd0, 0xcc, 0x8d, 0x6e, 0x5d, 0xeb, 0xa1}},\n+\t{nil, // 13\n+\t\t[]byte{0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xe6, 0xd5, 0xf8, 0x27, 0x52, 0xad, 0x63, 0xd1}},\n+\t{nil, // 14\n+\t\t[]byte{0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xec, 0xbf, 0xe3, 0xbd, 0x3f, 0x59, 0x1a, 0x5e}},\n+\t{nil, // 15\n+\t\t[]byte{0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xf3, 0x56, 0x83, 0x43, 0x79, 0xd1, 0x65, 0xcd}},\n+\t{nil, // 16\n+\t\t[]byte{0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x2b, 0x9f, 0x98, 0x2f, 0x20, 0x03, 0x7f, 0xa9}},\n+\t{nil, // 17\n+\t\t[]byte{0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x88, 0x9d, 0xe0, 0x68, 0xa1, 0x6f, 0x0b, 0xe6}},\n+\t{nil, // 18\n+\t\t[]byte{0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xe1, 0x9e, 0x27, 0x5d, 0x84, 0x6a, 0x12, 0x98}},\n+\t{nil, // 19\n+\t\t[]byte{0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x32, 0x9a, 0x8e, 0xd5, 0x23, 0xd7, 0x1a, 0xec}},\n+\t{nil, // 20\n+\t\t[]byte{0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xe7, 0xfc, 0xe2, 0x25, 0x57, 0xd2, 0x3c, 0x97}},\n+\t{nil, // 21\n+\t\t[]byte{0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x12, 0xa9, 0xf5, 0x81, 0x7f, 0xf2, 0xd6, 0x5d}},\n+\t{nil, // 22\n+\t\t[]byte{0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xa4, 0x84, 0xc3, 0xad, 0x38, 0xdc, 0x9c, 0x19}},\n+\t{nil, // 23\n+\t\t[]byte{0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xfb, 0xe0, 0x0a, 0x8a, 0x1e, 0xf8, 0xad, 0x72}},\n+\t{nil, // 24\n+\t\t[]byte{0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x75, 0x0d, 0x07, 0x94, 0x07, 0x52, 0x13, 0x63}},\n+\t{nil, // 25\n+\t\t[]byte{0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x64, 0xfe, 0xed, 0x9c, 0x72, 0x4c, 0x2f, 0xaf}},\n+\t{nil, // 26\n+\t\t[]byte{0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xf0, 0x2b, 0x26, 0x3b, 0x32, 0x8e, 0x2b, 0x60}},\n+\t{nil, // 27\n+\t\t[]byte{0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x9d, 0x64, 0x55, 0x5a, 0x9a, 0x10, 0xb8, 0x52}},\n+\t{nil, // 28\n+\t\t[]byte{0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xd1, 0x06, 0xff, 0x0b, 0xed, 0x52, 0x55, 0xd7}},\n+\t{nil, // 29\n+\t\t[]byte{0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xe1, 0x65, 0x2c, 0x6b, 0x13, 0x8c, 0x64, 0xa5}},\n+\t{nil, // 30\n+\t\t[]byte{0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xe4, 0x28, 0x58, 0x11, 0x86, 0xec, 0x8f, 0x46}},\n+\t{nil, // 31\n+\t\t[]byte{0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xae, 0xb5, 0xf5, 0xed, 0xe2, 0x2d, 0x1a, 0x36}},\n+\t{nil, // 32\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xe9, 0x43, 0xd7, 0x56, 0x8a, 0xec, 0x0c, 0x5c}},\n+\t{nil, // 33\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xdf, 0x98, 0xc8, 0x27, 0x6f, 0x54, 0xb0, 0x4b}},\n+\t{nil, // 34\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xb1, 0x60, 0xe4, 0x68, 0x0f, 0x6c, 0x69, 0x6f}},\n+\t{nil, // 35\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xfa, 0x07, 0x52, 0xb0, 0x7d, 0x9c, 0x4a, 0xb8}},\n+\t{nil, // 36\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00},\n+\t\t[]byte{0xca, 0x3a, 0x2b, 0x03, 0x6d, 0xbc, 0x85, 0x02}},\n+\t{nil, // 37\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x5e, 0x09, 0x05, 0x51, 0x7b, 0xb5, 0x9b, 0xcf}},\n+\t{nil, // 38\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x81, 0x4e, 0xeb, 0x3b, 0x91, 0xd9, 0x07, 0x26}},\n+\t{nil, // 39\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00},\n+\t\t[]byte{0x4d, 0x49, 0xdb, 0x15, 0x32, 0x91, 0x9c, 0x9f}},\n+\t{nil, // 40\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00},\n+\t\t[]byte{0x25, 0xeb, 0x5f, 0xc3, 0xf8, 0xcf, 0x06, 0x21}},\n+\t{nil, // 41\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00},\n+\t\t[]byte{0xab, 0x6a, 0x20, 0xc0, 0x62, 0x0d, 0x1c, 0x6f}},\n+\t{nil, // 42\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00},\n+\t\t[]byte{0x79, 0xe9, 0x0d, 0xbc, 0x98, 0xf9, 0x2c, 0xca}},\n+\t{nil, // 43\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00},\n+\t\t[]byte{0x86, 0x6e, 0xce, 0xdd, 0x80, 0x72, 0xbb, 0x0e}},\n+\t{nil, // 44\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00},\n+\t\t[]byte{0x8b, 0x54, 0x53, 0x6f, 0x2f, 0x3e, 0x64, 0xa8}},\n+\t{nil, // 45\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00},\n+\t\t[]byte{0xea, 0x51, 0xd3, 0x97, 0x55, 0x95, 0xb8, 0x6b}},\n+\t{nil, // 46\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00},\n+\t\t[]byte{0xca, 0xff, 0xc6, 0xac, 0x45, 0x42, 0xde, 0x31}},\n+\t{nil, // 47\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00},\n+\t\t[]byte{0x8d, 0xd4, 0x5a, 0x2d, 0xdf, 0x90, 0x79, 0x6c}},\n+\t{nil, // 48\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00},\n+\t\t[]byte{0x10, 0x29, 0xd5, 0x5e, 0x88, 0x0e, 0xc2, 0xd0}},\n+\t{nil, // 49\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00},\n+\t\t[]byte{0x5d, 0x86, 0xcb, 0x23, 0x63, 0x9d, 0xbe, 0xa9}},\n+\t{nil, // 50\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00},\n+\t\t[]byte{0x1d, 0x1c, 0xa8, 0x53, 0xae, 0x7c, 0x0c, 0x5f}},\n+\t{nil, // 51\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00},\n+\t\t[]byte{0xce, 0x33, 0x23, 0x29, 0x24, 0x8f, 0x32, 0x28}},\n+\t{nil, // 52\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08, 0x00},\n+\t\t[]byte{0x84, 0x05, 0xd1, 0xab, 0xe2, 0x4f, 0xb9, 0x42}},\n+\t{nil, // 53\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00},\n+\t\t[]byte{0xe6, 0x43, 0xd7, 0x80, 0x90, 0xca, 0x42, 0x07}},\n+\t{nil, // 54\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00},\n+\t\t[]byte{0x48, 0x22, 0x1b, 0x99, 0x37, 0x74, 0x8a, 0x23}},\n+\t{nil, // 55\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00},\n+\t\t[]byte{0xdd, 0x7c, 0x0b, 0xbd, 0x61, 0xfa, 0xfd, 0x54}},\n+\t{nil, // 56\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80},\n+\t\t[]byte{0x2f, 0xbc, 0x29, 0x1a, 0x57, 0x0d, 0xb5, 0xc4}},\n+\t{nil, // 57\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40},\n+\t\t[]byte{0xe0, 0x7c, 0x30, 0xd7, 0xe4, 0xe2, 0x6e, 0x12}},\n+\t{nil, // 58\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20},\n+\t\t[]byte{0x09, 0x53, 0xe2, 0x25, 0x8e, 0x8e, 0x90, 0xa1}},\n+\t{nil, // 59\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10},\n+\t\t[]byte{0x5b, 0x71, 0x1b, 0xc4, 0xce, 0xeb, 0xf2, 0xee}},\n+\t{nil, // 60\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x08},\n+\t\t[]byte{0xcc, 0x08, 0x3f, 0x1e, 0x6d, 0x9e, 0x85, 0xf6}},\n+\t{nil, // 61\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04},\n+\t\t[]byte{0xd2, 0xfd, 0x88, 0x67, 0xd5, 0x0d, 0x2d, 0xfe}},\n+\t{nil, // 62\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02},\n+\t\t[]byte{0x06, 0xe7, 0xea, 0x22, 0xce, 0x92, 0x70, 0x8f}},\n+\t{nil, // 63\n+\t\t[]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01},\n+\t\t[]byte{0x16, 0x6b, 0x40, 0xb4, 0x4a, 0xba, 0x4b, 0xd6}},\n+}\n+\n+// Plaintext for use with Table A.2 tests\n+var tableA2Plaintext = []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n+\n+// Table A.2 Resulting Ciphertext from the Variable Key Known Answer Test\n+var tableA2Tests = []CryptTest{\n+\t{ // 0\n+\t\t[]byte{\n+\t\t\t0x80, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x80, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x80, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x95, 0xa8, 0xd7, 0x28, 0x13, 0xda, 0xa9, 0x4d}},\n+\t{ // 1\n+\t\t[]byte{\n+\t\t\t0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x0e, 0xec, 0x14, 0x87, 0xdd, 0x8c, 0x26, 0xd5}},\n+\t{ // 2\n+\t\t[]byte{\n+\t\t\t0x20, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x20, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x20, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x7a, 0xd1, 0x6f, 0xfb, 0x79, 0xc4, 0x59, 0x26}},\n+\t{ // 3\n+\t\t[]byte{\n+\t\t\t0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xd3, 0x74, 0x62, 0x94, 0xca, 0x6a, 0x6c, 0xf3}},\n+\t{ // 4\n+\t\t[]byte{\n+\t\t\t0x08, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x08, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x08, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x80, 0x9f, 0x5f, 0x87, 0x3c, 0x1f, 0xd7, 0x61}},\n+\t{ // 5\n+\t\t[]byte{\n+\t\t\t0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xc0, 0x2f, 0xaf, 0xfe, 0xc9, 0x89, 0xd1, 0xfc}},\n+\t{ // 6\n+\t\t[]byte{\n+\t\t\t0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x46, 0x15, 0xaa, 0x1d, 0x33, 0xe7, 0x2f, 0x10}},\n+\t{ // 7\n+\t\t[]byte{\n+\t\t\t0x01, 0x80, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x80, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x80, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x20, 0x55, 0x12, 0x33, 0x50, 0xc0, 0x08, 0x58}},\n+\t{ // 8\n+\t\t[]byte{\n+\t\t\t0x01, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xdf, 0x3b, 0x99, 0xd6, 0x57, 0x73, 0x97, 0xc8}},\n+\t{ // 9\n+\t\t[]byte{\n+\t\t\t0x01, 0x20, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x20, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x20, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x31, 0xfe, 0x17, 0x36, 0x9b, 0x52, 0x88, 0xc9}},\n+\t{ // 10\n+\t\t[]byte{\n+\t\t\t0x01, 0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x10, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xdf, 0xdd, 0x3c, 0xc6, 0x4d, 0xae, 0x16, 0x42}},\n+\t{ // 11\n+\t\t[]byte{\n+\t\t\t0x01, 0x08, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x08, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x08, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x17, 0x8c, 0x83, 0xce, 0x2b, 0x39, 0x9d, 0x94}},\n+\t{ // 12\n+\t\t[]byte{\n+\t\t\t0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x50, 0xf6, 0x36, 0x32, 0x4a, 0x9b, 0x7f, 0x80}},\n+\t{ // 13\n+\t\t[]byte{\n+\t\t\t0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xa8, 0x46, 0x8e, 0xe3, 0xbc, 0x18, 0xf0, 0x6d}},\n+\t{ // 14\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x80, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x80, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x80, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xa2, 0xdc, 0x9e, 0x92, 0xfd, 0x3c, 0xde, 0x92}},\n+\t{ // 15\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x40, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xca, 0xc0, 0x9f, 0x79, 0x7d, 0x03, 0x12, 0x87}},\n+\t{ // 16\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x20, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x20, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x20, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x90, 0xba, 0x68, 0x0b, 0x22, 0xae, 0xb5, 0x25}},\n+\t{ // 17\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x10, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x10, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x10, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xce, 0x7a, 0x24, 0xf3, 0x50, 0xe2, 0x80, 0xb6}},\n+\t{ // 18\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x08, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x08, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x08, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x88, 0x2b, 0xff, 0x0a, 0xa0, 0x1a, 0x0b, 0x87}},\n+\t{ // 19\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x25, 0x61, 0x02, 0x88, 0x92, 0x45, 0x11, 0xc2}},\n+\t{ // 20\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xc7, 0x15, 0x16, 0xc2, 0x9c, 0x75, 0xd1, 0x70}},\n+\t{ // 21\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x80, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x80, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x80, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x51, 0x99, 0xc2, 0x9a, 0x52, 0xc9, 0xf0, 0x59}},\n+\t{ // 22\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x40, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x40, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x40, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xc2, 0x2f, 0x0a, 0x29, 0x4a, 0x71, 0xf2, 0x9f}},\n+\t{ // 23\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x20, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x20, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x20, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xee, 0x37, 0x14, 0x83, 0x71, 0x4c, 0x02, 0xea}},\n+\t{ // 24\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x10, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x10, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x10, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xa8, 0x1f, 0xbd, 0x44, 0x8f, 0x9e, 0x52, 0x2f}},\n+\t{ // 25\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x4f, 0x64, 0x4c, 0x92, 0xe1, 0x92, 0xdf, 0xed}},\n+\t{ // 26\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x1a, 0xfa, 0x9a, 0x66, 0xa6, 0xdf, 0x92, 0xae}},\n+\t{ // 27\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xb3, 0xc1, 0xcc, 0x71, 0x5c, 0xb8, 0x79, 0xd8}},\n+\t{ // 28\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x80, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x80, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x80, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x19, 0xd0, 0x32, 0xe6, 0x4a, 0xb0, 0xbd, 0x8b}},\n+\t{ // 29\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x40, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x40, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x40, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x3c, 0xfa, 0xa7, 0xa7, 0xdc, 0x87, 0x20, 0xdc}},\n+\t{ // 30\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x20, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x20, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x20, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xb7, 0x26, 0x5f, 0x7f, 0x44, 0x7a, 0xc6, 0xf3}},\n+\t{ // 31\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x9d, 0xb7, 0x3b, 0x3c, 0x0d, 0x16, 0x3f, 0x54}},\n+\t{ // 32\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x81, 0x81, 0xb6, 0x5b, 0xab, 0xf4, 0xa9, 0x75}},\n+\t{ // 33\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x93, 0xc9, 0xb6, 0x40, 0x42, 0xea, 0xa2, 0x40}},\n+\t{ // 34\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x55, 0x70, 0x53, 0x08, 0x29, 0x70, 0x55, 0x92}},\n+\t{ // 35\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x80, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x80, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x80, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x86, 0x38, 0x80, 0x9e, 0x87, 0x87, 0x87, 0xa0}},\n+\t{ // 36\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x40, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x40, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x40, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x41, 0xb9, 0xa7, 0x9a, 0xf7, 0x9a, 0xc2, 0x08}},\n+\t{ // 37\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x7a, 0x9b, 0xe4, 0x2f, 0x20, 0x09, 0xa8, 0x92}},\n+\t{ // 38\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x29, 0x03, 0x8d, 0x56, 0xba, 0x6d, 0x27, 0x45}},\n+\t{ // 39\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x08, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x54, 0x95, 0xc6, 0xab, 0xf1, 0xe5, 0xdf, 0x51}},\n+\t{ // 40\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xae, 0x13, 0xdb, 0xd5, 0x61, 0x48, 0x89, 0x33}},\n+\t{ // 41\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x02, 0x4d, 0x1f, 0xfa, 0x89, 0x04, 0xe3, 0x89}},\n+\t{ // 42\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x80, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x80, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x80, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xd1, 0x39, 0x97, 0x12, 0xf9, 0x9b, 0xf0, 0x2e}},\n+\t{ // 43\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x40, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x40, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x40, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x14, 0xc1, 0xd7, 0xc1, 0xcf, 0xfe, 0xc7, 0x9e}},\n+\t{ // 44\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20, 0x01},\n+\t\tnil,\n+\t\t[]byte{0x1d, 0xe5, 0x27, 0x9d, 0xae, 0x3b, 0xed, 0x6f}},\n+\t{ // 45\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xe9, 0x41, 0xa3, 0x3f, 0x85, 0x50, 0x13, 0x03}},\n+\t{ // 46\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x08, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x08, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x08, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xda, 0x99, 0xdb, 0xbc, 0x9a, 0x03, 0xf3, 0x79}},\n+\t{ // 47\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xb7, 0xfc, 0x92, 0xf9, 0x1d, 0x8e, 0x92, 0xe9}},\n+\t{ // 48\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x01},\n+\t\tnil,\n+\t\t[]byte{0xae, 0x8e, 0x5c, 0xaa, 0x3c, 0xa0, 0x4e, 0x85}},\n+\t{ // 49\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x80,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x80,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x80},\n+\t\tnil,\n+\t\t[]byte{0x9c, 0xc6, 0x2d, 0xf4, 0x3b, 0x6e, 0xed, 0x74}},\n+\t{ // 50\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x40,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x40,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x40},\n+\t\tnil,\n+\t\t[]byte{0xd8, 0x63, 0xdb, 0xb5, 0xc5, 0x9a, 0x91, 0xa0}},\n+\t{ // 50\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x20},\n+\t\tnil,\n+\t\t[]byte{0xa1, 0xab, 0x21, 0x90, 0x54, 0x5b, 0x91, 0xd7}},\n+\t{ // 52\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x10},\n+\t\tnil,\n+\t\t[]byte{0x08, 0x75, 0x04, 0x1e, 0x64, 0xc5, 0x70, 0xf7}},\n+\t{ // 53\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x08,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x08,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x08},\n+\t\tnil,\n+\t\t[]byte{0x5a, 0x59, 0x45, 0x28, 0xbe, 0xbe, 0xf1, 0xcc}},\n+\t{ // 54\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x04},\n+\t\tnil,\n+\t\t[]byte{0xfc, 0xdb, 0x32, 0x91, 0xde, 0x21, 0xf0, 0xc0}},\n+\t{ // 55\n+\t\t[]byte{\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02,\n+\t\t\t0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02},\n+\t\tnil,\n+\t\t[]byte{0x86, 0x9e, 0xfd, 0x7f, 0x9f, 0x26, 0x5a, 0x09}},\n+}\n+\n+// Plaintext for use with Table A.3 tests\n+var tableA3Plaintext = []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}\n+\n+// Table A.3 Values To Be Used for the Permutation Operation Known Answer Test\n+var tableA3Tests = []CryptTest{\n+\t{ // 0\n+\t\t[]byte{\n+\t\t\t0x10, 0x46, 0x91, 0x34, 0x89, 0x98, 0x01, 0x31,\n+\t\t\t0x10, 0x46, 0x91, 0x34, 0x89, 0x98, 0x01, 0x31,\n+\t\t\t0x10, 0x46, 0x91, 0x34, 0x89, 0x98, 0x01, 0x31,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x88, 0xd5, 0x5e, 0x54, 0xf5, 0x4c, 0x97, 0xb4}},\n+\t{ // 1\n+\t\t[]byte{\n+\t\t\t0x10, 0x07, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,\n+\t\t\t0x10, 0x07, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,\n+\t\t\t0x10, 0x07, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x0c, 0x0c, 0xc0, 0x0c, 0x83, 0xea, 0x48, 0xfd}},\n+\t{ // 2\n+\t\t[]byte{\n+\t\t\t0x10, 0x07, 0x10, 0x34, 0xc8, 0x98, 0x01, 0x20,\n+\t\t\t0x10, 0x07, 0x10, 0x34, 0xc8, 0x98, 0x01, 0x20,\n+\t\t\t0x10, 0x07, 0x10, 0x34, 0xc8, 0x98, 0x01, 0x20,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x83, 0xbc, 0x8e, 0xf3, 0xa6, 0x57, 0x01, 0x83}},\n+\t{ // 3\n+\t\t[]byte{\n+\t\t\t0x10, 0x46, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,\n+\t\t\t0x10, 0x46, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,\n+\t\t\t0x10, 0x46, 0x10, 0x34, 0x89, 0x98, 0x80, 0x20,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xdf, 0x72, 0x5d, 0xca, 0xd9, 0x4e, 0xa2, 0xe9}},\n+\t{ // 4\n+\t\t[]byte{\n+\t\t\t0x10, 0x86, 0x91, 0x15, 0x19, 0x19, 0x01, 0x01,\n+\t\t\t0x10, 0x86, 0x91, 0x15, 0x19, 0x19, 0x01, 0x01,\n+\t\t\t0x10, 0x86, 0x91, 0x15, 0x19, 0x19, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xe6, 0x52, 0xb5, 0x3b, 0x55, 0x0b, 0xe8, 0xb0}},\n+\t{ // 5\n+\t\t[]byte{\n+\t\t\t0x10, 0x86, 0x91, 0x15, 0x19, 0x58, 0x01, 0x01,\n+\t\t\t0x10, 0x86, 0x91, 0x15, 0x19, 0x58, 0x01, 0x01,\n+\t\t\t0x10, 0x86, 0x91, 0x15, 0x19, 0x58, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xaf, 0x52, 0x71, 0x20, 0xc4, 0x85, 0xcb, 0xb0}},\n+\t{ // 6\n+\t\t[]byte{\n+\t\t\t0x51, 0x07, 0xb0, 0x15, 0x19, 0x58, 0x01, 0x01,\n+\t\t\t0x51, 0x07, 0xb0, 0x15, 0x19, 0x58, 0x01, 0x01,\n+\t\t\t0x51, 0x07, 0xb0, 0x15, 0x19, 0x58, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x0f, 0x04, 0xce, 0x39, 0x3d, 0xb9, 0x26, 0xd5}},\n+\t{ // 7\n+\t\t[]byte{\n+\t\t\t0x10, 0x07, 0xb0, 0x15, 0x19, 0x19, 0x01, 0x01,\n+\t\t\t0x10, 0x07, 0xb0, 0x15, 0x19, 0x19, 0x01, 0x01,\n+\t\t\t0x10, 0x07, 0xb0, 0x15, 0x19, 0x19, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xc9, 0xf0, 0x0f, 0xfc, 0x74, 0x07, 0x90, 0x67}},\n+\t{ // 8\n+\t\t[]byte{\n+\t\t\t0x31, 0x07, 0x91, 0x54, 0x98, 0x08, 0x01, 0x01,\n+\t\t\t0x31, 0x07, 0x91, 0x54, 0x98, 0x08, 0x01, 0x01,\n+\t\t\t0x31, 0x07, 0x91, 0x54, 0x98, 0x08, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x7c, 0xfd, 0x82, 0xa5, 0x93, 0x25, 0x2b, 0x4e}},\n+\t{ // 9\n+\t\t[]byte{\n+\t\t\t0x31, 0x07, 0x91, 0x94, 0x98, 0x08, 0x01, 0x01,\n+\t\t\t0x31, 0x07, 0x91, 0x94, 0x98, 0x08, 0x01, 0x01,\n+\t\t\t0x31, 0x07, 0x91, 0x94, 0x98, 0x08, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xcb, 0x49, 0xa2, 0xf9, 0xe9, 0x13, 0x63, 0xe3}},\n+\t{ // 10\n+\t\t[]byte{\n+\t\t\t0x10, 0x07, 0x91, 0x15, 0xb9, 0x08, 0x01, 0x40,\n+\t\t\t0x10, 0x07, 0x91, 0x15, 0xb9, 0x08, 0x01, 0x40,\n+\t\t\t0x10, 0x07, 0x91, 0x15, 0xb9, 0x08, 0x01, 0x40,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x00, 0xb5, 0x88, 0xbe, 0x70, 0xd2, 0x3f, 0x56}},\n+\t{ // 11\n+\t\t[]byte{\n+\t\t\t0x31, 0x07, 0x91, 0x15, 0x98, 0x08, 0x01, 0x40,\n+\t\t\t0x31, 0x07, 0x91, 0x15, 0x98, 0x08, 0x01, 0x40,\n+\t\t\t0x31, 0x07, 0x91, 0x15, 0x98, 0x08, 0x01, 0x40,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x40, 0x6a, 0x9a, 0x6a, 0xb4, 0x33, 0x99, 0xae}},\n+\t{ // 12\n+\t\t[]byte{\n+\t\t\t0x10, 0x07, 0xd0, 0x15, 0x89, 0x98, 0x01, 0x01,\n+\t\t\t0x10, 0x07, 0xd0, 0x15, 0x89, 0x98, 0x01, 0x01,\n+\t\t\t0x10, 0x07, 0xd0, 0x15, 0x89, 0x98, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x6c, 0xb7, 0x73, 0x61, 0x1d, 0xca, 0x9a, 0xda}},\n+\t{ // 13\n+\t\t[]byte{\n+\t\t\t0x91, 0x07, 0x91, 0x15, 0x89, 0x98, 0x01, 0x01,\n+\t\t\t0x91, 0x07, 0x91, 0x15, 0x89, 0x98, 0x01, 0x01,\n+\t\t\t0x91, 0x07, 0x91, 0x15, 0x89, 0x98, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x67, 0xfd, 0x21, 0xc1, 0x7d, 0xbb, 0x5d, 0x70}},\n+\t{ // 14\n+\t\t[]byte{\n+\t\t\t0x91, 0x07, 0xd0, 0x15, 0x89, 0x19, 0x01, 0x01,\n+\t\t\t0x91, 0x07, 0xd0, 0x15, 0x89, 0x19, 0x01, 0x01,\n+\t\t\t0x91, 0x07, 0xd0, 0x15, 0x89, 0x19, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x95, 0x92, 0xcb, 0x41, 0x10, 0x43, 0x07, 0x87}},\n+\t{ // 15\n+\t\t[]byte{\n+\t\t\t0x10, 0x07, 0xd0, 0x15, 0x98, 0x98, 0x01, 0x20,\n+\t\t\t0x10, 0x07, 0xd0, 0x15, 0x98, 0x98, 0x01, 0x20,\n+\t\t\t0x10, 0x07, 0xd0, 0x15, 0x98, 0x98, 0x01, 0x20,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xa6, 0xb7, 0xff, 0x68, 0xa3, 0x18, 0xdd, 0xd3}},\n+\t{ // 16\n+\t\t[]byte{\n+\t\t\t0x10, 0x07, 0x94, 0x04, 0x98, 0x19, 0x01, 0x01,\n+\t\t\t0x10, 0x07, 0x94, 0x04, 0x98, 0x19, 0x01, 0x01,\n+\t\t\t0x10, 0x07, 0x94, 0x04, 0x98, 0x19, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x4d, 0x10, 0x21, 0x96, 0xc9, 0x14, 0xca, 0x16}},\n+\t{ // 17\n+\t\t[]byte{\n+\t\t\t0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x04, 0x01,\n+\t\t\t0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x04, 0x01,\n+\t\t\t0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x04, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x2d, 0xfa, 0x9f, 0x45, 0x73, 0x59, 0x49, 0x65}},\n+\t{ // 18\n+\t\t[]byte{\n+\t\t\t0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x01, 0x01,\n+\t\t\t0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x01, 0x01,\n+\t\t\t0x01, 0x07, 0x91, 0x04, 0x91, 0x19, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xb4, 0x66, 0x04, 0x81, 0x6c, 0x0e, 0x07, 0x74}},\n+\t{ // 19\n+\t\t[]byte{\n+\t\t\t0x01, 0x07, 0x94, 0x04, 0x91, 0x19, 0x04, 0x01,\n+\t\t\t0x01, 0x07, 0x94, 0x04, 0x91, 0x19, 0x04, 0x01,\n+\t\t\t0x01, 0x07, 0x94, 0x04, 0x91, 0x19, 0x04, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x6e, 0x7e, 0x62, 0x21, 0xa4, 0xf3, 0x4e, 0x87}},\n+\t{ // 20\n+\t\t[]byte{\n+\t\t\t0x19, 0x07, 0x92, 0x10, 0x98, 0x1a, 0x01, 0x01,\n+\t\t\t0x19, 0x07, 0x92, 0x10, 0x98, 0x1a, 0x01, 0x01,\n+\t\t\t0x19, 0x07, 0x92, 0x10, 0x98, 0x1a, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xaa, 0x85, 0xe7, 0x46, 0x43, 0x23, 0x31, 0x99}},\n+\t{ // 21\n+\t\t[]byte{\n+\t\t\t0x10, 0x07, 0x91, 0x19, 0x98, 0x19, 0x08, 0x01,\n+\t\t\t0x10, 0x07, 0x91, 0x19, 0x98, 0x19, 0x08, 0x01,\n+\t\t\t0x10, 0x07, 0x91, 0x19, 0x98, 0x19, 0x08, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x2e, 0x5a, 0x19, 0xdb, 0x4d, 0x19, 0x62, 0xd6}},\n+\t{ // 22\n+\t\t[]byte{\n+\t\t\t0x10, 0x07, 0x91, 0x19, 0x98, 0x1a, 0x08, 0x01,\n+\t\t\t0x10, 0x07, 0x91, 0x19, 0x98, 0x1a, 0x08, 0x01,\n+\t\t\t0x10, 0x07, 0x91, 0x19, 0x98, 0x1a, 0x08, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x23, 0xa8, 0x66, 0xa8, 0x09, 0xd3, 0x08, 0x94}},\n+\t{ // 23\n+\t\t[]byte{\n+\t\t\t0x10, 0x07, 0x92, 0x10, 0x98, 0x19, 0x01, 0x01,\n+\t\t\t0x10, 0x07, 0x92, 0x10, 0x98, 0x19, 0x01, 0x01,\n+\t\t\t0x10, 0x07, 0x92, 0x10, 0x98, 0x19, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xd8, 0x12, 0xd9, 0x61, 0xf0, 0x17, 0xd3, 0x20}},\n+\t{ // 24\n+\t\t[]byte{\n+\t\t\t0x10, 0x07, 0x91, 0x15, 0x98, 0x19, 0x01, 0x0b,\n+\t\t\t0x10, 0x07, 0x91, 0x15, 0x98, 0x19, 0x01, 0x0b,\n+\t\t\t0x10, 0x07, 0x91, 0x15, 0x98, 0x19, 0x01, 0x0b,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x05, 0x56, 0x05, 0x81, 0x6e, 0x58, 0x60, 0x8f}},\n+\t{ // 25\n+\t\t[]byte{\n+\t\t\t0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x01,\n+\t\t\t0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x01,\n+\t\t\t0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xab, 0xd8, 0x8e, 0x8b, 0x1b, 0x77, 0x16, 0xf1}},\n+\t{ // 26\n+\t\t[]byte{\n+\t\t\t0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x02,\n+\t\t\t0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x02,\n+\t\t\t0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x02,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x53, 0x7a, 0xc9, 0x5b, 0xe6, 0x9d, 0xa1, 0xe1}},\n+\t{ // 27\n+\t\t[]byte{\n+\t\t\t0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x08,\n+\t\t\t0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x08,\n+\t\t\t0x10, 0x04, 0x80, 0x15, 0x98, 0x19, 0x01, 0x08,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xae, 0xd0, 0xf6, 0xae, 0x3c, 0x25, 0xcd, 0xd8}},\n+\t{ // 28\n+\t\t[]byte{\n+\t\t\t0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x01, 0x04,\n+\t\t\t0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x01, 0x04,\n+\t\t\t0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x01, 0x04,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xb3, 0xe3, 0x5a, 0x5e, 0xe5, 0x3e, 0x7b, 0x8d}},\n+\t{ // 29\n+\t\t[]byte{\n+\t\t\t0x10, 0x02, 0x91, 0x15, 0x98, 0x19, 0x01, 0x04,\n+\t\t\t0x10, 0x02, 0x91, 0x15, 0x98, 0x19, 0x01, 0x04,\n+\t\t\t0x10, 0x02, 0x91, 0x15, 0x98, 0x19, 0x01, 0x04,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x61, 0xc7, 0x9c, 0x71, 0x92, 0x1a, 0x2e, 0xf8}},\n+\t{ // 30\n+\t\t[]byte{\n+\t\t\t0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x02, 0x01,\n+\t\t\t0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x02, 0x01,\n+\t\t\t0x10, 0x02, 0x91, 0x15, 0x98, 0x10, 0x02, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0xe2, 0xf5, 0x72, 0x8f, 0x09, 0x95, 0x01, 0x3c}},\n+\t{ // 31\n+\t\t[]byte{\n+\t\t\t0x10, 0x02, 0x91, 0x16, 0x98, 0x10, 0x01, 0x01,\n+\t\t\t0x10, 0x02, 0x91, 0x16, 0x98, 0x10, 0x01, 0x01,\n+\t\t\t0x10, 0x02, 0x91, 0x16, 0x98, 0x10, 0x01, 0x01,\n+\t\t},\n+\t\tnil,\n+\t\t[]byte{0x1a, 0xea, 0xc3, 0x9a, 0x61, 0xf0, 0xa4, 0x64}},\n+}\n+\n+// Table A.4 Values To Be Used for the Substitution Table Known Answer Test\n+var tableA4Tests = []CryptTest{\n+\t{ // 0\n+\t\t[]byte{\n+\t\t\t0x7c, 0xa1, 0x10, 0x45, 0x4a, 0x1a, 0x6e, 0x57,\n+\t\t\t0x7c, 0xa1, 0x10, 0x45, 0x4a, 0x1a, 0x6e, 0x57,\n+\t\t\t0x7c, 0xa1, 0x10, 0x45, 0x4a, 0x1a, 0x6e, 0x57},\n+\t\t[]byte{0x01, 0xa1, 0xd6, 0xd0, 0x39, 0x77, 0x67, 0x42},\n+\t\t[]byte{0x69, 0x0f, 0x5b, 0x0d, 0x9a, 0x26, 0x93, 0x9b}},\n+\t{ // 1\n+\t\t[]byte{\n+\t\t\t0x01, 0x31, 0xd9, 0x61, 0x9d, 0xc1, 0x37, 0x6e,\n+\t\t\t0x01, 0x31, 0xd9, 0x61, 0x9d, 0xc1, 0x37, 0x6e,\n+\t\t\t0x01, 0x31, 0xd9, 0x61, 0x9d, 0xc1, 0x37, 0x6e},\n+\t\t[]byte{0x5c, 0xd5, 0x4c, 0xa8, 0x3d, 0xef, 0x57, 0xda},\n+\t\t[]byte{0x7a, 0x38, 0x9d, 0x10, 0x35, 0x4b, 0xd2, 0x71}},\n+\t{ // 2\n+\t\t[]byte{\n+\t\t\t0x07, 0xa1, 0x13, 0x3e, 0x4a, 0x0b, 0x26, 0x86,\n+\t\t\t0x07, 0xa1, 0x13, 0x3e, 0x4a, 0x0b, 0x26, 0x86,\n+\t\t\t0x07, 0xa1, 0x13, 0x3e, 0x4a, 0x0b, 0x26, 0x86},\n+\t\t[]byte{0x02, 0x48, 0xd4, 0x38, 0x06, 0xf6, 0x71, 0x72},\n+\t\t[]byte{0x86, 0x8e, 0xbb, 0x51, 0xca, 0xb4, 0x59, 0x9a}},\n+\t{ // 3\n+\t\t[]byte{\n+\t\t\t0x38, 0x49, 0x67, 0x4c, 0x26, 0x02, 0x31, 0x9e,\n+\t\t\t0x38, 0x49, 0x67, 0x4c, 0x26, 0x02, 0x31, 0x9e,\n+\t\t\t0x38, 0x49, 0x67, 0x4c, 0x26, 0x02, 0x31, 0x9e},\n+\t\t[]byte{0x51, 0x45, 0x4b, 0x58, 0x2d, 0xdf, 0x44, 0x0a},\n+\t\t[]byte{0x71, 0x78, 0x87, 0x6e, 0x01, 0xf1, 0x9b, 0x2a}},\n+\t{ // 4\n+\t\t[]byte{\n+\t\t\t0x04, 0xb9, 0x15, 0xba, 0x43, 0xfe, 0xb5, 0xb6,\n+\t\t\t0x04, 0xb9, 0x15, 0xba, 0x43, 0xfe, 0xb5, 0xb6,\n+\t\t\t0x04, 0xb9, 0x15, 0xba, 0x43, 0xfe, 0xb5, 0xb6},\n+\t\t[]byte{0x42, 0xfd, 0x44, 0x30, 0x59, 0x57, 0x7f, 0xa2},\n+\t\t[]byte{0xaf, 0x37, 0xfb, 0x42, 0x1f, 0x8c, 0x40, 0x95}},\n+\t{ // 5\n+\t\t[]byte{\n+\t\t\t0x01, 0x13, 0xb9, 0x70, 0xfd, 0x34, 0xf2, 0xce,\n+\t\t\t0x01, 0x13, 0xb9, 0x70, 0xfd, 0x34, 0xf2, 0xce,\n+\t\t\t0x01, 0x13, 0xb9, 0x70, 0xfd, 0x34, 0xf2, 0xce},\n+\t\t[]byte{0x05, 0x9b, 0x5e, 0x08, 0x51, 0xcf, 0x14, 0x3a},\n+\t\t[]byte{0x86, 0xa5, 0x60, 0xf1, 0x0e, 0xc6, 0xd8, 0x5b}},\n+\t{ // 6\n+\t\t[]byte{\n+\t\t\t0x01, 0x70, 0xf1, 0x75, 0x46, 0x8f, 0xb5, 0xe6,\n+\t\t\t0x01, 0x70, 0xf1, 0x75, 0x46, 0x8f, 0xb5, 0xe6,\n+\t\t\t0x01, 0x70, 0xf1, 0x75, 0x46, 0x8f, 0xb5, 0xe6},\n+\t\t[]byte{0x07, 0x56, 0xd8, 0xe0, 0x77, 0x47, 0x61, 0xd2},\n+\t\t[]byte{0x0c, 0xd3, 0xda, 0x02, 0x00, 0x21, 0xdc, 0x09}},\n+\t{ // 7\n+\t\t[]byte{\n+\t\t\t0x43, 0x29, 0x7f, 0xad, 0x38, 0xe3, 0x73, 0xfe,\n+\t\t\t0x43, 0x29, 0x7f, 0xad, 0x38, 0xe3, 0x73, 0xfe,\n+\t\t\t0x43, 0x29, 0x7f, 0xad, 0x38, 0xe3, 0x73, 0xfe},\n+\t\t[]byte{0x76, 0x25, 0x14, 0xb8, 0x29, 0xbf, 0x48, 0x6a},\n+\t\t[]byte{0xea, 0x67, 0x6b, 0x2c, 0xb7, 0xdb, 0x2b, 0x7a}},\n+\t{ // 8\n+\t\t[]byte{\n+\t\t\t0x07, 0xa7, 0x13, 0x70, 0x45, 0xda, 0x2a, 0x16,\n+\t\t\t0x07, 0xa7, 0x13, 0x70, 0x45, 0xda, 0x2a, 0x16,\n+\t\t\t0x07, 0xa7, 0x13, 0x70, 0x45, 0xda, 0x2a, 0x16},\n+\t\t[]byte{0x3b, 0xdd, 0x11, 0x90, 0x49, 0x37, 0x28, 0x02},\n+\t\t[]byte{0xdf, 0xd6, 0x4a, 0x81, 0x5c, 0xaf, 0x1a, 0x0f}},\n+\t{ // 9\n+\t\t[]byte{\n+\t\t\t0x04, 0x68, 0x91, 0x04, 0xc2, 0xfd, 0x3b, 0x2f,\n+\t\t\t0x04, 0x68, 0x91, 0x04, 0xc2, 0xfd, 0x3b, 0x2f,\n+\t\t\t0x04, 0x68, 0x91, 0x04, 0xc2, 0xfd, 0x3b, 0x2f},\n+\t\t[]byte{0x26, 0x95, 0x5f, 0x68, 0x35, 0xaf, 0x60, 0x9a},\n+\t\t[]byte{0x5c, 0x51, 0x3c, 0x9c, 0x48, 0x86, 0xc0, 0x88}},\n+\t{ // 10\n+\t\t[]byte{\n+\t\t\t0x37, 0xd0, 0x6b, 0xb5, 0x16, 0xcb, 0x75, 0x46,\n+\t\t\t0x37, 0xd0, 0x6b, 0xb5, 0x16, 0xcb, 0x75, 0x46,\n+\t\t\t0x37, 0xd0, 0x6b, 0xb5, 0x16, 0xcb, 0x75, 0x46},\n+\t\t[]byte{0x16, 0x4d, 0x5e, 0x40, 0x4f, 0x27, 0x52, 0x32},\n+\t\t[]byte{0x0a, 0x2a, 0xee, 0xae, 0x3f, 0xf4, 0xab, 0x77}},\n+\t{ // 11\n+\t\t[]byte{\n+\t\t\t0x1f, 0x08, 0x26, 0x0d, 0x1a, 0xc2, 0x46, 0x5e,\n+\t\t\t0x1f, 0x08, 0x26, 0x0d, 0x1a, 0xc2, 0x46, 0x5e,\n+\t\t\t0x1f, 0x08, 0x26, 0x0d, 0x1a, 0xc2, 0x46, 0x5e},\n+\t\t[]byte{0x6b, 0x05, 0x6e, 0x18, 0x75, 0x9f, 0x5c, 0xca},\n+\t\t[]byte{0xef, 0x1b, 0xf0, 0x3e, 0x5d, 0xfa, 0x57, 0x5a}},\n+\t{ // 12\n+\t\t[]byte{\n+\t\t\t0x58, 0x40, 0x23, 0x64, 0x1a, 0xba, 0x61, 0x76,\n+\t\t\t0x58, 0x40, 0x23, 0x64, 0x1a, 0xba, 0x61, 0x76,\n+\t\t\t0x58, 0x40, 0x23, 0x64, 0x1a, 0xba, 0x61, 0x76},\n+\t\t[]byte{0x00, 0x4b, 0xd6, 0xef, 0x09, 0x17, 0x60, 0x62},\n+\t\t[]byte{0x88, 0xbf, 0x0d, 0xb6, 0xd7, 0x0d, 0xee, 0x56}},\n+\t{ // 13\n+\t\t[]byte{\n+\t\t\t0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xb0, 0x07,\n+\t\t\t0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xb0, 0x07,\n+\t\t\t0x02, 0x58, 0x16, 0x16, 0x46, 0x29, 0xb0, 0x07},\n+\t\t[]byte{0x48, 0x0d, 0x39, 0x00, 0x6e, 0xe7, 0x62, 0xf2},\n+\t\t[]byte{0xa1, 0xf9, 0x91, 0x55, 0x41, 0x02, 0x0b, 0x56}},\n+\t{ // 14\n+\t\t[]byte{\n+\t\t\t0x49, 0x79, 0x3e, 0xbc, 0x79, 0xb3, 0x25, 0x8f,\n+\t\t\t0x49, 0x79, 0x3e, 0xbc, 0x79, 0xb3, 0x25, 0x8f,\n+\t\t\t0x49, 0x79, 0x3e, 0xbc, 0x79, 0xb3, 0x25, 0x8f},\n+\t\t[]byte{0x43, 0x75, 0x40, 0xc8, 0x69, 0x8f, 0x3c, 0xfa},\n+\t\t[]byte{0x6f, 0xbf, 0x1c, 0xaf, 0xcf, 0xfd, 0x05, 0x56}},\n+\t{ // 15\n+\t\t[]byte{\n+\t\t\t0x4f, 0xb0, 0x5e, 0x15, 0x15, 0xab, 0x73, 0xa7,\n+\t\t\t0x4f, 0xb0, 0x5e, 0x15, 0x15, 0xab, 0x73, 0xa7,\n+\t\t\t0x4f, 0xb0, 0x5e, 0x15, 0x15, 0xab, 0x73, 0xa7},\n+\t\t[]byte{0x07, 0x2d, 0x43, 0xa0, 0x77, 0x07, 0x52, 0x92},\n+\t\t[]byte{0x2f, 0x22, 0xe4, 0x9b, 0xab, 0x7c, 0xa1, 0xac}},\n+\t{ // 16\n+\t\t[]byte{\n+\t\t\t0x49, 0xe9, 0x5d, 0x6d, 0x4c, 0xa2, 0x29, 0xbf,\n+\t\t\t0x49, 0xe9, 0x5d, 0x6d, 0x4c, 0xa2, 0x29, 0xbf,\n+\t\t\t0x49, 0xe9, 0x5d, 0x6d, 0x4c, 0xa2, 0x29, 0xbf},\n+\t\t[]byte{0x02, 0xfe, 0x55, 0x77, 0x81, 0x17, 0xf1, 0x2a},\n+\t\t[]byte{0x5a, 0x6b, 0x61, 0x2c, 0xc2, 0x6c, 0xce, 0x4a}},\n+\t{ // 17\n+\t\t[]byte{\n+\t\t\t0x01, 0x83, 0x10, 0xdc, 0x40, 0x9b, 0x26, 0xd6,\n+\t\t\t0x01, 0x83, 0x10, 0xdc, 0x40, 0x9b, 0x26, 0xd6,\n+\t\t\t0x01, 0x83, 0x10, 0xdc, 0x40, 0x9b, 0x26, 0xd6},\n+\t\t[]byte{0x1d, 0x9d, 0x5c, 0x50, 0x18, 0xf7, 0x28, 0xc2},\n+\t\t[]byte{0x5f, 0x4c, 0x03, 0x8e, 0xd1, 0x2b, 0x2e, 0x41}},\n+\t{ // 18\n+\t\t[]byte{\n+\t\t\t0x1c, 0x58, 0x7f, 0x1c, 0x13, 0x92, 0x4f, 0xef,\n+\t\t\t0x1c, 0x58, 0x7f, 0x1c, 0x13, 0x92, 0x4f, 0xef,\n+\t\t\t0x1c, 0x58, 0x7f, 0x1c, 0x13, 0x92, 0x4f, 0xef},\n+\t\t[]byte{0x30, 0x55, 0x32, 0x28, 0x6d, 0x6f, 0x29, 0x5a},\n+\t\t[]byte{0x63, 0xfa, 0xc0, 0xd0, 0x34, 0xd9, 0xf7, 0x93}},\n+}\n+\n+// Use the known weak keys to test DES implementation\n+func TestWeakKeys(t *testing.T) {\n+\tfor i, tt := range weakKeyTests {\n+\t\tvar encrypt = func(in []byte) (out []byte) {\n+\t\t\tc, _ := NewCipher(tt.key)\n+\t\t\tout = make([]byte, len(in))\n+\t\t\tencryptBlock(c.subkeys[:], out, in)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Encrypting twice with a DES weak\n+\t\t// key should reproduce the original input\n+\t\tresult := encrypt(tt.in)\n+\t\tresult = encrypt(result)\n+\n+\t\tif !bytes.Equal(result, tt.in) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, result, tt.in)\n+\t\t}\n+\t}\n+}\n+\n+// Use the known semi-weak key pairs to test DES implementation\n+func TestSemiWeakKeyPairs(t *testing.T) {\n+\tfor i, tt := range semiWeakKeyTests {\n+\t\tvar encrypt = func(key, in []byte) (out []byte) {\n+\t\t\tc, _ := NewCipher(key)\n+\t\t\tout = make([]byte, len(in))\n+\t\t\tencryptBlock(c.subkeys[:], out, in)\n+\t\t\treturn\n+\t\t}\n+\n+\t\t// Encrypting with one member of the semi-weak pair\n+\t\t// and then encrypting the result with the other member\n+\t\t// should reproduce the original input.\n+\t\tresult := encrypt(tt.key, tt.in)\n+\t\tresult = encrypt(tt.out, result)\n+\n+\t\tif !bytes.Equal(result, tt.in) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, result, tt.in)\n+\t\t}\n+\t}\n+}\n+\n+func TestDESEncryptBlock(t *testing.T) {\n+\tfor i, tt := range encryptDESTests {\n+\t\tc, _ := NewCipher(tt.key)\n+\t\tout := make([]byte, len(tt.in))\n+\t\tencryptBlock(c.subkeys[:], out, tt.in)\n+\n+\t\tif !bytes.Equal(out, tt.out) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, out, tt.out)\n+\t\t}\n+\t}\n+}\n+\n+func TestDESDecryptBlock(t *testing.T) {\n+\tfor i, tt := range encryptDESTests {\n+\t\tc, _ := NewCipher(tt.key)\n+\t\tplain := make([]byte, len(tt.in))\n+\t\tdecryptBlock(c.subkeys[:], plain, tt.out)\n+\n+\t\tif !bytes.Equal(plain, tt.in) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, plain, tt.in)\n+\t\t}\n+\t}\n+}\n+\n+func TestEncryptTripleDES(t *testing.T) {\n+\tfor i, tt := range encryptTripleDESTests {\n+\t\tc, _ := NewTripleDESCipher(tt.key)\n+\t\tout := make([]byte, len(tt.in))\n+\t\tc.Encrypt(out, tt.in)\n+\n+\t\tif !bytes.Equal(out, tt.out) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, out, tt.out)\n+\t\t}\n+\t}\n+}\n+\n+func TestDecryptTripleDES(t *testing.T) {\n+\tfor i, tt := range encryptTripleDESTests {\n+\t\tc, _ := NewTripleDESCipher(tt.key)\n+\n+\t\tplain := make([]byte, len(tt.in))\n+\t\tc.Decrypt(plain, tt.out)\n+\n+\t\tif !bytes.Equal(plain, tt.in) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, plain, tt.in)\n+\t\t}\n+\t}\n+}\n+\n+// Defined in Pub 800-20\n+func TestVariablePlaintextKnownAnswer(t *testing.T) {\n+\tfor i, tt := range tableA1Tests {\n+\t\tc, _ := NewTripleDESCipher(tableA1Key)\n+\n+\t\tout := make([]byte, len(tt.in))\n+\t\tc.Encrypt(out, tt.in)\n+\n+\t\tif !bytes.Equal(out, tt.out) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, out, tt.out)\n+\t\t}\n+\t}\n+}\n+\n+// Defined in Pub 800-20\n+func TestVariableCiphertextKnownAnswer(t *testing.T) {\n+\tfor i, tt := range tableA1Tests {\n+\t\tc, _ := NewTripleDESCipher(tableA1Key)\n+\n+\t\tplain := make([]byte, len(tt.out))\n+\t\tc.Decrypt(plain, tt.out)\n+\n+\t\tif !bytes.Equal(plain, tt.in) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, plain, tt.in)\n+\t\t}\n+\t}\n+}\n+\n+// Defined in Pub 800-20\n+// Encrypting the Table A.1 ciphertext with the\n+// 0x01... key produces the original plaintext\n+func TestInversePermutationKnownAnswer(t *testing.T) {\n+\tfor i, tt := range tableA1Tests {\n+\t\tc, _ := NewTripleDESCipher(tableA1Key)\n+\n+\t\tplain := make([]byte, len(tt.in))\n+\t\tc.Encrypt(plain, tt.out)\n+\n+\t\tif !bytes.Equal(plain, tt.in) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, plain, tt.in)\n+\t\t}\n+\t}\n+}\n+\n+// Defined in Pub 800-20\n+// Decrypting the Table A.1 plaintext with the\n+// 0x01... key produces the corresponding ciphertext\n+func TestInitialPermutationKnownAnswer(t *testing.T) {\n+\tfor i, tt := range tableA1Tests {\n+\t\tc, _ := NewTripleDESCipher(tableA1Key)\n+\n+\t\tout := make([]byte, len(tt.in))\n+\t\tc.Decrypt(out, tt.in)\n+\n+\t\tif !bytes.Equal(out, tt.out) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, out, tt.out)\n+\t\t}\n+\t}\n+}\n+\n+// Defined in Pub 800-20\n+func TestVariableKeyKnownAnswerEncrypt(t *testing.T) {\n+\tfor i, tt := range tableA2Tests {\n+\t\tc, _ := NewTripleDESCipher(tt.key)\n+\n+\t\tout := make([]byte, len(tableA2Plaintext))\n+\t\tc.Encrypt(out, tableA2Plaintext)\n+\n+\t\tif !bytes.Equal(out, tt.out) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, out, tt.out)\n+\t\t}\n+\t}\n+}\n+\n+// Defined in Pub 800-20\n+func TestVariableKeyKnownAnswerDecrypt(t *testing.T) {\n+\tfor i, tt := range tableA2Tests {\n+\t\tc, _ := NewTripleDESCipher(tt.key)\n+\n+\t\tout := make([]byte, len(tt.out))\n+\t\tc.Decrypt(out, tt.out)\n+\n+\t\tif !bytes.Equal(out, tableA2Plaintext) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, out, tableA2Plaintext)\n+\t\t}\n+\t}\n+}\n+\n+// Defined in Pub 800-20\n+func TestPermutationOperationKnownAnswerEncrypt(t *testing.T) {\n+\tfor i, tt := range tableA3Tests {\n+\t\tc, _ := NewTripleDESCipher(tt.key)\n+\n+\t\tout := make([]byte, len(tableA3Plaintext))\n+\t\tc.Encrypt(out, tableA3Plaintext)\n+\n+\t\tif !bytes.Equal(out, tt.out) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, out, tt.out)\n+\t\t}\n+\t}\n+}\n+\n+// Defined in Pub 800-20\n+func TestPermutationOperationKnownAnswerDecrypt(t *testing.T) {\n+\tfor i, tt := range tableA3Tests {\n+\t\tc, _ := NewTripleDESCipher(tt.key)\n+\n+\t\tout := make([]byte, len(tt.out))\n+\t\tc.Decrypt(out, tt.out)\n+\n+\t\tif !bytes.Equal(out, tableA3Plaintext) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, out, tableA3Plaintext)\n+\t\t}\n+\t}\n+}\n+\n+// Defined in Pub 800-20\n+func TestSubstitutionTableKnownAnswerEncrypt(t *testing.T) {\n+\tfor i, tt := range tableA4Tests {\n+\t\tc, _ := NewTripleDESCipher(tt.key)\n+\n+\t\tout := make([]byte, len(tt.in))\n+\t\tc.Encrypt(out, tt.in)\n+\n+\t\tif !bytes.Equal(out, tt.out) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, out, tt.out)\n+\t\t}\n+\t}\n+}\n+\n+// Defined in Pub 800-20\n+func TestSubstitutionTableKnownAnswerDecrypt(t *testing.T) {\n+\tfor i, tt := range tableA4Tests {\n+\t\tc, _ := NewTripleDESCipher(tt.key)\n+\n+\t\tout := make([]byte, len(tt.out))\n+\t\tc.Decrypt(out, tt.out)\n+\n+\t\tif !bytes.Equal(out, tt.in) {\n+\t\t\tt.Errorf(\"#%d: result: %x want: %x\", i, out, tt.in)\n+\t\t}\n+\t}\n+}"}, {"sha": "7bce1bc967538102504bba204ec6d9a5b0017ddf", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -37,7 +37,7 @@ var one = new(big.Int).SetInt64(1)\n // curve using the procedure given in [NSA] A.2.1.\n func randFieldElement(c *elliptic.Curve, rand io.Reader) (k *big.Int, err os.Error) {\n \tb := make([]byte, c.BitSize/8+8)\n-\t_, err = rand.Read(b)\n+\t_, err = io.ReadFull(rand, b)\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "3a06aa8b148954a4301d47084391de05de94291a", "filename": "libgo/go/crypto/rand/rand_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frand%2Frand_unix.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -32,7 +32,7 @@ func (r *devReader) Read(b []byte) (n int, err os.Error) {\n \tr.mu.Lock()\n \tdefer r.mu.Unlock()\n \tif r.f == nil {\n-\t\tf, err := os.Open(r.name, os.O_RDONLY, 0)\n+\t\tf, err := os.Open(r.name)\n \t\tif f == nil {\n \t\t\treturn 0, err\n \t\t}"}, {"sha": "9a7184127db0689533a87351623524ee50b75eef", "filename": "libgo/go/crypto/rsa/pkcs1v15.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Fpkcs1v15.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -127,7 +127,7 @@ func nonZeroRandomBytes(s []byte, rand io.Reader) (err os.Error) {\n \n \tfor i := 0; i < len(s); i++ {\n \t\tfor s[i] == 0 {\n-\t\t\t_, err = rand.Read(s[i : i+1])\n+\t\t\t_, err = io.ReadFull(rand, s[i:i+1])\n \t\t\tif err != nil {\n \t\t\t\treturn\n \t\t\t}"}, {"sha": "b3b212c2066ca9bb0f4e4cb884f947a646047a8b", "filename": "libgo/go/crypto/rsa/rsa.go", "status": "modified", "additions": 158, "deletions": 9, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -13,6 +13,7 @@ import (\n \t\"hash\"\n \t\"io\"\n \t\"os\"\n+\t\"sync\"\n )\n \n var bigZero = big.NewInt(0)\n@@ -91,15 +92,21 @@ type PublicKey struct {\n type PrivateKey struct {\n \tPublicKey          // public part.\n \tD         *big.Int // private exponent\n-\tP, Q      *big.Int // prime factors of N\n+\tP, Q, R   *big.Int // prime factors of N (R may be nil)\n+\n+\trwMutex    sync.RWMutex // protects the following\n+\tdP, dQ, dR *big.Int     // D mod (P-1) (or mod Q-1 etc) \n+\tqInv       *big.Int     // q^-1 mod p\n+\tpq         *big.Int     // P*Q\n+\ttr         *big.Int     // pq\u00b7tr \u2261 1 mod r\n }\n \n // Validate performs basic sanity checks on the key.\n // It returns nil if the key is valid, or else an os.Error describing a problem.\n \n-func (priv PrivateKey) Validate() os.Error {\n-\t// Check that p and q are prime. Note that this is just a sanity\n-\t// check. Since the random witnesses chosen by ProbablyPrime are\n+func (priv *PrivateKey) Validate() os.Error {\n+\t// Check that p, q and, maybe, r are prime. Note that this is just a\n+\t// sanity check. Since the random witnesses chosen by ProbablyPrime are\n \t// deterministic, given the candidate number, it's easy for an attack\n \t// to generate composites that pass this test.\n \tif !big.ProbablyPrime(priv.P, 20) {\n@@ -108,16 +115,26 @@ func (priv PrivateKey) Validate() os.Error {\n \tif !big.ProbablyPrime(priv.Q, 20) {\n \t\treturn os.ErrorString(\"Q is composite\")\n \t}\n+\tif priv.R != nil && !big.ProbablyPrime(priv.R, 20) {\n+\t\treturn os.ErrorString(\"R is composite\")\n+\t}\n \n-\t// Check that p*q == n.\n+\t// Check that p*q*r == n.\n \tmodulus := new(big.Int).Mul(priv.P, priv.Q)\n+\tif priv.R != nil {\n+\t\tmodulus.Mul(modulus, priv.R)\n+\t}\n \tif modulus.Cmp(priv.N) != 0 {\n \t\treturn os.ErrorString(\"invalid modulus\")\n \t}\n-\t// Check that e and totient(p, q) are coprime.\n+\t// Check that e and totient(p, q, r) are coprime.\n \tpminus1 := new(big.Int).Sub(priv.P, bigOne)\n \tqminus1 := new(big.Int).Sub(priv.Q, bigOne)\n \ttotient := new(big.Int).Mul(pminus1, qminus1)\n+\tif priv.R != nil {\n+\t\trminus1 := new(big.Int).Sub(priv.R, bigOne)\n+\t\ttotient.Mul(totient, rminus1)\n+\t}\n \te := big.NewInt(int64(priv.E))\n \tgcd := new(big.Int)\n \tx := new(big.Int)\n@@ -126,7 +143,7 @@ func (priv PrivateKey) Validate() os.Error {\n \tif gcd.Cmp(bigOne) != 0 {\n \t\treturn os.ErrorString(\"invalid public exponent E\")\n \t}\n-\t// Check that de \u2261 1 (mod totient(p, q))\n+\t// Check that de \u2261 1 (mod totient(p, q, r))\n \tde := new(big.Int).Mul(priv.D, e)\n \tde.Mod(de, totient)\n \tif de.Cmp(bigOne) != 0 {\n@@ -135,7 +152,7 @@ func (priv PrivateKey) Validate() os.Error {\n \treturn nil\n }\n \n-// GenerateKeyPair generates an RSA keypair of the given bit size.\n+// GenerateKey generates an RSA keypair of the given bit size.\n func GenerateKey(rand io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n \tpriv = new(PrivateKey)\n \t// Smaller public exponents lead to faster public key\n@@ -191,6 +208,77 @@ func GenerateKey(rand io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n \treturn\n }\n \n+// Generate3PrimeKey generates a 3-prime RSA keypair of the given bit size, as\n+// suggested in [1]. Although the public keys are compatible (actually,\n+// indistinguishable) from the 2-prime case, the private keys are not. Thus it\n+// may not be possible to export 3-prime private keys in certain formats or to\n+// subsequently import them into other code.\n+//\n+// Table 1 in [2] suggests that size should be >= 1024 when using 3 primes.\n+//\n+// [1] US patent 4405829 (1972, expired)\n+// [2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n+func Generate3PrimeKey(rand io.Reader, bits int) (priv *PrivateKey, err os.Error) {\n+\tpriv = new(PrivateKey)\n+\tpriv.E = 3\n+\n+\tpminus1 := new(big.Int)\n+\tqminus1 := new(big.Int)\n+\trminus1 := new(big.Int)\n+\ttotient := new(big.Int)\n+\n+\tfor {\n+\t\tp, err := randomPrime(rand, bits/3)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\ttodo := bits - p.BitLen()\n+\t\tq, err := randomPrime(rand, todo/2)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\ttodo -= q.BitLen()\n+\t\tr, err := randomPrime(rand, todo)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\n+\t\tif p.Cmp(q) == 0 ||\n+\t\t\tq.Cmp(r) == 0 ||\n+\t\t\tr.Cmp(p) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tn := new(big.Int).Mul(p, q)\n+\t\tn.Mul(n, r)\n+\t\tpminus1.Sub(p, bigOne)\n+\t\tqminus1.Sub(q, bigOne)\n+\t\trminus1.Sub(r, bigOne)\n+\t\ttotient.Mul(pminus1, qminus1)\n+\t\ttotient.Mul(totient, rminus1)\n+\n+\t\tg := new(big.Int)\n+\t\tpriv.D = new(big.Int)\n+\t\ty := new(big.Int)\n+\t\te := big.NewInt(int64(priv.E))\n+\t\tbig.GcdInt(g, priv.D, y, e, totient)\n+\n+\t\tif g.Cmp(bigOne) == 0 {\n+\t\t\tpriv.D.Add(priv.D, totient)\n+\t\t\tpriv.P = p\n+\t\t\tpriv.Q = q\n+\t\t\tpriv.R = r\n+\t\t\tpriv.N = n\n+\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn\n+}\n+\n // incCounter increments a four byte, big-endian counter.\n func incCounter(c *[4]byte) {\n \tif c[3]++; c[3] != 0 {\n@@ -321,6 +409,26 @@ func modInverse(a, n *big.Int) (ia *big.Int, ok bool) {\n \treturn x, true\n }\n \n+// precompute performs some calculations that speed up private key operations\n+// in the future.\n+func (priv *PrivateKey) precompute() {\n+\tpriv.dP = new(big.Int).Sub(priv.P, bigOne)\n+\tpriv.dP.Mod(priv.D, priv.dP)\n+\n+\tpriv.dQ = new(big.Int).Sub(priv.Q, bigOne)\n+\tpriv.dQ.Mod(priv.D, priv.dQ)\n+\n+\tpriv.qInv = new(big.Int).ModInverse(priv.Q, priv.P)\n+\n+\tif priv.R != nil {\n+\t\tpriv.dR = new(big.Int).Sub(priv.R, bigOne)\n+\t\tpriv.dR.Mod(priv.D, priv.dR)\n+\n+\t\tpriv.pq = new(big.Int).Mul(priv.P, priv.Q)\n+\t\tpriv.tr = new(big.Int).ModInverse(priv.pq, priv.R)\n+\t}\n+}\n+\n // decrypt performs an RSA decryption, resulting in a plaintext integer. If a\n // random source is given, RSA blinding is used.\n func decrypt(rand io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err os.Error) {\n@@ -359,7 +467,48 @@ func decrypt(rand io.Reader, priv *PrivateKey, c *big.Int) (m *big.Int, err os.E\n \t\tc.Mod(c, priv.N)\n \t}\n \n-\tm = new(big.Int).Exp(c, priv.D, priv.N)\n+\tpriv.rwMutex.RLock()\n+\n+\tif priv.dP == nil && priv.P != nil {\n+\t\tpriv.rwMutex.RUnlock()\n+\t\tpriv.rwMutex.Lock()\n+\t\tif priv.dP == nil && priv.P != nil {\n+\t\t\tpriv.precompute()\n+\t\t}\n+\t\tpriv.rwMutex.Unlock()\n+\t\tpriv.rwMutex.RLock()\n+\t}\n+\n+\tif priv.dP == nil {\n+\t\tm = new(big.Int).Exp(c, priv.D, priv.N)\n+\t} else {\n+\t\t// We have the precalculated values needed for the CRT.\n+\t\tm = new(big.Int).Exp(c, priv.dP, priv.P)\n+\t\tm2 := new(big.Int).Exp(c, priv.dQ, priv.Q)\n+\t\tm.Sub(m, m2)\n+\t\tif m.Sign() < 0 {\n+\t\t\tm.Add(m, priv.P)\n+\t\t}\n+\t\tm.Mul(m, priv.qInv)\n+\t\tm.Mod(m, priv.P)\n+\t\tm.Mul(m, priv.Q)\n+\t\tm.Add(m, m2)\n+\n+\t\tif priv.dR != nil {\n+\t\t\t// 3-prime CRT.\n+\t\t\tm2.Exp(c, priv.dR, priv.R)\n+\t\t\tm2.Sub(m2, m)\n+\t\t\tm2.Mul(m2, priv.tr)\n+\t\t\tm2.Mod(m2, priv.R)\n+\t\t\tif m2.Sign() < 0 {\n+\t\t\t\tm2.Add(m2, priv.R)\n+\t\t\t}\n+\t\t\tm2.Mul(m2, priv.pq)\n+\t\t\tm.Add(m, m2)\n+\t\t}\n+\t}\n+\n+\tpriv.rwMutex.RUnlock()\n \n \tif ir != nil {\n \t\t// Unblind."}, {"sha": "d8a936eb68f03739abd511360e4d0145e14677a1", "filename": "libgo/go/crypto/rsa/rsa_test.go", "status": "modified", "additions": 81, "deletions": 8, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Frsa%2Frsa_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -13,28 +13,48 @@ import (\n )\n \n func TestKeyGeneration(t *testing.T) {\n-\trandom := rand.Reader\n-\n \tsize := 1024\n \tif testing.Short() {\n \t\tsize = 128\n \t}\n-\tpriv, err := GenerateKey(random, size)\n+\tpriv, err := GenerateKey(rand.Reader, size)\n+\tif err != nil {\n+\t\tt.Errorf(\"failed to generate key\")\n+\t}\n+\ttestKeyBasics(t, priv)\n+}\n+\n+func Test3PrimeKeyGeneration(t *testing.T) {\n+\tif testing.Short() {\n+\t\treturn\n+\t}\n+\n+\tsize := 768\n+\tpriv, err := Generate3PrimeKey(rand.Reader, size)\n \tif err != nil {\n \t\tt.Errorf(\"failed to generate key\")\n \t}\n+\ttestKeyBasics(t, priv)\n+}\n+\n+func testKeyBasics(t *testing.T, priv *PrivateKey) {\n+\tif err := priv.Validate(); err != nil {\n+\t\tt.Errorf(\"Validate() failed: %s\", err)\n+\t}\n+\n \tpub := &priv.PublicKey\n \tm := big.NewInt(42)\n \tc := encrypt(new(big.Int), pub, m)\n \tm2, err := decrypt(nil, priv, c)\n \tif err != nil {\n \t\tt.Errorf(\"error while decrypting: %s\", err)\n+\t\treturn\n \t}\n \tif m.Cmp(m2) != 0 {\n-\t\tt.Errorf(\"got:%v, want:%v (%s)\", m2, m, priv)\n+\t\tt.Errorf(\"got:%v, want:%v (%+v)\", m2, m, priv)\n \t}\n \n-\tm3, err := decrypt(random, priv, c)\n+\tm3, err := decrypt(rand.Reader, priv, c)\n \tif err != nil {\n \t\tt.Errorf(\"error while decrypting (blind): %s\", err)\n \t}\n@@ -43,6 +63,57 @@ func TestKeyGeneration(t *testing.T) {\n \t}\n }\n \n+func fromBase10(base10 string) *big.Int {\n+\ti := new(big.Int)\n+\ti.SetString(base10, 10)\n+\treturn i\n+}\n+\n+func BenchmarkRSA2048Decrypt(b *testing.B) {\n+\tb.StopTimer()\n+\tpriv := &PrivateKey{\n+\t\tPublicKey: PublicKey{\n+\t\t\tN: fromBase10(\"14314132931241006650998084889274020608918049032671858325988396851334124245188214251956198731333464217832226406088020736932173064754214329009979944037640912127943488972644697423190955557435910767690712778463524983667852819010259499695177313115447116110358524558307947613422897787329221478860907963827160223559690523660574329011927531289655711860504630573766609239332569210831325633840174683944553667352219670930408593321661375473885147973879086994006440025257225431977751512374815915392249179976902953721486040787792801849818254465486633791826766873076617116727073077821584676715609985777563958286637185868165868520557\"),\n+\t\t\tE: 3,\n+\t\t},\n+\t\tD: fromBase10(\"9542755287494004433998723259516013739278699355114572217325597900889416163458809501304132487555642811888150937392013824621448709836142886006653296025093941418628992648429798282127303704957273845127141852309016655778568546006839666463451542076964744073572349705538631742281931858219480985907271975884773482372966847639853897890615456605598071088189838676728836833012254065983259638538107719766738032720239892094196108713378822882383694456030043492571063441943847195939549773271694647657549658603365629458610273821292232646334717612674519997533901052790334279661754176490593041941863932308687197618671528035670452762731\"),\n+\t\tP: fromBase10(\"130903255182996722426771613606077755295583329135067340152947172868415809027537376306193179624298874215608270802054347609836776473930072411958753044562214537013874103802006369634761074377213995983876788718033850153719421695468704276694983032644416930879093914927146648402139231293035971427838068945045019075433\"),\n+\t\tQ: fromBase10(\"109348945610485453577574767652527472924289229538286649661240938988020367005475727988253438647560958573506159449538793540472829815903949343191091817779240101054552748665267574271163617694640513549693841337820602726596756351006149518830932261246698766355347898158548465400674856021497190430791824869615170301029\"),\n+\t}\n+\tpriv.precompute()\n+\n+\tc := fromBase10(\"1000\")\n+\n+\tb.StartTimer()\n+\n+\tfor i := 0; i < b.N; i++ {\n+\t\tdecrypt(nil, priv, c)\n+\t}\n+}\n+\n+func Benchmark3PrimeRSA2048Decrypt(b *testing.B) {\n+\tb.StopTimer()\n+\tpriv := &PrivateKey{\n+\t\tPublicKey: PublicKey{\n+\t\t\tN: fromBase10(\"16346378922382193400538269749936049106320265317511766357599732575277382844051791096569333808598921852351577762718529818072849191122419410612033592401403764925096136759934497687765453905884149505175426053037420486697072448609022753683683718057795566811401938833367954642951433473337066311978821180526439641496973296037000052546108507805269279414789035461158073156772151892452251106173507240488993608650881929629163465099476849643165682709047462010581308719577053905787496296934240246311806555924593059995202856826239801816771116902778517096212527979497399966526283516447337775509777558018145573127308919204297111496233\"),\n+\t\t\tE: 3,\n+\t\t},\n+\t\tD: fromBase10(\"10897585948254795600358846499957366070880176878341177571733155050184921896034527397712889205732614568234385175145686545381899460748279607074689061600935843283397424506622998458510302603922766336783617368686090042765718290914099334449154829375179958369993407724946186243249568928237086215759259909861748642124071874879861299389874230489928271621259294894142840428407196932444474088857746123104978617098858619445675532587787023228852383149557470077802718705420275739737958953794088728369933811184572620857678792001136676902250566845618813972833750098806496641114644760255910789397593428910198080271317419213080834885003\"),\n+\t\tP: fromBase10(\"1025363189502892836833747188838978207017355117492483312747347695538428729137306368764177201532277413433182799108299960196606011786562992097313508180436744488171474690412562218914213688661311117337381958560443\"),\n+\t\tQ: fromBase10(\"3467903426626310123395340254094941045497208049900750380025518552334536945536837294961497712862519984786362199788654739924501424784631315081391467293694361474867825728031147665777546570788493758372218019373\"),\n+\t\tR: fromBase10(\"4597024781409332673052708605078359346966325141767460991205742124888960305710298765592730135879076084498363772408626791576005136245060321874472727132746643162385746062759369754202494417496879741537284589047\"),\n+\t}\n+\tpriv.precompute()\n+\n+\tc := fromBase10(\"1000\")\n+\n+\tb.StartTimer()\n+\n+\tfor i := 0; i < b.N; i++ {\n+\t\tdecrypt(nil, priv, c)\n+\t}\n+}\n+\n type testEncryptOAEPMessage struct {\n \tin   []byte\n \tseed []byte\n@@ -85,18 +156,20 @@ func TestDecryptOAEP(t *testing.T) {\n \tfor i, test := range testEncryptOAEPData {\n \t\tn.SetString(test.modulus, 16)\n \t\td.SetString(test.d, 16)\n-\t\tprivate := PrivateKey{PublicKey{n, test.e}, d, nil, nil}\n+\t\tprivate := new(PrivateKey)\n+\t\tprivate.PublicKey = PublicKey{n, test.e}\n+\t\tprivate.D = d\n \n \t\tfor j, message := range test.msgs {\n-\t\t\tout, err := DecryptOAEP(sha1, nil, &private, message.out, nil)\n+\t\t\tout, err := DecryptOAEP(sha1, nil, private, message.out, nil)\n \t\t\tif err != nil {\n \t\t\t\tt.Errorf(\"#%d,%d error: %s\", i, j, err)\n \t\t\t} else if bytes.Compare(out, message.in) != 0 {\n \t\t\t\tt.Errorf(\"#%d,%d bad result: %#v (want %#v)\", i, j, out, message.in)\n \t\t\t}\n \n \t\t\t// Decrypt with blinding.\n-\t\t\tout, err = DecryptOAEP(sha1, random, &private, message.out, nil)\n+\t\t\tout, err = DecryptOAEP(sha1, random, private, message.out, nil)\n \t\t\tif err != nil {\n \t\t\t\tt.Errorf(\"#%d,%d (blind) error: %s\", i, j, err)\n \t\t\t} else if bytes.Compare(out, message.in) != 0 {"}, {"sha": "5b8c700e5f909bf949280d1f2f2187ede8ae1dbb", "filename": "libgo/go/crypto/tls/generate_cert.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -50,7 +50,7 @@ func main() {\n \t\treturn\n \t}\n \n-\tcertOut, err := os.Open(\"cert.pem\", os.O_WRONLY|os.O_CREAT, 0644)\n+\tcertOut, err := os.Create(\"cert.pem\")\n \tif err != nil {\n \t\tlog.Fatalf(\"failed to open cert.pem for writing: %s\", err)\n \t\treturn\n@@ -59,7 +59,7 @@ func main() {\n \tcertOut.Close()\n \tlog.Print(\"written cert.pem\\n\")\n \n-\tkeyOut, err := os.Open(\"key.pem\", os.O_WRONLY|os.O_CREAT, 0600)\n+\tkeyOut, err := os.OpenFile(\"key.pem\", os.O_WRONLY|os.O_CREAT|os.O_TRUNC, 0600)\n \tif err != nil {\n \t\tlog.Print(\"failed to open key.pem for writing:\", err)\n \t\treturn"}, {"sha": "7de44bbd244df80afe6451ef0d8754e22e60f4d7", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -124,7 +124,16 @@ func LoadX509KeyPair(certFile string, keyFile string) (cert Certificate, err os.\n \tif err != nil {\n \t\treturn\n \t}\n+\tkeyPEMBlock, err := ioutil.ReadFile(keyFile)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\treturn X509KeyPair(certPEMBlock, keyPEMBlock)\n+}\n \n+// X509KeyPair parses a public/private key pair from a pair of\n+// PEM encoded data.\n+func X509KeyPair(certPEMBlock, keyPEMBlock []byte) (cert Certificate, err os.Error) {\n \tvar certDERBlock *pem.Block\n \tfor {\n \t\tcertDERBlock, certPEMBlock = pem.Decode(certPEMBlock)\n@@ -141,11 +150,6 @@ func LoadX509KeyPair(certFile string, keyFile string) (cert Certificate, err os.\n \t\treturn\n \t}\n \n-\tkeyPEMBlock, err := ioutil.ReadFile(keyFile)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\n \tkeyDERBlock, _ := pem.Decode(keyPEMBlock)\n \tif keyDERBlock == nil {\n \t\terr = os.ErrorString(\"crypto/tls: failed to parse key PEM data\")"}, {"sha": "6825030d6f97063fb5e9e60a96bc51cd49409351", "filename": "libgo/go/crypto/x509/x509.go", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -54,20 +54,21 @@ func ParsePKCS1PrivateKey(der []byte) (key *rsa.PrivateKey, err os.Error) {\n \t\treturn\n \t}\n \n-\tkey = &rsa.PrivateKey{\n-\t\tPublicKey: rsa.PublicKey{\n-\t\t\tE: priv.E,\n-\t\t\tN: new(big.Int).SetBytes(priv.N.Bytes),\n-\t\t},\n-\t\tD: new(big.Int).SetBytes(priv.D.Bytes),\n-\t\tP: new(big.Int).SetBytes(priv.P.Bytes),\n-\t\tQ: new(big.Int).SetBytes(priv.Q.Bytes),\n+\tkey = new(rsa.PrivateKey)\n+\tkey.PublicKey = rsa.PublicKey{\n+\t\tE: priv.E,\n+\t\tN: new(big.Int).SetBytes(priv.N.Bytes),\n \t}\n \n+\tkey.D = new(big.Int).SetBytes(priv.D.Bytes)\n+\tkey.P = new(big.Int).SetBytes(priv.P.Bytes)\n+\tkey.Q = new(big.Int).SetBytes(priv.Q.Bytes)\n+\n \terr = key.Validate()\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\n \treturn\n }\n "}, {"sha": "d9511b863fbbdfad3ccf3aaaa1e084cddcb5d748", "filename": "libgo/go/crypto/x509/x509_test.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fx509_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"crypto/rsa\"\n \t\"encoding/hex\"\n \t\"encoding/pem\"\n-\t\"reflect\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -22,7 +21,11 @@ func TestParsePKCS1PrivateKey(t *testing.T) {\n \tif err != nil {\n \t\tt.Errorf(\"Failed to parse private key: %s\", err)\n \t}\n-\tif !reflect.DeepEqual(priv, rsaPrivateKey) {\n+\tif priv.PublicKey.N.Cmp(rsaPrivateKey.PublicKey.N) != 0 ||\n+\t\tpriv.PublicKey.E != rsaPrivateKey.PublicKey.E ||\n+\t\tpriv.D.Cmp(rsaPrivateKey.D) != 0 ||\n+\t\tpriv.P.Cmp(rsaPrivateKey.P) != 0 ||\n+\t\tpriv.Q.Cmp(rsaPrivateKey.Q) != 0 {\n \t\tt.Errorf(\"got:%+v want:%+v\", priv, rsaPrivateKey)\n \t}\n }"}, {"sha": "6fdcda6d485faf4b6f3db39c79c5b45353e953b1", "filename": "libgo/go/debug/elf/file.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Felf%2Ffile.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -144,7 +144,7 @@ func (e *FormatError) String() string {\n \n // Open opens the named file using os.Open and prepares it for use as an ELF binary.\n func Open(name string) (*File, os.Error) {\n-\tf, err := os.Open(name, os.O_RDONLY, 0)\n+\tf, err := os.Open(name)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -228,7 +228,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \tswitch f.Class {\n \tcase ELFCLASS32:\n \t\thdr := new(Header32)\n-\t\tsr.Seek(0, 0)\n+\t\tsr.Seek(0, os.SEEK_SET)\n \t\tif err := binary.Read(sr, f.ByteOrder, hdr); err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -243,7 +243,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \t\tshstrndx = int(hdr.Shstrndx)\n \tcase ELFCLASS64:\n \t\thdr := new(Header64)\n-\t\tsr.Seek(0, 0)\n+\t\tsr.Seek(0, os.SEEK_SET)\n \t\tif err := binary.Read(sr, f.ByteOrder, hdr); err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -269,7 +269,7 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \tnames := make([]uint32, shnum)\n \tfor i := 0; i < shnum; i++ {\n \t\toff := shoff + int64(i)*int64(shentsize)\n-\t\tsr.Seek(off, 0)\n+\t\tsr.Seek(off, os.SEEK_SET)\n \t\ts := new(Section)\n \t\tswitch f.Class {\n \t\tcase ELFCLASS32:"}, {"sha": "a777d873cf2cd2e47eb90e9683e81d7545c2fae3", "filename": "libgo/go/debug/macho/file.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fmacho%2Ffile.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -159,7 +159,7 @@ func (e *FormatError) String() string {\n \n // Open opens the named file using os.Open and prepares it for use as a Mach-O binary.\n func Open(name string) (*File, os.Error) {\n-\tf, err := os.Open(name, os.O_RDONLY, 0)\n+\tf, err := os.Open(name)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "6a14e50f9609b8da4be68f8170aa8a82860b27db", "filename": "libgo/go/debug/pe/file.go", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fpe%2Ffile.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -87,7 +87,7 @@ func (e *FormatError) String() string {\n \n // Open opens the named file using os.Open and prepares it for use as a PE binary.\n func Open(name string) (*File, os.Error) {\n-\tf, err := os.Open(name, os.O_RDONLY, 0)\n+\tf, err := os.Open(name)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -132,15 +132,15 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \t} else {\n \t\tbase = int64(0)\n \t}\n-\tsr.Seek(base, 0)\n+\tsr.Seek(base, os.SEEK_SET)\n \tif err := binary.Read(sr, binary.LittleEndian, &f.FileHeader); err != nil {\n \t\treturn nil, err\n \t}\n \tif f.FileHeader.Machine != IMAGE_FILE_MACHINE_UNKNOWN && f.FileHeader.Machine != IMAGE_FILE_MACHINE_AMD64 && f.FileHeader.Machine != IMAGE_FILE_MACHINE_I386 {\n \t\treturn nil, os.NewError(\"Invalid PE File Format.\")\n \t}\n \t// get symbol string table\n-\tsr.Seek(int64(f.FileHeader.PointerToSymbolTable+18*f.FileHeader.NumberOfSymbols), 0)\n+\tsr.Seek(int64(f.FileHeader.PointerToSymbolTable+18*f.FileHeader.NumberOfSymbols), os.SEEK_SET)\n \tvar l uint32\n \tif err := binary.Read(sr, binary.LittleEndian, &l); err != nil {\n \t\treturn nil, err\n@@ -149,9 +149,9 @@ func NewFile(r io.ReaderAt) (*File, os.Error) {\n \tif _, err := r.ReadAt(ss, int64(f.FileHeader.PointerToSymbolTable+18*f.FileHeader.NumberOfSymbols)); err != nil {\n \t\treturn nil, err\n \t}\n-\tsr.Seek(base, 0)\n+\tsr.Seek(base, os.SEEK_SET)\n \tbinary.Read(sr, binary.LittleEndian, &f.FileHeader)\n-\tsr.Seek(int64(f.FileHeader.SizeOfOptionalHeader), 1) //Skip OptionalHeader\n+\tsr.Seek(int64(f.FileHeader.SizeOfOptionalHeader), os.SEEK_CUR) //Skip OptionalHeader\n \tf.Sections = make([]*Section, f.FileHeader.NumberOfSections)\n \tfor i := 0; i < int(f.FileHeader.NumberOfSections); i++ {\n \t\tsh := new(SectionHeader32)"}, {"sha": "17c8fa529f53aad2cb85d62bb57c8819962a77c9", "filename": "libgo/go/debug/proc/proc_linux.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_linux.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -1184,7 +1184,7 @@ func (p *process) attachThread(tid int) (*thread, os.Error) {\n // attachAllThreads attaches to all threads in a process.\n func (p *process) attachAllThreads() os.Error {\n \ttaskPath := \"/proc/\" + strconv.Itoa(p.pid) + \"/task\"\n-\ttaskDir, err := os.Open(taskPath, os.O_RDONLY, 0)\n+\ttaskDir, err := os.Open(taskPath)\n \tif err != nil {\n \t\treturn err\n \t}"}, {"sha": "5398eb8e0ca35b4f908725f9e479f65bdb307dca", "filename": "libgo/go/exec/exec.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -2,9 +2,13 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// The exec package runs external commands.\n+// The exec package runs external commands. It wraps os.StartProcess\n+// to make it easier to remap stdin and stdout, connect I/O with pipes,\n+// and do other adjustments.\n package exec\n \n+// BUG(r): This package should be made even easier to use or merged into os.\n+\n import (\n \t\"os\"\n \t\"strconv\"\n@@ -49,7 +53,7 @@ func modeToFiles(mode, fd int) (*os.File, *os.File, os.Error) {\n \t\tif fd == 0 {\n \t\t\trw = os.O_RDONLY\n \t\t}\n-\t\tf, err := os.Open(os.DevNull, rw, 0)\n+\t\tf, err := os.OpenFile(os.DevNull, rw, 0)\n \t\treturn f, nil, err\n \tcase PassThrough:\n \t\tswitch fd {"}, {"sha": "d48936ac178a865b9e5de82287e60036c5ca36c7", "filename": "libgo/go/exp/draw/x11/auth.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fauth.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fauth.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fdraw%2Fx11%2Fauth.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -53,7 +53,7 @@ func readAuth(displayStr string) (name, data string, err os.Error) {\n \t\t}\n \t\tfn = home + \"/.Xauthority\"\n \t}\n-\tr, err := os.Open(fn, os.O_RDONLY, 0444)\n+\tr, err := os.Open(fn)\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "813d3a875a6c85ed93d1dfee82ebff38e13f2e7a", "filename": "libgo/go/exp/ogle/cmd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -170,7 +170,7 @@ func cmdLoad(args []byte) os.Error {\n \t}\n \n \t// Get symbols\n-\tf, err := os.Open(fname, os.O_RDONLY, 0)\n+\tf, err := os.Open(fname)\n \tif err != nil {\n \t\ttproc.Detach()\n \t\treturn err"}, {"sha": "3766c838a91009c44fb0ed188eaaf7a488fd163f", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -139,7 +139,17 @@ var fmttests = []struct {\n \t{\"%5s\", \"abc\", \"  abc\"},\n \t{\"%2s\", \"\\u263a\", \" \\u263a\"},\n \t{\"%-5s\", \"abc\", \"abc  \"},\n+\t{\"%-8q\", \"abc\", `\"abc\"   `},\n \t{\"%05s\", \"abc\", \"00abc\"},\n+\t{\"%08q\", \"abc\", `000\"abc\"`},\n+\t{\"%5s\", \"abcdefghijklmnopqrstuvwxyz\", \"abcdefghijklmnopqrstuvwxyz\"},\n+\t{\"%.5s\", \"abcdefghijklmnopqrstuvwxyz\", \"abcde\"},\n+\t{\"%.5s\", \"\u65e5\u672c\u8a9e\u65e5\u672c\u8a9e\", \"\u65e5\u672c\u8a9e\u65e5\u672c\"},\n+\t{\"%.5s\", []byte(\"\u65e5\u672c\u8a9e\u65e5\u672c\u8a9e\"), \"\u65e5\u672c\u8a9e\u65e5\u672c\"},\n+\t{\"%.5q\", \"abcdefghijklmnopqrstuvwxyz\", `\"abcde\"`},\n+\t{\"%.3q\", \"\u65e5\u672c\u8a9e\u65e5\u672c\u8a9e\", `\"\\u65e5\\u672c\\u8a9e\"`},\n+\t{\"%.3q\", []byte(\"\u65e5\u672c\u8a9e\u65e5\u672c\u8a9e\"), `\"\\u65e5\\u672c\\u8a9e\"`},\n+\t{\"%10.1q\", \"\u65e5\u672c\u8a9e\u65e5\u672c\u8a9e\", `  \"\\u65e5\"`},\n \n \t// integers\n \t{\"%d\", 12345, \"12345\"},"}, {"sha": "f9d2b4fcaf6b177425d769c7f2fc62aef9ccc7dc", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -235,13 +235,24 @@ func (f *fmt) integer(a int64, base uint64, signedness bool, digits string) {\n \tf.pad(buf[i:])\n }\n \n-// fmt_s formats a string.\n-func (f *fmt) fmt_s(s string) {\n-\tif f.precPresent {\n-\t\tif f.prec < len(s) {\n-\t\t\ts = s[0:f.prec]\n+// truncate truncates the string to the specified precision, if present.\n+func (f *fmt) truncate(s string) string {\n+\tif f.precPresent && f.prec < utf8.RuneCountInString(s) {\n+\t\tn := f.prec\n+\t\tfor i := range s {\n+\t\t\tif n == 0 {\n+\t\t\t\ts = s[:i]\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tn--\n \t\t}\n \t}\n+\treturn s\n+}\n+\n+// fmt_s formats a string.\n+func (f *fmt) fmt_s(s string) {\n+\ts = f.truncate(s)\n \tf.padString(s)\n }\n \n@@ -275,6 +286,7 @@ func (f *fmt) fmt_sX(s string) {\n \n // fmt_q formats a string as a double-quoted, escaped Go string constant.\n func (f *fmt) fmt_q(s string) {\n+\ts = f.truncate(s)\n \tvar quoted string\n \tif f.sharp && strconv.CanBackquote(s) {\n \t\tquoted = \"`\" + s + \"`\""}, {"sha": "4b68051188a031cd253d6eda917e328eed6933f9", "filename": "libgo/go/fmt/print.go", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Ffmt%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Ffmt%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fprint.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -520,12 +520,14 @@ func (p *pp) fmtBytes(v []byte, verb int, goSyntax bool, depth int, value interf\n }\n \n func (p *pp) fmtPointer(field interface{}, value reflect.Value, verb int, goSyntax bool) {\n-\tv, ok := value.(uintptrGetter)\n-\tif !ok { // reflect.PtrValue is a uintptrGetter, so failure means it's not a pointer at all.\n+\tvar u uintptr\n+\tswitch value.(type) {\n+\tcase *reflect.ChanValue, *reflect.FuncValue, *reflect.MapValue, *reflect.PtrValue, *reflect.SliceValue, *reflect.UnsafePointerValue:\n+\t\tu = value.(uintptrGetter).Get()\n+\tdefault:\n \t\tp.badVerb(verb, field)\n \t\treturn\n \t}\n-\tu := v.Get()\n \tif goSyntax {\n \t\tp.add('(')\n \t\tp.buf.WriteString(reflect.Typeof(field).String())\n@@ -534,7 +536,7 @@ func (p *pp) fmtPointer(field interface{}, value reflect.Value, verb int, goSynt\n \t\tif u == 0 {\n \t\t\tp.buf.Write(nilBytes)\n \t\t} else {\n-\t\t\tp.fmt0x64(uint64(v.Get()), true)\n+\t\t\tp.fmt0x64(uint64(u), true)\n \t\t}\n \t\tp.add(')')\n \t} else {\n@@ -811,7 +813,7 @@ BigSwitch:\n \t\t\tbreak\n \t\t}\n \t\tp.fmt0x64(uint64(v), true)\n-\tcase uintptrGetter:\n+\tcase *reflect.ChanValue, *reflect.FuncValue, *reflect.UnsafePointerValue:\n \t\tp.fmtPointer(field, value, verb, goSyntax)\n \tdefault:\n \t\tp.unknownType(f)"}, {"sha": "b4780e05784f7cd992a2260e2f1152d2dd1e99ee", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -183,7 +183,7 @@ func ParseFiles(fset *token.FileSet, filenames []string, mode uint) (pkgs map[st\n // error are returned.\n //\n func ParseDir(fset *token.FileSet, path string, filter func(*os.FileInfo) bool, mode uint) (map[string]*ast.Package, os.Error) {\n-\tfd, err := os.Open(path, os.O_RDONLY, 0)\n+\tfd, err := os.Open(path)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "84a0da6ae7bddd6693e93bcb6464d2bd38d966c5", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -332,7 +332,7 @@ func (p *parser) next() {\n \t\tvar endline int\n \n \t\tif p.file.Line(p.pos) == line {\n-\t\t\t// The comment is on same line as previous token; it\n+\t\t\t// The comment is on same line as the previous token; it\n \t\t\t// cannot be a lead comment but may be a line comment.\n \t\t\tcomment, endline = p.consumeCommentGroup()\n \t\t\tif p.file.Line(p.pos) != endline {\n@@ -2016,16 +2016,18 @@ func parseTypeSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \t}\n \n \tident := p.parseIdent()\n-\ttyp := p.parseType()\n-\tp.expectSemi() // call before accessing p.linecomment\n \n \t// Go spec: The scope of a type identifier declared inside a function begins\n \t// at the identifier in the TypeSpec and ends at the end of the innermost\n \t// containing block.\n \t// (Global identifiers are resolved in a separate phase after parsing.)\n-\tspec := &ast.TypeSpec{doc, ident, typ, p.lineComment}\n+\tspec := &ast.TypeSpec{doc, ident, nil, nil}\n \tp.declare(spec, p.topScope, ast.Typ, ident)\n \n+\tspec.Type = p.parseType()\n+\tp.expectSemi() // call before accessing p.linecomment\n+\tspec.Comment = p.lineComment\n+\n \treturn spec\n }\n \n@@ -2207,6 +2209,9 @@ func (p *parser) parseFile() *ast.File {\n \t// Go spec: The package clause is not a declaration;\n \t// the package name does not appear in any scope.\n \tident := p.parseIdent()\n+\tif ident.Name == \"_\" {\n+\t\tp.error(p.pos, \"invalid package name _\")\n+\t}\n \tp.expectSemi()\n \n \tvar decls []ast.Decl"}, {"sha": "fe955436c8a4bd609ed3443f4f0b558e73798eeb", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -28,7 +28,7 @@ func pipeErr(err os.Error) io.Reader {\n }\n \n func readDat(filename string, c chan io.Reader) {\n-\tf, err := os.Open(\"testdata/webkit/\"+filename, os.O_RDONLY, 0600)\n+\tf, err := os.Open(\"testdata/webkit/\" + filename)\n \tif err != nil {\n \t\tc <- pipeErr(err)\n \t\treturn"}, {"sha": "c5efffca9cdb0ae0989b6172a18d190e38fdd800", "filename": "libgo/go/http/fs.go", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -72,7 +72,7 @@ func serveFile(w ResponseWriter, r *Request, name string, redirect bool) {\n \t\treturn\n \t}\n \n-\tf, err := os.Open(name, os.O_RDONLY, 0)\n+\tf, err := os.Open(name)\n \tif err != nil {\n \t\t// TODO expose actual error?\n \t\tNotFound(w, r)\n@@ -113,7 +113,7 @@ func serveFile(w ResponseWriter, r *Request, name string, redirect bool) {\n \t// use contents of index.html for directory, if present\n \tif d.IsDirectory() {\n \t\tindex := name + filepath.FromSlash(indexPage)\n-\t\tff, err := os.Open(index, os.O_RDONLY, 0)\n+\t\tff, err := os.Open(index)\n \t\tif err == nil {\n \t\t\tdefer ff.Close()\n \t\t\tdd, err := ff.Stat()\n@@ -134,21 +134,23 @@ func serveFile(w ResponseWriter, r *Request, name string, redirect bool) {\n \tsize := d.Size\n \tcode := StatusOK\n \n-\t// use extension to find content type.\n-\text := filepath.Ext(name)\n-\tif ctype := mime.TypeByExtension(ext); ctype != \"\" {\n-\t\tw.Header().Set(\"Content-Type\", ctype)\n-\t} else {\n-\t\t// read first chunk to decide between utf-8 text and binary\n-\t\tvar buf [1024]byte\n-\t\tn, _ := io.ReadFull(f, buf[:])\n-\t\tb := buf[:n]\n-\t\tif isText(b) {\n-\t\t\tw.Header().Set(\"Content-Type\", \"text-plain; charset=utf-8\")\n-\t\t} else {\n-\t\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\") // generic binary\n+\t// If Content-Type isn't set, use the file's extension to find it.\n+\tif w.Header().Get(\"Content-Type\") == \"\" {\n+\t\tctype := mime.TypeByExtension(filepath.Ext(name))\n+\t\tif ctype == \"\" {\n+\t\t\t// read a chunk to decide between utf-8 text and binary\n+\t\t\tvar buf [1024]byte\n+\t\t\tn, _ := io.ReadFull(f, buf[:])\n+\t\t\tb := buf[:n]\n+\t\t\tif isText(b) {\n+\t\t\t\tctype = \"text-plain; charset=utf-8\"\n+\t\t\t} else {\n+\t\t\t\t// generic binary\n+\t\t\t\tctype = \"application/octet-stream\"\n+\t\t\t}\n+\t\t\tf.Seek(0, os.SEEK_SET) // rewind to output whole file\n \t\t}\n-\t\tf.Seek(0, 0) // rewind to output whole file\n+\t\tw.Header().Set(\"Content-Type\", ctype)\n \t}\n \n \t// handle Content-Range header.\n@@ -163,7 +165,7 @@ func serveFile(w ResponseWriter, r *Request, name string, redirect bool) {\n \t}\n \tif len(ranges) == 1 {\n \t\tra := ranges[0]\n-\t\tif _, err := f.Seek(ra.start, 0); err != nil {\n+\t\tif _, err := f.Seek(ra.start, os.SEEK_SET); err != nil {\n \t\t\tError(w, err.String(), StatusRequestedRangeNotSatisfiable)\n \t\t\treturn\n \t\t}"}, {"sha": "692b9863e82fdc9ba4ec85a4d11d764c47c64869", "filename": "libgo/go/http/fs_test.go", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -85,6 +85,30 @@ func TestServeFile(t *testing.T) {\n \t}\n }\n \n+func TestServeFileContentType(t *testing.T) {\n+\tconst ctype = \"icecream/chocolate\"\n+\toverride := false\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tif override {\n+\t\t\tw.Header().Set(\"Content-Type\", ctype)\n+\t\t}\n+\t\tServeFile(w, r, \"testdata/file\")\n+\t}))\n+\tdefer ts.Close()\n+\tget := func(want string) {\n+\t\tresp, _, err := Get(ts.URL)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif h := resp.Header.Get(\"Content-Type\"); h != want {\n+\t\t\tt.Errorf(\"Content-Type mismatch: got %q, want %q\", h, want)\n+\t\t}\n+\t}\n+\tget(\"text-plain; charset=utf-8\")\n+\toverride = true\n+\tget(ctype)\n+}\n+\n func getBody(t *testing.T, req Request) (*Response, []byte) {\n \tr, err := DefaultClient.Do(&req)\n \tif err != nil {"}, {"sha": "8e385d045a1a64b95c3ee5270738209da92d445d", "filename": "libgo/go/http/httptest/server.go", "status": "modified", "additions": 71, "deletions": 5, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -7,17 +7,21 @@\n package httptest\n \n import (\n+\t\"crypto/rand\"\n+\t\"crypto/tls\"\n \t\"fmt\"\n \t\"http\"\n-\t\"os\"\n \t\"net\"\n+\t\"os\"\n+\t\"time\"\n )\n \n // A Server is an HTTP server listening on a system-chosen port on the\n // local loopback interface, for use in end-to-end HTTP tests.\n type Server struct {\n \tURL      string // base URL of form http://ipaddr:port with no trailing slash\n \tListener net.Listener\n+\tTLS      *tls.Config // nil if not using using TLS\n }\n \n // historyListener keeps track of all connections that it's ever\n@@ -35,23 +39,54 @@ func (hs *historyListener) Accept() (c net.Conn, err os.Error) {\n \treturn\n }\n \n-// NewServer starts and returns a new Server.\n-// The caller should call Close when finished, to shut it down.\n-func NewServer(handler http.Handler) *Server {\n-\tts := new(Server)\n+func newLocalListener() net.Listener {\n \tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n \tif err != nil {\n \t\tif l, err = net.Listen(\"tcp6\", \"[::1]:0\"); err != nil {\n \t\t\tpanic(fmt.Sprintf(\"httptest: failed to listen on a port: %v\", err))\n \t\t}\n \t}\n+\treturn l\n+}\n+\n+// NewServer starts and returns a new Server.\n+// The caller should call Close when finished, to shut it down.\n+func NewServer(handler http.Handler) *Server {\n+\tts := new(Server)\n+\tl := newLocalListener()\n \tts.Listener = &historyListener{l, make([]net.Conn, 0)}\n \tts.URL = \"http://\" + l.Addr().String()\n \tserver := &http.Server{Handler: handler}\n \tgo server.Serve(ts.Listener)\n \treturn ts\n }\n \n+// NewTLSServer starts and returns a new Server using TLS.\n+// The caller should call Close when finished, to shut it down.\n+func NewTLSServer(handler http.Handler) *Server {\n+\tl := newLocalListener()\n+\tts := new(Server)\n+\n+\tcert, err := tls.X509KeyPair(localhostCert, localhostKey)\n+\tif err != nil {\n+\t\tpanic(fmt.Sprintf(\"httptest: NewTLSServer: %v\", err))\n+\t}\n+\n+\tts.TLS = &tls.Config{\n+\t\tRand:         rand.Reader,\n+\t\tTime:         time.Seconds,\n+\t\tNextProtos:   []string{\"http/1.1\"},\n+\t\tCertificates: []tls.Certificate{cert},\n+\t}\n+\ttlsListener := tls.NewListener(l, ts.TLS)\n+\n+\tts.Listener = &historyListener{tlsListener, make([]net.Conn, 0)}\n+\tts.URL = \"https://\" + l.Addr().String()\n+\tserver := &http.Server{Handler: handler}\n+\tgo server.Serve(ts.Listener)\n+\treturn ts\n+}\n+\n // Close shuts down the server.\n func (s *Server) Close() {\n \ts.Listener.Close()\n@@ -68,3 +103,34 @@ func (s *Server) CloseClientConnections() {\n \t\tconn.Close()\n \t}\n }\n+\n+// localhostCert is a PEM-encoded TLS cert with SAN DNS names\n+// \"127.0.0.1\" and \"[::1]\", expiring at the last second of 2049 (the end\n+// of ASN.1 time).\n+var localhostCert = []byte(`-----BEGIN CERTIFICATE-----\n+MIIBwTCCASugAwIBAgIBADALBgkqhkiG9w0BAQUwADAeFw0xMTAzMzEyMDI1MDda\n+Fw00OTEyMzEyMzU5NTlaMAAwggCdMAsGCSqGSIb3DQEBAQOCAIwAMIIAhwKCAIB6\n+oy4iT42G6qk+GGn5VL5JlnJT6ZG5cqaMNFaNGlIxNb6CPUZLKq2sM3gRaimsktIw\n+nNAcNwQGHpe1tZo+J/Pl04JTt71Y/TTAxy7OX27aZf1Rpt0SjdZ7vTPnFDPNsHGe\n+KBKvPt55l2+YKjkZmV7eRevsVbpkNvNGB+T5d4Ge/wIBA6NPME0wDgYDVR0PAQH/\n+BAQDAgCgMA0GA1UdDgQGBAQBAgMEMA8GA1UdIwQIMAaABAECAwQwGwYDVR0RBBQw\n+EoIJMTI3LjAuMC4xggVbOjoxXTALBgkqhkiG9w0BAQUDggCBAHC3gbdvc44vs+wD\n+g2kONiENnx8WKc0UTGg/TOXS3gaRb+CUIQtHWja65l8rAfclEovjHgZ7gx8brO0W\n+JuC6p3MUAKsgOssIrrRIx2rpnfcmFVMzguCmrMNVmKUAalw18Yp0F72xYAIitVQl\n+kJrLdIhBajcJRYu/YGltHQRaXuVt\n+-----END CERTIFICATE-----\n+`)\n+\n+// localhostKey is the private key for localhostCert.\n+var localhostKey = []byte(`-----BEGIN RSA PRIVATE KEY-----\n+MIIBkgIBAQKCAIB6oy4iT42G6qk+GGn5VL5JlnJT6ZG5cqaMNFaNGlIxNb6CPUZL\n+Kq2sM3gRaimsktIwnNAcNwQGHpe1tZo+J/Pl04JTt71Y/TTAxy7OX27aZf1Rpt0S\n+jdZ7vTPnFDPNsHGeKBKvPt55l2+YKjkZmV7eRevsVbpkNvNGB+T5d4Ge/wIBAwKC\n+AIBRwh7Bil5Z8cYpZZv7jdQxDvbim7Z7ocRdeDmzZuF2I9RW04QyHHPIIlALnBvI\n+YeF1veASz1gEFGUjzmbUGqKYSbCoTzXoev+F4bmbRxcX9sOmtslqvhMSHRSzA5NH\n+aDVI3Hn4wvBVD8gePu8ACWqvPGbCiql11OKCMfjlPn2uuwJAx/24/F5DjXZ6hQQ7\n+HxScOxKrpx5WnA9r1wZTltOTZkhRRzuLc21WJeE3M15QUdWi3zZxCKRFoth65HEs\n+jy9YHQJAnPueRI44tz79b5QqVbeaOMUr7ZCb1Kp0uo6G+ANPLdlfliAupwij2eIz\n+mHRJOWk0jBtXfRft1McH2H51CpXAyw==\n+-----END RSA PRIVATE KEY-----\n+`)"}, {"sha": "ef67fdd2dc374ec1d82412b75d4694813616cb95", "filename": "libgo/go/http/response_test.go", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Fresponse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -164,6 +164,28 @@ var respTests = []respTest{\n \t\t\"Body here\\n\",\n \t},\n \n+\t// Chunked response in response to a HEAD request (the \"chunked\" should\n+\t// be ignored, as HEAD responses never have bodies)\n+\t{\n+\t\t\"HTTP/1.0 200 OK\\r\\n\" +\n+\t\t\t\"Transfer-Encoding: chunked\\r\\n\" +\n+\t\t\t\"\\r\\n\",\n+\n+\t\tResponse{\n+\t\t\tStatus:        \"200 OK\",\n+\t\t\tStatusCode:    200,\n+\t\t\tProto:         \"HTTP/1.0\",\n+\t\t\tProtoMajor:    1,\n+\t\t\tProtoMinor:    0,\n+\t\t\tRequestMethod: \"HEAD\",\n+\t\t\tHeader:        Header{},\n+\t\t\tClose:         true,\n+\t\t\tContentLength: 0,\n+\t\t},\n+\n+\t\t\"\",\n+\t},\n+\n \t// Status line without a Reason-Phrase, but trailing space.\n \t// (permitted by RFC 2616)\n \t{"}, {"sha": "cf889553fb7852f25d64efc9d7bcfa5fcbfb574d", "filename": "libgo/go/http/serve_test.go", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserve_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -507,3 +507,30 @@ func TestHeadResponses(t *testing.T) {\n \t\tt.Errorf(\"got unexpected body %q\", string(body))\n \t}\n }\n+\n+func TestTLSServer(t *testing.T) {\n+\tts := httptest.NewTLSServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tfmt.Fprintf(w, \"tls=%v\", r.TLS != nil)\n+\t}))\n+\tdefer ts.Close()\n+\tif !strings.HasPrefix(ts.URL, \"https://\") {\n+\t\tt.Fatalf(\"expected test TLS server to start with https://, got %q\", ts.URL)\n+\t}\n+\tres, _, err := Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif res == nil {\n+\t\tt.Fatalf(\"got nil Response\")\n+\t}\n+\tif res.Body == nil {\n+\t\tt.Fatalf(\"got nil Response.Body\")\n+\t}\n+\tbody, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif e, g := \"tls=true\", string(body); e != g {\n+\t\tt.Errorf(\"expected body %q; got %q\", e, g)\n+\t}\n+}"}, {"sha": "41614f144fe3ac999ba8338a2fdea81e97be0a4b", "filename": "libgo/go/http/transfer.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Ftransfer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Ftransfer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransfer.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -215,7 +215,7 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err os.Error) {\n \t}\n \n \t// Transfer encoding, content length\n-\tt.TransferEncoding, err = fixTransferEncoding(t.Header)\n+\tt.TransferEncoding, err = fixTransferEncoding(t.RequestMethod, t.Header)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -289,13 +289,20 @@ func readTransfer(msg interface{}, r *bufio.Reader) (err os.Error) {\n func chunked(te []string) bool { return len(te) > 0 && te[0] == \"chunked\" }\n \n // Sanitize transfer encoding\n-func fixTransferEncoding(header Header) ([]string, os.Error) {\n+func fixTransferEncoding(requestMethod string, header Header) ([]string, os.Error) {\n \traw, present := header[\"Transfer-Encoding\"]\n \tif !present {\n \t\treturn nil, nil\n \t}\n \n \theader[\"Transfer-Encoding\"] = nil, false\n+\n+\t// Head responses have no bodies, so the transfer encoding\n+\t// should be ignored.\n+\tif requestMethod == \"HEAD\" {\n+\t\treturn nil, nil\n+\t}\n+\n \tencodings := strings.Split(raw[0], \",\", -1)\n \tte := make([]string, 0, len(encodings))\n \t// TODO: Even though we only support \"identity\" and \"chunked\""}, {"sha": "797d134aa8511b645783d4c62807fb14e4f509d1", "filename": "libgo/go/http/transport.go", "status": "modified", "additions": 51, "deletions": 20, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -24,18 +24,28 @@ import (\n // environment variables.\n var DefaultTransport RoundTripper = &Transport{}\n \n+// DefaultMaxIdleConnsPerHost is the default value of Transport's\n+// MaxIdleConnsPerHost.\n+const DefaultMaxIdleConnsPerHost = 2\n+\n // Transport is an implementation of RoundTripper that supports http,\n // https, and http proxies (for either http or https with CONNECT).\n // Transport can also cache connections for future re-use.\n type Transport struct {\n \tlk       sync.Mutex\n \tidleConn map[string][]*persistConn\n \n-\t// TODO: tunables on max cached connections (total, per-server), duration\n+\t// TODO: tunable on global max cached connections\n+\t// TODO: tunable on timeout on cached connections\n \t// TODO: optional pipelining\n \n \tIgnoreEnvironment bool // don't look at environment variables for proxy configuration\n \tDisableKeepAlives bool\n+\n+\t// MaxIdleConnsPerHost, if non-zero, controls the maximum idle\n+\t// (keep-alive) to keep to keep per-host.  If zero,\n+\t// DefaultMaxIdleConnsPerHost is used.\n+\tMaxIdleConnsPerHost int\n }\n \n // RoundTrip implements the RoundTripper interface.\n@@ -147,14 +157,22 @@ func (cm *connectMethod) proxyAuth() string {\n func (t *Transport) putIdleConn(pconn *persistConn) {\n \tt.lk.Lock()\n \tdefer t.lk.Unlock()\n-\tif t.DisableKeepAlives {\n+\tif t.DisableKeepAlives || t.MaxIdleConnsPerHost < 0 {\n \t\tpconn.close()\n \t\treturn\n \t}\n \tif pconn.isBroken() {\n \t\treturn\n \t}\n \tkey := pconn.cacheKey\n+\tmax := t.MaxIdleConnsPerHost\n+\tif max == 0 {\n+\t\tmax = DefaultMaxIdleConnsPerHost\n+\t}\n+\tif len(t.idleConn[key]) >= max {\n+\t\tpconn.close()\n+\t\treturn\n+\t}\n \tt.idleConn[key] = append(t.idleConn[key], pconn)\n }\n \n@@ -406,24 +424,37 @@ func (pc *persistConn) readLoop() {\n \n \t\trc := <-pc.reqch\n \t\tresp, err := pc.cc.Read(rc.req)\n-\t\tif err == nil && !rc.req.Close {\n-\t\t\tpc.t.putIdleConn(pc)\n-\t\t}\n+\n \t\tif err == ErrPersistEOF {\n \t\t\t// Succeeded, but we can't send any more\n \t\t\t// persistent connections on this again.  We\n \t\t\t// hide this error to upstream callers.\n \t\t\talive = false\n \t\t\terr = nil\n-\t\t} else if err != nil {\n+\t\t} else if err != nil || rc.req.Close {\n \t\t\talive = false\n \t\t}\n+\n+\t\thasBody := resp != nil && resp.ContentLength != 0\n+\t\tvar waitForBodyRead chan bool\n+\t\tif alive {\n+\t\t\tif hasBody {\n+\t\t\t\twaitForBodyRead = make(chan bool)\n+\t\t\t\tresp.Body.(*bodyEOFSignal).fn = func() {\n+\t\t\t\t\tpc.t.putIdleConn(pc)\n+\t\t\t\t\twaitForBodyRead <- true\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tpc.t.putIdleConn(pc)\n+\t\t\t}\n+\t\t}\n+\n \t\trc.ch <- responseAndError{resp, err}\n \n \t\t// Wait for the just-returned response body to be fully consumed\n \t\t// before we race and peek on the underlying bufio reader.\n-\t\tif alive {\n-\t\t\t<-resp.Body.(*bodyEOFSignal).ch\n+\t\tif waitForBodyRead != nil {\n+\t\t\t<-waitForBodyRead\n \t\t}\n \t}\n }\n@@ -494,34 +525,34 @@ func responseIsKeepAlive(res *Response) bool {\n // the response body with a bodyEOFSignal-wrapped version.\n func readResponseWithEOFSignal(r *bufio.Reader, requestMethod string) (resp *Response, err os.Error) {\n \tresp, err = ReadResponse(r, requestMethod)\n-\tif err == nil {\n-\t\tresp.Body = &bodyEOFSignal{resp.Body, make(chan bool, 1), false}\n+\tif err == nil && resp.ContentLength != 0 {\n+\t\tresp.Body = &bodyEOFSignal{resp.Body, nil}\n \t}\n \treturn\n }\n \n-// bodyEOFSignal wraps a ReadCloser but sends on ch once once\n-// the wrapped ReadCloser is fully consumed (including on Close)\n+// bodyEOFSignal wraps a ReadCloser but runs fn (if non-nil) at most\n+// once, right before the final Read() or Close() call returns, but after\n+// EOF has been seen.\n type bodyEOFSignal struct {\n \tbody io.ReadCloser\n-\tch   chan bool\n-\tdone bool\n+\tfn   func()\n }\n \n func (es *bodyEOFSignal) Read(p []byte) (n int, err os.Error) {\n \tn, err = es.body.Read(p)\n-\tif err == os.EOF && !es.done {\n-\t\tes.ch <- true\n-\t\tes.done = true\n+\tif err == os.EOF && es.fn != nil {\n+\t\tes.fn()\n+\t\tes.fn = nil\n \t}\n \treturn\n }\n \n func (es *bodyEOFSignal) Close() (err os.Error) {\n \terr = es.body.Close()\n-\tif err == nil && !es.done {\n-\t\tes.ch <- true\n-\t\tes.done = true\n+\tif err == nil && es.fn != nil {\n+\t\tes.fn()\n+\t\tes.fn = nil\n \t}\n \treturn\n }"}, {"sha": "e46f830c82841a0bed2f40247671e2aaba8c6c01", "filename": "libgo/go/http/transport_test.go", "status": "modified", "additions": 118, "deletions": 2, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -85,6 +85,7 @@ func TestTransportConnectionCloseOnResponse(t *testing.T) {\n \t\t\t\tt.Fatalf(\"error in connectionClose=%v, req #%d, Do: %v\", connectionClose, n, err)\n \t\t\t}\n \t\t\tbody, err := ioutil.ReadAll(res.Body)\n+\t\t\tdefer res.Body.Close()\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"error in connectionClose=%v, req #%d, ReadAll: %v\", connectionClose, n, err)\n \t\t\t}\n@@ -154,17 +155,19 @@ func TestTransportIdleCacheKeys(t *testing.T) {\n \t\tt.Errorf(\"After CloseIdleConnections expected %d idle conn cache keys; got %d\", e, g)\n \t}\n \n-\tif _, _, err := c.Get(ts.URL); err != nil {\n+\tresp, _, err := c.Get(ts.URL)\n+\tif err != nil {\n \t\tt.Error(err)\n \t}\n+\tioutil.ReadAll(resp.Body)\n \n \tkeys := tr.IdleConnKeysForTesting()\n \tif e, g := 1, len(keys); e != g {\n \t\tt.Fatalf(\"After Get expected %d idle conn cache keys; got %d\", e, g)\n \t}\n \n \tif e := \"|http|\" + ts.Listener.Addr().String(); keys[0] != e {\n-\t\tt.Logf(\"Expected idle cache key %q; got %q\", e, keys[0])\n+\t\tt.Errorf(\"Expected idle cache key %q; got %q\", e, keys[0])\n \t}\n \n \ttr.CloseIdleConnections()\n@@ -173,6 +176,62 @@ func TestTransportIdleCacheKeys(t *testing.T) {\n \t}\n }\n \n+func TestTransportMaxPerHostIdleConns(t *testing.T) {\n+\tch := make(chan string)\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tfmt.Fprintf(w, \"%s\", <-ch)\n+\t}))\n+\tdefer ts.Close()\n+\tmaxIdleConns := 2\n+\ttr := &Transport{DisableKeepAlives: false, MaxIdleConnsPerHost: maxIdleConns}\n+\tc := &Client{Transport: tr}\n+\n+\t// Start 3 outstanding requests (will hang until we write to\n+\t// ch)\n+\tdonech := make(chan bool)\n+\tdoReq := func() {\n+\t\tresp, _, err := c.Get(ts.URL)\n+\t\tif err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t\tioutil.ReadAll(resp.Body)\n+\t\tdonech <- true\n+\t}\n+\tgo doReq()\n+\tgo doReq()\n+\tgo doReq()\n+\n+\tif e, g := 0, len(tr.IdleConnKeysForTesting()); e != g {\n+\t\tt.Fatalf(\"Before writes, expected %d idle conn cache keys; got %d\", e, g)\n+\t}\n+\n+\tch <- \"res1\"\n+\t<-donech\n+\tkeys := tr.IdleConnKeysForTesting()\n+\tif e, g := 1, len(keys); e != g {\n+\t\tt.Fatalf(\"after first response, expected %d idle conn cache keys; got %d\", e, g)\n+\t}\n+\tcacheKey := \"|http|\" + ts.Listener.Addr().String()\n+\tif keys[0] != cacheKey {\n+\t\tt.Fatalf(\"Expected idle cache key %q; got %q\", cacheKey, keys[0])\n+\t}\n+\tif e, g := 1, tr.IdleConnCountForTesting(cacheKey); e != g {\n+\t\tt.Errorf(\"after first response, expected %d idle conns; got %d\", e, g)\n+\t}\n+\n+\tch <- \"res2\"\n+\t<-donech\n+\tif e, g := 2, tr.IdleConnCountForTesting(cacheKey); e != g {\n+\t\tt.Errorf(\"after second response, expected %d idle conns; got %d\", e, g)\n+\t}\n+\n+\tch <- \"res3\"\n+\t<-donech\n+\tif e, g := maxIdleConns, tr.IdleConnCountForTesting(cacheKey); e != g {\n+\t\tt.Errorf(\"after third response, still expected %d idle conns; got %d\", e, g)\n+\t}\n+}\n+\n func TestTransportServerClosingUnexpectedly(t *testing.T) {\n \tts := httptest.NewServer(hostPortHandler)\n \tdefer ts.Close()\n@@ -209,6 +268,63 @@ func TestTransportServerClosingUnexpectedly(t *testing.T) {\n \t}\n }\n \n+// TestTransportHeadResponses verifies that we deal with Content-Lengths\n+// with no bodies properly\n+func TestTransportHeadResponses(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tif r.Method != \"HEAD\" {\n+\t\t\tpanic(\"expected HEAD; got \" + r.Method)\n+\t\t}\n+\t\tw.Header().Set(\"Content-Length\", \"123\")\n+\t\tw.WriteHeader(200)\n+\t}))\n+\tdefer ts.Close()\n+\n+\ttr := &Transport{DisableKeepAlives: false}\n+\tc := &Client{Transport: tr}\n+\tfor i := 0; i < 2; i++ {\n+\t\tres, err := c.Head(ts.URL)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error on loop %d: %v\", i, err)\n+\t\t}\n+\t\tif e, g := \"123\", res.Header.Get(\"Content-Length\"); e != g {\n+\t\t\tt.Errorf(\"loop %d: expected Content-Length header of %q, got %q\", e, g)\n+\t\t}\n+\t\tif e, g := int64(0), res.ContentLength; e != g {\n+\t\t\tt.Errorf(\"loop %d: expected res.ContentLength of %v, got %v\", e, g)\n+\t\t}\n+\t}\n+}\n+\n+// TestTransportHeadChunkedResponse verifies that we ignore chunked transfer-encoding\n+// on responses to HEAD requests.\n+func TestTransportHeadChunkedResponse(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tif r.Method != \"HEAD\" {\n+\t\t\tpanic(\"expected HEAD; got \" + r.Method)\n+\t\t}\n+\t\tw.Header().Set(\"Transfer-Encoding\", \"chunked\") // client should ignore\n+\t\tw.Header().Set(\"x-client-ipport\", r.RemoteAddr)\n+\t\tw.WriteHeader(200)\n+\t}))\n+\tdefer ts.Close()\n+\n+\ttr := &Transport{DisableKeepAlives: false}\n+\tc := &Client{Transport: tr}\n+\n+\tres1, err := c.Head(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatalf(\"request 1 error: %v\", err)\n+\t}\n+\tres2, err := c.Head(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatalf(\"request 2 error: %v\", err)\n+\t}\n+\tif v1, v2 := res1.Header.Get(\"x-client-ipport\"), res2.Header.Get(\"x-client-ipport\"); v1 != v2 {\n+\t\tt.Errorf(\"ip/ports differed between head requests: %q vs %q\", v1, v2)\n+\t}\n+}\n+\n func TestTransportNilURL(t *testing.T) {\n \tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n \t\tfmt.Fprintf(w, \"Hi\")"}, {"sha": "0fc0cb2d76ee2703ca244f890879e6b33373dbef", "filename": "libgo/go/http/url.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Furl.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Furl.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Furl.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -213,8 +213,8 @@ func urlEscape(s string, mode encoding) string {\n \t\t\tj++\n \t\tcase shouldEscape(c, mode):\n \t\t\tt[j] = '%'\n-\t\t\tt[j+1] = \"0123456789abcdef\"[c>>4]\n-\t\t\tt[j+2] = \"0123456789abcdef\"[c&15]\n+\t\t\tt[j+1] = \"0123456789ABCDEF\"[c>>4]\n+\t\t\tt[j+2] = \"0123456789ABCDEF\"[c&15]\n \t\t\tj += 3\n \t\tdefault:\n \t\t\tt[j] = s[i]"}, {"sha": "d8863f3d3b5751ad0bd695ef5c70a1a6647dbc95", "filename": "libgo/go/http/url_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Furl_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fhttp%2Furl_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Furl_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -490,7 +490,7 @@ var escapeTests = []URLEscapeTest{\n \t},\n \t{\n \t\t\" ?&=#+%!<>#\\\"{}|\\\\^[]`\u263a\\t\",\n-\t\t\"+%3f%26%3d%23%2b%25!%3c%3e%23%22%7b%7d%7c%5c%5e%5b%5d%60%e2%98%ba%09\",\n+\t\t\"+%3F%26%3D%23%2B%25!%3C%3E%23%22%7B%7D%7C%5C%5E%5B%5D%60%E2%98%BA%09\",\n \t\tnil,\n \t},\n }\n@@ -519,7 +519,7 @@ type UserinfoTest struct {\n var userinfoTests = []UserinfoTest{\n \t{\"user\", \"password\", \"user:password\"},\n \t{\"foo:bar\", \"~!@#$%^&*()_+{}|[]\\\\-=`:;'\\\"<>?,./\",\n-\t\t\"foo%3abar:~!%40%23$%25%5e&*()_+%7b%7d%7c%5b%5d%5c-=%60%3a;'%22%3c%3e?,.%2f\"},\n+\t\t\"foo%3Abar:~!%40%23$%25%5E&*()_+%7B%7D%7C%5B%5D%5C-=%60%3A;'%22%3C%3E?,.%2F\"},\n }\n \n func TestEscapeUserinfo(t *testing.T) {"}, {"sha": "0716ad9055b85ec56b3b898f1dc06f45516cfcec", "filename": "libgo/go/image/decode_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fimage%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fimage%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fdecode_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -34,7 +34,7 @@ var imageTests = []imageTest{\n }\n \n func decode(filename string) (image.Image, string, os.Error) {\n-\tf, err := os.Open(filename, os.O_RDONLY, 0400)\n+\tf, err := os.Open(filename)\n \tif err != nil {\n \t\treturn nil, \"\", err\n \t}"}, {"sha": "efa6336d792f979c6f958fa915ee345d453be1ca", "filename": "libgo/go/image/png/reader_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fpng%2Freader_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -41,7 +41,7 @@ var filenamesShort = []string{\n }\n \n func readPng(filename string) (image.Image, os.Error) {\n-\tf, err := os.Open(filename, os.O_RDONLY, 0444)\n+\tf, err := os.Open(filename)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -191,7 +191,7 @@ func TestReader(t *testing.T) {\n \t\tdefer piper.Close()\n \n \t\t// Read the .sng file.\n-\t\tsf, err := os.Open(\"testdata/pngsuite/\"+fn+\".sng\", os.O_RDONLY, 0444)\n+\t\tsf, err := os.Open(\"testdata/pngsuite/\" + fn + \".sng\")\n \t\tif err != nil {\n \t\t\tt.Error(fn, err)\n \t\t\tcontinue"}, {"sha": "57d797e851cf89b227733d8af637a83e3f795195", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -28,7 +28,7 @@ func ReadAll(r io.Reader) ([]byte, os.Error) {\n \n // ReadFile reads the file named by filename and returns the contents.\n func ReadFile(filename string) ([]byte, os.Error) {\n-\tf, err := os.Open(filename, os.O_RDONLY, 0)\n+\tf, err := os.Open(filename)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -52,7 +52,7 @@ func ReadFile(filename string) ([]byte, os.Error) {\n // If the file does not exist, WriteFile creates it with permissions perm;\n // otherwise WriteFile truncates it before writing.\n func WriteFile(filename string, data []byte, perm uint32) os.Error {\n-\tf, err := os.Open(filename, os.O_WRONLY|os.O_CREAT|os.O_TRUNC, perm)\n+\tf, err := os.OpenFile(filename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n \tif err != nil {\n \t\treturn err\n \t}\n@@ -74,7 +74,7 @@ func (f fileInfoList) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }\n // ReadDir reads the directory named by dirname and returns\n // a list of sorted directory entries.\n func ReadDir(dirname string) ([]*os.FileInfo, os.Error) {\n-\tf, err := os.Open(dirname, os.O_RDONLY, 0)\n+\tf, err := os.Open(dirname)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "8e681bdc3bce55fb04efe0ce6657cd43c757bd92", "filename": "libgo/go/io/ioutil/tempfile.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -48,7 +48,7 @@ func TempFile(dir, prefix string) (f *os.File, err os.Error) {\n \tnconflict := 0\n \tfor i := 0; i < 10000; i++ {\n \t\tname := filepath.Join(dir, prefix+nextSuffix())\n-\t\tf, err = os.Open(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)\n+\t\tf, err = os.OpenFile(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)\n \t\tif pe, ok := err.(*os.PathError); ok && pe.Error == os.EEXIST {\n \t\t\tif nconflict++; nconflict > 10 {\n \t\t\t\trand = reseed()"}, {"sha": "33140ee08afa08e358a2d100645bd1b330c6e69e", "filename": "libgo/go/log/log.go", "status": "modified", "additions": 69, "deletions": 32, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Flog%2Flog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Flog%2Flog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Flog.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -28,22 +28,24 @@ const (\n \t// order they appear (the order listed here) or the format they present (as\n \t// described in the comments).  A colon appears after these items:\n \t//\t2009/0123 01:23:23.123123 /a/b/c/d.go:23: message\n-\tLdate         = 1 << iota // the date: 2009/0123\n-\tLtime                     // the time: 01:23:23\n-\tLmicroseconds             // microsecond resolution: 01:23:23.123123.  assumes Ltime.\n-\tLlongfile                 // full file name and line number: /a/b/c/d.go:23\n-\tLshortfile                // final file name element and line number: d.go:23. overrides Llongfile\n+\tLdate         = 1 << iota     // the date: 2009/0123\n+\tLtime                         // the time: 01:23:23\n+\tLmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.\n+\tLlongfile                     // full file name and line number: /a/b/c/d.go:23\n+\tLshortfile                    // final file name element and line number: d.go:23. overrides Llongfile\n+\tLstdFlags     = Ldate | Ltime // initial values for the standard logger\n )\n \n // A Logger represents an active logging object that generates lines of\n // output to an io.Writer.  Each logging operation makes a single call to\n // the Writer's Write method.  A Logger can be used simultaneously from\n // multiple goroutines; it guarantees to serialize access to the Writer.\n type Logger struct {\n-\tmu     sync.Mutex // ensures atomic writes\n-\tout    io.Writer  // destination for output\n-\tprefix string     // prefix to write at beginning of each line\n-\tflag   int        // properties\n+\tprefix string       // prefix to write at beginning of each line\n+\tflag   int          // properties\n+\tmu     sync.Mutex   // ensures atomic writes; protects the following fields\n+\tout    io.Writer    // destination for output\n+\tbuf    bytes.Buffer // for accumulating text to write\n }\n \n // New creates a new Logger.   The out variable sets the\n@@ -54,7 +56,7 @@ func New(out io.Writer, prefix string, flag int) *Logger {\n \treturn &Logger{out: out, prefix: prefix, flag: flag}\n }\n \n-var std = New(os.Stderr, \"\", Ldate|Ltime)\n+var std = New(os.Stderr, \"\", LstdFlags)\n \n // Cheap integer to fixed-width decimal ASCII.  Give a negative width to avoid zero-padding.\n // Knows the buffer has capacity.\n@@ -81,7 +83,7 @@ func itoa(buf *bytes.Buffer, i int, wid int) {\n \t}\n }\n \n-func (l *Logger) formatHeader(buf *bytes.Buffer, ns int64, calldepth int) {\n+func (l *Logger) formatHeader(buf *bytes.Buffer, ns int64, file string, line int) {\n \tbuf.WriteString(l.prefix)\n \tif l.flag&(Ldate|Ltime|Lmicroseconds) != 0 {\n \t\tt := time.SecondsToLocalTime(ns / 1e9)\n@@ -107,21 +109,15 @@ func (l *Logger) formatHeader(buf *bytes.Buffer, ns int64, calldepth int) {\n \t\t}\n \t}\n \tif l.flag&(Lshortfile|Llongfile) != 0 {\n-\t\t_, file, line, ok := runtime.Caller(calldepth)\n-\t\tif ok {\n-\t\t\tif l.flag&Lshortfile != 0 {\n-\t\t\t\tshort := file\n-\t\t\t\tfor i := len(file) - 1; i > 0; i-- {\n-\t\t\t\t\tif file[i] == '/' {\n-\t\t\t\t\t\tshort = file[i+1:]\n-\t\t\t\t\t\tbreak\n-\t\t\t\t\t}\n+\t\tif l.flag&Lshortfile != 0 {\n+\t\t\tshort := file\n+\t\t\tfor i := len(file) - 1; i > 0; i-- {\n+\t\t\t\tif file[i] == '/' {\n+\t\t\t\t\tshort = file[i+1:]\n+\t\t\t\t\tbreak\n \t\t\t\t}\n-\t\t\t\tfile = short\n \t\t\t}\n-\t\t} else {\n-\t\t\tfile = \"???\"\n-\t\t\tline = 0\n+\t\t\tfile = short\n \t\t}\n \t\tbuf.WriteString(file)\n \t\tbuf.WriteByte(':')\n@@ -138,15 +134,26 @@ func (l *Logger) formatHeader(buf *bytes.Buffer, ns int64, calldepth int) {\n // paths it will be 2.\n func (l *Logger) Output(calldepth int, s string) os.Error {\n \tnow := time.Nanoseconds() // get this early.\n-\tbuf := new(bytes.Buffer)\n-\tl.formatHeader(buf, now, calldepth+1)\n-\tbuf.WriteString(s)\n-\tif len(s) > 0 && s[len(s)-1] != '\\n' {\n-\t\tbuf.WriteByte('\\n')\n+\t// get caller info (if required) before locking - it's expensive.\n+\tvar file string\n+\tvar line int\n+\tif l.flag&(Lshortfile|Llongfile) != 0 {\n+\t\tvar ok bool\n+\t\t_, file, line, ok = runtime.Caller(calldepth)\n+\t\tif !ok {\n+\t\t\tfile = \"???\"\n+\t\t\tline = 0\n+\t\t}\n \t}\n \tl.mu.Lock()\n \tdefer l.mu.Unlock()\n-\t_, err := l.out.Write(buf.Bytes())\n+\tl.buf.Reset()\n+\tl.formatHeader(&l.buf, now, file, line)\n+\tl.buf.WriteString(s)\n+\tif len(s) > 0 && s[len(s)-1] != '\\n' {\n+\t\tl.buf.WriteByte('\\n')\n+\t}\n+\t_, err := l.out.Write(l.buf.Bytes())\n \treturn err\n }\n \n@@ -203,19 +210,49 @@ func (l *Logger) Panicln(v ...interface{}) {\n \tpanic(s)\n }\n \n+// Flags returns the output flags for the logger.\n+func (l *Logger) Flags() int {\n+\treturn l.flag\n+}\n+\n+// SetFlags sets the output flags for the logger.\n+func (l *Logger) SetFlags(flag int) {\n+\tl.flag = flag\n+}\n+\n+// Prefix returns the output prefix for the logger.\n+func (l *Logger) Prefix() string {\n+\treturn l.prefix\n+}\n+\n+// SetPrefix sets the output prefix for the logger.\n+func (l *Logger) SetPrefix(prefix string) {\n+\tl.prefix = prefix\n+}\n+\n // SetOutput sets the output destination for the standard logger.\n func SetOutput(w io.Writer) {\n \tstd.out = w\n }\n \n+// Flags returns the output flags for the standard logger.\n+func Flags() int {\n+\treturn std.Flags()\n+}\n+\n // SetFlags sets the output flags for the standard logger.\n func SetFlags(flag int) {\n-\tstd.flag = flag\n+\tstd.SetFlags(flag)\n+}\n+\n+// Prefix returns the output prefix for the standard logger.\n+func Prefix() string {\n+\treturn std.Prefix()\n }\n \n // SetPrefix sets the output prefix for the standard logger.\n func SetPrefix(prefix string) {\n-\tstd.prefix = prefix\n+\tstd.SetPrefix(prefix)\n }\n \n // These functions write to the standard logger."}, {"sha": "72ebf398eda2b879cd156a41bd6751e3c2ab6858", "filename": "libgo/go/log/log_test.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Flog%2Flog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Flog%2Flog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Flog_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -84,3 +84,36 @@ func TestOutput(t *testing.T) {\n \t\tt.Errorf(\"log output should match %q is %q\", expect, b.String())\n \t}\n }\n+\n+func TestFlagAndPrefixSetting(t *testing.T) {\n+\tvar b bytes.Buffer\n+\tl := New(&b, \"Test:\", LstdFlags)\n+\tf := l.Flags()\n+\tif f != LstdFlags {\n+\t\tt.Errorf(\"Flags 1: expected %x got %x\", LstdFlags, f)\n+\t}\n+\tl.SetFlags(f | Lmicroseconds)\n+\tf = l.Flags()\n+\tif f != LstdFlags|Lmicroseconds {\n+\t\tt.Errorf(\"Flags 2: expected %x got %x\", LstdFlags|Lmicroseconds, f)\n+\t}\n+\tp := l.Prefix()\n+\tif p != \"Test:\" {\n+\t\tt.Errorf(`Prefix: expected \"Test:\" got %q`, p)\n+\t}\n+\tl.SetPrefix(\"Reality:\")\n+\tp = l.Prefix()\n+\tif p != \"Reality:\" {\n+\t\tt.Errorf(`Prefix: expected \"Reality:\" got %q`, p)\n+\t}\n+\t// Verify a log message looks right, with our prefix and microseconds present.\n+\tl.Print(\"hello\")\n+\tpattern := \"^Reality:\" + Rdate + \" \" + Rtime + Rmicroseconds + \" hello\\n\"\n+\tmatched, err := regexp.Match(pattern, b.Bytes())\n+\tif err != nil {\n+\t\tt.Fatalf(\"pattern %q did not compile: %s\", pattern, err)\n+\t}\n+\tif !matched {\n+\t\tt.Error(\"message did not match pattern\")\n+\t}\n+}"}, {"sha": "6fe0ed5fd5e0584cf4c819bf83a69cf7a032fbca", "filename": "libgo/go/mime/type.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fmime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fmime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Ftype.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -33,7 +33,7 @@ var mimeTypes = map[string]string{\n var mimeLock sync.RWMutex\n \n func loadMimeFile(filename string) {\n-\tf, err := os.Open(filename, os.O_RDONLY, 0666)\n+\tf, err := os.Open(filename)\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "d75e9e038a6791360b4f1a1cb49c850015726e7c", "filename": "libgo/go/net/hosts.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fnet%2Fhosts.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fnet%2Fhosts.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhosts.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -59,7 +59,7 @@ func readHosts() {\n \t}\n }\n \n-// lookupStaticHosts looks up the addresses for the given host from /etc/hosts.\n+// lookupStaticHost looks up the addresses for the given host from /etc/hosts.\n func lookupStaticHost(host string) []string {\n \thosts.Lock()\n \tdefer hosts.Unlock()\n@@ -72,7 +72,7 @@ func lookupStaticHost(host string) []string {\n \treturn nil\n }\n \n-// rlookupStaticHosts looks up the hosts for the given address from /etc/hosts.\n+// lookupStaticAddr looks up the hosts for the given address from /etc/hosts.\n func lookupStaticAddr(addr string) []string {\n \thosts.Lock()\n \tdefer hosts.Unlock()"}, {"sha": "de46830d2928d09f231d699ee9005485e12fd68b", "filename": "libgo/go/net/parse.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fnet%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fnet%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fparse.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -63,7 +63,7 @@ func (f *file) readLine() (s string, ok bool) {\n }\n \n func open(name string) (*file, os.Error) {\n-\tfd, err := os.Open(name, os.O_RDONLY, 0)\n+\tfd, err := os.Open(name)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "226f354d300604be7b7a308021e7599a21479239", "filename": "libgo/go/net/parse_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fnet%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fnet%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fparse_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -18,7 +18,7 @@ func TestReadLine(t *testing.T) {\n \t}\n \tfilename := \"/etc/services\" // a nice big file\n \n-\tfd, err := os.Open(filename, os.O_RDONLY, 0)\n+\tfd, err := os.Open(filename)\n \tif err != nil {\n \t\tt.Fatalf(\"open %s: %v\", filename, err)\n \t}"}, {"sha": "000c3065911fa07918e63c898fc7820b18c86e9d", "filename": "libgo/go/net/resolv_windows.go", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fnet%2Fresolv_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fnet%2Fresolv_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fresolv_windows.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -14,26 +14,51 @@ import (\n var hostentLock sync.Mutex\n var serventLock sync.Mutex\n \n-func LookupHost(name string) (cname string, addrs []string, err os.Error) {\n+func goLookupHost(name string) (addrs []string, err os.Error) {\n+\tips, err := goLookupIP(name)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\taddrs = make([]string, 0, len(ips))\n+\tfor _, ip := range ips {\n+\t\taddrs = append(addrs, ip.String())\n+\t}\n+\treturn\n+}\n+\n+func goLookupIP(name string) (addrs []IP, err os.Error) {\n \thostentLock.Lock()\n \tdefer hostentLock.Unlock()\n \th, e := syscall.GetHostByName(name)\n \tif e != 0 {\n-\t\treturn \"\", nil, os.NewSyscallError(\"GetHostByName\", e)\n+\t\treturn nil, os.NewSyscallError(\"GetHostByName\", e)\n \t}\n-\tcname = name\n \tswitch h.AddrType {\n \tcase syscall.AF_INET:\n \t\ti := 0\n-\t\taddrs = make([]string, 100) // plenty of room to grow\n+\t\taddrs = make([]IP, 100) // plenty of room to grow\n \t\tfor p := (*[100](*[4]byte))(unsafe.Pointer(h.AddrList)); i < cap(addrs) && p[i] != nil; i++ {\n-\t\t\taddrs[i] = IPv4(p[i][0], p[i][1], p[i][2], p[i][3]).String()\n+\t\t\taddrs[i] = IPv4(p[i][0], p[i][1], p[i][2], p[i][3])\n \t\t}\n \t\taddrs = addrs[0:i]\n \tdefault: // TODO(vcc): Implement non IPv4 address lookups.\n-\t\treturn \"\", nil, os.NewSyscallError(\"LookupHost\", syscall.EWINDOWS)\n+\t\treturn nil, os.NewSyscallError(\"LookupHost\", syscall.EWINDOWS)\n+\t}\n+\treturn addrs, nil\n+}\n+\n+func LookupCNAME(name string) (cname string, err os.Error) {\n+\tvar r *syscall.DNSRecord\n+\te := syscall.DnsQuery(name, syscall.DNS_TYPE_CNAME, 0, nil, &r, nil)\n+\tif int(e) != 0 {\n+\t\treturn \"\", os.NewSyscallError(\"LookupCNAME\", int(e))\n+\t}\n+\tdefer syscall.DnsRecordListFree(r, 1)\n+\tif r != nil && r.Type == syscall.DNS_TYPE_CNAME {\n+\t\tv := (*syscall.DNSPTRData)(unsafe.Pointer(&r.Data[0]))\n+\t\tcname = syscall.UTF16ToString((*[256]uint16)(unsafe.Pointer(v.Host))[:]) + \".\"\n \t}\n-\treturn cname, addrs, nil\n+\treturn\n }\n \n type SRV struct {\n@@ -62,7 +87,7 @@ func LookupSRV(service, proto, name string) (cname string, addrs []*SRV, err os.\n \treturn name, addrs, nil\n }\n \n-func LookupPort(network, service string) (port int, err os.Error) {\n+func goLookupPort(network, service string) (port int, err os.Error) {\n \tswitch network {\n \tcase \"tcp4\", \"tcp6\":\n \t\tnetwork = \"tcp\""}, {"sha": "7bb0642e47971d1d95a6b5f61fa9310119424fab", "filename": "libgo/go/os/dir_plan9.go", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fdir_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fdir_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_plan9.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,300 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+import (\n+\t\"syscall\"\n+)\n+\n+type dirInfo int\n+\n+var markDirectory dirInfo = ^0\n+\n+// Readdir reads the contents of the directory associated with file and\n+// returns an array of up to count FileInfo structures, as would be returned\n+// by Lstat, in directory order.  Subsequent calls on the same file will yield\n+// further FileInfos. A negative count means to read the entire directory.\n+// Readdir returns the array and an Error, if any.\n+func (file *File) Readdir(count int) (fi []FileInfo, err Error) {\n+\t// If this file has no dirinfo, create one.\n+\tif file.dirinfo == nil {\n+\t\tfile.dirinfo = &markDirectory\n+\t}\n+\n+\tsize := count\n+\tif size < 0 {\n+\t\tsize = 100\n+\t}\n+\n+\tresult := make([]FileInfo, 0, size)\n+\tvar buf [syscall.STATMAX]byte\n+\n+\tfor {\n+\t\tn, e := file.Read(buf[:])\n+\n+\t\tif e != nil {\n+\t\t\tif e == EOF {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\treturn []FileInfo{}, &PathError{\"readdir\", file.name, e}\n+\t\t}\n+\n+\t\tif n < syscall.STATFIXLEN {\n+\t\t\treturn []FileInfo{}, &PathError{\"readdir\", file.name, Eshortstat}\n+\t\t}\n+\n+\t\tfor i := 0; i < n; {\n+\t\t\tm, _ := gbit16(buf[i:])\n+\t\t\tm += 2\n+\n+\t\t\tif m < syscall.STATFIXLEN {\n+\t\t\t\treturn []FileInfo{}, &PathError{\"readdir\", file.name, Eshortstat}\n+\t\t\t}\n+\n+\t\t\td, e := UnmarshalDir(buf[i : i+int(m)])\n+\n+\t\t\tif e != nil {\n+\t\t\t\treturn []FileInfo{}, &PathError{\"readdir\", file.name, e}\n+\t\t\t}\n+\n+\t\t\tvar f FileInfo\n+\t\t\tfileInfoFromStat(&f, d)\n+\n+\t\t\tresult = append(result, f)\n+\n+\t\t\t// a negative count means to read until EOF.\n+\t\t\tif count > 0 && len(result) >= count {\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\ti += int(m)\n+\t\t}\n+\t}\n+\n+\treturn result, nil\n+}\n+\n+// Readdirnames returns an array of up to count file names residing in the \n+// directory associated with file. A negative count will return all of them.\n+// Readdir returns the array and an Error, if any.\n+func (file *File) Readdirnames(count int) (names []string, err Error) {\n+\tfi, e := file.Readdir(count)\n+\n+\tif e != nil {\n+\t\treturn []string{}, e\n+\t}\n+\n+\tnames = make([]string, len(fi))\n+\terr = nil\n+\n+\tfor i, _ := range fi {\n+\t\tnames[i] = fi[i].Name\n+\t}\n+\n+\treturn\n+}\n+\n+type Dir struct {\n+\t// system-modified data\n+\tType uint16 // server type\n+\tDev  uint32 // server subtype\n+\t// file data\n+\tQid    Qid    // unique id from server\n+\tMode   uint32 // permissions\n+\tAtime  uint32 // last read time\n+\tMtime  uint32 // last write time\n+\tLength uint64 // file length\n+\tName   string // last element of path\n+\tUid    string // owner name\n+\tGid    string // group name\n+\tMuid   string // last modifier name\n+}\n+\n+type Qid struct {\n+\tPath uint64 // the file server's unique identification for the file\n+\tVers uint32 // version number for given Path\n+\tType uint8  // the type of the file (syscall.QTDIR for example)\n+}\n+\n+var nullDir = Dir{\n+\t^uint16(0),\n+\t^uint32(0),\n+\tQid{^uint64(0), ^uint32(0), ^uint8(0)},\n+\t^uint32(0),\n+\t^uint32(0),\n+\t^uint32(0),\n+\t^uint64(0),\n+\t\"\",\n+\t\"\",\n+\t\"\",\n+\t\"\",\n+}\n+\n+// Null assigns members of d with special \"don't care\" values indicating\n+// they should not be written by syscall.Wstat. \n+func (d *Dir) Null() {\n+\t*d = nullDir\n+}\n+\n+// pdir appends a 9P Stat message based on the contents of Dir d to a byte slice b.\n+func pdir(b []byte, d *Dir) []byte {\n+\tn := len(b)\n+\tb = pbit16(b, 0) // length, filled in later\t\n+\tb = pbit16(b, d.Type)\n+\tb = pbit32(b, d.Dev)\n+\tb = pqid(b, d.Qid)\n+\tb = pbit32(b, d.Mode)\n+\tb = pbit32(b, d.Atime)\n+\tb = pbit32(b, d.Mtime)\n+\tb = pbit64(b, d.Length)\n+\tb = pstring(b, d.Name)\n+\tb = pstring(b, d.Uid)\n+\tb = pstring(b, d.Gid)\n+\tb = pstring(b, d.Muid)\n+\tpbit16(b[0:n], uint16(len(b)-(n+2)))\n+\treturn b\n+}\n+\n+// UnmarshalDir reads a 9P Stat message from a 9P protocol message strored in b,\n+// returning the corresponding Dir struct.\n+func UnmarshalDir(b []byte) (d *Dir, err Error) {\n+\tn := uint16(0)\n+\tn, b = gbit16(b)\n+\n+\tif int(n) != len(b) {\n+\t\treturn nil, Ebadstat\n+\t}\n+\n+\td = new(Dir)\n+\td.Type, b = gbit16(b)\n+\td.Dev, b = gbit32(b)\n+\td.Qid, b = gqid(b)\n+\td.Mode, b = gbit32(b)\n+\td.Atime, b = gbit32(b)\n+\td.Mtime, b = gbit32(b)\n+\td.Length, b = gbit64(b)\n+\td.Name, b = gstring(b)\n+\td.Uid, b = gstring(b)\n+\td.Gid, b = gstring(b)\n+\td.Muid, b = gstring(b)\n+\n+\tif len(b) != 0 {\n+\t\treturn nil, Ebadstat\n+\t}\n+\n+\treturn d, nil\n+}\n+\n+// gqid reads the qid part of a 9P Stat message from a 9P protocol message strored in b,\n+// returning the corresponding Qid struct and the remaining slice of b.\n+func gqid(b []byte) (Qid, []byte) {\n+\tvar q Qid\n+\tq.Path, b = gbit64(b)\n+\tq.Vers, b = gbit32(b)\n+\tq.Type, b = gbit8(b)\n+\treturn q, b\n+}\n+\n+// pqid appends a Qid struct q to a 9P message b.\n+func pqid(b []byte, q Qid) []byte {\n+\tb = pbit64(b, q.Path)\n+\tb = pbit32(b, q.Vers)\n+\tb = pbit8(b, q.Type)\n+\treturn b\n+}\n+\n+// gbit8 reads a byte-sized numeric value from a 9P protocol message strored in b,\n+// returning the value and the remaining slice of b.\n+func gbit8(b []byte) (uint8, []byte) {\n+\treturn uint8(b[0]), b[1:]\n+}\n+\n+// gbit16 reads a 16-bit numeric value from a 9P protocol message strored in b,\n+// returning the value and the remaining slice of b.\n+func gbit16(b []byte) (uint16, []byte) {\n+\treturn uint16(b[0]) | uint16(b[1])<<8, b[2:]\n+}\n+\n+// gbit32 reads a 32-bit numeric value from a 9P protocol message strored in b,\n+// returning the value and the remaining slice of b.\n+func gbit32(b []byte) (uint32, []byte) {\n+\treturn uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24, b[4:]\n+}\n+\n+// gbit64 reads a 64-bit numeric value from a 9P protocol message strored in b,\n+// returning the value and the remaining slice of b.\n+func gbit64(b []byte) (uint64, []byte) {\n+\tlo, b := gbit32(b)\n+\thi, b := gbit32(b)\n+\treturn uint64(hi)<<32 | uint64(lo), b\n+}\n+\n+// gstring reads a string from a 9P protocol message strored in b,\n+// returning the value as a Go string and the remaining slice of b.\n+func gstring(b []byte) (string, []byte) {\n+\tn, b := gbit16(b)\n+\treturn string(b[0:n]), b[n:]\n+}\n+\n+// pbit8 appends a byte-sized numeric value x to a 9P message b.\n+func pbit8(b []byte, x uint8) []byte {\n+\tn := len(b)\n+\tif n+1 > cap(b) {\n+\t\tnb := make([]byte, n, 100+2*cap(b))\n+\t\tcopy(nb, b)\n+\t\tb = nb\n+\t}\n+\tb = b[0 : n+1]\n+\tb[n] = x\n+\treturn b\n+}\n+\n+// pbit16 appends a 16-bit numeric value x to a 9P message b.\n+func pbit16(b []byte, x uint16) []byte {\n+\tn := len(b)\n+\tif n+2 > cap(b) {\n+\t\tnb := make([]byte, n, 100+2*cap(b))\n+\t\tcopy(nb, b)\n+\t\tb = nb\n+\t}\n+\tb = b[0 : n+2]\n+\tb[n] = byte(x)\n+\tb[n+1] = byte(x >> 8)\n+\treturn b\n+}\n+\n+// pbit32 appends a 32-bit numeric value x to a 9P message b.\n+func pbit32(b []byte, x uint32) []byte {\n+\tn := len(b)\n+\tif n+4 > cap(b) {\n+\t\tnb := make([]byte, n, 100+2*cap(b))\n+\t\tcopy(nb, b)\n+\t\tb = nb\n+\t}\n+\tb = b[0 : n+4]\n+\tb[n] = byte(x)\n+\tb[n+1] = byte(x >> 8)\n+\tb[n+2] = byte(x >> 16)\n+\tb[n+3] = byte(x >> 24)\n+\treturn b\n+}\n+\n+// pbit64 appends a 64-bit numeric value x to a 9P message b.\n+func pbit64(b []byte, x uint64) []byte {\n+\tb = pbit32(b, uint32(x))\n+\tb = pbit32(b, uint32(x>>32))\n+\treturn b\n+}\n+\n+// pstring appends a Go string s to a 9P message b.\n+func pstring(b []byte, s string) []byte {\n+\tif len(s) >= 1<<16 {\n+\t\tpanic(NewError(\"string too long\"))\n+\t}\n+\tb = pbit16(b, uint16(len(s)))\n+\tb = append(b, []byte(s)...)\n+\treturn b\n+}"}, {"sha": "f5b82230d1b18b51262d2e380510af2cb3a73806", "filename": "libgo/go/os/dir_unix.go", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fdir_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fdir_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fdir_unix.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+import (\n+\t\"syscall\"\n+)\n+\n+const (\n+\tblockSize = 4096\n+)\n+\n+// Readdirnames reads the contents of the directory associated with file and\n+// returns an array of up to count names, in directory order.  Subsequent\n+// calls on the same file will yield further names.\n+// A negative count means to read until EOF.\n+// Readdirnames returns the array and an Error, if any.\n+func (file *File) Readdirnames(count int) (names []string, err Error) {\n+\t// If this file has no dirinfo, create one.\n+\tif file.dirinfo == nil {\n+\t\tfile.dirinfo = new(dirInfo)\n+\t\t// The buffer must be at least a block long.\n+\t\tfile.dirinfo.buf = make([]byte, blockSize)\n+\t}\n+\td := file.dirinfo\n+\tsize := count\n+\tif size < 0 {\n+\t\tsize = 100\n+\t}\n+\tnames = make([]string, 0, size) // Empty with room to grow.\n+\tfor count != 0 {\n+\t\t// Refill the buffer if necessary\n+\t\tif d.bufp >= d.nbuf {\n+\t\t\td.bufp = 0\n+\t\t\tvar errno int\n+\t\t\td.nbuf, errno = syscall.ReadDirent(file.fd, d.buf)\n+\t\t\tif errno != 0 {\n+\t\t\t\treturn names, NewSyscallError(\"readdirent\", errno)\n+\t\t\t}\n+\t\t\tif d.nbuf <= 0 {\n+\t\t\t\tbreak // EOF\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Drain the buffer\n+\t\tvar nb, nc int\n+\t\tnb, nc, names = syscall.ParseDirent(d.buf[d.bufp:d.nbuf], count, names)\n+\t\td.bufp += nb\n+\t\tcount -= nc\n+\t}\n+\treturn names, nil\n+}"}, {"sha": "14df55ed0edd8a1cdef4adc82c91a8c30f1ad32f", "filename": "libgo/go/os/env_plan9.go", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fenv_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fenv_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv_plan9.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Plan 9 environment variables.\n+\n+package os\n+\n+import \"syscall\"\n+\n+// ENOENV is the Error indicating that an environment variable does not exist.\n+var ENOENV = NewError(\"no such environment variable\")\n+\n+// Getenverror retrieves the value of the environment variable named by the key.\n+// It returns the value and an error, if any.\n+func Getenverror(key string) (value string, err Error) {\n+\tif len(key) == 0 {\n+\t\treturn \"\", EINVAL\n+\t}\n+\tf, e := Open(\"/env/\" + key)\n+\tif iserror(e) {\n+\t\treturn \"\", ENOENV\n+\t}\n+\tdefer f.Close()\n+\n+\tvar buf [4096]byte\n+\tn, e := f.Read(buf[:len(buf)-1])\n+\tif iserror(e) {\n+\t\treturn \"\", ENOENV\n+\t}\n+\tbuf[n] = 0\n+\treturn string(buf[0:n]), nil\n+}\n+\n+// Getenv retrieves the value of the environment variable named by the key.\n+// It returns the value, which will be empty if the variable is not present.\n+func Getenv(key string) string {\n+\tv, _ := Getenverror(key)\n+\treturn v\n+}\n+\n+// Setenv sets the value of the environment variable named by the key.\n+// It returns an Error, if any.\n+func Setenv(key, value string) Error {\n+\tif len(key) == 0 {\n+\t\treturn EINVAL\n+\t}\n+\n+\tf, e := Create(\"/env/\" + key)\n+\tif iserror(e) {\n+\t\treturn e\n+\t}\n+\tdefer f.Close()\n+\n+\t_, e = f.Write(syscall.StringByteSlice(value))\n+\treturn nil\n+}\n+\n+// Clearenv deletes all environment variables.\n+func Clearenv() {\n+\tsyscall.RawSyscall(syscall.SYS_RFORK, syscall.RFCENVG, 0, 0)\n+}\n+\n+// Environ returns an array of strings representing the environment,\n+// in the form \"key=value\".\n+func Environ() []string {\n+\tenv := make([]string, 0, 100)\n+\n+\tf, e := Open(\"/env\")\n+\tif iserror(e) {\n+\t\tpanic(e)\n+\t}\n+\tdefer f.Close()\n+\n+\tnames, e := f.Readdirnames(-1)\n+\tif iserror(e) {\n+\t\tpanic(e)\n+\t}\n+\n+\tfor _, k := range names {\n+\t\tif v, e := Getenverror(k); !iserror(e) {\n+\t\t\tenv = append(env, k+\"=\"+v)\n+\t\t}\n+\t}\n+\treturn env[0:len(env)]\n+}\n+\n+// TempDir returns the default directory to use for temporary files.\n+func TempDir() string {\n+\treturn \"/tmp\"\n+}"}, {"sha": "2c4516ca7dae79c5743820918e5b369b6b4d1ca8", "filename": "libgo/go/os/error.go", "status": "modified", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ferror.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ferror.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -4,8 +4,6 @@\n \n package os\n \n-import syscall \"syscall\"\n-\n // An Error can represent any printable error condition.\n type Error interface {\n \tString() string\n@@ -26,63 +24,6 @@ func (e ErrorString) Timeout() bool   { return false }\n // NewError converts s to an ErrorString, which satisfies the Error interface.\n func NewError(s string) Error { return ErrorString(s) }\n \n-// Errno is the Unix error number.  Names such as EINVAL are simple\n-// wrappers to convert the error number into an Error.\n-type Errno int64\n-\n-func (e Errno) String() string { return syscall.Errstr(int(e)) }\n-\n-func (e Errno) Temporary() bool {\n-\treturn e == Errno(syscall.EINTR) || e.Timeout()\n-}\n-\n-func (e Errno) Timeout() bool {\n-\treturn e == Errno(syscall.EAGAIN) || e == Errno(syscall.EWOULDBLOCK) || e == Errno(syscall.ETIMEDOUT)\n-}\n-\n-// Commonly known Unix errors.\n-var (\n-\tEPERM        Error = Errno(syscall.EPERM)\n-\tENOENT       Error = Errno(syscall.ENOENT)\n-\tESRCH        Error = Errno(syscall.ESRCH)\n-\tEINTR        Error = Errno(syscall.EINTR)\n-\tEIO          Error = Errno(syscall.EIO)\n-\tENXIO        Error = Errno(syscall.ENXIO)\n-\tE2BIG        Error = Errno(syscall.E2BIG)\n-\tENOEXEC      Error = Errno(syscall.ENOEXEC)\n-\tEBADF        Error = Errno(syscall.EBADF)\n-\tECHILD       Error = Errno(syscall.ECHILD)\n-\tEDEADLK      Error = Errno(syscall.EDEADLK)\n-\tENOMEM       Error = Errno(syscall.ENOMEM)\n-\tEACCES       Error = Errno(syscall.EACCES)\n-\tEFAULT       Error = Errno(syscall.EFAULT)\n-\tEBUSY        Error = Errno(syscall.EBUSY)\n-\tEEXIST       Error = Errno(syscall.EEXIST)\n-\tEXDEV        Error = Errno(syscall.EXDEV)\n-\tENODEV       Error = Errno(syscall.ENODEV)\n-\tENOTDIR      Error = Errno(syscall.ENOTDIR)\n-\tEISDIR       Error = Errno(syscall.EISDIR)\n-\tEINVAL       Error = Errno(syscall.EINVAL)\n-\tENFILE       Error = Errno(syscall.ENFILE)\n-\tEMFILE       Error = Errno(syscall.EMFILE)\n-\tENOTTY       Error = Errno(syscall.ENOTTY)\n-\tEFBIG        Error = Errno(syscall.EFBIG)\n-\tENOSPC       Error = Errno(syscall.ENOSPC)\n-\tESPIPE       Error = Errno(syscall.ESPIPE)\n-\tEROFS        Error = Errno(syscall.EROFS)\n-\tEMLINK       Error = Errno(syscall.EMLINK)\n-\tEPIPE        Error = Errno(syscall.EPIPE)\n-\tEAGAIN       Error = Errno(syscall.EAGAIN)\n-\tEDOM         Error = Errno(syscall.EDOM)\n-\tERANGE       Error = Errno(syscall.ERANGE)\n-\tEADDRINUSE   Error = Errno(syscall.EADDRINUSE)\n-\tECONNREFUSED Error = Errno(syscall.ECONNREFUSED)\n-\tENAMETOOLONG Error = Errno(syscall.ENAMETOOLONG)\n-\tEAFNOSUPPORT Error = Errno(syscall.EAFNOSUPPORT)\n-\tETIMEDOUT    Error = Errno(syscall.ETIMEDOUT)\n-\tENOTCONN     Error = Errno(syscall.ENOTCONN)\n-)\n-\n // PathError records an error and the operation and file path that caused it.\n type PathError struct {\n \tOp    string\n@@ -91,25 +32,3 @@ type PathError struct {\n }\n \n func (e *PathError) String() string { return e.Op + \" \" + e.Path + \": \" + e.Error.String() }\n-\n-// SyscallError records an error from a specific system call.\n-type SyscallError struct {\n-\tSyscall string\n-\tErrno   Errno\n-}\n-\n-func (e *SyscallError) String() string { return e.Syscall + \": \" + e.Errno.String() }\n-\n-// Note: If the name of the function NewSyscallError changes,\n-// pkg/go/doc/doc.go should be adjusted since it hardwires\n-// this name in a heuristic.\n-\n-// NewSyscallError returns, as an Error, a new SyscallError\n-// with the given system call name and error number.\n-// As a convenience, if errno is 0, NewSyscallError returns nil.\n-func NewSyscallError(syscall string, errno int) Error {\n-\tif errno == 0 {\n-\t\treturn nil\n-\t}\n-\treturn &SyscallError{syscall, Errno(errno)}\n-}"}, {"sha": "d6575864e843d4e1f33ab0518a6a003d03970f04", "filename": "libgo/go/os/error_plan9.go", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ferror_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ferror_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_plan9.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+import syscall \"syscall\"\n+\n+// SyscallError records an error from a specific system call.\n+type SyscallError struct {\n+\tSyscall string\n+\tErr     string\n+}\n+\n+func (e *SyscallError) String() string { return e.Syscall + \": \" + e.Err }\n+\n+// Note: If the name of the function NewSyscallError changes,\n+// pkg/go/doc/doc.go should be adjusted since it hardwires\n+// this name in a heuristic.\n+\n+// NewSyscallError returns, as an Error, a new SyscallError\n+// with the given system call name and error details.\n+// As a convenience, if err is nil, NewSyscallError returns nil.\n+func NewSyscallError(syscall string, err syscall.Error) Error {\n+\tif err == nil {\n+\t\treturn nil\n+\t}\n+\treturn &SyscallError{syscall, err.String()}\n+}\n+\n+var (\n+\tEshortstat = NewError(\"stat buffer too small\")\n+\tEbadstat   = NewError(\"malformed stat buffer\")\n+\tEbadfd     = NewError(\"fd out of range or not open\")\n+\tEbadarg    = NewError(\"bad arg in system call\")\n+\tEnotdir    = NewError(\"not a directory\")\n+\tEnonexist  = NewError(\"file does not exist\")\n+\tEexist     = NewError(\"file already exists\")\n+\tEio        = NewError(\"i/o error\")\n+\n+\tEINVAL  = Ebadarg\n+\tENOTDIR = Enotdir\n+\tENOENT  = Enonexist\n+\tEEXIST  = Eexist\n+\tEIO     = Eio\n+\n+\tENAMETOOLONG = NewError(\"file name too long\")\n+\tERANGE       = NewError(\"math result not representable\")\n+\tEPIPE        = NewError(\"Broken Pipe\")\n+\tEPLAN9       = NewError(\"not supported by plan 9\")\n+)\n+\n+func iserror(err syscall.Error) bool {\n+\treturn err != nil\n+}\n+\n+func Errno(e syscall.Error) syscall.Error { return e }"}, {"sha": "0ee34e4b0eff849da8248ae106937acce61f8b2c", "filename": "libgo/go/os/error_posix.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ferror_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ferror_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ferror_posix.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+import syscall \"syscall\"\n+\n+// Errno is the Unix error number.  Names such as EINVAL are simple\n+// wrappers to convert the error number into an Error.\n+type Errno int64\n+\n+func (e Errno) String() string { return syscall.Errstr(int(e)) }\n+\n+func (e Errno) Temporary() bool {\n+\treturn e == Errno(syscall.EINTR) || e.Timeout()\n+}\n+\n+func (e Errno) Timeout() bool {\n+\treturn e == Errno(syscall.EAGAIN) || e == Errno(syscall.EWOULDBLOCK) || e == Errno(syscall.ETIMEDOUT)\n+}\n+\n+// Commonly known Unix errors.\n+var (\n+\tEPERM        Error = Errno(syscall.EPERM)\n+\tENOENT       Error = Errno(syscall.ENOENT)\n+\tESRCH        Error = Errno(syscall.ESRCH)\n+\tEINTR        Error = Errno(syscall.EINTR)\n+\tEIO          Error = Errno(syscall.EIO)\n+\tENXIO        Error = Errno(syscall.ENXIO)\n+\tE2BIG        Error = Errno(syscall.E2BIG)\n+\tENOEXEC      Error = Errno(syscall.ENOEXEC)\n+\tEBADF        Error = Errno(syscall.EBADF)\n+\tECHILD       Error = Errno(syscall.ECHILD)\n+\tEDEADLK      Error = Errno(syscall.EDEADLK)\n+\tENOMEM       Error = Errno(syscall.ENOMEM)\n+\tEACCES       Error = Errno(syscall.EACCES)\n+\tEFAULT       Error = Errno(syscall.EFAULT)\n+\tEBUSY        Error = Errno(syscall.EBUSY)\n+\tEEXIST       Error = Errno(syscall.EEXIST)\n+\tEXDEV        Error = Errno(syscall.EXDEV)\n+\tENODEV       Error = Errno(syscall.ENODEV)\n+\tENOTDIR      Error = Errno(syscall.ENOTDIR)\n+\tEISDIR       Error = Errno(syscall.EISDIR)\n+\tEINVAL       Error = Errno(syscall.EINVAL)\n+\tENFILE       Error = Errno(syscall.ENFILE)\n+\tEMFILE       Error = Errno(syscall.EMFILE)\n+\tENOTTY       Error = Errno(syscall.ENOTTY)\n+\tEFBIG        Error = Errno(syscall.EFBIG)\n+\tENOSPC       Error = Errno(syscall.ENOSPC)\n+\tESPIPE       Error = Errno(syscall.ESPIPE)\n+\tEROFS        Error = Errno(syscall.EROFS)\n+\tEMLINK       Error = Errno(syscall.EMLINK)\n+\tEPIPE        Error = Errno(syscall.EPIPE)\n+\tEAGAIN       Error = Errno(syscall.EAGAIN)\n+\tEDOM         Error = Errno(syscall.EDOM)\n+\tERANGE       Error = Errno(syscall.ERANGE)\n+\tEADDRINUSE   Error = Errno(syscall.EADDRINUSE)\n+\tECONNREFUSED Error = Errno(syscall.ECONNREFUSED)\n+\tENAMETOOLONG Error = Errno(syscall.ENAMETOOLONG)\n+\tEAFNOSUPPORT Error = Errno(syscall.EAFNOSUPPORT)\n+\tETIMEDOUT    Error = Errno(syscall.ETIMEDOUT)\n+\tENOTCONN     Error = Errno(syscall.ENOTCONN)\n+)\n+\n+// SyscallError records an error from a specific system call.\n+type SyscallError struct {\n+\tSyscall string\n+\tErrno   Errno\n+}\n+\n+func (e *SyscallError) String() string { return e.Syscall + \": \" + e.Errno.String() }\n+\n+// Note: If the name of the function NewSyscallError changes,\n+// pkg/go/doc/doc.go should be adjusted since it hardwires\n+// this name in a heuristic.\n+\n+// NewSyscallError returns, as an Error, a new SyscallError\n+// with the given system call name and error details.\n+// As a convenience, if errno is 0, NewSyscallError returns nil.\n+func NewSyscallError(syscall string, errno int) Error {\n+\tif errno == 0 {\n+\t\treturn nil\n+\t}\n+\treturn &SyscallError{syscall, Errno(errno)}\n+}\n+\n+func iserror(errno int) bool {\n+\treturn errno != 0\n+}"}, {"sha": "f62caf9a069b15b8fa7b10b24f92925a3b3a17d0", "filename": "libgo/go/os/exec.go", "status": "modified", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -39,126 +39,6 @@ type ProcAttr struct {\n \tFiles []*File\n }\n \n-// StartProcess starts a new process with the program, arguments and attributes\n-// specified by name, argv and attr.\n-func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err Error) {\n-\tsysattr := &syscall.ProcAttr{\n-\t\tDir: attr.Dir,\n-\t\tEnv: attr.Env,\n-\t}\n-\tif sysattr.Env == nil {\n-\t\tsysattr.Env = Environ()\n-\t}\n-\t// Create array of integer (system) fds.\n-\tintfd := make([]int, len(attr.Files))\n-\tfor i, f := range attr.Files {\n-\t\tif f == nil {\n-\t\t\tintfd[i] = -1\n-\t\t} else {\n-\t\t\tintfd[i] = f.Fd()\n-\t\t}\n-\t}\n-\tsysattr.Files = intfd\n-\n-\tpid, h, e := syscall.StartProcess(name, argv, sysattr)\n-\tif e != 0 {\n-\t\treturn nil, &PathError{\"fork/exec\", name, Errno(e)}\n-\t}\n-\treturn newProcess(pid, h), nil\n-}\n-\n-// Exec replaces the current process with an execution of the\n-// named binary, with arguments argv and environment envv.\n-// If successful, Exec never returns.  If it fails, it returns an Error.\n-// StartProcess is almost always a better way to execute a program.\n-func Exec(name string, argv []string, envv []string) Error {\n-\tif envv == nil {\n-\t\tenvv = Environ()\n-\t}\n-\te := syscall.Exec(name, argv, envv)\n-\tif e != 0 {\n-\t\treturn &PathError{\"exec\", name, Errno(e)}\n-\t}\n-\treturn nil\n-}\n-\n-// TODO(rsc): Should os implement its own syscall.WaitStatus\n-// wrapper with the methods, or is exposing the underlying one enough?\n-//\n-// TODO(rsc): Certainly need to have Rusage struct,\n-// since syscall one might have different field types across\n-// different OS.\n-\n-// Waitmsg stores the information about an exited process as reported by Wait.\n-type Waitmsg struct {\n-\tPid                int             // The process's id.\n-\tsyscall.WaitStatus                 // System-dependent status info.\n-\tRusage             *syscall.Rusage // System-dependent resource usage info.\n-}\n-\n-// Wait waits for process pid to exit or stop, and then returns a\n-// Waitmsg describing its status and an Error, if any. The options\n-// (WNOHANG etc.) affect the behavior of the Wait call.\n-// Wait is equivalent to calling FindProcess and then Wait\n-// and Release on the result.\n-func Wait(pid int, options int) (w *Waitmsg, err Error) {\n-\tp, e := FindProcess(pid)\n-\tif e != nil {\n-\t\treturn nil, e\n-\t}\n-\tdefer p.Release()\n-\treturn p.Wait(options)\n-}\n-\n-// Convert i to decimal string.\n-func itod(i int) string {\n-\tif i == 0 {\n-\t\treturn \"0\"\n-\t}\n-\n-\tu := uint64(i)\n-\tif i < 0 {\n-\t\tu = -u\n-\t}\n-\n-\t// Assemble decimal in reverse order.\n-\tvar b [32]byte\n-\tbp := len(b)\n-\tfor ; u > 0; u /= 10 {\n-\t\tbp--\n-\t\tb[bp] = byte(u%10) + '0'\n-\t}\n-\n-\tif i < 0 {\n-\t\tbp--\n-\t\tb[bp] = '-'\n-\t}\n-\n-\treturn string(b[bp:])\n-}\n-\n-func (w Waitmsg) String() string {\n-\t// TODO(austin) Use signal names when possible?\n-\tres := \"\"\n-\tswitch {\n-\tcase w.Exited():\n-\t\tres = \"exit status \" + itod(w.ExitStatus())\n-\tcase w.Signaled():\n-\t\tres = \"signal \" + itod(w.Signal())\n-\tcase w.Stopped():\n-\t\tres = \"stop signal \" + itod(w.StopSignal())\n-\t\tif w.StopSignal() == syscall.SIGTRAP && w.TrapCause() != 0 {\n-\t\t\tres += \" (trap \" + itod(w.TrapCause()) + \")\"\n-\t\t}\n-\tcase w.Continued():\n-\t\tres = \"continued\"\n-\t}\n-\tif w.CoreDump() {\n-\t\tres += \" (core dumped)\"\n-\t}\n-\treturn res\n-}\n-\n // Getpid returns the process id of the caller.\n func Getpid() int { return syscall.Getpid() }\n "}, {"sha": "11874aba6779fc37a66df990545cc3089ffbed8c", "filename": "libgo/go/os/exec_plan9.go", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fexec_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fexec_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_plan9.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,114 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+import (\n+\t\"runtime\"\n+\t\"syscall\"\n+)\n+\n+// StartProcess starts a new process with the program, arguments and attributes\n+// specified by name, argv and attr.\n+func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err Error) {\n+\tsysattr := &syscall.ProcAttr{\n+\t\tDir: attr.Dir,\n+\t\tEnv: attr.Env,\n+\t}\n+\n+\t// Create array of integer (system) fds.\n+\tintfd := make([]int, len(attr.Files))\n+\tfor i, f := range attr.Files {\n+\t\tif f == nil {\n+\t\t\tintfd[i] = -1\n+\t\t} else {\n+\t\t\tintfd[i] = f.Fd()\n+\t\t}\n+\t}\n+\n+\tsysattr.Files = intfd\n+\n+\tpid, h, e := syscall.StartProcess(name, argv, sysattr)\n+\tif iserror(e) {\n+\t\treturn nil, &PathError{\"fork/exec\", name, e}\n+\t}\n+\n+\treturn newProcess(pid, h), nil\n+}\n+\n+// Exec replaces the current process with an execution of the\n+// named binary, with arguments argv and environment envv.\n+// If successful, Exec never returns.  If it fails, it returns an Error.\n+// ForkExec is almost always a better way to execute a program.\n+func Exec(name string, argv []string, envv []string) Error {\n+\te := syscall.Exec(name, argv, envv)\n+\tif iserror(e) {\n+\t\treturn &PathError{\"exec\", name, e}\n+\t}\n+\n+\treturn nil\n+}\n+\n+// Waitmsg stores the information about an exited process as reported by Wait.\n+type Waitmsg syscall.Waitmsg\n+\n+// Wait waits for the Process to exit or stop, and then returns a\n+// Waitmsg describing its status and an Error, if any. The options\n+// (WNOHANG etc.) affect the behavior of the Wait call.\n+func (p *Process) Wait(options int) (w *Waitmsg, err Error) {\n+\tvar waitmsg syscall.Waitmsg\n+\n+\tif p.Pid == -1 {\n+\t\treturn nil, EINVAL\n+\t}\n+\n+\tfor true {\n+\t\terr = syscall.Await(&waitmsg)\n+\n+\t\tif iserror(err) {\n+\t\t\treturn nil, NewSyscallError(\"wait\", err)\n+\t\t}\n+\n+\t\tif waitmsg.Pid == p.Pid {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn (*Waitmsg)(&waitmsg), nil\n+}\n+\n+// Wait waits for process pid to exit or stop, and then returns a\n+// Waitmsg describing its status and an Error, if any. The options\n+// (WNOHANG etc.) affect the behavior of the Wait call.\n+// Wait is equivalent to calling FindProcess and then Wait\n+// and Release on the result.\n+func Wait(pid int, options int) (w *Waitmsg, err Error) {\n+\tp, e := FindProcess(pid)\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\tdefer p.Release()\n+\treturn p.Wait(options)\n+}\n+\n+// Release releases any resources associated with the Process.\n+func (p *Process) Release() Error {\n+\t// NOOP for Plan 9.\n+\tp.Pid = -1\n+\t// no need for a finalizer anymore\n+\truntime.SetFinalizer(p, nil)\n+\treturn nil\n+}\n+\n+// FindProcess looks for a running process by its pid.\n+// The Process it returns can be used to obtain information\n+// about the underlying operating system process.\n+func FindProcess(pid int) (p *Process, err Error) {\n+\t// NOOP for Plan 9.\n+\treturn newProcess(pid, 0), nil\n+}\n+\n+func (w Waitmsg) String() string {\n+\treturn \"exit status: \" + w.Msg\n+}"}, {"sha": "9102dc0a4cb283e1bc8cd7b9bee721c8088d5a36", "filename": "libgo/go/os/exec_posix.go", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fexec_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fexec_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec_posix.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,127 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+import \"syscall\"\n+\n+// StartProcess starts a new process with the program, arguments and attributes\n+// specified by name, argv and attr.\n+func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err Error) {\n+\tsysattr := &syscall.ProcAttr{\n+\t\tDir: attr.Dir,\n+\t\tEnv: attr.Env,\n+\t}\n+\tif sysattr.Env == nil {\n+\t\tsysattr.Env = Environ()\n+\t}\n+\t// Create array of integer (system) fds.\n+\tintfd := make([]int, len(attr.Files))\n+\tfor i, f := range attr.Files {\n+\t\tif f == nil {\n+\t\t\tintfd[i] = -1\n+\t\t} else {\n+\t\t\tintfd[i] = f.Fd()\n+\t\t}\n+\t}\n+\tsysattr.Files = intfd\n+\n+\tpid, h, e := syscall.StartProcess(name, argv, sysattr)\n+\tif iserror(e) {\n+\t\treturn nil, &PathError{\"fork/exec\", name, Errno(e)}\n+\t}\n+\treturn newProcess(pid, h), nil\n+}\n+\n+// Exec replaces the current process with an execution of the\n+// named binary, with arguments argv and environment envv.\n+// If successful, Exec never returns.  If it fails, it returns an Error.\n+// StartProcess is almost always a better way to execute a program.\n+func Exec(name string, argv []string, envv []string) Error {\n+\tif envv == nil {\n+\t\tenvv = Environ()\n+\t}\n+\te := syscall.Exec(name, argv, envv)\n+\tif iserror(e) {\n+\t\treturn &PathError{\"exec\", name, Errno(e)}\n+\t}\n+\treturn nil\n+}\n+\n+// TODO(rsc): Should os implement its own syscall.WaitStatus\n+// wrapper with the methods, or is exposing the underlying one enough?\n+//\n+// TODO(rsc): Certainly need to have Rusage struct,\n+// since syscall one might have different field types across\n+// different OS.\n+\n+// Waitmsg stores the information about an exited process as reported by Wait.\n+type Waitmsg struct {\n+\tPid                int             // The process's id.\n+\tsyscall.WaitStatus                 // System-dependent status info.\n+\tRusage             *syscall.Rusage // System-dependent resource usage info.\n+}\n+\n+// Wait waits for process pid to exit or stop, and then returns a\n+// Waitmsg describing its status and an Error, if any. The options\n+// (WNOHANG etc.) affect the behavior of the Wait call.\n+// Wait is equivalent to calling FindProcess and then Wait\n+// and Release on the result.\n+func Wait(pid int, options int) (w *Waitmsg, err Error) {\n+\tp, e := FindProcess(pid)\n+\tif e != nil {\n+\t\treturn nil, e\n+\t}\n+\tdefer p.Release()\n+\treturn p.Wait(options)\n+}\n+\n+// Convert i to decimal string.\n+func itod(i int) string {\n+\tif i == 0 {\n+\t\treturn \"0\"\n+\t}\n+\n+\tu := uint64(i)\n+\tif i < 0 {\n+\t\tu = -u\n+\t}\n+\n+\t// Assemble decimal in reverse order.\n+\tvar b [32]byte\n+\tbp := len(b)\n+\tfor ; u > 0; u /= 10 {\n+\t\tbp--\n+\t\tb[bp] = byte(u%10) + '0'\n+\t}\n+\n+\tif i < 0 {\n+\t\tbp--\n+\t\tb[bp] = '-'\n+\t}\n+\n+\treturn string(b[bp:])\n+}\n+\n+func (w Waitmsg) String() string {\n+\t// TODO(austin) Use signal names when possible?\n+\tres := \"\"\n+\tswitch {\n+\tcase w.Exited():\n+\t\tres = \"exit status \" + itod(w.ExitStatus())\n+\tcase w.Signaled():\n+\t\tres = \"signal \" + itod(w.Signal())\n+\tcase w.Stopped():\n+\t\tres = \"stop signal \" + itod(w.StopSignal())\n+\t\tif w.StopSignal() == syscall.SIGTRAP && w.TrapCause() != 0 {\n+\t\t\tres += \" (trap \" + itod(w.TrapCause()) + \")\"\n+\t\t}\n+\tcase w.Continued():\n+\t\tres = \"continued\"\n+\t}\n+\tif w.CoreDump() {\n+\t\tres += \" (core dumped)\"\n+\t}\n+\treturn res\n+}"}, {"sha": "3aad8023453358517fdede659574941e625af93a", "filename": "libgo/go/os/file.go", "status": "modified", "additions": 36, "deletions": 241, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ffile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ffile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -51,14 +51,20 @@ const (\n \tO_RDWR     int = syscall.O_RDWR     // open the file read-write.\n \tO_APPEND   int = syscall.O_APPEND   // append data to the file when writing.\n \tO_ASYNC    int = syscall.O_ASYNC    // generate a signal when I/O is available.\n-\tO_CREAT    int = syscall.O_CREAT    // create a new file if none exists.\n-\tO_EXCL     int = syscall.O_EXCL     // used with O_CREAT, file must not exist\n+\tO_CREATE   int = syscall.O_CREAT    // create a new file if none exists.\n+\tO_EXCL     int = syscall.O_EXCL     // used with O_CREATE, file must not exist\n \tO_NOCTTY   int = syscall.O_NOCTTY   // do not make file the controlling tty.\n \tO_NONBLOCK int = syscall.O_NONBLOCK // open in non-blocking mode.\n \tO_NDELAY   int = O_NONBLOCK         // synonym for O_NONBLOCK\n \tO_SYNC     int = syscall.O_SYNC     // open for synchronous I/O.\n \tO_TRUNC    int = syscall.O_TRUNC    // if possible, truncate file when opened.\n-\tO_CREATE   int = O_CREAT            // create a new file if none exists.\n+)\n+\n+// Seek whence values.\n+const (\n+\tSEEK_SET int = 0 // seek relative to the origin of the file\n+\tSEEK_CUR int = 1 // seek relative to the current offset\n+\tSEEK_END int = 2 // seek relative to the end\n )\n \n type eofError int\n@@ -83,10 +89,10 @@ func (file *File) Read(b []byte) (n int, err Error) {\n \tif n < 0 {\n \t\tn = 0\n \t}\n-\tif n == 0 && e == 0 {\n+\tif n == 0 && !iserror(e) {\n \t\treturn 0, EOF\n \t}\n-\tif e != 0 {\n+\tif iserror(e) {\n \t\terr = &PathError{\"read\", file.name, Errno(e)}\n \t}\n \treturn n, err\n@@ -102,10 +108,10 @@ func (file *File) ReadAt(b []byte, off int64) (n int, err Error) {\n \t}\n \tfor len(b) > 0 {\n \t\tm, e := syscall.Pread(file.fd, b, off)\n-\t\tif m == 0 && e == 0 {\n+\t\tif m == 0 && !iserror(e) {\n \t\t\treturn n, EOF\n \t\t}\n-\t\tif e != 0 {\n+\t\tif iserror(e) {\n \t\t\terr = &PathError{\"read\", file.name, Errno(e)}\n \t\t\tbreak\n \t\t}\n@@ -127,15 +133,10 @@ func (file *File) Write(b []byte) (n int, err Error) {\n \tif n < 0 {\n \t\tn = 0\n \t}\n-\tif e == syscall.EPIPE {\n-\t\tfile.nepipe++\n-\t\tif file.nepipe >= 10 {\n-\t\t\tExit(syscall.EPIPE)\n-\t\t}\n-\t} else {\n-\t\tfile.nepipe = 0\n-\t}\n-\tif e != 0 {\n+\n+\tepipecheck(file, e)\n+\n+\tif iserror(e) {\n \t\terr = &PathError{\"write\", file.name, Errno(e)}\n \t}\n \treturn n, err\n@@ -150,7 +151,7 @@ func (file *File) WriteAt(b []byte, off int64) (n int, err Error) {\n \t}\n \tfor len(b) > 0 {\n \t\tm, e := syscall.Pwrite(file.fd, b, off)\n-\t\tif e != 0 {\n+\t\tif iserror(e) {\n \t\t\terr = &PathError{\"write\", file.name, Errno(e)}\n \t\t\tbreak\n \t\t}\n@@ -167,10 +168,10 @@ func (file *File) WriteAt(b []byte, off int64) (n int, err Error) {\n // It returns the new offset and an Error, if any.\n func (file *File) Seek(offset int64, whence int) (ret int64, err Error) {\n \tr, e := syscall.Seek(file.fd, offset, whence)\n-\tif e == 0 && file.dirinfo != nil && r != 0 {\n+\tif !iserror(e) && file.dirinfo != nil && r != 0 {\n \t\te = syscall.EISDIR\n \t}\n-\tif e != 0 {\n+\tif iserror(e) {\n \t\treturn 0, &PathError{\"seek\", file.name, Errno(e)}\n \t}\n \treturn r, nil\n@@ -187,71 +188,19 @@ func (file *File) WriteString(s string) (ret int, err Error) {\n \treturn file.Write(b)\n }\n \n-// Pipe returns a connected pair of Files; reads from r return bytes written to w.\n-// It returns the files and an Error, if any.\n-func Pipe() (r *File, w *File, err Error) {\n-\tvar p [2]int\n-\n-\t// See ../syscall/exec.go for description of lock.\n-\tsyscall.ForkLock.RLock()\n-\te := syscall.Pipe(p[0:])\n-\tif e != 0 {\n-\t\tsyscall.ForkLock.RUnlock()\n-\t\treturn nil, nil, NewSyscallError(\"pipe\", e)\n-\t}\n-\tsyscall.CloseOnExec(p[0])\n-\tsyscall.CloseOnExec(p[1])\n-\tsyscall.ForkLock.RUnlock()\n-\n-\treturn NewFile(p[0], \"|0\"), NewFile(p[1], \"|1\"), nil\n-}\n-\n // Mkdir creates a new directory with the specified name and permission bits.\n // It returns an error, if any.\n func Mkdir(name string, perm uint32) Error {\n \te := syscall.Mkdir(name, perm)\n-\tif e != 0 {\n+\tif iserror(e) {\n \t\treturn &PathError{\"mkdir\", name, Errno(e)}\n \t}\n \treturn nil\n }\n \n-// Stat returns a FileInfo structure describing the named file and an error, if any.\n-// If name names a valid symbolic link, the returned FileInfo describes\n-// the file pointed at by the link and has fi.FollowedSymlink set to true.\n-// If name names an invalid symbolic link, the returned FileInfo describes\n-// the link itself and has fi.FollowedSymlink set to false.\n-func Stat(name string) (fi *FileInfo, err Error) {\n-\tvar lstat, stat syscall.Stat_t\n-\te := syscall.Lstat(name, &lstat)\n-\tif e != 0 {\n-\t\treturn nil, &PathError{\"stat\", name, Errno(e)}\n-\t}\n-\tstatp := &lstat\n-\tif lstat.Mode&syscall.S_IFMT == syscall.S_IFLNK {\n-\t\te := syscall.Stat(name, &stat)\n-\t\tif e == 0 {\n-\t\t\tstatp = &stat\n-\t\t}\n-\t}\n-\treturn fileInfoFromStat(name, new(FileInfo), &lstat, statp), nil\n-}\n-\n-// Lstat returns the FileInfo structure describing the named file and an\n-// error, if any.  If the file is a symbolic link, the returned FileInfo\n-// describes the symbolic link.  Lstat makes no attempt to follow the link.\n-func Lstat(name string) (fi *FileInfo, err Error) {\n-\tvar stat syscall.Stat_t\n-\te := syscall.Lstat(name, &stat)\n-\tif e != 0 {\n-\t\treturn nil, &PathError{\"lstat\", name, Errno(e)}\n-\t}\n-\treturn fileInfoFromStat(name, new(FileInfo), &stat, &stat), nil\n-}\n-\n // Chdir changes the current working directory to the named directory.\n func Chdir(dir string) Error {\n-\tif e := syscall.Chdir(dir); e != 0 {\n+\tif e := syscall.Chdir(dir); iserror(e) {\n \t\treturn &PathError{\"chdir\", dir, Errno(e)}\n \t}\n \treturn nil\n@@ -260,179 +209,25 @@ func Chdir(dir string) Error {\n // Chdir changes the current working directory to the file,\n // which must be a directory.\n func (f *File) Chdir() Error {\n-\tif e := syscall.Fchdir(f.fd); e != 0 {\n+\tif e := syscall.Fchdir(f.fd); iserror(e) {\n \t\treturn &PathError{\"chdir\", f.name, Errno(e)}\n \t}\n \treturn nil\n }\n \n-// Remove removes the named file or directory.\n-func Remove(name string) Error {\n-\t// System call interface forces us to know\n-\t// whether name is a file or directory.\n-\t// Try both: it is cheaper on average than\n-\t// doing a Stat plus the right one.\n-\te := syscall.Unlink(name)\n-\tif e == 0 {\n-\t\treturn nil\n-\t}\n-\te1 := syscall.Rmdir(name)\n-\tif e1 == 0 {\n-\t\treturn nil\n-\t}\n-\n-\t// Both failed: figure out which error to return.\n-\t// OS X and Linux differ on whether unlink(dir)\n-\t// returns EISDIR, so can't use that.  However,\n-\t// both agree that rmdir(file) returns ENOTDIR,\n-\t// so we can use that to decide which error is real.\n-\t// Rmdir might also return ENOTDIR if given a bad\n-\t// file path, like /etc/passwd/foo, but in that case,\n-\t// both errors will be ENOTDIR, so it's okay to\n-\t// use the error from unlink.\n-\t// For windows syscall.ENOTDIR is set\n-\t// to syscall.ERROR_DIRECTORY, hopefully it should\n-\t// do the trick.\n-\tif e1 != syscall.ENOTDIR {\n-\t\te = e1\n-\t}\n-\treturn &PathError{\"remove\", name, Errno(e)}\n-}\n-\n-// LinkError records an error during a link or symlink or rename\n-// system call and the paths that caused it.\n-type LinkError struct {\n-\tOp    string\n-\tOld   string\n-\tNew   string\n-\tError Error\n-}\n-\n-func (e *LinkError) String() string {\n-\treturn e.Op + \" \" + e.Old + \" \" + e.New + \": \" + e.Error.String()\n+// Open opens the named file for reading.  If successful, methods on\n+// the returned file can be used for reading; the associated file\n+// descriptor has mode O_RDONLY.\n+// It returns the File and an Error, if any.\n+func Open(name string) (file *File, err Error) {\n+\treturn OpenFile(name, O_RDONLY, 0)\n }\n \n-// Link creates a hard link.\n-func Link(oldname, newname string) Error {\n-\te := syscall.Link(oldname, newname)\n-\tif e != 0 {\n-\t\treturn &LinkError{\"link\", oldname, newname, Errno(e)}\n-\t}\n-\treturn nil\n-}\n-\n-// Symlink creates a symbolic link.\n-func Symlink(oldname, newname string) Error {\n-\te := syscall.Symlink(oldname, newname)\n-\tif e != 0 {\n-\t\treturn &LinkError{\"symlink\", oldname, newname, Errno(e)}\n-\t}\n-\treturn nil\n-}\n-\n-// Readlink reads the contents of a symbolic link: the destination of\n-// the link.  It returns the contents and an Error, if any.\n-func Readlink(name string) (string, Error) {\n-\tfor len := 128; ; len *= 2 {\n-\t\tb := make([]byte, len)\n-\t\tn, e := syscall.Readlink(name, b)\n-\t\tif e != 0 {\n-\t\t\treturn \"\", &PathError{\"readlink\", name, Errno(e)}\n-\t\t}\n-\t\tif n < len {\n-\t\t\treturn string(b[0:n]), nil\n-\t\t}\n-\t}\n-\t// Silence 6g.\n-\treturn \"\", nil\n-}\n-\n-// Rename renames a file.\n-func Rename(oldname, newname string) Error {\n-\te := syscall.Rename(oldname, newname)\n-\tif e != 0 {\n-\t\treturn &LinkError{\"rename\", oldname, newname, Errno(e)}\n-\t}\n-\treturn nil\n-}\n-\n-// Chmod changes the mode of the named file to mode.\n-// If the file is a symbolic link, it changes the mode of the link's target.\n-func Chmod(name string, mode uint32) Error {\n-\tif e := syscall.Chmod(name, mode); e != 0 {\n-\t\treturn &PathError{\"chmod\", name, Errno(e)}\n-\t}\n-\treturn nil\n-}\n-\n-// Chmod changes the mode of the file to mode.\n-func (f *File) Chmod(mode uint32) Error {\n-\tif e := syscall.Fchmod(f.fd, mode); e != 0 {\n-\t\treturn &PathError{\"chmod\", f.name, Errno(e)}\n-\t}\n-\treturn nil\n-}\n-\n-// Chown changes the numeric uid and gid of the named file.\n-// If the file is a symbolic link, it changes the uid and gid of the link's target.\n-func Chown(name string, uid, gid int) Error {\n-\tif e := syscall.Chown(name, uid, gid); e != 0 {\n-\t\treturn &PathError{\"chown\", name, Errno(e)}\n-\t}\n-\treturn nil\n-}\n-\n-// Lchown changes the numeric uid and gid of the named file.\n-// If the file is a symbolic link, it changes the uid and gid of the link itself.\n-func Lchown(name string, uid, gid int) Error {\n-\tif e := syscall.Lchown(name, uid, gid); e != 0 {\n-\t\treturn &PathError{\"lchown\", name, Errno(e)}\n-\t}\n-\treturn nil\n-}\n-\n-// Chown changes the numeric uid and gid of the named file.\n-func (f *File) Chown(uid, gid int) Error {\n-\tif e := syscall.Fchown(f.fd, uid, gid); e != 0 {\n-\t\treturn &PathError{\"chown\", f.name, Errno(e)}\n-\t}\n-\treturn nil\n-}\n-\n-// Truncate changes the size of the file.\n-// It does not change the I/O offset.\n-func (f *File) Truncate(size int64) Error {\n-\tif e := syscall.Ftruncate(f.fd, size); e != 0 {\n-\t\treturn &PathError{\"truncate\", f.name, Errno(e)}\n-\t}\n-\treturn nil\n-}\n-\n-// Sync commits the current contents of the file to stable storage.\n-// Typically, this means flushing the file system's in-memory copy\n-// of recently written data to disk.\n-func (file *File) Sync() (err Error) {\n-\tif file == nil {\n-\t\treturn EINVAL\n-\t}\n-\tif e := syscall.Fsync(file.fd); e != 0 {\n-\t\treturn NewSyscallError(\"fsync\", e)\n-\t}\n-\treturn nil\n-}\n-\n-// Chtimes changes the access and modification times of the named\n-// file, similar to the Unix utime() or utimes() functions.\n-//\n-// The argument times are in nanoseconds, although the underlying\n-// filesystem may truncate or round the values to a more\n-// coarse time unit.\n-func Chtimes(name string, atime_ns int64, mtime_ns int64) Error {\n-\tvar utimes [2]syscall.Timeval\n-\tutimes[0] = syscall.NsecToTimeval(atime_ns)\n-\tutimes[1] = syscall.NsecToTimeval(mtime_ns)\n-\tif e := syscall.Utimes(name, utimes[0:]); e != 0 {\n-\t\treturn &PathError{\"chtimes\", name, Errno(e)}\n-\t}\n-\treturn nil\n+// Create creates the named file mode 0666 (before umask), truncating\n+// it if it already exists.  If successful, methods on the returned\n+// File can be used for I/O; the associated file descriptor has mode\n+// O_RDWR.\n+// It returns the File and an Error, if any.\n+func Create(name string) (file *File, err Error) {\n+\treturn OpenFile(name, O_RDWR|O_CREATE|O_TRUNC, 0666)\n }"}, {"sha": "b79256c51ed1a446a9745ae2a688f6092e4b2465", "filename": "libgo/go/os/file_plan9.go", "status": "added", "additions": 233, "deletions": 0, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ffile_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ffile_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_plan9.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,233 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+import (\n+\t\"runtime\"\n+\t\"syscall\"\n+)\n+\n+func epipecheck(file *File, e syscall.Error) {\n+}\n+\n+\n+// DevNull is the name of the operating system's ``null device.''\n+// On Unix-like systems, it is \"/dev/null\"; on Windows, \"NUL\".\n+const DevNull = \"/dev/null\"\n+\n+// OpenFile is the generalized open call; most users will use Open\n+// or Create instead.  It opens the named file with specified flag\n+// (O_RDONLY etc.) and perm, (0666 etc.) if applicable.  If successful,\n+// methods on the returned File can be used for I/O.\n+// It returns the File and an Error, if any.\n+func OpenFile(name string, flag int, perm uint32) (file *File, err Error) {\n+\tvar fd int\n+\tvar e syscall.Error\n+\n+\tsyscall.ForkLock.RLock()\n+\tif flag&O_CREATE == O_CREATE {\n+\t\tfd, e = syscall.Create(name, flag & ^O_CREATE, perm)\n+\t} else {\n+\t\tfd, e = syscall.Open(name, flag)\n+\t}\n+\tsyscall.ForkLock.RUnlock()\n+\n+\tif e != nil {\n+\t\treturn nil, &PathError{\"open\", name, e}\n+\t}\n+\n+\treturn NewFile(fd, name), nil\n+}\n+\n+// Close closes the File, rendering it unusable for I/O.\n+// It returns an Error, if any.\n+func (file *File) Close() Error {\n+\tif file == nil || file.fd < 0 {\n+\t\treturn Ebadfd\n+\t}\n+\tvar err Error\n+\tsyscall.ForkLock.RLock()\n+\tif e := syscall.Close(file.fd); e != nil {\n+\t\terr = &PathError{\"close\", file.name, e}\n+\t}\n+\tsyscall.ForkLock.RUnlock()\n+\tfile.fd = -1 // so it can't be closed again\n+\n+\t// no need for a finalizer anymore\n+\truntime.SetFinalizer(file, nil)\n+\treturn err\n+}\n+\n+// Stat returns the FileInfo structure describing file.\n+// It returns the FileInfo and an error, if any.\n+func (file *File) Stat() (fi *FileInfo, err Error) {\n+\treturn dirstat(file)\n+}\n+\n+// Truncate changes the size of the file.\n+// It does not change the I/O offset.\n+func (f *File) Truncate(size int64) Error {\n+\tvar d Dir\n+\td.Null()\n+\n+\td.Length = uint64(size)\n+\n+\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); iserror(e) {\n+\t\treturn &PathError{\"truncate\", f.name, e}\n+\t}\n+\treturn nil\n+}\n+\n+// Chmod changes the mode of the file to mode.\n+func (f *File) Chmod(mode uint32) Error {\n+\tvar d Dir\n+\td.Null()\n+\n+\td.Mode = mode & 0777\n+\n+\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); iserror(e) {\n+\t\treturn &PathError{\"chmod\", f.name, e}\n+\t}\n+\treturn nil\n+}\n+\n+// Sync commits the current contents of the file to stable storage.\n+// Typically, this means flushing the file system's in-memory copy\n+// of recently written data to disk.\n+func (f *File) Sync() (err Error) {\n+\tif f == nil {\n+\t\treturn EINVAL\n+\t}\n+\n+\tvar d Dir\n+\td.Null()\n+\n+\tif e := syscall.Fwstat(f.fd, pdir(nil, &d)); iserror(e) {\n+\t\treturn NewSyscallError(\"fsync\", e)\n+\t}\n+\treturn nil\n+}\n+\n+// Truncate changes the size of the named file.\n+// If the file is a symbolic link, it changes the size of the link's target.\n+func Truncate(name string, size int64) Error {\n+\tvar d Dir\n+\td.Null()\n+\n+\td.Length = uint64(size)\n+\n+\tif e := syscall.Wstat(name, pdir(nil, &d)); iserror(e) {\n+\t\treturn &PathError{\"truncate\", name, e}\n+\t}\n+\treturn nil\n+}\n+\n+// Remove removes the named file or directory.\n+func Remove(name string) Error {\n+\tif e := syscall.Remove(name); iserror(e) {\n+\t\treturn &PathError{\"remove\", name, e}\n+\t}\n+\treturn nil\n+}\n+\n+// Rename renames a file.\n+func Rename(oldname, newname string) Error {\n+\tvar d Dir\n+\td.Null()\n+\n+\td.Name = newname\n+\n+\tif e := syscall.Wstat(oldname, pdir(nil, &d)); iserror(e) {\n+\t\treturn &PathError{\"rename\", oldname, e}\n+\t}\n+\treturn nil\n+}\n+\n+// Chmod changes the mode of the named file to mode.\n+func Chmod(name string, mode uint32) Error {\n+\tvar d Dir\n+\td.Null()\n+\n+\td.Mode = mode & 0777\n+\n+\tif e := syscall.Wstat(name, pdir(nil, &d)); iserror(e) {\n+\t\treturn &PathError{\"chmod\", name, e}\n+\t}\n+\treturn nil\n+}\n+\n+// ChownPlan9 changes the uid and gid strings of the named file.\n+func ChownPlan9(name, uid, gid string) Error {\n+\tvar d Dir\n+\td.Null()\n+\n+\td.Uid = uid\n+\td.Gid = gid\n+\n+\tif e := syscall.Wstat(name, pdir(nil, &d)); iserror(e) {\n+\t\treturn &PathError{\"chown_plan9\", name, e}\n+\t}\n+\treturn nil\n+}\n+\n+// Chtimes changes the access and modification times of the named\n+// file, similar to the Unix utime() or utimes() functions.\n+//\n+// The argument times are in nanoseconds, although the underlying\n+// filesystem may truncate or round the values to a more\n+// coarse time unit.\n+func Chtimes(name string, atimeNs int64, mtimeNs int64) Error {\n+\tvar d Dir\n+\td.Null()\n+\n+\td.Atime = uint32(atimeNs / 1e9)\n+\td.Mtime = uint32(mtimeNs / 1e9)\n+\n+\tif e := syscall.Wstat(name, pdir(nil, &d)); iserror(e) {\n+\t\treturn &PathError{\"chtimes\", name, e}\n+\t}\n+\treturn nil\n+}\n+\n+func Pipe() (r *File, w *File, err Error) {\n+\tvar p [2]int\n+\n+\tsyscall.ForkLock.RLock()\n+\tif e := syscall.Pipe(p[0:]); iserror(e) {\n+\t\tsyscall.ForkLock.RUnlock()\n+\t\treturn nil, nil, NewSyscallError(\"pipe\", e)\n+\t}\n+\tsyscall.ForkLock.RUnlock()\n+\n+\treturn NewFile(p[0], \"|0\"), NewFile(p[1], \"|1\"), nil\n+}\n+\n+\n+// not supported on Plan 9\n+\n+// Link creates a hard link.\n+func Link(oldname, newname string) Error {\n+\treturn EPLAN9\n+}\n+\n+func Symlink(oldname, newname string) Error {\n+\treturn EPLAN9\n+}\n+\n+func Readlink(name string) (string, Error) {\n+\treturn \"\", EPLAN9\n+}\n+\n+func Chown(name string, uid, gid int) Error {\n+\treturn EPLAN9\n+}\n+\n+func Lchown(name string, uid, gid int) Error {\n+\treturn EPLAN9\n+}\n+\n+func (f *File) Chown(uid, gid int) Error {\n+\treturn EPLAN9\n+}"}, {"sha": "5151df49873f3cdee420ea13feaf5d2296da70a0", "filename": "libgo/go/os/file_posix.go", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ffile_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ffile_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_posix.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,246 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The os package provides a platform-independent interface to operating\n+// system functionality.  The design is Unix-like.\n+package os\n+\n+import (\n+\t\"syscall\"\n+)\n+\n+func epipecheck(file *File, e int) {\n+\tif e == syscall.EPIPE {\n+\t\tfile.nepipe++\n+\t\tif file.nepipe >= 10 {\n+\t\t\tExit(syscall.EPIPE)\n+\t\t}\n+\t} else {\n+\t\tfile.nepipe = 0\n+\t}\n+}\n+\n+\n+// Pipe returns a connected pair of Files; reads from r return bytes written to w.\n+// It returns the files and an Error, if any.\n+func Pipe() (r *File, w *File, err Error) {\n+\tvar p [2]int\n+\n+\t// See ../syscall/exec.go for description of lock.\n+\tsyscall.ForkLock.RLock()\n+\te := syscall.Pipe(p[0:])\n+\tif iserror(e) {\n+\t\tsyscall.ForkLock.RUnlock()\n+\t\treturn nil, nil, NewSyscallError(\"pipe\", e)\n+\t}\n+\tsyscall.CloseOnExec(p[0])\n+\tsyscall.CloseOnExec(p[1])\n+\tsyscall.ForkLock.RUnlock()\n+\n+\treturn NewFile(p[0], \"|0\"), NewFile(p[1], \"|1\"), nil\n+}\n+\n+// Stat returns a FileInfo structure describing the named file and an error, if any.\n+// If name names a valid symbolic link, the returned FileInfo describes\n+// the file pointed at by the link and has fi.FollowedSymlink set to true.\n+// If name names an invalid symbolic link, the returned FileInfo describes\n+// the link itself and has fi.FollowedSymlink set to false.\n+func Stat(name string) (fi *FileInfo, err Error) {\n+\tvar lstat, stat syscall.Stat_t\n+\te := syscall.Lstat(name, &lstat)\n+\tif iserror(e) {\n+\t\treturn nil, &PathError{\"stat\", name, Errno(e)}\n+\t}\n+\tstatp := &lstat\n+\tif lstat.Mode&syscall.S_IFMT == syscall.S_IFLNK {\n+\t\te := syscall.Stat(name, &stat)\n+\t\tif !iserror(e) {\n+\t\t\tstatp = &stat\n+\t\t}\n+\t}\n+\treturn fileInfoFromStat(name, new(FileInfo), &lstat, statp), nil\n+}\n+\n+// Lstat returns the FileInfo structure describing the named file and an\n+// error, if any.  If the file is a symbolic link, the returned FileInfo\n+// describes the symbolic link.  Lstat makes no attempt to follow the link.\n+func Lstat(name string) (fi *FileInfo, err Error) {\n+\tvar stat syscall.Stat_t\n+\te := syscall.Lstat(name, &stat)\n+\tif iserror(e) {\n+\t\treturn nil, &PathError{\"lstat\", name, Errno(e)}\n+\t}\n+\treturn fileInfoFromStat(name, new(FileInfo), &stat, &stat), nil\n+}\n+\n+// Remove removes the named file or directory.\n+func Remove(name string) Error {\n+\t// System call interface forces us to know\n+\t// whether name is a file or directory.\n+\t// Try both: it is cheaper on average than\n+\t// doing a Stat plus the right one.\n+\te := syscall.Unlink(name)\n+\tif !iserror(e) {\n+\t\treturn nil\n+\t}\n+\te1 := syscall.Rmdir(name)\n+\tif !iserror(e1) {\n+\t\treturn nil\n+\t}\n+\n+\t// Both failed: figure out which error to return.\n+\t// OS X and Linux differ on whether unlink(dir)\n+\t// returns EISDIR, so can't use that.  However,\n+\t// both agree that rmdir(file) returns ENOTDIR,\n+\t// so we can use that to decide which error is real.\n+\t// Rmdir might also return ENOTDIR if given a bad\n+\t// file path, like /etc/passwd/foo, but in that case,\n+\t// both errors will be ENOTDIR, so it's okay to\n+\t// use the error from unlink.\n+\t// For windows syscall.ENOTDIR is set\n+\t// to syscall.ERROR_DIRECTORY, hopefully it should\n+\t// do the trick.\n+\tif e1 != syscall.ENOTDIR {\n+\t\te = e1\n+\t}\n+\treturn &PathError{\"remove\", name, Errno(e)}\n+}\n+\n+// LinkError records an error during a link or symlink or rename\n+// system call and the paths that caused it.\n+type LinkError struct {\n+\tOp    string\n+\tOld   string\n+\tNew   string\n+\tError Error\n+}\n+\n+func (e *LinkError) String() string {\n+\treturn e.Op + \" \" + e.Old + \" \" + e.New + \": \" + e.Error.String()\n+}\n+\n+// Link creates a hard link.\n+func Link(oldname, newname string) Error {\n+\te := syscall.Link(oldname, newname)\n+\tif iserror(e) {\n+\t\treturn &LinkError{\"link\", oldname, newname, Errno(e)}\n+\t}\n+\treturn nil\n+}\n+\n+// Symlink creates a symbolic link.\n+func Symlink(oldname, newname string) Error {\n+\te := syscall.Symlink(oldname, newname)\n+\tif iserror(e) {\n+\t\treturn &LinkError{\"symlink\", oldname, newname, Errno(e)}\n+\t}\n+\treturn nil\n+}\n+\n+// Readlink reads the contents of a symbolic link: the destination of\n+// the link.  It returns the contents and an Error, if any.\n+func Readlink(name string) (string, Error) {\n+\tfor len := 128; ; len *= 2 {\n+\t\tb := make([]byte, len)\n+\t\tn, e := syscall.Readlink(name, b)\n+\t\tif iserror(e) {\n+\t\t\treturn \"\", &PathError{\"readlink\", name, Errno(e)}\n+\t\t}\n+\t\tif n < len {\n+\t\t\treturn string(b[0:n]), nil\n+\t\t}\n+\t}\n+\t// Silence 6g.\n+\treturn \"\", nil\n+}\n+\n+// Rename renames a file.\n+func Rename(oldname, newname string) Error {\n+\te := syscall.Rename(oldname, newname)\n+\tif iserror(e) {\n+\t\treturn &LinkError{\"rename\", oldname, newname, Errno(e)}\n+\t}\n+\treturn nil\n+}\n+\n+// Chmod changes the mode of the named file to mode.\n+// If the file is a symbolic link, it changes the mode of the link's target.\n+func Chmod(name string, mode uint32) Error {\n+\tif e := syscall.Chmod(name, mode); iserror(e) {\n+\t\treturn &PathError{\"chmod\", name, Errno(e)}\n+\t}\n+\treturn nil\n+}\n+\n+// Chmod changes the mode of the file to mode.\n+func (f *File) Chmod(mode uint32) Error {\n+\tif e := syscall.Fchmod(f.fd, mode); iserror(e) {\n+\t\treturn &PathError{\"chmod\", f.name, Errno(e)}\n+\t}\n+\treturn nil\n+}\n+\n+// Chown changes the numeric uid and gid of the named file.\n+// If the file is a symbolic link, it changes the uid and gid of the link's target.\n+func Chown(name string, uid, gid int) Error {\n+\tif e := syscall.Chown(name, uid, gid); iserror(e) {\n+\t\treturn &PathError{\"chown\", name, Errno(e)}\n+\t}\n+\treturn nil\n+}\n+\n+// Lchown changes the numeric uid and gid of the named file.\n+// If the file is a symbolic link, it changes the uid and gid of the link itself.\n+func Lchown(name string, uid, gid int) Error {\n+\tif e := syscall.Lchown(name, uid, gid); iserror(e) {\n+\t\treturn &PathError{\"lchown\", name, Errno(e)}\n+\t}\n+\treturn nil\n+}\n+\n+// Chown changes the numeric uid and gid of the named file.\n+func (f *File) Chown(uid, gid int) Error {\n+\tif e := syscall.Fchown(f.fd, uid, gid); iserror(e) {\n+\t\treturn &PathError{\"chown\", f.name, Errno(e)}\n+\t}\n+\treturn nil\n+}\n+\n+// Truncate changes the size of the file.\n+// It does not change the I/O offset.\n+func (f *File) Truncate(size int64) Error {\n+\tif e := syscall.Ftruncate(f.fd, size); iserror(e) {\n+\t\treturn &PathError{\"truncate\", f.name, Errno(e)}\n+\t}\n+\treturn nil\n+}\n+\n+// Sync commits the current contents of the file to stable storage.\n+// Typically, this means flushing the file system's in-memory copy\n+// of recently written data to disk.\n+func (file *File) Sync() (err Error) {\n+\tif file == nil {\n+\t\treturn EINVAL\n+\t}\n+\tif e := syscall.Fsync(file.fd); iserror(e) {\n+\t\treturn NewSyscallError(\"fsync\", e)\n+\t}\n+\treturn nil\n+}\n+\n+// Chtimes changes the access and modification times of the named\n+// file, similar to the Unix utime() or utimes() functions.\n+//\n+// The argument times are in nanoseconds, although the underlying\n+// filesystem may truncate or round the values to a more\n+// coarse time unit.\n+func Chtimes(name string, atime_ns int64, mtime_ns int64) Error {\n+\tvar utimes [2]syscall.Timeval\n+\tutimes[0] = syscall.NsecToTimeval(atime_ns)\n+\tutimes[1] = syscall.NsecToTimeval(mtime_ns)\n+\tif e := syscall.Utimes(name, utimes[0:]); iserror(e) {\n+\t\treturn &PathError{\"chtimes\", name, Errno(e)}\n+\t}\n+\treturn nil\n+}"}, {"sha": "f80f1d538ef59ed2fc696e2d4b7f052036d6441d", "filename": "libgo/go/os/file_unix.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ffile_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ffile_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ffile_unix.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -19,10 +19,12 @@ type dirInfo struct {\n // On Unix-like systems, it is \"/dev/null\"; on Windows, \"NUL\".\n const DevNull = \"/dev/null\"\n \n-// Open opens the named file with specified flag (O_RDONLY etc.) and perm, (0666 etc.)\n-// if applicable.  If successful, methods on the returned File can be used for I/O.\n+// OpenFile is the generalized open call; most users will use Open\n+// or Create instead.  It opens the named file with specified flag\n+// (O_RDONLY etc.) and perm, (0666 etc.) if applicable.  If successful,\n+// methods on the returned File can be used for I/O.\n // It returns the File and an Error, if any.\n-func Open(name string, flag int, perm uint32) (file *File, err Error) {\n+func OpenFile(name string, flag int, perm uint32) (file *File, err Error) {\n \tr, e := syscall.Open(name, flag|syscall.O_CLOEXEC, perm)\n \tif e != 0 {\n \t\treturn nil, &PathError{\"open\", name, Errno(e)}"}, {"sha": "4c142ad3abbf453b7ec9a8cbe2d4355f6b3ad35b", "filename": "libgo/go/os/getwd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fgetwd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fgetwd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fgetwd.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -54,7 +54,7 @@ func Getwd() (string, Error) {\n \t\tif len(parent) >= 1024 { // Sanity check\n \t\t\treturn \"\", ENAMETOOLONG\n \t\t}\n-\t\tfd, err := Open(parent, O_RDONLY, 0)\n+\t\tfd, err := Open(parent)\n \t\tif err != nil {\n \t\t\treturn \"\", err\n \t\t}"}, {"sha": "f5d1f8384df5533fdff33c18803658b20f80ef07", "filename": "libgo/go/os/inotify/inotify_linux_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -51,7 +51,7 @@ func TestInotifyEvents(t *testing.T) {\n \n \t// Create a file\n \t// This should add at least one event to the inotify event queue\n-\t_, err = os.Open(testFile, os.O_WRONLY|os.O_CREAT, 0666)\n+\t_, err = os.OpenFile(testFile, os.O_WRONLY|os.O_CREATE, 0666)\n \tif err != nil {\n \t\tt.Fatalf(\"creating test file failed: %s\", err)\n \t}"}, {"sha": "607a11be334f0da1733d497ee2f220ff9ff06df9", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -17,6 +17,7 @@ import (\n )\n \n var dot = []string{\n+\t\"dir_unix.go\",\n \t\"env_unix.go\",\n \t\"error.go\",\n \t\"file.go\",\n@@ -56,7 +57,7 @@ var sysdir = func() (sd *sysDir) {\n }()\n \n func size(name string, t *testing.T) int64 {\n-\tfile, err := Open(name, O_RDONLY, 0)\n+\tfile, err := Open(name)\n \tdefer file.Close()\n \tif err != nil {\n \t\tt.Fatal(\"open failed:\", err)\n@@ -121,7 +122,7 @@ func TestStat(t *testing.T) {\n \n func TestFstat(t *testing.T) {\n \tpath := sfdir + \"/\" + sfname\n-\tfile, err1 := Open(path, O_RDONLY, 0)\n+\tfile, err1 := Open(path)\n \tdefer file.Close()\n \tif err1 != nil {\n \t\tt.Fatal(\"open failed:\", err1)\n@@ -155,7 +156,7 @@ func TestLstat(t *testing.T) {\n }\n \n func testReaddirnames(dir string, contents []string, t *testing.T) {\n-\tfile, err := Open(dir, O_RDONLY, 0)\n+\tfile, err := Open(dir)\n \tdefer file.Close()\n \tif err != nil {\n \t\tt.Fatalf(\"open %q failed: %v\", dir, err)\n@@ -184,7 +185,7 @@ func testReaddirnames(dir string, contents []string, t *testing.T) {\n }\n \n func testReaddir(dir string, contents []string, t *testing.T) {\n-\tfile, err := Open(dir, O_RDONLY, 0)\n+\tfile, err := Open(dir)\n \tdefer file.Close()\n \tif err != nil {\n \t\tt.Fatalf(\"open %q failed: %v\", dir, err)\n@@ -245,7 +246,7 @@ func TestReaddirnamesOneAtATime(t *testing.T) {\n \tif syscall.OS == \"windows\" {\n \t\tdir = Getenv(\"SystemRoot\") + \"\\\\system32\"\n \t}\n-\tfile, err := Open(dir, O_RDONLY, 0)\n+\tfile, err := Open(dir)\n \tdefer file.Close()\n \tif err != nil {\n \t\tt.Fatalf(\"open %q failed: %v\", dir, err)\n@@ -254,7 +255,7 @@ func TestReaddirnamesOneAtATime(t *testing.T) {\n \tif err1 != nil {\n \t\tt.Fatalf(\"readdirnames %q failed: %v\", dir, err1)\n \t}\n-\tfile1, err2 := Open(dir, O_RDONLY, 0)\n+\tfile1, err2 := Open(dir)\n \tif err2 != nil {\n \t\tt.Fatalf(\"open %q failed: %v\", dir, err2)\n \t}\n@@ -273,7 +274,7 @@ func TestHardLink(t *testing.T) {\n \t}\n \tfrom, to := \"hardlinktestfrom\", \"hardlinktestto\"\n \tRemove(from) // Just in case.\n-\tfile, err := Open(to, O_CREAT|O_WRONLY, 0666)\n+\tfile, err := Create(to)\n \tif err != nil {\n \t\tt.Fatalf(\"open %q failed: %v\", to, err)\n \t}\n@@ -306,7 +307,7 @@ func TestSymLink(t *testing.T) {\n \t}\n \tfrom, to := \"symlinktestfrom\", \"symlinktestto\"\n \tRemove(from) // Just in case.\n-\tfile, err := Open(to, O_CREAT|O_WRONLY, 0666)\n+\tfile, err := Create(to)\n \tif err != nil {\n \t\tt.Fatalf(\"open %q failed: %v\", to, err)\n \t}\n@@ -354,7 +355,7 @@ func TestSymLink(t *testing.T) {\n \tif s != to {\n \t\tt.Fatalf(\"after symlink %q != %q\", s, to)\n \t}\n-\tfile, err = Open(from, O_RDONLY, 0)\n+\tfile, err = Open(from)\n \tif err != nil {\n \t\tt.Fatalf(\"open %q failed: %v\", from, err)\n \t}\n@@ -388,7 +389,7 @@ func TestLongSymlink(t *testing.T) {\n func TestRename(t *testing.T) {\n \tfrom, to := \"renamefrom\", \"renameto\"\n \tRemove(to) // Just in case.\n-\tfile, err := Open(from, O_CREAT|O_WRONLY, 0666)\n+\tfile, err := Create(from)\n \tif err != nil {\n \t\tt.Fatalf(\"open %q failed: %v\", to, err)\n \t}\n@@ -615,7 +616,7 @@ func TestChdirAndGetwd(t *testing.T) {\n \tif syscall.OS == \"windows\" {\n \t\treturn\n \t}\n-\tfd, err := Open(\".\", O_RDONLY, 0)\n+\tfd, err := Open(\".\")\n \tif err != nil {\n \t\tt.Fatalf(\"Open .: %s\", err)\n \t}\n@@ -627,7 +628,7 @@ func TestChdirAndGetwd(t *testing.T) {\n \t\t\tif mode == 0 {\n \t\t\t\terr = Chdir(d)\n \t\t\t} else {\n-\t\t\t\tfd1, err := Open(d, O_RDONLY, 0)\n+\t\t\t\tfd1, err := Open(d)\n \t\t\t\tif err != nil {\n \t\t\t\t\tt.Errorf(\"Open %s: %s\", d, err)\n \t\t\t\t\tcontinue\n@@ -736,7 +737,7 @@ var openErrorTests = []openErrorTest{\n \n func TestOpenError(t *testing.T) {\n \tfor _, tt := range openErrorTests {\n-\t\tf, err := Open(tt.path, tt.mode, 0)\n+\t\tf, err := OpenFile(tt.path, tt.mode, 0)\n \t\tif err == nil {\n \t\t\tt.Errorf(\"Open(%q, %d) succeeded\", tt.path, tt.mode)\n \t\t\tf.Close()\n@@ -842,7 +843,7 @@ func TestWriteAt(t *testing.T) {\n }\n \n func writeFile(t *testing.T, fname string, flag int, text string) string {\n-\tf, err := Open(fname, flag, 0666)\n+\tf, err := OpenFile(fname, flag, 0666)\n \tif err != nil {\n \t\tt.Fatalf(\"Open: %v\", err)\n \t}\n@@ -861,7 +862,7 @@ func writeFile(t *testing.T, fname string, flag int, text string) string {\n func TestAppend(t *testing.T) {\n \tconst f = \"append.txt\"\n \tdefer Remove(f)\n-\ts := writeFile(t, f, O_CREAT|O_TRUNC|O_RDWR, \"new\")\n+\ts := writeFile(t, f, O_CREATE|O_TRUNC|O_RDWR, \"new\")\n \tif s != \"new\" {\n \t\tt.Fatalf(\"writeFile: have %q want %q\", s, \"new\")\n \t}"}, {"sha": "0eb3ee50369b98d1f986915181065c811e018304", "filename": "libgo/go/os/path.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -33,7 +33,7 @@ func MkdirAll(path string, perm uint32) Error {\n \t\tj--\n \t}\n \n-\tif j > 0 {\n+\tif j > 1 {\n \t\t// Create parent\n \t\terr = MkdirAll(path[0:j-1], perm)\n \t\tif err != nil {\n@@ -80,7 +80,7 @@ func RemoveAll(path string) Error {\n \t}\n \n \t// Directory.\n-\tfd, err := Open(path, O_RDONLY, 0)\n+\tfd, err := Open(path)\n \tif err != nil {\n \t\treturn err\n \t}"}, {"sha": "483bb639535ddbc748c0b366d249a70fd8e3c23f", "filename": "libgo/go/os/path_test.go", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -29,7 +29,7 @@ func TestMkdirAll(t *testing.T) {\n \n \t// Make file.\n \tfpath := path + \"/file\"\n-\t_, err = Open(fpath, O_WRONLY|O_CREAT, 0666)\n+\t_, err = Create(fpath)\n \tif err != nil {\n \t\tt.Fatalf(\"create %q: %s\", fpath, err)\n \t}\n@@ -72,7 +72,7 @@ func TestRemoveAll(t *testing.T) {\n \tif err := MkdirAll(path, 0777); err != nil {\n \t\tt.Fatalf(\"MkdirAll %q: %s\", path, err)\n \t}\n-\tfd, err := Open(fpath, O_WRONLY|O_CREAT, 0666)\n+\tfd, err := Create(fpath)\n \tif err != nil {\n \t\tt.Fatalf(\"create %q: %s\", fpath, err)\n \t}\n@@ -88,12 +88,12 @@ func TestRemoveAll(t *testing.T) {\n \tif err = MkdirAll(dpath, 0777); err != nil {\n \t\tt.Fatalf(\"MkdirAll %q: %s\", dpath, err)\n \t}\n-\tfd, err = Open(fpath, O_WRONLY|O_CREAT, 0666)\n+\tfd, err = Create(fpath)\n \tif err != nil {\n \t\tt.Fatalf(\"create %q: %s\", fpath, err)\n \t}\n \tfd.Close()\n-\tfd, err = Open(dpath+\"/file\", O_WRONLY|O_CREAT, 0666)\n+\tfd, err = Create(dpath + \"/file\")\n \tif err != nil {\n \t\tt.Fatalf(\"create %q: %s\", fpath, err)\n \t}\n@@ -121,7 +121,7 @@ func TestRemoveAll(t *testing.T) {\n \t\t}\n \n \t\tfor _, s := range []string{fpath, dpath + \"/file1\", path + \"/zzz\"} {\n-\t\t\tfd, err = Open(s, O_WRONLY|O_CREAT, 0666)\n+\t\t\tfd, err = Create(s)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatalf(\"create %q: %s\", s, err)\n \t\t\t}\n@@ -179,3 +179,20 @@ func TestMkdirAllWithSymlink(t *testing.T) {\n \t\tt.Errorf(\"MkdirAll %q: %s\", path, err)\n \t}\n }\n+\n+func TestMkdirAllAtSlash(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\treturn\n+\t}\n+\tRemoveAll(\"/_go_os_test\")\n+\terr := MkdirAll(\"/_go_os_test/dir\", 0777)\n+\tif err != nil {\n+\t\tpathErr, ok := err.(*PathError)\n+\t\t// common for users not to be able to write to /\n+\t\tif ok && pathErr.Error == EACCES {\n+\t\t\treturn\n+\t\t}\n+\t\tt.Fatalf(`MkdirAll \"/_go_os_test/dir\": %v`, err)\n+\t}\n+\tRemoveAll(\"/_go_os_test\")\n+}"}, {"sha": "481ef603371b407586264bd7f27f4b7c6de5ea74", "filename": "libgo/go/os/proc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fproc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fproc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fproc.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -26,8 +26,8 @@ func Getegid() int { return syscall.Getegid() }\n \n // Getgroups returns a list of the numeric ids of groups that the caller belongs to.\n func Getgroups() ([]int, Error) {\n-\tgids, errno := syscall.Getgroups()\n-\treturn gids, NewSyscallError(\"getgroups\", errno)\n+\tgids, e := syscall.Getgroups()\n+\treturn gids, NewSyscallError(\"getgroups\", e)\n }\n \n // Exit causes the current program to exit with the given status code."}, {"sha": "e96749d33f339e0c8e5338e9aafe5ad92062b17c", "filename": "libgo/go/os/stat_plan9.go", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fstat_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fstat_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_plan9.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,84 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package os\n+\n+import \"syscall\"\n+\n+func fileInfoFromStat(fi *FileInfo, d *Dir) *FileInfo {\n+\tfi.Dev = uint64(d.Qid.Vers) | uint64(d.Qid.Type<<32)\n+\tfi.Ino = d.Qid.Path\n+\n+\tfi.Mode = uint32(d.Mode) & 0777\n+\tif (d.Mode & syscall.DMDIR) == syscall.DMDIR {\n+\t\tfi.Mode |= syscall.S_IFDIR\n+\t} else {\n+\t\tfi.Mode |= syscall.S_IFREG\n+\t}\n+\n+\tfi.Size = int64(d.Length)\n+\tfi.Atime_ns = 1e9 * int64(d.Atime)\n+\tfi.Mtime_ns = 1e9 * int64(d.Mtime)\n+\tfi.Name = d.Name\n+\tfi.FollowedSymlink = false\n+\treturn fi\n+}\n+\n+// arg is an open *File or a path string. \n+func dirstat(arg interface{}) (fi *FileInfo, err Error) {\n+\tvar name string\n+\tnd := syscall.STATFIXLEN + 16*4\n+\n+\tfor i := 0; i < 2; i++ { /* should work by the second try */\n+\t\tbuf := make([]byte, nd)\n+\n+\t\tvar n int\n+\t\tvar e syscall.Error\n+\n+\t\tswitch syscallArg := arg.(type) {\n+\t\tcase *File:\n+\t\t\tname = syscallArg.name\n+\t\t\tn, e = syscall.Fstat(syscallArg.fd, buf)\n+\t\tcase string:\n+\t\t\tname = syscallArg\n+\t\t\tn, e = syscall.Stat(name, buf)\n+\t\t}\n+\n+\t\tif e != nil {\n+\t\t\treturn nil, &PathError{\"stat\", name, e}\n+\t\t}\n+\n+\t\tif n < syscall.STATFIXLEN {\n+\t\t\treturn nil, &PathError{\"stat\", name, Eshortstat}\n+\t\t}\n+\n+\t\tntmp, _ := gbit16(buf)\n+\t\tnd = int(ntmp)\n+\n+\t\tif nd <= n {\n+\t\t\td, e := UnmarshalDir(buf[:n])\n+\n+\t\t\tif e != nil {\n+\t\t\t\treturn nil, &PathError{\"stat\", name, e}\n+\t\t\t}\n+\n+\t\t\treturn fileInfoFromStat(new(FileInfo), d), nil\n+\t\t}\n+\t}\n+\n+\treturn nil, &PathError{\"stat\", name, Ebadstat}\n+}\n+\n+\n+// Stat returns a FileInfo structure describing the named file and an error, if any.\n+func Stat(name string) (fi *FileInfo, err Error) {\n+\treturn dirstat(name)\n+}\n+\n+// Lstat returns the FileInfo structure describing the named file and an\n+// error, if any.  If the file is a symbolic link (though Plan 9 does not have symbolic links), \n+// the returned FileInfo describes the symbolic link.  Lstat makes no attempt to follow the link.\n+func Lstat(name string) (fi *FileInfo, err Error) {\n+\treturn dirstat(name)\n+}"}, {"sha": "408d667c7cf1e2d5425fabe580208260a6fcb372", "filename": "libgo/go/os/sys_linux.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fsys_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fsys_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsys_linux.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -9,7 +9,7 @@ package os\n \n // Hostname returns the host name reported by the kernel.\n func Hostname() (name string, err Error) {\n-\tf, err := Open(\"/proc/sys/kernel/hostname\", O_RDONLY, 0)\n+\tf, err := Open(\"/proc/sys/kernel/hostname\")\n \tif err != nil {\n \t\treturn \"\", err\n \t}"}, {"sha": "f6af28b611601e61de78cd3d93e0a5d4d8b8b927", "filename": "libgo/go/os/sys_plan9.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fsys_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Fsys_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fsys_plan9.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Plan 9-specific\n+\n+package os\n+\n+\n+func Hostname() (name string, err Error) {\n+\tf, err := Open(\"#c/sysname\")\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tdefer f.Close()\n+\n+\tvar buf [128]byte\n+\tn, err := f.Read(buf[:len(buf)-1])\n+\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\tif n > 0 {\n+\t\tbuf[n] = 0\n+\t}\n+\treturn string(buf[0:n]), nil\n+}"}, {"sha": "8e87a49e1627171c3a43fba5f93decdcc2d1004a", "filename": "libgo/go/os/time.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fos%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftime.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -13,8 +13,8 @@ import \"syscall\"\n // time is the Unix epoch.\n func Time() (sec int64, nsec int64, err Error) {\n \tvar tv syscall.Timeval\n-\tif errno := syscall.Gettimeofday(&tv); errno != 0 {\n-\t\treturn 0, 0, NewSyscallError(\"gettimeofday\", errno)\n+\tif e := syscall.Gettimeofday(&tv); iserror(e) {\n+\t\treturn 0, 0, NewSyscallError(\"gettimeofday\", e)\n \t}\n \treturn int64(tv.Sec), int64(tv.Usec) * 1000, err\n }"}, {"sha": "a05bb5f7e71d6c050cb3df885b7545653b8085ed", "filename": "libgo/go/path/filepath/match.go", "status": "modified", "additions": 34, "deletions": 21, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -32,7 +32,7 @@ var ErrBadPattern = os.NewError(\"syntax error in pattern\")\n //\t\tlo '-' hi   matches character c for lo <= c <= hi\n //\n // Match requires pattern to match all of name, not just a substring.\n-// The only possible error return is when pattern is malformed.\n+// The only possible error return occurs when the pattern is malformed.\n //\n func Match(pattern, name string) (matched bool, err os.Error) {\n Pattern:\n@@ -211,13 +211,14 @@ func getEsc(chunk string) (r int, nchunk string, err os.Error) {\n // if there is no matching file. The syntax of patterns is the same\n // as in Match. The pattern may describe hierarchical names such as\n // /usr/*/bin/ed (assuming the Separator is '/').\n+// The only possible error return occurs when the pattern is malformed.\n //\n-func Glob(pattern string) (matches []string) {\n+func Glob(pattern string) (matches []string, err os.Error) {\n \tif !hasMeta(pattern) {\n-\t\tif _, err := os.Stat(pattern); err == nil {\n-\t\t\treturn []string{pattern}\n+\t\tif _, err = os.Stat(pattern); err != nil {\n+\t\t\treturn\n \t\t}\n-\t\treturn nil\n+\t\treturn []string{pattern}, nil\n \t}\n \n \tdir, file := Split(pattern)\n@@ -230,48 +231,60 @@ func Glob(pattern string) (matches []string) {\n \t\tdir = dir[0 : len(dir)-1] // chop off trailing separator\n \t}\n \n-\tif hasMeta(dir) {\n-\t\tfor _, d := range Glob(dir) {\n-\t\t\tmatches = glob(d, file, matches)\n-\t\t}\n-\t} else {\n+\tif !hasMeta(dir) {\n \t\treturn glob(dir, file, nil)\n \t}\n-\treturn matches\n+\n+\tvar m []string\n+\tm, err = Glob(dir)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tfor _, d := range m {\n+\t\tmatches, err = glob(d, file, matches)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn\n }\n \n // glob searches for files matching pattern in the directory dir\n-// and appends them to matches.\n-func glob(dir, pattern string, matches []string) []string {\n+// and appends them to matches. If the directory cannot be\n+// opened, it returns the existing matches. New matches are\n+// added in lexicographical order.\n+// The only possible error return occurs when the pattern is malformed.\n+func glob(dir, pattern string, matches []string) (m []string, e os.Error) {\n+\tm = matches\n \tfi, err := os.Stat(dir)\n \tif err != nil {\n-\t\treturn nil\n+\t\treturn\n \t}\n \tif !fi.IsDirectory() {\n-\t\treturn matches\n+\t\treturn\n \t}\n-\td, err := os.Open(dir, os.O_RDONLY, 0666)\n+\td, err := os.Open(dir)\n \tif err != nil {\n-\t\treturn nil\n+\t\treturn\n \t}\n \tdefer d.Close()\n \n \tnames, err := d.Readdirnames(-1)\n \tif err != nil {\n-\t\treturn nil\n+\t\treturn\n \t}\n \tsort.SortStrings(names)\n \n \tfor _, n := range names {\n \t\tmatched, err := Match(pattern, n)\n \t\tif err != nil {\n-\t\t\treturn matches\n+\t\t\treturn m, err\n \t\t}\n \t\tif matched {\n-\t\t\tmatches = append(matches, Join(dir, n))\n+\t\t\tm = append(m, Join(dir, n))\n \t\t}\n \t}\n-\treturn matches\n+\treturn\n }\n \n // hasMeta returns true if path contains any of the magic characters"}, {"sha": "0b594fa66e295c7be5ae4f9253aaa49ea6098006", "filename": "libgo/go/path/filepath/match_test.go", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -6,7 +6,7 @@ package filepath_test\n \n import (\n \t\"os\"\n-\t\"path/filepath\"\n+\t. \"path/filepath\"\n \t\"testing\"\n \t\"runtime\"\n )\n@@ -56,16 +56,16 @@ var matchTests = []MatchTest{\n \t{\"[\\\\-x]\", \"x\", true, nil},\n \t{\"[\\\\-x]\", \"-\", true, nil},\n \t{\"[\\\\-x]\", \"a\", false, nil},\n-\t{\"[]a]\", \"]\", false, filepath.ErrBadPattern},\n-\t{\"[-]\", \"-\", false, filepath.ErrBadPattern},\n-\t{\"[x-]\", \"x\", false, filepath.ErrBadPattern},\n-\t{\"[x-]\", \"-\", false, filepath.ErrBadPattern},\n-\t{\"[x-]\", \"z\", false, filepath.ErrBadPattern},\n-\t{\"[-x]\", \"x\", false, filepath.ErrBadPattern},\n-\t{\"[-x]\", \"-\", false, filepath.ErrBadPattern},\n-\t{\"[-x]\", \"a\", false, filepath.ErrBadPattern},\n-\t{\"\\\\\", \"a\", false, filepath.ErrBadPattern},\n-\t{\"[a-b-c]\", \"a\", false, filepath.ErrBadPattern},\n+\t{\"[]a]\", \"]\", false, ErrBadPattern},\n+\t{\"[-]\", \"-\", false, ErrBadPattern},\n+\t{\"[x-]\", \"x\", false, ErrBadPattern},\n+\t{\"[x-]\", \"-\", false, ErrBadPattern},\n+\t{\"[x-]\", \"z\", false, ErrBadPattern},\n+\t{\"[-x]\", \"x\", false, ErrBadPattern},\n+\t{\"[-x]\", \"-\", false, ErrBadPattern},\n+\t{\"[-x]\", \"a\", false, ErrBadPattern},\n+\t{\"\\\\\", \"a\", false, ErrBadPattern},\n+\t{\"[a-b-c]\", \"a\", false, ErrBadPattern},\n \t{\"*x\", \"xxx\", true, nil},\n }\n \n@@ -75,7 +75,7 @@ func TestMatch(t *testing.T) {\n \t\treturn\n \t}\n \tfor _, tt := range matchTests {\n-\t\tok, err := filepath.Match(tt.pattern, tt.s)\n+\t\tok, err := Match(tt.pattern, tt.s)\n \t\tif ok != tt.match || err != tt.err {\n \t\t\tt.Errorf(\"Match(%#q, %#q) = %v, %v want %v, nil\", tt.pattern, tt.s, ok, err, tt.match)\n \t\t}\n@@ -84,7 +84,7 @@ func TestMatch(t *testing.T) {\n \n // contains returns true if vector contains the string s.\n func contains(vector []string, s string) bool {\n-\ts = filepath.ToSlash(s)\n+\ts = ToSlash(s)\n \tfor _, elem := range vector {\n \t\tif elem == s {\n \t\t\treturn true\n@@ -109,9 +109,20 @@ func TestGlob(t *testing.T) {\n \t\treturn\n \t}\n \tfor _, tt := range globTests {\n-\t\tmatches := filepath.Glob(tt.pattern)\n+\t\tmatches, err := Glob(tt.pattern)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Glob error for %q: %s\", tt.pattern, err)\n+\t\t\tcontinue\n+\t\t}\n \t\tif !contains(matches, tt.result) {\n \t\t\tt.Errorf(\"Glob(%#q) = %#v want %v\", tt.pattern, matches, tt.result)\n \t\t}\n \t}\n }\n+\n+func TestGlobError(t *testing.T) {\n+\t_, err := Glob(\"[7]\")\n+\tif err != nil {\n+\t\tt.Error(\"expected error for bad pattern; got none\")\n+\t}\n+}"}, {"sha": "de673a7257725cf0d3e266af206f393794bad87d", "filename": "libgo/go/path/filepath/path.go", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -231,6 +231,21 @@ func EvalSymlinks(path string) (string, os.Error) {\n \treturn Clean(b.String()), nil\n }\n \n+// Abs returns an absolute representation of path.\n+// If the path is not absolute it will be joined with the current\n+// working directory to turn it into an absolute path.  The absolute\n+// path name for a given file is not guaranteed to be unique.\n+func Abs(path string) (string, os.Error) {\n+\tif IsAbs(path) {\n+\t\treturn path, nil\n+\t}\n+\twd, err := os.Getwd()\n+\tif err != nil {\n+\t\treturn \"\", err\n+\t}\n+\treturn Join(wd, path), nil\n+}\n+\n // Visitor methods are invoked for corresponding file tree entries\n // visited by Walk. The parameter path is the full path of f relative\n // to root.\n@@ -265,7 +280,7 @@ func walk(path string, f *os.FileInfo, v Visitor, errors chan<- os.Error) {\n // a list of sorted directory entries.\n // Copied from io/ioutil to avoid the circular import.\n func readDir(dirname string) ([]*os.FileInfo, os.Error) {\n-\tf, err := os.Open(dirname, os.O_RDONLY, 0)\n+\tf, err := os.Open(dirname)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "e40008364cfac2961cc99d00fe0b4e4b57da512d", "filename": "libgo/go/path/filepath/path_plan9.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_plan9.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package filepath\n+\n+import \"strings\"\n+\n+const (\n+\tSeparator     = '/' // OS-specific path separator\n+\tListSeparator = 0   // OS-specific path list separator\n+)\n+\n+// isSeparator returns true if c is a directory separator character.\n+func isSeparator(c uint8) bool {\n+\treturn Separator == c\n+}\n+\n+// IsAbs returns true if the path is absolute.\n+func IsAbs(path string) bool {\n+\treturn strings.HasPrefix(path, \"/\") || strings.HasPrefix(path, \"#\")\n+}\n+\n+// volumeName returns the leading volume name on Windows.\n+// It returns \"\" elsewhere\n+func volumeName(path string) string {\n+\treturn \"\"\n+}"}, {"sha": "37078f63af979b55f94a26ff288465933d0a67c0", "filename": "libgo/go/path/filepath/path_test.go", "status": "modified", "additions": 49, "deletions": 5, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -248,7 +248,7 @@ func walkTree(n *Node, path string, f func(path string, n *Node)) {\n func makeTree(t *testing.T) {\n \twalkTree(tree, tree.name, func(path string, n *Node) {\n \t\tif n.entries == nil {\n-\t\t\tfd, err := os.Open(path, os.O_CREAT, 0660)\n+\t\t\tfd, err := os.Create(path)\n \t\t\tif err != nil {\n \t\t\t\tt.Errorf(\"makeTree: %v\", err)\n \t\t\t}\n@@ -459,9 +459,9 @@ func TestEvalSymlinks(t *testing.T) {\n \t// relative\n \tfor _, d := range EvalSymlinksTests {\n \t\tif p, err := filepath.EvalSymlinks(d.path); err != nil {\n-\t\t\tt.Errorf(\"EvalSymlinks(%v) error: %v\", d.path, err)\n+\t\t\tt.Errorf(\"EvalSymlinks(%q) error: %v\", d.path, err)\n \t\t} else if p != d.dest {\n-\t\t\tt.Errorf(\"EvalSymlinks(%v)=%v, want %v\", d.path, p, d.dest)\n+\t\t\tt.Errorf(\"EvalSymlinks(%q)=%q, want %q\", d.path, p, d.dest)\n \t\t}\n \t}\n \t// absolute\n@@ -477,10 +477,54 @@ func TestEvalSymlinks(t *testing.T) {\n \t\t\tfilepath.Join(testroot, d.dest),\n \t\t}\n \t\tif p, err := filepath.EvalSymlinks(a.path); err != nil {\n-\t\t\tt.Errorf(\"EvalSymlinks(%v) error: %v\", a.path, err)\n+\t\t\tt.Errorf(\"EvalSymlinks(%q) error: %v\", a.path, err)\n \t\t} else if p != a.dest {\n-\t\t\tt.Errorf(\"EvalSymlinks(%v)=%v, want %v\", a.path, p, a.dest)\n+\t\t\tt.Errorf(\"EvalSymlinks(%q)=%q, want %q\", a.path, p, a.dest)\n \t\t}\n \t}\n */\n }\n+\n+/* These tests do not work in the gccgo test environment.\n+\n+// Test paths relative to $GOROOT/src\n+var abstests = []string{\n+\t\"../AUTHORS\",\n+\t\"pkg/../../AUTHORS\",\n+\t\"Make.pkg\",\n+\t\"pkg/Makefile\",\n+\n+\t// Already absolute\n+\t\"$GOROOT/src/Make.pkg\",\n+}\n+\n+func TestAbs(t *testing.T) {\n+\toldwd, err := os.Getwd()\n+\tif err != nil {\n+\t\tt.Fatal(\"Getwd failed: \" + err.String())\n+\t}\n+\tdefer os.Chdir(oldwd)\n+\tgoroot := os.Getenv(\"GOROOT\")\n+\tcwd := filepath.Join(goroot, \"src\")\n+\tos.Chdir(cwd)\n+\tfor _, path := range abstests {\n+\t\tpath = strings.Replace(path, \"$GOROOT\", goroot, -1)\n+\t\tabspath, err := filepath.Abs(path)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Abs(%q) error: %v\", path, err)\n+\t\t}\n+\t\tinfo, err := os.Stat(path)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"%s: %s\", path, err)\n+\t\t}\n+\t\tabsinfo, err := os.Stat(abspath)\n+\t\tif err != nil || absinfo.Ino != info.Ino {\n+\t\t\tt.Errorf(\"Abs(%q)=%q, not the same file\", path, abspath)\n+\t\t}\n+\t\tif !filepath.IsAbs(abspath) {\n+\t\t\tt.Errorf(\"Abs(%q)=%q, not an absolute path\", path, abspath)\n+\t\t}\n+\t}\n+}\n+\n+*/"}, {"sha": "f8ac248fbb973cc114a1d5d2c6a3047bbd373720", "filename": "libgo/go/path/filepath/path_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -22,7 +22,7 @@ func IsAbs(path string) bool {\n }\n \n // volumeName returns the leading volume name on Windows.\n-// It returns \"\" on Unix.\n+// It returns \"\" elsewhere.\n func volumeName(path string) string {\n \treturn \"\"\n }"}, {"sha": "560e595b45a82cab0740dfd20e38ac2f85913f2d", "filename": "libgo/go/scanner/scanner.go", "status": "modified", "additions": 16, "deletions": 27, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fscanner%2Fscanner.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -331,7 +331,7 @@ func (s *Scanner) error(msg string) {\n \t\ts.Error(s, msg)\n \t\treturn\n \t}\n-\tfmt.Fprintf(os.Stderr, \"%s: %s\", s.Position, msg)\n+\tfmt.Fprintf(os.Stderr, \"%s: %s\\n\", s.Position, msg)\n }\n \n \n@@ -503,41 +503,32 @@ func (s *Scanner) scanChar() {\n }\n \n \n-func (s *Scanner) scanLineComment() {\n-\tch := s.next() // read character after \"//\"\n-\tfor ch != '\\n' {\n-\t\tif ch < 0 {\n-\t\t\ts.error(\"comment not terminated\")\n-\t\t\treturn\n+func (s *Scanner) scanComment(ch int) int {\n+\t// ch == '/' || ch == '*'\n+\tif ch == '/' {\n+\t\t// line comment\n+\t\tch = s.next() // read character after \"//\"\n+\t\tfor ch != '\\n' && ch >= 0 {\n+\t\t\tch = s.next()\n \t\t}\n-\t\tch = s.next()\n+\t\treturn ch\n \t}\n-}\n-\n \n-func (s *Scanner) scanGeneralComment() {\n-\tch := s.next() // read character after \"/*\"\n+\t// general comment\n+\tch = s.next() // read character after \"/*\"\n \tfor {\n \t\tif ch < 0 {\n \t\t\ts.error(\"comment not terminated\")\n-\t\t\treturn\n+\t\t\tbreak\n \t\t}\n \t\tch0 := ch\n \t\tch = s.next()\n \t\tif ch0 == '*' && ch == '/' {\n+\t\t\tch = s.next()\n \t\t\tbreak\n \t\t}\n \t}\n-}\n-\n-\n-func (s *Scanner) scanComment(ch int) {\n-\t// ch == '/' || ch == '*'\n-\tif ch == '/' {\n-\t\ts.scanLineComment()\n-\t\treturn\n-\t}\n-\ts.scanGeneralComment()\n+\treturn ch\n }\n \n \n@@ -619,13 +610,11 @@ redo:\n \t\t\tif (ch == '/' || ch == '*') && s.Mode&ScanComments != 0 {\n \t\t\t\tif s.Mode&SkipComments != 0 {\n \t\t\t\t\ts.tokPos = -1 // don't collect token text\n-\t\t\t\t\ts.scanComment(ch)\n-\t\t\t\t\tch = s.next()\n+\t\t\t\t\tch = s.scanComment(ch)\n \t\t\t\t\tgoto redo\n \t\t\t\t}\n-\t\t\t\ts.scanComment(ch)\n+\t\t\t\tch = s.scanComment(ch)\n \t\t\t\ttok = Comment\n-\t\t\t\tch = s.next()\n \t\t\t}\n \t\tcase '`':\n \t\t\tif s.Mode&ScanRawStrings != 0 {"}, {"sha": "cf9ad01111f387ce212642124a2ccd487e8005fc", "filename": "libgo/go/scanner/scanner_test.go", "status": "modified", "additions": 46, "deletions": 22, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -77,15 +77,15 @@ type token struct {\n var f100 = \"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\n \n var tokenList = []token{\n-\t{Comment, \"// line comments\\n\"},\n-\t{Comment, \"//\\n\"},\n-\t{Comment, \"////\\n\"},\n-\t{Comment, \"// comment\\n\"},\n-\t{Comment, \"// /* comment */\\n\"},\n-\t{Comment, \"// // comment //\\n\"},\n-\t{Comment, \"//\" + f100 + \"\\n\"},\n-\n-\t{Comment, \"// general comments\\n\"},\n+\t{Comment, \"// line comments\"},\n+\t{Comment, \"//\"},\n+\t{Comment, \"////\"},\n+\t{Comment, \"// comment\"},\n+\t{Comment, \"// /* comment */\"},\n+\t{Comment, \"// // comment //\"},\n+\t{Comment, \"//\" + f100},\n+\n+\t{Comment, \"// general comments\"},\n \t{Comment, \"/**/\"},\n \t{Comment, \"/***/\"},\n \t{Comment, \"/* comment */\"},\n@@ -94,7 +94,7 @@ var tokenList = []token{\n \t{Comment, \"/*\\n comment\\n*/\"},\n \t{Comment, \"/*\" + f100 + \"*/\"},\n \n-\t{Comment, \"// identifiers\\n\"},\n+\t{Comment, \"// identifiers\"},\n \t{Ident, \"a\"},\n \t{Ident, \"a0\"},\n \t{Ident, \"foobar\"},\n@@ -116,21 +116,21 @@ var tokenList = []token{\n \t{Ident, \"bar\uff19\uff18\uff17\uff16\"},\n \t{Ident, f100},\n \n-\t{Comment, \"// decimal ints\\n\"},\n+\t{Comment, \"// decimal ints\"},\n \t{Int, \"0\"},\n \t{Int, \"1\"},\n \t{Int, \"9\"},\n \t{Int, \"42\"},\n \t{Int, \"1234567890\"},\n \n-\t{Comment, \"// octal ints\\n\"},\n+\t{Comment, \"// octal ints\"},\n \t{Int, \"00\"},\n \t{Int, \"01\"},\n \t{Int, \"07\"},\n \t{Int, \"042\"},\n \t{Int, \"01234567\"},\n \n-\t{Comment, \"// hexadecimal ints\\n\"},\n+\t{Comment, \"// hexadecimal ints\"},\n \t{Int, \"0x0\"},\n \t{Int, \"0x1\"},\n \t{Int, \"0xf\"},\n@@ -144,7 +144,7 @@ var tokenList = []token{\n \t{Int, \"0X123456789abcDEF\"},\n \t{Int, \"0X\" + f100},\n \n-\t{Comment, \"// floats\\n\"},\n+\t{Comment, \"// floats\"},\n \t{Float, \"0.\"},\n \t{Float, \"1.\"},\n \t{Float, \"42.\"},\n@@ -174,7 +174,7 @@ var tokenList = []token{\n \t{Float, \"42E+10\"},\n \t{Float, \"01234567890E-10\"},\n \n-\t{Comment, \"// chars\\n\"},\n+\t{Comment, \"// chars\"},\n \t{Char, `' '`},\n \t{Char, `'a'`},\n \t{Char, `'\u672c'`},\n@@ -195,7 +195,7 @@ var tokenList = []token{\n \t{Char, `'\\U00000000'`},\n \t{Char, `'\\U0000ffAB'`},\n \n-\t{Comment, \"// strings\\n\"},\n+\t{Comment, \"// strings\"},\n \t{String, `\" \"`},\n \t{String, `\"a\"`},\n \t{String, `\"\u672c\"`},\n@@ -217,13 +217,13 @@ var tokenList = []token{\n \t{String, `\"\\U0000ffAB\"`},\n \t{String, `\"` + f100 + `\"`},\n \n-\t{Comment, \"// raw strings\\n\"},\n+\t{Comment, \"// raw strings\"},\n \t{String, \"``\"},\n \t{String, \"`\\\\`\"},\n \t{String, \"`\" + \"\\n\\n/* foobar */\\n\\n\" + \"`\"},\n \t{String, \"`\" + f100 + \"`\"},\n \n-\t{Comment, \"// individual characters\\n\"},\n+\t{Comment, \"// individual characters\"},\n \t// NUL character is not allowed\n \t{'\\x01', \"\\x01\"},\n \t{' ' - 1, string(' ' - 1)},\n@@ -276,7 +276,7 @@ func countNewlines(s string) int {\n \n \n func testScan(t *testing.T, mode uint) {\n-\ts := new(Scanner).Init(makeSource(\" \\t%s\\t\\n\\r\"))\n+\ts := new(Scanner).Init(makeSource(\" \\t%s\\n\"))\n \ts.Mode = mode\n \ttok := s.Scan()\n \tline := 1\n@@ -287,7 +287,7 @@ func testScan(t *testing.T, mode uint) {\n \t\t}\n \t\tline += countNewlines(k.text) + 1 // each token is on a new line\n \t}\n-\tcheckTok(t, s, line, tok, -1, \"\")\n+\tcheckTok(t, s, line, tok, EOF, \"\")\n }\n \n \n@@ -317,6 +317,10 @@ func TestPosition(t *testing.T) {\n \t\tpos.Line += countNewlines(k.text) + 1 // each token is on a new line\n \t\ts.Scan()\n \t}\n+\t// make sure there were no token-internal errors reported by scanner\n+\tif s.ErrorCount != 0 {\n+\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n+\t}\n }\n \n \n@@ -336,6 +340,9 @@ func TestScanZeroMode(t *testing.T) {\n \tif tok != EOF {\n \t\tt.Fatalf(\"tok = %s, want EOF\", TokenString(tok))\n \t}\n+\tif s.ErrorCount != 0 {\n+\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n+\t}\n }\n \n \n@@ -350,6 +357,9 @@ func testScanSelectedMode(t *testing.T, mode uint, class int) {\n \t\t}\n \t\ttok = s.Scan()\n \t}\n+\tif s.ErrorCount != 0 {\n+\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n+\t}\n }\n \n \n@@ -367,7 +377,7 @@ func TestScanSelectedMask(t *testing.T) {\n \n \n func TestScanNext(t *testing.T) {\n-\ts := new(Scanner).Init(bytes.NewBufferString(\"if a == bcd /* comment */ {\\n\\ta += c\\n}\"))\n+\ts := new(Scanner).Init(bytes.NewBufferString(\"if a == bcd /* comment */ {\\n\\ta += c\\n} // line comment ending in eof\"))\n \tcheckTok(t, s, 1, s.Scan(), Ident, \"if\")\n \tcheckTok(t, s, 1, s.Scan(), Ident, \"a\")\n \tcheckTok(t, s, 1, s.Scan(), '=', \"=\")\n@@ -382,6 +392,9 @@ func TestScanNext(t *testing.T) {\n \tcheckTok(t, s, 2, s.Scan(), Ident, \"c\")\n \tcheckTok(t, s, 3, s.Scan(), '}', \"}\")\n \tcheckTok(t, s, 3, s.Scan(), -1, \"\")\n+\tif s.ErrorCount != 0 {\n+\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n+\t}\n }\n \n \n@@ -441,7 +454,6 @@ func TestError(t *testing.T) {\n \ttestError(t, `\"\\'\"`, \"illegal char escape\", String)\n \ttestError(t, `\"abc`, \"literal not terminated\", String)\n \ttestError(t, \"`abc\", \"literal not terminated\", String)\n-\ttestError(t, `//`, \"comment not terminated\", EOF)\n \ttestError(t, `/*/`, \"comment not terminated\", EOF)\n \ttestError(t, `\"abc`+\"\\x00\"+`def\"`, \"illegal character NUL\", String)\n \ttestError(t, `\"abc`+\"\\xff\"+`def\"`, \"illegal UTF-8 encoding\", String)\n@@ -493,6 +505,9 @@ func TestPos(t *testing.T) {\n \tfor i := 10; i > 0; i-- {\n \t\tcheckScanPos(t, s, 1, 2, 1, EOF)\n \t}\n+\tif s.ErrorCount != 0 {\n+\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n+\t}\n \n \t// corner case: source with only a single character\n \ts = new(Scanner).Init(bytes.NewBufferString(\"\u672c\"))\n@@ -502,6 +517,9 @@ func TestPos(t *testing.T) {\n \tfor i := 10; i > 0; i-- {\n \t\tcheckScanPos(t, s, 3, 1, 2, EOF)\n \t}\n+\tif s.ErrorCount != 0 {\n+\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n+\t}\n \n \t// positions after calling Next\n \ts = new(Scanner).Init(bytes.NewBufferString(\"  foo\u096c\u096a  \\n\\n\u672c\u8a9e\\n\"))\n@@ -524,6 +542,9 @@ func TestPos(t *testing.T) {\n \tfor i := 10; i > 0; i-- {\n \t\tcheckScanPos(t, s, 22, 4, 1, EOF)\n \t}\n+\tif s.ErrorCount != 0 {\n+\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n+\t}\n \n \t// positions after calling Scan\n \ts = new(Scanner).Init(bytes.NewBufferString(\"abc\\n\u672c\u8a9e\\n\\nx\"))\n@@ -543,4 +564,7 @@ func TestPos(t *testing.T) {\n \tfor i := 10; i > 0; i-- {\n \t\tcheckScanPos(t, s, 13, 4, 2, EOF)\n \t}\n+\tif s.ErrorCount != 0 {\n+\t\tt.Errorf(\"%d errors\", s.ErrorCount)\n+\t}\n }"}, {"sha": "34baeee39b3360a7dcc35d41e3a42c038a74e6d3", "filename": "libgo/go/strconv/fp_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fstrconv%2Ffp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Fstrconv%2Ffp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Ffp_test.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -94,7 +94,7 @@ func myatof32(s string) (f float32, ok bool) {\n }\n \n func TestFp(t *testing.T) {\n-\tf, err := os.Open(\"testfp.txt\", os.O_RDONLY, 0)\n+\tf, err := os.Open(\"testfp.txt\")\n \tif err != nil {\n \t\tt.Fatal(\"testfp: open testfp.txt:\", err.String())\n \t}"}, {"sha": "1e65528ef9689dee95d41b652f9006ed69fd6eb6", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -212,7 +212,7 @@ func before() {\n \t\truntime.MemProfileRate = *memProfileRate\n \t}\n \tif *cpuProfile != \"\" {\n-\t\tf, err := os.Open(*cpuProfile, os.O_WRONLY|os.O_CREAT|os.O_TRUNC, 0666)\n+\t\tf, err := os.Create(*cpuProfile)\n \t\tif err != nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"testing: %s\", err)\n \t\t\treturn\n@@ -233,7 +233,7 @@ func after() {\n \t\tpprof.StopCPUProfile() // flushes profile to disk\n \t}\n \tif *memProfile != \"\" {\n-\t\tf, err := os.Open(*memProfile, os.O_WRONLY|os.O_CREAT|os.O_TRUNC, 0666)\n+\t\tf, err := os.Create(*memProfile)\n \t\tif err != nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"testing: %s\", err)\n \t\t\treturn"}, {"sha": "05f4af01ab323b38b7b145fe1e42d218c6a33552", "filename": "libgo/mksysinfo.sh", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fmksysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fmksysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmksysinfo.sh?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -57,6 +57,9 @@ cat > sysinfo.c <<EOF\n #if defined(HAVE_SYS_EPOLL_H)\n #include <sys/epoll.h>\n #endif\n+#if defined(HAVE_SYS_MMAN_H)\n+#include <sys/mman.h>\n+#endif\n #if defined(HAVE_SYS_PTRACE_H)\n #include <sys/ptrace.h>\n #endif\n@@ -131,6 +134,12 @@ grep '^const _SYS_' gen-sysinfo.go | \\\n grep '^const _S_' gen-sysinfo.go | \\\n   sed -e 's/^\\(const \\)_\\(S_[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n \n+# Mmap constants.\n+grep '^const _PROT_' gen-sysinfo.go | \\\n+  sed -e 's/^\\(const \\)_\\(PROT_[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n+grep '^const _MAP_' gen-sysinfo.go | \\\n+  sed -e 's/^\\(const \\)_\\(MAP_[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n+\n # Process status constants.\n grep '^const _W' gen-sysinfo.go |\n   sed -e 's/^\\(const \\)_\\(W[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}"}, {"sha": "8c7a7ba5fee18ac3700358a290ba9a038a95cf38", "filename": "libgo/syscalls/syscall.go", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fsyscalls%2Fsyscall.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fsyscalls%2Fsyscall.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -13,7 +13,10 @@\n // the manuals for the appropriate operating system.\n package syscall\n \n-import \"unsafe\"\n+import (\n+\t\"sync\"\n+\t\"unsafe\"\n+)\n \n func libc_syscall32(trap int32, a1, a2, a3, a4, a5, a6 int32) int32 __asm__ (\"syscall\");\n func libc_syscall64(trap int64, a1, a2, a3, a4, a5, a6 int64) int64 __asm__ (\"syscall\");\n@@ -46,3 +49,63 @@ func Syscall6(trap, a1, a2, a3, a4, a5, a6 uintptr) (r1, r2, err uintptr) {\n   }\n   return r, 0, uintptr(GetErrno());\n }\n+\n+// Mmap manager, for use by operating system-specific implementations.\n+\n+type mmapper struct {\n+\tsync.Mutex\n+\tactive map[*byte][]byte // active mappings; key is last byte in mapping\n+\tmmap   func(addr, length uintptr, prot, flags, fd int, offset int64) (uintptr, int)\n+\tmunmap func(addr uintptr, length uintptr) int\n+}\n+\n+func (m *mmapper) Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, errno int) {\n+\tif length <= 0 {\n+\t\treturn nil, EINVAL\n+\t}\n+\n+\t// Map the requested memory.\n+\taddr, errno := m.mmap(0, uintptr(length), prot, flags, fd, offset)\n+\tif errno != 0 {\n+\t\treturn nil, errno\n+\t}\n+\n+\t// Slice memory layout\n+\tvar sl = struct {\n+\t\taddr uintptr\n+\t\tlen  int\n+\t\tcap  int\n+\t}{addr, length, length}\n+\n+\t// Use unsafe to turn sl into a []byte.\n+\tb := *(*[]byte)(unsafe.Pointer(&sl))\n+\n+\t// Register mapping in m and return it.\n+\tp := &b[cap(b)-1]\n+\tm.Lock()\n+\tdefer m.Unlock()\n+\tm.active[p] = b\n+\treturn b, 0\n+}\n+\n+func (m *mmapper) Munmap(data []byte) (errno int) {\n+\tif len(data) == 0 || len(data) != cap(data) {\n+\t\treturn EINVAL\n+\t}\n+\n+\t// Find the base of the mapping.\n+\tp := &data[cap(data)-1]\n+\tm.Lock()\n+\tdefer m.Unlock()\n+\tb := m.active[p]\n+\tif b == nil || &b[0] != &data[0] {\n+\t\treturn EINVAL\n+\t}\n+\n+\t// Unmap the memory and update m.\n+\tif errno := m.munmap(uintptr(unsafe.Pointer(&b[0])), uintptr(len(b))); errno != 0 {\n+\t\treturn errno\n+\t}\n+\tm.active[p] = nil, false\n+\treturn 0\n+}"}, {"sha": "b5a660e93d1b6ef35c553bd55580090a9867a55d", "filename": "libgo/syscalls/syscall_unix.go", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fsyscalls%2Fsyscall_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fsyscalls%2Fsyscall_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsyscall_unix.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -4,6 +4,8 @@\n \n package syscall\n \n+import \"unsafe\"\n+\n var (\n \tStdin  = 0\n \tStdout = 1\n@@ -22,3 +24,35 @@ func Uname(buf *Utsname) (errno int) {\n \t}\n \treturn\n }\n+\n+var mapper = &mmapper{\n+\tactive: make(map[*byte][]byte),\n+\tmmap:   mmap,\n+\tmunmap: munmap,\n+}\n+\n+func Mmap(fd int, offset int64, length int, prot int, flags int) (data []byte, errno int) {\n+\treturn mapper.Mmap(fd, offset, length, prot, flags)\n+}\n+\n+func Munmap(b []byte) (errno int) {\n+\treturn mapper.Munmap(b)\n+}\n+\n+func libc_munmap(*byte, Size_t) int __asm__ (\"munmap\")\n+\n+func mmap(addr uintptr, length uintptr, prot int, flag int, fd int, pos int64) (ret uintptr, errno int) {\n+\tr0 := libc_mmap((*byte)(unsafe.Pointer(addr)), Size_t(length), prot, flag, fd, Offset_t(pos))\n+\tret = uintptr(unsafe.Pointer(r0))\n+\tif ret + 1 == 0 {\n+\t\terrno = GetErrno()\n+\t}\n+\treturn\n+}\n+\n+func munmap(addr uintptr, length uintptr) (errno int) {\n+\tif libc_munmap((*byte)(unsafe.Pointer(addr)), Size_t(length)) < 0 {\n+\t\terrno = GetErrno()\n+\t}\n+\treturn\n+}"}, {"sha": "c0c4e555e63a1e8102a1160dad260d99e7e31b76", "filename": "libgo/syscalls/sysfile_largefile.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fsyscalls%2Fsysfile_largefile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fsyscalls%2Fsysfile_largefile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_largefile.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -11,3 +11,4 @@ func libc_pwrite(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm\n func libc_lseek(int, Offset_t, int) Offset_t __asm__ (\"lseek64\")\n func libc_truncate(path *byte, length Offset_t) int __asm__ (\"truncate64\")\n func libc_ftruncate(fd int, length Offset_t) int __asm__ (\"ftruncate64\")\n+func libc_mmap(*byte, Size_t, int, int, int, Offset_t) *byte __asm__ (\"mmap64\")"}, {"sha": "fcbf254dc0e3238c39ca0671a419d0653f00e319", "filename": "libgo/syscalls/sysfile_regfile.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fsyscalls%2Fsysfile_regfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/405ca10418216fc078ecb29ff13a39c911e8d806/libgo%2Fsyscalls%2Fsysfile_regfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fsysfile_regfile.go?ref=405ca10418216fc078ecb29ff13a39c911e8d806", "patch": "@@ -11,3 +11,4 @@ func libc_pwrite(fd int, buf *byte, count Size_t, offset Offset_t) Ssize_t __asm\n func libc_lseek(int, Offset_t, int) Offset_t __asm__ (\"lseek\")\n func libc_truncate(path *byte, length Offset_t) int __asm__ (\"truncate\")\n func libc_ftruncate(fd int, length Offset_t) int __asm__ (\"ftruncate\")\n+func libc_mmap(*byte, Size_t, int, int, int, Offset_t) *byte __asm__ (\"mmap\")"}]}