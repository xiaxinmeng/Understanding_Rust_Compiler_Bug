{"sha": "0bbe50f6b473e6857777cf9932773accd3cbb0c5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGJiZTUwZjZiNDczZTY4NTc3NzdjZjk5MzI3NzNhY2NkM2NiYjBjNQ==", "commit": {"author": {"name": "Changpeng Fang", "email": "changpeng.fang@amd.com", "date": "2010-07-09T23:08:55Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2010-07-09T23:08:55Z"}, "message": "pr44576 Avoid un-necessary prefetch analysis by distributing the cost models\n\n2010-07-09  Changpeng Fang  <changpeng.fang@amd.com>\n\n\tPR tree-optimization/44576\n\t* tree-ssa-loop-prefetch.c (trip_count_to_ahead_ratio_too_small_p):\n\tNew.  Pull out from is_loop_prefetching_profitable to implement\n\tthe trip count to ahead ratio heuristic.\n\t(mem_ref_count_reasonable_p): New.  Pull out from\n\tis_loop_prefetching_profitable to implement the instruction to\n\tmemory reference ratio heuristic.  Also consider not reasonable if\n\tthe memory reference count is above a threshold (to avoid\n\texplosive compilation time.\n\t(insn_to_prefetch_ratio_too_small_p): New.  Pull out from\n\tis_loop_prefetching_profitable to implement the instruction to\n\tprefetch ratio heuristic.\n\t(is_loop_prefetching_profitable): Removed.\n\t(loop_prefetch_arrays): Distribute the cost analysis across the\n\tfunction to allow early exit of the prefetch analysis.\n\tis_loop_prefetching_profitable is splitted into three functions,\n\twith each one called as early as possible.\n\t(PREFETCH_MAX_MEM_REFS_PER_LOOP): New.  Threshold above which the\n\tnumber of memory references in a loop is considered too many.\n\nFrom-SVN: r162023", "tree": {"sha": "08a6ff064dc82642939db19bcd80abf31bc265a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/08a6ff064dc82642939db19bcd80abf31bc265a6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0bbe50f6b473e6857777cf9932773accd3cbb0c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bbe50f6b473e6857777cf9932773accd3cbb0c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0bbe50f6b473e6857777cf9932773accd3cbb0c5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0bbe50f6b473e6857777cf9932773accd3cbb0c5/comments", "author": {"login": "changpeng", "id": 4239661, "node_id": "MDQ6VXNlcjQyMzk2NjE=", "avatar_url": "https://avatars.githubusercontent.com/u/4239661?v=4", "gravatar_id": "", "url": "https://api.github.com/users/changpeng", "html_url": "https://github.com/changpeng", "followers_url": "https://api.github.com/users/changpeng/followers", "following_url": "https://api.github.com/users/changpeng/following{/other_user}", "gists_url": "https://api.github.com/users/changpeng/gists{/gist_id}", "starred_url": "https://api.github.com/users/changpeng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/changpeng/subscriptions", "organizations_url": "https://api.github.com/users/changpeng/orgs", "repos_url": "https://api.github.com/users/changpeng/repos", "events_url": "https://api.github.com/users/changpeng/events{/privacy}", "received_events_url": "https://api.github.com/users/changpeng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95da5cf9177a915c6c015468b822e402293dcf5e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95da5cf9177a915c6c015468b822e402293dcf5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95da5cf9177a915c6c015468b822e402293dcf5e"}], "stats": {"total": 179, "additions": 132, "deletions": 47}, "files": [{"sha": "afbbb31e5b62e96cd6085cbe74bc5dd15d2ff464", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bbe50f6b473e6857777cf9932773accd3cbb0c5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bbe50f6b473e6857777cf9932773accd3cbb0c5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0bbe50f6b473e6857777cf9932773accd3cbb0c5", "patch": "@@ -1,3 +1,25 @@\n+2010-07-09  Changpeng Fang  <changpeng.fang@amd.com>\n+\n+\tPR tree-optimization/44576\n+\t* tree-ssa-loop-prefetch.c (trip_count_to_ahead_ratio_too_small_p):\n+\tNew.  Pull out from is_loop_prefetching_profitable to implement\n+\tthe trip count to ahead ratio heuristic.\n+\t(mem_ref_count_reasonable_p): New.  Pull out from\n+\tis_loop_prefetching_profitable to implement the instruction to\n+\tmemory reference ratio heuristic.  Also consider not reasonable if\n+\tthe memory reference count is above a threshold (to avoid\n+\texplosive compilation time.\n+\t(insn_to_prefetch_ratio_too_small_p): New.  Pull out from\n+\tis_loop_prefetching_profitable to implement the instruction to\n+\tprefetch ratio heuristic.\n+\t(is_loop_prefetching_profitable): Removed.\n+\t(loop_prefetch_arrays): Distribute the cost analysis across the\n+\tfunction to allow early exit of the prefetch analysis.\n+\tis_loop_prefetching_profitable is splitted into three functions,\n+\twith each one called as early as possible.\n+\t(PREFETCH_MAX_MEM_REFS_PER_LOOP): New.  Threshold above which the\n+\tnumber of memory references in a loop is considered too many.\n+\n 2010-07-09  Bernd Schmidt  <bernds@codesourcery.com>\n \n \t* reload.c (find_reloads): Don't clear badop if we have a"}, {"sha": "008f2ce4b7b8d442a20641d25cb71d07985172d8", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 110, "deletions": 47, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0bbe50f6b473e6857777cf9932773accd3cbb0c5/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0bbe50f6b473e6857777cf9932773accd3cbb0c5/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=0bbe50f6b473e6857777cf9932773accd3cbb0c5", "patch": "@@ -110,19 +110,29 @@ along with GCC; see the file COPYING3.  If not see\n       prefetch instructions with guards in cases where 5) was not sufficient\n       to satisfy the constraints?\n \n-   The function is_loop_prefetching_profitable() implements a cost model\n-   to determine if prefetching is profitable for a given loop. The cost\n-   model has two heuristcs:\n-   1. A heuristic that determines whether the given loop has enough CPU\n-      ops that can be overlapped with cache missing memory ops.\n-      If not, the loop won't benefit from prefetching. This is implemented\n-      by requirung the ratio between the instruction count and the mem ref\n-      count to be above a certain minimum.\n-   2. A heuristic that disables prefetching in a loop with an unknown trip\n-      count if the prefetching cost is above a certain limit. The relative\n-      prefetching cost is estimated by taking the ratio between the\n-      prefetch count and the total intruction count (this models the I-cache\n-      cost).\n+   A cost model is implemented to determine whether or not prefetching is\n+   profitable for a given loop.  The cost model has three heuristics:\n+\n+   1. Function trip_count_to_ahead_ratio_too_small_p implements a\n+      heuristic that determines whether or not the loop has too few\n+      iterations (compared to ahead).  Prefetching is not likely to be\n+      beneficial if the trip count to ahead ratio is below a certain\n+      minimum.\n+\n+   2. Function mem_ref_count_reasonable_p implements a heuristic that\n+      determines whether the given loop has enough CPU ops that can be\n+      overlapped with cache missing memory ops.  If not, the loop\n+      won't benefit from prefetching.  In the implementation,\n+      prefetching is not considered beneficial if the ratio between\n+      the instruction count and the mem ref count is below a certain\n+      minimum.\n+\n+   3. Function insn_to_prefetch_ratio_too_small_p implements a\n+      heuristic that disables prefetching in a loop if the prefetching\n+      cost is above a certain limit.  The relative prefetching cost is\n+      estimated by taking the ratio between the prefetch count and the\n+      total intruction count (this models the I-cache cost).\n+\n    The limits used in these heuristics are defined as parameters with\n    reasonable default values. Machine-specific default values will be\n    added later.\n@@ -238,6 +248,14 @@ struct mem_ref_group\n #define PREFETCH_MOD_TO_UNROLL_FACTOR_RATIO 4\n #endif\n \n+/* Some of the prefetch computations have quadratic complexity.  We want to\n+   avoid huge compile times and, therefore, want to limit the amount of\n+   memory references per loop where we consider prefetching.  */\n+\n+#ifndef PREFETCH_MAX_MEM_REFS_PER_LOOP\n+#define PREFETCH_MAX_MEM_REFS_PER_LOOP 200\n+#endif\n+\n /* The memory reference.  */\n \n struct mem_ref\n@@ -1640,24 +1658,51 @@ determine_loop_nest_reuse (struct loop *loop, struct mem_ref_group *refs,\n     }\n }\n \n-/* Do a cost-benefit analysis to determine if prefetching is profitable\n-   for the current loop given the following parameters:\n+/* Determine whether or not the trip count to ahead ratio is too small based\n+   on prefitablility consideration.\n    AHEAD: the iteration ahead distance,\n-   EST_NITER: the estimated trip count,\n+   EST_NITER: the estimated trip count.  */\n+\n+static bool\n+trip_count_to_ahead_ratio_too_small_p (unsigned ahead, HOST_WIDE_INT est_niter)\n+{\n+  /* Assume trip count to ahead ratio is big enough if the trip count could not\n+     be estimated at compile time.  */\n+  if (est_niter < 0)\n+    return false;\n+\n+  if (est_niter < (HOST_WIDE_INT) (TRIP_COUNT_TO_AHEAD_RATIO * ahead))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file,\n+\t\t \"Not prefetching -- loop estimated to roll only %d times\\n\",\n+\t\t (int) est_niter);\n+      return true;\n+    }\n+\n+  return false;\n+}\n+\n+/* Determine whether or not the number of memory references in the loop is\n+   reasonable based on the profitablity and compilation time considerations.\n    NINSNS: estimated number of instructions in the loop,\n-   PREFETCH_COUNT: an estimate of the number of prefetches\n    MEM_REF_COUNT: total number of memory references in the loop.  */\n \n static bool\n-is_loop_prefetching_profitable (unsigned ahead, HOST_WIDE_INT est_niter,\n-\t\t\t\tunsigned ninsns, unsigned prefetch_count,\n-\t\t\t\tunsigned mem_ref_count, unsigned unroll_factor)\n+mem_ref_count_reasonable_p (unsigned ninsns, unsigned mem_ref_count)\n {\n-  int insn_to_mem_ratio, insn_to_prefetch_ratio;\n+  int insn_to_mem_ratio;\n \n   if (mem_ref_count == 0)\n     return false;\n \n+  /* Miss rate computation (is_miss_rate_acceptable) and dependence analysis\n+     (compute_all_dependences) have high costs based on quadratic complexity.\n+     To avoid huge compilation time, we give up prefetching if mem_ref_count\n+     is too large.  */\n+  if (mem_ref_count > PREFETCH_MAX_MEM_REFS_PER_LOOP)\n+    return false;\n+\n   /* Prefetching improves performance by overlapping cache missing\n      memory accesses with CPU operations.  If the loop does not have\n      enough CPU operations to overlap with memory operations, prefetching\n@@ -1678,6 +1723,21 @@ is_loop_prefetching_profitable (unsigned ahead, HOST_WIDE_INT est_niter,\n       return false;\n     }\n \n+  return true;\n+}\n+\n+/* Determine whether or not the instruction to prefetch ratio in the loop is\n+   too small based on the profitablity consideration.\n+   NINSNS: estimated number of instructions in the loop,\n+   PREFETCH_COUNT: an estimate of the number of prefetches,\n+   UNROLL_FACTOR:  the factor to unroll the loop if prefetching.  */\n+\n+static bool\n+insn_to_prefetch_ratio_too_small_p (unsigned ninsns, unsigned prefetch_count,\n+                                     unsigned unroll_factor)\n+{\n+  int insn_to_prefetch_ratio;\n+\n   /* Prefetching most likely causes performance degradation when the instruction\n      to prefetch ratio is too small.  Too many prefetch instructions in a loop\n      may reduce the I-cache performance.\n@@ -1697,23 +1757,10 @@ is_loop_prefetching_profitable (unsigned ahead, HOST_WIDE_INT est_niter,\n         fprintf (dump_file,\n \t\t \"Not prefetching -- instruction to prefetch ratio (%d) too small\\n\",\n \t\t insn_to_prefetch_ratio);\n-      return false;\n+      return true;\n     }\n \n-  /* Could not do further estimation if the trip count is unknown.  Just assume\n-     prefetching is profitable. Too aggressive???  */\n-  if (est_niter < 0)\n-    return true;\n-\n-  if (est_niter < (HOST_WIDE_INT) (TRIP_COUNT_TO_AHEAD_RATIO * ahead))\n-    {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file,\n-\t\t \"Not prefetching -- loop estimated to roll only %d times\\n\",\n-\t\t (int) est_niter);\n-      return false;\n-    }\n-  return true;\n+  return false;\n }\n \n \n@@ -1738,9 +1785,31 @@ loop_prefetch_arrays (struct loop *loop)\n       return false;\n     }\n \n+  /* FIXME: the time should be weighted by the probabilities of the blocks in\n+     the loop body.  */\n+  time = tree_num_loop_insns (loop, &eni_time_weights);\n+  if (time == 0)\n+    return false;\n+\n+  ahead = (PREFETCH_LATENCY + time - 1) / time;\n+  est_niter = estimated_loop_iterations_int (loop, false);\n+\n+  /* Prefetching is not likely to be profitable if the trip count to ahead\n+     ratio is too small.  */\n+  if (trip_count_to_ahead_ratio_too_small_p (ahead, est_niter))\n+    return false;\n+\n+  ninsns = tree_num_loop_insns (loop, &eni_size_weights);\n+\n   /* Step 1: gather the memory references.  */\n   refs = gather_memory_references (loop, &no_other_refs, &mem_ref_count);\n \n+  /* Give up prefetching if the number of memory references in the\n+     loop is not reasonable based on profitablity and compilation time\n+     considerations.  */\n+  if (!mem_ref_count_reasonable_p (ninsns, mem_ref_count))\n+    goto fail;\n+\n   /* Step 2: estimate the reuse effects.  */\n   prune_by_reuse (refs);\n \n@@ -1749,15 +1818,7 @@ loop_prefetch_arrays (struct loop *loop)\n \n   determine_loop_nest_reuse (loop, refs, no_other_refs);\n \n-  /* Step 3: determine the ahead and unroll factor.  */\n-\n-  /* FIXME: the time should be weighted by the probabilities of the blocks in\n-     the loop body.  */\n-  time = tree_num_loop_insns (loop, &eni_time_weights);\n-  ahead = (PREFETCH_LATENCY + time - 1) / time;\n-  est_niter = estimated_loop_iterations_int (loop, false);\n-\n-  ninsns = tree_num_loop_insns (loop, &eni_size_weights);\n+  /* Step 3: determine unroll factor.  */\n   unroll_factor = determine_unroll_factor (loop, refs, ninsns, &desc,\n \t\t\t\t\t   est_niter);\n \n@@ -1773,8 +1834,10 @@ loop_prefetch_arrays (struct loop *loop)\n \t     ahead, unroll_factor, est_niter,\n \t     ninsns, mem_ref_count, prefetch_count);\n \n-  if (!is_loop_prefetching_profitable (ahead, est_niter, ninsns, prefetch_count,\n-\t\t\t\t       mem_ref_count, unroll_factor))\n+  /* Prefetching is not likely to be profitable if the instruction to prefetch\n+     ratio is too small.  */\n+  if (insn_to_prefetch_ratio_too_small_p (ninsns, prefetch_count,\n+\t\t\t\t\t  unroll_factor))\n     goto fail;\n \n   mark_nontemporal_stores (loop, refs);"}]}