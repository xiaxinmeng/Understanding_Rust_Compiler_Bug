{"sha": "41349aec29110e04cea2ee9c9ea4e56365f42eed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDEzNDlhZWMyOTExMGUwNGNlYTJlZTljOWVhNGU1NjM2NWY0MmVlZA==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-06-29T07:55:12Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2013-06-29T07:55:12Z"}, "message": "hashtable_policy.h (_Insert_base): Consider hint in insert methods.\n\n2013-06-29  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\n\t* include/bits/hashtable_policy.h (_Insert_base): Consider hint in\n\tinsert methods.\n\t* include/bits/hashtable.h: Likewise.\n\t* testsuite/23_containers/unordered_multimap/insert/hint.cc: New.\n\t* testsuite/performance/23_containers/insert/unordered_multiset_hint.cc:\n\tNew.\n\t* testsuite/23_containers/unordered_set/instantiation_neg.cc:\n\tAdjust dg-error line number.\n\t* testsuite/23_containers/unordered_set/\n\tnot_default_constructible_hash_neg.cc: Likewise.\n\t* doc/xml/manual/containers.xml: Document hinting in unordered\n\tcontainers.\n\nFrom-SVN: r200564", "tree": {"sha": "a5b222969d5c75ce686b7d4035015b3554a9764b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5b222969d5c75ce686b7d4035015b3554a9764b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41349aec29110e04cea2ee9c9ea4e56365f42eed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41349aec29110e04cea2ee9c9ea4e56365f42eed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41349aec29110e04cea2ee9c9ea4e56365f42eed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41349aec29110e04cea2ee9c9ea4e56365f42eed/comments", "author": null, "committer": null, "parents": [{"sha": "c865f9238ac6e835eb0e86f72cdd07b8064df21f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c865f9238ac6e835eb0e86f72cdd07b8064df21f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c865f9238ac6e835eb0e86f72cdd07b8064df21f"}], "stats": {"total": 622, "additions": 592, "deletions": 30}, "files": [{"sha": "9791953b78d3f9a2daa768e61f2aa8b6ca91faf7", "filename": "libstdc++-v3/doc/xml/manual/containers.xml", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fcontainers.xml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fcontainers.xml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdoc%2Fxml%2Fmanual%2Fcontainers.xml?ref=41349aec29110e04cea2ee9c9ea4e56365f42eed", "patch": "@@ -354,6 +354,60 @@\n   <info><title>Unordered Associative</title></info>\n   <?dbhtml filename=\"unordered_associative.html\"?>\n \n+  <section xml:id=\"containers.unordered.insert_hints\" xreflabel=\"Insertion Hints\">\n+    <info><title>Insertion Hints</title></info>\n+\n+    <para>\n+     Here is how the hinting works in the libstdc++ implementation of unordered\n+     containers, and the rationale behind this behavior.\n+    </para>\n+    <para>\n+      In the following text, the phrase <emphasis>equivalent to</emphasis> refer\n+      to the result of the invocation of the equal predicate imposed on the\n+      container by its <code>key_equal</code> object, which defaults to (basically)\n+      <quote>==</quote>.\n+    </para>\n+    <para>\n+      Unordered containers can be seen as a <code>std::vector</code> of\n+      <code>std::forward_list</code>. The <code>std::vector</code> represents\n+      the buckets and each <code>std::forward_list</code> is the list of nodes\n+      belonging to the same bucket. When inserting an element in such a data\n+      structure we first need to compute the element hash code to find the\n+      bucket to insert the element to, the second step depends on the uniqueness\n+      of elements in the container.\n+    </para>\n+    <para>\n+      In the case of <code>std::unordered_set</code> and\n+      <code>std::unordered_map</code> you need to look through all bucket's\n+      elements for an equivalent one. If there is none the insertion can be\n+      achieved, otherwise the insertion fails. As we always need to loop though\n+      all bucket's elements, the hint doesn't tell us if the element is already\n+      present, and we don't have any constraint on where the new element is to\n+      be inserted, the hint won't be of any help and will then be ignored.\n+    </para>\n+    <para>\n+      In the case of <code>std::unordered_multiset</code>\n+      and <code>std::unordered_multimap</code> equivalent elements must be\n+      linked together so that the <code>equal_range(const key_type&amp;)</code>\n+      can return the range of iterators pointing to all equivalent elements.\n+      This is where hinting can be used to point to another equivalent element\n+      already part of the container and so skip all non equivalent elements of\n+      the bucket. So to be useful the hint shall point to an element equivalent\n+      to the one being inserted. The new element will be then inserted right\n+      after the hint. Note that because of an implementation detail inserting\n+      after a node can require updating the bucket of the following node. To\n+      check if the next bucket is to be modified we need to compute the\n+      following node's hash code. So if you want your hint to be really efficient\n+      it should be followed by another equivalent element, the implementation\n+      will detect this equivalence and won't compute next element hash code.\n+    </para>\n+    <para>\n+      It is highly advised to start using unordered containers hints only if you\n+      have a benchmark that will demonstrate the benefit of it. If you don't then do\n+      not use hints, it might do more harm than good.\n+    </para>\n+  </section>\n+\n   <section xml:id=\"containers.unordered.hash\" xreflabel=\"Hash\">\n     <info><title>Hash Code</title></info>\n "}, {"sha": "9b586b01e2404a4541addf1d8bb6ca82b205b8ea", "filename": "libstdc++-v3/include/bits/hashtable.h", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable.h?ref=41349aec29110e04cea2ee9c9ea4e56365f42eed", "patch": "@@ -225,7 +225,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __node_base = typename __hashtable_base::__node_base;\n       using __bucket_type = typename __hashtable_base::__bucket_type;\n       using __ireturn_type = typename __hashtable_base::__ireturn_type;\n-      using __iconv_type = typename __hashtable_base::__iconv_type;\n \n       using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,\n \t\t\t\t\t     _Equal, _H1, _H2, _Hash,\n@@ -680,23 +679,47 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       // Insert node with hash code __code. Take ownership of the node,\n       // deallocate it on exception.\n       iterator\n-      _M_insert_multi_node(__hash_code __code, __node_type* __n);\n+      _M_insert_multi_node(__node_type* __hint,\n+\t\t\t   __hash_code __code, __node_type* __n);\n \n       template<typename... _Args>\n \tstd::pair<iterator, bool>\n \t_M_emplace(std::true_type, _Args&&... __args);\n \n       template<typename... _Args>\n \titerator\n-\t_M_emplace(std::false_type, _Args&&... __args);\n+\t_M_emplace(std::false_type __uk, _Args&&... __args)\n+\t{ return _M_emplace(cend(), __uk, std::forward<_Args>(__args)...); }\n+\n+      // Emplace with hint, useless when keys are unique.\n+      template<typename... _Args>\n+\titerator\n+\t_M_emplace(const_iterator, std::true_type __uk, _Args&&... __args)\n+\t{ return _M_emplace(__uk, std::forward<_Args>(__args)...).first; }\n+\n+      template<typename... _Args>\n+\titerator\n+\t_M_emplace(const_iterator, std::false_type, _Args&&... __args);\n \n       template<typename _Arg>\n \tstd::pair<iterator, bool>\n \t_M_insert(_Arg&&, std::true_type);\n \n       template<typename _Arg>\n \titerator\n-\t_M_insert(_Arg&&, std::false_type);\n+\t_M_insert(_Arg&& __arg, std::false_type __uk)\n+\t{ return _M_insert(cend(), std::forward<_Arg>(__arg), __uk); }\n+\n+      // Insert with hint, not used when keys are unique.\n+      template<typename _Arg>\n+\titerator\n+\t_M_insert(const_iterator, _Arg&& __arg, std::true_type __uk)\n+\t{ return _M_insert(std::forward<_Arg>(__arg), __uk).first; }\n+\n+      // Insert with hint when keys are not unique.\n+      template<typename _Arg>\n+\titerator\n+\t_M_insert(const_iterator, _Arg&&, std::false_type);\n \n       size_type\n       _M_erase(std::true_type, const key_type&);\n@@ -716,8 +739,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename... _Args>\n \titerator\n-\templace_hint(const_iterator, _Args&&... __args)\n-\t{ return __iconv_type()(emplace(std::forward<_Args>(__args)...)); }\n+\templace_hint(const_iterator __hint, _Args&&... __args)\n+\t{\n+\t  return _M_emplace(__hint, __unique_keys(),\n+\t\t\t    std::forward<_Args>(__args)...);\n+\t}\n \n       // Insert member functions via inheritance.\n \n@@ -1642,7 +1668,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t  _Traits>::iterator\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_emplace(std::false_type, _Args&&... __args)\n+      _M_emplace(const_iterator __hint, std::false_type, _Args&&... __args)\n       {\n \t// First build the node to get its hash code.\n \t__node_type* __node = _M_allocate_node(std::forward<_Args>(__args)...);\n@@ -1658,7 +1684,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    __throw_exception_again;\n \t  }\n \n-\treturn _M_insert_multi_node(__code, __node);\n+\treturn _M_insert_multi_node(__hint._M_cur, __code, __node);\n       }\n \n   template<typename _Key, typename _Value,\n@@ -1710,7 +1736,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t_Traits>::iterator\n     _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t       _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-    _M_insert_multi_node(__hash_code __code, __node_type* __node)\n+    _M_insert_multi_node(__node_type* __hint, __hash_code __code,\n+\t\t\t __node_type* __node)\n     {\n       const __rehash_state& __saved_state = _M_rehash_policy._M_state();\n       std::pair<bool, std::size_t> __do_rehash\n@@ -1725,13 +1752,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  const key_type& __k = this->_M_extract()(__node->_M_v());\n \t  size_type __bkt = _M_bucket_index(__k, __code);\n \n-\t  // Find the node before an equivalent one.\n-\t  __node_base* __prev = _M_find_before_node(__bkt, __k, __code);\n+\t  // Find the node before an equivalent one or use hint if it exists and\n+\t  // if it is equivalent.\n+\t  __node_base* __prev\n+\t    = __builtin_expect(__hint != nullptr, false)\n+\t      && this->_M_equals(__k, __code, __hint)\n+\t\t? __hint\n+\t\t: _M_find_before_node(__bkt, __k, __code);\n \t  if (__prev)\n \t    {\n \t      // Insert after the node before the equivalent one.\n \t      __node->_M_nxt = __prev->_M_nxt;\n \t      __prev->_M_nxt = __node;\n+\t      if (__builtin_expect(__prev == __hint, false))\n+\t      \t// hint might be the last bucket node, in this case we need to\n+\t      \t// update next bucket.\n+\t      \tif (__node->_M_nxt\n+\t      \t    && !this->_M_equals(__k, __code, __node->_M_next()))\n+\t      \t  {\n+\t      \t    size_type __next_bkt = _M_bucket_index(__node->_M_next());\n+\t      \t    if (__next_bkt != __bkt)\n+\t      \t      _M_buckets[__next_bkt] = __node;\n+\t      \t  }\n \t    }\n \t  else\n \t    // The inserted node has no equivalent in the\n@@ -1786,7 +1828,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t  _Traits>::iterator\n       _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,\n \t\t _H1, _H2, _Hash, _RehashPolicy, _Traits>::\n-      _M_insert(_Arg&& __v, std::false_type)\n+      _M_insert(const_iterator __hint, _Arg&& __v, std::false_type)\n       {\n \t// First compute the hash code so that we don't do anything if it\n \t// throws.\n@@ -1795,7 +1837,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t// Second allocate new node so that we don't rehash if it throws.\n \t__node_type* __node = _M_allocate_node(std::forward<_Arg>(__v));\n \n-\treturn _M_insert_multi_node(__code, __node);\n+\treturn _M_insert_multi_node(__hint._M_cur, __code, __node);\n       }\n \n   template<typename _Key, typename _Value,"}, {"sha": "2ae0efa08b505607cca160131db82dfb84f09f5c", "filename": "libstdc++-v3/include/bits/hashtable_policy.h", "status": "modified", "additions": 22, "deletions": 15, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fhashtable_policy.h?ref=41349aec29110e04cea2ee9c9ea4e56365f42eed", "patch": "@@ -612,7 +612,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       using __unique_keys = typename __hashtable_base::__unique_keys;\n       using __ireturn_type = typename __hashtable_base::__ireturn_type;\n-      using __iconv_type = typename __hashtable_base::__iconv_type;\n \n       __hashtable&\n       _M_conjure_hashtable()\n@@ -626,8 +625,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       iterator\n-      insert(const_iterator, const value_type& __v)\n-      { return __iconv_type()(insert(__v)); }\n+      insert(const_iterator __hint, const value_type& __v)\n+      {\n+\t__hashtable& __h = _M_conjure_hashtable();\n+\treturn __h._M_insert(__hint, __v, __unique_keys());\n+      }\n \n       void\n       insert(initializer_list<value_type> __l)\n@@ -711,8 +713,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       iterator\n-      insert(const_iterator, value_type&& __v)\n-      { return insert(std::move(__v)).first; }\n+      insert(const_iterator __hint, value_type&& __v)\n+      {\n+\t__hashtable& __h = this->_M_conjure_hashtable();\n+\treturn __h._M_insert(__hint, std::move(__v), __unique_keys());\n+      }\n     };\n \n   /// Specialization.\n@@ -745,9 +750,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n       iterator\n-      insert(const_iterator, value_type&& __v)\n-      { return insert(std::move(__v)); }\n-     };\n+      insert(const_iterator __hint, value_type&& __v)\n+      {\n+\t__hashtable& __h = this->_M_conjure_hashtable();\n+\treturn __h._M_insert(__hint, std::move(__v), __unique_keys());\n+      }\n+    };\n \n   /// Specialization.\n   template<typename _Key, typename _Value, typename _Alloc,\n@@ -769,7 +777,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       using __unique_keys = typename __base_type::__unique_keys;\n       using __hashtable = typename __base_type::__hashtable;\n       using __ireturn_type = typename __base_type::__ireturn_type;\n-      using __iconv_type = typename __base_type::__iconv_type;\n \n       using __base_type::insert;\n \n@@ -792,8 +799,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       template<typename _Pair, typename = _IFconsp<_Pair>>\n \titerator\n-\tinsert(const_iterator, _Pair&& __v)\n-\t{ return __iconv_type()(insert(std::forward<_Pair>(__v))); }\n+\tinsert(const_iterator __hint, _Pair&& __v)\n+\t{\n+\t  __hashtable& __h = this->_M_conjure_hashtable();\n+\t  return __h._M_emplace(__hint, __unique_keys(),\n+\t\t\t\tstd::forward<_Pair>(__v));\n+\t}\n    };\n \n   /**\n@@ -1470,10 +1481,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     using __ireturn_type = typename std::conditional<__unique_keys::value,\n \t\t\t\t\t\t     std::pair<iterator, bool>,\n \t\t\t\t\t\t     iterator>::type;\n-\n-    using __iconv_type = typename  std::conditional<__unique_keys::value,\n-\t\t\t\t\t\t    _Select1st, _Identity\n-\t\t\t\t\t\t    >::type;\n   private:\n     using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;\n     using _EqualHelper =  _Equal_helper<_Key, _Value, _ExtractKey, _Equal,"}, {"sha": "f7bde0423dc64deeecd89c80041a075eebd948bc", "filename": "libstdc++-v3/testsuite/23_containers/unordered_multimap/insert/hint.cc", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fhint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fhint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_multimap%2Finsert%2Fhint.cc?ref=41349aec29110e04cea2ee9c9ea4e56365f42eed", "patch": "@@ -0,0 +1,123 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+// Insert with hint, specific to this library implementation.\n+\n+#include <iterator>\n+#include <unordered_map>\n+#include <testsuite_hooks.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_multimap<int, int> Map;\n+  typedef typename Map::value_type Pair;\n+\n+  Map m;\n+\n+  auto it1 = m.insert(Pair(0, 0));\n+  VERIFY( it1 != m.end() );\n+  VERIFY( it1->first == 0 );\n+  VERIFY( it1->second == 0 );\n+\n+  auto it2 = m.insert(it1, Pair(0, 2));\n+  VERIFY( it2 != m.end() );\n+  VERIFY( it2 != it1 );\n+  VERIFY( it2->second == 2 );\n+  VERIFY( it2 == std::next(it1) );\n+\n+  Pair p(0, 1);\n+  it2 = m.insert(it1, p);\n+  VERIFY( it2 == std::next(it1) );\n+}\n+\n+struct hasher\n+{\n+  std::size_t operator()(int val) const\n+  { return val / 2; }\n+};\n+\n+void test02()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_multimap<int, int, hasher> Map;\n+  typedef typename Map::value_type Pair;\n+\n+  Map m;\n+\n+  auto it1 = m.insert(Pair(0, 0));\n+  auto it2 = m.insert(it1, Pair(1, 0));\n+  VERIFY( m.bucket(it1->first) == m.bucket(it2->first) );\n+  VERIFY( m.bucket_size(m.bucket(it1->first)) == 2 );\n+\n+  auto it3 = m.insert(it2, Pair(2, 0));\n+  VERIFY( m.bucket(it3->first) != m.bucket(it2->first) );\n+  VERIFY( m.bucket_size(m.bucket(it3->first)) == 1 );\n+\n+  auto it4 = m.insert(it1, Pair(0, 1));\n+  VERIFY( it4 == std::next(it1) );\n+  VERIFY( m.bucket_size(m.bucket(it1->first)) == 3 );\n+  VERIFY( m.bucket_size(m.bucket(it3->first)) == 1 );\n+\n+  Pair p(1, 1);\n+  it4 = m.insert(it2, p);\n+  VERIFY( it4 == std::next(it2) );\n+  VERIFY( m.bucket_size(m.bucket(it1->first)) == 4 );\n+  auto range = m.equal_range(0);\n+  VERIFY( std::distance(range.first, range.second) == 2 );\n+  range = m.equal_range(1);\n+  VERIFY( std::distance(range.first, range.second) == 2 );\n+}\n+\n+void test03()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef std::unordered_multimap<int, int> Map;\n+  typedef typename Map::value_type Pair;\n+\n+  Map m;\n+\n+  auto it1 = m.insert(Pair(0, 0));\n+  VERIFY( it1 != m.end() );\n+  VERIFY( it1->first == 0 );\n+  VERIFY( it1->second == 0 );\n+\n+  auto it2 = m.emplace_hint(it1, std::piecewise_construct,\n+\t\t\t\t std::make_tuple(0),\n+\t\t\t\t std::make_tuple(2));\n+  VERIFY( it2 != m.end() );\n+  VERIFY( it2 != it1 );\n+  VERIFY( it2->second == 2 );\n+  VERIFY( it2 == std::next(it1) );\n+\n+  Pair p(0, 1);\n+  it2 = m.emplace_hint(it1, p);\n+  VERIFY( it2 == std::next(it1) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  test02();\n+  test03();\n+  return 0;\n+}"}, {"sha": "dcea9740689ba289dd4f1f35e715d1964446626d", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/instantiation_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Finstantiation_neg.cc?ref=41349aec29110e04cea2ee9c9ea4e56365f42eed", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"with noexcept\" \"\" { target *-*-* } 254 }\n+// { dg-error \"with noexcept\" \"\" { target *-*-* } 253 }\n \n #include <unordered_set>\n "}, {"sha": "e1b96a4a44bf567017247456a7ede5ac9053fdbc", "filename": "libstdc++-v3/testsuite/23_containers/unordered_set/not_default_constructible_hash_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Funordered_set%2Fnot_default_constructible_hash_neg.cc?ref=41349aec29110e04cea2ee9c9ea4e56365f42eed", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"default constructible\" \"\" { target *-*-* } 272 }\n+// { dg-error \"default constructible\" \"\" { target *-*-* } 271 }\n \n #include <unordered_set>\n "}, {"sha": "4e96ec1b840db6a118a2ad4d81663bffc868f749", "filename": "libstdc++-v3/testsuite/performance/23_containers/insert/unordered_multiset_hint.cc", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2Funordered_multiset_hint.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41349aec29110e04cea2ee9c9ea4e56365f42eed/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2Funordered_multiset_hint.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fperformance%2F23_containers%2Finsert%2Funordered_multiset_hint.cc?ref=41349aec29110e04cea2ee9c9ea4e56365f42eed", "patch": "@@ -0,0 +1,336 @@\n+// Copyright (C) 2013 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// { dg-options \"-std=gnu++11\" }\n+\n+#include <testsuite_performance.h>\n+\n+#include <sstream>\n+#include <string>\n+#include <vector>\n+#include <unordered_set>\n+\n+namespace\n+{\n+  const int sz = 2000000;\n+  const std::string pattern = \"test string #\";\n+  const int nb_copies = 100;\n+\n+  // Special std::string hasher based on std::hash<std::string> but not tag as\n+  // slow so that hash code is not cached. It is easier to show impact of\n+  // hinting in this context.\n+  struct hasher\n+  {\n+    std::size_t\n+    operator()(const std::string& str) const noexcept\n+    {\n+      //std::istringstream istr(str.substr(pattern.size()));\n+      //std::size_t str_index;\n+      //istr >> str_index;\n+      //return str_index;\n+      std::hash<std::string> std_hasher;\n+      return std_hasher(str);\n+    }\n+  };\n+\n+  using ums_t = std::unordered_multiset<std::string, hasher>;\n+\n+  void\n+  insert_with_perfect_hint1(const std::vector<std::string>& strs,\n+\t\t\t    ums_t& ms)\n+  {\n+    std::vector<typename ums_t::iterator> hints;\n+    hints.reserve(strs.size());\n+    for (auto str : strs)\n+      hints.push_back(ms.insert(str));\n+\n+    for (int j = 1; j != nb_copies; ++j)\n+      for (std::size_t i = 0; i != strs.size(); ++i)\n+\tms.insert(hints[i], strs[i]);\n+  }\n+\n+  void\n+  insert_with_perfect_hint2(const std::vector<std::string>& strs,\n+\t\t\t    ums_t& ms)\n+  {\n+    std::vector<typename ums_t::iterator> hints;\n+    hints.reserve(strs.size());\n+    for (auto str : strs)\n+      hints.push_back(ms.insert(str));\n+\n+    for (std::size_t i = 0; i != strs.size(); ++i)\n+      for (int j = 1; j != nb_copies; ++j)\n+\tms.insert(hints[i], strs[i]);\n+  }\n+\n+  // Always insert with the result of the previous insertion. The result of\n+  // the previous insertion will never be followed by an equivalent node\n+  // resulting in a re-computation of its hash code which is expensive.\n+  void\n+  insert_with_good_hint(const std::vector<std::string>& strs,\n+\t\t\tums_t& ms)\n+  {\n+    std::vector<typename ums_t::iterator> hints;\n+    hints.reserve(strs.size());\n+    for (auto str : strs)\n+      hints.push_back(ms.insert(str));\n+\n+    for (int j = 1; j != nb_copies; ++j)\n+      for (std::size_t i = 0; i != strs.size(); ++i)\n+\thints[i] = ms.insert(hints[i], strs[i]);\n+  }\n+\n+  // Note that the following use case is particularly bad especially compared to\n+  // the solution without hint because without hint the first insertion will put\n+  // it first in the bucket and following insertions will detect it and insert\n+  // just before. By giving a hint insertion will be done just after forcing to\n+  // check if it has no impact on the following bucket.\n+  void\n+  insert_with_bad_hint(const std::vector<std::string>& strs,\n+\t\t       ums_t& ms)\n+  {\n+    std::vector<typename ums_t::iterator> hints;\n+    hints.reserve(strs.size());\n+    for (auto str : strs)\n+      hints.push_back(ms.insert(str));\n+\n+    for (std::size_t i = 0; i != strs.size(); ++i)\n+      for (int j = 1; j != nb_copies; ++j)\n+\thints[i] = ms.insert(hints[i], strs[i]);\n+  }\n+\n+  void\n+  insert_without_hint1(const std::vector<std::string>& strs,\n+\t\t       ums_t& ms)\n+  {\n+    std::vector<typename ums_t::iterator> hints;\n+    hints.reserve(strs.size());\n+    for (auto str : strs)\n+      hints.push_back(ms.insert(str));\n+\n+    for (int j = 1; j != nb_copies; ++j)\n+      for (std::size_t i = 0; i != strs.size(); ++i)\n+\thints[i] = ms.insert(strs[i]);\n+  }\n+\n+  // This version is the best one if you insert all equivalent elements at the\n+  // same time. It demonstrates that most of the time it is better not to give\n+  // any hint unless you have written a benchmark for your application showing\n+  // that it does have a positive effect.\n+  void\n+  insert_without_hint2(const std::vector<std::string>& strs,\n+\t\t       ums_t& ms)\n+  {\n+    std::vector<typename ums_t::iterator> hints;\n+    hints.reserve(strs.size());\n+    for (auto str : strs)\n+      hints.push_back(ms.insert(str));\n+\n+    for (std::size_t i = 0; i != strs.size(); ++i)\n+      for (int j = 1; j != nb_copies; ++j)\n+\thints[i] = ms.insert(strs[i]);\n+  }\n+\n+  void\n+  insert_with_any_hint1(const std::vector<std::string>& strs,\n+\t\t\tums_t& ms)\n+  {\n+    std::vector<typename ums_t::iterator> hints;\n+    hints.reserve(strs.size());\n+    for (auto str : strs)\n+      hints.push_back(ms.insert(ms.begin(), str));\n+\n+    std::size_t offset = strs.size() / 2;\n+    for (int j = 1; j != nb_copies; ++j)\n+      for (std::size_t i = 0; i != strs.size(); ++i)\n+\t{\n+\t  ms.insert(hints[(i + offset) % hints.size()], strs[i]);\n+\t  ++offset;\n+\t}\n+  }\n+\n+  void\n+  insert_with_any_hint2(const std::vector<std::string>& strs,\n+\t\t\tums_t& ms)\n+  {\n+    std::vector<typename ums_t::iterator> hints;\n+    hints.reserve(strs.size());\n+    for (auto str : strs)\n+      hints.push_back(ms.insert(ms.begin(), str));\n+\n+    std::size_t offset = strs.size() / 2;\n+    for (std::size_t i = 0; i != strs.size(); ++i)\n+      for (int j = 1; j != nb_copies; ++j)\n+\t{\n+\t  ms.insert(hints[(i + offset) % hints.size()], strs[i]);\n+\t  ++offset;\n+\t}\n+  }\n+}\n+\n+int main()\n+{\n+  using namespace __gnu_test;\n+\n+  const int nb_iter = 10;\n+\n+  std::vector<std::string> strs;\n+  strs.reserve(sz / nb_copies);\n+\n+  for (int i = 0; i != sz / nb_copies; ++i)\n+    {\n+      std::ostringstream osstr;\n+      osstr << pattern << i;\n+      strs.push_back(osstr.str());\n+    }\n+\n+  ums_t ms;\n+  // Use a large load factor to make the context ideal for using hint because we\n+  // will have many elements per bucket.\n+  ms.max_load_factor(10.0f);\n+  ms.reserve(sz);\n+\n+  // Warm up.\n+  {\n+    for (auto str : strs)\n+      for (int j = 0; j != nb_copies; ++j)\n+\tms.insert(str);\n+  }\n+\n+  time_counter time_no_hint1, time_any_hint1, time_bad_hint, time_perfect_hint1;\n+  time_counter time_no_hint2, time_any_hint2, time_good_hint, time_perfect_hint2;\n+  resource_counter resource_no_hint1, resource_any_hint1, resource_bad_hint,\n+    resource_perfect_hint1;\n+  resource_counter resource_no_hint2, resource_any_hint2, resource_good_hint,\n+    resource_perfect_hint2;\n+\n+  for (int i = 0; i != nb_iter; ++i)\n+    {\n+      // Bad hint\n+      {\n+\tms.clear();\n+\tstart_counters(time_bad_hint, resource_bad_hint);\n+\tinsert_with_bad_hint(strs, ms);\n+\tstop_counters(time_bad_hint, resource_bad_hint);\n+      }\n+\n+      // No hint\n+      {\n+\tms.clear();\n+\tstart_counters(time_no_hint1, resource_no_hint1);\n+\tinsert_without_hint1(strs, ms);\n+\tstop_counters(time_no_hint1, resource_no_hint1);\n+      }\n+\n+      // Any hint\n+      {\n+\tms.clear();\n+\tstart_counters(time_any_hint1, resource_any_hint1);\n+\tinsert_with_any_hint1(strs, ms);\n+\tstop_counters(time_any_hint1, resource_any_hint1);\n+      }\n+\n+      // Good hint\n+      {\n+\tms.clear();\n+\tstart_counters(time_good_hint, resource_good_hint);\n+\tinsert_with_good_hint(strs, ms);\n+\tstop_counters(time_good_hint, resource_good_hint);\n+      }\n+\n+      // No hint\n+      {\n+\tms.clear();\n+\tstart_counters(time_no_hint2, resource_no_hint2);\n+\tinsert_without_hint2(strs, ms);\n+\tstop_counters(time_no_hint2, resource_no_hint2);\n+      }\n+\n+      // Perfect hint\n+      {\n+\tms.clear();\n+\tstart_counters(time_perfect_hint2, resource_perfect_hint2);\n+\tinsert_with_perfect_hint2(strs, ms);\n+\tstop_counters(time_perfect_hint2, resource_perfect_hint2);\n+      }\n+\n+      // Any hint\n+      {\n+\tms.clear();\n+\tstart_counters(time_any_hint2, resource_any_hint2);\n+\tinsert_with_any_hint2(strs, ms);\n+\tstop_counters(time_any_hint2, resource_any_hint2);\n+      }\n+\n+      // Perfect hint\n+      {\n+\tms.clear();\n+\tstart_counters(time_perfect_hint1, resource_perfect_hint1);\n+\tinsert_with_perfect_hint1(strs, ms);\n+\tstop_counters(time_perfect_hint1, resource_perfect_hint1);\n+      }\n+    }\n+\n+  std::ostringstream ostr;\n+  ostr << \"unordered_set \" << nb_copies << \" X \" << sz / nb_copies\n+       << \" insertions w/o hint\";\n+  report_performance(__FILE__, ostr.str().c_str(),\n+\t\t     time_no_hint1, resource_no_hint1);\n+\n+  ostr.str(\"\");\n+  ostr << \"unordered_set \" << nb_copies << \" X \" << sz / nb_copies\n+       << \" insertions with any hint\";\n+  report_performance(__FILE__, ostr.str().c_str(),\n+\t\t     time_any_hint1, resource_any_hint1);\n+\n+  ostr.str(\"\");\n+  ostr << \"unordered_set \" << nb_copies << \" X \" << sz / nb_copies\n+       << \" insertions with good hint\";\n+  report_performance(__FILE__, ostr.str().c_str(),\n+\t\t     time_good_hint, resource_good_hint);\n+\n+  ostr.str(\"\");\n+  ostr << \"unordered_set \" << nb_copies << \" X \" << sz / nb_copies\n+       << \" insertions with perfect hint\";\n+  report_performance(__FILE__, ostr.str().c_str(),\n+\t\t     time_perfect_hint1, resource_perfect_hint1);\n+\n+  ostr.str(\"\");\n+  ostr << \"unordered_set \" << sz / nb_copies << \" X \" << nb_copies\n+       << \" insertions w/o hint\";\n+  report_performance(__FILE__, ostr.str().c_str(),\n+\t\t     time_no_hint2, resource_no_hint2);\n+\n+  ostr.str(\"\");\n+  ostr << \"unordered_set \" << sz / nb_copies << \" X \" << nb_copies\n+       << \" insertions with any hint\";\n+  report_performance(__FILE__, ostr.str().c_str(),\n+\t\t     time_any_hint2, resource_any_hint2);\n+\n+  ostr.str(\"\");\n+  ostr << \"unordered_set \" << sz / nb_copies << \" X \" << nb_copies\n+       << \" insertions with bad hint\";\n+  report_performance(__FILE__, ostr.str().c_str(),\n+\t\t     time_bad_hint, resource_bad_hint);\n+\n+  ostr.str(\"\");\n+  ostr << \"unordered_set \" << sz / nb_copies << \" X \" << nb_copies\n+       << \" insertions with perfect hint\";\n+  report_performance(__FILE__, ostr.str().c_str(),\n+\t\t     time_perfect_hint2, resource_perfect_hint2);\n+  return 0;\n+}"}]}