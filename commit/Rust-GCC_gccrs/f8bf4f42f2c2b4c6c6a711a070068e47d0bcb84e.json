{"sha": "f8bf4f42f2c2b4c6c6a711a070068e47d0bcb84e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjhiZjRmNDJmMmMyYjRjNmM2YTcxMWEwNzAwNjhlNDdkMGJjYjg0ZQ==", "commit": {"author": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-19T05:35:37Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2005-04-19T05:35:37Z"}, "message": "[multiple changes]\n\n2005-04-19  Roman Kennke  <roman@kennke.org>\n\n\t* javax/swing/BoxLayout.java:\n\t(layoutContainer): Made this layout manager respect the\n\tminimum, maximum and preferred size more correctly.\n\n2005-04-19  Roman Kennke  <roman@ontographics.com>\n\n\t* javax/swing/BoxLayout.java:\n\t(preferredLayoutSize,minimumLayoutSize,maximumLayoutSize,\n\tlayoutContainer): Make these methods and thereby the\n\tBoxLayout respect the insets (like borders) of the\n\tcomponent that is laid out.\n\nFrom-SVN: r98378", "tree": {"sha": "f3d2f890b33c9d970edd8abac1ee84335f5e6193", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3d2f890b33c9d970edd8abac1ee84335f5e6193"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f8bf4f42f2c2b4c6c6a711a070068e47d0bcb84e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8bf4f42f2c2b4c6c6a711a070068e47d0bcb84e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f8bf4f42f2c2b4c6c6a711a070068e47d0bcb84e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f8bf4f42f2c2b4c6c6a711a070068e47d0bcb84e/comments", "author": null, "committer": null, "parents": [{"sha": "615af6564e786fc91c09bafd1c60bf421d88f1f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/615af6564e786fc91c09bafd1c60bf421d88f1f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/615af6564e786fc91c09bafd1c60bf421d88f1f1"}], "stats": {"total": 174, "additions": 147, "deletions": 27}, "files": [{"sha": "032497df21a315754be05ea0b0e303b65afdcdc8", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf4f42f2c2b4c6c6a711a070068e47d0bcb84e/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf4f42f2c2b4c6c6a711a070068e47d0bcb84e/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=f8bf4f42f2c2b4c6c6a711a070068e47d0bcb84e", "patch": "@@ -1,3 +1,17 @@\n+2005-04-19  Roman Kennke  <roman@kennke.org>\n+\n+\t* javax/swing/BoxLayout.java:\n+\t(layoutContainer): Made this layout manager respect the\n+\tminimum, maximum and preferred size more correctly.\n+\n+2005-04-19  Roman Kennke  <roman@ontographics.com>\n+\n+\t* javax/swing/BoxLayout.java:\n+\t(preferredLayoutSize,minimumLayoutSize,maximumLayoutSize,\n+\tlayoutContainer): Make these methods and thereby the\n+\tBoxLayout respect the insets (like borders) of the\n+\tcomponent that is laid out.\n+\n 2005-04-19  Roman Kennke  <roman@kennke.org>\n \n \t* javax/swing/JComponent.java:"}, {"sha": "384eb69410ce0963ef2a26a3742d9cd19e83d60c", "filename": "libjava/javax/swing/BoxLayout.java", "status": "modified", "additions": 133, "deletions": 27, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f8bf4f42f2c2b4c6c6a711a070068e47d0bcb84e/libjava%2Fjavax%2Fswing%2FBoxLayout.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f8bf4f42f2c2b4c6c6a711a070068e47d0bcb84e/libjava%2Fjavax%2Fswing%2FBoxLayout.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjavax%2Fswing%2FBoxLayout.java?ref=f8bf4f42f2c2b4c6c6a711a070068e47d0bcb84e", "patch": "@@ -42,6 +42,7 @@\n import java.awt.ComponentOrientation;\n import java.awt.Container;\n import java.awt.Dimension;\n+import java.awt.Insets;\n import java.awt.LayoutManager2;\n import java.io.Serializable;\n \n@@ -146,8 +147,9 @@ public Dimension preferredLayoutSize(Container parent)\n     if (parent != container)\n       throw new AWTError(\"invalid parent\");\n \n-    int x = 0;\n-    int y = 0;\n+    Insets insets = parent.getInsets();\n+    int x = insets.left + insets.right;\n+    int y = insets.bottom + insets.top;\n \n     Component[] children = parent.getComponents();\n \n@@ -191,8 +193,9 @@ public Dimension minimumLayoutSize(Container parent)\n     if (parent != container)\n       throw new AWTError(\"invalid parent\");\n \n-    int x = 0;\n-    int y = 0;\n+    Insets insets = parent.getInsets();\n+    int x = insets.left + insets.right;\n+    int y = insets.bottom + insets.top;\n \n     Component[] children = parent.getComponents();\n \n@@ -235,53 +238,155 @@ public void layoutContainer(Container parent)\n       throw new AWTError(\"invalid parent\");\n \n     Dimension size = parent.getSize();\n-\n+    Insets insets = parent.getInsets();\n+    Dimension innerSize = new Dimension(size.width - insets.left\n+                                        - insets.right, size.height\n+                                        - insets.bottom - insets.top);\n     Component[] children = parent.getComponents();\n+    boolean[] laidOut = new boolean[children.length];\n+    for (int index = 0; index < laidOut.length; index++)\n+      laidOut[index] = false;\n \n     if (isHorizontalIn(parent))\n       {\n-        int x = 0;\n+        // compute overall preferred width\n+        int preferredWidthAll = 0;\n+        for (int index = 0; index < children.length; index++)\n+          {\n+            preferredWidthAll += children[index].getPreferredSize().width;\n+          }\n+        double widthFactor = (double) innerSize.width /\n+          (double) preferredWidthAll;\n+\n+        // sort out components that are constrained by minimum or maximum size\n+        int widthRemain = innerSize.width;\n         for (int index = 0; index < children.length; index++)\n           {\n             Component comp = children[index];\n             Dimension sz = comp.getPreferredSize();\n-            int width = sz.width;\n-            int height = sz.height;\n-            int cy = 0;\n-            if (height > size.height)\n+            Dimension minSize = comp.getMinimumSize();\n+            Dimension maxSize = comp.getMaximumSize();\n+            int width = (int) (sz.width * widthFactor);\n+            int height = Math.min(innerSize.height, maxSize.height);\n+            // check min size\n+            if (width < minSize.width)\n               {\n-                height = size.height;\n+                width = minSize.width;\n+                comp.setSize(width, height);\n+                laidOut[index] = true;\n+                preferredWidthAll -= sz.width;\n+                widthRemain -= width;\n+                continue;\n               }\n-            else\n+            // check max size\n+            if (width > maxSize.width)\n               {\n-                cy = (int) ((size.height - height) * comp.getAlignmentY());\n+                width = maxSize.width;\n+                comp.setSize(width, height);\n+                laidOut[index] = true;\n+                preferredWidthAll -= sz.width;\n+                widthRemain -= width;\n+                continue;\n               }\n-            \n-            comp.setSize(width, height);\n+\n+          }\n+\n+        // recompute widthFactor for remaining components\n+        widthFactor = (double) widthRemain / (double) preferredWidthAll;\n+\n+        int x = insets.left;\n+\n+        // lay out remaining comonents\n+        for (int index = 0; index < children.length; index++)\n+          {\n+            Component comp = children[index];\n+            int width = 0;\n+\n+            if (!laidOut[index])\n+              {\n+                Dimension sz = comp.getPreferredSize();\n+                Dimension maxSize = comp.getMaximumSize();\n+                width = (int) (sz.width * widthFactor);\n+                int height = Math.min(innerSize.height, maxSize.height);\n+                comp.setSize(width, height);\n+              }\n+            else\n+                width = comp.getWidth();\n+\n+            int cy = (int) ((innerSize.height - comp.getHeight())\n+              * comp.getAlignmentY() + insets.top);\n             comp.setLocation(x, cy);\n             x = x + width;            \n           }\n       }\n     else\n       {\n-        int y = 0;        \n+        // compute overall preferred height\n+        int preferredHeightAll = 0;\n+        for (int index = 0; index < children.length; index++)\n+          {\n+            preferredHeightAll += children[index].getPreferredSize().height;\n+          }\n+        double heightFactor = (double) innerSize.height /\n+          (double) preferredHeightAll;\n+\n+        // sort out components that are constrained by minimum or maximum size\n+        int heightRemain = innerSize.height;\n         for (int index = 0; index < children.length; index++)\n           {\n             Component comp = children[index];\n             Dimension sz = comp.getPreferredSize();\n-            int width = sz.width;\n-            int height = sz.height;\n-            int cx = 0;\n-            if (width > size.width)\n+            Dimension minSize = comp.getMinimumSize();\n+            Dimension maxSize = comp.getMaximumSize();\n+            int height = (int) (sz.height * heightFactor);\n+            int width = Math.min(innerSize.width, maxSize.width);\n+            // check min size\n+            if (height < minSize.height)\n               {\n-                width = size.width;\n+                height = minSize.height;\n+                comp.setSize(width, height);\n+                laidOut[index] = true;\n+                preferredHeightAll -= sz.height;\n+                heightRemain -= height;\n+                continue;\n               }\n-            else\n+            // check max size\n+            if (height > maxSize.height)\n+              {\n+                height = maxSize.height;\n+                comp.setSize(width, height);\n+                laidOut[index] = true;\n+                preferredHeightAll -= sz.height;\n+                heightRemain -= height;\n+                continue;\n+              }\n+\n+          }\n+\n+        // recompute heightFactor for remaining components\n+        heightFactor = (double) heightRemain / (double) preferredHeightAll;\n+\n+        int y = insets.top;\n+\n+        // lay out remaining comonents\n+        for (int index = 0; index < children.length; index++)\n+          {\n+            Component comp = children[index];\n+            int height = 0;\n+\n+            if (!laidOut[index])\n               {\n-                cx = (int) ((size.width - width) * comp.getAlignmentX());\n+                Dimension sz = comp.getPreferredSize();\n+                Dimension maxSize = comp.getMaximumSize();\n+                height = (int) (sz.height * heightFactor);\n+                int width = Math.min(innerSize.width, maxSize.width);\n+                comp.setSize(width, height);\n               }\n-            \n-            comp.setSize(width, height);\n+            else\n+              height = comp.getHeight();\n+\n+            int cx = (int) ((innerSize.width - comp.getWidth())\n+              * comp.getAlignmentX() + insets.left);\n             comp.setLocation(cx, y);\n             y = y + height;            \n           }\n@@ -352,8 +457,9 @@ public Dimension maximumLayoutSize(Container parent)\n     if (parent != container)\n       throw new AWTError(\"invalid parent\");\n \n-    int x = 0;\n-    int y = 0;\n+    Insets insets = parent.getInsets();\n+    int x = insets.left + insets.right;\n+    int y = insets.top + insets.bottom;\n \n     Component[] children = parent.getComponents();\n "}]}