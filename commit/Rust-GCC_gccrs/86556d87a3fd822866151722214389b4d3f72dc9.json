{"sha": "86556d87a3fd822866151722214389b4d3f72dc9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY1NTZkODdhM2ZkODIyODY2MTUxNzIyMjE0Mzg5YjRkM2Y3MmRjOQ==", "commit": {"author": {"name": "Ben Elliston", "email": "bje@au.ibm.com", "date": "2005-11-24T02:50:02Z"}, "committer": {"name": "Ben Elliston", "email": "bje@gcc.gnu.org", "date": "2005-11-24T02:50:02Z"}, "message": "machmode.h (CLASS_HAS_WIDER_MODES_P): New macro.\n\n\t* machmode.h (CLASS_HAS_WIDER_MODES_P): New macro.\n\t* optabs.c (expand_binop): Use CLASS_HAS_WIDER_MODES_P, improve\n\tformatting.\n\t(expand_twoval_unop): Likewise.\n\t(widen_clz): Likewise.\n\t(expand_parity): Likewise.\n\t(expand_unop): Likewise.\n\t(emit_cmp_and_jmp_insn_1): Likewise.\n\t(prepare_float_lib_cmp): Likewise.\n\nFrom-SVN: r107450", "tree": {"sha": "6553b3a7d61573e66048e19c1859f5e43ef79c03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6553b3a7d61573e66048e19c1859f5e43ef79c03"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/86556d87a3fd822866151722214389b4d3f72dc9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86556d87a3fd822866151722214389b4d3f72dc9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/86556d87a3fd822866151722214389b4d3f72dc9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/86556d87a3fd822866151722214389b4d3f72dc9/comments", "author": null, "committer": null, "parents": [{"sha": "94044657e9a3b514a5b38e71156290a4c7d2a474", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94044657e9a3b514a5b38e71156290a4c7d2a474", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94044657e9a3b514a5b38e71156290a4c7d2a474"}], "stats": {"total": 65, "additions": 46, "deletions": 19}, "files": [{"sha": "67e050a72e632b8c0ca6e7cc701d87a4c9387533", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86556d87a3fd822866151722214389b4d3f72dc9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86556d87a3fd822866151722214389b4d3f72dc9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=86556d87a3fd822866151722214389b4d3f72dc9", "patch": "@@ -1,3 +1,15 @@\n+2005-11-24  Ben Elliston  <bje@au.ibm.com>\n+\n+\t* machmode.h (CLASS_HAS_WIDER_MODES_P): New macro.\n+\t* optabs.c (expand_binop): Use CLASS_HAS_WIDER_MODES_P, improve\n+\tformatting.\n+\t(expand_twoval_unop): Likewise.\n+\t(widen_clz): Likewise.\n+\t(expand_parity): Likewise.\n+\t(expand_unop): Likewise.\n+\t(emit_cmp_and_jmp_insn_1): Likewise.\n+\t(prepare_float_lib_cmp): Likewise.\n+\n 2005-11-24  Ben Elliston  <bje@au.ibm.com>\n \n \t* optabs.c (prepare_cmp_insn): Use SCALAR_FLOAT_MODE_P."}, {"sha": "1ba5963326cb32ffedae5f3d18893277cc6a452c", "filename": "gcc/machmode.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86556d87a3fd822866151722214389b4d3f72dc9/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86556d87a3fd822866151722214389b4d3f72dc9/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=86556d87a3fd822866151722214389b4d3f72dc9", "patch": "@@ -76,6 +76,12 @@ extern const unsigned char mode_class[NUM_MACHINE_MODES];\n #define SCALAR_FLOAT_MODE_P(MODE)\t\t\\\n   (GET_MODE_CLASS (MODE) == MODE_FLOAT)\n \n+/* Nonzero if CLASS modes can be widened.  */\n+#define CLASS_HAS_WIDER_MODES_P(CLASS)         \\\n+  (CLASS == MODE_INT                           \\\n+   || CLASS == MODE_FLOAT                      \\\n+   || CLASS == MODE_COMPLEX_FLOAT)\n+\n /* Get the size in bytes and bits of an object of mode MODE.  */\n \n extern CONST_MODE_SIZE unsigned char mode_size[NUM_MACHINE_MODES];"}, {"sha": "b01b3dea8addea2ce8e51f2a8065e44e78ff5dcb", "filename": "gcc/optabs.c", "status": "modified", "additions": 28, "deletions": 19, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/86556d87a3fd822866151722214389b4d3f72dc9/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/86556d87a3fd822866151722214389b4d3f72dc9/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=86556d87a3fd822866151722214389b4d3f72dc9", "patch": "@@ -1192,7 +1192,8 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* If this is a multiply, see if we can do a widening operation that\n      takes operands of this mode and makes a wider mode.  */\n \n-  if (binoptab == smul_optab && GET_MODE_WIDER_MODE (mode) != VOIDmode\n+  if (binoptab == smul_optab\n+      && GET_MODE_WIDER_MODE (mode) != VOIDmode\n       && (((unsignedp ? umul_widen_optab : smul_widen_optab)\n \t   ->handlers[(int) GET_MODE_WIDER_MODE (mode)].insn_code)\n \t  != CODE_FOR_nothing))\n@@ -1216,9 +1217,10 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n      can open-code the operation.  Check for a widening multiply at the\n      wider mode as well.  */\n \n-  if ((class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n+  if (CLASS_HAS_WIDER_MODES_P (class)\n       && methods != OPTAB_DIRECT && methods != OPTAB_LIB)\n-    for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+    for (wider_mode = GET_MODE_WIDER_MODE (mode);\n+\t wider_mode != VOIDmode;\n \t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n       {\n \tif (binoptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing\n@@ -1747,9 +1749,10 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n   /* Look for a wider mode of the same class for which it appears we can do\n      the operation.  */\n \n-  if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n+  if (CLASS_HAS_WIDER_MODES_P (class))\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n+\t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n \t  if ((binoptab->handlers[(int) wider_mode].insn_code\n@@ -1921,9 +1924,10 @@ expand_twoval_unop (optab unoptab, rtx op0, rtx targ0, rtx targ1,\n \n   /* It can't be done in this mode.  Can we do it in a wider mode?  */\n \n-  if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n+  if (CLASS_HAS_WIDER_MODES_P (class))\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n+\t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n \t  if (unoptab->handlers[(int) wider_mode].insn_code\n@@ -2043,9 +2047,10 @@ expand_twoval_binop (optab binoptab, rtx op0, rtx op1, rtx targ0, rtx targ1,\n \n   /* It can't be done in this mode.  Can we do it in a wider mode?  */\n \n-  if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n+  if (CLASS_HAS_WIDER_MODES_P (class))\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n+\t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n \t  if (binoptab->handlers[(int) wider_mode].insn_code\n@@ -2142,10 +2147,11 @@ static rtx\n widen_clz (enum machine_mode mode, rtx op0, rtx target)\n {\n   enum mode_class class = GET_MODE_CLASS (mode);\n-  if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n+  if (CLASS_HAS_WIDER_MODES_P (class))\n     {\n       enum machine_mode wider_mode;\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n+\t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n \t  if (clz_optab->handlers[(int) wider_mode].insn_code\n@@ -2180,7 +2186,7 @@ static rtx\n expand_parity (enum machine_mode mode, rtx op0, rtx target)\n {\n   enum mode_class class = GET_MODE_CLASS (mode);\n-  if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n+  if (CLASS_HAS_WIDER_MODES_P (class))\n     {\n       enum machine_mode wider_mode;\n       for (wider_mode = mode; wider_mode != VOIDmode;\n@@ -2412,8 +2418,9 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \tgoto try_libcall;\n     }\n \n-  if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n-    for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+  if (CLASS_HAS_WIDER_MODES_P (class))\n+    for (wider_mode = GET_MODE_WIDER_MODE (mode);\n+\t wider_mode != VOIDmode;\n \t wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n       {\n \tif (unoptab->handlers[(int) wider_mode].insn_code != CODE_FOR_nothing)\n@@ -2551,9 +2558,10 @@ expand_unop (enum machine_mode mode, optab unoptab, rtx op0, rtx target,\n \n   /* It can't be done in this mode.  Can we do it in a wider mode?  */\n \n-  if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n+  if (CLASS_HAS_WIDER_MODES_P (class))\n     {\n-      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+      for (wider_mode = GET_MODE_WIDER_MODE (mode);\n+\t   wider_mode != VOIDmode;\n \t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n \t{\n \t  if ((unoptab->handlers[(int) wider_mode].insn_code\n@@ -3633,8 +3641,7 @@ emit_cmp_and_jump_insn_1 (rtx x, rtx y, enum machine_mode mode,\n \t  return;\n \t}\n \n-      if (class != MODE_INT && class != MODE_FLOAT\n-\t  && class != MODE_COMPLEX_FLOAT)\n+      if (!CLASS_HAS_WIDER_MODES_P (class))\n \tbreak;\n \n       wider_mode = GET_MODE_WIDER_MODE (wider_mode);\n@@ -3720,7 +3727,9 @@ prepare_float_lib_cmp (rtx *px, rtx *py, enum rtx_code *pcomparison,\n   rtx libfunc = 0;\n   bool reversed_p = false;\n \n-  for (mode = orig_mode; mode != VOIDmode; mode = GET_MODE_WIDER_MODE (mode))\n+  for (mode = orig_mode;\n+       mode != VOIDmode;\n+       mode = GET_MODE_WIDER_MODE (mode))\n     {\n       if ((libfunc = code_to_optab[comparison]->handlers[mode].libfunc))\n \tbreak;"}]}