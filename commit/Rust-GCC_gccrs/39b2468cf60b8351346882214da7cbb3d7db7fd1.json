{"sha": "39b2468cf60b8351346882214da7cbb3d7db7fd1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzliMjQ2OGNmNjBiODM1MTM0Njg4MjIxNGRhN2NiYjNkN2RiN2ZkMQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2013-11-08T22:15:09Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2013-11-08T22:15:09Z"}, "message": "[multiple changes]\n\n2013-11-08  Andrew MacLeod  <amacleod@redhat.com>\n\t    Joseph Myers  <joseph@codesourcery.com>\n\n\t* ginclude/stdatomic.h: New file.\n\t* Makefile.in (USER_H): Add stdatomic.h.\n\ntestsuite:\n2013-11-08  Joseph Myers  <joseph@codesourcery.com>\n\n\t* gcc.dg/atomic/stdatomic-compare-exchange-1.c,\n\tgcc.dg/atomic/stdatomic-compare-exchange-2.c,\n\tgcc.dg/atomic/stdatomic-compare-exchange-3.c,\n\tgcc.dg/atomic/stdatomic-compare-exchange-4.c,\n\tgcc.dg/atomic/stdatomic-exchange-1.c,\n\tgcc.dg/atomic/stdatomic-exchange-2.c,\n\tgcc.dg/atomic/stdatomic-exchange-3.c,\n\tgcc.dg/atomic/stdatomic-exchange-4.c,\n\tgcc.dg/atomic/stdatomic-fence.c, gcc.dg/atomic/stdatomic-flag.c,\n\tgcc.dg/atomic/stdatomic-generic.c,\n\tgcc.dg/atomic/stdatomic-kill-dep.c,\n\tgcc.dg/atomic/stdatomic-load-1.c,\n\tgcc.dg/atomic/stdatomic-load-2.c,\n\tgcc.dg/atomic/stdatomic-load-3.c,\n\tgcc.dg/atomic/stdatomic-load-4.c,\n\tgcc.dg/atomic/stdatomic-lockfree.c,\n\tgcc.dg/atomic/stdatomic-op-1.c, gcc.dg/atomic/stdatomic-op-2.c,\n\tgcc.dg/atomic/stdatomic-op-3.c, gcc.dg/atomic/stdatomic-op-4.c,\n\tgcc.dg/atomic/stdatomic-store-1.c,\n\tgcc.dg/atomic/stdatomic-store-2.c,\n\tgcc.dg/atomic/stdatomic-store-3.c,\n\tgcc.dg/atomic/stdatomic-store-4.c, gcc.dg/c11-stdatomic-1.c: New\n\ttests.\n\nFrom-SVN: r204603", "tree": {"sha": "8cd7d5499cfd5e888443c1b00f1d3e46994c58b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8cd7d5499cfd5e888443c1b00f1d3e46994c58b4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/39b2468cf60b8351346882214da7cbb3d7db7fd1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39b2468cf60b8351346882214da7cbb3d7db7fd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39b2468cf60b8351346882214da7cbb3d7db7fd1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39b2468cf60b8351346882214da7cbb3d7db7fd1/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9fc0e24b6c36db7fab166148d3c20dc11979d26b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fc0e24b6c36db7fab166148d3c20dc11979d26b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fc0e24b6c36db7fab166148d3c20dc11979d26b"}], "stats": {"total": 2819, "additions": 2819, "deletions": 0}, "files": [{"sha": "8c52a6cc03f495f10d070c5aa40b525c3bc5c509", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -1,3 +1,9 @@\n+2013-11-08  Andrew MacLeod  <amacleod@redhat.com>\n+\t    Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* ginclude/stdatomic.h: New file.\n+\t* Makefile.in (USER_H): Add stdatomic.h.\n+\n 2013-11-08  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/arm/arm.c (arm_new_rtx_costs): Break after handling"}, {"sha": "49285e5f73207947a75ae3c55d98fc440a89afa6", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -381,6 +381,7 @@ USER_H = $(srcdir)/ginclude/float.h \\\n \t $(srcdir)/ginclude/stdfix.h \\\n \t $(srcdir)/ginclude/stdnoreturn.h \\\n \t $(srcdir)/ginclude/stdalign.h \\\n+\t $(srcdir)/ginclude/stdatomic.h \\\n \t $(EXTRA_HEADERS)\n \n USER_H_INC_NEXT_PRE = @user_headers_inc_next_pre@"}, {"sha": "622577f0877327278e35f6755a1c367365a036d0", "filename": "gcc/ginclude/stdatomic.h", "status": "added", "additions": 244, "deletions": 0, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Fginclude%2Fstdatomic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Fginclude%2Fstdatomic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fstdatomic.h?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,244 @@\n+/* Copyright (C) 2013 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* ISO C11 Standard:  7.17  Atomics <stdatomic.h>.  */\n+\n+#ifndef _STDATOMIC_H\n+#define _STDATOMIC_H\n+\n+typedef enum\n+  {\n+    memory_order_relaxed = __ATOMIC_RELAXED,\n+    memory_order_consume = __ATOMIC_CONSUME,\n+    memory_order_acquire = __ATOMIC_ACQUIRE,\n+    memory_order_release = __ATOMIC_RELEASE,\n+    memory_order_acq_rel = __ATOMIC_ACQ_REL,\n+    memory_order_seq_cst = __ATOMIC_SEQ_CST\n+  } memory_order;\n+\n+\n+typedef _Atomic _Bool atomic_bool;\n+typedef _Atomic char atomic_char;\n+typedef _Atomic signed char atomic_schar;\n+typedef _Atomic unsigned char atomic_uchar;\n+typedef _Atomic short atomic_short;\n+typedef _Atomic unsigned short atomic_ushort;\n+typedef _Atomic int atomic_int;\n+typedef _Atomic unsigned int atomic_uint;\n+typedef _Atomic long atomic_long;\n+typedef _Atomic unsigned long atomic_ulong;\n+typedef _Atomic long long atomic_llong;\n+typedef _Atomic unsigned long long atomic_ullong;\n+typedef _Atomic __CHAR16_TYPE__ atomic_char16_t;\n+typedef _Atomic __CHAR32_TYPE__ atomic_char32_t;\n+typedef _Atomic __WCHAR_TYPE__ atomic_wchar_t;\n+typedef _Atomic __INT_LEAST8_TYPE__ atomic_int_least8_t;\n+typedef _Atomic __UINT_LEAST8_TYPE__ atomic_uint_least8_t;\n+typedef _Atomic __INT_LEAST16_TYPE__ atomic_int_least16_t;\n+typedef _Atomic __UINT_LEAST16_TYPE__ atomic_uint_least16_t;\n+typedef _Atomic __INT_LEAST32_TYPE__ atomic_int_least32_t;\n+typedef _Atomic __UINT_LEAST32_TYPE__ atomic_uint_least32_t;\n+typedef _Atomic __INT_LEAST64_TYPE__ atomic_int_least64_t;\n+typedef _Atomic __UINT_LEAST64_TYPE__ atomic_uint_least64_t;\n+typedef _Atomic __INT_FAST8_TYPE__ atomic_int_fast8_t;\n+typedef _Atomic __UINT_FAST8_TYPE__ atomic_uint_fast8_t;\n+typedef _Atomic __INT_FAST16_TYPE__ atomic_int_fast16_t;\n+typedef _Atomic __UINT_FAST16_TYPE__ atomic_uint_fast16_t;\n+typedef _Atomic __INT_FAST32_TYPE__ atomic_int_fast32_t;\n+typedef _Atomic __UINT_FAST32_TYPE__ atomic_uint_fast32_t;\n+typedef _Atomic __INT_FAST64_TYPE__ atomic_int_fast64_t;\n+typedef _Atomic __UINT_FAST64_TYPE__ atomic_uint_fast64_t;\n+typedef _Atomic __INTPTR_TYPE__ atomic_intptr_t;\n+typedef _Atomic __UINTPTR_TYPE__ atomic_uintptr_t;\n+typedef _Atomic __SIZE_TYPE__ atomic_size_t;\n+typedef _Atomic __PTRDIFF_TYPE__ atomic_ptrdiff_t;\n+typedef _Atomic __INTMAX_TYPE__ atomic_intmax_t;\n+typedef _Atomic __UINTMAX_TYPE__ atomic_uintmax_t;        \n+\n+\n+#define ATOMIC_VAR_INIT(VALUE)\t(VALUE)\n+#define atomic_init(PTR, VAL)\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      *(PTR) = (VAL);\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define kill_dependency(Y)\t\t\t\\\n+  __extension__\t\t\t\t\t\\\n+  ({\t\t\t\t\t\t\\\n+    __typeof__ (Y) __kill_dependency_tmp = (Y);\t\\\n+    __kill_dependency_tmp;\t\t\t\\\n+  })\n+\n+#define atomic_thread_fence(MO)\t__atomic_thread_fence (MO)\n+#define atomic_signal_fence(MO)\t__atomic_signal_fence  (MO)\n+#define atomic_is_lock_free(OBJ) __atomic_is_lock_free (sizeof (*(OBJ)), (OBJ))\n+\n+#define __atomic_type_lock_free(T)\t\t\t\t\\\n+  (__atomic_always_lock_free (sizeof (T), (void *) 0)\t\t\\\n+   ? 2\t\t\t\t\t\t\t\t\\\n+   : (__atomic_is_lock_free (sizeof (T), (void *) 0) ? 1 : 0))\n+#define ATOMIC_BOOL_LOCK_FREE\t\t\t\\\n+  __atomic_type_lock_free (atomic_bool)\n+#define ATOMIC_CHAR_LOCK_FREE\t\t\t\\\n+  __atomic_type_lock_free (atomic_char)\n+#define ATOMIC_CHAR16_T_LOCK_FREE\t\t\\\n+  __atomic_type_lock_free (atomic_char16_t)\n+#define ATOMIC_CHAR32_T_LOCK_FREE\t\t\\\n+  __atomic_type_lock_free (atomic_char32_t)\n+#define ATOMIC_WCHAR_T_LOCK_FREE\t\t\\\n+  __atomic_type_lock_free (atomic_wchar_t)\n+#define ATOMIC_SHORT_LOCK_FREE \t\t\t\\\n+  __atomic_type_lock_free (atomic_short)\n+#define ATOMIC_INT_LOCK_FREE \t\t\t\\\n+  __atomic_type_lock_free (atomic_int)\n+#define ATOMIC_LONG_LOCK_FREE\t\t\t\\\n+  __atomic_type_lock_free (atomic_long)\n+#define ATOMIC_LLONG_LOCK_FREE\t\t\t\\\n+  __atomic_type_lock_free (atomic_llong)\n+#define ATOMIC_POINTER_LOCK_FREE\t\t\\\n+  __atomic_type_lock_free (void * _Atomic)\n+\n+\n+/* Note that these macros require __typeof__ to remove _Atomic\n+   qualifiers (and const qualifiers, if those are valid on macro\n+   operands).\n+   \n+   Also note that the header file uses the generic form of __atomic\n+   builtins, which requires the address to be taken of the value\n+   parameter, and then we pass that value on.  This allows the macros\n+   to work for any type, and the compiler is smart enough to convert\n+   these to lock-free _N variants if possible, and throw away the\n+   temps.  */\n+\n+#define atomic_store_explicit(PTR, VAL, MO)\t\t\\\n+  __extension__\t\t\t\t\t\t\\\n+  ({\t\t\t\t\t\t\t\\\n+    __typeof__ (*(PTR)) __atomic_store_tmp = (VAL);\t\\\n+    __atomic_store ((PTR), &__atomic_store_tmp, (MO));\t\\\n+  })\n+\n+#define atomic_store(PTR, VAL)\t\t\t\t\\\n+  atomic_store_explicit (PTR, VAL, __ATOMIC_SEQ_CST)\n+\n+\n+#define atomic_load_explicit(PTR, MO)\t\t\t\t\t\\\n+  __extension__\t\t\t\t\t\t\t\t\\\n+  ({\t\t\t\t\t\t\t\t\t\\\n+    __typeof__ (*(PTR)) __atomic_load_tmp; \t\t\t\t\\\n+    __atomic_load ((PTR), &__atomic_load_tmp, (MO));\t\t\t\\\n+    __atomic_load_tmp;\t\t\t\t\t\t\t\\\n+  })\n+\n+#define atomic_load(PTR)  atomic_load_explicit (PTR, __ATOMIC_SEQ_CST)\n+\n+\n+#define atomic_exchange_explicit(PTR, VAL, MO)\t\t\t\t\\\n+  __extension__\t\t\t\t\t\t\t\t\\\n+  ({\t\t\t\t\t\t\t\t\t\\\n+    __typeof__ (*(PTR)) __atomic_exchange_val = (VAL), __atomic_exchange_tmp; \\\n+    __atomic_exchange ((PTR), &__atomic_exchange_val,\t\t\t\\\n+\t\t       &__atomic_exchange_tmp, (MO));\t\t\t\\\n+    __atomic_exchange_tmp;\t\t\t\t\t\t\\\n+  })\n+\n+#define atomic_exchange(PTR, VAL) \t\t\t\\\n+  atomic_exchange_explicit (PTR, VAL, __ATOMIC_SEQ_CST)\n+\n+\n+#define atomic_compare_exchange_strong_explicit(PTR, VAL, DES, SUC, FAIL) \\\n+  __extension__\t\t\t\t\t\t\t\t\\\n+  ({\t\t\t\t\t\t\t\t\t\\\n+    __typeof__ (*(PTR)) __atomic_compare_exchange_tmp = (DES);\t\t\\\n+    __atomic_compare_exchange ((PTR), (VAL),\t\t\t\t\\\n+\t\t\t       &__atomic_compare_exchange_tmp, 0,\t\\\n+\t\t\t       (SUC), (FAIL));\t\t\t\t\\\n+  })\n+\n+#define atomic_compare_exchange_strong(PTR, VAL, DES) \t\t\t   \\\n+  atomic_compare_exchange_strong_explicit (PTR, VAL, DES, __ATOMIC_SEQ_CST, \\\n+\t\t\t\t\t   __ATOMIC_SEQ_CST)\n+\n+#define atomic_compare_exchange_weak_explicit(PTR, VAL, DES, SUC, FAIL) \\\n+  __extension__\t\t\t\t\t\t\t\t\\\n+  ({\t\t\t\t\t\t\t\t\t\\\n+    __typeof__ (*(PTR)) __atomic_compare_exchange_tmp = (DES);\t\t\\\n+    __atomic_compare_exchange ((PTR), (VAL),\t\t\t\t\\\n+\t\t\t       &__atomic_compare_exchange_tmp, 1,\t\\\n+\t\t\t       (SUC), (FAIL));\t\t\t\t\\\n+  })\n+\n+#define atomic_compare_exchange_weak(PTR, VAL, DES)\t\t\t\\\n+  atomic_compare_exchange_weak_explicit (PTR, VAL, DES, __ATOMIC_SEQ_CST, \\\n+\t\t\t\t\t __ATOMIC_SEQ_CST)\n+\n+\n+\n+#define atomic_fetch_add(PTR, VAL) __atomic_fetch_add ((PTR), (VAL), \t\\\n+\t\t\t\t\t\t       __ATOMIC_SEQ_CST)\n+#define atomic_fetch_add_explicit(PTR, VAL, MO) \t\t\t\\\n+\t\t\t  __atomic_fetch_add ((PTR), (VAL), (MO))\n+\n+#define atomic_fetch_sub(PTR, VAL) __atomic_fetch_sub ((PTR), (VAL), \t\\\n+\t\t\t\t\t\t       __ATOMIC_SEQ_CST)\n+#define atomic_fetch_sub_explicit(PTR, VAL, MO) \t\t\t\\\n+\t\t\t  __atomic_fetch_sub ((PTR), (VAL), (MO))\n+\n+#define atomic_fetch_or(PTR, VAL) __atomic_fetch_or ((PTR), (VAL), \t\\\n+\t\t\t\t\t\t       __ATOMIC_SEQ_CST)\n+#define atomic_fetch_or_explicit(PTR, VAL, MO) \t\t\t\\\n+\t\t\t  __atomic_fetch_or ((PTR), (VAL), (MO))\n+\n+#define atomic_fetch_xor(PTR, VAL) __atomic_fetch_xor ((PTR), (VAL), \t\\\n+\t\t\t\t\t\t       __ATOMIC_SEQ_CST)\n+#define atomic_fetch_xor_explicit(PTR, VAL, MO) \t\t\t\\\n+\t\t\t  __atomic_fetch_xor ((PTR), (VAL), (MO))\n+\n+#define atomic_fetch_and(PTR, VAL) __atomic_fetch_and ((PTR), (VAL), \t\\\n+\t\t\t\t\t\t       __ATOMIC_SEQ_CST)\n+#define atomic_fetch_and_explicit(PTR, VAL, MO) \t\t\t\\\n+\t\t\t  __atomic_fetch_and ((PTR), (VAL), (MO))\n+\n+\n+typedef _Atomic struct\n+{\n+#if __GCC_ATOMIC_TEST_AND_SET_TRUEVAL == 1\n+  _Bool __val;\n+#else\n+  unsigned char __val;\n+#endif\n+} atomic_flag;\n+\n+#define ATOMIC_FLAG_INIT\t{ 0 }\n+\n+\n+#define atomic_flag_test_and_set(PTR) \t\t\t\t\t\\\n+\t\t\t__atomic_test_and_set ((PTR), __ATOMIC_SEQ_CST)\n+#define atomic_flag_test_and_set_explicit(PTR, MO)\t\t\t\\\n+\t\t\t__atomic_test_and_set ((PTR), (MO))\n+\n+#define atomic_flag_clear(PTR)\t__atomic_clear ((PTR), __ATOMIC_SEQ_CST)\n+#define atomic_flag_clear_explicit(PTR, MO)   __atomic_clear ((PTR), (MO))\n+\n+#endif  /* _STDATOMIC_H */"}, {"sha": "7ceba7057819c062eabce8221345e1951c078dca", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -1,3 +1,29 @@\n+2013-11-08  Joseph Myers  <joseph@codesourcery.com>\n+\n+\t* gcc.dg/atomic/stdatomic-compare-exchange-1.c,\n+\tgcc.dg/atomic/stdatomic-compare-exchange-2.c,\n+\tgcc.dg/atomic/stdatomic-compare-exchange-3.c,\n+\tgcc.dg/atomic/stdatomic-compare-exchange-4.c,\n+\tgcc.dg/atomic/stdatomic-exchange-1.c,\n+\tgcc.dg/atomic/stdatomic-exchange-2.c,\n+\tgcc.dg/atomic/stdatomic-exchange-3.c,\n+\tgcc.dg/atomic/stdatomic-exchange-4.c,\n+\tgcc.dg/atomic/stdatomic-fence.c, gcc.dg/atomic/stdatomic-flag.c,\n+\tgcc.dg/atomic/stdatomic-generic.c,\n+\tgcc.dg/atomic/stdatomic-kill-dep.c,\n+\tgcc.dg/atomic/stdatomic-load-1.c,\n+\tgcc.dg/atomic/stdatomic-load-2.c,\n+\tgcc.dg/atomic/stdatomic-load-3.c,\n+\tgcc.dg/atomic/stdatomic-load-4.c,\n+\tgcc.dg/atomic/stdatomic-lockfree.c,\n+\tgcc.dg/atomic/stdatomic-op-1.c, gcc.dg/atomic/stdatomic-op-2.c,\n+\tgcc.dg/atomic/stdatomic-op-3.c, gcc.dg/atomic/stdatomic-op-4.c,\n+\tgcc.dg/atomic/stdatomic-store-1.c,\n+\tgcc.dg/atomic/stdatomic-store-2.c,\n+\tgcc.dg/atomic/stdatomic-store-3.c,\n+\tgcc.dg/atomic/stdatomic-store-4.c, gcc.dg/c11-stdatomic-1.c: New\n+\ttests.\n+\n 2013-11-08  Cong Hou  <congh@google.com>\n \n \tPR tree-optimization/58508"}, {"sha": "d44c17dd60ff41ab86226f485f86439e4580ed1c", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-compare-exchange-1.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-1.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,81 @@\n+/* Test atomic_compare_exchange routines for existence and proper\n+   execution on 1-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic char v = ATOMIC_VAR_INIT (0);\n+char expected = 0;\n+char max = ~0;\n+char desired = ~0;\n+char zero = 0;\n+\n+int\n+main ()\n+{\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, max, memory_order_relaxed, memory_order_relaxed))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_strong_explicit (&v, &expected, 0, memory_order_acquire, memory_order_relaxed))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, 0, memory_order_release, memory_order_acquire))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_weak_explicit (&v, &expected, desired, memory_order_acq_rel, memory_order_acquire))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, desired, memory_order_seq_cst, memory_order_seq_cst))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  v = 0;\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, max))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_strong (&v, &expected, zero))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, zero))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_weak (&v, &expected, desired))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, desired))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "5647ee66335ea09466595ab1584db87bb0caf85b", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-compare-exchange-2.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-2.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,81 @@\n+/* Test atomic_compare_exchange routines for existence and proper\n+   execution on 2-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic short v = ATOMIC_VAR_INIT (0);\n+short expected = 0;\n+short max = ~0;\n+short desired = ~0;\n+short zero = 0;\n+\n+int\n+main ()\n+{\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, max, memory_order_relaxed, memory_order_relaxed))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_strong_explicit (&v, &expected, 0, memory_order_acquire, memory_order_relaxed))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, 0, memory_order_release, memory_order_acquire))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_weak_explicit (&v, &expected, desired, memory_order_acq_rel, memory_order_acquire))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, desired, memory_order_seq_cst, memory_order_seq_cst))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  v = 0;\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, max))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_strong (&v, &expected, zero))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, zero))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_weak (&v, &expected, desired))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, desired))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "e29784e5b2170bfc2d91d38ccb296e9da4f1e5e1", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-compare-exchange-3.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-3.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,81 @@\n+/* Test atomic_compare_exchange routines for existence and proper\n+   execution on 2-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic int v = ATOMIC_VAR_INIT (0);\n+int expected = 0;\n+int max = ~0;\n+int desired = ~0;\n+int zero = 0;\n+\n+int\n+main ()\n+{\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, max, memory_order_relaxed, memory_order_relaxed))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_strong_explicit (&v, &expected, 0, memory_order_acquire, memory_order_relaxed))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, 0, memory_order_release, memory_order_acquire))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_weak_explicit (&v, &expected, desired, memory_order_acq_rel, memory_order_acquire))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, desired, memory_order_seq_cst, memory_order_seq_cst))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  v = 0;\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, max))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_strong (&v, &expected, zero))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, zero))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_weak (&v, &expected, desired))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, desired))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "e052dca0c94f087c736d63b614fe99bd909b2b58", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-compare-exchange-4.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-compare-exchange-4.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,81 @@\n+/* Test atomic_compare_exchange routines for existence and proper\n+   execution on 2-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic long long v = ATOMIC_VAR_INIT (0);\n+long long expected = 0;\n+long long max = ~0LL;\n+long long desired = ~0LL;\n+long long zero = 0;\n+\n+int\n+main ()\n+{\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, max, memory_order_relaxed, memory_order_relaxed))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_strong_explicit (&v, &expected, 0, memory_order_acquire, memory_order_relaxed))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, 0, memory_order_release, memory_order_acquire))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_weak_explicit (&v, &expected, desired, memory_order_acq_rel, memory_order_acquire))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong_explicit (&v, &expected, desired, memory_order_seq_cst, memory_order_seq_cst))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  v = 0;\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, max))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_strong (&v, &expected, zero))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, zero))\n+    abort ();\n+  if (expected != max)\n+    abort ();\n+  if (v != 0)\n+    abort ();\n+\n+  if (atomic_compare_exchange_weak (&v, &expected, desired))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong (&v, &expected, desired))\n+    abort ();\n+  if (expected != 0)\n+    abort ();\n+  if (v != max)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "d7c751a34febd9ebff56dc69ad279a7649630d09", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-exchange-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-1.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,46 @@\n+/* Test atomic_exchange routines for existence and proper execution on\n+   1-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic char v;\n+char count, ret;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_relaxed) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_acquire) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_release) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_acq_rel) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_seq_cst) != count)\n+    abort ();\n+  count++;\n+\n+  count++;\n+\n+  ret = atomic_exchange (&v, count);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "2f1f7e2359d7e9763d3ac23ef7a61ef5926a910b", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-exchange-2.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-2.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,46 @@\n+/* Test atomic_exchange routines for existence and proper execution on\n+   2-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic short v;\n+short count, ret;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_relaxed) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_acquire) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_release) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_acq_rel) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_seq_cst) != count)\n+    abort ();\n+  count++;\n+\n+  count++;\n+\n+  ret = atomic_exchange (&v, count);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "a62c5718785d28c1ec9f029817d99f847d495d9e", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-exchange-3.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-3.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,46 @@\n+/* Test atomic_exchange routines for existence and proper execution on\n+   4-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic int v;\n+int count, ret;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_relaxed) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_acquire) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_release) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_acq_rel) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_seq_cst) != count)\n+    abort ();\n+  count++;\n+\n+  count++;\n+\n+  ret = atomic_exchange (&v, count);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "1be9b2999480cfe7f5d555d29866c22865da976a", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-exchange-4.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-exchange-4.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,46 @@\n+/* Test atomic_exchange routines for existence and proper execution on\n+   8-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic long long v;\n+long long count, ret;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_relaxed) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_acquire) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_release) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_acq_rel) != count)\n+    abort ();\n+  count++;\n+\n+  if (atomic_exchange_explicit (&v, count + 1, memory_order_seq_cst) != count)\n+    abort ();\n+  count++;\n+\n+  count++;\n+\n+  ret = atomic_exchange (&v, count);\n+  if (ret != count - 1 || v != count)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "5f6c4e0f9d7df884dae899d73137ff2d1c4deedf", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-fence.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-fence.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-fence.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-fence.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,26 @@\n+/* Test atomic_*_fence routines for existence and execution with each\n+   valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+int\n+main ()\n+{\n+  atomic_thread_fence (memory_order_relaxed);\n+  atomic_thread_fence (memory_order_consume);\n+  atomic_thread_fence (memory_order_acquire);\n+  atomic_thread_fence (memory_order_release);\n+  atomic_thread_fence (memory_order_acq_rel);\n+  atomic_thread_fence (memory_order_seq_cst);\n+\n+  atomic_signal_fence (memory_order_relaxed);\n+  atomic_signal_fence (memory_order_consume);\n+  atomic_signal_fence (memory_order_acquire);\n+  atomic_signal_fence (memory_order_release);\n+  atomic_signal_fence (memory_order_acq_rel);\n+  atomic_signal_fence (memory_order_seq_cst);\n+\n+  return 0;\n+}"}, {"sha": "32f9e9bb631356fbe65327cbfd40312edd8b6691", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-flag.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-flag.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-flag.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-flag.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,38 @@\n+/* Test atomic_flag routines for existence and execution.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+atomic_flag a = ATOMIC_FLAG_INIT;\n+\n+int\n+main ()\n+{\n+  int b;\n+\n+  if (!atomic_is_lock_free (&a))\n+    abort ();\n+\n+  if (atomic_flag_test_and_set (&a))\n+    abort ();\n+  atomic_flag_clear_explicit (&a, memory_order_relaxed);\n+  if (atomic_flag_test_and_set (&a))\n+    abort ();\n+  atomic_flag_clear (&a);\n+\n+  b = atomic_flag_test_and_set_explicit (&a, memory_order_seq_cst);\n+  if (!atomic_flag_test_and_set (&a) || b != 0)\n+    abort ();\n+\n+  b = atomic_flag_test_and_set_explicit (&a, memory_order_acq_rel);\n+  if (!atomic_flag_test_and_set (&a) || b != 1)\n+    abort ();\n+\n+  atomic_flag_clear_explicit (&a, memory_order_seq_cst);\n+  if (atomic_flag_test_and_set (&a))\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "8033c53739d5540aab3cf940aaf9d3cc0dec00db", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-generic.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-generic.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,52 @@\n+/* Test generic atomic routines for proper function calling.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort ();\n+extern int memcmp (const void *, const void *, __SIZE_TYPE__);\n+\n+typedef struct test {\n+  int array[10];\n+} test_struct;\n+\n+test_struct zero = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };\n+test_struct ones = { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };\n+_Atomic test_struct a;\n+test_struct b;\n+\n+int size = sizeof (test_struct);\n+/* Test for consistency on sizes 1, 2, 4, 8, 16 and 32.  */\n+int\n+main ()\n+{\n+  test_struct c;\n+\n+  atomic_store_explicit (&a, zero, memory_order_relaxed);\n+  if (memcmp (&a, &zero, size))\n+    abort ();\n+\n+  c = atomic_exchange_explicit (&a, ones, memory_order_seq_cst);\n+  if (memcmp (&c, &zero, size))\n+    abort ();\n+  if (memcmp (&a, &ones, size))\n+    abort ();\n+\n+  b = atomic_load_explicit (&a, memory_order_relaxed);\n+  if (memcmp (&b, &ones, size))\n+    abort ();\n+\n+  if (!atomic_compare_exchange_strong_explicit (&a, &b, zero, memory_order_seq_cst, memory_order_acquire))\n+    abort ();\n+  if (memcmp (&a, &zero, size))\n+    abort ();\n+\n+  if (atomic_compare_exchange_weak_explicit (&a, &b, ones, memory_order_seq_cst, memory_order_acquire))\n+    abort ();\n+  if (memcmp (&b, &zero, size))\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "fda7fe7d1f0a45e61e38abe53686a041058f08e6", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-kill-dep.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-kill-dep.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-kill-dep.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-kill-dep.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,19 @@\n+/* Test atomic_kill_dependency.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic int a = ATOMIC_VAR_INIT (1), b;\n+\n+int\n+main ()\n+{\n+  b = kill_dependency (a);\n+  if (b != 1)\n+    abort ();\n+\n+  return 0;\n+}"}, {"sha": "16bea684cb3131320287f109cdc16cb7d8809357", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-load-1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-1.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,44 @@\n+/* Test atomic_load routines for existence and proper execution on\n+   1-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic char v;\n+char count;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (atomic_load_explicit (&v, memory_order_relaxed) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_acquire) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_consume) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_seq_cst) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load (&v) != count)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "6b492d8c2ceb6952d913395b668bdc15c9e45b77", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-load-2.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-2.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,44 @@\n+/* Test atomic_load routines for existence and proper execution on\n+   2-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic short v;\n+short count;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (atomic_load_explicit (&v, memory_order_relaxed) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_acquire) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_consume) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_seq_cst) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load (&v) != count)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "c6f2e4b09ecc24fba5c88918241b1a840f90e8a9", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-load-3.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-3.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,44 @@\n+/* Test atomic_load routines for existence and proper execution on\n+   4-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic int v;\n+int count;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (atomic_load_explicit (&v, memory_order_relaxed) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_acquire) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_consume) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_seq_cst) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load (&v) != count)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "bc26a5238df180acd0488ff2c5e025e9b38c2e5d", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-load-4.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-load-4.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,44 @@\n+/* Test atomic_load routines for existence and proper execution on\n+   8-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic long long v;\n+long long count;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  if (atomic_load_explicit (&v, memory_order_relaxed) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_acquire) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_consume) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load_explicit (&v, memory_order_seq_cst) != count++)\n+    abort ();\n+  else\n+    v++;\n+\n+  if (atomic_load (&v) != count)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "29310e9ce2a7cbaf7066237ade06b76230e781c4", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-lockfree.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-lockfree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-lockfree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-lockfree.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,68 @@\n+/* Test atomic_is_lock_free.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+#include <stdint.h>\n+\n+extern void abort ();\n+\n+_Atomic _Bool aba;\n+atomic_bool abt;\n+_Atomic char aca;\n+atomic_char act;\n+_Atomic __CHAR16_TYPE__ ac16a;\n+atomic_char16_t ac16t;\n+_Atomic __CHAR32_TYPE__ ac32a;\n+atomic_char32_t ac32t;\n+_Atomic __WCHAR_TYPE__ awca;\n+atomic_wchar_t awct;\n+_Atomic short asa;\n+atomic_short ast;\n+_Atomic int aia;\n+atomic_int ait;\n+_Atomic long ala;\n+atomic_long alt;\n+_Atomic long long alla;\n+atomic_llong allt;\n+void *_Atomic apa;\n+\n+#define CHECK_TYPE(MACRO, V1, V2)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      int r1 = MACRO;\t\t\t\t\\\n+      int r2 = atomic_is_lock_free (&V1);\t\\\n+      int r3 = atomic_is_lock_free (&V2);\t\\\n+      if (r1 != 0 && r1 != 1 && r1 != 2)\t\\\n+\tabort ();\t\t\t\t\\\n+      if (r2 != 0 && r2 != 1)\t\t\t\\\n+\tabort ();\t\t\t\t\\\n+      if (r3 != 0 && r3 != 1)\t\t\t\\\n+\tabort ();\t\t\t\t\\\n+      if (r1 == 2 && r2 != 1)\t\t\t\\\n+\tabort ();\t\t\t\t\\\n+      if (r1 == 2 && r3 != 1)\t\t\t\\\n+\tabort ();\t\t\t\t\\\n+      if (r1 == 0 && r2 != 0)\t\t\t\\\n+\tabort ();\t\t\t\t\\\n+      if (r1 == 0 && r3 != 0)\t\t\t\\\n+\tabort ();\t\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+int\n+main ()\n+{\n+  CHECK_TYPE (ATOMIC_BOOL_LOCK_FREE, aba, abt);\n+  CHECK_TYPE (ATOMIC_CHAR_LOCK_FREE, aca, act);\n+  CHECK_TYPE (ATOMIC_CHAR16_T_LOCK_FREE, ac16a, ac16t);\n+  CHECK_TYPE (ATOMIC_CHAR32_T_LOCK_FREE, ac32a, ac32t);\n+  CHECK_TYPE (ATOMIC_WCHAR_T_LOCK_FREE, awca, awct);\n+  CHECK_TYPE (ATOMIC_SHORT_LOCK_FREE, asa, ast);\n+  CHECK_TYPE (ATOMIC_INT_LOCK_FREE, aia, ait);\n+  CHECK_TYPE (ATOMIC_LONG_LOCK_FREE, ala, alt);\n+  CHECK_TYPE (ATOMIC_LLONG_LOCK_FREE, alla, allt);\n+  CHECK_TYPE (ATOMIC_POINTER_LOCK_FREE, apa, apa);\n+\n+  return 0;\n+}"}, {"sha": "6513a53402e0066dbfc7a1ecc965f05f74ea5cb9", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-op-1.c", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-1.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,341 @@\n+/* Test atomic_fetch routines for existence and proper execution on\n+   1-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic char v;\n+char count, res;\n+const char init = ~0;\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_relaxed) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_consume) != 1)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_acquire) != 2)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_release) != 3)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_acq_rel) != 4)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_seq_cst) != 5)\n+    abort ();\n+\n+  if (atomic_fetch_add (&v, 1) != 6)\n+    abort ();\n+}\n+\n+void\n+test_fetch_sub ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_relaxed) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_consume) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_acquire) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_release) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_acq_rel) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_seq_cst) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub (&v, 1) != res--)\n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_relaxed) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, init, memory_order_consume) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_acquire) != 0)\n+    abort ();\n+\n+  v = ~v;\n+  if (atomic_fetch_and_explicit (&v, init, memory_order_release) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_acq_rel) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_seq_cst) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_and (&v, 0) != 0)\n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (atomic_fetch_xor_explicit (&v, count, memory_order_relaxed) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_consume) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, 0, memory_order_acquire) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_release) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, 0, memory_order_acq_rel) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_seq_cst) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor (&v, ~count) != 0)\n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_relaxed) != 0)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, 2, memory_order_consume) != 1)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_acquire) != 3)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, 8, memory_order_release) != 7)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_acq_rel) != 15)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_seq_cst) != 31)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or (&v, count) != 63)\n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  atomic_fetch_add (&v, count);\n+  if (v != 1)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, count, memory_order_consume);\n+  if (v != 2)\n+    abort ();\n+\n+  atomic_fetch_add (&v, 1);\n+  if (v != 3)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, 1, memory_order_release);\n+  if (v != 4)\n+    abort ();\n+\n+  atomic_fetch_add (&v, 1);\n+  if (v != 5)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, count, memory_order_seq_cst);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+void\n+test_sub ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  atomic_fetch_sub (&v, count + 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, count + 1, memory_order_consume);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub (&v, 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, 1, memory_order_release);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub (&v, count + 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, count + 1, memory_order_seq_cst);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  atomic_fetch_and_explicit (&v, init, memory_order_consume);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  atomic_fetch_and_explicit (&v, init, memory_order_release);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  atomic_fetch_and_explicit (&v, 0, memory_order_seq_cst);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  atomic_fetch_xor (&v, count);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, ~count, memory_order_consume);\n+  if (v != 0)\n+    abort ();\n+\n+  atomic_fetch_xor (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, ~count, memory_order_release);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, 0, memory_order_acq_rel);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor (&v, ~count);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  atomic_fetch_or (&v, count);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, count, memory_order_consume);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or (&v, 4);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, 8, memory_order_release);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or (&v, count);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, count, memory_order_seq_cst);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "05edafff0bdb5d51168513de7fcab11893547a6f", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-op-2.c", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-2.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,341 @@\n+/* Test atomic_fetch routines for existence and proper execution on\n+   2-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic short v;\n+short count, res;\n+const short init = ~0;\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_relaxed) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_consume) != 1)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_acquire) != 2)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_release) != 3)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_acq_rel) != 4)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_seq_cst) != 5)\n+    abort ();\n+\n+  if (atomic_fetch_add (&v, 1) != 6)\n+    abort ();\n+}\n+\n+void\n+test_fetch_sub ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_relaxed) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_consume) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_acquire) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_release) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_acq_rel) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_seq_cst) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub (&v, 1) != res--)\n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_relaxed) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, init, memory_order_consume) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_acquire) != 0)\n+    abort ();\n+\n+  v = ~v;\n+  if (atomic_fetch_and_explicit (&v, init, memory_order_release) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_acq_rel) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_seq_cst) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_and (&v, 0) != 0)\n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (atomic_fetch_xor_explicit (&v, count, memory_order_relaxed) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_consume) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, 0, memory_order_acquire) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_release) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, 0, memory_order_acq_rel) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_seq_cst) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor (&v, ~count) != 0)\n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_relaxed) != 0)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, 2, memory_order_consume) != 1)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_acquire) != 3)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, 8, memory_order_release) != 7)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_acq_rel) != 15)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_seq_cst) != 31)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or (&v, count) != 63)\n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  atomic_fetch_add (&v, count);\n+  if (v != 1)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, count, memory_order_consume);\n+  if (v != 2)\n+    abort ();\n+\n+  atomic_fetch_add (&v, 1);\n+  if (v != 3)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, 1, memory_order_release);\n+  if (v != 4)\n+    abort ();\n+\n+  atomic_fetch_add (&v, 1);\n+  if (v != 5)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, count, memory_order_seq_cst);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+void\n+test_sub ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  atomic_fetch_sub (&v, count + 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, count + 1, memory_order_consume);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub (&v, 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, 1, memory_order_release);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub (&v, count + 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, count + 1, memory_order_seq_cst);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  atomic_fetch_and_explicit (&v, init, memory_order_consume);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  atomic_fetch_and_explicit (&v, init, memory_order_release);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  atomic_fetch_and_explicit (&v, 0, memory_order_seq_cst);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  atomic_fetch_xor (&v, count);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, ~count, memory_order_consume);\n+  if (v != 0)\n+    abort ();\n+\n+  atomic_fetch_xor (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, ~count, memory_order_release);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, 0, memory_order_acq_rel);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor (&v, ~count);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  atomic_fetch_or (&v, count);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, count, memory_order_consume);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or (&v, 4);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, 8, memory_order_release);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or (&v, count);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, count, memory_order_seq_cst);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "dc745d405911c02023ac32f4e8ea4903760f7ad7", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-op-3.c", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-3.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,341 @@\n+/* Test atomic_fetch routines for existence and proper execution on\n+   4-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic int v;\n+int count, res;\n+const int init = ~0;\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_relaxed) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_consume) != 1)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_acquire) != 2)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_release) != 3)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_acq_rel) != 4)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_seq_cst) != 5)\n+    abort ();\n+\n+  if (atomic_fetch_add (&v, 1) != 6)\n+    abort ();\n+}\n+\n+void\n+test_fetch_sub ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_relaxed) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_consume) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_acquire) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_release) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_acq_rel) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_seq_cst) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub (&v, 1) != res--)\n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_relaxed) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, init, memory_order_consume) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_acquire) != 0)\n+    abort ();\n+\n+  v = ~v;\n+  if (atomic_fetch_and_explicit (&v, init, memory_order_release) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_acq_rel) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_seq_cst) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_and (&v, 0) != 0)\n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (atomic_fetch_xor_explicit (&v, count, memory_order_relaxed) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_consume) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, 0, memory_order_acquire) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_release) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, 0, memory_order_acq_rel) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_seq_cst) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor (&v, ~count) != 0)\n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_relaxed) != 0)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, 2, memory_order_consume) != 1)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_acquire) != 3)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, 8, memory_order_release) != 7)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_acq_rel) != 15)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_seq_cst) != 31)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or (&v, count) != 63)\n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  atomic_fetch_add (&v, count);\n+  if (v != 1)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, count, memory_order_consume);\n+  if (v != 2)\n+    abort ();\n+\n+  atomic_fetch_add (&v, 1);\n+  if (v != 3)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, 1, memory_order_release);\n+  if (v != 4)\n+    abort ();\n+\n+  atomic_fetch_add (&v, 1);\n+  if (v != 5)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, count, memory_order_seq_cst);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+void\n+test_sub ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  atomic_fetch_sub (&v, count + 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, count + 1, memory_order_consume);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub (&v, 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, 1, memory_order_release);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub (&v, count + 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, count + 1, memory_order_seq_cst);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  atomic_fetch_and_explicit (&v, init, memory_order_consume);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  atomic_fetch_and_explicit (&v, init, memory_order_release);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  atomic_fetch_and_explicit (&v, 0, memory_order_seq_cst);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  atomic_fetch_xor (&v, count);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, ~count, memory_order_consume);\n+  if (v != 0)\n+    abort ();\n+\n+  atomic_fetch_xor (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, ~count, memory_order_release);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, 0, memory_order_acq_rel);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor (&v, ~count);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  atomic_fetch_or (&v, count);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, count, memory_order_consume);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or (&v, 4);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, 8, memory_order_release);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or (&v, count);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, count, memory_order_seq_cst);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "84b83e44f8e76bbcf4c27b7fa340cf7a63efb275", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-op-4.c", "status": "added", "additions": 341, "deletions": 0, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-op-4.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,341 @@\n+/* Test atomic_fetch routines for existence and proper execution on\n+   8-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic long long v;\n+long long count, res;\n+const long long init = ~0;\n+\n+void\n+test_fetch_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_relaxed) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_consume) != 1)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_acquire) != 2)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_release) != 3)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, count, memory_order_acq_rel) != 4)\n+    abort ();\n+\n+  if (atomic_fetch_add_explicit (&v, 1, memory_order_seq_cst) != 5)\n+    abort ();\n+\n+  if (atomic_fetch_add (&v, 1) != 6)\n+    abort ();\n+}\n+\n+void\n+test_fetch_sub ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_relaxed) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_consume) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_acquire) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_release) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, count + 1, memory_order_acq_rel) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub_explicit (&v, 1, memory_order_seq_cst) != res--)\n+    abort ();\n+\n+  if (atomic_fetch_sub (&v, 1) != res--)\n+    abort ();\n+}\n+\n+void\n+test_fetch_and ()\n+{\n+  v = init;\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_relaxed) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, init, memory_order_consume) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_acquire) != 0)\n+    abort ();\n+\n+  v = ~v;\n+  if (atomic_fetch_and_explicit (&v, init, memory_order_release) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_acq_rel) != init)\n+    abort ();\n+\n+  if (atomic_fetch_and_explicit (&v, 0, memory_order_seq_cst) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_and (&v, 0) != 0)\n+    abort ();\n+}\n+\n+void\n+test_fetch_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  if (atomic_fetch_xor_explicit (&v, count, memory_order_relaxed) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_consume) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, 0, memory_order_acquire) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_release) != 0)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, 0, memory_order_acq_rel) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor_explicit (&v, ~count, memory_order_seq_cst) != init)\n+    abort ();\n+\n+  if (atomic_fetch_xor (&v, ~count) != 0)\n+    abort ();\n+}\n+\n+void\n+test_fetch_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_relaxed) != 0)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, 2, memory_order_consume) != 1)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_acquire) != 3)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, 8, memory_order_release) != 7)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_acq_rel) != 15)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or_explicit (&v, count, memory_order_seq_cst) != 31)\n+    abort ();\n+\n+  count *= 2;\n+  if (atomic_fetch_or (&v, count) != 63)\n+    abort ();\n+}\n+\n+\n+/* Test the OP routines with a result which isn't used.  */\n+\n+void\n+test_add ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  atomic_fetch_add (&v, count);\n+  if (v != 1)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, count, memory_order_consume);\n+  if (v != 2)\n+    abort ();\n+\n+  atomic_fetch_add (&v, 1);\n+  if (v != 3)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, 1, memory_order_release);\n+  if (v != 4)\n+    abort ();\n+\n+  atomic_fetch_add (&v, 1);\n+  if (v != 5)\n+    abort ();\n+\n+  atomic_fetch_add_explicit (&v, count, memory_order_seq_cst);\n+  if (v != 6)\n+    abort ();\n+}\n+\n+void\n+test_sub ()\n+{\n+  v = res = 20;\n+  count = 0;\n+\n+  atomic_fetch_sub (&v, count + 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, count + 1, memory_order_consume);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub (&v, 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, 1, memory_order_release);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub (&v, count + 1);\n+  if (v != --res)\n+    abort ();\n+\n+  atomic_fetch_sub_explicit (&v, count + 1, memory_order_seq_cst);\n+  if (v != --res)\n+    abort ();\n+}\n+\n+void\n+test_and ()\n+{\n+  v = init;\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = init;\n+  atomic_fetch_and_explicit (&v, init, memory_order_consume);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  atomic_fetch_and_explicit (&v, init, memory_order_release);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_and (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  v = ~v;\n+  atomic_fetch_and_explicit (&v, 0, memory_order_seq_cst);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_xor ()\n+{\n+  v = init;\n+  count = 0;\n+\n+  atomic_fetch_xor (&v, count);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, ~count, memory_order_consume);\n+  if (v != 0)\n+    abort ();\n+\n+  atomic_fetch_xor (&v, 0);\n+  if (v != 0)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, ~count, memory_order_release);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor_explicit (&v, 0, memory_order_acq_rel);\n+  if (v != init)\n+    abort ();\n+\n+  atomic_fetch_xor (&v, ~count);\n+  if (v != 0)\n+    abort ();\n+}\n+\n+void\n+test_or ()\n+{\n+  v = 0;\n+  count = 1;\n+\n+  atomic_fetch_or (&v, count);\n+  if (v != 1)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, count, memory_order_consume);\n+  if (v != 3)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or (&v, 4);\n+  if (v != 7)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, 8, memory_order_release);\n+  if (v != 15)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or (&v, count);\n+  if (v != 31)\n+    abort ();\n+\n+  count *= 2;\n+  atomic_fetch_or_explicit (&v, count, memory_order_seq_cst);\n+  if (v != 63)\n+    abort ();\n+}\n+\n+int\n+main ()\n+{\n+  test_fetch_add ();\n+  test_fetch_sub ();\n+  test_fetch_and ();\n+  test_fetch_xor ();\n+  test_fetch_or ();\n+\n+  test_add ();\n+  test_sub ();\n+  test_and ();\n+  test_xor ();\n+  test_or ();\n+\n+  return 0;\n+}"}, {"sha": "f7936dabc1ecd4a02059ce62ed42f1c7d5505709", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-store-1.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-1.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,43 @@\n+/* Test atomic_store routines for existence and proper execution on\n+   1-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic char v;\n+char count;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  atomic_init (&v, count + 1);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_relaxed);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_release);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_seq_cst);\n+  if (v != ++count)\n+    abort ();\n+\n+  count++;\n+\n+  atomic_store (&v, count);\n+  if (v != count)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "0bbba1cef8995d3e814d4c25750f1d3e80c7a746", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-store-2.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-2.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,43 @@\n+/* Test atomic_store routines for existence and proper execution on\n+   2-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic short v;\n+short count;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  atomic_init (&v, count + 1);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_relaxed);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_release);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_seq_cst);\n+  if (v != ++count)\n+    abort ();\n+\n+  count++;\n+\n+  atomic_store (&v, count);\n+  if (v != count)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "86c1b2aa886f3846164c53551f138d51020a86f8", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-store-3.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-3.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,43 @@\n+/* Test atomic_store routines for existence and proper execution on\n+   4-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic int v;\n+int count;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  atomic_init (&v, count + 1);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_relaxed);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_release);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_seq_cst);\n+  if (v != ++count)\n+    abort ();\n+\n+  count++;\n+\n+  atomic_store (&v, count);\n+  if (v != count)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "fe96469a9be7ec4bae50ae690a17dfe941235bb8", "filename": "gcc/testsuite/gcc.dg/atomic/stdatomic-store-4.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fatomic%2Fstdatomic-store-4.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,43 @@\n+/* Test atomic_store routines for existence and proper execution on\n+   8-byte values with each valid memory model.  */\n+/* { dg-do run } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+extern void abort (void);\n+\n+_Atomic long long v;\n+long long count;\n+\n+int\n+main ()\n+{\n+  v = 0;\n+  count = 0;\n+\n+  atomic_init (&v, count + 1);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_relaxed);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_release);\n+  if (v != ++count)\n+    abort ();\n+\n+  atomic_store_explicit (&v, count + 1, memory_order_seq_cst);\n+  if (v != ++count)\n+    abort ();\n+\n+  count++;\n+\n+  atomic_store (&v, count);\n+  if (v != count)\n+    abort ();\n+\n+  return 0;\n+}\n+"}, {"sha": "79909c055a7a16c5de3d878eeef98f555789a5f4", "filename": "gcc/testsuite/gcc.dg/c11-stdatomic-1.c", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-stdatomic-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/39b2468cf60b8351346882214da7cbb3d7db7fd1/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-stdatomic-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fc11-stdatomic-1.c?ref=39b2468cf60b8351346882214da7cbb3d7db7fd1", "patch": "@@ -0,0 +1,119 @@\n+/* Test stdatomic.h header contents.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=c11 -pedantic-errors\" } */\n+\n+#include <stdatomic.h>\n+\n+#ifndef ATOMIC_BOOL_LOCK_FREE\n+# error ATOMIC_BOOL_LOCK_FREE not defined\n+#endif\n+\n+#ifndef ATOMIC_CHAR_LOCK_FREE\n+# error ATOMIC_CHAR_LOCK_FREE not defined\n+#endif\n+\n+#ifndef ATOMIC_CHAR16_T_LOCK_FREE\n+# error ATOMIC_CHAR16_T_LOCK_FREE not defined\n+#endif\n+\n+#ifndef ATOMIC_CHAR32_T_LOCK_FREE\n+# error ATOMIC_CHAR32_T_LOCK_FREE not defined\n+#endif\n+\n+#ifndef ATOMIC_WCHAR_T_LOCK_FREE\n+# error ATOMIC_WCHAR_T_LOCK_FREE not defined\n+#endif\n+\n+#ifndef ATOMIC_SHORT_LOCK_FREE\n+# error ATOMIC_SHORT_LOCK_FREE not defined\n+#endif\n+\n+#ifndef ATOMIC_INT_LOCK_FREE\n+# error ATOMIC_INT_LOCK_FREE not defined\n+#endif\n+\n+#ifndef ATOMIC_LONG_LOCK_FREE\n+# error ATOMIC_LONG_LOCK_FREE not defined\n+#endif\n+\n+#ifndef ATOMIC_LLONG_LOCK_FREE\n+# error ATOMIC_LLONG_LOCK_FREE not defined\n+#endif\n+\n+#ifndef ATOMIC_POINTER_LOCK_FREE\n+# error ATOMIC_POINTER_LOCK_FREE not defined\n+#endif\n+\n+memory_order m0 = memory_order_relaxed;\n+memory_order m1 = memory_order_consume;\n+memory_order m2 = memory_order_acquire;\n+memory_order m3 = memory_order_release;\n+memory_order m4 = memory_order_acq_rel;\n+memory_order m5 = memory_order_seq_cst;\n+\n+atomic_flag af = ATOMIC_FLAG_INIT;\n+\n+struct s { int i[100]; } sv;\n+void\n+f (void)\n+{\n+  _Atomic struct s sva = ATOMIC_VAR_INIT (sv);\n+}\n+\n+#ifndef kill_dependency\n+# error kill_dependency not defined\n+#endif\n+\n+#define CHECK_ATOMIC_TYPEDEF(A, B)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      A v;\t\t\t\t\t\t\t\\\n+      char array1[sizeof (A) == sizeof (B) ? 1 : -1];\t\t\\\n+      char array2[_Alignof (A) == _Alignof (B) ? 1 : -1];\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#include <stddef.h>\n+#include <stdint.h>\n+\n+void\n+check_typedefs (void)\n+{\n+  CHECK_ATOMIC_TYPEDEF (atomic_bool, _Atomic _Bool);\n+  CHECK_ATOMIC_TYPEDEF (atomic_char, _Atomic char);\n+  CHECK_ATOMIC_TYPEDEF (atomic_schar, _Atomic signed char);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uchar, _Atomic unsigned char);\n+  CHECK_ATOMIC_TYPEDEF (atomic_short, _Atomic short);\n+  CHECK_ATOMIC_TYPEDEF (atomic_ushort, _Atomic unsigned short);\n+  CHECK_ATOMIC_TYPEDEF (atomic_int, _Atomic int);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uint, _Atomic unsigned int);\n+  CHECK_ATOMIC_TYPEDEF (atomic_long, _Atomic long);\n+  CHECK_ATOMIC_TYPEDEF (atomic_ulong, _Atomic unsigned long);\n+  CHECK_ATOMIC_TYPEDEF (atomic_llong, _Atomic long long);\n+  CHECK_ATOMIC_TYPEDEF (atomic_ullong, _Atomic unsigned long long);\n+  CHECK_ATOMIC_TYPEDEF (atomic_char16_t, _Atomic __CHAR16_TYPE__);\n+  CHECK_ATOMIC_TYPEDEF (atomic_char32_t, _Atomic __CHAR32_TYPE__);\n+  CHECK_ATOMIC_TYPEDEF (atomic_wchar_t, _Atomic wchar_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_int_least8_t, _Atomic int_least8_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uint_least8_t, _Atomic uint_least8_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_int_least16_t, _Atomic int_least16_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uint_least16_t, _Atomic uint_least16_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_int_least32_t, _Atomic int_least32_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uint_least32_t, _Atomic uint_least32_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_int_least64_t, _Atomic int_least64_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uint_least64_t, _Atomic uint_least64_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_int_fast8_t, _Atomic int_fast8_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uint_fast8_t, _Atomic uint_fast8_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_int_fast16_t, _Atomic int_fast16_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uint_fast16_t, _Atomic uint_fast16_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_int_fast32_t, _Atomic int_fast32_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uint_fast32_t, _Atomic uint_fast32_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_int_fast64_t, _Atomic int_fast64_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uint_fast64_t, _Atomic uint_fast64_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_intptr_t, _Atomic intptr_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uintptr_t, _Atomic uintptr_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_size_t, _Atomic size_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_ptrdiff_t, _Atomic ptrdiff_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_intmax_t, _Atomic intmax_t);\n+  CHECK_ATOMIC_TYPEDEF (atomic_uintmax_t, _Atomic uintmax_t);\n+}"}]}