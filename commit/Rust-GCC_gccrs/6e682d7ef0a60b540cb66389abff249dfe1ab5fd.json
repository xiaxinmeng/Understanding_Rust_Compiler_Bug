{"sha": "6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU2ODJkN2VmMGE2MGI1NDBjYjY2Mzg5YWJmZjI0OWRmZTFhYjVmZA==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-12-22T21:38:52Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-12-22T21:38:52Z"}, "message": "tree-ssa-loop-niter.c (zero_p, nonzero_p): Removed.\n\n\t* tree-ssa-loop-niter.c (zero_p, nonzero_p): Removed.\n\t(number_of_iterations_ne, number_of_iterations_lt_to_ne,\n\tassert_no_overflow_lt, assert_loop_rolls_lt,\n\tnumber_of_iterations_lt, number_of_iterations_le,\n\tnumber_of_iterations_cond, tree_simplify_using_condition_1,\n\tnumber_of_iterations_exit, find_loop_niter, loop_niter_by_eval,\n\timplies_nonnegative_p, implies_ge_p, record_nonwrapping_iv,\n\tidx_infer_loop_bounds, n_of_executions_at_most, scev_probably_wraps_p):\n\tDo not use zero_p/nonzero_p.\n\t* tree-ssa-loop-manip.c (determine_exit_conditions): Ditto.\n\t* tree-ssa-loop-ivopts.c (niter_for_exit, determine_biv_step,\n\tfind_interesting_uses_op, find_interesting_uses_cond,\n\tfind_interesting_uses_address, find_interesting_uses_stmt,\n\tstrip_offset_1, add_candidate_1, add_old_ivs_candidates,\n\tdifference_cost, determine_use_iv_cost_condition,\n\trewrite_use_compare, remove_unused_ivs): Ditto.\n\t* tree-ssa-address.c (tree_mem_ref_addr, create_mem_ref_raw): Ditto.\n\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Ditto.\n\t* tree-cfg.c (find_taken_edge_cond_expr): Ditto.\n\t* tree.h (zero_p): Declaration removed.\n\t(null_or_integer_zerop, nonnull_and_integer_nonzerop): New.\n\nFrom-SVN: r120156", "tree": {"sha": "b06c0e8f9ec9f1eb10595d5ccba06c4ee8faa074", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b06c0e8f9ec9f1eb10595d5ccba06c4ee8faa074"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/comments", "author": null, "committer": null, "parents": [{"sha": "54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54129a64cd5ec8254cdf7cc735537f14cb3c27d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54129a64cd5ec8254cdf7cc735537f14cb3c27d7"}], "stats": {"total": 240, "additions": 126, "deletions": 114}, "files": [{"sha": "5314fc98473832c5a688129be6339163ca753bad", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "patch": "@@ -1,3 +1,27 @@\n+2006-12-22  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-loop-niter.c (zero_p, nonzero_p): Removed.\n+\t(number_of_iterations_ne, number_of_iterations_lt_to_ne,\n+\tassert_no_overflow_lt, assert_loop_rolls_lt,\n+\tnumber_of_iterations_lt, number_of_iterations_le,\n+\tnumber_of_iterations_cond, tree_simplify_using_condition_1,\n+\tnumber_of_iterations_exit, find_loop_niter, loop_niter_by_eval,\n+\timplies_nonnegative_p, implies_ge_p, record_nonwrapping_iv,\n+\tidx_infer_loop_bounds, n_of_executions_at_most, scev_probably_wraps_p):\n+\tDo not use zero_p/nonzero_p.\n+\t* tree-ssa-loop-manip.c (determine_exit_conditions): Ditto.\n+\t* tree-ssa-loop-ivopts.c (niter_for_exit, determine_biv_step,\n+\tfind_interesting_uses_op, find_interesting_uses_cond,\n+\tfind_interesting_uses_address, find_interesting_uses_stmt,\n+\tstrip_offset_1, add_candidate_1, add_old_ivs_candidates,\n+\tdifference_cost, determine_use_iv_cost_condition,\n+\trewrite_use_compare, remove_unused_ivs): Ditto.\n+\t* tree-ssa-address.c (tree_mem_ref_addr, create_mem_ref_raw): Ditto.\n+\t* tree-ssa-loop-prefetch.c (idx_analyze_ref): Ditto.\n+\t* tree-cfg.c (find_taken_edge_cond_expr): Ditto.\n+\t* tree.h (zero_p): Declaration removed.\n+\t(null_or_integer_zerop, nonnull_and_integer_nonzerop): New.\n+\n 2006-12-22  Manuel Lopez-Ibanez  <manu@gcc.gnu.org>\n \n \tPR middle-end/7651"}, {"sha": "bdb1bce23230ce563cd18b2d009e8e04faed4789", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "patch": "@@ -2153,7 +2153,7 @@ find_taken_edge_cond_expr (basic_block bb, tree val)\n   extract_true_false_edges_from_block (bb, &true_edge, &false_edge);\n \n   gcc_assert (TREE_CODE (val) == INTEGER_CST);\n-  return (zero_p (val) ? false_edge : true_edge);\n+  return (integer_zerop (val) ? false_edge : true_edge);\n }\n \n /* Given an INTEGER_CST VAL and the entry block BB to a SWITCH_EXPR"}, {"sha": "3fffd1d3fea9e1ce105a412c36562b79fe9c481a", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "patch": "@@ -281,7 +281,7 @@ tree_mem_ref_addr (tree type, tree mem_ref)\n \taddr = act_elem;\n     }\n \n-  if (!zero_p (offset))\n+  if (offset && !integer_zerop (offset))\n     {\n       act_elem = fold_convert (type, offset);\n \n@@ -325,7 +325,7 @@ create_mem_ref_raw (tree type, struct mem_address *addr)\n   if (addr->step && integer_onep (addr->step))\n     addr->step = NULL_TREE;\n \n-  if (addr->offset && zero_p (addr->offset))\n+  if (addr->offset && integer_zerop (addr->offset))\n     addr->offset = NULL_TREE;\n \n   return build7 (TARGET_MEM_REF, type,"}, {"sha": "5e70937a6f7ce6b9497106a3845adaffa72e9c38", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "patch": "@@ -732,7 +732,7 @@ niter_for_exit (struct ivopts_data *data, edge exit)\n \t overlapping life ranges for them (PR 27283).  */\n       if (number_of_iterations_exit (data->current_loop,\n \t\t\t\t     exit, &desc, true)\n-\t  && zero_p (desc.may_be_zero)\n+\t  && integer_zerop (desc.may_be_zero)\n      \t  && !contains_abnormal_ssa_name_p (desc.niter))\n \tnfe_desc->niter = desc.niter;\n       else\n@@ -904,7 +904,7 @@ determine_biv_step (tree phi)\n   if (!simple_iv (loop, phi, name, &iv, true))\n     return NULL_TREE;\n \n-  return (zero_p (iv.step) ? NULL_TREE : iv.step);\n+  return (null_or_integer_zerop (iv.step) ? NULL_TREE : iv.step);\n }\n \n /* Finds basic ivs.  */\n@@ -1160,7 +1160,7 @@ find_interesting_uses_op (struct ivopts_data *data, tree op)\n       return use;\n     }\n \n-  if (zero_p (iv->step))\n+  if (null_or_integer_zerop (iv->step))\n     {\n       record_invariant (data, op, true);\n       return NULL;\n@@ -1224,21 +1224,23 @@ find_interesting_uses_cond (struct ivopts_data *data, tree stmt, tree *cond_p)\n       (!iv0 || !iv1)\n       /* Eliminating condition based on two ivs would be nontrivial.\n \t ??? TODO -- it is not really important to handle this case.  */\n-      || (!zero_p (iv0->step) && !zero_p (iv1->step)))\n+      || (!null_or_integer_zerop (iv0->step)\n+\t  && !null_or_integer_zerop (iv1->step)))\n     {\n       find_interesting_uses_op (data, *op0_p);\n       find_interesting_uses_op (data, *op1_p);\n       return;\n     }\n \n-  if (zero_p (iv0->step) && zero_p (iv1->step))\n+  if (null_or_integer_zerop (iv0->step)\n+      && null_or_integer_zerop (iv1->step))\n     {\n       /* If both are invariants, this is a work for unswitching.  */\n       return;\n     }\n \n   civ = XNEW (struct iv);\n-  *civ = zero_p (iv0->step) ? *iv1: *iv0;\n+  *civ = null_or_integer_zerop (iv0->step) ? *iv1: *iv0;\n   record_use (data, cond_p, civ, stmt, USE_COMPARE);\n }\n \n@@ -1514,7 +1516,7 @@ find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n \t    }\n \t}\n \n-      if (zero_p (step))\n+      if (null_or_integer_zerop (step))\n \tgoto fail;\n       base = tree_mem_ref_addr (type, base);\n     }\n@@ -1524,7 +1526,7 @@ find_interesting_uses_address (struct ivopts_data *data, tree stmt, tree *op_p)\n       ifs_ivopts_data.stmt = stmt;\n       ifs_ivopts_data.step_p = &step;\n       if (!for_each_index (&base, idx_find_step, &ifs_ivopts_data)\n-\t  || zero_p (step))\n+\t  || null_or_integer_zerop (step))\n \tgoto fail;\n \n       gcc_assert (TREE_CODE (base) != ALIGN_INDIRECT_REF);\n@@ -1598,7 +1600,7 @@ find_interesting_uses_stmt (struct ivopts_data *data, tree stmt)\n \n \t  iv = get_iv (data, lhs);\n \n-\t  if (iv && !zero_p (iv->step))\n+\t  if (iv && !null_or_integer_zerop (iv->step))\n \t    return;\n \t}\n \n@@ -1644,7 +1646,7 @@ find_interesting_uses_stmt (struct ivopts_data *data, tree stmt)\n       lhs = PHI_RESULT (stmt);\n       iv = get_iv (data, lhs);\n \n-      if (iv && !zero_p (iv->step))\n+      if (iv && !null_or_integer_zerop (iv->step))\n \treturn;\n     }\n \n@@ -1758,7 +1760,7 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n     {\n     case INTEGER_CST:\n       if (!cst_and_fits_in_hwi (expr)\n-\t  || zero_p (expr))\n+\t  || integer_zerop (expr))\n \treturn orig_expr;\n \n       *offset = int_cst_value (expr);\n@@ -1777,9 +1779,9 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n \t  && op1 == TREE_OPERAND (expr, 1))\n \treturn orig_expr;\n \n-      if (zero_p (op1))\n+      if (integer_zerop (op1))\n \texpr = op0;\n-      else if (zero_p (op0))\n+      else if (integer_zerop (op0))\n \t{\n \t  if (code == PLUS_EXPR)\n \t    expr = op1;\n@@ -1805,7 +1807,7 @@ strip_offset_1 (tree expr, bool inside_addr, bool top_compref,\n       *offset = off1 * st;\n \n       if (top_compref\n-\t  && zero_p (op1))\n+\t  && integer_zerop (op1))\n \t{\n \t  /* Strip the component reference completely.  */\n \t  op0 = TREE_OPERAND (expr, 0);\n@@ -1971,9 +1973,9 @@ add_candidate_1 (struct ivopts_data *data,\n       if (!operand_equal_p (base, cand->iv->base, 0))\n \tcontinue;\n \n-      if (zero_p (cand->iv->step))\n+      if (null_or_integer_zerop (cand->iv->step))\n \t{\n-\t  if (zero_p (step))\n+\t  if (null_or_integer_zerop (step))\n \t    break;\n \t}\n       else\n@@ -2134,7 +2136,7 @@ add_old_ivs_candidates (struct ivopts_data *data)\n   EXECUTE_IF_SET_IN_BITMAP (data->relevant, 0, i, bi)\n     {\n       iv = ver_info (data, i)->iv;\n-      if (iv && iv->biv_p && !zero_p (iv->step))\n+      if (iv && iv->biv_p && !null_or_integer_zerop (iv->step))\n \tadd_old_iv_candidates (data, iv);\n     }\n }\n@@ -3340,10 +3342,10 @@ difference_cost (struct ivopts_data *data,\n       return 0;\n     }\n   *var_present = true;\n-  if (zero_p (e2))\n+  if (integer_zerop (e2))\n     return force_var_cost (data, e1, depends_on);\n \n-  if (zero_p (e1))\n+  if (integer_zerop (e1))\n     {\n       cost = force_var_cost (data, e2, depends_on);\n       cost += multiply_by_cost (-1, mode);\n@@ -3730,7 +3732,8 @@ determine_use_iv_cost_condition (struct ivopts_data *data,\n   if (TREE_CODE (cond) != SSA_NAME)\n     {\n       op = TREE_OPERAND (cond, 0);\n-      if (TREE_CODE (op) == SSA_NAME && !zero_p (get_iv (data, op)->step))\n+      if (TREE_CODE (op) == SSA_NAME\n+\t  && !null_or_integer_zerop (get_iv (data, op)->step))\n \top = TREE_OPERAND (cond, 1);\n       if (TREE_CODE (op) == SSA_NAME)\n \t{\n@@ -5148,7 +5151,7 @@ rewrite_use_compare (struct ivopts_data *data,\n   cond = *use->op_p;\n   op_p = &TREE_OPERAND (cond, 0);\n   if (TREE_CODE (*op_p) != SSA_NAME\n-      || zero_p (get_iv (data, *op_p)->step))\n+      || null_or_integer_zerop (get_iv (data, *op_p)->step))\n     op_p = &TREE_OPERAND (cond, 1);\n \n   op = force_gimple_operand (comp, &stmts, true, SSA_NAME_VAR (*op_p));\n@@ -5219,7 +5222,7 @@ remove_unused_ivs (struct ivopts_data *data)\n \n       info = ver_info (data, j);\n       if (info->iv\n-\t  && !zero_p (info->iv->step)\n+\t  && !null_or_integer_zerop (info->iv->step)\n \t  && !info->inv_id\n \t  && !info->iv->have_use_for\n \t  && !info->preserve_biv)"}, {"sha": "d27985f32919bcf4f3e5dde08bd340e92eb20ba0", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "patch": "@@ -706,7 +706,7 @@ determine_exit_conditions (struct loop *loop, struct tree_niter_desc *desc,\n \tof the loop, i.e., BOUND - step * FACTOR does not overflow.\n      3) # of iterations is at least FACTOR  */\n \n-  if (!zero_p (desc->may_be_zero))\n+  if (!integer_zerop (desc->may_be_zero))\n     cond = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\tinvert_truthvalue (desc->may_be_zero),\n \t\t\tcond);"}, {"sha": "2187c2f332dc6f05273586e7e32b49465104d6ba", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 56, "deletions": 86, "changes": 142, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "patch": "@@ -52,36 +52,6 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n */\n \n-/* Returns true if ARG is either NULL_TREE or constant zero.  Unlike\n-   integer_zerop, it does not care about overflow flags.  */\n-\n-bool\n-zero_p (tree arg)\n-{\n-  if (!arg)\n-    return true;\n-\n-  if (TREE_CODE (arg) != INTEGER_CST)\n-    return false;\n-\n-  return (TREE_INT_CST_LOW (arg) == 0 && TREE_INT_CST_HIGH (arg) == 0);\n-}\n-\n-/* Returns true if ARG a nonzero constant.  Unlike integer_nonzerop, it does\n-   not care about overflow flags.  */\n-\n-static bool\n-nonzero_p (tree arg)\n-{\n-  if (!arg)\n-    return false;\n-\n-  if (TREE_CODE (arg) != INTEGER_CST)\n-    return false;\n-\n-  return (TREE_INT_CST_LOW (arg) != 0 || TREE_INT_CST_HIGH (arg) != 0);\n-}\n-\n /* Returns inverse of X modulo 2^s, where MASK = 2^s-1.  */\n \n static tree\n@@ -188,7 +158,7 @@ number_of_iterations_ne (tree type, affine_iv *iv, tree final,\n       assumption = fold_build2 (FLOOR_MOD_EXPR, niter_type, c, d);\n       assumption = fold_build2 (EQ_EXPR, boolean_type_node,\n \t\t\t\tassumption, build_int_cst (niter_type, 0));\n-      if (!nonzero_p (assumption))\n+      if (!integer_nonzerop (assumption))\n \tniter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t\t  niter->assumptions, assumption);\n     }\n@@ -219,22 +189,22 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n \n   if (TREE_CODE (mod) != INTEGER_CST)\n     return false;\n-  if (nonzero_p (mod))\n+  if (integer_nonzerop (mod))\n     mod = fold_build2 (MINUS_EXPR, niter_type, step, mod);\n   tmod = fold_convert (type, mod);\n \n-  if (nonzero_p (iv0->step))\n+  if (nonnull_and_integer_nonzerop (iv0->step))\n     {\n       /* The final value of the iv is iv1->base + MOD, assuming that this\n \t computation does not overflow, and that\n \t iv0->base <= iv1->base + MOD.  */\n-      if (!iv1->no_overflow && !zero_p (mod))\n+      if (!iv1->no_overflow && !integer_zerop (mod))\n \t{\n \t  bound = fold_build2 (MINUS_EXPR, type,\n \t\t\t       TYPE_MAX_VALUE (type), tmod);\n \t  assumption = fold_build2 (LE_EXPR, boolean_type_node,\n \t\t\t\t    iv1->base, bound);\n-\t  if (zero_p (assumption))\n+\t  if (integer_zerop (assumption))\n \t    return false;\n \t}\n       noloop = fold_build2 (GT_EXPR, boolean_type_node,\n@@ -247,13 +217,13 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n       /* The final value of the iv is iv0->base - MOD, assuming that this\n \t computation does not overflow, and that\n \t iv0->base - MOD <= iv1->base. */\n-      if (!iv0->no_overflow && !zero_p (mod))\n+      if (!iv0->no_overflow && !integer_zerop (mod))\n \t{\n \t  bound = fold_build2 (PLUS_EXPR, type,\n \t\t\t       TYPE_MIN_VALUE (type), tmod);\n \t  assumption = fold_build2 (GE_EXPR, boolean_type_node,\n \t\t\t\t    iv0->base, bound);\n-\t  if (zero_p (assumption))\n+\t  if (integer_zerop (assumption))\n \t    return false;\n \t}\n       noloop = fold_build2 (GT_EXPR, boolean_type_node,\n@@ -262,11 +232,11 @@ number_of_iterations_lt_to_ne (tree type, affine_iv *iv0, affine_iv *iv1,\n \t\t\t    iv1->base);\n     }\n \n-  if (!nonzero_p (assumption))\n+  if (!integer_nonzerop (assumption))\n     niter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t      niter->assumptions,\n \t\t\t\t      assumption);\n-  if (!zero_p (noloop))\n+  if (!integer_zerop (noloop))\n     niter->may_be_zero = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n \t\t\t\t      niter->may_be_zero,\n \t\t\t\t      noloop);\n@@ -286,7 +256,7 @@ assert_no_overflow_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   tree bound, d, assumption, diff;\n   tree niter_type = TREE_TYPE (step);\n \n-  if (nonzero_p (iv0->step))\n+  if (nonnull_and_integer_nonzerop (iv0->step))\n     {\n       /* for (i = iv0->base; i < iv1->base; i += iv0->step) */\n       if (iv0->no_overflow)\n@@ -333,9 +303,9 @@ assert_no_overflow_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \t\t\t\tiv0->base, bound);\n     }\n \n-  if (zero_p (assumption))\n+  if (integer_zerop (assumption))\n     return false;\n-  if (!nonzero_p (assumption))\n+  if (!integer_nonzerop (assumption))\n     niter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t      niter->assumptions, assumption);\n     \n@@ -354,7 +324,7 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   tree assumption = boolean_true_node, bound, diff;\n   tree mbz, mbzl, mbzr;\n \n-  if (nonzero_p (iv0->step))\n+  if (nonnull_and_integer_nonzerop (iv0->step))\n     {\n       diff = fold_build2 (MINUS_EXPR, type,\n \t\t\t  iv0->step, build_int_cst (type, 1));\n@@ -394,10 +364,10 @@ assert_loop_rolls_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \n   mbz = fold_build2 (GT_EXPR, boolean_type_node, mbzl, mbzr);\n \n-  if (!nonzero_p (assumption))\n+  if (!integer_nonzerop (assumption))\n     niter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t      niter->assumptions, assumption);\n-  if (!zero_p (mbz))\n+  if (!integer_zerop (mbz))\n     niter->may_be_zero = fold_build2 (TRUTH_OR_EXPR, boolean_type_node,\n \t\t\t\t      niter->may_be_zero, mbz);\n }\n@@ -414,7 +384,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n   tree niter_type = unsigned_type_for (type);\n   tree delta, step, s;\n \n-  if (nonzero_p (iv0->step))\n+  if (nonnull_and_integer_nonzerop (iv0->step))\n     {\n       niter->control = *iv0;\n       niter->cmp = LT_EXPR;\n@@ -433,9 +403,9 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n \n   /* First handle the special case that the step is +-1.  */\n   if ((iv0->step && integer_onep (iv0->step)\n-       && zero_p (iv1->step))\n+       && null_or_integer_zerop (iv1->step))\n       || (iv1->step && integer_all_onesp (iv1->step)\n-\t  && zero_p (iv0->step)))\n+\t  && null_or_integer_zerop (iv0->step)))\n     {\n       /* for (i = iv0->base; i < iv1->base; i++)\n \n@@ -451,7 +421,7 @@ number_of_iterations_lt (tree type, affine_iv *iv0, affine_iv *iv1,\n       return true;\n     }\n \n-  if (nonzero_p (iv0->step))\n+  if (nonnull_and_integer_nonzerop (iv0->step))\n     step = fold_convert (niter_type, iv0->step);\n   else\n     step = fold_convert (niter_type,\n@@ -509,21 +479,21 @@ number_of_iterations_le (tree type, affine_iv *iv0, affine_iv *iv1,\n \n   if (!never_infinite)\n     {\n-      if (nonzero_p (iv0->step))\n+      if (nonnull_and_integer_nonzerop (iv0->step))\n \tassumption = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t\t  iv1->base, TYPE_MAX_VALUE (type));\n       else\n \tassumption = fold_build2 (NE_EXPR, boolean_type_node,\n \t\t\t\t  iv0->base, TYPE_MIN_VALUE (type));\n \n-      if (zero_p (assumption))\n+      if (integer_zerop (assumption))\n \treturn false;\n-      if (!nonzero_p (assumption))\n+      if (!integer_nonzerop (assumption))\n \tniter->assumptions = fold_build2 (TRUTH_AND_EXPR, boolean_type_node,\n \t\t\t\t\t  niter->assumptions, assumption);\n     }\n \n-  if (nonzero_p (iv0->step))\n+  if (nonnull_and_integer_nonzerop (iv0->step))\n     iv1->base = fold_build2 (PLUS_EXPR, type,\n \t\t\t     iv1->base, build_int_cst (type, 1));\n   else\n@@ -572,7 +542,7 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n   /* Make < comparison from > ones, and for NE_EXPR comparisons, ensure that\n      the control variable is on lhs.  */\n   if (code == GE_EXPR || code == GT_EXPR\n-      || (code == NE_EXPR && zero_p (iv0->step)))\n+      || (code == NE_EXPR && null_or_integer_zerop (iv0->step)))\n     {\n       SWAP (iv0, iv1);\n       code = swap_tree_comparison (code);\n@@ -608,17 +578,17 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n \n   /* If the control induction variable does not overflow, the loop obviously\n      cannot be infinite.  */\n-  if (!zero_p (iv0->step) && iv0->no_overflow)\n+  if (!null_or_integer_zerop (iv0->step) && iv0->no_overflow)\n     never_infinite = true;\n-  else if (!zero_p (iv1->step) && iv1->no_overflow)\n+  else if (!null_or_integer_zerop (iv1->step) && iv1->no_overflow)\n     never_infinite = true;\n   else\n     never_infinite = false;\n \n   /* We can handle the case when neither of the sides of the comparison is\n      invariant, provided that the test is NE_EXPR.  This rarely occurs in\n      practice, but it is simple enough to manage.  */\n-  if (!zero_p (iv0->step) && !zero_p (iv1->step))\n+  if (!null_or_integer_zerop (iv0->step) && !null_or_integer_zerop (iv1->step))\n     {\n       if (code != NE_EXPR)\n \treturn false;\n@@ -633,7 +603,7 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n   /* If the result of the comparison is a constant,  the loop is weird.  More\n      precise handling would be possible, but the situation is not common enough\n      to waste time on it.  */\n-  if (zero_p (iv0->step) && zero_p (iv1->step))\n+  if (null_or_integer_zerop (iv0->step) && null_or_integer_zerop (iv1->step))\n     return false;\n \n   /* Ignore loops of while (i-- < 10) type.  */\n@@ -642,12 +612,12 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n       if (iv0->step && tree_int_cst_sign_bit (iv0->step))\n \treturn false;\n \n-      if (!zero_p (iv1->step) && !tree_int_cst_sign_bit (iv1->step))\n+      if (!null_or_integer_zerop (iv1->step) && !tree_int_cst_sign_bit (iv1->step))\n \treturn false;\n     }\n \n   /* If the loop exits immediately, there is nothing to do.  */\n-  if (zero_p (fold_build2 (code, boolean_type_node, iv0->base, iv1->base)))\n+  if (integer_zerop (fold_build2 (code, boolean_type_node, iv0->base, iv1->base)))\n     {\n       niter->niter = build_int_cst (unsigned_type_for (type), 0);\n       return true;\n@@ -658,7 +628,7 @@ number_of_iterations_cond (tree type, affine_iv *iv0, enum tree_code code,\n   switch (code)\n     {\n     case NE_EXPR:\n-      gcc_assert (zero_p (iv1->step));\n+      gcc_assert (null_or_integer_zerop (iv1->step));\n       return number_of_iterations_ne (type, iv0, iv1->base, niter, never_infinite);\n     case LT_EXPR:\n       return number_of_iterations_lt (type, iv0, iv1, niter, never_infinite);\n@@ -822,11 +792,11 @@ tree_simplify_using_condition_1 (tree cond, tree expr)\n       /* We know that e0 == e1.  Check whether we cannot simplify expr\n \t using this fact.  */\n       e = simplify_replace_tree (expr, e0, e1);\n-      if (zero_p (e) || nonzero_p (e))\n+      if (integer_zerop (e) || integer_nonzerop (e))\n \treturn e;\n \n       e = simplify_replace_tree (expr, e1, e0);\n-      if (zero_p (e) || nonzero_p (e))\n+      if (integer_zerop (e) || integer_nonzerop (e))\n \treturn e;\n     }\n   if (TREE_CODE (expr) == EQ_EXPR)\n@@ -836,10 +806,10 @@ tree_simplify_using_condition_1 (tree cond, tree expr)\n \n       /* If e0 == e1 (EXPR) implies !COND, then EXPR cannot be true.  */\n       e = simplify_replace_tree (cond, e0, e1);\n-      if (zero_p (e))\n+      if (integer_zerop (e))\n \treturn e;\n       e = simplify_replace_tree (cond, e1, e0);\n-      if (zero_p (e))\n+      if (integer_zerop (e))\n \treturn e;\n     }\n   if (TREE_CODE (expr) == NE_EXPR)\n@@ -849,10 +819,10 @@ tree_simplify_using_condition_1 (tree cond, tree expr)\n \n       /* If e0 == e1 (!EXPR) implies !COND, then EXPR must be true.  */\n       e = simplify_replace_tree (cond, e0, e1);\n-      if (zero_p (e))\n+      if (integer_zerop (e))\n \treturn boolean_true_node;\n       e = simplify_replace_tree (cond, e1, e0);\n-      if (zero_p (e))\n+      if (integer_zerop (e))\n \treturn boolean_true_node;\n     }\n \n@@ -861,12 +831,12 @@ tree_simplify_using_condition_1 (tree cond, tree expr)\n   /* Check whether COND ==> EXPR.  */\n   notcond = invert_truthvalue (cond);\n   e = fold_binary (TRUTH_OR_EXPR, boolean_type_node, notcond, te);\n-  if (nonzero_p (e))\n+  if (e && integer_nonzerop (e))\n     return e;\n \n   /* Check whether COND ==> not EXPR.  */\n   e = fold_binary (TRUTH_AND_EXPR, boolean_type_node, cond, te);\n-  if (e && zero_p (e))\n+  if (e && integer_zerop (e))\n     return e;\n \n   return expr;\n@@ -1129,8 +1099,8 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n   \n       /* We can provide a more specific warning if one of the operator is\n \t constant and the other advances by +1 or -1.  */\n-      if (!zero_p (iv1.step)\n-\t  ? (zero_p (iv0.step)\n+      if (!null_or_integer_zerop (iv1.step)\n+\t  ? (null_or_integer_zerop (iv0.step)\n \t     && (integer_onep (iv1.step) || integer_all_onesp (iv1.step)))\n \t  : (iv0.step\n \t     && (integer_onep (iv0.step) || integer_all_onesp (iv0.step))))\n@@ -1176,7 +1146,7 @@ find_loop_niter (struct loop *loop, edge *exit)\n       if (!number_of_iterations_exit (loop, ex, &desc, false))\n \tcontinue;\n \n-      if (nonzero_p (desc.may_be_zero))\n+      if (integer_nonzerop (desc.may_be_zero))\n \t{\n \t  /* We exit in the first iteration through this exit.\n \t     We won't find anything better.  */\n@@ -1185,7 +1155,7 @@ find_loop_niter (struct loop *loop, edge *exit)\n \t  break;\n \t}\n \n-      if (!zero_p (desc.may_be_zero))\n+      if (!integer_zerop (desc.may_be_zero))\n \tcontinue;\n \n       aniter = desc.niter;\n@@ -1415,7 +1385,7 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n \taval[j] = get_val_for (op[j], val[j]);\n \n       acnd = fold_binary (cmp, boolean_type_node, aval[0], aval[1]);\n-      if (acnd && zero_p (acnd))\n+      if (acnd && integer_zerop (acnd))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n@@ -1489,14 +1459,14 @@ implies_nonnegative_p (tree cond, tree val)\n   if (tree_expr_nonnegative_p (val))\n     return true;\n \n-  if (nonzero_p (cond))\n+  if (integer_nonzerop (cond))\n     return false;\n \n   compare = fold_build2 (GE_EXPR,\n \t\t\t boolean_type_node, val, build_int_cst (type, 0));\n   compare = tree_simplify_using_condition_1 (cond, compare);\n \n-  return nonzero_p (compare);\n+  return integer_nonzerop (compare);\n }\n \n /* Returns true if we can prove that COND ==> A >= B.  */\n@@ -1506,15 +1476,15 @@ implies_ge_p (tree cond, tree a, tree b)\n {\n   tree compare = fold_build2 (GE_EXPR, boolean_type_node, a, b);\n \n-  if (nonzero_p (compare))\n+  if (integer_nonzerop (compare))\n     return true;\n \n-  if (nonzero_p (cond))\n+  if (integer_nonzerop (cond))\n     return false;\n \n   compare = tree_simplify_using_condition_1 (cond, compare);\n \n-  return nonzero_p (compare);\n+  return integer_nonzerop (compare);\n }\n \n /* Returns a constant upper bound on the value of expression VAL.  VAL\n@@ -1711,7 +1681,7 @@ record_nonwrapping_iv (struct loop *loop, tree base, tree step, tree stmt,\n   tree niter_bound, extreme, delta;\n   tree type = TREE_TYPE (base), unsigned_type;\n \n-  if (TREE_CODE (step) != INTEGER_CST || zero_p (step))\n+  if (TREE_CODE (step) != INTEGER_CST || integer_zerop (step))\n     return;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1808,7 +1778,7 @@ idx_infer_loop_bounds (tree base, tree *idx, void *dta)\n   if (!init\n       || !step\n       || TREE_CODE (step) != INTEGER_CST\n-      || zero_p (step)\n+      || integer_zerop (step)\n       || tree_contains_chrecs (init, NULL)\n       || chrec_contains_symbols_defined_in_loop (init, loop->num))\n     return true;\n@@ -2070,7 +2040,7 @@ n_of_executions_at_most (tree stmt,\n \t\t\t tree niter)\n {\n   double_int bound = niter_bound->bound;\n-  tree nit_type = TREE_TYPE (niter);\n+  tree nit_type = TREE_TYPE (niter), e;\n   enum tree_code cmp;\n \n   gcc_assert (TYPE_UNSIGNED (nit_type));\n@@ -2117,9 +2087,9 @@ n_of_executions_at_most (tree stmt,\n       cmp = GT_EXPR;\n     }\n \n-  return nonzero_p (fold_binary (cmp, boolean_type_node,\n-\t\t\t\t niter,\n-\t\t\t\t double_int_to_tree (nit_type, bound)));\n+  e = fold_binary (cmp, boolean_type_node,\n+\t\t   niter, double_int_to_tree (nit_type, bound));\n+  return e && integer_nonzerop (e);\n }\n \n /* Returns true if the arithmetics in TYPE can be assumed not to wrap.  */\n@@ -2179,7 +2149,7 @@ scev_probably_wraps_p (tree base, tree step,\n       || TREE_CODE (step) != INTEGER_CST)\n     return true;\n \n-  if (zero_p (step))\n+  if (integer_zerop (step))\n     return false;\n \n   /* If we can use the fact that signed and pointer arithmetics does not"}, {"sha": "c8e69226844931356e1714fbf3186c3afa1542e2", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "patch": "@@ -337,7 +337,7 @@ idx_analyze_ref (tree base, tree *index, void *data)\n   ibase = iv.base;\n   step = iv.step;\n \n-  if (zero_p (step))\n+  if (null_or_integer_zerop (step))\n     istep = 0;\n   else\n     {"}, {"sha": "87bce8b0d72bc70bfb7facc93a2cac5674784b08", "filename": "gcc/tree.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e682d7ef0a60b540cb66389abff249dfe1ab5fd/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6e682d7ef0a60b540cb66389abff249dfe1ab5fd", "patch": "@@ -4075,7 +4075,22 @@ extern int integer_pow2p (tree);\n \n extern int integer_nonzerop (tree);\n \n-extern bool zero_p (tree);\n+/* Returns true if X is either NULL or zero.  */\n+\n+static inline bool\n+null_or_integer_zerop (tree x)\n+{\n+  return x == NULL_TREE || integer_zerop (x);\n+}\n+\n+/* Returns true if X is non-NULL and non-zero.  */\n+\n+static inline bool\n+nonnull_and_integer_nonzerop (tree x)\n+{\n+  return x != NULL_TREE && integer_nonzerop (x);\n+}\n+\n extern bool cst_and_fits_in_hwi (tree);\n extern tree num_ending_zeros (tree);\n "}]}