{"sha": "a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTY2OGFkYjJmM2JiZTdlNGI2ZjZhZWUyY2E3MjFiOGU0NjZkMmVlNw==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm@polyomino.org.uk", "date": "2004-05-24T19:28:20Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2004-05-24T19:28:20Z"}, "message": "intl.h (open_quote, [...]): New.\n\n\t* intl.h (open_quote, close_quote): New.\n\t* intl.c (open_quote, close_quote): New.\n\t(gcc_init_libintl): Set them.\n\t* pretty-print.c: Include \"intl.h\".\n\t(pp_base_format_text): Support 'q' format flag and %` and %'\n\tformats.  Use ' instead of ` in comments.\n\t* c-format.c (gcc_diag_flag_specs, gcc_cxxdiag_flag_specs,\n\tgcc_diag_char_table, gcc_cdiag_char_table, gcc_cxxdiag_char_table,\n\tforamt_types_orig): Describe these new formats.\n\t(decode_format_attr, check_function_format,\n\tcheck_format_info_main): Use these new formats.\n\t(status_warning): Use ATTRIBUTE_GCC_DIAG.\n\t* toplev.c (ATTRIBUTE_GCC_DIAG): Increase required GCC version to\n\tcheck these formats to 3.5.\n\nFrom-SVN: r82215", "tree": {"sha": "8e604d480ecc6f087099ac7d2f0f4f6d9b68c228", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e604d480ecc6f087099ac7d2f0f4f6d9b68c228"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1bfc8f675bee787718c1f5d24a300d7b86107fea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bfc8f675bee787718c1f5d24a300d7b86107fea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bfc8f675bee787718c1f5d24a300d7b86107fea"}], "stats": {"total": 200, "additions": 144, "deletions": 56}, "files": [{"sha": "5f86a6c5323ea9e85c2239224980228a2a493e10", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7", "patch": "@@ -1,3 +1,20 @@\n+2004-05-24  Joseph S. Myers  <jsm@polyomino.org.uk>\n+\n+\t* intl.h (open_quote, close_quote): New.\n+\t* intl.c (open_quote, close_quote): New.\n+\t(gcc_init_libintl): Set them.\n+\t* pretty-print.c: Include \"intl.h\".\n+\t(pp_base_format_text): Support 'q' format flag and %` and %'\n+\tformats.  Use ' instead of ` in comments.\n+\t* c-format.c (gcc_diag_flag_specs, gcc_cxxdiag_flag_specs,\n+\tgcc_diag_char_table, gcc_cdiag_char_table, gcc_cxxdiag_char_table,\n+\tforamt_types_orig): Describe these new formats.\n+\t(decode_format_attr, check_function_format,\n+\tcheck_format_info_main): Use these new formats.\n+\t(status_warning): Use ATTRIBUTE_GCC_DIAG.\n+\t* toplev.c (ATTRIBUTE_GCC_DIAG): Increase required GCC version to\n+\tcheck these formats to 3.5.\n+\n 2004-05-24  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* Makefile.in (CPPLIBS): Renamed to CPPLIB."}, {"sha": "e791a834b6e66f7bbba7b7b38ad5070427d0055e", "filename": "gcc/c-format.c", "status": "modified", "additions": 56, "deletions": 48, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7", "patch": "@@ -200,7 +200,7 @@ decode_format_attr (tree args, function_format_info *info, int validated_p)\n \t{\n \t  if (validated_p)\n \t    abort ();\n-\t  warning (\"`%s' is an unrecognized format function type\", p);\n+\t  warning (\"%qs is an unrecognized format function type\", p);\n \t  return false;\n \t}\n     }\n@@ -615,6 +615,7 @@ static const format_flag_pair gcc_diag_flag_pairs[] =\n \n static const format_flag_spec gcc_diag_flag_specs[] =\n {\n+  { 'q',  0, 0, N_(\"`q' flag\"),        N_(\"the `q' diagnostic flag\"),          STD_C89 },\n   { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n   { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n   { 0, 0, 0, NULL, NULL, 0 }\n@@ -626,6 +627,7 @@ static const format_flag_spec gcc_cxxdiag_flag_specs[] =\n {\n   { '+',  0, 0, N_(\"`+' flag\"),        N_(\"the `+' printf flag\"),              STD_C89 },\n   { '#',  0, 0, N_(\"`#' flag\"),        N_(\"the `#' printf flag\"),              STD_C89 },\n+  { 'q',  0, 0, N_(\"`q' flag\"),        N_(\"the `q' diagnostic flag\"),          STD_C89 },\n   { 'p',  0, 0, N_(\"precision\"),       N_(\"precision in printf format\"),       STD_C89 },\n   { 'L',  0, 0, N_(\"length modifier\"), N_(\"length modifier in printf format\"), STD_C89 },\n   { 0, 0, 0, NULL, NULL, 0 }\n@@ -798,69 +800,75 @@ static const format_char_info asm_fprintf_char_table[] =\n static const format_char_info gcc_diag_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n-  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"p\",  \"cR\" },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"c\"  },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\" },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\"  },\n \n   /* Custom conversion specifiers.  */\n \n   /* %H will require \"location_t\" at runtime.  */\n-  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"J\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+  { \"J\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",    \"\"   },\n \n-  { \"m\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"`\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"'\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\"   },\n   { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n };\n \n static const format_char_info gcc_cdiag_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n-  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"p\",  \"cR\" },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"c\"  },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\" },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\"  },\n \n   /* Custom conversion specifiers.  */\n \n   /* %H will require \"location_t\" at runtime.  */\n-  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"DEFJT\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+  { \"DEFJT\", 0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\", \"\"   },\n \n-  { \"m\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"`\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"'\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\"   },\n   { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n };\n \n static const format_char_info gcc_cxxdiag_char_table[] =\n {\n   /* C89 conversion specifiers.  */\n-  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n-  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n-  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",  \"\"   },\n-  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n-  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"p\",  \"cR\" },\n-  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"c\"  },\n+  { \"di\",  0, STD_C89, { T89_I,   BADLEN,  BADLEN,  T89_L,   T9L_LL,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"ox\",  0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"u\",   0, STD_C89, { T89_UI,  BADLEN,  BADLEN,  T89_UL,  T9L_ULL, BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"c\",   0, STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n+  { \"s\",   1, STD_C89, { T89_C,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"pq\", \"cR\" },\n+  { \"p\",   1, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"c\"  },\n \n   /* Custom conversion specifiers.  */\n \n   /* %H will require \"location_t\" at runtime.  */\n-  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+  { \"H\",   0, STD_C89, { T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n \n   /* These will require a \"tree\" at runtime.  */\n-  { \"ADEFJTV\",0,STD_C89,{ T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"+#\",   \"\"   },\n+  { \"ADEFJTV\",0,STD_C89,{ T89_V,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q+#\",   \"\"   },\n \n   /* These accept either an `int' or an `enum tree_code' (which is handled as an `int'.)  */\n-  { \"CLOPQ\",0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"\",   \"\"   },\n+  { \"CLOPQ\",0,STD_C89, { T89_I,   BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN,  BADLEN  }, \"q\",  \"\"   },\n \n-  { \"m\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"`\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"'\",   0, STD_C89, NOARGUMENTS, \"\",      \"\"   },\n+  { \"m\",   0, STD_C89, NOARGUMENTS, \"q\",     \"\"   },\n   { NULL,  0, 0, NOLENGTHS, NULL, NULL }\n };\n \n@@ -933,19 +941,19 @@ static const format_kind_info format_types_orig[] =\n     'w', 0, 'p', 0, 'L',\n     NULL, NULL\n   },\n-  { \"gcc_diag\",   gcc_diag_length_specs,  gcc_diag_char_table, \"\", NULL, \n+  { \"gcc_diag\",   gcc_diag_length_specs,  gcc_diag_char_table, \"q\", NULL, \n     gcc_diag_flag_specs, gcc_diag_flag_pairs,\n     FMT_FLAG_ARG_CONVERT,\n     0, 0, 'p', 0, 'L',\n     NULL, &integer_type_node\n   },\n-  { \"gcc_cdiag\",   gcc_cdiag_length_specs,  gcc_cdiag_char_table, \"\", NULL, \n+  { \"gcc_cdiag\",   gcc_cdiag_length_specs,  gcc_cdiag_char_table, \"q\", NULL, \n     gcc_cdiag_flag_specs, gcc_cdiag_flag_pairs,\n     FMT_FLAG_ARG_CONVERT,\n     0, 0, 'p', 0, 'L',\n     NULL, &integer_type_node\n   },\n-  { \"gcc_cxxdiag\",   gcc_cxxdiag_length_specs,  gcc_cxxdiag_char_table, \"+#\", NULL, \n+  { \"gcc_cxxdiag\",   gcc_cxxdiag_length_specs,  gcc_cxxdiag_char_table, \"q+#\", NULL, \n     gcc_cxxdiag_flag_specs, gcc_cxxdiag_flag_pairs,\n     FMT_FLAG_ARG_CONVERT,\n     0, 0, 'p', 0, 'L',\n@@ -1018,7 +1026,7 @@ static void check_format_info_main (int *, format_check_results *,\n \t\t\t\t    const char *, int, tree,\n \t\t\t\t    unsigned HOST_WIDE_INT);\n static void status_warning (int *, const char *, ...)\n-     ATTRIBUTE_PRINTF_2;\n+     ATTRIBUTE_GCC_DIAG(2, 3);\n \n static void init_dollar_format_checking (int, tree);\n static int maybe_read_dollar_number (int *, const char **, int,\n@@ -1105,7 +1113,7 @@ check_function_format (int *status, tree attrs, tree params)\n \t\t\tbreak;\n \t\t    }\n \t\t  if (args != 0)\n-\t\t    warning (\"function might be possible candidate for `%s' format attribute\",\n+\t\t    warning (\"function might be possible candidate for %qs format attribute\",\n \t\t\t     format_types[info.format_type].name);\n \t\t}\n \t    }\n@@ -1699,7 +1707,7 @@ check_format_info_main (int *status, format_check_results *res,\n       if (*format_chars == 0)\n \t{\n \t  if (format_chars - orig_format_chars != format_length)\n-\t    status_warning (status, \"embedded `\\\\0' in format\");\n+\t    status_warning (status, \"embedded %`\\\\0%' in format\");\n \t  if (info->first_arg_num != 0 && params != 0\n \t      && has_operand_number <= 0)\n \t    {\n@@ -1714,7 +1722,7 @@ check_format_info_main (int *status, format_check_results *res,\n \tcontinue;\n       if (*format_chars == 0)\n \t{\n-\t  status_warning (status, \"spurious trailing `%%' in format\");\n+\t  status_warning (status, \"spurious trailing %`%%%' in format\");\n \t  continue;\n \t}\n       if (*format_chars == '%')\n@@ -1989,7 +1997,7 @@ check_format_info_main (int *status, format_check_results *res,\n \t    {\n \t      /* Warn if the length modifier is non-standard.  */\n \t      if (ADJ_STD (length_chars_std) > C_STD_VER)\n-\t\tstatus_warning (status, \"%s does not support the `%s' %s length modifier\",\n+\t\tstatus_warning (status, \"%s does not support the %qs %s length modifier\",\n \t\t\t\tC_STD_NAME (length_chars_std), length_chars,\n \t\t\t\tfki->name);\n \t    }\n@@ -2050,7 +2058,7 @@ check_format_info_main (int *status, format_check_results *res,\n       if (fci->format_chars == 0)\n \t{\n           if (ISGRAPH(format_char))\n-\t    status_warning (status, \"unknown conversion type character `%c' in format\",\n+\t    status_warning (status, \"unknown conversion type character %qc in format\",\n \t\t     format_char);\n \t  else\n \t    status_warning (status, \"unknown conversion type character 0x%x in format\",\n@@ -2060,7 +2068,7 @@ check_format_info_main (int *status, format_check_results *res,\n       if (pedantic)\n \t{\n \t  if (ADJ_STD (fci->std) > C_STD_VER)\n-\t    status_warning (status, \"%s does not support the `%%%c' %s format\",\n+\t    status_warning (status, \"%s does not support the %`%%%c%' %s format\",\n \t\t\t    C_STD_NAME (fci->std), format_char, fki->name);\n \t}\n \n@@ -2076,7 +2084,7 @@ check_format_info_main (int *status, format_check_results *res,\n \t      continue;\n \t    if (strchr (fci->flag_chars, flag_chars[i]) == 0)\n \t      {\n-\t\tstatus_warning (status, \"%s used with `%%%c' %s format\",\n+\t\tstatus_warning (status, \"%s used with %`%%%c%' %s format\",\n \t\t\t\t_(s->name), format_char, fki->name);\n \t\td++;\n \t\tcontinue;\n@@ -2094,7 +2102,7 @@ check_format_info_main (int *status, format_check_results *res,\n \t\t\t\t\t     ? t->long_name\n \t\t\t\t\t     : s->long_name);\n \t\t    if (ADJ_STD (t->std) > C_STD_VER)\n-\t\t      status_warning (status, \"%s does not support %s with the `%%%c' %s format\",\n+\t\t      status_warning (status, \"%s does not support %s with the %`%%%c%' %s format\",\n \t\t\t\t      C_STD_NAME (t->std), _(long_name),\n \t\t\t\t      format_char, fki->name);\n \t\t  }\n@@ -2127,7 +2135,7 @@ check_format_info_main (int *status, format_check_results *res,\n \t  if (bad_flag_pairs[i].ignored)\n \t    {\n \t      if (bad_flag_pairs[i].predicate != 0)\n-\t\tstatus_warning (status, \"%s ignored with %s and `%%%c' %s format\",\n+\t\tstatus_warning (status, \"%s ignored with %s and %`%%%c%' %s format\",\n \t\t\t\t_(s->name), _(t->name), format_char,\n \t\t\t\tfki->name);\n \t      else\n@@ -2137,7 +2145,7 @@ check_format_info_main (int *status, format_check_results *res,\n \t  else\n \t    {\n \t      if (bad_flag_pairs[i].predicate != 0)\n-\t\tstatus_warning (status, \"use of %s and %s together with `%%%c' %s format\",\n+\t\tstatus_warning (status, \"use of %s and %s together with %`%%%c%' %s format\",\n \t\t\t\t_(s->name), _(t->name), format_char,\n \t\t\t\tfki->name);\n \t      else\n@@ -2160,10 +2168,10 @@ check_format_info_main (int *status, format_check_results *res,\n \t  else if (strchr (fci->flags2, '2') != 0)\n \t    y2k_level = 2;\n \t  if (y2k_level == 3)\n-\t    status_warning (status, \"`%%%c' yields only last 2 digits of year in some locales\",\n+\t    status_warning (status, \"%`%%%c%' yields only last 2 digits of year in some locales\",\n \t\t\t    format_char);\n \t  else if (y2k_level == 2)\n-\t    status_warning (status, \"`%%%c' yields only last 2 digits of year\", format_char);\n+\t    status_warning (status, \"%`%%%c%' yields only last 2 digits of year\", format_char);\n \t}\n \n       if (strchr (fci->flags2, '[') != 0)\n@@ -2179,7 +2187,7 @@ check_format_info_main (int *status, format_check_results *res,\n \t    ++format_chars;\n \t  if (*format_chars != ']')\n \t    /* The end of the format string was reached.  */\n-\t    status_warning (status, \"no closing `]' for `%%[' format\");\n+\t    status_warning (status, \"no closing %`]%' for %`%%[%' format\");\n \t}\n \n       wanted_type = 0;\n@@ -2192,7 +2200,7 @@ check_format_info_main (int *status, format_check_results *res,\n \t  wanted_type_std = fci->types[length_chars_val].std;\n \t  if (wanted_type == 0)\n \t    {\n-\t      status_warning (status, \"use of `%s' length modifier with `%c' type character\",\n+\t      status_warning (status, \"use of %qs length modifier with %qc type character\",\n \t\t\t      length_chars, format_char);\n \t      /* Heuristic: skip one argument when an invalid length/type\n \t\t combination is encountered.  */\n@@ -2213,7 +2221,7 @@ check_format_info_main (int *status, format_check_results *res,\n \t\t   && ADJ_STD (wanted_type_std) > ADJ_STD (fci->std))\n \t    {\n \t      if (ADJ_STD (wanted_type_std) > C_STD_VER)\n-\t\tstatus_warning (status, \"%s does not support the `%%%s%c' %s format\",\n+\t\tstatus_warning (status, \"%s does not support the %`%%%s%c%' %s format\",\n \t\t\t\tC_STD_NAME (wanted_type_std), length_chars,\n \t\t\t\tformat_char, fki->name);\n \t    }"}, {"sha": "e5aa941021fedf669bf8553bb9e6f82f317089b5", "filename": "gcc/intl.c", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2Fintl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2Fintl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl.c?ref=a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7", "patch": "@@ -1,5 +1,5 @@\n /* Message translation utilities.\n-   Copyright (C) 2001, 2003 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2003, 2004 Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -24,6 +24,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm.h\"\n #include \"intl.h\"\n \n+#ifdef HAVE_LANGINFO_CODESET\n+#include <langinfo.h>\n+#endif\n+\n+/* Opening quotation mark for diagnostics.  */\n+const char *open_quote = \"'\";\n+\n+/* Closing quotation mark for diagnostics.  */\n+const char *close_quote = \"'\";\n+\n #ifdef ENABLE_NLS\n \n /* Initialize the translation library for GCC.  This performs the\n@@ -43,6 +53,33 @@ gcc_init_libintl (void)\n \n   (void) bindtextdomain (\"gcc\", LOCALEDIR);\n   (void) textdomain (\"gcc\");\n+\n+  /* Opening quotation mark.  */\n+  open_quote = _(\"`\");\n+\n+  /* Closing quotation mark.  */\n+  close_quote = _(\"'\");\n+\n+  if (!strcmp (open_quote, \"`\") && !strcmp (close_quote, \"'\"))\n+    {\n+#if defined HAVE_LANGINFO_CODESET\n+      const char *encoding;\n+#endif\n+      /* Untranslated quotes that it may be possible to replace with\n+\t U+2018 and U+2019; but otherwise use \"'\" instead of \"`\" as\n+\t opening quote.  */\n+      open_quote = \"'\";\n+#if defined HAVE_LANGINFO_CODESET\n+      encoding = nl_langinfo (CODESET);\n+      if (encoding != NULL\n+\t  && (!strcasecmp (encoding, \"utf-8\")\n+\t      || !strcasecmp (encoding, \"utf8\")))\n+\t{\n+\t  open_quote = \"\\xe2\\x80\\x98\";\n+\t  close_quote = \"\\xe2\\x80\\x99\";\n+\t}\n+#endif\n+    }\n }\n \n #if defined HAVE_WCHAR_H && defined HAVE_WORKING_MBSTOWCS && defined HAVE_WCSWIDTH"}, {"sha": "1166794ed741f779a3316dbe19fb74f29da5a7d1", "filename": "gcc/intl.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2Fintl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2Fintl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintl.h?ref=a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7", "patch": "@@ -1,5 +1,5 @@\n /* intl.h - internationalization\n-   Copyright 1998, 2001, 2003 Free Software Foundation, Inc.\n+   Copyright 1998, 2001, 2003, 2004 Free Software Foundation, Inc.\n \n    GCC is free software; you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n@@ -51,4 +51,7 @@ extern size_t gcc_gettext_width (const char *);\n # define N_(msgid) msgid\n #endif\n \n+extern const char *open_quote;\n+extern const char *close_quote;\n+\n #endif /* intl.h */"}, {"sha": "3f70277e0d6506a43ad5ffc211b1fd6cef4031f5", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 28, "deletions": 5, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7", "patch": "@@ -24,6 +24,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #undef FFS  /* Some systems define this in param.h.  */\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"intl.h\"\n #include \"pretty-print.h\"\n \n #define obstack_chunk_alloc xmalloc\n@@ -177,16 +178,20 @@ pp_base_indent (pretty_printer *pp)\n    %s: string.\n    %p: pointer.\n    %m: strerror(text->err_no) - does not consume a value from args_ptr.\n-   %%: `%'.\n+   %%: '%'.\n+   %`: opening quote.\n+   %': closing quote.\n    %.*s: a substring the length of which is specified by an integer.\n-   %H: location_t.  */\n+   %H: location_t.\n+   Flag 'q': quote formatted text (must come immediately after '%').  */\n void\n pp_base_format_text (pretty_printer *pp, text_info *text)\n {\n   for (; *text->format_spec; ++text->format_spec)\n     {\n       int precision = 0;\n       bool wide = false;\n+      bool quoted = false;\n \n       /* Ignore text.  */\n       {\n@@ -200,8 +205,14 @@ pp_base_format_text (pretty_printer *pp, text_info *text)\n       if (*text->format_spec == '\\0')\n \tbreak;\n \n-      /* We got a '%'.  Parse precision modifiers, if any.  */\n-      switch (*++text->format_spec)\n+      /* We got a '%'.  Check for 'q', then parse precision modifiers,\n+\t if any.  */\n+      if (*++text->format_spec == 'q')\n+\t{\n+\t  quoted = true;\n+\t  ++text->format_spec;\n+\t}\n+      switch (*text->format_spec)\n         {\n         case 'w':\n           wide = true;\n@@ -221,6 +232,8 @@ pp_base_format_text (pretty_printer *pp, text_info *text)\n       if (precision > 2)\n         abort();\n \n+      if (quoted)\n+\tpp_string (pp, open_quote);\n       switch (*text->format_spec)\n \t{\n \tcase 'c':\n@@ -279,6 +292,14 @@ pp_base_format_text (pretty_printer *pp, text_info *text)\n \t  pp_character (pp, '%');\n \t  break;\n \n+\tcase '`':\n+\t  pp_string (pp, open_quote);\n+\t  break;\n+\n+\tcase '\\'':\n+\t  pp_string (pp, close_quote);\n+\t  break;\n+\n         case 'H':\n           {\n             const location_t *locus = va_arg (*text->args_ptr, location_t *);\n@@ -293,7 +314,7 @@ pp_base_format_text (pretty_printer *pp, text_info *text)\n \t  {\n \t    int n;\n \t    const char *s;\n-\t    /* We handle no precision specifier but `%.*s'.  */\n+\t    /* We handle no precision specifier but '%.*s'.  */\n \t    if (*++text->format_spec != '*')\n \t      abort ();\n \t    else if (*++text->format_spec != 's')\n@@ -314,6 +335,8 @@ pp_base_format_text (pretty_printer *pp, text_info *text)\n \t      abort ();\n \t    }\n \t}\n+      if (quoted)\n+\tpp_string (pp, close_quote);\n     }\n }\n "}, {"sha": "aca355771fb02df2518ce480be14df6acfe0f373", "filename": "gcc/toplev.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2Ftoplev.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7/gcc%2Ftoplev.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.h?ref=a668adb2f3bbe7e4b6f6aee2ca721b8e466d2ee7", "patch": "@@ -49,7 +49,7 @@ extern void _fatal_insn (const char *, rtx, const char *, int, const char *)\n /* None of these functions are suitable for ATTRIBUTE_PRINTF, because\n    each language front end can extend them with its own set of format\n    specifiers.  We must use custom format checks.  */\n-#if GCC_VERSION >= 3004\n+#if GCC_VERSION >= 3005\n #define ATTRIBUTE_GCC_DIAG(m, n) __attribute__ ((__format__ (GCC_DIAG_STYLE, m, n))) ATTRIBUTE_NONNULL(m)\n #else\n #define ATTRIBUTE_GCC_DIAG(m, n) ATTRIBUTE_NONNULL(m)"}]}