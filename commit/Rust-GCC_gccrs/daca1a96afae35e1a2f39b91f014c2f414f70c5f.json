{"sha": "daca1a96afae35e1a2f39b91f014c2f414f70c5f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFjYTFhOTZhZmFlMzVlMWEyZjM5YjkxZjAxNGMyZjQxNGY3MGM1Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2014-10-22T12:02:26Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-10-22T12:02:26Z"}, "message": "recog.h (constrain_operands): Add an alternative_mask parameter.\n\ngcc/\n\t* recog.h (constrain_operands): Add an alternative_mask parameter.\n\t(constrain_operands_cached): Likewise.\n\t(get_preferred_alternatives): Declare new form.\n\t* recog.c (get_preferred_alternatives): New bb-taking instance.\n\t(constrain_operands): Take the set of available alternatives as\n\ta parameter.\n\t(check_asm_operands, insn_invalid_p, extract_constrain_insn)\n\t(extract_constrain_insn_cached): Update calls to constrain_operands.\n\t* caller-save.c (reg_save_code): Likewise.\n\t* ira.c (setup_prohibited_mode_move_regs): Likewise.\n\t* postreload-gcse.c (eliminate_partially_redundant_load): Likewise.\n\t* ree.c (combine_reaching_defs): Likewise.\n\t* reload.c (can_reload_into): Likewise.\n\t* reload1.c (reload, reload_as_needed, inc_for_reload): Likewise.\n\t(gen_reload_chain_without_interm_reg_p, emit_input_reload_insns)\n\t(emit_insn_if_valid_for_reload): Likewise.\n\t* reorg.c (fill_slots_from_thread): Likewise.\n\t* config/i386/i386.c (ix86_attr_length_address_default): Likewise.\n\t* config/pa/pa.c (pa_can_combine_p): Likewise.\n\t* config/rl78/rl78.c (insn_ok_now): Likewise.\n\t* config/sh/sh.md (define_peephole2): Likewise.\n\t* final.c (final_scan_insn): Update call to constrain_operands_cached.\n\nFrom-SVN: r216555", "tree": {"sha": "eee5382fbf8bb42300717bebf986a46d87ae8a9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eee5382fbf8bb42300717bebf986a46d87ae8a9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/daca1a96afae35e1a2f39b91f014c2f414f70c5f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daca1a96afae35e1a2f39b91f014c2f414f70c5f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daca1a96afae35e1a2f39b91f014c2f414f70c5f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daca1a96afae35e1a2f39b91f014c2f414f70c5f/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9840b2fa87cc9657dca2b63dc66d37f94d2c9cb8"}], "stats": {"total": 142, "additions": 100, "deletions": 42}, "files": [{"sha": "107afeea4164c436d9e68095dc126a00289287a0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -1,3 +1,28 @@\n+2014-10-22  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* recog.h (constrain_operands): Add an alternative_mask parameter.\n+\t(constrain_operands_cached): Likewise.\n+\t(get_preferred_alternatives): Declare new form.\n+\t* recog.c (get_preferred_alternatives): New bb-taking instance.\n+\t(constrain_operands): Take the set of available alternatives as\n+\ta parameter.\n+\t(check_asm_operands, insn_invalid_p, extract_constrain_insn)\n+\t(extract_constrain_insn_cached): Update calls to constrain_operands.\n+\t* caller-save.c (reg_save_code): Likewise.\n+\t* ira.c (setup_prohibited_mode_move_regs): Likewise.\n+\t* postreload-gcse.c (eliminate_partially_redundant_load): Likewise.\n+\t* ree.c (combine_reaching_defs): Likewise.\n+\t* reload.c (can_reload_into): Likewise.\n+\t* reload1.c (reload, reload_as_needed, inc_for_reload): Likewise.\n+\t(gen_reload_chain_without_interm_reg_p, emit_input_reload_insns)\n+\t(emit_insn_if_valid_for_reload): Likewise.\n+\t* reorg.c (fill_slots_from_thread): Likewise.\n+\t* config/i386/i386.c (ix86_attr_length_address_default): Likewise.\n+\t* config/pa/pa.c (pa_can_combine_p): Likewise.\n+\t* config/rl78/rl78.c (insn_ok_now): Likewise.\n+\t* config/sh/sh.md (define_peephole2): Likewise.\n+\t* final.c (final_scan_insn): Update call to constrain_operands_cached.\n+\n 2014-10-22  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* doc/md.texi: Document \"preferred_for_size\" and \"preferred_for_speed\""}, {"sha": "8d38eabf701064f5e0f4846c6fc83e7814c55c4e", "filename": "gcc/caller-save.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -143,15 +143,17 @@ reg_save_code (int reg, enum machine_mode mode)\n   cached_reg_restore_code[reg][mode] = recog_memoized (restinsn);\n \n   /* Now extract both insns and see if we can meet their\n-     constraints.  */\n+     constraints.  We don't know here whether the save and restore will\n+     be in size- or speed-tuned code, so just use the set of enabled\n+     alternatives.  */\n   ok = (cached_reg_save_code[reg][mode] != -1\n \t&& cached_reg_restore_code[reg][mode] != -1);\n   if (ok)\n     {\n       extract_insn (saveinsn);\n-      ok = constrain_operands (1);\n+      ok = constrain_operands (1, get_enabled_alternatives (saveinsn));\n       extract_insn (restinsn);\n-      ok &= constrain_operands (1);\n+      ok &= constrain_operands (1, get_enabled_alternatives (restinsn));\n     }\n \n   if (! ok)"}, {"sha": "ec3e056a3d2aeb6c892d032eb2324957750367a7", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -25467,7 +25467,7 @@ ix86_attr_length_address_default (rtx_insn *insn)\n   for (i = recog_data.n_operands - 1; i >= 0; --i)\n     if (MEM_P (recog_data.operand[i]))\n       {\n-        constrain_operands_cached (reload_completed);\n+        constrain_operands_cached (insn, reload_completed);\n         if (which_alternative != -1)\n \t  {\n \t    const char *constraints = recog_data.constraints[i];"}, {"sha": "05131d493f934343a5c83bc6bbea0a16961deea7", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -9064,8 +9064,10 @@ pa_can_combine_p (rtx_insn *new_rtx, rtx_insn *anchor, rtx_insn *floater,\n   XVECEXP (PATTERN (new_rtx), 0, 1) = PATTERN (floater);\n   INSN_CODE (new_rtx) = -1;\n   insn_code_number = recog_memoized (new_rtx);\n+  basic_block bb = BLOCK_FOR_INSN (anchor);\n   if (insn_code_number < 0\n-      || (extract_insn (new_rtx), ! constrain_operands (1)))\n+      || (extract_insn (new_rtx),\n+\t  !constrain_operands (1, get_preferred_alternatives (new_rtx, bb)))\n     return 0;\n \n   if (reversed)"}, {"sha": "f2419ba62266d39a1f129088695c4a076dd6f31b", "filename": "gcc/config/rl78/rl78.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fconfig%2Frl78%2Frl78.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fconfig%2Frl78%2Frl78.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frl78%2Frl78.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -2170,7 +2170,7 @@ insn_ok_now (rtx_insn *insn)\n   if (recog (pattern, insn, 0) > -1)\n     {\n       extract_insn (insn);\n-      if (constrain_operands (1))\n+      if (constrain_operands (1, get_preferred_alternatives (insn)))\n \t{\n #if DEBUG_ALLOC\n \t  fprintf (stderr, \"\\033[32m\");\n@@ -2199,7 +2199,7 @@ insn_ok_now (rtx_insn *insn)\n       if (recog (pattern, insn, 0) > -1)\n \t{\n \t  extract_insn (insn);\n-\t  if (constrain_operands (0))\n+\t  if (constrain_operands (0, get_preferred_alternatives (insn)))\n \t    {\n \t      cfun->machine->virt_insns_ok = 0;\n \t      return false;"}, {"sha": "b48be1092a38198e97d30c76538a88f809871d16", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -1580,7 +1580,7 @@\n    (set (match_dup 4) (match_dup 5))]\n {\n   rtx set1, set2;\n-  rtx_insn *insn2;\n+  rtx_insn *insn1, *insn2;\n   rtx replacements[4];\n \n   /* We want to replace occurrences of operands[0] with operands[1] and\n@@ -1607,14 +1607,16 @@\n   /* ??? The last insn might be a jump insn, but the generic peephole2 code\n      always uses emit_insn.  */\n   /* Check that we don't violate matching constraints or earlyclobbers.  */\n-  extract_insn (emit_insn (set1));\n-  if (! constrain_operands (1))\n+  basic_block bb = BLOCK_FOR_INSN (peep2_next_insn (2));\n+  insn1 = emit_insn (set1);\n+  extract_insn (insn1);\n+  if (! constrain_operands (1, get_preferred_alternatives (insn1, bb)))\n     goto failure;\n   insn2 = emit (set2);\n   if (GET_CODE (insn2) == BARRIER)\n     goto failure;\n   extract_insn (insn2);\n-  if (! constrain_operands (1))\n+  if (! constrain_operands (1, get_preferred_alternatives (insn2, bb)))\n     {\n       rtx tmp;\n     failure:"}, {"sha": "c3dc7a5d78c9acb9e062ef2db5209ca66d894363", "filename": "gcc/final.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -2934,7 +2934,7 @@ final_scan_insn (rtx_insn *insn, FILE *file, int optimize_p ATTRIBUTE_UNUSED,\n \t    print_rtx_head = \"\";\n \t  }\n \n-\tif (! constrain_operands_cached (1))\n+\tif (! constrain_operands_cached (insn, 1))\n \t  fatal_insn_not_found (insn);\n \n \t/* Some target machines need to prescan each insn before"}, {"sha": "235a21171df9a4f61b17d595d50c6c81714a76fe", "filename": "gcc/ira.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -1765,7 +1765,9 @@ setup_prohibited_mode_move_regs (void)\n \t  if (INSN_CODE (move_insn) < 0)\n \t    continue;\n \t  extract_insn (move_insn);\n-\t  if (! constrain_operands (1))\n+\t  /* We don't know whether the move will be in code that is optimized\n+\t     for size or speed, so consider all enabled alternatives.  */\n+\t  if (! constrain_operands (1, get_enabled_alternatives (move_insn)))\n \t    continue;\n \t  CLEAR_HARD_REG_BIT (ira_prohibited_mode_move_regs[i], j);\n \t}"}, {"sha": "264e03064f83a6d309ada688e3511c6813d88729", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -1008,10 +1008,11 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n \n \t  /* Make sure we can generate a move from register avail_reg to\n \t     dest.  */\n-\t  extract_insn (as_a <rtx_insn *> (\n-\t\t\t  gen_move_insn (copy_rtx (dest),\n-\t\t\t\t\t copy_rtx (avail_reg))));\n-\t  if (! constrain_operands (1)\n+\t  rtx_insn *move = as_a <rtx_insn *>\n+\t    (gen_move_insn (copy_rtx (dest), copy_rtx (avail_reg)));\n+\t  extract_insn (move);\n+\t  if (! constrain_operands (1, get_preferred_alternatives (insn,\n+\t\t\t\t\t\t\t\t   pred_bb))\n \t      || reg_killed_on_edge (avail_reg, pred)\n \t      || reg_used_on_edge (dest, pred))\n \t    {"}, {"sha": "5be01ccca95867d12d673f55048102bd0a116ec6", "filename": "gcc/recog.c", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -160,8 +160,9 @@ check_asm_operands (rtx x)\n   if (reload_completed)\n     {\n       /* ??? Doh!  We've not got the wrapping insn.  Cook one up.  */\n-      extract_insn (make_insn_raw (x));\n-      constrain_operands (1);\n+      rtx_insn *insn = make_insn_raw (x);\n+      extract_insn (insn);\n+      constrain_operands (1, get_enabled_alternatives (insn));\n       return which_alternative >= 0;\n     }\n \n@@ -365,7 +366,7 @@ insn_invalid_p (rtx_insn *insn, bool in_group)\n     {\n       extract_insn (insn);\n \n-      if (! constrain_operands (1))\n+      if (! constrain_operands (1, get_preferred_alternatives (insn)))\n \treturn 1;\n     }\n \n@@ -2164,6 +2165,21 @@ get_preferred_alternatives (rtx_insn *insn)\n     return get_bool_attr_mask (insn, BA_PREFERRED_FOR_SIZE);\n }\n \n+/* Return the set of alternatives of INSN that are allowed by the current\n+   target and are preferred for the size/speed optimization choice\n+   associated with BB.  Passing a separate BB is useful if INSN has not\n+   been emitted yet or if we are considering moving it to a different\n+   block.  */\n+\n+alternative_mask\n+get_preferred_alternatives (rtx_insn *insn, basic_block bb)\n+{\n+  if (optimize_bb_for_speed_p (bb))\n+    return get_bool_attr_mask (insn, BA_PREFERRED_FOR_SPEED);\n+  else\n+    return get_bool_attr_mask (insn, BA_PREFERRED_FOR_SIZE);\n+}\n+\n /* Assert that the cached boolean attributes for INSN are still accurate.\n    The backend is required to define these attributes in a way that only\n    depends on the current target (rather than operands, compiler phase,\n@@ -2204,7 +2220,7 @@ void\n extract_constrain_insn (rtx_insn *insn)\n {\n   extract_insn (insn);\n-  if (!constrain_operands (reload_completed))\n+  if (!constrain_operands (reload_completed, get_enabled_alternatives (insn)))\n     fatal_insn_not_found (insn);\n }\n \n@@ -2215,16 +2231,17 @@ extract_constrain_insn_cached (rtx_insn *insn)\n {\n   extract_insn_cached (insn);\n   if (which_alternative == -1\n-      && !constrain_operands (reload_completed))\n+      && !constrain_operands (reload_completed,\n+\t\t\t      get_enabled_alternatives (insn)))\n     fatal_insn_not_found (insn);\n }\n \n-/* Do cached constrain_operands and complain about failures.  */\n+/* Do cached constrain_operands on INSN and complain about failures.  */\n int\n-constrain_operands_cached (int strict)\n+constrain_operands_cached (rtx_insn *insn, int strict)\n {\n   if (which_alternative == -1)\n-    return constrain_operands (strict);\n+    return constrain_operands (strict, get_enabled_alternatives (insn));\n   else\n     return 1;\n }\n@@ -2500,7 +2517,8 @@ preprocess_constraints (rtx insn)\n }\n \n /* Check the operands of an insn against the insn's operand constraints\n-   and return 1 if they are valid.\n+   and return 1 if they match any of the alternatives in ALTERNATIVES.\n+\n    The information about the insn's operands, constraints, operand modes\n    etc. is obtained from the global variables set up by extract_insn.\n \n@@ -2532,7 +2550,7 @@ struct funny_match\n };\n \n int\n-constrain_operands (int strict)\n+constrain_operands (int strict, alternative_mask alternatives)\n {\n   const char *constraints[MAX_RECOG_OPERANDS];\n   int matching_operands[MAX_RECOG_OPERANDS];\n@@ -2559,7 +2577,7 @@ constrain_operands (int strict)\n       int lose = 0;\n       funny_match_index = 0;\n \n-      if (!TEST_BIT (recog_data.enabled_alternatives, which_alternative))\n+      if (!TEST_BIT (alternatives, which_alternative))\n \t{\n \t  int i;\n \n@@ -2841,7 +2859,7 @@ constrain_operands (int strict)\n   /* If we are about to reject this, but we are not to test strictly,\n      try a very loose test.  Only return failure if it fails also.  */\n   if (strict == 0)\n-    return constrain_operands (-1);\n+    return constrain_operands (-1, alternatives);\n   else\n     return 0;\n }"}, {"sha": "c91f661ad566b2471115d8e52ed9f6d5cc85611c", "filename": "gcc/recog.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -95,8 +95,8 @@ extern void confirm_change_group (void);\n extern int apply_change_group (void);\n extern int num_validated_changes (void);\n extern void cancel_changes (int);\n-extern int constrain_operands (int);\n-extern int constrain_operands_cached (int);\n+extern int constrain_operands (int, alternative_mask);\n+extern int constrain_operands_cached (rtx_insn *, int);\n extern int memory_address_addr_space_p (enum machine_mode, rtx, addr_space_t);\n #define memory_address_p(mode,addr) \\\n \tmemory_address_addr_space_p ((mode), (addr), ADDR_SPACE_GENERIC)\n@@ -414,6 +414,7 @@ extern struct target_recog *this_target_recog;\n \n alternative_mask get_enabled_alternatives (rtx_insn *);\n alternative_mask get_preferred_alternatives (rtx_insn *);\n+alternative_mask get_preferred_alternatives (rtx_insn *, basic_block);\n bool check_bool_attrs (rtx_insn *);\n \n void recog_init ();"}, {"sha": "30a975c9e81f99d748078b9febe6c4a96a6f0d61", "filename": "gcc/ree.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -767,7 +767,8 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n \t This is merely to keep the test for safety and updating the insn\n \t stream simple.  Also ensure that within the block the candidate\n \t follows the defining insn.  */\n-      if (BLOCK_FOR_INSN (cand->insn) != BLOCK_FOR_INSN (def_insn)\n+      basic_block bb = BLOCK_FOR_INSN (cand->insn);\n+      if (bb != BLOCK_FOR_INSN (def_insn)\n \t  || DF_INSN_LUID (def_insn) > DF_INSN_LUID (cand->insn))\n \treturn false;\n \n@@ -817,7 +818,7 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n       if (recog_memoized (insn) == -1)\n \treturn false;\n       extract_insn (insn);\n-      if (!constrain_operands (1))\n+      if (!constrain_operands (1, get_preferred_alternatives (insn, bb)))\n \treturn false;\n     }\n "}, {"sha": "b8da67db3a2a1a78c6ef257b04b8a85e1d431ab8", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -918,7 +918,7 @@ can_reload_into (rtx in, int regno, enum machine_mode mode)\n   if (recog_memoized (test_insn) >= 0)\n     {\n       extract_insn (test_insn);\n-      r = constrain_operands (1);\n+      r = constrain_operands (1, get_enabled_alternatives (test_insn));\n     }\n   recog_data = save_recog_data;\n   return r;"}, {"sha": "74dee444196f834ab9e0be3afa87cf6182610dcc", "filename": "gcc/reload1.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -1261,7 +1261,7 @@ reload (rtx_insn *first, int global)\n \tif (asm_noperands (PATTERN (insn)) >= 0)\n \t  {\n \t    extract_insn (insn);\n-\t    if (!constrain_operands (1))\n+\t    if (!constrain_operands (1, get_enabled_alternatives (insn)))\n \t      {\n \t\terror_for_asm (insn,\n \t\t\t       \"%<asm%> operand has impossible constraints\");\n@@ -4713,7 +4713,9 @@ reload_as_needed (int live_known)\n \t\t  if (p != insn && INSN_P (p)\n \t\t      && GET_CODE (PATTERN (p)) != USE\n \t\t      && (recog_memoized (p) < 0\n-\t\t\t  || (extract_insn (p), ! constrain_operands (1))))\n+\t\t\t  || (extract_insn (p),\n+\t\t\t      !(constrain_operands (1,\n+\t\t\t\t  get_enabled_alternatives (p))))))\n \t\t    {\n \t\t      error_for_asm (insn,\n \t\t\t\t     \"%<asm%> operand requires \"\n@@ -4796,7 +4798,8 @@ reload_as_needed (int live_known)\n \t\t\t      if (n)\n \t\t\t\t{\n \t\t\t\t  extract_insn (p);\n-\t\t\t\t  n = constrain_operands (1);\n+\t\t\t\t  n = constrain_operands (1,\n+\t\t\t\t    get_enabled_alternatives (p));\n \t\t\t\t}\n \n \t\t\t      /* If the constraints were not met, then\n@@ -5723,7 +5726,7 @@ gen_reload_chain_without_interm_reg_p (int r1, int r2)\n \t  /* We want constrain operands to treat this insn strictly in\n \t     its validity determination, i.e., the way it would after\n \t     reload has completed.  */\n-\t  result = constrain_operands (1);\n+\t  result = constrain_operands (1, get_enabled_alternatives (insn));\n \t}\n \n       delete_insns_since (last);\n@@ -7393,7 +7396,7 @@ emit_input_reload_insns (struct insn_chain *chain, struct reload *rl,\n \t     autoincrement addressing mode, then the resulting insn\n \t     is ill-formed and we must reject this optimization.  */\n \t  extract_insn (temp);\n-\t  if (constrain_operands (1)\n+\t  if (constrain_operands (1, get_enabled_alternatives (temp))\n #ifdef AUTO_INC_DEC\n \t      && ! find_reg_note (temp, REG_INC, reloadreg)\n #endif\n@@ -8580,7 +8583,7 @@ emit_insn_if_valid_for_reload (rtx pat)\n       /* We want constrain operands to treat this insn strictly in its\n \t validity determination, i.e., the way it would after reload has\n \t completed.  */\n-      if (constrain_operands (1))\n+      if (constrain_operands (1, get_enabled_alternatives (insn)))\n \treturn insn;\n     }\n \n@@ -9217,7 +9220,7 @@ inc_for_reload (rtx reloadreg, rtx in, rtx value, int inc_amount)\n       if (code >= 0)\n \t{\n \t  extract_insn (add_insn);\n-\t  if (constrain_operands (1))\n+\t  if (constrain_operands (1, get_enabled_alternatives (add_insn)))\n \t    {\n \t      /* If this is a pre-increment and we have incremented the value\n \t\t where it lives, copy the incremented value to RELOADREG to"}, {"sha": "8d69433e1048e598ae3197c3e8f35978ac139231", "filename": "gcc/reorg.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daca1a96afae35e1a2f39b91f014c2f414f70c5f/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=daca1a96afae35e1a2f39b91f014c2f414f70c5f", "patch": "@@ -2769,7 +2769,8 @@ fill_slots_from_thread (rtx_insn *insn, rtx condition, rtx thread_or_return,\n \t\t\t\t   insn);\n \n \t  if (recog_memoized (ninsn) < 0\n-\t      || (extract_insn (ninsn), ! constrain_operands (1)))\n+\t      || (extract_insn (ninsn),\n+\t\t  !constrain_operands (1, get_preferred_alternatives (ninsn))))\n \t    {\n \t      delete_related_insns (ninsn);\n \t      return 0;"}]}