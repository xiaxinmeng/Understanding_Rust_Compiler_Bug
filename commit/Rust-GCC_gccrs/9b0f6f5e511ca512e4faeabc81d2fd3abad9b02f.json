{"sha": "9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWIwZjZmNWU1MTFjYTUxMmU0ZmFlYWJjODFkMmZkM2FiYWQ5YjAyZg==", "commit": {"author": {"name": "Nick Clifton", "email": "nickc@redhat.com", "date": "2011-08-12T16:26:11Z"}, "committer": {"name": "Nick Clifton", "email": "nickc@gcc.gnu.org", "date": "2011-08-12T16:26:11Z"}, "message": "builtins.c (expand_builtin_memcmp): Do not use cmpstrnsi pattern.\n\n\t* builtins.c (expand_builtin_memcmp): Do not use cmpstrnsi\n\tpattern.\n\t* doc/md.texi (cmpstrn): Note that the comparison stops if both\n\tfetched bytes are zero.\n\t(cmpstr): Likewise.\n\t(cmpmem): Note that the comparison does not stop if both of the\n\tfetched bytes are zero.\n\nFrom-SVN: r177701", "tree": {"sha": "a50ea2c82520d1f93b27686bceb3419f587bb2c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a50ea2c82520d1f93b27686bceb3419f587bb2c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f/comments", "author": {"login": "nickclifton", "id": 31441682, "node_id": "MDQ6VXNlcjMxNDQxNjgy", "avatar_url": "https://avatars.githubusercontent.com/u/31441682?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nickclifton", "html_url": "https://github.com/nickclifton", "followers_url": "https://api.github.com/users/nickclifton/followers", "following_url": "https://api.github.com/users/nickclifton/following{/other_user}", "gists_url": "https://api.github.com/users/nickclifton/gists{/gist_id}", "starred_url": "https://api.github.com/users/nickclifton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nickclifton/subscriptions", "organizations_url": "https://api.github.com/users/nickclifton/orgs", "repos_url": "https://api.github.com/users/nickclifton/repos", "events_url": "https://api.github.com/users/nickclifton/events{/privacy}", "received_events_url": "https://api.github.com/users/nickclifton/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c49b1a299e4be73819e3f12394eeb2681057e8fc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c49b1a299e4be73819e3f12394eeb2681057e8fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c49b1a299e4be73819e3f12394eeb2681057e8fc"}], "stats": {"total": 56, "additions": 29, "deletions": 27}, "files": [{"sha": "de9fb5e66c8f2f9d49b3081c59943865f5d5cb72", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f", "patch": "@@ -1,3 +1,13 @@\n+2011-08-12  Nick Clifton  <nickc@redhat.com>\n+\n+\t* builtins.c (expand_builtin_memcmp): Do not use cmpstrnsi\n+\tpattern.\n+\t* doc/md.texi (cmpstrn): Note that the comparison stops if both\n+\tfetched bytes are zero.\n+\t(cmpstr): Likewise.\n+\t(cmpmem): Note that the comparison does not stop if both of the\n+\tfetched bytes are zero.\n+\n 2011-08-12  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* builtins.def (BUILT_IN_ICEIL{,F,L}, BUILT_IN_IFLOOR{,F,L}"}, {"sha": "e0afc908d5af93a94fe816e6c9fc2e9dce1add79", "filename": "gcc/builtins.c", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f", "patch": "@@ -3635,9 +3635,9 @@ expand_builtin_bzero (tree exp)\n }\n \n /* Expand expression EXP, which is a call to the memcmp built-in function.\n-   Return NULL_RTX if we failed and the\n-   caller should emit a normal call, otherwise try to get the result in\n-   TARGET, if convenient (and in mode MODE, if that's convenient).  */\n+   Return NULL_RTX if we failed and the caller should emit a normal call,\n+   otherwise try to get the result in TARGET, if convenient (and in mode\n+   MODE, if that's convenient).  */\n \n static rtx\n expand_builtin_memcmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n@@ -3649,7 +3649,10 @@ expand_builtin_memcmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n  \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return NULL_RTX;\n \n-#if defined HAVE_cmpmemsi || defined HAVE_cmpstrnsi\n+  /* Note: The cmpstrnsi pattern, if it exists, is not suitable for\n+     implementing memcmp because it will stop if it encounters two\n+     zero bytes.  */\n+#if defined HAVE_cmpmemsi\n   {\n     rtx arg1_rtx, arg2_rtx, arg3_rtx;\n     rtx result;\n@@ -3662,16 +3665,9 @@ expand_builtin_memcmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n     unsigned int arg2_align = get_pointer_alignment (arg2) / BITS_PER_UNIT;\n     enum machine_mode insn_mode;\n \n-#ifdef HAVE_cmpmemsi\n     if (HAVE_cmpmemsi)\n       insn_mode = insn_data[(int) CODE_FOR_cmpmemsi].operand[0].mode;\n     else\n-#endif\n-#ifdef HAVE_cmpstrnsi\n-    if (HAVE_cmpstrnsi)\n-      insn_mode = insn_data[(int) CODE_FOR_cmpstrnsi].operand[0].mode;\n-    else\n-#endif\n       return NULL_RTX;\n \n     /* If we don't have POINTER_TYPE, call the function.  */\n@@ -3696,18 +3692,10 @@ expand_builtin_memcmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n \tset_mem_size (arg2_rtx, INTVAL (arg3_rtx));\n       }\n \n-#ifdef HAVE_cmpmemsi\n     if (HAVE_cmpmemsi)\n       insn = gen_cmpmemsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n \t\t\t   GEN_INT (MIN (arg1_align, arg2_align)));\n     else\n-#endif\n-#ifdef HAVE_cmpstrnsi\n-    if (HAVE_cmpstrnsi)\n-      insn = gen_cmpstrnsi (result, arg1_rtx, arg2_rtx, arg3_rtx,\n-\t\t\t    GEN_INT (MIN (arg1_align, arg2_align)));\n-    else\n-#endif\n       gcc_unreachable ();\n \n     if (insn)\n@@ -3733,7 +3721,7 @@ expand_builtin_memcmp (tree exp, ATTRIBUTE_UNUSED rtx target,\n     else\n       return convert_to_mode (mode, result, 0);\n   }\n-#endif\n+#endif /* HAVE_cmpmemsi.  */\n \n   return NULL_RTX;\n }"}, {"sha": "0bd9ecdd1674ca4bd3671b4b35ca84d37adf33d7", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=9b0f6f5e511ca512e4faeabc81d2fd3abad9b02f", "patch": "@@ -4680,8 +4680,9 @@ byte by byte in lexicographic order starting at the beginning of each\n string.  The instruction is not allowed to prefetch more than one byte\n at a time since either string may end in the first byte and reading past\n that may access an invalid page or segment and cause a fault.  The\n-effect of the instruction is to store a value in operand 0 whose sign\n-indicates the result of the comparison.\n+comparison terminates early if the fetched bytes are different or if\n+they are equal to zero.  The effect of the instruction is to store a\n+value in operand 0 whose sign indicates the result of the comparison.\n \n @cindex @code{cmpstr@var{m}} instruction pattern\n @item @samp{cmpstr@var{m}}\n@@ -4699,18 +4700,21 @@ The two memory blocks specified are compared byte by byte in lexicographic\n order starting at the beginning of each string.  The instruction is not allowed\n to prefetch more than one byte at a time since either string may end in the\n first byte and reading past that may access an invalid page or segment and\n-cause a fault.  The effect of the instruction is to store a value in operand 0\n-whose sign indicates the result of the comparison.\n+cause a fault.  The comparison will terminate when the fetched bytes\n+are different or if they are equal to zero.  The effect of the\n+instruction is to store a value in operand 0 whose sign indicates the\n+result of the comparison.\n \n @cindex @code{cmpmem@var{m}} instruction pattern\n @item @samp{cmpmem@var{m}}\n Block compare instruction, with five operands like the operands\n of @samp{cmpstr@var{m}}.  The two memory blocks specified are compared\n byte by byte in lexicographic order starting at the beginning of each\n block.  Unlike @samp{cmpstr@var{m}} the instruction can prefetch\n-any bytes in the two memory blocks.  The effect of the instruction is\n-to store a value in operand 0 whose sign indicates the result of the\n-comparison.\n+any bytes in the two memory blocks.  Also unlike @samp{cmpstr@var{m}}\n+the comparison will not stop if both bytes are zero.  The effect of\n+the instruction is to store a value in operand 0 whose sign indicates\n+the result of the comparison.\n \n @cindex @code{strlen@var{m}} instruction pattern\n @item @samp{strlen@var{m}}"}]}