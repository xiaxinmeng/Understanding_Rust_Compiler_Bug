{"sha": "a6b3dfde4c29fda63839bcac6cc9377d42704507", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZiM2RmZGU0YzI5ZmRhNjM4MzliY2FjNmNjOTM3N2Q0MjcwNDUwNw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-10-25T21:29:56Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-10-25T21:29:56Z"}, "message": "Implement interleave via permutation.\n\n        * expr.c (expand_expr_real_2) [VEC_EXTRACT_EVEN_EXPR]: Use binop.\n        [VEC_EXTRACT_ODD_EXPR, VEC_INTERLEAVE_HIGH_EXPR]: Likewise.\n        [VEC_INTERLEAVE_LOW_EXPR]: Likewise.\n        * optabs.c (expand_binop): Implement vec_interleave_high_optab,\n        vec_interleave_low_optab, vec_extract_even_optab,\n        vec_extract_odd_optab with expand_vec_perm.\n        (can_vec_perm_for_code_p): New.\n        * optabs.h: Update.\n        * tree-vect-data-refs.c (vect_strided_store_supported): Allow for\n        fallback via can_vec_perm_for_code_p.\n        (vect_strided_load_supported): Likewise.\n        * tree-vect-generic.c (expand_vector_operations_1): Never lower\n        VEC_INTERLEAVE_HIGH_EXPR, VEC_INTERLEAVE_LOW_EXPR,\n        VEC_EXTRACT_EVEN_EXPR, VEC_EXTRACT_ODD_EXPR.\n\nFrom-SVN: r180450", "tree": {"sha": "45f2e4d1399a268bc62cbc1f51000ceee9bcc2b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/45f2e4d1399a268bc62cbc1f51000ceee9bcc2b1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6b3dfde4c29fda63839bcac6cc9377d42704507", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b3dfde4c29fda63839bcac6cc9377d42704507", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6b3dfde4c29fda63839bcac6cc9377d42704507", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6b3dfde4c29fda63839bcac6cc9377d42704507/comments", "author": null, "committer": null, "parents": [{"sha": "22e4dee74f73108b7dda295f6999276be12b7568", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22e4dee74f73108b7dda295f6999276be12b7568", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22e4dee74f73108b7dda295f6999276be12b7568"}], "stats": {"total": 243, "additions": 174, "deletions": 69}, "files": [{"sha": "33cbeaf1e9031198ae17cbbd36b174d3ded3245c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6b3dfde4c29fda63839bcac6cc9377d42704507", "patch": "@@ -1,5 +1,20 @@\n 2011-10-25  Richard Henderson  <rth@redhat.com>\n \n+\t* expr.c (expand_expr_real_2) [VEC_EXTRACT_EVEN_EXPR]: Use binop.\n+\t[VEC_EXTRACT_ODD_EXPR, VEC_INTERLEAVE_HIGH_EXPR]: Likewise.\n+\t[VEC_INTERLEAVE_LOW_EXPR]: Likewise.\n+\t* optabs.c (expand_binop): Implement vec_interleave_high_optab,\n+\tvec_interleave_low_optab, vec_extract_even_optab,\n+\tvec_extract_odd_optab with expand_vec_perm.\n+\t(can_vec_perm_for_code_p): New.\n+\t* optabs.h: Update.\n+\t* tree-vect-data-refs.c (vect_strided_store_supported): Allow for\n+\tfallback via can_vec_perm_for_code_p.\n+\t(vect_strided_load_supported): Likewise.\n+\t* tree-vect-generic.c (expand_vector_operations_1): Never lower\n+\tVEC_INTERLEAVE_HIGH_EXPR, VEC_INTERLEAVE_LOW_EXPR,\n+\tVEC_EXTRACT_EVEN_EXPR, VEC_EXTRACT_ODD_EXPR.\n+\n \t* target.def (vec_perm_const_ok): Change parameters to mode and\n \tarray of indicies.\n \t* doc/tm.texi: Rebuild."}, {"sha": "84cfe5c23ee230ed15846f39f1cf9034ad4b14a0", "filename": "gcc/expr.c", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a6b3dfde4c29fda63839bcac6cc9377d42704507", "patch": "@@ -8667,27 +8667,9 @@ expand_expr_real_2 (sepops ops, rtx target, enum machine_mode tmode,\n \n     case VEC_EXTRACT_EVEN_EXPR:\n     case VEC_EXTRACT_ODD_EXPR:\n-      {\n-        expand_operands (treeop0,  treeop1,\n-                         NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n-        this_optab = optab_for_tree_code (code, type, optab_default);\n-        temp = expand_binop (mode, this_optab, op0, op1, target, unsignedp,\n-                             OPTAB_WIDEN);\n-        gcc_assert (temp);\n-        return temp;\n-      }\n-\n     case VEC_INTERLEAVE_HIGH_EXPR:\n     case VEC_INTERLEAVE_LOW_EXPR:\n-      {\n-        expand_operands (treeop0,  treeop1,\n-                         NULL_RTX, &op0, &op1, EXPAND_NORMAL);\n-        this_optab = optab_for_tree_code (code, type, optab_default);\n-        temp = expand_binop (mode, this_optab, op0, op1, target, unsignedp,\n-                             OPTAB_WIDEN);\n-        gcc_assert (temp);\n-        return temp;\n-      }\n+      goto binop;\n \n     case VEC_LSHIFT_EXPR:\n     case VEC_RSHIFT_EXPR:"}, {"sha": "9afc91139da108648baae059b0b0d6b7e5738ecb", "filename": "gcc/optabs.c", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=a6b3dfde4c29fda63839bcac6cc9377d42704507", "patch": "@@ -1606,6 +1606,30 @@ expand_binop (enum machine_mode mode, optab binoptab, rtx op0, rtx op1,\n \t}\n     }\n \n+  /* Certain vector operations can be implemented with vector permutation.  */\n+  if (VECTOR_MODE_P (mode))\n+    {\n+      enum tree_code tcode = ERROR_MARK;\n+      rtx sel;\n+\n+      if (binoptab == vec_interleave_high_optab)\n+\ttcode = VEC_INTERLEAVE_HIGH_EXPR;\n+      else if (binoptab == vec_interleave_low_optab)\n+\ttcode = VEC_INTERLEAVE_LOW_EXPR;\n+      else if (binoptab == vec_extract_even_optab)\n+\ttcode = VEC_EXTRACT_EVEN_EXPR;\n+      else if (binoptab == vec_extract_odd_optab)\n+\ttcode = VEC_EXTRACT_ODD_EXPR;\n+\n+      if (tcode != ERROR_MARK\n+\t  && can_vec_perm_for_code_p (tcode, mode, &sel))\n+\t{\n+\t  temp = expand_vec_perm (mode, op0, op1, sel, target);\n+\t  gcc_assert (temp != NULL);\n+\t  return temp;\n+\t}\n+    }\n+\n   /* Look for a wider mode of the same class for which we think we\n      can open-code the operation.  Check for a widening multiply at the\n      wider mode as well.  */\n@@ -6751,6 +6775,98 @@ can_vec_perm_p (enum machine_mode mode, bool variable,\n   return true;\n }\n \n+/* Return true if we can implement VEC_INTERLEAVE_{HIGH,LOW}_EXPR or\n+   VEC_EXTRACT_{EVEN,ODD}_EXPR with VEC_PERM_EXPR for this target.\n+   If PSEL is non-null, return the selector for the permutation.  */\n+\n+bool\n+can_vec_perm_for_code_p (enum tree_code code, enum machine_mode mode,\n+\t\t\t rtx *psel)\n+{\n+  bool need_sel_test = false;\n+  enum insn_code icode;\n+\n+  /* If the target doesn't implement a vector mode for the vector type,\n+     then no operations are supported.  */\n+  if (!VECTOR_MODE_P (mode))\n+    return false;\n+\n+  /* Do as many tests as possible without reqiring the selector.  */\n+  icode = direct_optab_handler (vec_perm_optab, mode);\n+  if (icode == CODE_FOR_nothing && GET_MODE_INNER (mode) != QImode)\n+    {\n+      enum machine_mode qimode\n+\t= mode_for_vector (QImode, GET_MODE_SIZE (mode));\n+      if (VECTOR_MODE_P (qimode))\n+\ticode = direct_optab_handler (vec_perm_optab, qimode);\n+    }\n+  if (icode == CODE_FOR_nothing)\n+    {\n+      icode = direct_optab_handler (vec_perm_const_optab, mode);\n+      if (icode != CODE_FOR_nothing\n+\t  && targetm.vectorize.vec_perm_const_ok != NULL)\n+\tneed_sel_test = true;\n+    }\n+  if (icode == CODE_FOR_nothing)\n+    return false;\n+\n+  /* If the selector is required, or if we need to test it, build it.  */\n+  if (psel || need_sel_test)\n+    {\n+      int i, nelt = GET_MODE_NUNITS (mode), alt = 0;\n+      unsigned char *data = XALLOCAVEC (unsigned char, nelt);\n+\n+      switch (code)\n+\t{\n+\tcase VEC_EXTRACT_ODD_EXPR:\n+\t  alt = 1;\n+\t  /* FALLTHRU */\n+\tcase VEC_EXTRACT_EVEN_EXPR:\n+\t  for (i = 0; i < nelt; ++i)\n+\t    data[i] = i * 2 + alt;\n+\t  break;\n+\n+\tcase VEC_INTERLEAVE_HIGH_EXPR:\n+\t  alt = nelt / 2;\n+\t  /* FALLTHRU */\n+\tcase VEC_INTERLEAVE_LOW_EXPR:\n+\t  for (i = 0; i < nelt / 2; ++i)\n+\t    {\n+\t      data[i * 2] = i + alt;\n+\t      data[i * 2 + 1] = i + nelt + alt;\n+\t    }\n+\t  break;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+\n+      if (need_sel_test\n+\t  && !targetm.vectorize.vec_perm_const_ok (mode, data))\n+\treturn false;\n+\n+      if (psel)\n+\t{\n+\t  rtvec vec = rtvec_alloc (nelt);\n+\t  enum machine_mode imode = mode;\n+\n+\t  for (i = 0; i < nelt; ++i)\n+\t    RTVEC_ELT (vec, i) = GEN_INT (data[i]);\n+\n+\t  if (GET_MODE_CLASS (mode) != MODE_VECTOR_INT)\n+\t    {\n+\t      imode = int_mode_for_mode (GET_MODE_INNER (mode));\n+\t      imode = mode_for_vector (imode, nelt);\n+\t      gcc_assert (GET_MODE_CLASS (imode) == MODE_VECTOR_INT);\n+\t    }\n+\n+\t  *psel = gen_rtx_CONST_VECTOR (imode, vec);\n+\t}\n+    }\n+\n+  return true;\n+}\n+\n /* A subroutine of expand_vec_perm for expanding one vec_perm insn.  */\n \n static rtx"}, {"sha": "057f6533ad161f52e8ba264b384e9a03cd878f93", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=a6b3dfde4c29fda63839bcac6cc9377d42704507", "patch": "@@ -903,6 +903,9 @@ extern rtx expand_vec_shift_expr (sepops, rtx);\n /* Return tree if target supports vector operations for VEC_PERM_EXPR.  */\n extern bool can_vec_perm_p (enum machine_mode, bool, const unsigned char *);\n \n+/* Return true if target supports vector operations using VEC_PERM_EXPR.  */\n+extern bool can_vec_perm_for_code_p (enum tree_code, enum machine_mode, rtx *);\n+\n /* Generate code for VEC_PERM_EXPR.  */\n extern rtx expand_vec_perm (enum machine_mode, rtx, rtx, rtx, rtx);\n "}, {"sha": "a239216cf2df38a697bc647c1946ec8ea79e4e05", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 30, "deletions": 50, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=a6b3dfde4c29fda63839bcac6cc9377d42704507", "patch": "@@ -3467,7 +3467,7 @@ vect_create_destination_var (tree scalar_dest, tree vectype)\n bool\n vect_strided_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n {\n-  optab interleave_high_optab, interleave_low_optab;\n+  optab ih_optab, il_optab;\n   enum machine_mode mode;\n \n   mode = TYPE_MODE (vectype);\n@@ -3482,26 +3482,22 @@ vect_strided_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n     }\n \n   /* Check that the operation is supported.  */\n-  interleave_high_optab = optab_for_tree_code (VEC_INTERLEAVE_HIGH_EXPR,\n-\t\t\t\t\t       vectype, optab_default);\n-  interleave_low_optab = optab_for_tree_code (VEC_INTERLEAVE_LOW_EXPR,\n-\t\t\t\t\t      vectype, optab_default);\n-  if (!interleave_high_optab || !interleave_low_optab)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"no optab for interleave.\");\n-      return false;\n-    }\n+  ih_optab = optab_for_tree_code (VEC_INTERLEAVE_HIGH_EXPR,\n+\t\t\t\t  vectype, optab_default);\n+  il_optab = optab_for_tree_code (VEC_INTERLEAVE_LOW_EXPR,\n+\t\t\t\t  vectype, optab_default);\n+  if (il_optab && ih_optab\n+      && optab_handler (ih_optab, mode) != CODE_FOR_nothing\n+      && optab_handler (il_optab, mode) != CODE_FOR_nothing)\n+    return true;\n \n-  if (optab_handler (interleave_high_optab, mode) == CODE_FOR_nothing\n-      || optab_handler (interleave_low_optab, mode) == CODE_FOR_nothing)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"interleave op not supported by target.\");\n-      return false;\n-    }\n+  if (can_vec_perm_for_code_p (VEC_INTERLEAVE_HIGH_EXPR, mode, NULL)\n+      && can_vec_perm_for_code_p (VEC_INTERLEAVE_LOW_EXPR, mode, NULL))\n+    return true;\n \n-  return true;\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"interleave op not supported by target.\");\n+  return false;\n }\n \n \n@@ -3923,7 +3919,7 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n bool\n vect_strided_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n {\n-  optab perm_even_optab, perm_odd_optab;\n+  optab ee_optab, eo_optab;\n   enum machine_mode mode;\n \n   mode = TYPE_MODE (vectype);\n@@ -3937,38 +3933,22 @@ vect_strided_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n       return false;\n     }\n \n-  perm_even_optab = optab_for_tree_code (VEC_EXTRACT_EVEN_EXPR, vectype,\n-\t\t\t\t\t optab_default);\n-  if (!perm_even_optab)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"no optab for perm_even.\");\n-      return false;\n-    }\n-\n-  if (optab_handler (perm_even_optab, mode) == CODE_FOR_nothing)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"perm_even op not supported by target.\");\n-      return false;\n-    }\n+  ee_optab = optab_for_tree_code (VEC_EXTRACT_EVEN_EXPR,\n+\t\t\t\t  vectype, optab_default);\n+  eo_optab = optab_for_tree_code (VEC_EXTRACT_ODD_EXPR,\n+\t\t\t\t  vectype, optab_default);\n+  if (ee_optab && eo_optab\n+      && optab_handler (ee_optab, mode) != CODE_FOR_nothing\n+      && optab_handler (eo_optab, mode) != CODE_FOR_nothing)\n+    return true;\n \n-  perm_odd_optab = optab_for_tree_code (VEC_EXTRACT_ODD_EXPR, vectype,\n-\t\t\t\t\toptab_default);\n-  if (!perm_odd_optab)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"no optab for perm_odd.\");\n-      return false;\n-    }\n+  if (can_vec_perm_for_code_p (VEC_EXTRACT_EVEN_EXPR, mode, NULL)\n+      && can_vec_perm_for_code_p (VEC_EXTRACT_ODD_EXPR, mode, NULL))\n+    return true;\n \n-  if (optab_handler (perm_odd_optab, mode) == CODE_FOR_nothing)\n-    {\n-      if (vect_print_dump_info (REPORT_DETAILS))\n-\tfprintf (vect_dump, \"perm_odd op not supported by target.\");\n-      return false;\n-    }\n-  return true;\n+  if (vect_print_dump_info (REPORT_DETAILS))\n+    fprintf (vect_dump, \"extract even/odd not supported by target\");\n+  return false;\n }\n \n /* Return TRUE if vec_load_lanes is available for COUNT vectors of"}, {"sha": "ccbec6ebac67d795a44e8ba5314a0f63ba6f46c3", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6b3dfde4c29fda63839bcac6cc9377d42704507/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=a6b3dfde4c29fda63839bcac6cc9377d42704507", "patch": "@@ -771,6 +771,15 @@ expand_vector_operations_1 (gimple_stmt_iterator *gsi)\n       || code == VIEW_CONVERT_EXPR)\n     return;\n \n+  /* These are only created by the vectorizer, after having queried\n+     the target support.  It's more than just looking at the optab,\n+     and there's no need to do it again.  */\n+  if (code == VEC_INTERLEAVE_HIGH_EXPR\n+      || code == VEC_INTERLEAVE_LOW_EXPR\n+      || code == VEC_EXTRACT_EVEN_EXPR\n+      || code == VEC_EXTRACT_ODD_EXPR)\n+    return;\n+\n   gcc_assert (code != CONVERT_EXPR);\n \n   /* The signedness is determined from input argument.  */"}]}