{"sha": "8d689cf43b501a2f5c077389adbb6d2bfa530ca9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ2ODljZjQzYjUwMWEyZjVjMDc3Mzg5YWRiYjZkMmJmYTUzMGNhOQ==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-03-27T09:51:12Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-03-27T11:02:32Z"}, "message": "Fix PR90332 by extending half size vector mode\n\nAs PR90332 shows, the current scalar epilogue peeling for gaps\nelimination requires expected vec_init optab with two half size\nvector mode.  On Power, we don't support vector mode like V8QI,\nso can't support optab like vec_initv16qiv8qi.  But we want to\nleverage existing scalar mode like DI to init the desirable\nvector mode.  This patch is to extend the existing support for\nPower, as evaluated on Power9 we can see expected 1.9% speed up\non SPEC2017 525.x264_r.\n\nAs Richi suggested, add one function vector_vector_composition_type\nto refactor existing related codes and also make use of it further.\n\nBootstrapped/regtested on powerpc64le-linux-gnu (LE) P8 and P9,\nas well as x86_64-redhat-linux.\n\ngcc/ChangeLog\n\n2020-03-27  Kewen Lin  <linkw@gcc.gnu.org>\n\n    PR tree-optimization/90332\n    * tree-vect-stmts.c (vector_vector_composition_type): New function.\n    (get_group_load_store_type): Adjust to call vector_vector_composition_type,\n    extend it to construct with scalar types.\n    (vectorizable_load): Likewise.", "tree": {"sha": "ff7446b65f9c5402da5ffdd6d26d2008aeaa4f05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff7446b65f9c5402da5ffdd6d26d2008aeaa4f05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d689cf43b501a2f5c077389adbb6d2bfa530ca9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d689cf43b501a2f5c077389adbb6d2bfa530ca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d689cf43b501a2f5c077389adbb6d2bfa530ca9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d689cf43b501a2f5c077389adbb6d2bfa530ca9/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66e0e23c12d143c8caf787d95ff356f009b1fca9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66e0e23c12d143c8caf787d95ff356f009b1fca9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66e0e23c12d143c8caf787d95ff356f009b1fca9"}], "stats": {"total": 161, "additions": 107, "deletions": 54}, "files": [{"sha": "bf7204f82dfc7ad278855a205a0c213116253510", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d689cf43b501a2f5c077389adbb6d2bfa530ca9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d689cf43b501a2f5c077389adbb6d2bfa530ca9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8d689cf43b501a2f5c077389adbb6d2bfa530ca9", "patch": "@@ -1,3 +1,12 @@\n+2020-03-27  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\tPR tree-optimization/90332\n+\t* tree-vect-stmts.c (vector_vector_composition_type): New function.\n+\t(get_group_load_store_type): Adjust to call\n+\tvector_vector_composition_type, extend it to construct with scalar\n+\ttypes.\n+\t(vectorizable_load): Likewise.\n+\n 2020-03-27  Roman Zhuykov  <zhroma@ispras.ru>\n \n \t* ddg.c (create_ddg_dep_from_intra_loop_link): Remove assertions."}, {"sha": "12beef6978c81d52c65bd85d46ac7a5e556dc92e", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 98, "deletions": 54, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d689cf43b501a2f5c077389adbb6d2bfa530ca9/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d689cf43b501a2f5c077389adbb6d2bfa530ca9/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=8d689cf43b501a2f5c077389adbb6d2bfa530ca9", "patch": "@@ -2220,6 +2220,62 @@ vect_get_store_rhs (stmt_vec_info stmt_info)\n   gcc_unreachable ();\n }\n \n+/* Function VECTOR_VECTOR_COMPOSITION_TYPE\n+\n+   This function returns a vector type which can be composed with NETLS pieces,\n+   whose type is recorded in PTYPE.  VTYPE should be a vector type, and has the\n+   same vector size as the return vector.  It checks target whether supports\n+   pieces-size vector mode for construction firstly, if target fails to, check\n+   pieces-size scalar mode for construction further.  It returns NULL_TREE if\n+   fails to find the available composition.\n+\n+   For example, for (vtype=V16QI, nelts=4), we can probably get:\n+     - V16QI with PTYPE V4QI.\n+     - V4SI with PTYPE SI.\n+     - NULL_TREE.  */\n+\n+static tree\n+vector_vector_composition_type (tree vtype, poly_uint64 nelts, tree *ptype)\n+{\n+  gcc_assert (VECTOR_TYPE_P (vtype));\n+  gcc_assert (known_gt (nelts, 0U));\n+\n+  machine_mode vmode = TYPE_MODE (vtype);\n+  if (!VECTOR_MODE_P (vmode))\n+    return NULL_TREE;\n+\n+  poly_uint64 vbsize = GET_MODE_BITSIZE (vmode);\n+  unsigned int pbsize;\n+  if (constant_multiple_p (vbsize, nelts, &pbsize))\n+    {\n+      /* First check if vec_init optab supports construction from\n+\t vector pieces directly.  */\n+      scalar_mode elmode = SCALAR_TYPE_MODE (TREE_TYPE (vtype));\n+      poly_uint64 inelts = pbsize / GET_MODE_BITSIZE (elmode);\n+      machine_mode rmode;\n+      if (related_vector_mode (vmode, elmode, inelts).exists (&rmode)\n+\t  && (convert_optab_handler (vec_init_optab, vmode, rmode)\n+\t      != CODE_FOR_nothing))\n+\t{\n+\t  *ptype = build_vector_type (TREE_TYPE (vtype), inelts);\n+\t  return vtype;\n+\t}\n+\n+      /* Otherwise check if exists an integer type of the same piece size and\n+\t if vec_init optab supports construction from it directly.  */\n+      if (int_mode_for_size (pbsize, 0).exists (&elmode)\n+\t  && related_vector_mode (vmode, elmode, nelts).exists (&rmode)\n+\t  && (convert_optab_handler (vec_init_optab, rmode, elmode)\n+\t      != CODE_FOR_nothing))\n+\t{\n+\t  *ptype = build_nonstandard_integer_type (pbsize, 1);\n+\t  return build_vector_type (*ptype, nelts);\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* A subroutine of get_load_store_type, with a subset of the same\n    arguments.  Handle the case where STMT_INFO is part of a grouped load\n    or store.\n@@ -2300,8 +2356,7 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,\n \t     by simply loading half of the vector only.  Usually\n \t     the construction with an upper zero half will be elided.  */\n \t  dr_alignment_support alignment_support_scheme;\n-\t  scalar_mode elmode = SCALAR_TYPE_MODE (TREE_TYPE (vectype));\n-\t  machine_mode vmode;\n+\t  tree half_vtype;\n \t  if (overrun_p\n \t      && !masked_p\n \t      && (((alignment_support_scheme\n@@ -2310,12 +2365,8 @@ get_group_load_store_type (stmt_vec_info stmt_info, tree vectype, bool slp,\n \t\t  || alignment_support_scheme == dr_unaligned_supported)\n \t      && known_eq (nunits, (group_size - gap) * 2)\n \t      && known_eq (nunits, group_size)\n-\t      && VECTOR_MODE_P (TYPE_MODE (vectype))\n-\t      && related_vector_mode (TYPE_MODE (vectype), elmode,\n-\t\t\t\t      group_size - gap).exists (&vmode)\n-\t      && (convert_optab_handler (vec_init_optab,\n-\t\t\t\t\t TYPE_MODE (vectype), vmode)\n-\t\t  != CODE_FOR_nothing))\n+\t      && (vector_vector_composition_type (vectype, 2, &half_vtype)\n+\t\t  != NULL_TREE))\n \t    overrun_p = false;\n \n \t  if (overrun_p && !can_overrun_p)\n@@ -8915,47 +8966,24 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t{\n \t  if (group_size < const_nunits)\n \t    {\n-\t      /* First check if vec_init optab supports construction from\n-\t\t vector elts directly.  */\n-\t      scalar_mode elmode = SCALAR_TYPE_MODE (TREE_TYPE (vectype));\n-\t      machine_mode vmode;\n-\t      if (VECTOR_MODE_P (TYPE_MODE (vectype))\n-\t\t  && related_vector_mode (TYPE_MODE (vectype), elmode,\n-\t\t\t\t\t  group_size).exists (&vmode)\n-\t\t  && (convert_optab_handler (vec_init_optab,\n-\t\t\t\t\t     TYPE_MODE (vectype), vmode)\n-\t\t      != CODE_FOR_nothing))\n+\t      /* First check if vec_init optab supports construction from vector\n+\t\t elts directly.  Otherwise avoid emitting a constructor of\n+\t\t vector elements by performing the loads using an integer type\n+\t\t of the same size, constructing a vector of those and then\n+\t\t re-interpreting it as the original vector type.  This avoids a\n+\t\t huge runtime penalty due to the general inability to perform\n+\t\t store forwarding from smaller stores to a larger load.  */\n+\t      tree ptype;\n+\t      tree vtype\n+\t\t= vector_vector_composition_type (vectype,\n+\t\t\t\t\t\t  const_nunits / group_size,\n+\t\t\t\t\t\t  &ptype);\n+\t      if (vtype != NULL_TREE)\n \t\t{\n \t\t  nloads = const_nunits / group_size;\n \t\t  lnel = group_size;\n-\t\t  ltype = build_vector_type (TREE_TYPE (vectype), group_size);\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  /* Otherwise avoid emitting a constructor of vector elements\n-\t\t     by performing the loads using an integer type of the same\n-\t\t     size, constructing a vector of those and then\n-\t\t     re-interpreting it as the original vector type.\n-\t\t     This avoids a huge runtime penalty due to the general\n-\t\t     inability to perform store forwarding from smaller stores\n-\t\t     to a larger load.  */\n-\t\t  unsigned lsize\n-\t\t    = group_size * TYPE_PRECISION (TREE_TYPE (vectype));\n-\t\t  unsigned int lnunits = const_nunits / group_size;\n-\t\t  /* If we can't construct such a vector fall back to\n-\t\t     element loads of the original vector type.  */\n-\t\t  if (int_mode_for_size (lsize, 0).exists (&elmode)\n-\t\t      && VECTOR_MODE_P (TYPE_MODE (vectype))\n-\t\t      && related_vector_mode (TYPE_MODE (vectype), elmode,\n-\t\t\t\t\t      lnunits).exists (&vmode)\n-\t\t      && (convert_optab_handler (vec_init_optab, vmode, elmode)\n-\t\t\t  != CODE_FOR_nothing))\n-\t\t    {\n-\t\t      nloads = lnunits;\n-\t\t      lnel = group_size;\n-\t\t      ltype = build_nonstandard_integer_type (lsize, 1);\n-\t\t      lvectype = build_vector_type (ltype, nloads);\n-\t\t    }\n+\t\t  lvectype = vtype;\n+\t\t  ltype = ptype;\n \t\t}\n \t    }\n \t  else\n@@ -9541,6 +9569,7 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t    else\n \t\t      {\n \t\t\ttree ltype = vectype;\n+\t\t\ttree new_vtype = NULL_TREE;\n \t\t\t/* If there's no peeling for gaps but we have a gap\n \t\t\t   with slp loads then load the lower half of the\n \t\t\t   vector only.  See get_group_load_store_type for\n@@ -9553,10 +9582,14 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t\t\t (group_size\n \t\t\t\t\t  - DR_GROUP_GAP (first_stmt_info)) * 2)\n \t\t\t    && known_eq (nunits, group_size))\n-\t\t\t  ltype = build_vector_type (TREE_TYPE (vectype),\n-\t\t\t\t\t\t     (group_size\n-\t\t\t\t\t\t      - DR_GROUP_GAP\n-\t\t\t\t\t\t          (first_stmt_info)));\n+\t\t\t  {\n+\t\t\t    tree half_vtype;\n+\t\t\t    new_vtype\n+\t\t\t      = vector_vector_composition_type (vectype, 2,\n+\t\t\t\t\t\t\t\t&half_vtype);\n+\t\t\t    if (new_vtype != NULL_TREE)\n+\t\t\t      ltype = half_vtype;\n+\t\t\t  }\n \t\t\tdata_ref\n \t\t\t  = fold_build2 (MEM_REF, ltype, dataref_ptr,\n \t\t\t\t\t dataref_offset\n@@ -9584,10 +9617,21 @@ vectorizable_load (stmt_vec_info stmt_info, gimple_stmt_iterator *gsi,\n \t\t\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, tem);\n \t\t\t    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n \t\t\t\t\t\t    build_zero_cst (ltype));\n-\t\t\t    new_stmt\n-\t\t\t      = gimple_build_assign (vec_dest,\n-\t\t\t\t\t\t     build_constructor\n-\t\t\t\t\t\t       (vectype, v));\n+\t\t\t    gcc_assert (new_vtype != NULL_TREE);\n+\t\t\t    if (new_vtype == vectype)\n+\t\t\t      new_stmt = gimple_build_assign (\n+\t\t\t\tvec_dest, build_constructor (vectype, v));\n+\t\t\t    else\n+\t\t\t      {\n+\t\t\t\ttree new_vname = make_ssa_name (new_vtype);\n+\t\t\t\tnew_stmt = gimple_build_assign (\n+\t\t\t\t  new_vname, build_constructor (new_vtype, v));\n+\t\t\t\tvect_finish_stmt_generation (stmt_info,\n+\t\t\t\t\t\t\t     new_stmt, gsi);\n+\t\t\t\tnew_stmt = gimple_build_assign (\n+\t\t\t\t  vec_dest, build1 (VIEW_CONVERT_EXPR, vectype,\n+\t\t\t\t\t\t    new_vname));\n+\t\t\t      }\n \t\t\t  }\n \t\t      }\n \t\t    break;"}]}