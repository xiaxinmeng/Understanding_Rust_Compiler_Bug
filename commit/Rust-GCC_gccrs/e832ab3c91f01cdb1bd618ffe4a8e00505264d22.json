{"sha": "e832ab3c91f01cdb1bd618ffe4a8e00505264d22", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTgzMmFiM2M5MWYwMWNkYjFiZDYxOGZmZTRhOGUwMDUwNTI2NGQyMg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2002-10-03T11:23:33Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2002-10-03T11:23:33Z"}, "message": "2002-09-30  Michael Koch  <konqueror@gmx.de>\n\n\t* java/net/DatagramSocket.java\n\t(receive): Check with SecurityManager AFTER the packet is received,\n\tcheck if connected to multicast address, documentation added.\n\t(send): Only check SecurityManager if connected, check address of\n\tpacket to send.\n\t(connect): Implemented, documentation added.\n\t* java/net/Inet6Address.java: New file (not added yet to Makefile.am).\n\t* java/net/InetSocketAddress.java\n\t(whole file): Reindented.\n\t(hostname): New attribute.\n\t(InetSocketAddress): Initialize new attribute.\n\t(getAddress): Documentation added.\n\t(getHostName): Documentation added.\n\t(getPort): Documentation added.\n\t(hashCode): Documentation added.\n\t(isUnresolved): Documentation added.\n\t(toString): Conform to output of JDK 1.4.1, documentation added.\n\t* java/net/MulticastSocket.java\n\t(joinGroup): Removed FIXME, documentation added.\n\t(leaveGroup): Removed FIXME, documentation added.\n\t(send): Documentation added.\n\t* java/net/Socket.java\n\t(inputShutdown): New variable.\n\t(outputShutdown): New variable.\n\t(Socket): Initialize new variables.\n\t(getRemoteSocketAddress): Check if connected.\n\t(shutdownInput): Set new variable.\n\t(shutdownOutput): Set new variable.\n\t(isConnected): New method.\n\t(isClosed): New method.\n\t(isInputShutdown): New method.\n\t(isOutputShutdown): New method.\n\t* java/net/URLStreamHandler.java\n\t(URLStreamHandler): New method.\n\t(openConnection): Added documentation.\n\t(parseURL): Added documentation.\n\t(getHostAddress): New method.\n\t(getDefaultPort): New method.\n\nFrom-SVN: r57772", "tree": {"sha": "aff5f3ab2e4d52928ed330a39300502da4fdce8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aff5f3ab2e4d52928ed330a39300502da4fdce8b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e832ab3c91f01cdb1bd618ffe4a8e00505264d22", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e832ab3c91f01cdb1bd618ffe4a8e00505264d22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e832ab3c91f01cdb1bd618ffe4a8e00505264d22", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/comments", "author": null, "committer": null, "parents": [{"sha": "3eacc81d00aa85d20a95069177f608edb4f8104c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3eacc81d00aa85d20a95069177f608edb4f8104c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3eacc81d00aa85d20a95069177f608edb4f8104c"}], "stats": {"total": 728, "additions": 602, "deletions": 126}, "files": [{"sha": "4e7110f17d6a190c752ea101567657486e4e7b26", "filename": "libjava/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=e832ab3c91f01cdb1bd618ffe4a8e00505264d22", "patch": "@@ -1,3 +1,44 @@\n+2002-09-30  Michael Koch  <konqueror@gmx.de>\n+\n+\t* java/net/DatagramSocket.java\n+\t(receive): Check with SecurityManager AFTER the packet is received,\n+\tcheck if connected to multicast address, documentation added.\n+\t(send): Only check SecurityManager if connected, check address of\n+\tpacket to send.\n+\t(connect): Implemented, documentation added.\n+\t* java/net/Inet6Address.java: New file (not added yet to Makefile.am).\n+\t* java/net/InetSocketAddress.java\n+\t(whole file): Reindented.\n+\t(hostname): New attribute.\n+\t(InetSocketAddress): Initialize new attribute.\n+\t(getAddress): Documentation added.\n+\t(getHostName): Documentation added.\n+\t(getPort): Documentation added.\n+\t(hashCode): Documentation added.\n+\t(isUnresolved): Documentation added.\n+\t(toString): Conform to output of JDK 1.4.1, documentation added.\n+\t* java/net/MulticastSocket.java\n+\t(joinGroup): Removed FIXME, documentation added.\n+\t(leaveGroup): Removed FIXME, documentation added.\n+\t(send): Documentation added.\n+\t* java/net/Socket.java\n+\t(inputShutdown): New variable.\n+\t(outputShutdown): New variable.\n+\t(Socket): Initialize new variables.\n+\t(getRemoteSocketAddress): Check if connected.\n+\t(shutdownInput): Set new variable.\n+\t(shutdownOutput): Set new variable.\n+\t(isConnected): New method.\n+\t(isClosed): New method.\n+\t(isInputShutdown): New method.\n+\t(isOutputShutdown): New method.\n+\t* java/net/URLStreamHandler.java\n+\t(URLStreamHandler): New method.\n+\t(openConnection): Added documentation.\n+\t(parseURL): Added documentation.\n+\t(getHostAddress): New method.\n+\t(getDefaultPort): New method.\n+\n 2002-10-02  Tom Tromey  <tromey@redhat.com>\n \n \t* java/rmi/activation/ActivationDesc.java,"}, {"sha": "b2f2ca11ce31a3b77102f1a8983bf7faba3fd599", "filename": "libjava/java/net/DatagramSocket.java", "status": "modified", "additions": 33, "deletions": 6, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FDatagramSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FDatagramSocket.java?ref=e832ab3c91f01cdb1bd618ffe4a8e00505264d22", "patch": "@@ -290,20 +290,26 @@ public synchronized int getSoTimeout() throws SocketException\n    * exception will be thrown\n    * @exception IllegalBlockingModeException If this socket has an associated\n    * channel, and the channel is in non-blocking mode\n+   * @exception SecurityException If a security manager exists and its\n+   * checkAccept ethod doesn't allow the receive\n    */\n   public synchronized void receive(DatagramPacket p) throws IOException\n   {\n-    SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n-      s.checkAccept (p.getAddress().getHostName (), p.getPort ());\n-\t\t \n     if (impl == null)\n       throw new IOException (\"Cannot initialize Socket implementation\");\n \n+    if (remoteAddress != null && remoteAddress.isMulticastAddress ())\n+      throw new IOException (\n+        \"Socket connected to a multicast address my not receive\");\n+\n     if (ch != null && !ch.isBlocking ())\n       throw new IllegalBlockingModeException ();\n \n     impl.receive(p);\n+\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null && isConnected ())\n+      s.checkAccept (p.getAddress().getHostName (), p.getPort ());\n   }\n \n   /**\n@@ -324,14 +330,22 @@ public void send(DatagramPacket p) throws IOException\n   {\n     // JDK1.2: Don't do security checks if socket is connected; see jdk1.2 api.\n     SecurityManager s = System.getSecurityManager();\n-    if (s != null)\n+    if (s != null && !isConnected ())\n       {\n         InetAddress addr = p.getAddress();\n         if (addr.isMulticastAddress())\n           s.checkMulticast(addr);\n         else\n           s.checkConnect(addr.getHostAddress(), p.getPort());\n       }\n+\n+    if (isConnected ())\n+      {\n+        if (p.getAddress () != null && (remoteAddress != p.getAddress () ||\n+                                        remotePort != p.getPort ()))\n+          throw new IllegalArgumentException (\n+            \"DatagramPacket address does not match remote address\" );\n+      }\n \t    \n     // FIXME: if this is a subclass of MulticastSocket,\n     // use getTimeToLive for TTL val.\n@@ -376,7 +390,20 @@ public synchronized void setSoTimeout(int timeout) throws SocketException\n   public void connect(InetAddress address, int port)\n     throws SocketException\n   {\n-    //impl.connect(address, port);\n+    if (address == null)\n+      throw new IllegalArgumentException (\"Address may not be null\");\n+\n+    if (port < 1 || port > 65535)\n+      throw new IllegalArgumentException (\"Port number is illegal\");\n+\n+    SecurityManager s = System.getSecurityManager();\n+    if (s != null)\n+      s.checkAccept(address.getHostName (), port);\n+\n+    impl.connect (address, port);\n+\n+    remoteAddress = address;\n+    remotePort = port;\n   }\n \n   /**"}, {"sha": "de496b148eea0e99a96f5db232fb3a8a7dfb3653", "filename": "libjava/java/net/Inet6Address.java", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FInet6Address.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FInet6Address.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInet6Address.java?ref=e832ab3c91f01cdb1bd618ffe4a8e00505264d22", "patch": "@@ -0,0 +1,272 @@\n+/* Inet6Address.java\n+   Copyright (C) 2002 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+ \n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+package java.net;\n+\n+import java.io.IOException;\n+\n+/**\n+ * @author Michael Koch\n+ * @date August 3, 2002.\n+ */\n+\n+/*\n+ * Written using on-line Java Platform 1.4 API Specification and\n+ * RFC 1884 (http://www.ietf.org/rfc/rfc1884.txt)\n+ * Status: Believed complete and correct.\n+ */\n+\n+public final class Inet6Address extends InetAddress\n+{\n+  static final long serialVersionUID = 6880410070516793377L;\n+\n+  /**\n+   * Needed for serialization\n+   */\n+  byte[] ipaddress;\n+  \n+  /**\n+   * Create an Inet6Address object\n+   *\n+   * @param addr The IP address\n+   * @param host The hostname\n+   */\n+  protected Inet6Address (byte[] addr, String host)\n+  {\n+    super (null, host);\n+    this.ipaddress = addr;\n+  }\n+\n+  /**\n+   * Utility routine to check if the InetAddress is an IP multicast address\n+   * \n+   * @since 1.1\n+   */\n+  public boolean isMulticastAddress ()\n+  {\n+    return ipaddress [0] == 0xFF;\n+  }\n+ \n+  /**\n+   * Utility routine to check if the InetAddress in a wildcard address\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isAnyLocalAddress ()\n+  {\n+    byte[] anylocal = { 0, 0, 0, 0, 0, 0, 0, 0,\n+\t                0, 0, 0, 0, 0, 0, 0, 0 };\n+    \n+    return ipaddress == anylocal;\n+  }\n+\t  \n+  /**\n+   * Utility routine to check if the InetAddress is a loopback address\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isLoopbackAddress ()\n+  {\n+    byte[] loopback = { 0, 0, 0, 0, 0, 0, 0, 0,\n+\t                0, 0, 0, 0, 0, 0, 0, 1 };\n+    \n+    return ipaddress == loopback;\n+  }\n+\n+  /**\n+   * Utility routine to check if the InetAddress is an link local address\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isLinkLocalAddress ()\n+  {\n+    return ipaddress [0] == 0xFA;\n+  }\n+\n+  /**\n+   * Utility routine to check if the InetAddress is a site local address\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isSiteLocalAddress ()\n+  {\n+    return ipaddress [0] == 0xFB;\n+  }\n+\n+  /**\n+   * Utility routine to check if the multicast address has global scope\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isMCGlobal ()\n+  {\n+    if (!isMulticastAddress ())\n+      return false;\n+    \n+    return (ipaddress [1] & 0x0F) == 0xE;\n+  }\n+\n+  /**\n+   * Utility routine to check if the multicast address has node scope\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isMCNodeLocal ()\n+  {\n+    if (!isMulticastAddress ())\n+      return false;\n+    \n+    return (ipaddress [1] & 0x0F) == 0x1;\n+  }\n+\n+  /**\n+   * Utility routine to check if the multicast address has link scope\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isMCLinkLocal ()\n+  {\n+    if (!isMulticastAddress ())\n+      return false;\n+    \n+    return (ipaddress [1] & 0x0F) == 0x2;\n+  }\n+\n+  /**\n+   * Utility routine to check if the multicast address has site scope\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isMCSiteLocal ()\n+  {\n+    if (!isMulticastAddress ())\n+      return false;\n+    \n+    return (ipaddress [1] & 0x0F) == 0x5;\n+  }\n+\n+  /**\n+   * Utility routine to check if the multicast address has organization scope\n+   * \n+   * @since 1.4\n+   */\n+  public boolean isMCOrgLocal ()\n+  {\n+    if (!isMulticastAddress ())\n+      return false;\n+    \n+    return (ipaddress [1] & 0x0F) == 0x8;\n+  }\n+  \n+  /**\n+   * Returns the raw IP address of this InetAddress object. The result is in\n+   * network byte order: the highest order byte of the address is i\n+   * n getAddress()[0]\n+   */\n+  public byte[] getAddress ()\n+  {\n+    return ipaddress;\n+  }\n+  \n+  /**\n+   * Returns the IP address string in textual presentation\n+   */\n+  public String getHostAddress ()\n+  {\n+    StringBuffer sbuf = new StringBuffer (40);\n+\n+    for (int i = 0; i < 16; i += 2)\n+      {\n+        int x = ((ipaddress [i] & 0xFF) << 8) | (ipaddress [i + 1] & 0xFF);\n+        boolean empty = sbuf.length () == 0;\n+\t\n+        if (empty)\n+          {\n+            if (i > 0)\n+              sbuf.append (\"::\");\n+          }\n+        else\n+          sbuf.append (':');\n+\n+        if (x != 0 || i >= 14)\n+          sbuf.append (Integer.toHexString (x));\n+      }\n+   \n+    return sbuf.toString ();\n+  }\n+\n+  /**\n+   * Returns a hashcode for this IP address\n+   */\n+  public int hashCode ()\n+  {\n+    return super.hashCode ();\n+  }\n+ \n+  /**\n+   * Compares this object against the specified object\n+   */\n+  public boolean equals (Object obj)\n+  {\n+    if (obj == null || ! (obj instanceof Inet6Address))\n+      return false;\n+\n+    Inet6Address tmp = (Inet6Address) obj;\n+\n+    return super.equals (tmp)\n+           && this.ipaddress == tmp.ipaddress;\n+  }\n+  \n+  /**\n+   * Utility routine to check if the InetAddress is an\n+   * IPv4 compatible IPv6 address\n+   *\n+   * @since 1.4\n+   */\n+  public boolean isIPv4CompatibleAddress ()\n+  {\n+    if (ipaddress [0] != 0x00 || ipaddress [1] != 0x00 ||\n+        ipaddress [2] != 0x00 || ipaddress [3] != 0x00 ||\n+\tipaddress [4] != 0x00 || ipaddress [5] != 0x00 ||\n+\tipaddress [6] != 0x00 || ipaddress [7] != 0x00 ||\n+\tipaddress [8] != 0x00 || ipaddress [9] != 0x00 ||\n+\tipaddress [10] != 0x00 || ipaddress [11] != 0x00)\n+      return false;\n+\n+    return true;\n+  }\n+}"}, {"sha": "1f932a95b5f683991b7f34d92928589189c880cf", "filename": "libjava/java/net/InetSocketAddress.java", "status": "modified", "additions": 145, "deletions": 110, "changes": 255, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FInetSocketAddress.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FInetSocketAddress.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FInetSocketAddress.java?ref=e832ab3c91f01cdb1bd618ffe4a8e00505264d22", "patch": "@@ -47,119 +47,154 @@\n \n public class InetSocketAddress extends SocketAddress\n {\n-    InetAddress addr;\n-    int port;\n+  String hostname;\n+  InetAddress addr;\n+  int port;\n     \n-    /**\n-     * Constructs an InetSocketAddress instance.\n-     * \n-     * @param addr Address of the socket\n-     * @param port Port if the socket\n-     *\n-     * @exception IllegalArgumentException If the port number is illegel\n-     */\n-    public InetSocketAddress(InetAddress addr, int port)\n-\tthrows IllegalArgumentException\n-    {\n-\tif (port < 0 || port > 65535)\n-          throw new IllegalArgumentException();\n+  /**\n+   * Constructs an InetSocketAddress instance.\n+   * \n+   * @param addr Address of the socket\n+   * @param port Port if the socket\n+   *\n+   * @exception IllegalArgumentException If the port number is illegal\n+   */\n+  public InetSocketAddress(InetAddress addr, int port)\n+    throws IllegalArgumentException\n+  {\n+    if (port < 0 || port > 65535)\n+      throw new IllegalArgumentException();\n   \n-\tthis.addr = addr;\n-\tthis.port = port;\n-    }\n-\n-    /**\n-     * Constructs an InetSocketAddress instance.\n-     * \n-     * @param port Port if the socket\n-     *\n-     * @exception IllegalArgumentException If the port number is illegal\n-     */\n-    public InetSocketAddress(int port)\n-\tthrows IllegalArgumentException\n-    {\n-\tif (port < 0 || port > 65535)\n-          throw new IllegalArgumentException();\n-\n-\tthis.port = port;\n-\ttry {\n-\t    this.addr = InetAddress.getLocalHost();\n-\t} catch (Exception e) {\n-\t}\n-    }\n-\n-\n-    /**\n-     * Constructs an InetSocketAddress instance.\n-     *\n-     * @param addr Address of the socket\n-     * @param port Port if the socket\n-     *\n-     * @exception IllegalArgumentException If the port number is illegal\n-     */\n-    public InetSocketAddress(String hostname, int port)\n-\tthrows IllegalArgumentException\n-    {\n-\tif (port < 0 || port > 65535)\n-          throw new IllegalArgumentException();\n-\n-\tthis.port = port;\n-\ttry {\n-\t    this.addr = InetAddress.getByName(hostname);\n-\t} catch (Exception e) {\n-\t}\n-    }\n+    this.addr = addr;\n+    this.port = port;\n+\n+    try\n+      {\n+        this.hostname = addr.getHostName ();\n+      }\n+    catch (UnknownHostException e)\n+      {\n+        this.hostname = \"\";\n+      }\n+  }\n+\n+  /**\n+   * Constructs an InetSocketAddress instance.\n+   * \n+   * @param port Port if the socket\n+   *\n+   * @exception IllegalArgumentException If the port number is illegal\n+   */\n+  public InetSocketAddress(int port)\n+    throws IllegalArgumentException\n+  {\n+    if (port < 0 || port > 65535)\n+      throw new IllegalArgumentException();\n+\n+    this.port = port;\n+    \n+    try\n+      {\n+\tbyte[] any = { 0, 0, 0, 0 };\n+\tthis.addr = InetAddress.getByAddress (any);\n+\tthis.hostname = \"0.0.0.0\";\n+      }\n+    catch (UnknownHostException e)\n+      {\n+        this.addr = null;\n+\tthis.hostname = \"\";\n+      }\n+  }\n+\n+\n+  /**\n+   * Constructs an InetSocketAddress instance.\n+   *\n+   * @param addr Address of the socket\n+   * @param port Port if the socket\n+   *\n+   * @exception IllegalArgumentException If the port number is illegal\n+   */\n+  public InetSocketAddress(String hostname, int port)\n+    throws IllegalArgumentException\n+  {\n+    if (port < 0 || port > 65535)\n+      throw new IllegalArgumentException();\n+\n+    this.port = port;\n+    this.hostname = hostname;\n+\n+    try\n+      {\n+        this.addr = InetAddress.getByName(hostname);\n+      }\n+    catch (Exception e) // UnknownHostException, SecurityException\n+      {\n+        this.addr = null;\n+      }\n+  }\n  \n-    /** \n-     * Test if obj is a InetSocketAddress and\n-     * has the same address & port\n-     */\n-    public final boolean equals(Object obj)\n-    {\n-\tif (obj instanceof InetSocketAddress)\n-\t    {\n-\t\tInetSocketAddress a = (InetSocketAddress) obj;\n-\t\treturn addr.equals(a.addr) && a.port == port;\n-\t    }\n-\treturn false;\n-    }\n-\n-    public final InetAddress getAddress()\n-    {\n-\treturn addr;\n-    }\n-\n-    public final String getHostName()\n-    {\n-\treturn addr.getHostName();\n-    }\n-\n-    public final int getPort()\n-    {\n-\treturn port;\n-    }\n+  /** \n+   * Test if obj is a <code>InetSocketAddress</code> and\n+   * has the same address and port\n+   */\n+  public final boolean equals (Object obj)\n+  {\n+    if (obj instanceof InetSocketAddress)\n+      {\n+        InetSocketAddress a = (InetSocketAddress) obj;\n+        return addr.equals(a.addr) && a.port == port;\n+      }\n+    \n+    return false;\n+  }\n+\n+  /**\n+   * Returns the <code>InetAddress</code> or\n+   * <code>null</code> if its unresolved\n+   */\n+  public final InetAddress getAddress()\n+  {\n+    return addr;\n+  }\n+\n+  /**\n+   * Returns <code>hostname</code>\n+   */\n+  public final String getHostName()\n+  {\n+    return hostname;\n+  }\n+\n+  /**\n+   * Returns the <code>port</code>\n+   */\n+  public final int getPort()\n+  {\n+    return port;\n+  }\n     \n-    /**\n-     * TODO: see what sun does here.\n-     */\n-    public final int hashCode()\n-    {\n-\treturn port + addr.hashCode();\n-    }\n-\n-    /**\n-     * TODO: see what sun does here.\n-     */\n-    public final boolean isUnresolved()\n-    {\n-\treturn addr == null;\n-    }\n+  /**\n+   * Returns the hashcode of the <code>InetSocketAddress</code>\n+   */\n+  public final int hashCode()\n+  {\n+    return port + addr.hashCode();\n+  }\n+\n+  /**\n+   * Checks wether the address has been resolved or not\n+   */\n+  public final boolean isUnresolved()\n+  {\n+    return addr == null;\n+  }\n     \n-    /**\n-     * TODO: see what sun does here.\n-     */\n-    public String toString()\n-    {\n-\treturn \"SA:\"+addr+\":\"+port;\n-    }\n+  /**\n+   * Returns the <code>InetSocketAddress</code> as string\n+   */\n+  public String toString()\n+  {\n+    return addr + \":\" + port;\n+  }\n }"}, {"sha": "04d07351ab668736fb961b4b56d54de3b4cc437d", "filename": "libjava/java/net/MulticastSocket.java", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FMulticastSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FMulticastSocket.java?ref=e832ab3c91f01cdb1bd618ffe4a8e00505264d22", "patch": "@@ -252,7 +252,8 @@ public void setTimeToLive(int ttl) throws IOException\n    * @param addr The address of the group to join\n    * \n    * @exception IOException If an error occurs\n-   * @exception SecurityException FIXME\n+   * @exception SecurityException If a security manager exists and its\n+   * checkMulticast method doesn't allow the operation\n    */\n   public void joinGroup(InetAddress mcastaddr) throws IOException\n   {\n@@ -272,7 +273,8 @@ public void joinGroup(InetAddress mcastaddr) throws IOException\n    * @param addr The address of the group to leave\n    *\n    * @exception IOException If an error occurs\n-   * @exception SecurityException FIXME\n+   * @exception SecurityException If a security manager exists and its\n+   * checkMulticast method doesn't allow the operation\n    */\n   public void leaveGroup(InetAddress mcastaddr) throws IOException\n   {\n@@ -296,7 +298,8 @@ public void leaveGroup(InetAddress mcastaddr) throws IOException\n    * \n    * @exception IOException If an error occurs\n    * @exception IllegalArgumentException If address type is not supported\n-   * @exception SecurityException FIXME\n+   * @exception SecurityException If a security manager exists and its\n+   * checkMulticast method doesn't allow the operation\n    *\n    * @see MulticastSocket:setInterface\n    * @see MulticastSocket:setNetworkInterface\n@@ -314,7 +317,6 @@ public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n     if (! tmp.getAddress ().isMulticastAddress ())\n       throw new IOException (\"Not a Multicast address\");\n \n-    // FIXME: check if this check is sufficient. Do we need to check the port ?\n     SecurityManager s = System.getSecurityManager ();\n     if (s != null)\n       s.checkMulticast (tmp.getAddress ());\n@@ -331,7 +333,8 @@ public void joinGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n    *\n    * @exception IOException If an error occurs\n    * @exception IllegalArgumentException If address type is not supported\n-   * @exception SecurityException FIXME\n+   * @exception SecurityException If a security manager exists and its\n+   * checkMulticast method doesn't allow the operation\n    *\n    * @see MulticastSocket:setInterface\n    * @see MulticastSocket:setNetworkInterface\n@@ -346,7 +349,6 @@ public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n     if (! tmp.getAddress ().isMulticastAddress ())\n       throw new IOException (\"Not a Multicast address\");\n \n-    // FIXME: do we need to check the port too, or is this sufficient ?\n     SecurityManager s = System.getSecurityManager ();\n     if (s != null)\n       s.checkMulticast (tmp.getAddress ());\n@@ -363,7 +365,8 @@ public void leaveGroup(SocketAddress mcastaddr, NetworkInterface netIf)\n    * @param ttl The TTL for this packet\n    *\n    * @exception IOException If an error occurs\n-   * @exception SecurityException FIXME\n+   * @exception SecurityException If a security manager exists and its\n+   * checkConnect or checkMulticast method doesn't allow the operation\n    */\n   public synchronized void send(DatagramPacket p, byte ttl) throws IOException\n   {"}, {"sha": "b900801a16b052adc380179542dd9eebf09a30ad", "filename": "libjava/java/net/Socket.java", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FSocket.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FSocket.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FSocket.java?ref=e832ab3c91f01cdb1bd618ffe4a8e00505264d22", "patch": "@@ -80,6 +80,9 @@\n    */\n   SocketImpl impl;\n \n+  private boolean inputShutdown;\n+  private boolean outputShutdown;\n+\n   SocketChannel ch; // this field must have been set if created by SocketChannel\n \n   // Constructors\n@@ -97,6 +100,9 @@ public Socket ()\n       impl = factory.createSocketImpl();\n     else\n       impl = new PlainSocketImpl();\n+\n+    inputShutdown = false;\n+    outputShutdown = false;\n   }\n \n   /**\n@@ -118,6 +124,8 @@ public Socket ()\n   protected Socket (SocketImpl impl) throws SocketException\n   {\n     this.impl = impl;\n+    this.inputShutdown = false;\n+    this.outputShutdown = false;\n   }\n \n   /**\n@@ -264,6 +272,9 @@ private Socket(InetAddress raddr, int rport, InetAddress laddr, int lport,\n                  boolean stream) throws IOException\n   {\n     this();\n+    this.inputShutdown = false;\n+    this.outputShutdown = false;\n+\n     if (impl == null)\n       throw new IOException(\"Cannot initialize Socket implementation\");\n \n@@ -457,6 +468,9 @@ public SocketAddress getLocalSocketAddress()\n    */\n   public SocketAddress getRemoteSocketAddress()\n   {\n+    if (!isConnected ())\n+      return null;\n+\n     return new InetSocketAddress (impl.getInetAddress (), impl.getPort ());\n   }\n \n@@ -886,10 +900,12 @@ public static synchronized void setSocketImplFactory (SocketImplFactory fac)\n    *\n    * @exception IOException If an error occurs.\n    */\n-  public void shutdownInput() throws IOException \n+  public void shutdownInput() throws IOException\n   {\n     if (impl != null)\n       impl.shutdownInput();\n+\n+    inputShutdown = true;\n   }\n \n   /**\n@@ -901,6 +917,8 @@ public void shutdownOutput() throws IOException\n   {\n     if (impl != null)\n       impl.shutdownOutput();\n+    \n+    outputShutdown = true;\n   }\n \n   /**\n@@ -993,11 +1011,44 @@ public void setTrafficClass (int tc) throws SocketException\n     impl.setOption (SocketOptions.IP_TOS, new Integer (tc));\n   }\n \n+  /**\n+   * Checks if the socket is connected\n+   */\n+  public boolean isConnected ()\n+  {\n+    return impl.getInetAddress () != null;\n+  }\n+\n   /**\n    * Checks if the socket is already bound.\n    */\n   public boolean isBound ()\n   {\n     return getLocalAddress () != null;\n   }\n+\n+  /**\n+   * Checks if the socket is closed.\n+   */\n+  public boolean isClosed ()\n+  {\n+    // FIXME: implement this.\n+    return false;\n+  }\n+\n+  /**\n+   * Checks if the socket's input stream is shutdown\n+   */\n+  public boolean isInputShutdown ()\n+  {\n+    return inputShutdown;\n+  }\n+\n+  /**\n+   * Checks if the socket's output stream is shutdown\n+   */\n+  public boolean isOutputShutdown ()\n+  {\n+    return outputShutdown;\n+  }\n }"}, {"sha": "9c6ba258dc7128688f507f6c21065ce9b5cf8d2b", "filename": "libjava/java/net/URLStreamHandler.java", "status": "modified", "additions": 49, "deletions": 2, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e832ab3c91f01cdb1bd618ffe4a8e00505264d22/libjava%2Fjava%2Fnet%2FURLStreamHandler.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fnet%2FURLStreamHandler.java?ref=e832ab3c91f01cdb1bd618ffe4a8e00505264d22", "patch": "@@ -25,6 +25,19 @@\n \n public abstract class URLStreamHandler\n {\n+  /**\n+   * Creates a URLStreamHander\n+   */\n+  public URLStreamHandler ()\n+  {\n+  }\n+\n+  /**\n+   * Opens a connection to the object referenced by the URL argument.\n+   * This method should be overridden by a subclass.\n+   *\n+   * @exception IOException If an error occurs\n+   */\n   protected abstract URLConnection openConnection(URL u)\n     throws IOException;\n \n@@ -33,8 +46,12 @@ protected abstract URLConnection openConnection(URL u)\n    *\n    * @param u The URL to parse\n    * @param spec The specification to use\n-   * @param start FIXME\n-   * @param limit FIXME\n+   * @param start The character index at which to begin parsing. This is just\n+   * past the ':' (if there is one) that specifies the determination of the\n+   * protocol name\n+   * @param limit The character position to stop parsing at. This is the end\n+   * of the string or the position of the \"#\" character, if present. All\n+   * information after the sharp sign indicates an anchor\n    */\n   protected void parseURL(URL u, String spec, int start, int limit)\n   {\n@@ -206,6 +223,36 @@ protected void setURL(URL u, String protocol, String host, int port,\n     u.set(protocol, host, port, authority, userInfo, path, query, ref);\n   }\n \n+  /**\n+   * Get the IP address of our host. An empty host field or a DNS failure will\n+   * result in a null return.\n+   */\n+  protected InetAddress getHostAddress (URL url)\n+  {\n+    String hostname = url.getHost ();\n+\n+    if (hostname == \"\")\n+      return null;\n+    \n+    try\n+      {\n+        return InetAddress.getByName (hostname);\n+      }\n+    catch (UnknownHostException e)\n+      {\n+\treturn null;\n+      }\n+  }\n+\n+  /**\n+   * Returns the default port for a URL parsed by this handler. This method is\n+   * meant to be overidden by handlers with default port numbers.\n+   */\n+  protected int getDefaultPort ()\n+  {\n+    return -1;\n+  }\n+\n   /**\n    * Converts an URL of a specific protocol to a string\n    *"}]}