{"sha": "3e6b638642af31850768e3f9bdaacb27c3b26c76", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U2YjYzODY0MmFmMzE4NTA3NjhlM2Y5YmRhYWNiMjdjM2IyNmM3Ng==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2004-10-03T01:53:09Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2004-10-03T01:53:09Z"}, "message": "builtins.c (expand_builtin_memcmp, [...]): Delete duplicate code.\n\n\t* builtins.c (expand_builtin_memcmp, expand_builtin_strcmp,\n\texpand_builtin_strncmp): Delete duplicate code.\n\nFrom-SVN: r88437", "tree": {"sha": "d55c8edae6a269879356f49f1ff044ecebeedb0a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d55c8edae6a269879356f49f1ff044ecebeedb0a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e6b638642af31850768e3f9bdaacb27c3b26c76", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e6b638642af31850768e3f9bdaacb27c3b26c76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e6b638642af31850768e3f9bdaacb27c3b26c76", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e6b638642af31850768e3f9bdaacb27c3b26c76/comments", "author": null, "committer": null, "parents": [{"sha": "400356e3e90926905416405a3a02c2b60a8b9ba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/400356e3e90926905416405a3a02c2b60a8b9ba7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/400356e3e90926905416405a3a02c2b60a8b9ba7"}], "stats": {"total": 167, "additions": 25, "deletions": 142}, "files": [{"sha": "b4848154ff1601febc958731e10cc3afd5e0a4fb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6b638642af31850768e3f9bdaacb27c3b26c76/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6b638642af31850768e3f9bdaacb27c3b26c76/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e6b638642af31850768e3f9bdaacb27c3b26c76", "patch": "@@ -1,3 +1,8 @@\n+2004-10-02  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* builtins.c (expand_builtin_memcmp, expand_builtin_strcmp,\n+\texpand_builtin_strncmp): Delete duplicate code.\n+\n 2004-10-02  Frank Ch. Eigler  <fche@redhat.com>\n \n \t* tree-mudflap.c (mf_build_check_statement_for): Reorganize to"}, {"sha": "dd8c8ea87730573ac190313e7d22ab31b370198c", "filename": "gcc/builtins.c", "status": "modified", "additions": 20, "deletions": 142, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e6b638642af31850768e3f9bdaacb27c3b26c76/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e6b638642af31850768e3f9bdaacb27c3b26c76/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=3e6b638642af31850768e3f9bdaacb27c3b26c76", "patch": "@@ -3296,69 +3296,21 @@ static rtx\n expand_builtin_memcmp (tree exp ATTRIBUTE_UNUSED, tree arglist, rtx target,\n \t\t       enum machine_mode mode)\n {\n-  tree arg1, arg2, len;\n-  const char *p1, *p2;\n-\n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n-\n-  arg1 = TREE_VALUE (arglist);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-\n-  /* If the len parameter is zero, return zero.  */\n-  if (integer_zerop (len))\n-    {\n-      /* Evaluate and ignore arg1 and arg2 in case they have\n-         side-effects.  */\n-      expand_expr (arg1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      expand_expr (arg2, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      return const0_rtx;\n-    }\n-\n-  /* If both arguments are equal (and not volatile), return zero.  */\n-  if (operand_equal_p (arg1, arg2, 0))\n-    {\n-      /* Evaluate and ignore len in case it has side-effects.  */\n-      expand_expr (len, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      return const0_rtx;\n-    }\n-\n-  p1 = c_getstr (arg1);\n-  p2 = c_getstr (arg2);\n-\n-  /* If all arguments are constant, and the value of len is not greater\n-     than the lengths of arg1 and arg2, evaluate at compile-time.  */\n-  if (host_integerp (len, 1) && p1 && p2\n-      && compare_tree_int (len, strlen (p1) + 1) <= 0\n-      && compare_tree_int (len, strlen (p2) + 1) <= 0)\n-    {\n-      const int r = memcmp (p1, p2, tree_low_cst (len, 1));\n-\n-      return (r < 0 ? constm1_rtx : (r > 0 ? const1_rtx : const0_rtx));\n-    }\n-\n-  /* If len parameter is one, return an expression corresponding to\n-     (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n-  if (integer_onep (len))\n+  else\n     {\n-      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n-      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n-      tree ind1 =\n-      fold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t    fold_convert (cst_uchar_ptr_node, arg1))));\n-      tree ind2 =\n-      fold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t    fold_convert (cst_uchar_ptr_node, arg2))));\n-      tree result = fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n-      return expand_expr (result, target, mode, EXPAND_NORMAL);\n+      tree result = fold_builtin_memcmp (arglist);\n+      if (result)\n+\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n \n #if defined HAVE_cmpmemsi || defined HAVE_cmpstrsi\n   {\n+    tree arg1 = TREE_VALUE (arglist);\n+    tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+    tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n     rtx arg1_rtx, arg2_rtx, arg3_rtx;\n     rtx result;\n     rtx insn;\n@@ -3453,49 +3405,21 @@ static rtx\n expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree arg1, arg2;\n-  const char *p1, *p2;\n \n   if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n     return 0;\n-\n-  arg1 = TREE_VALUE (arglist);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-\n-  /* If both arguments are equal (and not volatile), return zero.  */\n-  if (operand_equal_p (arg1, arg2, 0))\n-    return const0_rtx;\n-\n-  p1 = c_getstr (arg1);\n-  p2 = c_getstr (arg2);\n-\n-  if (p1 && p2)\n-    {\n-      const int i = strcmp (p1, p2);\n-      return (i < 0 ? constm1_rtx : (i > 0 ? const1_rtx : const0_rtx));\n-    }\n-\n-  /* If either arg is \"\", return an expression corresponding to\n-     (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n-  if ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0'))\n+  else\n     {\n-      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n-      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n-      tree ind1 =\n-\tfold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t      fold_convert (cst_uchar_ptr_node, arg1))));\n-      tree ind2 =\n-\tfold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t      fold_convert (cst_uchar_ptr_node, arg2))));\n-      tree result = fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n-      return expand_expr (result, target, mode, EXPAND_NORMAL);\n+      tree result = fold_builtin_strcmp (arglist);\n+      if (result)\n+\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n \n #ifdef HAVE_cmpstrsi\n   if (HAVE_cmpstrsi)\n   {\n+    tree arg1 = TREE_VALUE (arglist);\n+    tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n     tree len, len1, len2;\n     rtx arg1_rtx, arg2_rtx, arg3_rtx;\n     rtx result, insn;\n@@ -3598,64 +3522,15 @@ static rtx\n expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n {\n   tree arglist = TREE_OPERAND (exp, 1);\n-  tree arg1, arg2, arg3;\n-  const char *p1, *p2;\n \n   if (!validate_arglist (arglist,\n \t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n-\n-  arg1 = TREE_VALUE (arglist);\n-  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n-  arg3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n-\n-  /* If the len parameter is zero, return zero.  */\n-  if (integer_zerop (arg3))\n-    {\n-      /* Evaluate and ignore arg1 and arg2 in case they have\n-\t side-effects.  */\n-      expand_expr (arg1, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      expand_expr (arg2, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      return const0_rtx;\n-    }\n-\n-  /* If arg1 and arg2 are equal (and not volatile), return zero.  */\n-  if (operand_equal_p (arg1, arg2, 0))\n-    {\n-      /* Evaluate and ignore arg3 in case it has side-effects.  */\n-      expand_expr (arg3, const0_rtx, VOIDmode, EXPAND_NORMAL);\n-      return const0_rtx;\n-    }\n-\n-  p1 = c_getstr (arg1);\n-  p2 = c_getstr (arg2);\n-\n-  /* If all arguments are constant, evaluate at compile-time.  */\n-  if (host_integerp (arg3, 1) && p1 && p2)\n-    {\n-      const int r = strncmp (p1, p2, tree_low_cst (arg3, 1));\n-      return (r < 0 ? constm1_rtx : (r > 0 ? const1_rtx : const0_rtx));\n-    }\n-\n-  /* If len == 1 or (either string parameter is \"\" and (len >= 1)),\n-      return (*(const u_char*)arg1 - *(const u_char*)arg2).  */\n-  if (host_integerp (arg3, 1)\n-      && (tree_low_cst (arg3, 1) == 1\n-\t  || (tree_low_cst (arg3, 1) > 1\n-\t      && ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0')))))\n+  else\n     {\n-      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n-      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n-      tree ind1 =\n-\tfold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t      fold_convert (cst_uchar_ptr_node, arg1))));\n-      tree ind2 =\n-\tfold (build1 (CONVERT_EXPR, integer_type_node,\n-\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n-\t\t\t      fold_convert (cst_uchar_ptr_node, arg2))));\n-      tree result = fold (build2 (MINUS_EXPR, integer_type_node, ind1, ind2));\n-      return expand_expr (result, target, mode, EXPAND_NORMAL);\n+      tree result = fold_builtin_strncmp (arglist);\n+      if (result)\n+\treturn expand_expr (result, target, mode, EXPAND_NORMAL);\n     }\n \n   /* If c_strlen can determine an expression for one of the string\n@@ -3664,6 +3539,9 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n #ifdef HAVE_cmpstrsi\n   if (HAVE_cmpstrsi)\n   {\n+    tree arg1 = TREE_VALUE (arglist);\n+    tree arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+    tree arg3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n     tree len, len1, len2;\n     rtx arg1_rtx, arg2_rtx, arg3_rtx;\n     rtx result, insn;"}]}