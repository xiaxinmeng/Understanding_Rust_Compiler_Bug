{"sha": "00150bf9f31d6a0ec576ead73a315f26b1c31749", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDAxNTBiZjlmMzFkNmEwZWM1NzZlYWQ3M2EzMTVmMjZiMWMzMTc0OQ==", "commit": {"author": {"name": "Andrew Haley", "email": "aph@redhat.com", "date": "2004-07-21T16:03:43Z"}, "committer": {"name": "Andrew Haley", "email": "aph@gcc.gnu.org", "date": "2004-07-21T16:03:43Z"}, "message": "verify.c (verify_jvm_instructions): Comment change only.\n\n2004-07-20  Andrew Haley  <aph@redhat.com>\n\n\t* verify.c (verify_jvm_instructions): Comment change only.\n\n\t* typeck.c (build_java_array_type): Add size field to array name.\n\n\t* java-tree.h (LOCAL_SLOT_P): New.\n\t(update_aliases): Add PC argument.\n\t(pushdecl_function_level): New function.\n\n\t* java-gimplify.c (java_gimplify_expr): Handle VAR_DECL,\n\tMODIFY_EXPR, and SAVE_EXPR.\n\t(java_gimplify_modify_expr): New function.\n\n\t* expr.c (push_type_0): Call find_stack_slot() to create temporary.\n\t(expand_iinc): Pass PC to update_aliases().\n\t(STORE_INTERNAL): Likewise.\n\t(process_jvm_instruction): Likewise.\n\n\t* decl.c (base_decl_map): New variable.\n\t(uniq): New variable.\n\t(update_aliases): Rewrite with more thorough checking.\n\t(debug_variable_p): New function.\n\t(push_jvm_slot): Don't initialize local variable.  Don't pushdecl.\n\t(check_local_named_variable): Delete whole function.\n\t(initialize_local_variable): New function.\n\t(check_local_unnamed_variable): Add checks and comments.\n\t(find_local_variable): Rewrite.\n\t(java_replace_reference): New function.\n\t(function_binding_level): New variable.\n\t(pushdecl_function_level): New function.\n\t(maybe_pushlevels): Set DECL_LOCAL_END_PC.\n\t(maybe_pushlevels): Call pushdecl() on each of the new decls.\n\t(start_java_method): Reset uniq.  Create base_decl_map.  Set\n\tfunction_binding_level.\n\t(end_java_method): Null unused fields to save memory.\n\nFrom-SVN: r85009", "tree": {"sha": "1785e3e0f34d4daf27613e8a698fd2c59ee721f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1785e3e0f34d4daf27613e8a698fd2c59ee721f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00150bf9f31d6a0ec576ead73a315f26b1c31749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00150bf9f31d6a0ec576ead73a315f26b1c31749", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00150bf9f31d6a0ec576ead73a315f26b1c31749", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00150bf9f31d6a0ec576ead73a315f26b1c31749/comments", "author": {"login": "theRealAph", "id": 254637, "node_id": "MDQ6VXNlcjI1NDYzNw==", "avatar_url": "https://avatars.githubusercontent.com/u/254637?v=4", "gravatar_id": "", "url": "https://api.github.com/users/theRealAph", "html_url": "https://github.com/theRealAph", "followers_url": "https://api.github.com/users/theRealAph/followers", "following_url": "https://api.github.com/users/theRealAph/following{/other_user}", "gists_url": "https://api.github.com/users/theRealAph/gists{/gist_id}", "starred_url": "https://api.github.com/users/theRealAph/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/theRealAph/subscriptions", "organizations_url": "https://api.github.com/users/theRealAph/orgs", "repos_url": "https://api.github.com/users/theRealAph/repos", "events_url": "https://api.github.com/users/theRealAph/events{/privacy}", "received_events_url": "https://api.github.com/users/theRealAph/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5d16533a079388246d53311790a4a4b2a16aa6c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d16533a079388246d53311790a4a4b2a16aa6c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d16533a079388246d53311790a4a4b2a16aa6c6"}], "stats": {"total": 450, "additions": 339, "deletions": 111}, "files": [{"sha": "2dc55837347086c9d59450840577d6c3d491ef53", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=00150bf9f31d6a0ec576ead73a315f26b1c31749", "patch": "@@ -1,3 +1,40 @@\n+2004-07-20  Andrew Haley  <aph@redhat.com>\n+\n+\t* verify.c (verify_jvm_instructions): Comment change only.\n+\n+\t* typeck.c (build_java_array_type): Add size field to array name.\n+\n+\t* java-tree.h (LOCAL_SLOT_P): New.\n+\t(update_aliases): Add PC argument.\n+\t(pushdecl_function_level): New function.\n+\n+\t* java-gimplify.c (java_gimplify_expr): Handle VAR_DECL,\n+\tMODIFY_EXPR, and SAVE_EXPR.\n+\t(java_gimplify_modify_expr): New function.\n+\n+\t* expr.c (push_type_0): Call find_stack_slot() to create temporary.\n+\t(expand_iinc): Pass PC to update_aliases().\n+\t(STORE_INTERNAL): Likewise.\n+\t(process_jvm_instruction): Likewise.\n+\n+\t* decl.c (base_decl_map): New variable.\n+\t(uniq): New variable.\n+\t(update_aliases): Rewrite with more thorough checking.\n+\t(debug_variable_p): New function.\n+\t(push_jvm_slot): Don't initialize local variable.  Don't pushdecl.\n+\t(check_local_named_variable): Delete whole function.\n+\t(initialize_local_variable): New function.\n+\t(check_local_unnamed_variable): Add checks and comments.\n+\t(find_local_variable): Rewrite.\n+\t(java_replace_reference): New function.\n+\t(function_binding_level): New variable.\n+\t(pushdecl_function_level): New function.\n+\t(maybe_pushlevels): Set DECL_LOCAL_END_PC.\n+\t(maybe_pushlevels): Call pushdecl() on each of the new decls.\n+\t(start_java_method): Reset uniq.  Create base_decl_map.  Set\n+\tfunction_binding_level.\n+\t(end_java_method): Null unused fields to save memory.\n+\t\n 2004-07-20  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* class.c (add_interface_do): Remove."}, {"sha": "35a9218bc4152744c67ad42aba4a0fe6c4e60ebb", "filename": "gcc/java/decl.c", "status": "modified", "additions": 232, "deletions": 101, "changes": 333, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=00150bf9f31d6a0ec576ead73a315f26b1c31749", "patch": "@@ -57,7 +57,6 @@ static tree lookup_name_current_level (tree);\n static tree push_promoted_type (const char *, tree);\n static struct binding_level *make_binding_level (void);\n static tree create_primitive_vtable (const char *);\n-static tree check_local_named_variable (tree, tree, int, int *);\n static tree check_local_unnamed_variable (tree, tree, tree);\n \n /* Name of the Cloneable class.  */\n@@ -76,14 +75,20 @@ tree java_io_serializable_identifier_node;\n \n static GTY(()) tree decl_map;\n \n+/* The base_decl_map is contains one variable of ptr_type: this is\n+   used to contain every variable of reference type that is ever\n+   stored in a local variable slot.  */\n+\n+static GTY(()) tree base_decl_map;\n+\n+/* An index used to make temporary identifiers unique.  */\n+static int uniq;\n+\n /* A list of local variables VAR_DECLs for this method that we have seen\n    debug information, but we have not reached their starting (byte) PC yet. */\n \n static GTY(()) tree pending_local_decls;\n \n-/* Push a local variable or stack slot into the decl_map,\n-   and assign it an rtl. */\n-\n #if defined(DEBUG_JAVA_BINDING_LEVELS)\n int binding_depth = 0;\n int is_class_level = 0;\n@@ -99,51 +104,67 @@ indent (void)\n }\n #endif /* defined(DEBUG_JAVA_BINDING_LEVELS) */\n \n-/* Copy the value in decl into every alias in the same local variable\n-   slot.  */\n+/* True if decl is a named local variable, i.e. if it is an alias\n+   that's used only for debugging purposes.  */\n+\n+static bool\n+debug_variable_p (tree decl)\n+{\n+  if (TREE_CODE (decl) == PARM_DECL)\n+    return false;\n+\n+  if (LOCAL_SLOT_P (decl))\n+    return false;\n+\n+  return true;\n+}\n+ \n+/* Copy the value in decl into every live alias in the same local\n+   variable slot.  Some of these will be dead stores removed by the\n+   optimizer.  */\n+\n void \n-update_aliases (tree decl, int index)\n+update_aliases (tree decl, int index, int pc)\n {\n-  tree tmp = TREE_VEC_ELT (decl_map, index);\n-  tree type = TREE_TYPE (decl);\n-  while (tmp != NULL_TREE)\n+  tree decl_type = TREE_TYPE (decl);\n+  tree tmp;\n+\n+  if (debug_variable_p (decl))\n+    abort ();\n+\n+  for (tmp = TREE_VEC_ELT (decl_map, index); \n+       tmp != NULL_TREE; \n+       tmp = DECL_LOCAL_SLOT_CHAIN (tmp))\n     {\n+      tree tmp_type = TREE_TYPE (tmp);\n       if (tmp != decl\n-\t  && ! LOCAL_VAR_OUT_OF_SCOPE_P (tmp)\n-\t  && TYPE_MODE (type) == TYPE_MODE (TREE_TYPE (tmp)))\n+\t  && LOCAL_SLOT_P (tmp) == 0\n+\t  && (pc == -1\n+\t      || (pc >= DECL_LOCAL_START_PC (tmp)\n+\t\t  && pc <= DECL_LOCAL_END_PC (tmp)))\n+\t  && (tmp_type == decl_type\n+\t      || (INTEGRAL_TYPE_P (tmp_type)\n+\t\t  && INTEGRAL_TYPE_P (decl_type)\n+\t\t  && TYPE_PRECISION (decl_type) <= 32\n+\t\t  && TYPE_PRECISION (tmp_type) <= 32)\n+\t      || (TREE_CODE (tmp_type) == POINTER_TYPE\n+\t\t  && TREE_CODE (decl_type) == POINTER_TYPE)))\n \t{\n-\t  tree src = build1 (NOP_EXPR, TREE_TYPE (tmp), decl);\n-\t  java_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (tmp), tmp, src));\n+\t  tree src = build1 (NOP_EXPR, tmp_type, decl);\n+\t  if (LOCAL_VAR_OUT_OF_SCOPE_P (tmp))\n+\t    abort ();\n+\t  java_add_stmt \n+\t    (build (MODIFY_EXPR, tmp_type, tmp, src));\n \t}\n-      tmp = DECL_LOCAL_SLOT_CHAIN (tmp);      \n     }\n }\n \n static tree\n push_jvm_slot (int index, tree decl)\n {\n-  tree type = TREE_TYPE (decl);\n-  tree tmp;\n-\n   DECL_CONTEXT (decl) = current_function_decl;\n   layout_decl (decl, 0);\n \n-  /* Look for another variable of the same mode in this slot.  */ \n-  tmp = TREE_VEC_ELT (decl_map, index);\n-  while (tmp != NULL_TREE)\n-    {\n-      if (! LOCAL_VAR_OUT_OF_SCOPE_P (tmp)\n-\t  && TYPE_MODE (type) == TYPE_MODE (TREE_TYPE (tmp)))\n-\t{\n-\t  /* At the point of its creation this decl inherits whatever\n-\t     is in the slot.  */\n-\t  tree src = build1 (NOP_EXPR, TREE_TYPE (decl), tmp);\n-\t  java_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (decl), decl, src));\t\n-\t  break;\n-\t}\n-      tmp = DECL_LOCAL_SLOT_CHAIN (tmp);\n-    }\n-\n   /* Now link the decl into the decl_map. */\n   if (DECL_LANG_SPECIFIC (decl) == NULL)\n     {\n@@ -155,31 +176,54 @@ push_jvm_slot (int index, tree decl)\n   DECL_LOCAL_SLOT_CHAIN (decl) = TREE_VEC_ELT (decl_map, index);\n   TREE_VEC_ELT (decl_map, index) = decl;\n \n-  if (TREE_CODE (decl) != PARM_DECL)\n-    pushdecl (decl);\n   return decl;\n }\n \n-/* Find out if 'decl' passed in fits the defined PC location better than\n-   'best'.  Return decl if it does, return best if it doesn't.  If decl\n-   is returned, then updated is set to true.  */\n+/*  At the point of its creation a local variable decl inherits\n+    whatever is already in the same slot.  In the case of a local\n+    variable that is declared but unused, we won't find anything.  */\n \n-static tree\n-check_local_named_variable (tree best, tree decl, int pc, int *updated)\n+static void\n+initialize_local_variable (tree decl, int index)\n {\n-  if (pc >= DECL_LOCAL_START_PC (decl)\n-      && pc < DECL_LOCAL_END_PC (decl))\n+  tree decl_type = TREE_TYPE (decl);\n+  if (TREE_CODE (decl_type) == POINTER_TYPE)\n     {\n-      if (best == NULL_TREE\n-\t  || (DECL_LOCAL_START_PC (decl) > DECL_LOCAL_START_PC (best)\n-\t      && DECL_LOCAL_END_PC (decl) < DECL_LOCAL_END_PC (best)))\n+      tree tmp = TREE_VEC_ELT (base_decl_map, index);\n+\n+      if (tmp)\n         {\n-\t  *updated = 1;\n-\t  return decl;\n+\t  /* At the point of its creation this decl inherits whatever\n+\t     is in the slot.  */\n+\t  tree src = build1 (NOP_EXPR, decl_type, tmp);\n+\t  java_add_stmt \n+\t    (build (MODIFY_EXPR, decl_type, decl, src));\t\n \t}\n     }\n+  else\n+    {\n+      tree tmp;\n   \n-  return best;\n+      for (tmp = TREE_VEC_ELT (decl_map, index); \n+\t   tmp != NULL_TREE; \n+\t   tmp = DECL_LOCAL_SLOT_CHAIN (tmp))\n+\t{\n+\t  tree tmp_type = TREE_TYPE (tmp);\n+\t  if (tmp != decl\n+\t      && ! debug_variable_p (tmp)\n+\t      && (tmp_type == decl_type\n+\t\t  || (INTEGRAL_TYPE_P (tmp_type)\n+\t\t      && INTEGRAL_TYPE_P (decl_type)\n+\t\t      && TYPE_PRECISION (decl_type) <= 32\n+\t\t      && TYPE_PRECISION (tmp_type) <= 32\n+\t\t      && TYPE_PRECISION (tmp_type) >= TYPE_PRECISION (decl_type))))\n+\t    {\n+\t      java_add_stmt \n+\t\t(build (MODIFY_EXPR, decl_type, decl, tmp));\t\n+\t      return;\n+\t    }\n+\t}  \n+    }\n }\n \n /* Find the best declaration based upon type.  If 'decl' fits 'type' better\n@@ -188,16 +232,25 @@ check_local_named_variable (tree best, tree decl, int pc, int *updated)\n static tree\n check_local_unnamed_variable (tree best, tree decl, tree type)\n {\n-    if (TREE_TYPE (decl) == type\n-\t|| (TREE_CODE (TREE_TYPE (decl)) == TREE_CODE (type)\n-\t    && TYPE_PRECISION (TREE_TYPE (decl)) <= 32\n+  tree decl_type = TREE_TYPE (decl);\n+  \n+  if (LOCAL_VAR_OUT_OF_SCOPE_P (decl))\n+    abort ();\n+\n+  /* Use the same decl for all integer types <= 32 bits.  This is\n+     necessary because sometimes a value is stored as (for example)\n+     boolean but loaded as int.  */\n+  if (decl_type == type\n+      || (INTEGRAL_TYPE_P (decl_type)\n+\t  && INTEGRAL_TYPE_P (type)\n+\t  && TYPE_PRECISION (decl_type) <= 32\n \t    && TYPE_PRECISION (type) <= 32\n-\t    && TREE_CODE (type) != POINTER_TYPE)\n+\t  && TYPE_PRECISION (decl_type) >= TYPE_PRECISION (type))      \n \t|| (TREE_CODE (TREE_TYPE (decl)) == POINTER_TYPE\n \t    && type == ptr_type_node))\n       {\n \tif (best == NULL_TREE\n-\t    || (TREE_TYPE (decl) == type && TREE_TYPE (best) != type))\n+\t  || (decl_type == type && TREE_TYPE (best) != type))\n \t  return decl;\n       }\n \n@@ -210,63 +263,103 @@ check_local_unnamed_variable (tree best, tree decl, tree type)\n    If there is no existing matching decl, allocate one.  */\n \n tree\n-find_local_variable (int index, tree type, int pc)\n+find_local_variable (int index, tree type, int pc ATTRIBUTE_UNUSED)\n {\n-  tree decl = TREE_VEC_ELT (decl_map, index);\n-  tree best = NULL_TREE;\n-  int found_scoped_var = 0;\n+  tree tmp = TREE_VEC_ELT (decl_map, index);\n+  tree decl = NULL_TREE;\n \n-  /* Scan through every declaration that has been created in this slot. */\n-  while (decl != NULL_TREE)\n+  /* Scan through every declaration that has been created in this\n+     slot.  We're only looking for variables that correspond to local\n+     index declarations and PARM_DECLs, not named variables: such\n+     local variables are used only for debugging information.  */\n+  while (tmp != NULL_TREE)\n     {\n-      bool has_name = false;\n-      tree name = DECL_NAME (decl);\n-      if (name && IDENTIFIER_POINTER (name))\n-\thas_name = IDENTIFIER_POINTER (name)[0] != '#';\n-      \n-       /* Variables created in give_name_to_locals() have a name and have\n- \t a specified scope, so we can handle them specifically.  We want\n- \t to use the specific decls created for those so they are assigned\n- \t the right variables in the debugging information. */\n-      if (has_name)\n-\t{\n-\t  /* This is a variable we have a name for, so it has a scope\n-\t     supplied in the class file.  But it only matters when we\n-\t     actually have a PC to use.  If pc<0, then we are asking\n-\t     for a stack slot and this decl won't be one of those. */\n- \t  if (pc >= 0)\n- \t    best = check_local_named_variable (best, decl, pc,\n- \t\t\t\t\t       &found_scoped_var);\n- \t}\n-      /* We scan for type information unless we found a variable in the\n-\t proper scope already. */\n-      else if (!found_scoped_var)\n- \t{\n- \t  /* If we don't have scoping information for a variable, we use\n- \t     a different method to look it up. */\n- \t  best = check_local_unnamed_variable (best, decl, type);\n- \t}\n-\n-      decl = DECL_LOCAL_SLOT_CHAIN (decl);\n+      if (! debug_variable_p (tmp))\n+\tdecl = check_local_unnamed_variable (decl, tmp, type);\n+      tmp = DECL_LOCAL_SLOT_CHAIN (tmp);\n     }\n \n-  if (best != NULL_TREE)\n-    return best;\n-\n   /* If we don't find a match, create one with the type passed in.\n-     Ths name of the variable is #n#m, which n is the variable index\n+     The name of the variable is #n#m, which n is the variable index\n      in the local variable area and m is a dummy identifier for\n      uniqueness -- multiple variables may share the same local\n-     variable index.  */\n+     variable index.  We don't call pushdecl() to push pointer types\n+     into a binding expr because they'll all be replaced by a single\n+     variable that is used for every reference in that local variable\n+     slot.  */\n+  if (! decl)\n   {\n     char buf[64];\n     tree name;\n-    static int uniq;\n-    sprintf (buf, \"#%d#%d\", index, uniq++);\n-    name = get_identifier (buf);\n+      sprintf (buf, \"#slot#%d#%d\", index, uniq++);\n+      name = get_identifier (buf);\n+      decl = build_decl (VAR_DECL, name, type);\n+      DECL_IGNORED_P (decl) = 1;\n+      DECL_ARTIFICIAL (decl) = 1;\n+      decl = push_jvm_slot (index, decl);\n+      LOCAL_SLOT_P (decl) = 1;\n+\n+      if (TREE_CODE (type) != POINTER_TYPE)\n+\tpushdecl_function_level (decl);\n+    }\n \n-    return push_jvm_slot (index, build_decl (VAR_DECL, name, type));\n-  }\n+  /* As well as creating a local variable that matches the type, we\n+     also create a base variable (of ptr_type) that will hold all its\n+     aliases.  */\n+  if (TREE_CODE (type) == POINTER_TYPE\n+      && ! TREE_VEC_ELT (base_decl_map, index))\n+    {\n+      char buf[64];\n+      tree name;\n+      tree base_decl;\n+      sprintf (buf, \"#ref#%d#%d\", index, uniq++);\n+      name = get_identifier (buf);\n+      base_decl\n+\t= TREE_VEC_ELT (base_decl_map, index)\n+\t= build_decl (VAR_DECL, name, ptr_type_node);\n+      pushdecl_function_level (base_decl);\n+      DECL_IGNORED_P (base_decl) = 1;\n+      DECL_ARTIFICIAL (base_decl) = 1;\n+    }\n+\n+  return decl;\n+}\n+\n+/* Called during gimplification for every variable.  If the variable\n+   is a temporary of pointer type, replace it with a common variable\n+   thath is used to hold all pointer types that are ever stored in\n+   that slot.  Set WANT_LVALUE if you want a variable that is to be\n+   written to.  */\n+\n+tree \n+java_replace_reference (tree var_decl, bool want_lvalue)\n+{\n+  tree decl_type;\n+\n+  if (! base_decl_map)\n+    return var_decl;\n+\n+  decl_type = TREE_TYPE (var_decl);\n+\n+  if (TREE_CODE (decl_type) == POINTER_TYPE)\n+    {\n+      if (DECL_LANG_SPECIFIC (var_decl)\n+\t  && LOCAL_SLOT_P (var_decl))\n+\t{\n+\t  int index = DECL_LOCAL_SLOT_NUMBER (var_decl);\n+\t  tree base_decl = TREE_VEC_ELT (base_decl_map, index); \n+\n+\t  if (! base_decl)\n+\t    abort ();\n+\n+\t  if (! want_lvalue)\n+\t    base_decl = build1 (NOP_EXPR, decl_type, base_decl);\n+\n+\t  return base_decl;\n+\t}\n+    }\n+\n+  return var_decl;\n }\n \n \n@@ -331,6 +424,11 @@ static GTY(()) struct binding_level *free_binding_level;\n \n static GTY(()) struct binding_level *global_binding_level;\n \n+/* The binding level that holds variables declared at the outermost\n+   level within a function body.  */\n+\n+static struct binding_level *function_binding_level;\n+\n /* A PC value bigger than any PC value we may ever may encounter. */\n \n #define LARGEST_PC (( (unsigned int)1 << (HOST_BITS_PER_INT - 1)) - 1)\n@@ -1174,6 +1272,20 @@ pushdecl_top_level (tree x)\n   return t;\n }\n \n+/* Like pushdecl, only it places X in FUNCTION_BINDING_LEVEL, if appropriate.  */\n+\n+tree\n+pushdecl_function_level (tree x)\n+{\n+  tree t;\n+  struct binding_level *b = current_binding_level;\n+\n+  current_binding_level = function_binding_level;\n+  t = pushdecl (x);\n+  current_binding_level = b;\n+  return t;\n+}\n+\n /* Nonzero if we are currently in the global binding level.  */\n \n int\n@@ -1497,9 +1609,13 @@ maybe_pushlevels (int pc)\n       pending_local_decls = *ptr;\n       *ptr = NULL_TREE;\n \n-      /* Force non-nested range to be nested in current range. */\n+      /* Force non-nested range to be nested in current range by\n+\t truncating variable lifetimes. */\n       if (end_pc > current_binding_level->end_pc)\n-\tend_pc = current_binding_level->end_pc;\n+\t{\n+\t  end_pc = current_binding_level->end_pc;\n+\t  DECL_LOCAL_END_PC (decl) = end_pc;\n+\t}\n \n       maybe_start_try (pc, end_pc);\n       \n@@ -1512,6 +1628,8 @@ maybe_pushlevels (int pc)\n \t{\n \t  next = TREE_CHAIN (decl);\n \t  push_jvm_slot (DECL_LOCAL_SLOT_NUMBER (decl), decl);\n+\t  pushdecl (decl);\n+\t  initialize_local_variable (decl, DECL_LOCAL_SLOT_NUMBER (decl));\n \t}\n     }      \n \n@@ -1698,11 +1816,14 @@ start_java_method (tree fndecl)\n   tree tem, *ptr;\n   int i;\n \n+  uniq = 0;\n+\n   current_function_decl = fndecl;\n   announce_function (fndecl);\n \n   i = DECL_MAX_LOCALS(fndecl) + DECL_MAX_STACK(fndecl);\n   decl_map = make_tree_vec (i);\n+  base_decl_map = make_tree_vec (i);\n   type_map = xrealloc (type_map, i * sizeof (tree));\n \n #if defined(DEBUG_JAVA_BINDING_LEVELS)\n@@ -1751,6 +1872,8 @@ start_java_method (tree fndecl)\n \n   /* Push local variables.  */\n   pushlevel (2);\n+\n+  function_binding_level = current_binding_level;\n }\n \n void\n@@ -1769,6 +1892,14 @@ end_java_method (void)\n   flag_unit_at_a_time = 0;\n   finish_method (fndecl);\n \n+  if (! flag_unit_at_a_time)\n+    {\n+      /* Nulling these fields when we no longer need them saves\n+\t memory.  */\n+      DECL_SAVED_TREE (fndecl) = NULL;\n+      DECL_STRUCT_FUNCTION (fndecl) = NULL;\n+      DECL_INITIAL (fndecl) = NULL_TREE;\n+    }\n   if (! flag_unit_at_a_time)\n     {\n       /* Nulling these fields when we no longer need them saves"}, {"sha": "73e3e8106de9316a7e05c3a5bc83007d22c8cc0e", "filename": "gcc/java/expr.c", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=00150bf9f31d6a0ec576ead73a315f26b1c31749", "patch": "@@ -255,6 +255,9 @@ push_type_0 (tree type)\n   n_words = 1 + TYPE_IS_WIDE (type);\n   if (stack_pointer + n_words > DECL_MAX_STACK (current_function_decl))\n     return 0;\n+  /* Allocate decl for this variable now, so we get a temporary that\n+     survives the whole method. */\n+  find_stack_slot (stack_pointer, type);\n   stack_type_map[stack_pointer++] = type;\n   n_words--;\n   while (--n_words >= 0)\n@@ -368,7 +371,7 @@ pop_type (tree type)\n   return type;\n }\n \n-/* Return 1f if SOURCE_TYPE can be safely widened to TARGET_TYPE.\n+/* Return 1 if SOURCE_TYPE can be safely widened to TARGET_TYPE.\n    Handles array types and interfaces.  */\n \n int\n@@ -1289,7 +1292,7 @@ expand_iinc (unsigned int local_var_index, int ival, int pc)\n   constant_value = build_int_2 (ival, ival < 0 ? -1 : 0);\n   res = fold (build2 (PLUS_EXPR, int_type_node, local_var, constant_value));\n   java_add_stmt (build2 (MODIFY_EXPR, TREE_TYPE (local_var), local_var, res));\n-  update_aliases (local_var, local_var_index);\n+  update_aliases (local_var, local_var_index, pc);\n }\n \n       \n@@ -2758,7 +2761,8 @@ process_jvm_instruction (int PC, const unsigned char* byte_ops,\n   {\t\t\t\t\t\t\t\t\t\\\n     int saw_index = 0;\t\t\t\t\t\t\t\\\n     int index     = OPERAND_VALUE;\t\t\t\t\t\\\n-    build_java_ret (find_local_variable (index, ptr_type_node, oldpc));\t\\\n+    build_java_ret\t\t\t\t\t\t\t\\\n+      (find_local_variable (index, return_address_type_node, oldpc));\t\\\n   }\n \n #define JSR(OPERAND_TYPE, OPERAND_VALUE) \\\n@@ -2937,7 +2941,7 @@ process_jvm_instruction (int PC, const unsigned char* byte_ops,\n     decl = find_local_variable (index, type, oldpc);\t\t\\\n     set_local_type (index, type);\t\t\t\t\\\n     java_add_stmt (build2 (MODIFY_EXPR, type, decl, value));\t\\\n-    update_aliases (decl, index);\t\t\t\t\\\n+    update_aliases (decl, index, PC);\t\t\t\t\\\n   }\n \n #define STORE(OPERAND_TYPE, OPERAND_VALUE) \\"}, {"sha": "eb277f8caec8e0ce58928652c3bc2388a956906f", "filename": "gcc/java/java-gimplify.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=00150bf9f31d6a0ec576ead73a315f26b1c31749", "patch": "@@ -37,6 +37,7 @@ static tree java_gimplify_default_expr (tree);\n static tree java_gimplify_block (tree);\n static tree java_gimplify_new_array_init (tree);\n static tree java_gimplify_try_expr (tree);\n+static tree java_gimplify_modify_expr (tree);\n \n static void dump_java_tree (enum tree_dump_index, tree);\n \n@@ -117,6 +118,21 @@ java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n       *expr_p = build_exception_object_ref (TREE_TYPE (*expr_p));\n       break;\n \n+    case VAR_DECL:\n+      *expr_p = java_replace_reference (*expr_p, /* want_lvalue */ false);\n+      return GS_UNHANDLED;\n+\n+    case MODIFY_EXPR:\n+      *expr_p = java_gimplify_modify_expr (*expr_p);\n+      return GS_UNHANDLED;\n+\n+    case SAVE_EXPR:\n+      if (TREE_CODE (TREE_OPERAND (*expr_p, 0)) == VAR_DECL)\n+\tTREE_OPERAND (*expr_p, 0) \n+\t  = java_replace_reference (TREE_OPERAND (*expr_p, 0), \n+\t\t\t       /* want_lvalue */ false);\n+      return GS_UNHANDLED;\n+\n     /* These should already be lowered before we get here.  */\n     case URSHIFT_EXPR:\n     case COMPARE_EXPR:\n@@ -140,6 +156,33 @@ java_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n   return GS_OK;\n }\n \n+/* This is specific to the bytecode compiler.  If a variable has\n+   LOCAL_SLOT_P set, replace an assignment to it with an assignment to\n+   the corresponding variable that holds all its aliases.  */\n+\n+static tree\n+java_gimplify_modify_expr (tree modify_expr)\n+{\n+  tree lhs = TREE_OPERAND (modify_expr, 0);\n+  tree rhs = TREE_OPERAND (modify_expr, 1);\n+  tree lhs_type = TREE_TYPE (lhs);\n+  \n+  if (TREE_CODE (lhs) == VAR_DECL\n+      && DECL_LANG_SPECIFIC (lhs)\n+      && LOCAL_SLOT_P (lhs)\n+      && TREE_CODE (lhs_type) == POINTER_TYPE)\n+    {\n+      tree new_lhs = java_replace_reference (lhs, /* want_lvalue */ true);\n+      tree new_rhs = build1 (NOP_EXPR, TREE_TYPE (new_lhs), rhs);\n+      modify_expr = build (MODIFY_EXPR, TREE_TYPE (new_lhs),\n+\t\t\t   new_lhs, new_rhs);\n+      modify_expr = build1 (NOP_EXPR, lhs_type, modify_expr);\n+    }\n+  \n+  return modify_expr;\n+}\n+\n+    \n static tree\n java_gimplify_case_expr (tree expr)\n {"}, {"sha": "44a2ed96273003c11e337ff5f3863545626465de", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=00150bf9f31d6a0ec576ead73a315f26b1c31749", "patch": "@@ -925,6 +925,8 @@ union lang_tree_node\n /* True if NODE is a variable that is out of scope.  */\n #define LOCAL_VAR_OUT_OF_SCOPE_P(NODE) \\\n     (DECL_LANG_SPECIFIC (NODE)->u.v.freed)\n+#define LOCAL_SLOT_P(NODE) \\\n+    (DECL_LANG_SPECIFIC (NODE)->u.v.local_slot)\n /* Create a DECL_LANG_SPECIFIC if necessary. */\n #define MAYBE_CREATE_VAR_LANG_DECL_SPECIFIC(T)\t\t\t\\\n   if (DECL_LANG_SPECIFIC (T) == NULL)\t\t\t\t\\\n@@ -1010,7 +1012,8 @@ struct lang_decl_var GTY(())\n   tree owner;\n   unsigned int final_iud : 1;\t/* Final initialized upon declaration */\n   unsigned int cif : 1;\t\t/* True: decl is a class initialization flag */\n-  unsigned int freed;\t\t/* Decl is no longer in scope.  */\n+  unsigned int freed : 1;\t\t/* Decl is no longer in scope.  */\n+  unsigned int local_slot : 1;\t/* Decl is a temporary in the stack frame.  */\n };\n \n /* This is what 'lang_decl' really points to.  */\n@@ -1176,7 +1179,7 @@ extern void set_java_signature (tree, tree);\n extern tree build_static_field_ref (tree);\n extern tree build_address_of (tree);\n extern tree find_local_variable (int index, tree type, int pc);\n-extern void update_aliases (tree decl, int index);\n+extern void update_aliases (tree decl, int index, int pc);\n extern tree find_stack_slot (int index, tree type);\n extern tree build_prim_array_type (tree, HOST_WIDE_INT);\n extern tree build_java_array_type (tree, HOST_WIDE_INT);\n@@ -1254,6 +1257,8 @@ extern void java_layout_seen_class_methods (void);\n extern void check_for_initialization (tree, tree);\n \n extern tree pushdecl_top_level (tree);\n+extern tree pushdecl_function_level (tree);\n+extern tree java_replace_reference (tree, bool);\n extern int alloc_class_constant (tree);\n extern void init_expr_processing (void);\n extern void push_super_field (tree, tree);"}, {"sha": "5c38bb842bf7ccae0a674515cfcba579fc1a044e", "filename": "gcc/java/typeck.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Ftypeck.c?ref=00150bf9f31d6a0ec576ead73a315f26b1c31749", "patch": "@@ -391,9 +391,17 @@ build_java_array_type (tree element_type, HOST_WIDE_INT length)\n   el_name = TYPE_NAME (el_name);\n   if (TREE_CODE (el_name) == TYPE_DECL)\n     el_name = DECL_NAME (el_name);\n-  TYPE_NAME (t) = build_decl (TYPE_DECL,\n-                             identifier_subst (el_name, \"\", '.', '.', \"[]\"),\n+  {\n+    char suffix[12];\n+    if (length >= 0)\n+      sprintf (suffix, \"[%d]\", (int)length); \n+    else\n+      strcpy (suffix, \"[]\");\n+    TYPE_NAME (t) \n+      = build_decl (TYPE_DECL,\n+\t\t    identifier_subst (el_name, \"\", '.', '.', suffix),\n                              t);\n+  }\n \n   set_java_signature (t, sig);\n   set_super_info (0, t, object_type_node, 0);"}, {"sha": "89b9d95bd57056eba8ee039a68bec0119478d12f", "filename": "gcc/java/verify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Fverify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00150bf9f31d6a0ec576ead73a315f26b1c31749/gcc%2Fjava%2Fverify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fverify.c?ref=00150bf9f31d6a0ec576ead73a315f26b1c31749", "patch": "@@ -734,8 +734,8 @@ verify_jvm_instructions (JCF* jcf, const unsigned char *byte_ops, long length)\n         handlers.  */\n \tprev_eh_ranges = NULL_EH_RANGE;\n \n-\t/* Allocate decl and rtx for this variable now, so if we're not\n-\t   optimizing, we get a temporary that survives the whole method.  */\n+\t/* Allocate decl for this variable now, so we get a temporary\n+! \t   that survives the whole method. */\n \tfind_local_variable (index, type, oldpc);\n \n         if (TYPE_IS_WIDE (type))"}]}