{"sha": "afc1ab6196fd6b3f96da19b5859929ec70d8c4dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZjMWFiNjE5NmZkNmIzZjk2ZGExOWI1ODU5OTI5ZWM3MGQ4YzRkYw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-06-29T18:13:27Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-06-29T18:13:27Z"}, "message": "tree-vect-transform.c (vect_min_worthwhile_factor): Declare.\n\n        * tree-vect-transform.c (vect_min_worthwhile_factor): Declare.\n        (vect_create_epilog_for_reduction): Don't use vec_shr if the\n        operation is emulated.\n        (vectorizable_reduction): Duplicate vect_min_worthwhile_factor\n        tests from vectorizable_operation.\n\nFrom-SVN: r101433", "tree": {"sha": "21e4e4b0f66cf9b9e02db590e6dd2170c1cf352f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21e4e4b0f66cf9b9e02db590e6dd2170c1cf352f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afc1ab6196fd6b3f96da19b5859929ec70d8c4dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc1ab6196fd6b3f96da19b5859929ec70d8c4dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afc1ab6196fd6b3f96da19b5859929ec70d8c4dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afc1ab6196fd6b3f96da19b5859929ec70d8c4dc/comments", "author": null, "committer": null, "parents": [{"sha": "affb0e06f4c928c65c0216d8a4ce4c8f9e9c272a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/affb0e06f4c928c65c0216d8a4ce4c8f9e9c272a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/affb0e06f4c928c65c0216d8a4ce4c8f9e9c272a"}], "stats": {"total": 39, "additions": 39, "deletions": 0}, "files": [{"sha": "9849127504978f180f7c2df3aef1ab5d46b1e407", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc1ab6196fd6b3f96da19b5859929ec70d8c4dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc1ab6196fd6b3f96da19b5859929ec70d8c4dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=afc1ab6196fd6b3f96da19b5859929ec70d8c4dc", "patch": "@@ -1,3 +1,11 @@\n+2005-06-29  Richard Henderson  <rth@redhat.com>\n+\n+\t* tree-vect-transform.c (vect_min_worthwhile_factor): Declare.\n+\t(vect_create_epilog_for_reduction): Don't use vec_shr if the\n+\toperation is emulated.\n+\t(vectorizable_reduction): Duplicate vect_min_worthwhile_factor\n+\ttests from vectorizable_operation.\n+\n 2005-06-29  Caroline Tice  <ctice@apple.com>\n \n \tFix PR 21956"}, {"sha": "2929bdb897ead1be1de4e6824e7749ef8985fa5c", "filename": "gcc/tree-vect-transform.c", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afc1ab6196fd6b3f96da19b5859929ec70d8c4dc/gcc%2Ftree-vect-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afc1ab6196fd6b3f96da19b5859929ec70d8c4dc/gcc%2Ftree-vect-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-transform.c?ref=afc1ab6196fd6b3f96da19b5859929ec70d8c4dc", "patch": "@@ -72,6 +72,7 @@ static void vect_update_inits_of_drs (loop_vec_info, tree);\n static void vect_do_peeling_for_alignment (loop_vec_info, struct loops *);\n static void vect_do_peeling_for_loop_bound \n   (loop_vec_info, tree *, struct loops *);\n+static int vect_min_worthwhile_factor (enum tree_code);\n \n \n /* Function vect_get_new_vect_var.\n@@ -940,6 +941,21 @@ vect_create_epilog_for_reduction (tree vect_def, tree stmt, tree reduction_op,\n       else\n \thave_whole_vector_shift = false;\n \n+      /* Regardless of whether we have a whole vector shift, if we're\n+\t emulating the operation via tree-vect-generic, we don't want\n+\t to use it.  Only the first round of the reduction is likely\n+\t to still be profitable via emulation.  */\n+      /* ??? It might be better to emit a reduction tree code here, so that\n+\t tree-vect-generic can expand the first round via bit tricks.  */\n+      if (!VECTOR_MODE_P (mode))\n+\thave_whole_vector_shift = false;\n+      else\n+\t{\n+\t  optab optab = optab_for_tree_code (code, vectype);\n+\t  if (optab->handlers[mode].insn_code == CODE_FOR_nothing)\n+\t    have_whole_vector_shift = false;\n+\t}\n+\n       if (have_whole_vector_shift)\n         {\n \t  /*** Case 2:\n@@ -1211,6 +1227,21 @@ vectorizable_reduction (tree stmt, block_stmt_iterator *bsi, tree *vec_stmt)\n     {\n       if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n         fprintf (vect_dump, \"op not supported by target.\");\n+      if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n+          || LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t     < vect_min_worthwhile_factor (code))\n+        return false;\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"proceeding using word mode.\");\n+    }\n+\n+  /* Worthwhile without SIMD support?  */\n+  if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n+      && LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n+\t < vect_min_worthwhile_factor (code))\n+    {\n+      if (vect_print_dump_info (REPORT_DETAILS, UNKNOWN_LOC))\n+\tfprintf (vect_dump, \"not worthwhile without SIMD support.\");\n       return false;\n     }\n "}]}