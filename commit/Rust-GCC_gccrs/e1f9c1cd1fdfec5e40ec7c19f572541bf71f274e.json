{"sha": "e1f9c1cd1fdfec5e40ec7c19f572541bf71f274e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmOWMxY2QxZmRmZWM1ZTQwZWM3YzE5ZjU3MjU0MWJmNzFmMjc0ZQ==", "commit": {"author": {"name": "Tobias Grosser", "email": "grosser@fim.uni-passau.de", "date": "2009-11-30T22:06:54Z"}, "committer": {"name": "Tobias Grosser", "email": "grosser@gcc.gnu.org", "date": "2009-11-30T22:06:54Z"}, "message": "split translate_clast into single methods\n\n2009-11-23  Tobias Grosser  <grosser@fim.uni-passau.de>\n\n\t* graphite-clast-to-gimple.c (translate_clast_user,\n\ttranslate_clast_for, translate_clast_guard): Split out of\n\ttranslate_clast.\n\nFrom-SVN: r154845", "tree": {"sha": "36a599e231305856f0a21d0be7f39d30c4c678fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/36a599e231305856f0a21d0be7f39d30c4c678fd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1f9c1cd1fdfec5e40ec7c19f572541bf71f274e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f9c1cd1fdfec5e40ec7c19f572541bf71f274e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f9c1cd1fdfec5e40ec7c19f572541bf71f274e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f9c1cd1fdfec5e40ec7c19f572541bf71f274e/comments", "author": {"login": "tobiasgrosser", "id": 521960, "node_id": "MDQ6VXNlcjUyMTk2MA==", "avatar_url": "https://avatars.githubusercontent.com/u/521960?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tobiasgrosser", "html_url": "https://github.com/tobiasgrosser", "followers_url": "https://api.github.com/users/tobiasgrosser/followers", "following_url": "https://api.github.com/users/tobiasgrosser/following{/other_user}", "gists_url": "https://api.github.com/users/tobiasgrosser/gists{/gist_id}", "starred_url": "https://api.github.com/users/tobiasgrosser/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tobiasgrosser/subscriptions", "organizations_url": "https://api.github.com/users/tobiasgrosser/orgs", "repos_url": "https://api.github.com/users/tobiasgrosser/repos", "events_url": "https://api.github.com/users/tobiasgrosser/events{/privacy}", "received_events_url": "https://api.github.com/users/tobiasgrosser/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a521ff2fce2a365cf0e783ea33373f3b13b4b20", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a521ff2fce2a365cf0e783ea33373f3b13b4b20"}], "stats": {"total": 251, "additions": 158, "deletions": 93}, "files": [{"sha": "7de3ce2e15bb5f9fff7424d6c0ab74a478b7ac4c", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f9c1cd1fdfec5e40ec7c19f572541bf71f274e/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f9c1cd1fdfec5e40ec7c19f572541bf71f274e/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=e1f9c1cd1fdfec5e40ec7c19f572541bf71f274e", "patch": "@@ -1,3 +1,9 @@\n+2009-11-23  Tobias Grosser  <grosser@fim.uni-passau.de>\n+\n+\t* graphite-clast-to-gimple.c (translate_clast_user,\n+\ttranslate_clast_for, translate_clast_guard): Split out of\n+\ttranslate_clast.\n+\n 2009-11-21  Tobias Grosser  <grosser@fim.uni-passau.de>\n \n \t* graphite-clast-to-gimple.c (clast_name_index, new_clast_name_index,"}, {"sha": "c2fda8be0a566f53d8ea61b56a118aab0a1a4815", "filename": "gcc/graphite-clast-to-gimple.c", "status": "modified", "additions": 152, "deletions": 93, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f9c1cd1fdfec5e40ec7c19f572541bf71f274e/gcc%2Fgraphite-clast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f9c1cd1fdfec5e40ec7c19f572541bf71f274e/gcc%2Fgraphite-clast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-clast-to-gimple.c?ref=e1f9c1cd1fdfec5e40ec7c19f572541bf71f274e", "patch": "@@ -718,20 +718,157 @@ dependency_in_loop_p (loop_p loop, htab_t bb_pbb_mapping, int level)\n   return false;\n }\n \n-/* Translates a CLAST statement STMT to GCC representation in the\n-   context of a SESE.\n+static edge\n+translate_clast (sese, loop_p, struct clast_stmt *, edge, htab_t,\n+\t\t VEC (tree, heap) **, htab_t, htab_t, int, htab_t);\n \n+/* Translates a clast user statement STMT to gimple.\n+\n+   - REGION is the sese region we used to generate the scop.\n    - NEXT_E is the edge where new generated code should be attached.\n    - CONTEXT_LOOP is the loop in which the generated code will be placed\n    - RENAME_MAP contains a set of tuples of new names associated to\n      the original variables names.\n    - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n-*/\n+   - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n+     the sese region.  */\n+static edge\n+translate_clast_user (sese region, struct loop *context_loop,\n+\t\t      struct clast_stmt *stmt, edge next_e,\n+\t\t      htab_t rename_map, VEC (tree, heap) **newivs,\n+\t\t      htab_t newivs_index, htab_t bb_pbb_mapping, int level,\n+\t\t      htab_t params_index)\n+{\n+  gimple_bb_p gbb;\n+  basic_block new_bb;\n+  CloogStatement *cs = ((struct clast_user_stmt*) stmt)->statement;\n+  poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);\n+  gbb = PBB_BLACK_BOX (pbb);\n+\n+  if (GBB_BB (gbb) == ENTRY_BLOCK_PTR)\n+    return next_e;\n+\n+  build_iv_mapping (rename_map, region, *newivs, newivs_index,\n+\t\t    (struct clast_user_stmt*) stmt, params_index);\n+  next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb), region,\n+\t\t\t\t\t   next_e, rename_map);\n+  new_bb = next_e->src;\n+  mark_bb_with_pbb (pbb, new_bb, bb_pbb_mapping);\n+  recompute_all_dominators ();\n+  update_ssa (TODO_update_ssa);\n+  graphite_verify ();\n+  return translate_clast (region, context_loop, stmt->next, next_e,\n+\t\t\t  rename_map, newivs, newivs_index,\n+\t\t\t  bb_pbb_mapping, level, params_index);\n+}\n+\n+/* Translates a clast for statement STMT to gimple.\n+\n+   - REGION is the sese region we used to generate the scop.\n+   - NEXT_E is the edge where new generated code should be attached.\n+   - CONTEXT_LOOP is the loop in which the generated code will be placed\n+   - RENAME_MAP contains a set of tuples of new names associated to\n+     the original variables names.\n+   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n+   - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n+     the sese region.  */\n+static edge\n+translate_clast_for (sese region, loop_p context_loop, struct clast_stmt *stmt,\n+\t\t     edge next_e, htab_t rename_map, VEC (tree, heap) **newivs,\n+\t\t     htab_t newivs_index, htab_t bb_pbb_mapping, int level,\n+\t\t     htab_t params_index)\n+{\n+  struct clast_for *stmtfor = (struct clast_for *)stmt;\n+  struct loop *loop\n+    = graphite_create_new_loop (region, next_e, stmtfor,\n+\t\t\t\tcontext_loop, newivs, newivs_index,\n+\t\t\t\tparams_index);\n+  edge last_e = single_exit (loop);\n+  edge to_body = single_succ_edge (loop->header);\n+  basic_block after = to_body->dest;\n+\n+  /* Create a basic block for loop close phi nodes.  */\n+  last_e = single_succ_edge (split_edge (last_e));\n+\n+  /* Translate the body of the loop.  */\n+  next_e = translate_clast\n+    (region, loop, ((struct clast_for *) stmt)->body,\n+     single_succ_edge (loop->header), rename_map, newivs,\n+     newivs_index, bb_pbb_mapping, level + 1, params_index);\n+  redirect_edge_succ_nodup (next_e, after);\n+  set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n+\n+  /* Remove from rename_map all the tuples containing variables\n+     defined in loop's body.  */\n+  insert_loop_close_phis (rename_map, loop);\n+\n+  if (flag_loop_parallelize_all\n+      && !dependency_in_loop_p (loop, bb_pbb_mapping,\n+\t\t\t\tget_scattering_level (level)))\n+    loop->can_be_parallel = true;\n+\n+  recompute_all_dominators ();\n+  graphite_verify ();\n+  return translate_clast (region, context_loop, stmt->next, last_e,\n+\t\t\t  rename_map, newivs, newivs_index,\n+\t\t\t  bb_pbb_mapping, level, params_index);\n+}\n+\n+/* Translates a clast guard statement STMT to gimple.\n+\n+   - REGION is the sese region we used to generate the scop.\n+   - NEXT_E is the edge where new generated code should be attached.\n+   - CONTEXT_LOOP is the loop in which the generated code will be placed\n+   - RENAME_MAP contains a set of tuples of new names associated to\n+     the original variables names.\n+   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.\n+   - PARAMS_INDEX connects the cloog parameters with the gimple parameters in\n+     the sese region.  */\n+static edge\n+translate_clast_guard (sese region, loop_p context_loop,\n+\t\t       struct clast_stmt *stmt, edge next_e, htab_t rename_map,\n+\t\t       VEC (tree, heap) **newivs, htab_t newivs_index,\n+\t\t       htab_t bb_pbb_mapping, int level, htab_t params_index)\n+{\n+  edge last_e = graphite_create_new_guard (region, next_e,\n+\t\t\t\t\t   ((struct clast_guard *) stmt),\n+\t\t\t\t\t   *newivs, newivs_index,\n+\t\t\t\t\t   params_index);\n+  edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n+  edge false_e = get_false_edge_from_guard_bb (next_e->dest);\n+  edge exit_true_e = single_succ_edge (true_e->dest);\n+  edge exit_false_e = single_succ_edge (false_e->dest);\n+  htab_t before_guard = htab_create (10, rename_map_elt_info,\n+\t\t\t\t     eq_rename_map_elts, free);\n+\n+  htab_traverse (rename_map, copy_renames, before_guard);\n+  next_e = translate_clast (region, context_loop,\n+\t\t\t    ((struct clast_guard *) stmt)->then,\n+\t\t\t    true_e, rename_map, newivs, newivs_index,\n+\t\t\t    bb_pbb_mapping, level, params_index);\n+  insert_guard_phis (last_e->src, exit_true_e, exit_false_e,\n+\t\t     before_guard, rename_map);\n+\n+  htab_delete (before_guard);\n+  recompute_all_dominators ();\n+  graphite_verify ();\n+\n+  return translate_clast (region, context_loop, stmt->next, last_e,\n+\t\t\t  rename_map, newivs, newivs_index,\n+\t\t\t  bb_pbb_mapping, level, params_index);\n+}\n+\n+/* Translates a CLAST statement STMT to GCC representation in the\n+   context of a SESE.\n \n+   - NEXT_E is the edge where new generated code should be attached.\n+   - CONTEXT_LOOP is the loop in which the generated code will be placed\n+   - RENAME_MAP contains a set of tuples of new names associated to\n+     the original variables names.\n+   - BB_PBB_MAPPING is is a basic_block and it's related poly_bb_p mapping.  */\n static edge\n-translate_clast (sese region, struct loop *context_loop,\n-\t\t struct clast_stmt *stmt, edge next_e,\n-\t\t htab_t rename_map, VEC (tree, heap) **newivs,\n+translate_clast (sese region, loop_p context_loop, struct clast_stmt *stmt,\n+\t\t edge next_e, htab_t rename_map, VEC (tree, heap) **newivs,\n \t\t htab_t newivs_index, htab_t bb_pbb_mapping, int level,\n \t\t htab_t params_index)\n {\n@@ -744,97 +881,19 @@ translate_clast (sese region, struct loop *context_loop,\n \t\t\t    bb_pbb_mapping, level, params_index);\n \n   if (CLAST_STMT_IS_A (stmt, stmt_user))\n-    {\n-      gimple_bb_p gbb;\n-      basic_block new_bb;\n-      CloogStatement *cs = ((struct clast_user_stmt *) stmt)->statement;\n-      poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);\n-      gbb = PBB_BLACK_BOX (pbb);\n-\n-      if (GBB_BB (gbb) == ENTRY_BLOCK_PTR)\n-\treturn next_e;\n-\n-      build_iv_mapping (rename_map, region, *newivs, newivs_index,\n-\t\t\t(struct clast_user_stmt *) stmt, params_index);\n-      next_e = copy_bb_and_scalar_dependences (GBB_BB (gbb), region,\n-\t\t\t\t\t       next_e, rename_map);\n-      new_bb = next_e->src;\n-      mark_bb_with_pbb (pbb, new_bb, bb_pbb_mapping);\n-      recompute_all_dominators ();\n-      update_ssa (TODO_update_ssa);\n-      graphite_verify ();\n-      return translate_clast (region, context_loop, stmt->next, next_e,\n-\t\t\t      rename_map, newivs, newivs_index,\n-\t\t\t      bb_pbb_mapping, level, params_index);\n-    }\n+    return translate_clast_user (region, context_loop, stmt, next_e,\n+\t\t\t\t rename_map, newivs, newivs_index,\n+\t\t\t\t bb_pbb_mapping, level, params_index);\n \n   if (CLAST_STMT_IS_A (stmt, stmt_for))\n-    {\n-      struct clast_for *stmtfor = (struct clast_for *)stmt;\n-      struct loop *loop\n-\t= graphite_create_new_loop (region, next_e, stmtfor,\n-\t\t\t\t    context_loop, newivs, newivs_index,\n-\t\t\t\t    params_index);\n-      edge last_e = single_exit (loop);\n-      edge to_body = single_succ_edge (loop->header);\n-      basic_block after = to_body->dest;\n-\n-      /* Create a basic block for loop close phi nodes.  */\n-      last_e = single_succ_edge (split_edge (last_e));\n-\n-      /* Translate the body of the loop.  */\n-      next_e = translate_clast\n-\t(region, loop, ((struct clast_for *) stmt)->body,\n-\t single_succ_edge (loop->header), rename_map, newivs,\n-\t newivs_index, bb_pbb_mapping, level + 1, params_index);\n-      redirect_edge_succ_nodup (next_e, after);\n-      set_immediate_dominator (CDI_DOMINATORS, next_e->dest, next_e->src);\n-\n-      /* Remove from rename_map all the tuples containing variables\n-\t defined in loop's body.  */\n-      insert_loop_close_phis (rename_map, loop);\n-\n-      if (flag_loop_parallelize_all\n-\t  && !dependency_in_loop_p (loop, bb_pbb_mapping,\n-\t\t\t\t    get_scattering_level (level)))\n-\tloop->can_be_parallel = true;\n-\n-      recompute_all_dominators ();\n-      graphite_verify ();\n-      return translate_clast (region, context_loop, stmt->next, last_e,\n-\t\t\t      rename_map, newivs, newivs_index,\n-\t\t\t      bb_pbb_mapping, level, params_index);\n-    }\n-\n-  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n-    {\n-      edge last_e = graphite_create_new_guard (region, next_e,\n-\t\t\t\t\t       ((struct clast_guard *) stmt),\n-\t\t\t\t\t       *newivs, newivs_index,\n-\t\t\t\t\t       params_index);\n-      edge true_e = get_true_edge_from_guard_bb (next_e->dest);\n-      edge false_e = get_false_edge_from_guard_bb (next_e->dest);\n-      edge exit_true_e = single_succ_edge (true_e->dest);\n-      edge exit_false_e = single_succ_edge (false_e->dest);\n-      htab_t before_guard = htab_create (10, rename_map_elt_info,\n-\t\t\t\t\t eq_rename_map_elts, free);\n-\n-      htab_traverse (rename_map, copy_renames, before_guard);\n-      next_e = translate_clast (region, context_loop,\n-\t\t\t\t((struct clast_guard *) stmt)->then,\n-\t\t\t\ttrue_e, rename_map, newivs, newivs_index,\n+    return translate_clast_for (region, context_loop, stmt, next_e,\n+\t\t\t\trename_map, newivs, newivs_index,\n \t\t\t\tbb_pbb_mapping, level, params_index);\n-      insert_guard_phis (last_e->src, exit_true_e, exit_false_e,\n-\t\t\t before_guard, rename_map);\n-\n-      htab_delete (before_guard);\n-      recompute_all_dominators ();\n-      graphite_verify ();\n \n-      return translate_clast (region, context_loop, stmt->next, last_e,\n-\t\t\t      rename_map, newivs, newivs_index,\n-\t\t\t      bb_pbb_mapping, level, params_index);\n-    }\n+  if (CLAST_STMT_IS_A (stmt, stmt_guard))\n+    return translate_clast_guard (region, context_loop, stmt, next_e,\n+\t\t\t\t  rename_map, newivs, newivs_index,\n+\t\t\t\t  bb_pbb_mapping, level, params_index);\n \n   if (CLAST_STMT_IS_A (stmt, stmt_block))\n     {"}]}