{"sha": "f2662b08c72e8b3bdd130409bd553cd4eb85a94b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjI2NjJiMDhjNzJlOGIzYmRkMTMwNDA5YmQ1NTNjZDRlYjg1YTk0Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-24T12:06:34Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-09-24T12:06:34Z"}, "message": "(struct directive, directive_table, handle_directive): pass_thru now 1 for #define and 2 for #pragma.\n\n(struct directive, directive_table, handle_directive): pass_thru now 1 for\n#define and 2 for #pragma.\n(handle_directive): When deciding whether to suppress comment at end of\ndirective, ignore tabs and spaces after comment.  Remove redundant limit test.\nWith -dD -C, copy comment when isolating definition.\n(skip_to_end_of_comment): With -C, don't copy newline at end of C++ comment.\n\nFrom-SVN: r12831", "tree": {"sha": "a8987646374d33a7c2ef323903c9b73b670a9662", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a8987646374d33a7c2ef323903c9b73b670a9662"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f2662b08c72e8b3bdd130409bd553cd4eb85a94b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2662b08c72e8b3bdd130409bd553cd4eb85a94b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2662b08c72e8b3bdd130409bd553cd4eb85a94b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2662b08c72e8b3bdd130409bd553cd4eb85a94b/comments", "author": null, "committer": null, "parents": [{"sha": "2dbb8078bf1a26e87a1c1ba350c4a4dedf4bbe4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dbb8078bf1a26e87a1c1ba350c4a4dedf4bbe4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dbb8078bf1a26e87a1c1ba350c4a4dedf4bbe4c"}], "stats": {"total": 33, "additions": 19, "deletions": 14}, "files": [{"sha": "7d6f3f503df10f429186567b2c2a2b8f657b9d81", "filename": "gcc/cccp.c", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f2662b08c72e8b3bdd130409bd553cd4eb85a94b/gcc%2Fcccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f2662b08c72e8b3bdd130409bd553cd4eb85a94b/gcc%2Fcccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcccp.c?ref=f2662b08c72e8b3bdd130409bd553cd4eb85a94b", "patch": "@@ -954,7 +954,9 @@ struct directive {\n   enum node_type type;\t\t/* Code which describes which directive.  */\n   char angle_brackets;\t\t/* Nonzero => <...> is special.  */\n   char traditional_comments;\t/* Nonzero: keep comments if -traditional.  */\n-  char pass_thru;\t\t/* Copy preprocessed directive to output file.  */\n+  char pass_thru;\t\t/* Copy directive to output:\n+\t\t\t\t   if 1, copy if dumping definitions;\n+\t\t\t\t   if 2, always copy, after preprocessing.  */\n };\n \n /* These functions are declared to return int instead of void since they\n@@ -983,7 +985,7 @@ static int do_xifdef DO_PROTO;\n /* Here is the actual list of #-directives, most-often-used first.  */\n \n static struct directive directive_table[] = {\n-  {  6, do_define, \"define\", T_DEFINE, 0, 1},\n+  {  6, do_define, \"define\", T_DEFINE, 0, 1, 1},\n   {  2, do_if, \"if\", T_IF},\n   {  5, do_xifdef, \"ifdef\", T_IFDEF},\n   {  6, do_xifdef, \"ifndef\", T_IFNDEF},\n@@ -1000,7 +1002,7 @@ static struct directive directive_table[] = {\n #ifdef SCCS_DIRECTIVE\n   {  4, do_sccs, \"sccs\", T_SCCS},\n #endif\n-  {  6, do_pragma, \"pragma\", T_PRAGMA, 0, 0, 1},\n+  {  6, do_pragma, \"pragma\", T_PRAGMA, 0, 0, 2},\n   {  5, do_ident, \"ident\", T_IDENT},\n   {  6, do_assert, \"assert\", T_ASSERT},\n   {  8, do_unassert, \"unassert\", T_UNASSERT},\n@@ -3776,9 +3778,14 @@ handle_directive (ip, op)\n \t    bp = ip->bufp;\n \t    /* No need to copy the directive because of a comment at the end;\n \t       just don't include the comment in the directive.  */\n-\t    if (bp == limit || *bp == '\\n') {\n-\t      bp = obp;\n-\t      goto endloop1;\n+\t    if (!put_out_comments) {\n+\t      U_CHAR *p;\n+\t      for (p = bp;  *p == ' ' || *p == '\\t';  p++)\n+\t\tcontinue;\n+\t      if (*p == '\\n') {\n+\t\tbp = obp;\n+\t\tgoto endloop1;\n+\t      }\n \t    }\n \t    /* Don't remove the comments if -traditional.  */\n \t    if (! keep_comments)\n@@ -3809,7 +3816,8 @@ handle_directive (ip, op)\n \n       /* If a directive should be copied through, and -E was given,\n \t pass it through before removing comments.  */\n-      if (!no_output && kt->pass_thru && put_out_comments) {\n+      if (!no_output && put_out_comments\n+\t  && (dump_macros != dump_definitions) < kt->pass_thru) {\n         int len;\n \n \t/* Output directive name.  */\n@@ -3936,10 +3944,7 @@ handle_directive (ip, op)\n \t definitions through.  */\n \n       if (!no_output && already_output == 0\n-\t  && (kt->pass_thru\n-\t      || (kt->type == T_DEFINE\n-\t\t  && (dump_macros == dump_names\n-\t\t      || dump_macros == dump_definitions)))) {\n+\t  && (dump_macros < dump_names) < kt->pass_thru) {\n         int len;\n \n \t/* Output directive name.  */\n@@ -3948,7 +3953,7 @@ handle_directive (ip, op)\n         bcopy (kt->name, (char *) op->bufp, kt->length);\n         op->bufp += kt->length;\n \n-\tif (kt->pass_thru || dump_macros == dump_definitions) {\n+\tif ((dump_macros != dump_definitions) < kt->pass_thru) {\n \t  /* Output arguments.  */\n \t  len = (cp - buf);\n \t  check_expand (op, len);\n@@ -7577,8 +7582,6 @@ skip_to_end_of_comment (ip, line_counter, nowarn)\n   }\n   if (cplusplus_comments && bp[-1] == '/') {\n     for (; bp < limit; bp++) {\n-      if (op)\n-\t*op->bufp++ = *bp;\n       if (*bp == '\\n') {\n \tif (bp[-1] != '\\\\')\n \t  break;\n@@ -7589,6 +7592,8 @@ skip_to_end_of_comment (ip, line_counter, nowarn)\n \tif (op)\n \t  ++op->lineno;\n       }\n+      if (op)\n+\t*op->bufp++ = *bp;\n     }\n     ip->bufp = bp;\n     return bp;"}]}