{"sha": "7dab511cf3331378aaafdeb7676835c0cdb194fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RhYjUxMWNmMzMzMTM3OGFhYWZkZWI3Njc2ODM1YzBjZGIxOTRmYQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-12-23T18:36:07Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-12-23T18:36:07Z"}, "message": "mips: Improved vectorization support for Loongson and mips3d-ps.\n\n\t* config/mips/loongson.md (UNSPEC_LOONGSON_PINSR_0,\n\tUNSPEC_LOONGSON_PINSR_1, UNSPEC_LOONGSON_PINSR_2,\n\tUNSPEC_LOONGSON_PINSR_3): Replace with...\n\t(UNSPEC_LOONGSON_PINSRH): ... this.\n\t(UNSPEC_LOONGSON_VINIT): New.\n\t(UNSPEC_LOONGSON_DSLL, UNSPEC_LOONGSON_DSRL): New.\n\t(VWB): New mode iterator.\n\t(V_inner): New mode attribute.\n\t(loongson_vec_init1_<VHB>): New.\n\t(*vec_concatv2si): New.\n\t(and<VWHB>3, ior<VWHB>3, xor<VWHB>3, one_cmpl<VWHB>2): New.\n\t(*loongson_nor): New.\n\t(loongson_pextrh): Un-macro-ify.\n\t(loongson_pmaddhw): Likewise.\n\t(smaxv4hi3, umaxv8qi3, sminv4hi3, uminv8qi3): Likewise.\n\t(loongson_pinsrh_0): Represent with vec_select+vec_concat.\n\t(loongson_pinsrh_1, loongson_pinsrh_2, loongson_pinsrh_3): Likewise.\n\t(*vec_setv4hi, vec_setv4hi): New.\n\t(sdot_prodv4hi): New.\n\t(smax<VWB>3, smin<VWB>3): New.\n\t(reduc_uplus_v8qi): New.\n\t(loongson_pshufh): Remove destination matching input.\n\t(ashl<VWH>3, ashr<VWH>3, lshr<VWH>3): Fix type attribute.\n\t(vec_interleave_high<VWHB>, vec_interleave_low<VWHB>): Remove.\n\t(loongson_punpckhbh, loongson_punpckhhw, loongson_punpckhhw_qi,\n\tloongson_punpckhwd, loongson_punpckhwd_qi, loongson_punpckhwd_hi,\n\tloongson_punpcklbh, loongson_punpcklhw, loongson_punpcklhw_qi,\n\tloongson_punpcklwd, loongson_punpcklwd_qi, loongson_punpcklwd_hi,\n\tvec_perm_const<VWHB>, vec_unpacks_lo_<VHB>, vec_unpacks_hi_<VHB>,\n\tvec_unpacku_lo_<VHB>, vec_unpacku_hi_<VHB>, vec_shl_<VWHBDI>,\n\tvec_shr_<VWHBDI>, reduc_uplus_<VWH>, reduc_splus_<VWHB>,\n\treduc_smax_<VWHB>, reduc_smin_<VWHB>, reduc_umax_<VWHB>,\n\treduc_umin_<VB>): New.\n\t* config/mips/mips-ps-3d.md (vec_perm_const_ps): New.\n\t(mips_pul_ps, mips_puu_ps, mips_pll_ps, mips_plu_ps): Expand in\n\tterms of vec_perm_const_ps.\n\t(vec_perm_constv2sf): New.\n\t(vec_initv2sf): Use mips_expand_vector_init.\n\t(vec_concatv2sf): Rename from vec_initv2sf_internal.\n\t(vec_setv2sf): Use vec_perm_const_ps.\n\t(reduc_splus_v2sf, reduc_smin_v2sf, reduc_smax_v2sf): New.\n\t* config/mips/loongson.h (pshufh_u, pshufh_s): Don't pass dest to\n\tthe builtin.\n\t* config/mips/mips-modes.def (V16QI, V8HI, V4SI, V4SF): New modes.\n\t* config/mips/mips-protos.h: Update.\n\t* config/mips/mips.c (mips_get_arg_info): Match V2SFmode, not all\n\tMODE_VECTOR_FLOAT.\n\t(mips_return_mode_in_fpr_p): Likewise.\n\t(mips_cannot_change_mode_class): Allow 8-byte integral mode changes.\n\t(CODE_FOR_loongson_punpckhbh, CODE_FOR_loongson_punpckhhw,\n\tCODE_FOR_loongson_punpckhwd, CODE_FOR_loongson_punpcklbh,\n\tCODE_FOR_loongson_punpcklhw, CODE_FOR_loongson_punpcklwd): Remove.\n\t(mips_builtins): Remove first operand for loongson pshufh builtins.\n\t(MAX_VECT_LEN, struct expand_vec_perm_d): New.\n\t(mips_expand_vselect, mips_expand_vselect_vconcat,\n\tmips_expand_vpc_loongson_even_odd, mips_expand_vpc_loongson_pshufh,\n\tmips_expand_vpc_loongson_bcast, mips_expand_vec_perm_const_1,\n\tmips_expand_vec_perm_const, mips_vectorize_vec_perm_const_ok,\n\tmips_expand_vec_unpack, mips_constant_elt_p, mips_expand_vi_broadcast,\n\tmips_expand_vi_constant, mips_expand_vi_loongson_one_pinsrh,\n\tmips_expand_vi_general, mips_expand_vec_reduc, mips_expand_vec_minmax,\n\tTARGET_VECTORIZE_VEC_PERM_CONST_OK): New.\n\t(mips_expand_vector_init): Rewrite.\n\t* config/mips/predicates.md (const_2_or_3_operand): New.\n\t(const_0_to_3_operand): New.\n\nFrom-SVN: r182662", "tree": {"sha": "1c8d34b9a7912544993291860dd4418dbf708c2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1c8d34b9a7912544993291860dd4418dbf708c2d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7dab511cf3331378aaafdeb7676835c0cdb194fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dab511cf3331378aaafdeb7676835c0cdb194fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7dab511cf3331378aaafdeb7676835c0cdb194fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7dab511cf3331378aaafdeb7676835c0cdb194fa/comments", "author": null, "committer": null, "parents": [{"sha": "7a37d6eaff371edd55ca3f7d242565bbb14003ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a37d6eaff371edd55ca3f7d242565bbb14003ca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a37d6eaff371edd55ca3f7d242565bbb14003ca"}], "stats": {"total": 1656, "additions": 1461, "deletions": 195}, "files": [{"sha": "0a426765c7947446d61a880f19678a17fe22e6c1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7dab511cf3331378aaafdeb7676835c0cdb194fa", "patch": "@@ -1,3 +1,71 @@\n+2011-12-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* config/mips/loongson.md (UNSPEC_LOONGSON_PINSR_0,\n+\tUNSPEC_LOONGSON_PINSR_1, UNSPEC_LOONGSON_PINSR_2,\n+\tUNSPEC_LOONGSON_PINSR_3): Replace with...\n+\t(UNSPEC_LOONGSON_PINSRH): ... this.\n+\t(UNSPEC_LOONGSON_VINIT): New.\n+\t(UNSPEC_LOONGSON_DSLL, UNSPEC_LOONGSON_DSRL): New.\n+\t(VWB): New mode iterator.\n+\t(V_inner): New mode attribute.\n+\t(loongson_vec_init1_<VHB>): New.\n+\t(*vec_concatv2si): New.\n+\t(and<VWHB>3, ior<VWHB>3, xor<VWHB>3, one_cmpl<VWHB>2): New.\n+\t(*loongson_nor): New.\n+\t(loongson_pextrh): Un-macro-ify.\n+\t(loongson_pmaddhw): Likewise.\n+\t(smaxv4hi3, umaxv8qi3, sminv4hi3, uminv8qi3): Likewise.\n+\t(loongson_pinsrh_0): Represent with vec_select+vec_concat.\n+\t(loongson_pinsrh_1, loongson_pinsrh_2, loongson_pinsrh_3): Likewise.\n+\t(*vec_setv4hi, vec_setv4hi): New.\n+\t(sdot_prodv4hi): New.\n+\t(smax<VWB>3, smin<VWB>3): New.\n+\t(reduc_uplus_v8qi): New.\n+\t(loongson_pshufh): Remove destination matching input.\n+\t(ashl<VWH>3, ashr<VWH>3, lshr<VWH>3): Fix type attribute.\n+\t(vec_interleave_high<VWHB>, vec_interleave_low<VWHB>): Remove.\n+\t(loongson_punpckhbh, loongson_punpckhhw, loongson_punpckhhw_qi,\n+\tloongson_punpckhwd, loongson_punpckhwd_qi, loongson_punpckhwd_hi,\n+\tloongson_punpcklbh, loongson_punpcklhw, loongson_punpcklhw_qi,\n+\tloongson_punpcklwd, loongson_punpcklwd_qi, loongson_punpcklwd_hi,\n+\tvec_perm_const<VWHB>, vec_unpacks_lo_<VHB>, vec_unpacks_hi_<VHB>,\n+\tvec_unpacku_lo_<VHB>, vec_unpacku_hi_<VHB>, vec_shl_<VWHBDI>,\n+\tvec_shr_<VWHBDI>, reduc_uplus_<VWH>, reduc_splus_<VWHB>,\n+\treduc_smax_<VWHB>, reduc_smin_<VWHB>, reduc_umax_<VWHB>,\n+\treduc_umin_<VB>): New.\n+\t* config/mips/mips-ps-3d.md (vec_perm_const_ps): New.\n+\t(mips_pul_ps, mips_puu_ps, mips_pll_ps, mips_plu_ps): Expand in\n+\tterms of vec_perm_const_ps.\n+\t(vec_perm_constv2sf): New.\n+\t(vec_initv2sf): Use mips_expand_vector_init.\n+\t(vec_concatv2sf): Rename from vec_initv2sf_internal.\n+\t(vec_setv2sf): Use vec_perm_const_ps.\n+\t(reduc_splus_v2sf, reduc_smin_v2sf, reduc_smax_v2sf): New.\n+\t* config/mips/loongson.h (pshufh_u, pshufh_s): Don't pass dest to\n+\tthe builtin.\n+\t* config/mips/mips-modes.def (V16QI, V8HI, V4SI, V4SF): New modes.\n+\t* config/mips/mips-protos.h: Update.\n+\t* config/mips/mips.c (mips_get_arg_info): Match V2SFmode, not all\n+\tMODE_VECTOR_FLOAT.\n+\t(mips_return_mode_in_fpr_p): Likewise.\n+\t(mips_cannot_change_mode_class): Allow 8-byte integral mode changes.\n+\t(CODE_FOR_loongson_punpckhbh, CODE_FOR_loongson_punpckhhw,\n+\tCODE_FOR_loongson_punpckhwd, CODE_FOR_loongson_punpcklbh,\n+\tCODE_FOR_loongson_punpcklhw, CODE_FOR_loongson_punpcklwd): Remove.\n+\t(mips_builtins): Remove first operand for loongson pshufh builtins.\n+\t(MAX_VECT_LEN, struct expand_vec_perm_d): New.\n+\t(mips_expand_vselect, mips_expand_vselect_vconcat,\n+\tmips_expand_vpc_loongson_even_odd, mips_expand_vpc_loongson_pshufh,\n+\tmips_expand_vpc_loongson_bcast, mips_expand_vec_perm_const_1,\n+\tmips_expand_vec_perm_const, mips_vectorize_vec_perm_const_ok,\n+\tmips_expand_vec_unpack, mips_constant_elt_p, mips_expand_vi_broadcast,\n+\tmips_expand_vi_constant, mips_expand_vi_loongson_one_pinsrh,\n+\tmips_expand_vi_general, mips_expand_vec_reduc, mips_expand_vec_minmax,\n+\tTARGET_VECTORIZE_VEC_PERM_CONST_OK): New.\n+\t(mips_expand_vector_init): Rewrite.\n+\t* config/mips/predicates.md (const_2_or_3_operand): New.\n+\t(const_0_to_3_operand): New.\n+\n 2011-12-23  Dmitry Plotnikov  <dplotnikov@ispras.ru>\n \n \t* config/arm/neon.md (float<mode><V_cvtto>2): New."}, {"sha": "fcaf55366f157e6596c18005d95fc39aaeb0e960", "filename": "gcc/config/mips/loongson.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Floongson.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Floongson.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Floongson.h?ref=7dab511cf3331378aaafdeb7676835c0cdb194fa", "patch": "@@ -449,13 +449,13 @@ psadbh (uint8x8_t s, uint8x8_t t)\n __extension__ static __inline uint16x4_t __attribute__ ((__always_inline__))\n pshufh_u (uint16x4_t dest, uint16x4_t s, uint8_t order)\n {\n-  return __builtin_loongson_pshufh_u (dest, s, order);\n+  return __builtin_loongson_pshufh_u (s, order);\n }\n \n __extension__ static __inline int16x4_t __attribute__ ((__always_inline__))\n pshufh_s (int16x4_t dest, int16x4_t s, uint8_t order)\n {\n-  return __builtin_loongson_pshufh_s (dest, s, order);\n+  return __builtin_loongson_pshufh_s (s, order);\n }\n \n /* Shift left logical.  */"}, {"sha": "4f9cc7396ca379d01bfd9fed302558fbc4ef5272", "filename": "gcc/config/mips/loongson.md", "status": "modified", "additions": 490, "deletions": 80, "changes": 570, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Floongson.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Floongson.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Floongson.md?ref=7dab511cf3331378aaafdeb7676835c0cdb194fa", "patch": "@@ -24,10 +24,8 @@\n   UNSPEC_LOONGSON_PCMPEQ\n   UNSPEC_LOONGSON_PCMPGT\n   UNSPEC_LOONGSON_PEXTR\n-  UNSPEC_LOONGSON_PINSR_0\n-  UNSPEC_LOONGSON_PINSR_1\n-  UNSPEC_LOONGSON_PINSR_2\n-  UNSPEC_LOONGSON_PINSR_3\n+  UNSPEC_LOONGSON_PINSRH\n+  UNSPEC_LOONGSON_VINIT\n   UNSPEC_LOONGSON_PMADD\n   UNSPEC_LOONGSON_PMOVMSK\n   UNSPEC_LOONGSON_PMULHU\n@@ -41,6 +39,8 @@\n   UNSPEC_LOONGSON_PUNPCKL\n   UNSPEC_LOONGSON_PADDD\n   UNSPEC_LOONGSON_PSUBD\n+  UNSPEC_LOONGSON_DSLL\n+  UNSPEC_LOONGSON_DSRL\n ])\n \n ;; Mode iterators and attributes.\n@@ -60,6 +60,9 @@\n ;; 64-bit vectors of words and halfwords.\n (define_mode_iterator VWH [V2SI V4HI])\n \n+;; 64-bit vectors of words and bytes\n+(define_mode_iterator VWB [V2SI V8QI])\n+\n ;; 64-bit vectors of words, halfwords and bytes.\n (define_mode_iterator VWHB [V2SI V4HI V8QI])\n \n@@ -86,6 +89,9 @@\n ;; but with twice as many elements.\n (define_mode_attr V_squash_double [(V2SI \"V4HI\") (V4HI \"V8QI\")])\n \n+;; Given a vector type T, the inner mode.\n+(define_mode_attr V_inner [(V8QI \"QI\") (V4HI \"HI\") (V2SI \"SI\")])\n+\n ;; The Loongson instruction suffixes corresponding to the conversions\n ;; specified by V_half_width.\n (define_mode_attr V_squash_double_suffix [(V2SI \"wh\") (V4HI \"hb\")])\n@@ -122,6 +128,28 @@\n   DONE;\n })\n \n+;; Helper for vec_init.  Initialize element 0 of the output from the input.\n+;; All other elements are undefined.\n+(define_insn \"loongson_vec_init1_<mode>\"\n+  [(set (match_operand:VHB 0 \"register_operand\" \"=f\")\n+\t(unspec:VHB [(truncate:<V_inner>\n+\t\t       (match_operand:DI 1 \"reg_or_0_operand\" \"Jd\"))]\n+\t\t    UNSPEC_LOONGSON_VINIT))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"dmtc1\\t%z1,%0\"\n+  [(set_attr \"move_type\" \"mtc\")\n+   (set_attr \"mode\" \"DI\")])\n+\n+;; Helper for vec_initv2si.\n+(define_insn \"*vec_concatv2si\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=f\")\n+\t(vec_concat:V2SI\n+\t  (match_operand:SI 1 \"register_operand\" \"f\")\n+\t  (match_operand:SI 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpcklwd\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fcvt\")])\n+\n ;; Instruction patterns for SIMD instructions.\n \n ;; Pack with signed saturation.\n@@ -200,6 +228,51 @@\n   \"pandn\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fmul\")])\n \n+;; Logical AND.\n+(define_insn \"and<mode>3\"\n+  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n+\t(and:VWHB (match_operand:VWHB 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:VWHB 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"and\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fmul\")])\n+\n+;; Logical OR.\n+(define_insn \"ior<mode>3\"\n+  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n+\t(ior:VWHB (match_operand:VWHB 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:VWHB 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"or\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fcvt\")])\n+\n+;; Logical XOR.\n+(define_insn \"xor<mode>3\"\n+  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n+\t(xor:VWHB (match_operand:VWHB 1 \"register_operand\" \"f\")\n+\t\t  (match_operand:VWHB 2 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"xor\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fmul\")])\n+\n+;; Logical NOR.\n+(define_insn \"*loongson_nor\"\n+  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n+\t(and:VWHB\n+\t  (not:VWHB (match_operand:VWHB 1 \"register_operand\" \"f\"))\n+\t  (not:VWHB (match_operand:VWHB 2 \"register_operand\" \"f\"))))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"nor\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fmul\")])\n+\n+;; Logical NOT.\n+(define_insn \"one_cmpl<mode>2\"\n+  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n+\t(not:VWHB (match_operand:VWHB 1 \"register_operand\" \"f\")))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"nor\\t%0,%1,%1\"\n+  [(set_attr \"type\" \"fmul\")])\n+\n ;; Average.\n (define_insn \"loongson_pavg<V_suffix>\"\n   [(set (match_operand:VHB 0 \"register_operand\" \"=f\")\n@@ -231,96 +304,166 @@\n   [(set_attr \"type\" \"fadd\")])\n \n ;; Extract halfword.\n-(define_insn \"loongson_pextr<V_suffix>\"\n-  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n-        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n- \t\t    (match_operand:SI 2 \"register_operand\" \"f\")]\n+(define_insn \"loongson_pextrh\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+        (unspec:V4HI [(match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"f\")]\n \t\t   UNSPEC_LOONGSON_PEXTR))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"pextr<V_suffix>\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fmul\")])\n+  \"pextrh\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fcvt\")])\n \n ;; Insert halfword.\n-(define_insn \"loongson_pinsr<V_suffix>_0\"\n-  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n-        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n-\t\t    (match_operand:VH 2 \"register_operand\" \"f\")]\n-\t\t   UNSPEC_LOONGSON_PINSR_0))]\n+(define_insn \"loongson_pinsrh_0\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 4) (const_int 1)\n+\t\t     (const_int 2) (const_int 3)])))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"pinsrh_0\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fdiv\")])\n+\n+(define_insn \"loongson_pinsrh_1\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 4)\n+\t\t     (const_int 2) (const_int 3)])))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"pinsr<V_suffix>_0\\t%0,%1,%2\"\n+  \"pinsrh_1\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fdiv\")])\n \n-(define_insn \"loongson_pinsr<V_suffix>_1\"\n-  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n-        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n-\t\t    (match_operand:VH 2 \"register_operand\" \"f\")]\n-\t\t   UNSPEC_LOONGSON_PINSR_1))]\n+(define_insn \"loongson_pinsrh_2\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 1)\n+\t\t     (const_int 4) (const_int 3)])))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"pinsr<V_suffix>_1\\t%0,%1,%2\"\n+  \"pinsrh_2\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fdiv\")])\n \n-(define_insn \"loongson_pinsr<V_suffix>_2\"\n-  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n-        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n-\t\t    (match_operand:VH 2 \"register_operand\" \"f\")]\n-\t\t   UNSPEC_LOONGSON_PINSR_2))]\n+(define_insn \"loongson_pinsrh_3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 1)\n+\t\t     (const_int 2) (const_int 4)])))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"pinsr<V_suffix>_2\\t%0,%1,%2\"\n+  \"pinsrh_3\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fdiv\")])\n \n-(define_insn \"loongson_pinsr<V_suffix>_3\"\n-  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n-        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n-\t\t    (match_operand:VH 2 \"register_operand\" \"f\")]\n-\t\t   UNSPEC_LOONGSON_PINSR_3))]\n+(define_insn \"*vec_setv4hi\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+\t(unspec:V4HI [(match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:SI 2 \"register_operand\" \"f\")\n+\t\t      (match_operand:SI 3 \"const_0_to_3_operand\" \"\")]\n+\t\t     UNSPEC_LOONGSON_PINSRH))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"pinsr<V_suffix>_3\\t%0,%1,%2\"\n+  \"pinsrh_%3\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fdiv\")])\n \n+(define_expand \"vec_setv4hi\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+\t(unspec:V4HI [(match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:HI 2 \"register_operand\" \"f\")\n+\t\t      (match_operand:SI 3 \"const_0_to_3_operand\" \"\")]\n+\t\t     UNSPEC_LOONGSON_PINSRH))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  rtx ext = gen_reg_rtx (SImode);\n+  emit_move_insn (ext, gen_lowpart (SImode, operands[1]));\n+  operands[1] = ext;\n+})\n+\n ;; Multiply and add packed integers.\n-(define_insn \"loongson_pmadd<V_stretch_half_suffix>\"\n-  [(set (match_operand:<V_stretch_half> 0 \"register_operand\" \"=f\")\n-        (unspec:<V_stretch_half> [(match_operand:VH 1 \"register_operand\" \"f\")\n-\t\t\t\t  (match_operand:VH 2 \"register_operand\" \"f\")]\n-\t\t\t\t UNSPEC_LOONGSON_PMADD))]\n+(define_insn \"loongson_pmaddhw\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=f\")\n+        (unspec:V2SI [(match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t\t      (match_operand:V4HI 2 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_LOONGSON_PMADD))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"pmadd<V_stretch_half_suffix>\\t%0,%1,%2\"\n+  \"pmaddhw\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fmul\")])\n \n+(define_expand \"sdot_prodv4hi\"\n+  [(match_operand:V2SI 0 \"register_operand\" \"\")\n+   (match_operand:V4HI 1 \"register_operand\" \"\")\n+   (match_operand:V4HI 2 \"register_operand\" \"\")\n+   (match_operand:V2SI 3 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  rtx t = gen_reg_rtx (V2SImode);\n+  emit_insn (gen_loongson_pmaddhw (t, operands[1], operands[2]));\n+  emit_insn (gen_addv2si3 (operands[0], t, operands[3]));\n+  DONE;\n+})\n+\n ;; Maximum of signed halfwords.\n-(define_insn \"smax<mode>3\"\n-  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n-        (smax:VH (match_operand:VH 1 \"register_operand\" \"f\")\n-\t\t (match_operand:VH 2 \"register_operand\" \"f\")))]\n+(define_insn \"smaxv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+        (smax:V4HI (match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:V4HI 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"pmaxs<V_suffix>\\t%0,%1,%2\"\n+  \"pmaxsh\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fadd\")])\n \n+(define_expand \"smax<mode>3\"\n+  [(match_operand:VWB 0 \"register_operand\" \"\")\n+   (match_operand:VWB 1 \"register_operand\" \"\")\n+   (match_operand:VWB 2 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vec_minmax (operands[0], operands[1], operands[2],\n+\t\t\t  gen_loongson_pcmpgt<V_suffix>, false);\n+  DONE;\n+})\n+\n ;; Maximum of unsigned bytes.\n-(define_insn \"umax<mode>3\"\n-  [(set (match_operand:VB 0 \"register_operand\" \"=f\")\n-        (umax:VB (match_operand:VB 1 \"register_operand\" \"f\")\n-\t\t (match_operand:VB 2 \"register_operand\" \"f\")))]\n+(define_insn \"umaxv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=f\")\n+        (umax:V8QI (match_operand:V8QI 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:V8QI 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"pmaxu<V_suffix>\\t%0,%1,%2\"\n+  \"pmaxub\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fadd\")])\n \n ;; Minimum of signed halfwords.\n-(define_insn \"smin<mode>3\"\n-  [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n-        (smin:VH (match_operand:VH 1 \"register_operand\" \"f\")\n-\t\t (match_operand:VH 2 \"register_operand\" \"f\")))]\n+(define_insn \"sminv4hi3\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+        (smin:V4HI (match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:V4HI 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"pmins<V_suffix>\\t%0,%1,%2\"\n+  \"pminsh\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fadd\")])\n \n+(define_expand \"smin<mode>3\"\n+  [(match_operand:VWB 0 \"register_operand\" \"\")\n+   (match_operand:VWB 1 \"register_operand\" \"\")\n+   (match_operand:VWB 2 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vec_minmax (operands[0], operands[1], operands[2],\n+\t\t\t  gen_loongson_pcmpgt<V_suffix>, true);\n+  DONE;\n+})\n+\n ;; Minimum of unsigned bytes.\n-(define_insn \"umin<mode>3\"\n-  [(set (match_operand:VB 0 \"register_operand\" \"=f\")\n-        (umin:VB (match_operand:VB 1 \"register_operand\" \"f\")\n-\t\t (match_operand:VB 2 \"register_operand\" \"f\")))]\n+(define_insn \"uminv8qi3\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=f\")\n+        (umin:V8QI (match_operand:V8QI 1 \"register_operand\" \"f\")\n+\t\t   (match_operand:V8QI 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"pminu<V_suffix>\\t%0,%1,%2\"\n+  \"pminub\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fadd\")])\n \n ;; Move byte mask.\n@@ -390,6 +533,14 @@\n   \"biadd\\t%0,%1\"\n   [(set_attr \"type\" \"fabs\")])\n \n+(define_insn \"reduc_uplus_v8qi\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=f\")\n+\t(unspec:V8QI [(match_operand:V8QI 1 \"register_operand\" \"f\")]\n+\t\t     UNSPEC_LOONGSON_BIADD))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"biadd\\t%0,%1\"\n+  [(set_attr \"type\" \"fabs\")])\n+\n ;; Sum of absolute differences.\n (define_insn \"loongson_psadbh\"\n   [(set (match_operand:<V_stretch_half> 0 \"register_operand\" \"=f\")\n@@ -403,12 +554,11 @@\n ;; Shuffle halfwords.\n (define_insn \"loongson_pshufh\"\n   [(set (match_operand:VH 0 \"register_operand\" \"=f\")\n-        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"0\")\n-\t\t    (match_operand:VH 2 \"register_operand\" \"f\")\n-\t\t    (match_operand:SI 3 \"register_operand\" \"f\")]\n+        (unspec:VH [(match_operand:VH 1 \"register_operand\" \"f\")\n+\t\t    (match_operand:SI 2 \"register_operand\" \"f\")]\n \t\t   UNSPEC_LOONGSON_PSHUFH))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"pshufh\\t%0,%2,%3\"\n+  \"pshufh\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fmul\")])\n \n ;; Shift left logical.\n@@ -418,7 +568,7 @@\n \t\t    (match_operand:SI 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n   \"psll<V_suffix>\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fmul\")])\n+  [(set_attr \"type\" \"fcvt\")])\n \n ;; Shift right arithmetic.\n (define_insn \"ashr<mode>3\"\n@@ -427,7 +577,7 @@\n \t\t      (match_operand:SI 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n   \"psra<V_suffix>\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fdiv\")])\n+  [(set_attr \"type\" \"fcvt\")])\n \n ;; Shift right logical.\n (define_insn \"lshr<mode>3\"\n@@ -436,7 +586,7 @@\n \t\t      (match_operand:SI 2 \"register_operand\" \"f\")))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n   \"psrl<V_suffix>\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fdiv\")])\n+  [(set_attr \"type\" \"fcvt\")])\n \n ;; Subtraction, treating overflow by wraparound.\n (define_insn \"sub<mode>3\"\n@@ -478,26 +628,286 @@\n   \"psubus<V_suffix>\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fadd\")])\n \n-;; Unpack high data.\n-(define_insn \"vec_interleave_high<mode>\"\n-  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n-        (unspec:VWHB [(match_operand:VWHB 1 \"register_operand\" \"f\")\n-\t\t      (match_operand:VWHB 2 \"register_operand\" \"f\")]\n-\t\t     UNSPEC_LOONGSON_PUNPCKH))]\n+;; Unpack high data.  Recall that Loongson only runs in little-endian.\n+(define_insn \"loongson_punpckhbh\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V8QI\n+\t  (vec_concat:V16QI\n+\t    (match_operand:V8QI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V8QI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 4) (const_int 12)\n+\t\t     (const_int 5) (const_int 13)\n+\t\t     (const_int 6) (const_int 14)\n+\t\t     (const_int 7) (const_int 15)])))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpckhbh\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fdiv\")])\n+\n+(define_insn \"loongson_punpckhhw\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 2) (const_int 6)\n+\t\t     (const_int 3) (const_int 7)])))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"punpckh<V_stretch_half_suffix>\\t%0,%1,%2\"\n+  \"punpckhhw\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fdiv\")])\n \n+(define_insn \"loongson_punpckhhw_qi\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V8QI\n+\t  (vec_concat:V16QI\n+\t    (match_operand:V8QI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V8QI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 4)  (const_int 5)\n+\t\t     (const_int 12) (const_int 13)\n+\t\t     (const_int 6)  (const_int 7)\n+\t\t     (const_int 14) (const_int 15)])))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpckhhw\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fdiv\")])\n+\n+(define_insn \"loongson_punpckhwd\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V2SI\n+\t  (vec_concat:V4SI\n+\t    (match_operand:V2SI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V2SI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 1) (const_int 3)])))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpckhwd\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fcvt\")])\n+\n+(define_insn \"loongson_punpckhwd_qi\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V8QI\n+\t  (vec_concat:V16QI\n+\t    (match_operand:V8QI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V8QI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 4) (const_int 5)\n+\t\t     (const_int 6) (const_int 7)\n+\t\t     (const_int 12) (const_int 13)\n+\t\t     (const_int 14) (const_int 15)])))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpckhwd\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fcvt\")])\n+\n+(define_insn \"loongson_punpckhwd_hi\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 2) (const_int 3)\n+\t\t     (const_int 6) (const_int 7)])))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpckhwd\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fcvt\")])\n+\n ;; Unpack low data.\n-(define_insn \"vec_interleave_low<mode>\"\n-  [(set (match_operand:VWHB 0 \"register_operand\" \"=f\")\n-        (unspec:VWHB [(match_operand:VWHB 1 \"register_operand\" \"f\")\n-\t\t      (match_operand:VWHB 2 \"register_operand\" \"f\")]\n-\t\t     UNSPEC_LOONGSON_PUNPCKL))]\n+(define_insn \"loongson_punpcklbh\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V8QI\n+\t  (vec_concat:V16QI\n+\t    (match_operand:V8QI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V8QI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 8)\n+\t\t     (const_int 1) (const_int 9)\n+\t\t     (const_int 2) (const_int 10)\n+\t\t     (const_int 3) (const_int 11)])))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpcklbh\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fdiv\")])\n+\n+(define_insn \"loongson_punpcklhw\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 4)\n+\t\t     (const_int 1) (const_int 5)])))]\n   \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n-  \"punpckl<V_stretch_half_suffix>\\t%0,%1,%2\"\n+  \"punpcklhw\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fdiv\")])\n+\n+(define_insn \"*loongson_punpcklhw_qi\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V8QI\n+\t  (vec_concat:V16QI\n+\t    (match_operand:V8QI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V8QI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0)  (const_int 1)\n+\t\t     (const_int 8)  (const_int 9)\n+\t\t     (const_int 2)  (const_int 3)\n+\t\t     (const_int 10) (const_int 11)])))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpcklhw\\t%0,%1,%2\"\n   [(set_attr \"type\" \"fdiv\")])\n \n+(define_insn \"loongson_punpcklwd\"\n+  [(set (match_operand:V2SI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V2SI\n+\t  (vec_concat:V4SI\n+\t    (match_operand:V2SI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V2SI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 2)])))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpcklwd\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fcvt\")])\n+\n+(define_insn \"*loongson_punpcklwd_qi\"\n+  [(set (match_operand:V8QI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V8QI\n+\t  (vec_concat:V16QI\n+\t    (match_operand:V8QI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V8QI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 1)\n+\t\t     (const_int 2) (const_int 3)\n+\t\t     (const_int 8) (const_int 9)\n+\t\t     (const_int 10) (const_int 11)])))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpcklwd\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fcvt\")])\n+\n+(define_insn \"*loongson_punpcklwd_hi\"\n+  [(set (match_operand:V4HI 0 \"register_operand\" \"=f\")\n+\t(vec_select:V4HI\n+\t  (vec_concat:V8HI\n+\t    (match_operand:V4HI 1 \"register_operand\" \"f\")\n+\t    (match_operand:V4HI 2 \"register_operand\" \"f\"))\n+\t  (parallel [(const_int 0) (const_int 1)\n+\t\t     (const_int 4) (const_int 5)])))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"punpcklwd\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fcvt\")])\n+\n+(define_expand \"vec_perm_const<mode>\"\n+  [(match_operand:VWHB 0 \"register_operand\" \"\")\n+   (match_operand:VWHB 1 \"register_operand\" \"\")\n+   (match_operand:VWHB 2 \"register_operand\" \"\")\n+   (match_operand:VWHB 3 \"\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  if (mips_expand_vec_perm_const (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+(define_expand \"vec_unpacks_lo_<mode>\"\n+  [(match_operand:<V_stretch_half> 0 \"register_operand\" \"\")\n+   (match_operand:VHB 1 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vec_unpack (operands, false, false);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacks_hi_<mode>\"\n+  [(match_operand:<V_stretch_half> 0 \"register_operand\" \"\")\n+   (match_operand:VHB 1 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vec_unpack (operands, false, true);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacku_lo_<mode>\"\n+  [(match_operand:<V_stretch_half> 0 \"register_operand\" \"\")\n+   (match_operand:VHB 1 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vec_unpack (operands, true, false);\n+  DONE;\n+})\n+\n+(define_expand \"vec_unpacku_hi_<mode>\"\n+  [(match_operand:<V_stretch_half> 0 \"register_operand\" \"\")\n+   (match_operand:VHB 1 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vec_unpack (operands, true, true);\n+  DONE;\n+})\n+\n+;; Whole vector shifts, used for reduction epilogues.\n+(define_insn \"vec_shl_<mode>\"\n+  [(set (match_operand:VWHBDI 0 \"register_operand\" \"=f\")\n+        (unspec:VWHBDI [(match_operand:VWHBDI 1 \"register_operand\" \"f\")\n+                        (match_operand:SI 2 \"register_operand\" \"f\")]\n+                       UNSPEC_LOONGSON_DSLL))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"dsll\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fcvt\")])\n+\n+(define_insn \"vec_shr_<mode>\"\n+  [(set (match_operand:VWHBDI 0 \"register_operand\" \"=f\")\n+        (unspec:VWHBDI [(match_operand:VWHBDI 1 \"register_operand\" \"f\")\n+                        (match_operand:SI 2 \"register_operand\" \"f\")]\n+                       UNSPEC_LOONGSON_DSRL))]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+  \"dsrl\\t%0,%1,%2\"\n+  [(set_attr \"type\" \"fcvt\")])\n+\n+(define_expand \"reduc_uplus_<mode>\"\n+  [(match_operand:VWH 0 \"register_operand\" \"\")\n+   (match_operand:VWH 1 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vec_reduc (operands[0], operands[1], gen_add<mode>3);\n+  DONE;\n+})\n+\n+; ??? Given that we're not describing a widening reduction, we should\n+; not have separate optabs for signed and unsigned.\n+(define_expand \"reduc_splus_<mode>\"\n+  [(match_operand:VWHB 0 \"register_operand\" \"\")\n+   (match_operand:VWHB 1 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  emit_insn (gen_reduc_uplus_<mode>(operands[0], operands[1]));\n+  DONE;\n+})\n+\n+(define_expand \"reduc_smax_<mode>\"\n+  [(match_operand:VWHB 0 \"register_operand\" \"\")\n+   (match_operand:VWHB 1 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vec_reduc (operands[0], operands[1], gen_smax<mode>3);\n+  DONE;\n+})\n+\n+(define_expand \"reduc_smin_<mode>\"\n+  [(match_operand:VWHB 0 \"register_operand\" \"\")\n+   (match_operand:VWHB 1 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vec_reduc (operands[0], operands[1], gen_smin<mode>3);\n+  DONE;\n+})\n+\n+(define_expand \"reduc_umax_<mode>\"\n+  [(match_operand:VB 0 \"register_operand\" \"\")\n+   (match_operand:VB 1 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vec_reduc (operands[0], operands[1], gen_umax<mode>3);\n+  DONE;\n+})\n+\n+(define_expand \"reduc_umin_<mode>\"\n+  [(match_operand:VB 0 \"register_operand\" \"\")\n+   (match_operand:VB 1 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS\"\n+{\n+  mips_expand_vec_reduc (operands[0], operands[1], gen_umin<mode>3);\n+  DONE;\n+})\n+\n ;; Integer division and modulus.  For integer multiplication, see mips.md.\n \n (define_insn \"<u>div<mode>3\""}, {"sha": "187c651bbbc232dac004e35542163f80d81a8450", "filename": "gcc/config/mips/mips-modes.def", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Fmips-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Fmips-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-modes.def?ref=7dab511cf3331378aaafdeb7676835c0cdb194fa", "patch": "@@ -26,9 +26,15 @@ RESET_FLOAT_FORMAT (DF, mips_double_format);\n FLOAT_MODE (TF, 16, mips_quad_format);\n \n /* Vector modes.  */\n-VECTOR_MODES (INT, 8);        /*       V8QI V4HI V2SI */\n-VECTOR_MODES (FLOAT, 8);      /*            V4HF V2SF */\n-VECTOR_MODES (INT, 4);        /*            V4QI V2HI */\n+VECTOR_MODES (INT, 4);        /* V4QI  V2HI      */\n+VECTOR_MODES (INT, 8);        /* V8QI  V4HI V2SI */\n+VECTOR_MODES (FLOAT, 8);      /*       V4HF V2SF */\n+\n+/* Double-sized vector modes for vec_concat.  */\n+VECTOR_MODE (INT, QI, 16);    /* V16QI           */\n+VECTOR_MODE (INT, HI, 8);     /*       V8HI      */\n+VECTOR_MODE (INT, SI, 4);     /*            V4SI */\n+VECTOR_MODE (FLOAT, SF, 4);   /*            V4SF */\n \n VECTOR_MODES (FRACT, 4);\t/* V4QQ  V2HQ */\n VECTOR_MODES (UFRACT, 4);\t/* V4UQQ V2UHQ */"}, {"sha": "1791ce7c1433d677193fe6285b428a4cb9f04a50", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=7dab511cf3331378aaafdeb7676835c0cdb194fa", "patch": "@@ -328,6 +328,11 @@ extern void mips_expand_atomic_qihi (union mips_gen_fn_ptrs,\n \t\t\t\t     rtx, rtx, rtx, rtx);\n \n extern void mips_expand_vector_init (rtx, rtx);\n+extern bool mips_expand_vec_perm_const (rtx op[4]);\n+extern void mips_expand_vec_unpack (rtx op[2], bool, bool);\n+extern void mips_expand_vec_reduc (rtx, rtx, rtx (*)(rtx, rtx, rtx));\n+extern void mips_expand_vec_minmax (rtx, rtx, rtx,\n+\t\t\t\t    rtx (*) (rtx, rtx, rtx), bool);\n \n extern bool mips_eh_uses (unsigned int);\n extern bool mips_epilogue_uses (unsigned int);"}, {"sha": "cc8a4c044ac8152704f9c107b271aa7951afc2fd", "filename": "gcc/config/mips/mips-ps-3d.md", "status": "modified", "additions": 197, "deletions": 68, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-ps-3d.md?ref=7dab511cf3331378aaafdeb7676835c0cdb194fa", "patch": "@@ -89,75 +89,181 @@\n   DONE;\n })\n \n-; pul.ps - Pair Upper Lower\n-(define_insn \"mips_pul_ps\"\n+(define_insn \"vec_perm_const_ps\"\n   [(set (match_operand:V2SF 0 \"register_operand\" \"=f\")\n-\t(vec_merge:V2SF\n-\t (match_operand:V2SF 1 \"register_operand\" \"f\")\n-\t (match_operand:V2SF 2 \"register_operand\" \"f\")\n-\t (const_int 2)))]\n+\t(vec_select:V2SF\n+\t  (vec_concat:V4SF\n+\t    (match_operand:V2SF 1 \"register_operand\" \"f\")\n+\t    (match_operand:V2SF 2 \"register_operand\" \"f\"))\n+\t  (parallel [(match_operand:SI 3 \"const_0_or_1_operand\" \"\")\n+\t\t     (match_operand:SI 4 \"const_2_or_3_operand\" \"\")])))]\n   \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"pul.ps\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fmove\")\n-   (set_attr \"mode\" \"SF\")])\n+{\n+  /* Let <op>L be the lower part of operand <op> and <op>U be the upper part.\n+     The P[UL][UL].PS instruction always specifies the upper part of the\n+     result first, so the instruction is:\n \n-; puu.ps - Pair upper upper\n-(define_insn \"mips_puu_ps\"\n-  [(set (match_operand:V2SF 0 \"register_operand\" \"=f\")\n-\t(vec_merge:V2SF\n-\t (match_operand:V2SF 1 \"register_operand\" \"f\")\n-\t (vec_select:V2SF (match_operand:V2SF 2 \"register_operand\" \"f\")\n-\t\t\t  (parallel [(const_int 1)\n-\t\t\t\t     (const_int 0)]))\n-\t (const_int 2)))]\n-  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"puu.ps\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fmove\")\n-   (set_attr \"mode\" \"SF\")])\n+\tP<aUL><bUL>.PS %0,<aop>,<bop>\n \n-; pll.ps - Pair Lower Lower\n-(define_insn \"mips_pll_ps\"\n-  [(set (match_operand:V2SF 0 \"register_operand\" \"=f\")\n-\t(vec_merge:V2SF\n-\t (vec_select:V2SF (match_operand:V2SF 1 \"register_operand\" \"f\")\n-\t\t\t  (parallel [(const_int 1)\n-\t\t\t\t     (const_int 0)]))\n-\t (match_operand:V2SF 2 \"register_operand\" \"f\")\n-\t (const_int 2)))]\n-  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"pll.ps\\t%0,%1,%2\"\n-  [(set_attr \"type\" \"fmove\")\n-   (set_attr \"mode\" \"SF\")])\n+     where 0U == <aop><aUL> and 0L == <bop><bUL>.\n \n-; plu.ps - Pair Lower Upper\n-(define_insn \"mips_plu_ps\"\n-  [(set (match_operand:V2SF 0 \"register_operand\" \"=f\")\n-\t(vec_merge:V2SF\n-\t (vec_select:V2SF (match_operand:V2SF 1 \"register_operand\" \"f\")\n-\t\t\t  (parallel [(const_int 1)\n-\t\t\t\t     (const_int 0)]))\n-\t (vec_select:V2SF (match_operand:V2SF 2 \"register_operand\" \"f\")\n-\t\t\t  (parallel [(const_int 1)\n-\t\t\t\t     (const_int 0)]))\n-\t (const_int 2)))]\n-  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n-  \"plu.ps\\t%0,%1,%2\"\n+     GCC's vector indices are specified in memory order, which means\n+     that vector element 0 is the lower part (L) on little-endian targets\n+     and the upper part (U) on big-endian targets.  vec_concat likewise\n+     concatenates in memory order, which means that operand 3 (being\n+     0 or 1) selects part of operand 1 and operand 4 (being 2 or 3)\n+     selects part of operand 2.\n+\n+     Let:\n+\n+\tI3 = INTVAL (operands[3])\n+\tI4 = INTVAL (operands[4]) - 2\n+\n+     Taking the two endiannesses in turn:\n+\n+     Little-endian:\n+\n+        The semantics of the RTL pattern are:\n+\n+\t{ 0L, 0U } = { X[I3], X[I4 + 2] }, where X = { 1L, 1U, 2L, 2U }\n+\n+\tso: 0L = { 1L, 1U }[I3] (= <bop><bUL>)\n+\t    0U = { 2L, 2U }[I4] (= <aop><aUL>)\n+\n+\t    <aop> = 2, <aUL> = I4 ? U : L\n+\t    <bop> = 1, <bUL> = I3 ? U : L\n+\n+\t    [LL] !I4 && !I3   [UL] I4 && !I3\n+\t    [LU] !I4 && I3    [UU] I4 && I3\n+\n+     Big-endian:\n+\n+        The semantics of the RTL pattern are:\n+\n+\t{ 0U, 0L } = { X[I3], X[I4 + 2] }, where X = { 1U, 1L, 2U, 2L }\n+\n+\tso: 0U = { 1U, 1L }[I3] (= <aop><aUL>)\n+\t    0L = { 2U, 2L }[I4] (= <bop><bUL>)\n+\n+\t    <aop> = 1, <aUL> = I3 ? L : U\n+\t    <bop> = 2, <bUL> = I4 ? L : U\n+\n+\t    [UU] !I3 && !I4   [UL] !I3 && I4\n+\t    [LU] I3 && !I4    [LL] I3 && I4.  */\n+\n+  static const char * const mnemonics[2][4] = {\n+    /* LE */ { \"pll.ps\\t%0,%2,%1\", \"pul.ps\\t%0,%2,%1\",\n+\t       \"plu.ps\\t%0,%2,%1\", \"puu.ps\\t%0,%2,%1\" },\n+    /* BE */ { \"puu.ps\\t%0,%1,%2\", \"pul.ps\\t%0,%1,%2\",\n+\t       \"plu.ps\\t%0,%1,%2\", \"pll.ps\\t%0,%1,%2\" },\n+  };\n+\n+  unsigned mask = INTVAL (operands[3]) * 2 + (INTVAL (operands[4]) - 2);\n+  return mnemonics[BYTES_BIG_ENDIAN][mask];\n+}\n   [(set_attr \"type\" \"fmove\")\n    (set_attr \"mode\" \"SF\")])\n \n+(define_expand \"vec_perm_constv2sf\"\n+  [(match_operand:V2SF 0 \"register_operand\" \"\")\n+   (match_operand:V2SF 1 \"register_operand\" \"\")\n+   (match_operand:V2SF 2 \"register_operand\" \"\")\n+   (match_operand:V2SI 3 \"\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n+{\n+  if (mips_expand_vec_perm_const (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n+;; Expanders for builtins.  The instruction:\n+;;\n+;;     P[UL][UL].PS <result>, <a>, <b>\n+;;\n+;; says that the upper part of <result> is taken from half of <a> and\n+;; the lower part of <result> is taken from half of <b>.  This means\n+;; that the P[UL][UL].PS operand order matches memory order on big-endian\n+;; targets; <a> is element 0 of the V2SF result while <b> is element 1.\n+;; However, the P[UL][UL].PS operand order is the reverse of memory order\n+;; on little-endian targets; <a> is element 1 of the V2SF result while\n+;; <b> is element 0.  The arguments to vec_perm_const_ps are always in\n+;; memory order.\n+;;\n+;; Similarly, \"U\" corresponds to element 0 on big-endian targets but\n+;; to element 1 on little-endian targets.\n+\n+(define_expand \"mips_puu_ps\"\n+  [(match_operand:V2SF 0 \"register_operand\" \"\")\n+   (match_operand:V2SF 1 \"register_operand\" \"\")\n+   (match_operand:V2SF 2 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_vec_perm_const_ps (operands[0], operands[1], operands[2],\n+\t\t\t\t      const0_rtx, const2_rtx));\n+  else\n+    emit_insn (gen_vec_perm_const_ps (operands[0], operands[2], operands[1],\n+\t\t\t\t      const1_rtx, GEN_INT (3)));\n+  DONE;\n+})\n+\n+(define_expand \"mips_pul_ps\"\n+  [(match_operand:V2SF 0 \"register_operand\" \"\")\n+   (match_operand:V2SF 1 \"register_operand\" \"\")\n+   (match_operand:V2SF 2 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_vec_perm_const_ps (operands[0], operands[1], operands[2],\n+\t\t\t\t      const0_rtx, GEN_INT (3)));\n+  else\n+    emit_insn (gen_vec_perm_const_ps (operands[0], operands[2], operands[1],\n+\t\t\t\t      const0_rtx, GEN_INT (3)));\n+  DONE;\n+})\n+\n+(define_expand \"mips_plu_ps\"\n+  [(match_operand:V2SF 0 \"register_operand\" \"\")\n+   (match_operand:V2SF 1 \"register_operand\" \"\")\n+   (match_operand:V2SF 2 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_vec_perm_const_ps (operands[0], operands[1], operands[2],\n+\t\t\t\t      const1_rtx, const2_rtx));\n+  else\n+    emit_insn (gen_vec_perm_const_ps (operands[0], operands[2], operands[1],\n+\t\t\t\t      const1_rtx, const2_rtx));\n+  DONE;\n+})\n+\n+(define_expand \"mips_pll_ps\"\n+  [(match_operand:V2SF 0 \"register_operand\" \"\")\n+   (match_operand:V2SF 1 \"register_operand\" \"\")\n+   (match_operand:V2SF 2 \"register_operand\" \"\")]\n+  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n+{\n+  if (BYTES_BIG_ENDIAN)\n+    emit_insn (gen_vec_perm_const_ps (operands[0], operands[1], operands[2],\n+\t\t\t\t      const1_rtx, GEN_INT (3)));\n+  else\n+    emit_insn (gen_vec_perm_const_ps (operands[0], operands[2], operands[1],\n+\t\t\t\t      const0_rtx, const2_rtx));\n+  DONE;\n+})\n+\n ; vec_init\n (define_expand \"vec_initv2sf\"\n   [(match_operand:V2SF 0 \"register_operand\")\n    (match_operand:V2SF 1 \"\")]\n   \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n {\n-  rtx op0 = force_reg (SFmode, XVECEXP (operands[1], 0, 0));\n-  rtx op1 = force_reg (SFmode, XVECEXP (operands[1], 0, 1));\n-  emit_insn (gen_vec_initv2sf_internal (operands[0], op0, op1));\n+  mips_expand_vector_init (operands[0], operands[1]);\n   DONE;\n })\n \n-(define_insn \"vec_initv2sf_internal\"\n+(define_insn \"vec_concatv2sf\"\n   [(set (match_operand:V2SF 0 \"register_operand\" \"=f\")\n \t(vec_concat:V2SF\n \t (match_operand:SF 1 \"register_operand\" \"f\")\n@@ -195,22 +301,21 @@\n ;; no other way to get a vector mode bitfield store currently.\n \n (define_expand \"vec_setv2sf\"\n-  [(match_operand:V2SF 0 \"register_operand\")\n-   (match_operand:SF 1 \"register_operand\")\n-   (match_operand 2 \"const_0_or_1_operand\")]\n+  [(set (match_operand:V2SF 0 \"register_operand\" \"\")\n+\t(vec_select:V2SF\n+\t  (vec_concat:V4SF\n+\t    (match_operand:SF 1 \"register_operand\" \"\")\n+\t    (match_dup 0))\n+\t  (parallel [(match_operand 2 \"const_0_or_1_operand\" \"\")\n+\t\t     (match_dup 3)])))]\n   \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n {\n-  rtx temp;\n-\n   /* We don't have an insert instruction, so we duplicate the float, and\n      then use a PUL instruction.  */\n-  temp = gen_reg_rtx (V2SFmode);\n-  emit_insn (gen_mips_cvt_ps_s (temp, operands[1], operands[1]));\n-  if (INTVAL (operands[2]) == !BYTES_BIG_ENDIAN)\n-    emit_insn (gen_mips_pul_ps (operands[0], temp, operands[0]));\n-  else\n-    emit_insn (gen_mips_pul_ps (operands[0], operands[0], temp));\n-  DONE;\n+  rtx temp = gen_reg_rtx (V2SFmode);\n+  emit_insn (gen_vec_concatv2sf (temp, operands[1], operands[1]));\n+  operands[1] = temp;\n+  operands[3] = GEN_INT (1 - INTVAL (operands[2]) + 2);\n })\n \n ; cvt.ps.s - Floating Point Convert Pair to Paired Single\n@@ -221,11 +326,9 @@\n   \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n {\n   if (BYTES_BIG_ENDIAN)\n-    emit_insn (gen_vec_initv2sf_internal (operands[0], operands[1],\n-\t       operands[2]));\n+    emit_insn (gen_vec_concatv2sf (operands[0], operands[1], operands[2]));\n   else\n-    emit_insn (gen_vec_initv2sf_internal (operands[0], operands[2],\n-\t       operands[1]));\n+    emit_insn (gen_vec_concatv2sf (operands[0], operands[2], operands[1]));\n   DONE;\n })\n \n@@ -268,6 +371,14 @@\n   [(set_attr \"type\" \"fadd\")\n    (set_attr \"mode\" \"SF\")])\n \n+(define_insn \"reduc_splus_v2sf\"\n+  [(set (match_operand:V2SF 0 \"register_operand\" \"=f\")\n+\t(unspec:V2SF [(match_operand:V2SF 1 \"register_operand\" \"f\")\n+\t\t      (match_dup 1)]\n+\t\t     UNSPEC_ADDR_PS))]\n+  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n+  \"\")\n+\n ; cvt.pw.ps - Floating Point Convert Paired Single to Paired Word\n (define_insn \"mips_cvt_pw_ps\"\n   [(set (match_operand:V2SF 0 \"register_operand\" \"=f\")\n@@ -633,3 +744,21 @@\n \t\t\t LE, operands[2], operands[1]);\n   DONE;\n })\n+\n+(define_expand \"reduc_smin_v2sf\"\n+  [(match_operand:V2SF 0 \"register_operand\")\n+   (match_operand:V2SF 1 \"register_operand\")]\n+  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n+{\n+  mips_expand_vec_reduc (operands[0], operands[1], gen_sminv2sf3);\n+  DONE;\n+})\n+\n+(define_expand \"reduc_smax_v2sf\"\n+  [(match_operand:V2SF 0 \"register_operand\")\n+   (match_operand:V2SF 1 \"register_operand\")]\n+  \"TARGET_HARD_FLOAT && TARGET_PAIRED_SINGLE_FLOAT\"\n+{\n+  mips_expand_vec_reduc (operands[0], operands[1], gen_smaxv2sf3);\n+  DONE;\n+})"}, {"sha": "bdbf94a48b031e4e9662204fc27ceced3b65ade0", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 681, "deletions": 40, "changes": 721, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=7dab511cf3331378aaafdeb7676835c0cdb194fa", "patch": "@@ -4638,7 +4638,7 @@ mips_get_arg_info (struct mips_arg_info *info, const CUMULATIVE_ARGS *cum,\n       /* The EABI conventions have traditionally been defined in terms\n \t of TYPE_MODE, regardless of the actual type.  */\n       info->fpr_p = ((GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t\t      || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+\t\t      || mode == V2SFmode)\n \t\t     && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE);\n       break;\n \n@@ -4653,7 +4653,7 @@ mips_get_arg_info (struct mips_arg_info *info, const CUMULATIVE_ARGS *cum,\n \t\t\t || SCALAR_FLOAT_TYPE_P (type)\n \t\t\t || VECTOR_FLOAT_TYPE_P (type))\n \t\t     && (GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t\t\t || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+\t\t\t || mode == V2SFmode)\n \t\t     && GET_MODE_SIZE (mode) <= UNITS_PER_FPVALUE);\n       break;\n \n@@ -4666,7 +4666,7 @@ mips_get_arg_info (struct mips_arg_info *info, const CUMULATIVE_ARGS *cum,\n \t\t     && (type == 0 || FLOAT_TYPE_P (type))\n \t\t     && (GET_MODE_CLASS (mode) == MODE_FLOAT\n \t\t\t || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n-\t\t\t || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+\t\t\t || mode == V2SFmode)\n \t\t     && GET_MODE_UNIT_SIZE (mode) <= UNITS_PER_FPVALUE);\n \n       /* ??? According to the ABI documentation, the real and imaginary\n@@ -5103,7 +5103,7 @@ static bool\n mips_return_mode_in_fpr_p (enum machine_mode mode)\n {\n   return ((GET_MODE_CLASS (mode) == MODE_FLOAT\n-\t   || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT\n+\t   || mode == V2SFmode\n \t   || GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT)\n \t  && GET_MODE_UNIT_SIZE (mode) <= UNITS_PER_HWFPVALUE);\n }\n@@ -10782,12 +10782,18 @@ mips_class_max_nregs (enum reg_class rclass, enum machine_mode mode)\n /* Implement CANNOT_CHANGE_MODE_CLASS.  */\n \n bool\n-mips_cannot_change_mode_class (enum machine_mode from ATTRIBUTE_UNUSED,\n-\t\t\t       enum machine_mode to ATTRIBUTE_UNUSED,\n+mips_cannot_change_mode_class (enum machine_mode from,\n+\t\t\t       enum machine_mode to,\n \t\t\t       enum reg_class rclass)\n {\n-  /* There are several problems with changing the modes of values in\n-     floating-point registers:\n+  /* Allow conversions between different Loongson integer vectors,\n+     and between those vectors and DImode.  */\n+  if (GET_MODE_SIZE (from) == 8 && GET_MODE_SIZE (to) == 8\n+      && INTEGRAL_MODE_P (from) && INTEGRAL_MODE_P (to))\n+    return false;\n+\n+  /* Otherwise, there are several problems with changing the modes of\n+     values in floating-point registers:\n \n      - When a multi-word value is stored in paired floating-point\n        registers, the first register always holds the low word.  We\n@@ -10808,6 +10814,7 @@ mips_cannot_change_mode_class (enum machine_mode from ATTRIBUTE_UNUSED,\n        format.\n \n      We therefore disallow all mode changes involving FPRs.  */\n+\n   return reg_classes_intersect_p (FP_REGS, rclass);\n }\n \n@@ -12785,12 +12792,6 @@ AVAIL_NON_MIPS16 (cache, TARGET_CACHE_BUILTIN)\n #define CODE_FOR_loongson_psubsb CODE_FOR_sssubv8qi3\n #define CODE_FOR_loongson_psubush CODE_FOR_ussubv4hi3\n #define CODE_FOR_loongson_psubusb CODE_FOR_ussubv8qi3\n-#define CODE_FOR_loongson_punpckhbh CODE_FOR_vec_interleave_highv8qi\n-#define CODE_FOR_loongson_punpckhhw CODE_FOR_vec_interleave_highv4hi\n-#define CODE_FOR_loongson_punpckhwd CODE_FOR_vec_interleave_highv2si\n-#define CODE_FOR_loongson_punpcklbh CODE_FOR_vec_interleave_lowv8qi\n-#define CODE_FOR_loongson_punpcklhw CODE_FOR_vec_interleave_lowv4hi\n-#define CODE_FOR_loongson_punpcklwd CODE_FOR_vec_interleave_lowv2si\n \n static const struct mips_builtin_description mips_builtins[] = {\n   DIRECT_BUILTIN (pll_ps, MIPS_V2SF_FTYPE_V2SF_V2SF, paired_single),\n@@ -13032,8 +13033,8 @@ static const struct mips_builtin_description mips_builtins[] = {\n   LOONGSON_BUILTIN (pasubub, MIPS_UV8QI_FTYPE_UV8QI_UV8QI),\n   LOONGSON_BUILTIN (biadd, MIPS_UV4HI_FTYPE_UV8QI),\n   LOONGSON_BUILTIN (psadbh, MIPS_UV4HI_FTYPE_UV8QI_UV8QI),\n-  LOONGSON_BUILTIN_SUFFIX (pshufh, u, MIPS_UV4HI_FTYPE_UV4HI_UV4HI_UQI),\n-  LOONGSON_BUILTIN_SUFFIX (pshufh, s, MIPS_V4HI_FTYPE_V4HI_V4HI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (pshufh, u, MIPS_UV4HI_FTYPE_UV4HI_UQI),\n+  LOONGSON_BUILTIN_SUFFIX (pshufh, s, MIPS_V4HI_FTYPE_V4HI_UQI),\n   LOONGSON_BUILTIN_SUFFIX (psllh, u, MIPS_UV4HI_FTYPE_UV4HI_UQI),\n   LOONGSON_BUILTIN_SUFFIX (psllh, s, MIPS_V4HI_FTYPE_V4HI_UQI),\n   LOONGSON_BUILTIN_SUFFIX (psllw, u, MIPS_UV2SI_FTYPE_UV2SI_UQI),\n@@ -15923,30 +15924,6 @@ mips_conditional_register_usage (void)\n     }\n }\n \n-/* Initialize vector TARGET to VALS.  */\n-\n-void\n-mips_expand_vector_init (rtx target, rtx vals)\n-{\n-  enum machine_mode mode;\n-  enum machine_mode inner;\n-  unsigned int i, n_elts;\n-  rtx mem;\n-\n-  mode = GET_MODE (target);\n-  inner = GET_MODE_INNER (mode);\n-  n_elts = GET_MODE_NUNITS (mode);\n-\n-  gcc_assert (VECTOR_MODE_P (mode));\n-\n-  mem = assign_stack_temp (mode, GET_MODE_SIZE (mode), 0);\n-  for (i = 0; i < n_elts; i++)\n-    emit_move_insn (adjust_address_nv (mem, inner, i * GET_MODE_SIZE (inner)),\n-                    XVECEXP (vals, 0, i));\n-\n-  emit_move_insn (target, mem);\n-}\n-\n /* When generating MIPS16 code, we want to allocate $24 (T_REG) before\n    other registers for instructions for which it is possible.  This\n    encourages the compiler to use CMP in cases where an XOR would\n@@ -16357,6 +16334,667 @@ mips_prepare_pch_save (void)\n   mips16_globals = 0;\n }\n \f\n+/* Generate or test for an insn that supports a constant permutation.  */\n+\n+#define MAX_VECT_LEN 8\n+\n+struct expand_vec_perm_d\n+{\n+  rtx target, op0, op1;\n+  unsigned char perm[MAX_VECT_LEN];\n+  enum machine_mode vmode;\n+  unsigned char nelt;\n+  bool one_vector_p;\n+  bool testing_p;\n+};\n+\n+/* Construct (set target (vec_select op0 (parallel perm))) and\n+   return true if that's a valid instruction in the active ISA.  */\n+\n+static bool\n+mips_expand_vselect (rtx target, rtx op0,\n+\t\t     const unsigned char *perm, unsigned nelt)\n+{\n+  rtx rperm[MAX_VECT_LEN], x;\n+  unsigned i;\n+\n+  for (i = 0; i < nelt; ++i)\n+    rperm[i] = GEN_INT (perm[i]);\n+\n+  x = gen_rtx_PARALLEL (VOIDmode, gen_rtvec_v (nelt, rperm));\n+  x = gen_rtx_VEC_SELECT (GET_MODE (target), op0, x);\n+  x = gen_rtx_SET (VOIDmode, target, x);\n+\n+  x = emit_insn (x);\n+  if (recog_memoized (x) < 0)\n+    {\n+      remove_insn (x);\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Similar, but generate a vec_concat from op0 and op1 as well.  */\n+\n+static bool\n+mips_expand_vselect_vconcat (rtx target, rtx op0, rtx op1,\n+\t\t\t     const unsigned char *perm, unsigned nelt)\n+{\n+  enum machine_mode v2mode;\n+  rtx x;\n+\n+  v2mode = GET_MODE_2XWIDER_MODE (GET_MODE (op0));\n+  x = gen_rtx_VEC_CONCAT (v2mode, op0, op1);\n+  return mips_expand_vselect (target, x, perm, nelt);\n+}\n+\n+/* Recognize patterns for even-odd extraction.  */\n+\n+static bool\n+mips_expand_vpc_loongson_even_odd (struct expand_vec_perm_d *d)\n+{\n+  unsigned i, odd, nelt = d->nelt;\n+  rtx t0, t1, t2, t3;\n+\n+  if (!(TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS))\n+    return false;\n+  /* Even-odd for V2SI/V2SFmode is matched by interleave directly.  */\n+  if (nelt < 4)\n+    return false;\n+\n+  odd = d->perm[0];\n+  if (odd > 1)\n+    return false;\n+  for (i = 1; i < nelt; ++i)\n+    if (d->perm[i] != i * 2 + odd)\n+      return false;\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  /* We need 2*log2(N)-1 operations to achieve odd/even with interleave. */\n+  t0 = gen_reg_rtx (d->vmode);\n+  t1 = gen_reg_rtx (d->vmode);\n+  switch (d->vmode)\n+    {\n+    case V4HImode:\n+      emit_insn (gen_loongson_punpckhhw (t0, d->op0, d->op1));\n+      emit_insn (gen_loongson_punpcklhw (t1, d->op0, d->op1));\n+      if (odd)\n+\temit_insn (gen_loongson_punpckhhw (d->target, t1, t0));\n+      else\n+\temit_insn (gen_loongson_punpcklhw (d->target, t1, t0));\n+      break;\n+\n+    case V8QImode:\n+      t2 = gen_reg_rtx (d->vmode);\n+      t3 = gen_reg_rtx (d->vmode);\n+      emit_insn (gen_loongson_punpckhbh (t0, d->op0, d->op1));\n+      emit_insn (gen_loongson_punpcklbh (t1, d->op0, d->op1));\n+      emit_insn (gen_loongson_punpckhbh (t2, t1, t0));\n+      emit_insn (gen_loongson_punpcklbh (t3, t1, t0));\n+      if (odd)\n+\temit_insn (gen_loongson_punpckhbh (d->target, t3, t2));\n+      else\n+\temit_insn (gen_loongson_punpcklbh (d->target, t3, t2));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return true;\n+}\n+\n+/* Recognize patterns for the Loongson PSHUFH instruction.  */\n+\n+static bool\n+mips_expand_vpc_loongson_pshufh (struct expand_vec_perm_d *d)\n+{\n+  unsigned i, mask;\n+  rtx rmask;\n+\n+  if (!(TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS))\n+    return false;\n+  if (d->vmode != V4HImode)\n+    return false;\n+  if (d->testing_p)\n+    return true;\n+\n+  /* Convert the selector into the packed 8-bit form for pshufh.  */\n+  /* Recall that loongson is little-endian only.  No big-endian\n+     adjustment required.  */\n+  for (i = mask = 0; i < 4; i++)\n+    mask |= (d->perm[i] & 3) << (i * 2);\n+  rmask = force_reg (SImode, GEN_INT (mask));\n+\n+  if (d->one_vector_p)\n+    emit_insn (gen_loongson_pshufh (d->target, d->op0, rmask));\n+  else\n+    {\n+      rtx t0, t1, x, merge, rmerge[4];\n+\n+      t0 = gen_reg_rtx (V4HImode);\n+      t1 = gen_reg_rtx (V4HImode);\n+      emit_insn (gen_loongson_pshufh (t1, d->op1, rmask));\n+      emit_insn (gen_loongson_pshufh (t0, d->op0, rmask));\n+\n+      for (i = 0; i < 4; ++i)\n+\trmerge[i] = (d->perm[i] & 4 ? constm1_rtx : const0_rtx);\n+      merge = gen_rtx_CONST_VECTOR (V4HImode, gen_rtvec_v (4, rmerge));\n+      merge = force_reg (V4HImode, merge);\n+\n+      x = gen_rtx_AND (V4HImode, merge, t1);\n+      emit_insn (gen_rtx_SET (VOIDmode, t1, x));\n+\n+      x = gen_rtx_NOT (V4HImode, merge);\n+      x = gen_rtx_AND (V4HImode, x, t0);\n+      emit_insn (gen_rtx_SET (VOIDmode, t0, x));\n+\n+      x = gen_rtx_IOR (V4HImode, t0, t1);\n+      emit_insn (gen_rtx_SET (VOIDmode, d->target, x));\n+    }\n+\n+  return true;\n+}\n+\n+/* Recognize broadcast patterns for the Loongson.  */\n+\n+static bool\n+mips_expand_vpc_loongson_bcast (struct expand_vec_perm_d *d)\n+{\n+  unsigned i, elt;\n+  rtx t0, t1;\n+\n+  if (!(TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS))\n+    return false;\n+  /* Note that we've already matched V2SI via punpck and V4HI via pshufh.  */\n+  if (d->vmode != V8QImode)\n+    return false;\n+  if (!d->one_vector_p)\n+    return false;\n+\n+  elt = d->perm[0];\n+  for (i = 1; i < 8; ++i)\n+    if (d->perm[i] != elt)\n+      return false;\n+\n+  if (d->testing_p)\n+    return true;\n+\n+  /* With one interleave we put two of the desired element adjacent.  */\n+  t0 = gen_reg_rtx (V8QImode);\n+  if (elt < 4)\n+    emit_insn (gen_loongson_punpcklbh (t0, d->op0, d->op0));\n+  else\n+    emit_insn (gen_loongson_punpckhbh (t0, d->op0, d->op0));\n+\n+  /* Shuffle that one HImode element into all locations.  */\n+  elt &= 3;\n+  elt *= 0x55;\n+  t1 = gen_reg_rtx (V4HImode);\n+  emit_insn (gen_loongson_pshufh (t1, gen_lowpart (V4HImode, t0),\n+\t\t\t\t  force_reg (SImode, GEN_INT (elt))));\n+\n+  emit_move_insn (d->target, gen_lowpart (V8QImode, t1));\n+  return true;\n+}\n+\n+static bool\n+mips_expand_vec_perm_const_1 (struct expand_vec_perm_d *d)\n+{\n+  unsigned int i, nelt = d->nelt;\n+  unsigned char perm2[MAX_VECT_LEN];\n+\n+  if (d->one_vector_p)\n+    {\n+      /* Try interleave with alternating operands.  */\n+      memcpy (perm2, d->perm, sizeof(perm2));\n+      for (i = 1; i < nelt; i += 2)\n+\tperm2[i] += nelt;\n+      if (mips_expand_vselect_vconcat (d->target, d->op0, d->op1, perm2, nelt))\n+\treturn true;\n+    }\n+  else\n+    {\n+      if (mips_expand_vselect_vconcat (d->target, d->op0, d->op1,\n+\t\t\t\t       d->perm, nelt))\n+\treturn true;\n+\n+      /* Try again with swapped operands.  */\n+      for (i = 0; i < nelt; ++i)\n+\tperm2[i] = (d->perm[i] + nelt) & (2 * nelt - 1);\n+      if (mips_expand_vselect_vconcat (d->target, d->op1, d->op0, perm2, nelt))\n+\treturn true;\n+    }\n+\n+  if (mips_expand_vpc_loongson_even_odd (d))\n+    return true;\n+  if (mips_expand_vpc_loongson_pshufh (d))\n+    return true;\n+  if (mips_expand_vpc_loongson_bcast (d))\n+    return true;\n+  return false;\n+}\n+\n+/* Expand a vec_perm_const pattern.  */\n+\n+bool\n+mips_expand_vec_perm_const (rtx operands[4])\n+{\n+  struct expand_vec_perm_d d;\n+  int i, nelt, which;\n+  unsigned char orig_perm[MAX_VECT_LEN];\n+  rtx sel;\n+  bool ok;\n+\n+  d.target = operands[0];\n+  d.op0 = operands[1];\n+  d.op1 = operands[2];\n+  sel = operands[3];\n+\n+  d.vmode = GET_MODE (d.target);\n+  gcc_assert (VECTOR_MODE_P (d.vmode));\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = false;\n+\n+  for (i = which = 0; i < nelt; ++i)\n+    {\n+      rtx e = XVECEXP (sel, 0, i);\n+      int ei = INTVAL (e) & (2 * nelt - 1);\n+      which |= (ei < nelt ? 1 : 2);\n+      orig_perm[i] = ei;\n+    }\n+  memcpy (d.perm, orig_perm, MAX_VECT_LEN);\n+\n+  switch (which)\n+    {\n+    default:\n+      gcc_unreachable();\n+\n+    case 3:\n+      d.one_vector_p = false;\n+      if (!rtx_equal_p (d.op0, d.op1))\n+\tbreak;\n+      /* FALLTHRU */\n+\n+    case 2:\n+      for (i = 0; i < nelt; ++i)\n+        d.perm[i] &= nelt - 1;\n+      d.op0 = d.op1;\n+      d.one_vector_p = true;\n+      break;\n+\n+    case 1:\n+      d.op1 = d.op0;\n+      d.one_vector_p = true;\n+      break;\n+    }\n+\n+  ok = mips_expand_vec_perm_const_1 (&d);\n+\n+  /* If we were given a two-vector permutation which just happened to\n+     have both input vectors equal, we folded this into a one-vector\n+     permutation.  There are several loongson patterns that are matched\n+     via direct vec_select+vec_concat expansion, but we do not have\n+     support in mips_expand_vec_perm_const_1 to guess the adjustment\n+     that should be made for a single operand.  Just try again with\n+     the original permutation.  */\n+  if (!ok && which == 3)\n+    {\n+      d.op0 = operands[1];\n+      d.op1 = operands[2];\n+      d.one_vector_p = false;\n+      memcpy (d.perm, orig_perm, MAX_VECT_LEN);\n+      ok = mips_expand_vec_perm_const_1 (&d);\n+    }\n+\n+  return ok;\n+}\n+\n+/* Implement TARGET_VECTORIZE_VEC_PERM_CONST_OK.  */\n+\n+static bool\n+mips_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n+\t\t\t\t  const unsigned char *sel)\n+{\n+  struct expand_vec_perm_d d;\n+  unsigned int i, nelt, which;\n+  bool ret;\n+\n+  d.vmode = vmode;\n+  d.nelt = nelt = GET_MODE_NUNITS (d.vmode);\n+  d.testing_p = true;\n+  memcpy (d.perm, sel, nelt);\n+\n+  /* Categorize the set of elements in the selector.  */\n+  for (i = which = 0; i < nelt; ++i)\n+    {\n+      unsigned char e = d.perm[i];\n+      gcc_assert (e < 2 * nelt);\n+      which |= (e < nelt ? 1 : 2);\n+    }\n+\n+  /* For all elements from second vector, fold the elements to first.  */\n+  if (which == 2)\n+    for (i = 0; i < nelt; ++i)\n+      d.perm[i] -= nelt;\n+\n+  /* Check whether the mask can be applied to the vector type.  */\n+  d.one_vector_p = (which != 3);\n+\n+  d.target = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 1);\n+  d.op1 = d.op0 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 2);\n+  if (!d.one_vector_p)\n+    d.op1 = gen_raw_REG (d.vmode, LAST_VIRTUAL_REGISTER + 3);\n+\n+  start_sequence ();\n+  ret = mips_expand_vec_perm_const_1 (&d);\n+  end_sequence ();\n+\n+  return ret;\n+}\n+\n+/* Expand an integral vector unpack operation.  */\n+\n+void\n+mips_expand_vec_unpack (rtx operands[2], bool unsigned_p, bool high_p)\n+{\n+  enum machine_mode imode = GET_MODE (operands[1]);\n+  rtx (*unpack) (rtx, rtx, rtx);\n+  rtx (*cmpgt) (rtx, rtx, rtx);\n+  rtx tmp, dest, zero;\n+\n+  switch (imode)\n+    {\n+    case V8QImode:\n+      if (high_p)\n+\tunpack = gen_loongson_punpckhbh;\n+      else\n+\tunpack = gen_loongson_punpcklbh;\n+      cmpgt = gen_loongson_pcmpgtb;\n+      break;\n+    case V4HImode:\n+      if (high_p)\n+\tunpack = gen_loongson_punpckhhw;\n+      else\n+\tunpack = gen_loongson_punpcklhw;\n+      cmpgt = gen_loongson_pcmpgth;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  zero = force_reg (imode, CONST0_RTX (imode));\n+  if (unsigned_p)\n+    tmp = zero;\n+  else\n+    {\n+      tmp = gen_reg_rtx (imode);\n+      emit_insn (cmpgt (tmp, zero, operands[1]));\n+    }\n+\n+  dest = gen_reg_rtx (imode);\n+  emit_insn (unpack (dest, operands[1], tmp));\n+\n+  emit_move_insn (operands[0], gen_lowpart (GET_MODE (operands[0]), dest));\n+}\n+\n+/* A subroutine of mips_expand_vec_init, match constant vector elements.  */\n+\n+static inline bool\n+mips_constant_elt_p (rtx x)\n+{\n+  return CONST_INT_P (x) || GET_CODE (x) == CONST_DOUBLE;\n+}\n+\n+/* A subroutine of mips_expand_vec_init, expand via broadcast.  */\n+\n+static void\n+mips_expand_vi_broadcast (enum machine_mode vmode, rtx target, rtx elt)\n+{\n+  struct expand_vec_perm_d d;\n+  rtx t1;\n+  bool ok;\n+\n+  if (elt != const0_rtx)\n+    elt = force_reg (GET_MODE_INNER (vmode), elt);\n+  if (REG_P (elt))\n+    elt = gen_lowpart (DImode, elt);\n+\n+  t1 = gen_reg_rtx (vmode);\n+  switch (vmode)\n+    {\n+    case V8QImode:\n+      emit_insn (gen_loongson_vec_init1_v8qi (t1, elt));\n+      break;\n+    case V4HImode:\n+      emit_insn (gen_loongson_vec_init1_v4hi (t1, elt));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  memset (&d, 0, sizeof (d));\n+  d.target = target;\n+  d.op0 = t1;\n+  d.op1 = t1;\n+  d.vmode = vmode;\n+  d.nelt = GET_MODE_NUNITS (vmode);\n+  d.one_vector_p = true;\n+\n+  ok = mips_expand_vec_perm_const_1 (&d);\n+  gcc_assert (ok);\n+}\n+\n+/* A subroutine of mips_expand_vec_init, replacing all of the non-constant\n+   elements of VALS with zeros, copy the constant vector to TARGET.  */\n+\n+static void\n+mips_expand_vi_constant (enum machine_mode vmode, unsigned nelt,\n+\t\t\t rtx target, rtx vals)\n+{\n+  rtvec vec = shallow_copy_rtvec (XVEC (vals, 0));\n+  unsigned i;\n+\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      if (!mips_constant_elt_p (RTVEC_ELT (vec, i)))\n+\tRTVEC_ELT (vec, i) = const0_rtx;\n+    }\n+\n+  emit_move_insn (target, gen_rtx_CONST_VECTOR (vmode, vec));\n+}\n+\n+\n+/* A subroutine of mips_expand_vec_init, expand via pinsrh.  */\n+\n+static void\n+mips_expand_vi_loongson_one_pinsrh (rtx target, rtx vals, unsigned one_var)\n+{\n+  mips_expand_vi_constant (V4HImode, 4, target, vals);\n+\n+  emit_insn (gen_vec_setv4hi (target, target, XVECEXP (vals, 0, one_var),\n+\t\t\t      GEN_INT (one_var)));\n+}\n+\n+/* A subroutine of mips_expand_vec_init, expand anything via memory.  */\n+\n+static void\n+mips_expand_vi_general (enum machine_mode vmode, enum machine_mode imode,\n+\t\t\tunsigned nelt, unsigned nvar, rtx target, rtx vals)\n+{\n+  rtx mem = assign_stack_temp (vmode, GET_MODE_SIZE (vmode), 0);\n+  unsigned int i, isize = GET_MODE_SIZE (imode);\n+\n+  if (nvar < nelt)\n+    mips_expand_vi_constant (vmode, nelt, mem, vals);\n+\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      rtx x = XVECEXP (vals, 0, i);\n+      if (!mips_constant_elt_p (x))\n+\temit_move_insn (adjust_address (mem, imode, i * isize), x);\n+    }\n+\n+  emit_move_insn (target, mem);\n+}\n+\n+/* Expand a vector initialization.  */\n+\n+void\n+mips_expand_vector_init (rtx target, rtx vals)\n+{\n+  enum machine_mode vmode = GET_MODE (target);\n+  enum machine_mode imode = GET_MODE_INNER (vmode);\n+  unsigned i, nelt = GET_MODE_NUNITS (vmode);\n+  unsigned nvar = 0, one_var = -1u;\n+  bool all_same = true;\n+  rtx x;\n+\n+  for (i = 0; i < nelt; ++i)\n+    {\n+      x = XVECEXP (vals, 0, i);\n+      if (!mips_constant_elt_p (x))\n+\tnvar++, one_var = i;\n+      if (i > 0 && !rtx_equal_p (x, XVECEXP (vals, 0, 0)))\n+\tall_same = false;\n+    }\n+\n+  /* Load constants from the pool, or whatever's handy.  */\n+  if (nvar == 0)\n+    {\n+      emit_move_insn (target, gen_rtx_CONST_VECTOR (vmode, XVEC (vals, 0)));\n+      return;\n+    }\n+\n+  /* For two-part initialization, always use CONCAT.  */\n+  if (nelt == 2)\n+    {\n+      rtx op0 = force_reg (imode, XVECEXP (vals, 0, 0));\n+      rtx op1 = force_reg (imode, XVECEXP (vals, 0, 1));\n+      x = gen_rtx_VEC_CONCAT (vmode, op0, op1);\n+      emit_insn (gen_rtx_SET (VOIDmode, target, x));\n+      return;\n+    }\n+\n+  /* Loongson is the only cpu with vectors with more elements.  */\n+  gcc_assert (TARGET_HARD_FLOAT && TARGET_LOONGSON_VECTORS);\n+\n+  /* If all values are identical, broadcast the value.  */\n+  if (all_same)\n+    {\n+      mips_expand_vi_broadcast (vmode, target, XVECEXP (vals, 0, 0));\n+      return;\n+    }\n+\n+  /* If we've only got one non-variable V4HImode, use PINSRH.  */\n+  if (nvar == 1 && vmode == V4HImode)\n+    {\n+      mips_expand_vi_loongson_one_pinsrh (target, vals, one_var);\n+      return;\n+    }\n+\n+  mips_expand_vi_general (vmode, imode, nelt, nvar, target, vals);\n+}\n+\n+/* Expand a vector reduction.  */\n+\n+void\n+mips_expand_vec_reduc (rtx target, rtx in, rtx (*gen)(rtx, rtx, rtx))\n+{\n+  enum machine_mode vmode = GET_MODE (in);\n+  unsigned char perm2[2];\n+  rtx last, next, fold, x;\n+  bool ok;\n+\n+  last = in;\n+  fold = gen_reg_rtx (vmode);\n+  switch (vmode)\n+    {\n+    case V2SFmode:\n+      /* Use PUL/PLU to produce { L, H } op { H, L }.\n+\t By reversing the pair order, rather than a pure interleave high,\n+\t we avoid erroneous exceptional conditions that we might otherwise\n+\t produce from the computation of H op H.  */\n+      perm2[0] = 1;\n+      perm2[1] = 2;\n+      ok = mips_expand_vselect_vconcat (fold, last, last, perm2, 2);\n+      gcc_assert (ok);\n+      break;\n+\n+    case V2SImode:\n+      /* Use interleave to produce { H, L } op { H, H }.  */\n+      emit_insn (gen_loongson_punpckhwd (fold, last, last));\n+      break;\n+\n+    case V4HImode:\n+      /* Perform the first reduction with interleave,\n+\t and subsequent reductions with shifts.  */\n+      emit_insn (gen_loongson_punpckhwd_hi (fold, last, last));\n+\n+      next = gen_reg_rtx (vmode);\n+      emit_insn (gen (next, last, fold));\n+      last = next;\n+\n+      fold = gen_reg_rtx (vmode);\n+      x = force_reg (SImode, GEN_INT (16));\n+      emit_insn (gen_vec_shr_v4hi (fold, last, x));\n+      break;\n+\n+    case V8QImode:\n+      emit_insn (gen_loongson_punpckhwd_qi (fold, last, last));\n+\n+      next = gen_reg_rtx (vmode);\n+      emit_insn (gen (next, last, fold));\n+      last = next;\n+\n+      fold = gen_reg_rtx (vmode);\n+      x = force_reg (SImode, GEN_INT (16));\n+      emit_insn (gen_vec_shr_v8qi (fold, last, x));\n+\n+      next = gen_reg_rtx (vmode);\n+      emit_insn (gen (next, last, fold));\n+      last = next;\n+\n+      fold = gen_reg_rtx (vmode);\n+      x = force_reg (SImode, GEN_INT (8));\n+      emit_insn (gen_vec_shr_v8qi (fold, last, x));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  emit_insn (gen (target, last, fold));\n+}\n+\n+/* Expand a vector minimum/maximum.  */\n+\n+void\n+mips_expand_vec_minmax (rtx target, rtx op0, rtx op1,\n+\t\t\trtx (*cmp) (rtx, rtx, rtx), bool min_p)\n+{\n+  enum machine_mode vmode = GET_MODE (target);\n+  rtx tc, t0, t1, x;\n+\n+  tc = gen_reg_rtx (vmode);\n+  t0 = gen_reg_rtx (vmode);\n+  t1 = gen_reg_rtx (vmode);\n+\n+  /* op0 > op1 */\n+  emit_insn (cmp (tc, op0, op1));\n+\n+  x = gen_rtx_AND (vmode, tc, (min_p ? op1 : op0));\n+  emit_insn (gen_rtx_SET (VOIDmode, t0, x));\n+\n+  x = gen_rtx_NOT (vmode, tc);\n+  x = gen_rtx_AND (vmode, x, (min_p ? op0 : op1));\n+  emit_insn (gen_rtx_SET (VOIDmode, t1, x));\n+\n+  x = gen_rtx_IOR (vmode, t0, t1);\n+  emit_insn (gen_rtx_SET (VOIDmode, target, x));\n+}\n+\f\n /* Initialize the GCC target structure.  */\n #undef TARGET_ASM_ALIGNED_HI_OP\n #define TARGET_ASM_ALIGNED_HI_OP \"\\t.half\\t\"\n@@ -16578,6 +17216,9 @@ mips_prepare_pch_save (void)\n #undef TARGET_PREPARE_PCH_SAVE\n #define TARGET_PREPARE_PCH_SAVE mips_prepare_pch_save\n \n+#undef TARGET_VECTORIZE_VEC_PERM_CONST_OK\n+#define TARGET_VECTORIZE_VEC_PERM_CONST_OK mips_vectorize_vec_perm_const_ok\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n #include \"gt-mips.h\""}, {"sha": "b6113739786f03f1c9bb60f51d40d0043050ce65", "filename": "gcc/config/mips/predicates.md", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7dab511cf3331378aaafdeb7676835c0cdb194fa/gcc%2Fconfig%2Fmips%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fpredicates.md?ref=7dab511cf3331378aaafdeb7676835c0cdb194fa", "patch": "@@ -73,8 +73,15 @@\n ;; This is used for indexing into vectors, and hence only accepts const_int.\n (define_predicate \"const_0_or_1_operand\"\n   (and (match_code \"const_int\")\n-       (ior (match_test \"op == CONST0_RTX (GET_MODE (op))\")\n-\t    (match_test \"op == CONST1_RTX (GET_MODE (op))\"))))\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 1)\")))\n+\n+(define_predicate \"const_2_or_3_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 2, 3)\")))\n+\n+(define_predicate \"const_0_to_3_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 3)\")))\n \n (define_predicate \"qi_mask_operand\"\n   (and (match_code \"const_int\")"}]}