{"sha": "c7e30a96b100f767d33424bb97a3527fe88f8c14", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzdlMzBhOTZiMTAwZjc2N2QzMzQyNGJiOTdhMzUyN2ZlODhmOGMxNA==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2014-03-26T07:38:30Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2014-03-26T07:38:30Z"}, "message": "re PR rtl-optimization/60452 (wrong code at -O1 with large offsets in the frame)\n\n\tPR rtl-optimization/60452\n\t* rtlanal.c (rtx_addr_can_trap_p_1): Fix head comment.\n\t<case REG>: Return 1 for invalid offsets from the frame pointer.\n\nFrom-SVN: r208837", "tree": {"sha": "545a241db523ea18afe2f6eccda8cad4e7308fc5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/545a241db523ea18afe2f6eccda8cad4e7308fc5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c7e30a96b100f767d33424bb97a3527fe88f8c14", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e30a96b100f767d33424bb97a3527fe88f8c14", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7e30a96b100f767d33424bb97a3527fe88f8c14", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7e30a96b100f767d33424bb97a3527fe88f8c14/comments", "author": null, "committer": null, "parents": [{"sha": "d615d763225f330cf5416c95ad0726db67e227b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d615d763225f330cf5416c95ad0726db67e227b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d615d763225f330cf5416c95ad0726db67e227b4"}], "stats": {"total": 62, "additions": 50, "deletions": 12}, "files": [{"sha": "7fea9dedf08d8414f6fcc2a1ae08b8ac538f7138", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e30a96b100f767d33424bb97a3527fe88f8c14/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e30a96b100f767d33424bb97a3527fe88f8c14/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c7e30a96b100f767d33424bb97a3527fe88f8c14", "patch": "@@ -1,3 +1,9 @@\n+2014-03-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR rtl-optimization/60452\n+\t* rtlanal.c (rtx_addr_can_trap_p_1): Fix head comment.\n+\t<case REG>: Return 1 for invalid offsets from the frame pointer.\n+\n 2014-03-26  Marek Polacek  <polacek@redhat.com>\n \n \tPR c/37428"}, {"sha": "98fbacce4a2d4881ebdc2dd32860512c20393673", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e30a96b100f767d33424bb97a3527fe88f8c14/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e30a96b100f767d33424bb97a3527fe88f8c14/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=c7e30a96b100f767d33424bb97a3527fe88f8c14", "patch": "@@ -224,22 +224,23 @@ rtx_varies_p (const_rtx x, bool for_alias)\n   return 0;\n }\n \n-/* Return nonzero if the use of X as an address in a MEM can cause a trap.\n-   MODE is the mode of the MEM (not that of X) and UNALIGNED_MEMS controls\n-   whether nonzero is returned for unaligned memory accesses on strict\n-   alignment machines.  */\n+/* Return nonzero if the use of X+OFFSET as an address in a MEM with SIZE\n+   bytes can cause a trap.  MODE is the mode of the MEM (not that of X) and\n+   UNALIGNED_MEMS controls whether nonzero is returned for unaligned memory\n+   references on strict alignment machines.  */\n \n static int\n rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n \t\t       enum machine_mode mode, bool unaligned_mems)\n {\n   enum rtx_code code = GET_CODE (x);\n \n-  if (STRICT_ALIGNMENT\n-      && unaligned_mems\n-      && GET_MODE_SIZE (mode) != 0)\n+  /* The offset must be a multiple of the mode size if we are considering\n+     unaligned memory references on strict alignment machines.  */\n+  if (STRICT_ALIGNMENT && unaligned_mems && GET_MODE_SIZE (mode) != 0)\n     {\n       HOST_WIDE_INT actual_offset = offset;\n+\n #ifdef SPARC_STACK_BOUNDARY_HACK\n       /* ??? The SPARC port may claim a STACK_BOUNDARY higher than\n \t     the real alignment of %sp.  However, when it does this, the\n@@ -298,8 +299,27 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n       return 0;\n \n     case REG:\n-      /* As in rtx_varies_p, we have to use the actual rtx, not reg number.  */\n-      if (x == frame_pointer_rtx || x == hard_frame_pointer_rtx\n+      /* Stack references are assumed not to trap, but we need to deal with\n+\t nonsensical offsets.  */\n+      if (x == frame_pointer_rtx)\n+\t{\n+\t  HOST_WIDE_INT adj_offset = offset - STARTING_FRAME_OFFSET;\n+\t  if (size == 0)\n+\t    size = GET_MODE_SIZE (mode);\n+\t  if (FRAME_GROWS_DOWNWARD)\n+\t    {\n+\t      if (adj_offset < frame_offset || adj_offset + size - 1 >= 0)\n+\t\treturn 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (adj_offset < 0 || adj_offset + size - 1 >= frame_offset)\n+\t\treturn 1;\n+\t    }\n+\t  return 0;\n+\t}\n+      /* ??? Need to add a similar guard for nonsensical offsets.  */\n+      if (x == hard_frame_pointer_rtx\n \t  || x == stack_pointer_rtx\n \t  /* The arg pointer varies if it is not a fixed register.  */\n \t  || (x == arg_pointer_rtx && fixed_regs[ARG_POINTER_REGNUM]))\n@@ -320,9 +340,7 @@ rtx_addr_can_trap_p_1 (const_rtx x, HOST_WIDE_INT offset, HOST_WIDE_INT size,\n       if (XEXP (x, 0) == pic_offset_table_rtx && CONSTANT_P (XEXP (x, 1)))\n \treturn 0;\n \n-      /* - or it is an address that can't trap plus a constant integer,\n-\t   with the proper remainder modulo the mode size if we are\n-\t   considering unaligned memory references.  */\n+      /* - or it is an address that can't trap plus a constant integer.  */\n       if (CONST_INT_P (XEXP (x, 1))\n \t  && !rtx_addr_can_trap_p_1 (XEXP (x, 0), offset + INTVAL (XEXP (x, 1)),\n \t\t\t\t     size, mode, unaligned_mems))"}, {"sha": "5b245870efe81f85c7f4737bd171d7355856b4bb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e30a96b100f767d33424bb97a3527fe88f8c14/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e30a96b100f767d33424bb97a3527fe88f8c14/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c7e30a96b100f767d33424bb97a3527fe88f8c14", "patch": "@@ -1,3 +1,7 @@\n+2014-03-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.c-torture/execute/20140326-1.c: New test.\n+\n 2014-03-25  Jan Hubicka  <hubicka@ucw.cz>\n \n \tPR ipa/60315"}, {"sha": "552e21891cb0f7f8923381ba61b975cca3648673", "filename": "gcc/testsuite/gcc.c-torture/execute/20140326-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c7e30a96b100f767d33424bb97a3527fe88f8c14/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20140326-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c7e30a96b100f767d33424bb97a3527fe88f8c14/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20140326-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20140326-1.c?ref=c7e30a96b100f767d33424bb97a3527fe88f8c14", "patch": "@@ -0,0 +1,10 @@\n+int a;\n+\n+int\n+main (void)\n+{\n+  char e[2] = { 0, 0 }, f = 0;\n+  if (a == 131072)\n+    f = e[a];\n+  return f;\n+}"}]}