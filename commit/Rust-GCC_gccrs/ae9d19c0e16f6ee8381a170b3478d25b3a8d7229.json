{"sha": "ae9d19c0e16f6ee8381a170b3478d25b3a8d7229", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWU5ZDE5YzBlMTZmNmVlODM4MWExNzBiMzQ3OGQyNWIzYThkNzIyOQ==", "commit": {"author": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1996-10-29T01:08:53Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1996-10-29T01:08:53Z"}, "message": "(EXT_SHIFT_SIGNED): New macro.\n\n(shl_sext_kind, gen_shl_sext): try left shift - sign extend -\nleft shift - arithmetic right shift in case 2.\n\nFrom-SVN: r13059", "tree": {"sha": "777d75f6715445d7065937174fdc77744381644b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/777d75f6715445d7065937174fdc77744381644b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ae9d19c0e16f6ee8381a170b3478d25b3a8d7229", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9d19c0e16f6ee8381a170b3478d25b3a8d7229", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ae9d19c0e16f6ee8381a170b3478d25b3a8d7229", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ae9d19c0e16f6ee8381a170b3478d25b3a8d7229/comments", "author": null, "committer": null, "parents": [{"sha": "0f13a422020fd379d217a7ef913b3bb1002730f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f13a422020fd379d217a7ef913b3bb1002730f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f13a422020fd379d217a7ef913b3bb1002730f3"}], "stats": {"total": 37, "additions": 27, "deletions": 10}, "files": [{"sha": "cafbc5169ca21fcd7cbb8e19e7ab3b6233081014", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ae9d19c0e16f6ee8381a170b3478d25b3a8d7229/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ae9d19c0e16f6ee8381a170b3478d25b3a8d7229/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=ae9d19c0e16f6ee8381a170b3478d25b3a8d7229", "patch": "@@ -701,6 +701,11 @@ static short ext_shift_amounts[32][4] = {\n   {16, 8}, {16, 1, 8}, {16, 8, 2}, {16, 8, 1, 2},\n   {16, 8, 2, 2}, {16, -1, -2, 16}, {16, -2, 16}, {16, -1, 16}};\n \n+/* Assuming we have a value that has been sign-extended by at least one bit,\n+   can we use the ext_shift_amounts with the last shift turned to an arithmetic shift\n+   to shift it by N without data loss, and quicker than by other means?  */\n+#define EXT_SHIFT_SIGNED(n) (((n) | 8) == 15)\n+\n /* This is used in length attributes in sh.md to help compute the length\n    of arbitrary constant shift instructions.  */\n \n@@ -1372,17 +1377,21 @@ shl_sext_kind (left_rtx, size_rtx, costp)\n \t      best_cost = cost;\n \t    }\n \t}\n-      if (size <= 16)\n+      /* Check if we can do a sloppy shift with a final signed shift\n+\t restoring the sign.  */\n+      if (EXT_SHIFT_SIGNED (size - ext))\n+\tcost = ext_shift_insns[ext - insize] + ext_shift_insns[size - ext] + 1;\n+      /* If not, maybe it's still cheaper to do the second shift sloppy,\n+\t and do a final sign extend?  */\n+      else if (size <= 16)\n+\tcost = ext_shift_insns[ext - insize] + 1\n+\t  + ext_shift_insns[size > ext ? size - ext : ext - size] + 1;\n+      else\n+\tcontinue;\n+      if (cost < best_cost)\n \t{\n-\t  /* Maybe it's cheaper to do the second shift sloppy, and do a\n-\t     final sign extend?  */\n-\t  cost = ext_shift_insns[ext - insize] + 1\n-\t    + ext_shift_insns[size > ext ? size - ext : ext - size] + 1;\n-\t  if (cost < best_cost)\n-\t    {\n-\t      kind = ext / 8U + 2;\n-\t      best_cost = cost;\n-\t    }\n+\t  kind = ext / 8U + 2;\n+\t  best_cost = cost;\n \t}\n     }\n   /* Check if we can sign extend in r0 */\n@@ -1493,6 +1502,14 @@ gen_shl_sext (dest, left_rtx, size_rtx, source)\n \t  {\n \t    if (shift2 > 0)\n \t      {\n+\t\tif (EXT_SHIFT_SIGNED (shift2))\n+\t\t  {\n+\t\t    operands[2] = GEN_INT (shift2 + 1);\n+\t\t    gen_shifty_op (ASHIFT, operands);\n+\t\t    operands[2] = GEN_INT (1);\n+\t\t    gen_shifty_op (ASHIFTRT, operands);\n+\t\t    break;\n+\t\t  }\n \t\toperands[2] = GEN_INT (shift2);\n \t\tgen_shifty_hi_op (ASHIFT, operands);\n \t      }"}]}