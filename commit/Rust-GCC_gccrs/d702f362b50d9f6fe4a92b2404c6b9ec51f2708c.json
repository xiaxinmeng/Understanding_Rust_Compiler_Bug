{"sha": "d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcwMmYzNjJiNTBkOWY2ZmU0YTkyYjI0MDRjNmI5ZWM1MWYyNzA4Yw==", "commit": {"author": {"name": "Georg-Johann Lay", "email": "avr@gjlay.de", "date": "2011-10-29T14:35:59Z"}, "committer": {"name": "Georg-Johann Lay", "email": "gjl@gcc.gnu.org", "date": "2011-10-29T14:35:59Z"}, "message": "re PR target/50887 ([avr] Support ACCUMULATE_OUTGOING_ARGS)\n\n\tPR target/50887\n\t* config/avr/avr.opt (-maccumulate-args): New option.\n\t* config/avr/avr.h (STARTING_FRAME_OFFSET): Redefine to\n\tavr_starting_frame_offset.\n\t(ACCUMULATE_OUTGOING_ARGS): Define to avr_accumulate_outgoing_args.\n\t* config/avr/avr.md (UNSPECV_WRITE_SP_IRQ_ON): Remove.\n\t(UNSPECV_WRITE_SP_IRQ_OFF): Remove.\n\t(UNSPECV_WRITE_SP): New constant.\n\t(*addhi3_sp_R): Rewrite to...\n\t(*addhi3_sp): ...this new insn.\n\t(movhi_sp_r_irq_off, movhi_sp_r_irq_on): Combine to...\n\t(movhi_sp_r): ...this new insn.\n\t* config/avr/avr-protos.h (avr_accumulate_outgoing_args): New.\n\t(avr_starting_frame_offset): New.\n\t* config/avr/avr.c (avr_accumulate_outgoing_args): New function.\n\t(avr_starting_frame_offset): New function.\n\t(avr_outgoing_args_size): New static function.\n\t(avr_initial_elimination_offset): Use it.\n\t(avr_simple_epilogue): Use it.\n\t(avr_asm_function_end_prologue): Use it.\n\t(expand_epilogue): Use it.\n\t(expand_prologue): Use it.  Break out code to...\n\t(avr_prologue_setup_frame): ...this new static function.\n\t(avr_can_eliminate): Allow eliminating to frame pointer if there\n\tis one.\n\t(avr_frame_pointer_required_p): Use frame pointer if target has a\n\tnonlocal label.\n\t* config/avr/constraints.md (R): Remove.\n\t(Csp): New constraint.\n\t* config/avr/predicates.md (avr_sp_immediate_operand): Use it.\n\nFrom-SVN: r180654", "tree": {"sha": "2b7105e17f53cbbc8c1dab89a9af8469370a09bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b7105e17f53cbbc8c1dab89a9af8469370a09bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/comments", "author": null, "committer": {"login": "sprintersb", "id": 8905355, "node_id": "MDQ6VXNlcjg5MDUzNTU=", "avatar_url": "https://avatars.githubusercontent.com/u/8905355?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sprintersb", "html_url": "https://github.com/sprintersb", "followers_url": "https://api.github.com/users/sprintersb/followers", "following_url": "https://api.github.com/users/sprintersb/following{/other_user}", "gists_url": "https://api.github.com/users/sprintersb/gists{/gist_id}", "starred_url": "https://api.github.com/users/sprintersb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sprintersb/subscriptions", "organizations_url": "https://api.github.com/users/sprintersb/orgs", "repos_url": "https://api.github.com/users/sprintersb/repos", "events_url": "https://api.github.com/users/sprintersb/events{/privacy}", "received_events_url": "https://api.github.com/users/sprintersb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f439d6bad9ee840bf7e63e0f7a74440679bb50e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f439d6bad9ee840bf7e63e0f7a74440679bb50e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f439d6bad9ee840bf7e63e0f7a74440679bb50e0"}], "stats": {"total": 874, "additions": 512, "deletions": 362}, "files": [{"sha": "f25b3f085f2df59c7070e56a9cad420a617dff80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "patch": "@@ -1,3 +1,36 @@\n+2011-10-29  Georg-Johann Lay  <avr@gjlay.de>\n+\n+\tPR target/50887\n+\t* config/avr/avr.opt (-maccumulate-args): New option.\n+\t* config/avr/avr.h (STARTING_FRAME_OFFSET): Redefine to\n+\tavr_starting_frame_offset.\n+\t(ACCUMULATE_OUTGOING_ARGS): Define to avr_accumulate_outgoing_args.\n+\t* config/avr/avr.md (UNSPECV_WRITE_SP_IRQ_ON): Remove.\n+\t(UNSPECV_WRITE_SP_IRQ_OFF): Remove.\n+\t(UNSPECV_WRITE_SP): New constant.\n+\t(*addhi3_sp_R): Rewrite to...\n+\t(*addhi3_sp): ...this new insn.\n+\t(movhi_sp_r_irq_off, movhi_sp_r_irq_on): Combine to...\n+\t(movhi_sp_r): ...this new insn.\n+\t* config/avr/avr-protos.h (avr_accumulate_outgoing_args): New.\n+\t(avr_starting_frame_offset): New.\n+\t* config/avr/avr.c (avr_accumulate_outgoing_args): New function.\n+\t(avr_starting_frame_offset): New function.\n+\t(avr_outgoing_args_size): New static function.\n+\t(avr_initial_elimination_offset): Use it.\n+\t(avr_simple_epilogue): Use it.\n+\t(avr_asm_function_end_prologue): Use it.\n+\t(expand_epilogue): Use it.\n+\t(expand_prologue): Use it.  Break out code to...\n+\t(avr_prologue_setup_frame): ...this new static function.\n+\t(avr_can_eliminate): Allow eliminating to frame pointer if there\n+\tis one.\n+\t(avr_frame_pointer_required_p): Use frame pointer if target has a\n+\tnonlocal label.\n+\t* config/avr/constraints.md (R): Remove.\n+\t(Csp): New constraint.\n+\t* config/avr/predicates.md (avr_sp_immediate_operand): Use it.\n+\n 2011-10-29  Andi Kleen  <ak@linux.intel.com>\n \n \t* gcc-ar.c (target_machine): Add."}, {"sha": "b32e697f9cac1b1f6740c3809261f4db27e990c8", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "patch": "@@ -32,6 +32,7 @@ extern int avr_initial_elimination_offset (int from, int to);\n extern int avr_simple_epilogue (void);\n extern int avr_hard_regno_rename_ok (unsigned int, unsigned int);\n extern rtx avr_return_addr_rtx (int count, rtx tem);\n+extern bool avr_accumulate_outgoing_args (void);\n \n #ifdef TREE_CODE\n extern void avr_asm_output_aligned_decl_common (FILE*, const_tree, const char*, unsigned HOST_WIDE_INT, unsigned int, bool);\n@@ -77,6 +78,7 @@ extern bool avr_rotate_bytes (rtx operands[]);\n extern void expand_prologue (void);\n extern void expand_epilogue (bool);\n extern int avr_epilogue_uses (int regno);\n+extern int avr_starting_frame_offset (void);\n \n extern void avr_output_bld (rtx operands[], int bit_nr);\n extern void avr_output_addr_vec_elt (FILE *stream, int value);"}, {"sha": "187dcb149128d8904ab7634798b37a2cc2d54710", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 442, "deletions": 330, "changes": 772, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "patch": "@@ -433,6 +433,47 @@ avr_OS_main_function_p (tree func)\n   return avr_lookup_function_attribute1 (func, \"OS_main\");\n }\n \n+\n+/* Implement `ACCUMULATE_OUTGOING_ARGS'.  */\n+bool\n+avr_accumulate_outgoing_args (void)\n+{\n+  if (!cfun)\n+    return TARGET_ACCUMULATE_OUTGOING_ARGS;\n+\n+  /* FIXME: For setjmp and in avr_builtin_setjmp_frame_value we don't know\n+        what offset is correct.  In some cases it is relative to\n+        virtual_outgoing_args_rtx and in others it is relative to\n+        virtual_stack_vars_rtx.  For example code see\n+            gcc.c-torture/execute/built-in-setjmp.c\n+            gcc.c-torture/execute/builtins/sprintf-chk.c   */\n+  \n+  return (TARGET_ACCUMULATE_OUTGOING_ARGS\n+          && !(cfun->calls_setjmp\n+               || cfun->has_nonlocal_label));\n+}\n+\n+\n+/* Report contribution of accumulated outgoing arguments to stack size.  */\n+\n+static inline int\n+avr_outgoing_args_size (void)\n+{\n+  return ACCUMULATE_OUTGOING_ARGS ? crtl->outgoing_args_size : 0;\n+}\n+\n+\n+/* Implement `STARTING_FRAME_OFFSET'.  */\n+/* This is the offset from the frame pointer register to the first stack slot\n+   that contains a variable living in the frame.  */\n+\n+int\n+avr_starting_frame_offset (void)\n+{\n+  return 1 + avr_outgoing_args_size ();\n+}\n+\n+\n /* Return the number of hard registers to push/pop in the prologue/epilogue\n    of the current function, and optionally store these registers in SET.  */\n \n@@ -441,7 +482,7 @@ avr_regs_to_save (HARD_REG_SET *set)\n {\n   int reg, count;\n   int int_or_sig_p = (interrupt_function_p (current_function_decl)\n-\t\t      || signal_function_p (current_function_decl));\n+                      || signal_function_p (current_function_decl));\n \n   if (set)\n     CLEAR_HARD_REG_SET (*set);\n@@ -457,20 +498,22 @@ avr_regs_to_save (HARD_REG_SET *set)\n   for (reg = 0; reg < 32; reg++)\n     {\n       /* Do not push/pop __tmp_reg__, __zero_reg__, as well as\n-\t any global register variables.  */\n+         any global register variables.  */\n       if (fixed_regs[reg])\n-\tcontinue;\n+        continue;\n \n       if ((int_or_sig_p && !current_function_is_leaf && call_used_regs[reg])\n-\t  || (df_regs_ever_live_p (reg)\n-\t      && (int_or_sig_p || !call_used_regs[reg])\n-\t      && !(frame_pointer_needed\n-\t\t   && (reg == REG_Y || reg == (REG_Y+1)))))\n-\t{\n-\t  if (set)\n-\t    SET_HARD_REG_BIT (*set, reg);\n-\t  count++;\n-\t}\n+          || (df_regs_ever_live_p (reg)\n+              && (int_or_sig_p || !call_used_regs[reg])\n+              /* Don't record frame pointer registers here.  They are treated\n+                 indivitually in prologue.  */\n+              && !(frame_pointer_needed\n+                   && (reg == REG_Y || reg == (REG_Y+1)))))\n+        {\n+          if (set)\n+            SET_HARD_REG_BIT (*set, reg);\n+          count++;\n+        }\n     }\n   return count;\n }\n@@ -481,9 +524,10 @@ static bool\n avr_can_eliminate (const int from, const int to)\n {\n   return ((from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n-\t  || ((from == FRAME_POINTER_REGNUM \n-\t       || from == FRAME_POINTER_REGNUM + 1)\n-\t      && !frame_pointer_needed));\n+          || (frame_pointer_needed && to == FRAME_POINTER_REGNUM)\n+          || ((from == FRAME_POINTER_REGNUM \n+               || from == FRAME_POINTER_REGNUM + 1)\n+              && !frame_pointer_needed));\n }\n \n /* Compute offset between arg_pointer and frame_pointer.  */\n@@ -497,9 +541,10 @@ avr_initial_elimination_offset (int from, int to)\n     {\n       int offset = frame_pointer_needed ? 2 : 0;\n       int avr_pc_size = AVR_HAVE_EIJMP_EICALL ? 3 : 2;\n-\n+      \n       offset += avr_regs_to_save (NULL);\n-      return get_frame_size () + (avr_pc_size) + 1 + offset;\n+      return (get_frame_size () + avr_outgoing_args_size()\n+              + avr_pc_size + 1 + offset);\n     }\n }\n \n@@ -546,12 +591,13 @@ int\n avr_simple_epilogue (void)\n {\n   return (! frame_pointer_needed\n-\t  && get_frame_size () == 0\n-\t  && avr_regs_to_save (NULL) == 0\n-\t  && ! interrupt_function_p (current_function_decl)\n-\t  && ! signal_function_p (current_function_decl)\n-\t  && ! avr_naked_function_p (current_function_decl)\n-\t  && ! TREE_THIS_VOLATILE (current_function_decl));\n+          && get_frame_size () == 0\n+          && avr_outgoing_args_size() == 0\n+          && avr_regs_to_save (NULL) == 0\n+          && ! interrupt_function_p (current_function_decl)\n+          && ! signal_function_p (current_function_decl)\n+          && ! avr_naked_function_p (current_function_decl)\n+          && ! TREE_THIS_VOLATILE (current_function_decl));\n }\n \n /* This function checks sequence of live registers.  */\n@@ -656,17 +702,238 @@ emit_push_byte (unsigned regno, bool frame_related_p)\n   cfun->machine->stack_usage++;\n }\n \n+static void\n+avr_prologue_setup_frame (HOST_WIDE_INT size, HARD_REG_SET set)\n+{\n+  rtx insn;\n+  bool isr_p = cfun->machine->is_interrupt || cfun->machine->is_signal;\n+  int live_seq = sequent_regs_live ();\n+\n+  bool minimize = (TARGET_CALL_PROLOGUES\n+                   && live_seq\n+                   && !isr_p\n+                   && !cfun->machine->is_OS_task\n+                   && !cfun->machine->is_OS_main);\n+  \n+  if (minimize\n+      && (frame_pointer_needed\n+          || avr_outgoing_args_size() > 8\n+          || (AVR_2_BYTE_PC && live_seq > 6)\n+          || live_seq > 7)) \n+    {\n+      rtx pattern;\n+      int first_reg, reg, offset;\n+\n+      emit_move_insn (gen_rtx_REG (HImode, REG_X), \n+                      gen_int_mode (size, HImode));\n+\n+      pattern = gen_call_prologue_saves (gen_int_mode (live_seq, HImode),\n+                                         gen_int_mode (live_seq+size, HImode));\n+      insn = emit_insn (pattern);\n+      RTX_FRAME_RELATED_P (insn) = 1;\n+\n+      /* Describe the effect of the unspec_volatile call to prologue_saves.\n+         Note that this formulation assumes that add_reg_note pushes the\n+         notes to the front.  Thus we build them in the reverse order of\n+         how we want dwarf2out to process them.  */\n+\n+      /* The function does always set frame_pointer_rtx, but whether that\n+         is going to be permanent in the function is frame_pointer_needed.  */\n+\n+      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+                    gen_rtx_SET (VOIDmode, (frame_pointer_needed\n+                                            ? frame_pointer_rtx\n+                                            : stack_pointer_rtx),\n+                                 plus_constant (stack_pointer_rtx,\n+                                                -(size + live_seq))));\n+\n+      /* Note that live_seq always contains r28+r29, but the other\n+         registers to be saved are all below 18.  */\n+\n+      first_reg = 18 - (live_seq - 2);\n+\n+      for (reg = 29, offset = -live_seq + 1;\n+           reg >= first_reg;\n+           reg = (reg == 28 ? 17 : reg - 1), ++offset)\n+        {\n+          rtx m, r;\n+\n+          m = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, offset));\n+          r = gen_rtx_REG (QImode, reg);\n+          add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (VOIDmode, m, r));\n+        }\n+\n+      cfun->machine->stack_usage += size + live_seq;\n+    }\n+  else /* !minimize */\n+    {\n+      int reg;\n+      \n+      for (reg = 0; reg < 32; ++reg)\n+        if (TEST_HARD_REG_BIT (set, reg))\n+          emit_push_byte (reg, true);\n+\n+      if (frame_pointer_needed\n+          && (!(cfun->machine->is_OS_task || cfun->machine->is_OS_main)))\n+        {\n+          /* Push frame pointer.  Always be consistent about the\n+             ordering of pushes -- epilogue_restores expects the\n+             register pair to be pushed low byte first.  */\n+          \n+          emit_push_byte (REG_Y, true);\n+          emit_push_byte (REG_Y + 1, true);\n+        }\n+          \n+      if (frame_pointer_needed\n+          && size == 0)\n+        {\n+          insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+        }\n+      \n+      if (size != 0)\n+        {\n+          /*  Creating a frame can be done by direct manipulation of the\n+              stack or via the frame pointer. These two methods are:\n+                  fp =  sp\n+                  fp -= size\n+                  sp =  fp\n+              or\n+                  sp -= size\n+                  fp =  sp    (*)\n+              the optimum method depends on function type, stack and\n+              frame size.  To avoid a complex logic, both methods are\n+              tested and shortest is selected.\n+\n+              There is also the case where SIZE != 0 and no frame pointer is\n+              needed; this can occur if ACCUMULATE_OUTGOING_ARGS is on.\n+              In that case, insn (*) is not needed in that case.\n+              We use the X register as scratch. This is save because in X\n+              is call-clobbered.\n+                 In an interrupt routine, the case of SIZE != 0 together with\n+              !frame_pointer_needed can only occur if the function is not a\n+              leaf function and thus X has already been saved.  */\n+              \n+          rtx fp_plus_insns, fp, my_fp;\n+          rtx sp_minus_size = plus_constant (stack_pointer_rtx, -size);\n+\n+          gcc_assert (frame_pointer_needed\n+                      || !isr_p\n+                      || !current_function_is_leaf);\n+          \n+          fp = my_fp = (frame_pointer_needed\n+                        ? frame_pointer_rtx\n+                        : gen_rtx_REG (Pmode, REG_X));\n+          \n+          if (AVR_HAVE_8BIT_SP)\n+            {\n+              /* The high byte (r29) does not change:\n+                 Prefer SUBI (1 cycle) over ABIW (2 cycles, same size).  */\n+\n+              my_fp = simplify_gen_subreg (QImode, fp, Pmode, 0);\n+            }\n+\n+          /************  Method 1: Adjust frame pointer  ************/\n+          \n+          start_sequence ();\n+\n+          /* Normally, the dwarf2out frame-related-expr interpreter does\n+             not expect to have the CFA change once the frame pointer is\n+             set up.  Thus, we avoid marking the move insn below and\n+             instead indicate that the entire operation is complete after\n+             the frame pointer subtraction is done.  */\n+          \n+          insn = emit_move_insn (fp, stack_pointer_rtx);\n+          if (!frame_pointer_needed)\n+            RTX_FRAME_RELATED_P (insn) = 1;\n+\n+          insn = emit_move_insn (my_fp, plus_constant (my_fp, -size));\n+          RTX_FRAME_RELATED_P (insn) = 1;\n+          \n+          if (frame_pointer_needed)\n+            {\n+              add_reg_note (insn, REG_CFA_ADJUST_CFA,\n+                            gen_rtx_SET (VOIDmode, fp, sp_minus_size));\n+            }\n+          \n+          /* Copy to stack pointer.  Note that since we've already\n+             changed the CFA to the frame pointer this operation\n+             need not be annotated if frame pointer is needed.  */\n+              \n+          if (AVR_HAVE_8BIT_SP)\n+            {\n+              insn = emit_move_insn (stack_pointer_rtx, fp);\n+            }\n+          else if (TARGET_NO_INTERRUPTS \n+                   || isr_p\n+                   || cfun->machine->is_OS_main)\n+            {\n+              rtx irqs_are_on = GEN_INT (!!cfun->machine->is_interrupt);\n+              \n+              insn = emit_insn (gen_movhi_sp_r (stack_pointer_rtx,\n+                                                fp, irqs_are_on));\n+            }\n+          else\n+            {\n+              insn = emit_move_insn (stack_pointer_rtx, fp);\n+            }\n+\n+          if (!frame_pointer_needed)\n+            RTX_FRAME_RELATED_P (insn) = 1;\n+\n+          fp_plus_insns = get_insns ();\n+          end_sequence ();\n+          \n+          /************  Method 2: Adjust Stack pointer  ************/\n+\n+          /* Stack adjustment by means of RCALL . and/or PUSH __TMP_REG__\n+             can only handle specific offsets.  */\n+          \n+          if (avr_sp_immediate_operand (gen_int_mode (-size, HImode), HImode))\n+            {\n+              rtx sp_plus_insns;\n+              \n+              start_sequence ();\n+\n+              insn = emit_move_insn (stack_pointer_rtx, sp_minus_size);\n+              RTX_FRAME_RELATED_P (insn) = 1;\n+\n+              if (frame_pointer_needed)\n+                {\n+                  insn = emit_move_insn (fp, stack_pointer_rtx);\n+                  RTX_FRAME_RELATED_P (insn) = 1;\n+                }\n+\n+              sp_plus_insns = get_insns ();\n+              end_sequence ();\n+\n+              /************ Use shortest method  ************/\n+                  \n+              emit_insn (get_sequence_length (sp_plus_insns)\n+                         < get_sequence_length (fp_plus_insns)\n+                         ? sp_plus_insns\n+                         : fp_plus_insns);\n+            }\n+          else\n+            {\n+              emit_insn (fp_plus_insns);\n+            }\n+\n+          cfun->machine->stack_usage += size;\n+        } /* !minimize && size != 0 */\n+    } /* !minimize */\n+}\n+\n \n /*  Output function prologue.  */\n \n void\n expand_prologue (void)\n {\n-  int live_seq;\n   HARD_REG_SET set;\n-  int minimize;\n-  HOST_WIDE_INT size = get_frame_size();\n-  rtx insn;\n+  HOST_WIDE_INT size;\n+\n+  size = get_frame_size() + avr_outgoing_args_size();\n   \n   /* Init cfun->machine.  */\n   cfun->machine->is_naked = avr_naked_function_p (current_function_decl);\n@@ -683,20 +950,13 @@ expand_prologue (void)\n     }\n \n   avr_regs_to_save (&set);\n-  live_seq = sequent_regs_live ();\n-  minimize = (TARGET_CALL_PROLOGUES\n-\t      && !cfun->machine->is_interrupt\n-\t      && !cfun->machine->is_signal\n-\t      && !cfun->machine->is_OS_task\n-\t      && !cfun->machine->is_OS_main\n-\t      && live_seq);\n \n   if (cfun->machine->is_interrupt || cfun->machine->is_signal)\n     {\n       /* Enable interrupts.  */\n       if (cfun->machine->is_interrupt)\n-\temit_insn (gen_enable_interrupt ());\n-\t\n+        emit_insn (gen_enable_interrupt ());\n+        \n       /* Push zero reg.  */\n       emit_push_byte (ZERO_REGNO, true);\n \n@@ -715,189 +975,19 @@ expand_prologue (void)\n           && TEST_HARD_REG_BIT (set, REG_Z + 1))\n         {\n           emit_move_insn (tmp_reg_rtx,\n-\t\t\t  gen_rtx_MEM (QImode, GEN_INT (RAMPZ_ADDR)));\n-\t  emit_push_byte (TMP_REGNO, false);\n+                          gen_rtx_MEM (QImode, GEN_INT (RAMPZ_ADDR)));\n+          emit_push_byte (TMP_REGNO, false);\n         }\n-\t\n+        \n       /* Clear zero reg.  */\n       emit_move_insn (zero_reg_rtx, const0_rtx);\n \n       /* Prevent any attempt to delete the setting of ZERO_REG!  */\n       emit_use (zero_reg_rtx);\n     }\n-  if (minimize && (frame_pointer_needed \n-\t\t   || (AVR_2_BYTE_PC && live_seq > 6)\n-\t\t   || live_seq > 7)) \n-    {\n-      int first_reg, reg, offset;\n-\n-      emit_move_insn (gen_rtx_REG (HImode, REG_X), \n-                      gen_int_mode (size, HImode));\n-\n-      insn = emit_insn (gen_call_prologue_saves\n-\t\t\t(gen_int_mode (live_seq, HImode),\n-\t\t         gen_int_mode (size + live_seq, HImode)));\n-      RTX_FRAME_RELATED_P (insn) = 1;\n-\n-      /* Describe the effect of the unspec_volatile call to prologue_saves.\n-\t Note that this formulation assumes that add_reg_note pushes the\n-\t notes to the front.  Thus we build them in the reverse order of\n-\t how we want dwarf2out to process them.  */\n-\n-      /* The function does always set frame_pointer_rtx, but whether that\n-\t is going to be permanent in the function is frame_pointer_needed.  */\n-      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n-\t\t    gen_rtx_SET (VOIDmode,\n-\t\t\t\t (frame_pointer_needed\n-\t\t\t\t  ? frame_pointer_rtx : stack_pointer_rtx),\n-\t\t\t\t plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t-(size + live_seq))));\n-\n-      /* Note that live_seq always contains r28+r29, but the other\n-\t registers to be saved are all below 18.  */\n-      first_reg = 18 - (live_seq - 2);\n-\n-      for (reg = 29, offset = -live_seq + 1;\n-\t   reg >= first_reg;\n-\t   reg = (reg == 28 ? 17 : reg - 1), ++offset)\n-\t{\n-\t  rtx m, r;\n-\n-\t  m = gen_rtx_MEM (QImode, plus_constant (stack_pointer_rtx, offset));\n-\t  r = gen_rtx_REG (QImode, reg);\n-\t  add_reg_note (insn, REG_CFA_OFFSET, gen_rtx_SET (VOIDmode, m, r));\n-\t}\n-\n-      cfun->machine->stack_usage += size + live_seq;\n-    }\n-  else\n-    {\n-      int reg;\n-      for (reg = 0; reg < 32; ++reg)\n-        if (TEST_HARD_REG_BIT (set, reg))\n-\t  emit_push_byte (reg, true);\n-\n-      if (frame_pointer_needed)\n-        {\n-\t  if (!(cfun->machine->is_OS_task || cfun->machine->is_OS_main))\n-\t    {\n-              /* Push frame pointer.  Always be consistent about the\n-\t\t ordering of pushes -- epilogue_restores expects the\n-\t\t register pair to be pushed low byte first.  */\n-\t      emit_push_byte (REG_Y, true);\n-\t      emit_push_byte (REG_Y + 1, true);\n-\t    }\n-\n-          if (!size)\n-            {\n-              insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n-              RTX_FRAME_RELATED_P (insn) = 1;\n-            }\n-          else\n-            {\n-              /*  Creating a frame can be done by direct manipulation of the\n-                  stack or via the frame pointer. These two methods are:\n-                    fp=sp\n-                    fp-=size\n-                    sp=fp\n-                  OR\n-                    sp-=size\n-                    fp=sp\n-              the optimum method depends on function type, stack and frame size.\n-              To avoid a complex logic, both methods are tested and shortest\n-              is selected.  */\n-              rtx myfp;\n-\t      rtx fp_plus_insns; \n-\n-              if (AVR_HAVE_8BIT_SP)\n-                {\n-                  /* The high byte (r29) doesn't change.  Prefer 'subi'\n-\t\t     (1 cycle) over 'sbiw' (2 cycles, same size).  */\n-                  myfp = gen_rtx_REG (QImode, FRAME_POINTER_REGNUM);\n-                }\n-              else \n-                {\n-                  /*  Normal sized addition.  */\n-                  myfp = frame_pointer_rtx;\n-                }\n-\n-\t      /* Method 1-Adjust frame pointer.  */\n-\t      start_sequence ();\n-\n-\t      /* Normally the dwarf2out frame-related-expr interpreter does\n-\t\t not expect to have the CFA change once the frame pointer is\n-\t\t set up.  Thus we avoid marking the move insn below and\n-\t\t instead indicate that the entire operation is complete after\n-\t\t the frame pointer subtraction is done.  */\n-\n-              emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n-\n-              insn = emit_move_insn (myfp, plus_constant (myfp, -size));\n-              RTX_FRAME_RELATED_P (insn) = 1;\n-\t      add_reg_note (insn, REG_CFA_ADJUST_CFA,\n-\t\t\t    gen_rtx_SET (VOIDmode, frame_pointer_rtx,\n-\t\t\t\t\t plus_constant (stack_pointer_rtx,\n-\t\t\t\t\t\t\t-size)));\n-\n-\t      /* Copy to stack pointer.  Note that since we've already\n-\t\t changed the CFA to the frame pointer this operation\n-\t\t need not be annotated at all.  */\n-\t      if (AVR_HAVE_8BIT_SP)\n-\t\t{\n-\t\t  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-\t\t}\n-\t      else if (TARGET_NO_INTERRUPTS \n-\t\t       || cfun->machine->is_signal\n-\t\t       || cfun->machine->is_OS_main)\n-\t\t{\n-\t\t  emit_insn (gen_movhi_sp_r_irq_off (stack_pointer_rtx, \n-\t\t\t\t\t\t     frame_pointer_rtx));\n-\t\t}\n-\t      else if (cfun->machine->is_interrupt)\n-\t\t{\n-\t\t  emit_insn (gen_movhi_sp_r_irq_on (stack_pointer_rtx, \n-\t\t\t\t\t\t    frame_pointer_rtx));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-\t\t}\n-\n-\t      fp_plus_insns = get_insns ();\n-\t      end_sequence ();\n-\n-\t      /* Method 2-Adjust Stack pointer.  */\n-              if (size <= 6)\n-                {\n-\t\t  rtx sp_plus_insns;\n-\n-\t\t  start_sequence ();\n-\n-\t          insn = plus_constant (stack_pointer_rtx, -size);\n-\t\t  insn = emit_move_insn (stack_pointer_rtx, insn);\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\t\t  \n-\t\t  insn = emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n-\t\t  RTX_FRAME_RELATED_P (insn) = 1;\n-\n-\t\t  sp_plus_insns = get_insns ();\n-\t\t  end_sequence ();\n-\n-\t\t  /* Use shortest method.  */\n-\t\t  if (get_sequence_length (sp_plus_insns) \n-\t\t      < get_sequence_length (fp_plus_insns))\n-\t\t    emit_insn (sp_plus_insns);\n-\t\t  else\n-\t\t    emit_insn (fp_plus_insns);\n-                }\n-\t      else\n-\t\temit_insn (fp_plus_insns);\n-\n-\t      cfun->machine->stack_usage += size;\n-            }\n-        }\n-    }\n \n+  avr_prologue_setup_frame (size, set);\n+  \n   if (flag_stack_usage_info)\n     current_function_static_stack_size = cfun->machine->stack_usage;\n }\n@@ -924,6 +1014,11 @@ avr_asm_function_end_prologue (FILE *file)\n       else\n         fputs (\"/* prologue: function */\\n\", file);\n     }\n+\n+  if (ACCUMULATE_OUTGOING_ARGS)\n+    fprintf (file, \"/* outgoing args size = %d */\\n\",\n+             avr_outgoing_args_size());\n+\n   fprintf (file, \"/* frame size = \" HOST_WIDE_INT_PRINT_DEC \" */\\n\",\n                  get_frame_size());\n   fprintf (file, \"/* stack size = %d */\\n\",\n@@ -969,7 +1064,10 @@ expand_epilogue (bool sibcall_p)\n   int live_seq;\n   HARD_REG_SET set;      \n   int minimize;\n-  HOST_WIDE_INT size = get_frame_size();\n+  HOST_WIDE_INT size;\n+  bool isr_p = cfun->machine->is_interrupt || cfun->machine->is_signal;\n+\n+  size = get_frame_size() + avr_outgoing_args_size();\n   \n   /* epilogue: naked  */\n   if (cfun->machine->is_naked)\n@@ -982,146 +1080,158 @@ expand_epilogue (bool sibcall_p)\n \n   avr_regs_to_save (&set);\n   live_seq = sequent_regs_live ();\n+  \n   minimize = (TARGET_CALL_PROLOGUES\n-\t      && !cfun->machine->is_interrupt\n-\t      && !cfun->machine->is_signal\n-\t      && !cfun->machine->is_OS_task\n-\t      && !cfun->machine->is_OS_main\n-\t      && live_seq);\n+              && live_seq\n+              && !isr_p\n+              && !cfun->machine->is_OS_task\n+              && !cfun->machine->is_OS_main);\n   \n-  if (minimize && (frame_pointer_needed || live_seq > 4))\n+  if (minimize\n+      && (live_seq > 4\n+          || frame_pointer_needed\n+          || size))\n     {\n-      if (frame_pointer_needed)\n-\t{\n-          /*  Get rid of frame.  */\n-          if (size)\n-            emit_move_insn (frame_pointer_rtx,\n-                            gen_rtx_PLUS (HImode, frame_pointer_rtx,\n-                                          gen_int_mode (size, HImode)));\n-\t}\n-      else\n-\t{\n+      /*  Get rid of frame.  */\n+      \n+      if (!frame_pointer_needed)\n+        {\n           emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n-\t}\n-\t\n+        }\n+\n+      if (size)\n+        {\n+          emit_move_insn (frame_pointer_rtx,\n+                          plus_constant (frame_pointer_rtx, size));\n+        }\n+        \n       emit_insn (gen_epilogue_restores (gen_int_mode (live_seq, HImode)));\n+      return;\n     }\n-  else\n+      \n+  if (size)\n     {\n-      if (frame_pointer_needed)\n-\t{\n-\t  if (size)\n-\t    {\n-              /* Try two methods to adjust stack and select shortest.  */\n-\t      rtx myfp;\n-\t      rtx fp_plus_insns;\n+      /* Try two methods to adjust stack and select shortest.  */\n+          \n+      rtx fp, my_fp;\n+      rtx fp_plus_insns;\n \n-\t      if (AVR_HAVE_8BIT_SP)\n-                {\n-                  /* The high byte (r29) doesn't change - prefer 'subi' \n-                     (1 cycle) over 'sbiw' (2 cycles, same size).  */\n-                  myfp = gen_rtx_REG (QImode, FRAME_POINTER_REGNUM);\n-                }\n-              else \n-                {\n-                  /* Normal sized addition.  */\n-                  myfp = frame_pointer_rtx;\n-                }\n-\t      \n-              /* Method 1-Adjust frame pointer.  */\n-\t      start_sequence ();\n+      gcc_assert (frame_pointer_needed\n+                  || !isr_p\n+                  || !current_function_is_leaf);\n+      \n+      fp = my_fp = (frame_pointer_needed\n+                    ? frame_pointer_rtx\n+                    : gen_rtx_REG (Pmode, REG_X));\n \n-\t      emit_move_insn (myfp, plus_constant (myfp, size));\n+      if (AVR_HAVE_8BIT_SP)\n+        {\n+          /* The high byte (r29) does not change:\n+             Prefer SUBI (1 cycle) over SBIW (2 cycles).  */\n+                  \n+          my_fp = simplify_gen_subreg (QImode, fp, Pmode, 0);\n+        }\n+              \n+      /********** Method 1: Adjust fp register  **********/\n+              \n+      start_sequence ();\n \n-\t      /* Copy to stack pointer.  */\n-\t      if (AVR_HAVE_8BIT_SP)\n-\t\t{\n-\t\t  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-\t\t}\n-\t      else if (TARGET_NO_INTERRUPTS \n-\t\t       || cfun->machine->is_signal)\n-\t\t{\n-\t\t  emit_insn (gen_movhi_sp_r_irq_off (stack_pointer_rtx, \n-\t\t\t\t\t\t     frame_pointer_rtx));\n-\t\t}\n-\t      else if (cfun->machine->is_interrupt)\n-\t\t{\n-\t\t  emit_insn (gen_movhi_sp_r_irq_on (stack_pointer_rtx, \n-\t\t\t\t\t\t    frame_pointer_rtx));\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  emit_move_insn (stack_pointer_rtx, frame_pointer_rtx);\n-\t\t}\n+      if (!frame_pointer_needed)\n+        emit_move_insn (fp, stack_pointer_rtx);\n \n-\t      fp_plus_insns = get_insns ();\n-\t      end_sequence ();\t      \n+      emit_move_insn (my_fp, plus_constant (my_fp, size));\n \n-              /* Method 2-Adjust Stack pointer.  */\n-              if (size <= 5)\n-                {\n-\t\t  rtx sp_plus_insns;\n+      /* Copy to stack pointer.  */\n+              \n+      if (AVR_HAVE_8BIT_SP)\n+        {\n+          emit_move_insn (stack_pointer_rtx, fp);\n+        }\n+      else if (TARGET_NO_INTERRUPTS \n+               || isr_p\n+               || cfun->machine->is_OS_main)\n+        {\n+          rtx irqs_are_on = GEN_INT (!!cfun->machine->is_interrupt);\n+          \n+          emit_insn (gen_movhi_sp_r (stack_pointer_rtx, fp, irqs_are_on));\n+        }\n+      else\n+        {\n+          emit_move_insn (stack_pointer_rtx, fp);\n+        }\n \n-\t\t  start_sequence ();\n+      fp_plus_insns = get_insns ();\n+      end_sequence ();        \n \n-\t\t  emit_move_insn (stack_pointer_rtx,\n-\t\t\t\t  plus_constant (stack_pointer_rtx, size));\n+      /********** Method 2: Adjust Stack pointer  **********/\n+      \n+      if (avr_sp_immediate_operand (gen_int_mode (size, HImode), HImode))\n+        {\n+          rtx sp_plus_insns;\n \n-\t\t  sp_plus_insns = get_insns ();\n-\t\t  end_sequence ();\n+          start_sequence ();\n \n-\t\t  /* Use shortest method.  */\n-\t\t  if (get_sequence_length (sp_plus_insns) \n-\t\t      < get_sequence_length (fp_plus_insns))\n-\t\t    emit_insn (sp_plus_insns);\n-\t\t  else\n-\t\t    emit_insn (fp_plus_insns);\n-                }\n-\t      else\n-\t\temit_insn (fp_plus_insns);\n-            }\n-\t  if (!(cfun->machine->is_OS_task || cfun->machine->is_OS_main))\n-\t    {\n-              /* Restore previous frame_pointer.  See expand_prologue for\n-\t\t rationale for not using pophi.  */\n-\t      emit_pop_byte (REG_Y + 1);\n-\t      emit_pop_byte (REG_Y);\n-\t    }\n-\t}\n+          emit_move_insn (stack_pointer_rtx,\n+                          plus_constant (stack_pointer_rtx, size));\n \n-      /* Restore used registers.  */\n-      for (reg = 31; reg >= 0; --reg)\n-        if (TEST_HARD_REG_BIT (set, reg))\n-          emit_pop_byte (reg);\n+          sp_plus_insns = get_insns ();\n+          end_sequence ();\n \n-      if (cfun->machine->is_interrupt || cfun->machine->is_signal)\n-        {\n-          /* Restore RAMPZ using tmp reg as scratch.  */\n-\t  if (AVR_HAVE_RAMPZ \n-              && TEST_HARD_REG_BIT (set, REG_Z)\n-\t      && TEST_HARD_REG_BIT (set, REG_Z + 1))\n-            {\n-\t      emit_pop_byte (TMP_REGNO);\n-\t      emit_move_insn (gen_rtx_MEM (QImode, GEN_INT (RAMPZ_ADDR)), \n-\t\t\t      tmp_reg_rtx);\n-\t    }\n+          /************ Use shortest method  ************/\n+          \n+          emit_insn (get_sequence_length (sp_plus_insns)\n+                     < get_sequence_length (fp_plus_insns)\n+                     ? sp_plus_insns\n+                     : fp_plus_insns);\n+        }\n+      else\n+        emit_insn (fp_plus_insns);\n+    } /* size != 0 */\n+          \n+  if (frame_pointer_needed\n+      && !(cfun->machine->is_OS_task || cfun->machine->is_OS_main))\n+    {\n+      /* Restore previous frame_pointer.  See expand_prologue for\n+         rationale for not using pophi.  */\n+              \n+      emit_pop_byte (REG_Y + 1);\n+      emit_pop_byte (REG_Y);\n+    }\n \n-          /* Restore SREG using tmp reg as scratch.  */\n-          emit_pop_byte (TMP_REGNO);\n-      \n-          emit_move_insn (gen_rtx_MEM (QImode, GEN_INT (SREG_ADDR)), \n-\t\t\t  tmp_reg_rtx);\n+  /* Restore used registers.  */\n+  \n+  for (reg = 31; reg >= 0; --reg)\n+    if (TEST_HARD_REG_BIT (set, reg))\n+      emit_pop_byte (reg);\n \n-          /* Restore tmp REG.  */\n+  if (isr_p)\n+    {\n+      /* Restore RAMPZ using tmp reg as scratch.  */\n+      \n+      if (AVR_HAVE_RAMPZ \n+          && TEST_HARD_REG_BIT (set, REG_Z)\n+          && TEST_HARD_REG_BIT (set, REG_Z + 1))\n+        {\n           emit_pop_byte (TMP_REGNO);\n-\n-          /* Restore zero REG.  */\n-          emit_pop_byte (ZERO_REGNO);\n+          emit_move_insn (gen_rtx_MEM (QImode, GEN_INT (RAMPZ_ADDR)), \n+                          tmp_reg_rtx);\n         }\n \n-      if (!sibcall_p)\n-        emit_jump_insn (gen_return ());\n+      /* Restore SREG using tmp reg as scratch.  */\n+      \n+      emit_pop_byte (TMP_REGNO);\n+      emit_move_insn (gen_rtx_MEM (QImode, GEN_INT (SREG_ADDR)), \n+                      tmp_reg_rtx);\n+\n+      /* Restore tmp REG.  */\n+      emit_pop_byte (TMP_REGNO);\n+\n+      /* Restore zero REG.  */\n+      emit_pop_byte (ZERO_REGNO);\n     }\n+\n+  if (!sibcall_p)\n+    emit_jump_insn (gen_return ());\n }\n \n /* Output summary messages at beginning of function epilogue.  */\n@@ -3069,8 +3179,10 @@ static bool\n avr_frame_pointer_required_p (void)\n {\n   return (cfun->calls_alloca\n-\t  || crtl->args.info.nregs == 0\n-  \t  || get_frame_size () > 0);\n+          || cfun->calls_setjmp\n+          || cfun->has_nonlocal_label\n+          || crtl->args.info.nregs == 0\n+          || get_frame_size () > 0);\n }\n \n /* Returns the condition of compare insn INSN, or UNKNOWN.  */"}, {"sha": "50f64884c07d5902c4df4a175141a832f6a5e678", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "patch": "@@ -324,7 +324,7 @@ enum reg_class {\n \n #define STACK_GROWS_DOWNWARD\n \n-#define STARTING_FRAME_OFFSET 1\n+#define STARTING_FRAME_OFFSET avr_starting_frame_offset()\n \n #define STACK_POINTER_OFFSET 1\n \n@@ -635,3 +635,5 @@ struct GTY(()) machine_function\n /* AVR does not round pushes, but the existance of this macro is\n    required in order for pushes to be generated.  */\n #define PUSH_ROUNDING(X)\t(X)\n+\n+#define ACCUMULATE_OUTGOING_ARGS avr_accumulate_outgoing_args()"}, {"sha": "faf18797bc18b1f24a3a2925cacde0ec12a80b26", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "patch": "@@ -62,8 +62,7 @@\n (define_c_enum \"unspecv\"\n   [UNSPECV_PROLOGUE_SAVES\n    UNSPECV_EPILOGUE_RESTORES\n-   UNSPECV_WRITE_SP_IRQ_ON\n-   UNSPECV_WRITE_SP_IRQ_OFF\n+   UNSPECV_WRITE_SP\n    UNSPECV_GOTO_RECEIVER\n    UNSPECV_ENABLE_IRQS\n    UNSPECV_NOP\n@@ -380,26 +379,24 @@\n     }\n }\")\n \n-(define_insn \"movhi_sp_r_irq_off\"\n-  [(set (match_operand:HI 0 \"stack_register_operand\" \"=q\")\n-        (unspec_volatile:HI [(match_operand:HI 1 \"register_operand\"  \"r\")] \n-\t\t\t    UNSPECV_WRITE_SP_IRQ_OFF))]\n-  \"\"\n-  \"out __SP_H__, %B1\n-\tout __SP_L__, %A1\"\n-  [(set_attr \"length\" \"2\")\n-   (set_attr \"cc\" \"none\")])\n \n-(define_insn \"movhi_sp_r_irq_on\"\n-  [(set (match_operand:HI 0 \"stack_register_operand\" \"=q\")\n-        (unspec_volatile:HI [(match_operand:HI 1 \"register_operand\"  \"r\")] \n-\t\t\t    UNSPECV_WRITE_SP_IRQ_ON))]\n+;; Move register $1 to the Stack Pointer register SP.\n+;; This insn is emit during function prologue/epilogue generation.\n+;;    $2 = 0: We know that IRQs are off\n+;;    $2 = 1: We know that IRQs are on\n+;; Remaining cases when the state of the I-Flag is unknown are\n+;; handled by generic movhi insn.\n+\n+(define_insn \"movhi_sp_r\"\n+  [(set (match_operand:HI 0 \"stack_register_operand\"                \"=q,q\")\n+        (unspec_volatile:HI [(match_operand:HI 1 \"register_operand\"  \"r,r\")\n+                             (match_operand:HI 2 \"const_int_operand\" \"L,P\")]\n+                            UNSPECV_WRITE_SP))]\n   \"\"\n-  \"cli\n-        out __SP_H__, %B1\n-\tsei\n-\tout __SP_L__, %A1\"\n-  [(set_attr \"length\" \"4\")\n+  \"@\n+\tout __SP_H__,%B1\\;out __SP_L__,%A1\n+\tcli\\;out __SP_H__,%B1\\;sei\\;out __SP_L__,%A1\"\n+  [(set_attr \"length\" \"2,4\")\n    (set_attr \"cc\" \"none\")])\n \n (define_peephole2\n@@ -800,15 +797,15 @@\n   [(set_attr \"length\" \"2\")\n    (set_attr \"cc\" \"set_n\")])\n \n-(define_insn \"*addhi3_sp_R\"\n-  [(set (match_operand:HI 1 \"stack_register_operand\" \"=q\")\n-        (plus:HI (match_operand:HI 2 \"stack_register_operand\" \"q\")\n-                 (match_operand:HI 0 \"avr_sp_immediate_operand\" \"R\")))]\n+(define_insn \"*addhi3_sp\"\n+  [(set (match_operand:HI 1 \"stack_register_operand\"           \"=q\")\n+        (plus:HI (match_operand:HI 2 \"stack_register_operand\"   \"q\")\n+                 (match_operand:HI 0 \"avr_sp_immediate_operand\" \"Csp\")))]\n   \"\"\n   {\n     return avr_out_addto_sp (operands, NULL);\n   }\n-  [(set_attr \"length\" \"5\")\n+  [(set_attr \"length\" \"6\")\n    (set_attr \"adjust_len\" \"addto_sp\")])\n \n (define_insn \"*addhi3\""}, {"sha": "8de929d12918f9819dc30329453ac81557d9c1c3", "filename": "gcc/config/avr/avr.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Favr.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Favr.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.opt?ref=d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "patch": "@@ -62,6 +62,10 @@ mpmem-wrap-around\n Target Report\n Make the linker relaxation machine assume that a program counter wrap-around occurs.\n \n+maccumulate-args\n+Target Report Mask(ACCUMULATE_OUTGOING_ARGS)\n+Accumulate outgoing function arguments and acquire/release the needed stack space for outpoing function arguments in function prologue/epilogue.  Without this option, outgoing arguments are pushed before calling a function and popped afterwards.  This option can lead to reduced code size for functions that call many functions that get their arguments on the stack like, for example printf.\n+\n mstrict-X\n Target Report Var(avr_strict_X) Init(0)\n When accessing RAM, use X as imposed by the hardware, i.e. just use pre-decrement, post-increment and indirect addressing with the X register.  Without this option, the compiler may assume that there is an addressing mode X+const similar to Y+const and Z+const and emit instructions to emulate such an addressing mode for X."}, {"sha": "d26bff3ca19d20ce80eb56624584d9f83b27014c", "filename": "gcc/config/avr/constraints.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fconstraints.md?ref=d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "patch": "@@ -98,11 +98,6 @@\n   (and (match_code \"const_double\")\n        (match_test \"op == CONST0_RTX (SFmode)\")))\n \n-(define_constraint \"R\"\n-  \"Integer constant in the range -6 @dots{} 5.\"\n-  (and (match_code \"const_int\")\n-       (match_test \"ival >= -6 && ival <= 5\")))\n-       \n (define_memory_constraint \"Q\"\n   \"A memory address based on Y or Z pointer with displacement.\"\n   (and (match_code \"mem\")\n@@ -162,3 +157,8 @@\n   \"Constant 4-byte integer that allows XOR without clobber register.\"\n   (and (match_code \"const_int\")\n        (match_test \"avr_popcount_each_byte (op, 4, (1<<0) | (1<<8))\")))\n+\n+(define_constraint \"Csp\"\n+  \"Integer constant in the range -6 @dots{} 6.\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (ival, -6, 6)\")))"}, {"sha": "55a25b8b05a879b55efc7365e90feca74ff9071b", "filename": "gcc/config/avr/predicates.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d702f362b50d9f6fe4a92b2404c6b9ec51f2708c/gcc%2Fconfig%2Favr%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Fpredicates.md?ref=d702f362b50d9f6fe4a92b2404c6b9ec51f2708c", "patch": "@@ -135,7 +135,7 @@\n ;;\n (define_predicate \"avr_sp_immediate_operand\"\n   (and (match_code \"const_int\")\n-       (match_test \"INTVAL (op) >= -6 && INTVAL (op) <= 5\")))\n+       (match_test \"satisfies_constraint_Csp (op)\")))\n \n ;; True for EQ & NE\n (define_predicate \"eqne_operator\""}]}