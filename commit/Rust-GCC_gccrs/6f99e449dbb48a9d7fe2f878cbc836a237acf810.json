{"sha": "6f99e449dbb48a9d7fe2f878cbc836a237acf810", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY5OWU0NDlkYmI0OGE5ZDdmZTJmODc4Y2JjODM2YTIzN2FjZjgxMA==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2013-11-13T15:34:47Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2013-11-13T15:34:47Z"}, "message": "cgraph.c (cgraph_get_create_node): Do what cgraph_get_create_real_symbol_node used to do.\n\n2013-11-13  Martin Jambor  <mjambor@suse.cz>\n\n\t* cgraph.c (cgraph_get_create_node): Do what\n\tcgraph_get_create_real_symbol_node used to do.\n\t(cgraph_get_create_real_symbol_node): Removed.  Changed all users to\n\tcall cgraph_get_create_node.\n\t* cgraph.h (cgraph_get_create_real_symbol_node): Removed.\n\t* lto-streamer-in.c (input_function): Call cgraph_get_node instead of\n\tcgraph_get_create_node.  Assert we get a node.\n\nFrom-SVN: r204748", "tree": {"sha": "6edf9591cd759ae47f7a8a497c6ddf24374e6477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6edf9591cd759ae47f7a8a497c6ddf24374e6477"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f99e449dbb48a9d7fe2f878cbc836a237acf810", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f99e449dbb48a9d7fe2f878cbc836a237acf810", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f99e449dbb48a9d7fe2f878cbc836a237acf810", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f99e449dbb48a9d7fe2f878cbc836a237acf810/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0f365c102f3ae1b5025c0893074ed4a94d3ee295", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f365c102f3ae1b5025c0893074ed4a94d3ee295", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f365c102f3ae1b5025c0893074ed4a94d3ee295"}], "stats": {"total": 110, "additions": 45, "deletions": 65}, "files": [{"sha": "77f3ea285b0d7236c9410168ec48e1bb1455d96b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6f99e449dbb48a9d7fe2f878cbc836a237acf810", "patch": "@@ -1,3 +1,13 @@\n+2013-11-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* cgraph.c (cgraph_get_create_node): Do what\n+\tcgraph_get_create_real_symbol_node used to do.\n+\t(cgraph_get_create_real_symbol_node): Removed.  Changed all users to\n+\tcall cgraph_get_create_node.\n+\t* cgraph.h (cgraph_get_create_real_symbol_node): Removed.\n+\t* lto-streamer-in.c (input_function): Call cgraph_get_node instead of\n+\tcgraph_get_create_node.  Assert we get a node.\n+\n 2013-11-13  Tejas Belagod  <tejas.belagod@arm.com>\n \n \t* config/aarch64/aarch64-simd.md (vec_extract): New."}, {"sha": "b7ec16655f564764a8071864494b6b7c5edc3bec", "filename": "gcc/cgraph.c", "status": "modified", "additions": 22, "deletions": 52, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6f99e449dbb48a9d7fe2f878cbc836a237acf810", "patch": "@@ -540,19 +540,34 @@ cgraph_create_node (tree decl)\n   return node;\n }\n \n-/* Try to find a call graph node for declaration DECL and if it does not exist,\n-   create it.  */\n+/* Try to find a call graph node for declaration DECL and if it does not exist\n+   or if it corresponds to an inline clone, create a new one.  */\n \n struct cgraph_node *\n cgraph_get_create_node (tree decl)\n {\n-  struct cgraph_node *node;\n+  struct cgraph_node *first_clone = cgraph_get_node (decl);\n \n-  node = cgraph_get_node (decl);\n-  if (node)\n-    return node;\n+  if (first_clone && !first_clone->global.inlined_to)\n+    return first_clone;\n \n-  return cgraph_create_node (decl);\n+  struct cgraph_node *node = cgraph_create_node (decl);\n+  if (first_clone)\n+    {\n+      first_clone->clone_of = node;\n+      node->clones = first_clone;\n+      symtab_prevail_in_asm_name_hash (node);\n+      symtab_insert_node_to_hashtable (node);\n+      if (dump_file)\n+\tfprintf (dump_file, \"Introduced new external node \"\n+\t\t \"(%s/%i) and turned into root of the clone tree.\\n\",\n+\t\t xstrdup (cgraph_node_name (node)), node->order);\n+    }\n+  else if (dump_file)\n+    fprintf (dump_file, \"Introduced new external node \"\n+\t     \"(%s/%i).\\n\", xstrdup (cgraph_node_name (node)),\n+\t     node->order);\n+  return node;\n }\n \n /* Mark ALIAS as an alias to DECL.  DECL_NODE is cgraph node representing\n@@ -2890,51 +2905,6 @@ verify_cgraph (void)\n     verify_cgraph_node (node);\n }\n \n-/* Create external decl node for DECL.\n-   The difference i nbetween cgraph_get_create_node and\n-   cgraph_get_create_real_symbol_node is that cgraph_get_create_node\n-   may return inline clone, while cgraph_get_create_real_symbol_node\n-   will create a new node in this case.\n-   FIXME: This function should be removed once clones are put out of decl\n-   hash.  */\n-\n-struct cgraph_node *\n-cgraph_get_create_real_symbol_node (tree decl)\n-{\n-  struct cgraph_node *first_clone = cgraph_get_node (decl);\n-  struct cgraph_node *node;\n-  /* create symbol table node.  even if inline clone exists, we can not take\n-     it as a target of non-inlined call.  */\n-  node = cgraph_get_node (decl);\n-  if (node && !node->global.inlined_to)\n-    return node;\n-\n-  node = cgraph_create_node (decl);\n-\n-  /* ok, we previously inlined the function, then removed the offline copy and\n-     now we want it back for external call.  this can happen when devirtualizing\n-     while inlining function called once that happens after extern inlined and\n-     virtuals are already removed.  in this case introduce the external node\n-     and make it available for call.  */\n-  if (first_clone)\n-    {\n-      first_clone->clone_of = node;\n-      node->clones = first_clone;\n-      symtab_prevail_in_asm_name_hash (node);\n-      symtab_insert_node_to_hashtable (node);\n-      if (dump_file)\n-\tfprintf (dump_file, \"Introduced new external node \"\n-\t\t \"(%s/%i) and turned into root of the clone tree.\\n\",\n-\t\t xstrdup (cgraph_node_name (node)), node->order);\n-    }\n-  else if (dump_file)\n-    fprintf (dump_file, \"Introduced new external node \"\n-\t     \"(%s/%i).\\n\", xstrdup (cgraph_node_name (node)),\n-\t     node->order);\n-  return node;\n-}\n-\n-\n /* Given NODE, walk the alias chain to return the function NODE is alias of.\n    Walk through thunk, too.\n    When AVAILABILITY is non-NULL, get minimal availability in the chain.  */"}, {"sha": "1ac6dfb9e0de827412ca81d1b2848ddc775d92b5", "filename": "gcc/cgraph.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6f99e449dbb48a9d7fe2f878cbc836a237acf810", "patch": "@@ -635,7 +635,6 @@ struct cgraph_indirect_call_info *cgraph_allocate_init_indirect_info (void);\n struct cgraph_node * cgraph_create_node (tree);\n struct cgraph_node * cgraph_create_empty_node (void);\n struct cgraph_node * cgraph_get_create_node (tree);\n-struct cgraph_node * cgraph_get_create_real_symbol_node (tree);\n struct cgraph_node * cgraph_same_body_alias (struct cgraph_node *, tree, tree);\n struct cgraph_node * cgraph_add_thunk (struct cgraph_node *, tree, tree, bool, HOST_WIDE_INT,\n \t\t\t\t       HOST_WIDE_INT, tree, tree);"}, {"sha": "21ad0ab2ab68e5f44d1764d50f0a5964f0cab616", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=6f99e449dbb48a9d7fe2f878cbc836a237acf810", "patch": "@@ -71,7 +71,7 @@ record_reference (tree *tp, int *walk_subtrees, void *data)\n       decl = get_base_var (*tp);\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \t{\n-\t  struct cgraph_node *node = cgraph_get_create_real_symbol_node (decl);\n+\t  struct cgraph_node *node = cgraph_get_create_node (decl);\n \t  if (!ctx->only_vars)\n \t    cgraph_mark_address_taken_node (node);\n \t  ipa_record_reference (ctx->varpool_node,\n@@ -139,9 +139,9 @@ record_eh_tables (struct cgraph_node *node, struct function *fun)\n \n   if (DECL_FUNCTION_PERSONALITY (node->decl))\n     {\n-      struct cgraph_node *per_node;\n+      tree per_decl = DECL_FUNCTION_PERSONALITY (node->decl);\n+      struct cgraph_node *per_node = cgraph_get_create_node (per_decl);\n \n-      per_node = cgraph_get_create_real_symbol_node (DECL_FUNCTION_PERSONALITY (node->decl));\n       ipa_record_reference (node, per_node, IPA_REF_ADDR, NULL);\n       cgraph_mark_address_taken_node (per_node);\n     }\n@@ -221,7 +221,7 @@ mark_address (gimple stmt, tree addr, void *data)\n   addr = get_base_address (addr);\n   if (TREE_CODE (addr) == FUNCTION_DECL)\n     {\n-      struct cgraph_node *node = cgraph_get_create_real_symbol_node (addr);\n+      struct cgraph_node *node = cgraph_get_create_node (addr);\n       cgraph_mark_address_taken_node (node);\n       ipa_record_reference ((symtab_node *)data,\n \t\t\t    node,\n@@ -250,7 +250,7 @@ mark_load (gimple stmt, tree t, void *data)\n     {\n       /* ??? This can happen on platforms with descriptors when these are\n \t directly manipulated in the code.  Pretend that it's an address.  */\n-      struct cgraph_node *node = cgraph_get_create_real_symbol_node (t);\n+      struct cgraph_node *node = cgraph_get_create_node (t);\n       cgraph_mark_address_taken_node (node);\n       ipa_record_reference ((symtab_node *)data,\n \t\t\t    node,\n@@ -338,20 +338,20 @@ build_cgraph_edges (void)\n \t    {\n \t      tree fn = gimple_omp_parallel_child_fn (stmt);\n \t      ipa_record_reference (node,\n-\t\t\t\t    cgraph_get_create_real_symbol_node (fn),\n+\t\t\t\t    cgraph_get_create_node (fn),\n \t\t\t\t    IPA_REF_ADDR, stmt);\n \t    }\n \t  if (gimple_code (stmt) == GIMPLE_OMP_TASK)\n \t    {\n \t      tree fn = gimple_omp_task_child_fn (stmt);\n \t      if (fn)\n \t\tipa_record_reference (node,\n-\t\t\t\t      cgraph_get_create_real_symbol_node (fn),\n+\t\t\t\t      cgraph_get_create_node (fn),\n \t\t\t\t      IPA_REF_ADDR, stmt);\n \t      fn = gimple_omp_task_copy_fn (stmt);\n \t      if (fn)\n \t\tipa_record_reference (node,\n-\t\t\t\t      cgraph_get_create_real_symbol_node (fn),\n+\t\t\t\t      cgraph_get_create_node (fn),\n \t\t\t\t      IPA_REF_ADDR, stmt);\n \t    }\n \t}"}, {"sha": "1cf8965b7f2d5bc5c16f0ce4655a01da4c4a46ff", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=6f99e449dbb48a9d7fe2f878cbc836a237acf810", "patch": "@@ -196,7 +196,7 @@ canonicalize_constructor_val (tree cval, tree from_decl)\n \t  /* Make sure we create a cgraph node for functions we'll reference.\n \t     They can be non-existent if the reference comes from an entry\n \t     of an external vtable for example.  */\n-\t  cgraph_get_create_real_symbol_node (base);\n+\t  cgraph_get_create_node (base);\n \t}\n       /* Fixup types in global initializers.  */\n       if (TREE_TYPE (TREE_TYPE (cval)) != TREE_TYPE (TREE_OPERAND (cval, 0)))"}, {"sha": "d1d3d71c0afd0e727ade90b78648511ff57fc7e3", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=6f99e449dbb48a9d7fe2f878cbc836a237acf810", "patch": "@@ -2454,7 +2454,7 @@ ipa_make_edge_direct_to_target (struct cgraph_edge *ie, tree target)\n \t\t     ie->callee->order);\n \t  return NULL;\n \t}\n-      callee = cgraph_get_create_real_symbol_node (target);\n+      callee = cgraph_get_create_node (target);\n     }\n   ipa_check_create_node_params ();\n "}, {"sha": "a11b1c753043efdbb337c903c30d9428bd698a9e", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=6f99e449dbb48a9d7fe2f878cbc836a237acf810", "patch": "@@ -355,7 +355,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  if (DECL_ABSTRACT_ORIGIN (node->decl))\n \t    {\n \t      struct cgraph_node *origin_node\n-\t      = cgraph_get_create_real_symbol_node (DECL_ABSTRACT_ORIGIN (node->decl));\n+\t      = cgraph_get_create_node (DECL_ABSTRACT_ORIGIN (node->decl));\n \t      origin_node->used_as_abstract_origin = true;\n \t      enqueue_node (origin_node, &first, reachable);\n \t    }"}, {"sha": "ebff04f5cdc6c7dc7b7cfc63015895e2d7cd6a25", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f99e449dbb48a9d7fe2f878cbc836a237acf810/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=6f99e449dbb48a9d7fe2f878cbc836a237acf810", "patch": "@@ -915,7 +915,8 @@ input_function (tree fn_decl, struct data_in *data_in,\n \n   gimple_register_cfg_hooks ();\n \n-  node = cgraph_get_create_node (fn_decl);\n+  node = cgraph_get_node (fn_decl);\n+  gcc_checking_assert (node);\n   input_struct_function_base (fn, data_in, ib);\n   input_cfg (ib_cfg, fn, node->count_materialization_scale);\n "}]}