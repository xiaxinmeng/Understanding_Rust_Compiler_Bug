{"sha": "3e5bcef316b5e5562490257735d9c6be0529652c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U1YmNlZjMxNmI1ZTU1NjI0OTAyNTc3MzVkOWM2YmUwNTI5NjUyYw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2004-12-11T01:49:05Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-12-11T01:49:05Z"}, "message": "re PR target/18002 ('while' loop performace regression on avr target)\n\n\n\tPR target/18002\n\tPR middle-end/18424\n\t* dojump.c (do_jump): When attempting to reverse the effects of\n\tfold_single_bit_test, we need to STRIP_NOPS and narrowing type\n\tconversions, and handle BIT_XOR_EXPR that's used to invert the\n\tsense of the single bit test.\n\nFrom-SVN: r92024", "tree": {"sha": "3035ae03ea21d5c817d6d99c7d2021a89ac56159", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3035ae03ea21d5c817d6d99c7d2021a89ac56159"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e5bcef316b5e5562490257735d9c6be0529652c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e5bcef316b5e5562490257735d9c6be0529652c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e5bcef316b5e5562490257735d9c6be0529652c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e5bcef316b5e5562490257735d9c6be0529652c/comments", "author": null, "committer": null, "parents": [{"sha": "aa6cc10dedbb80be5fd5b152716a97639b6fbab7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa6cc10dedbb80be5fd5b152716a97639b6fbab7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa6cc10dedbb80be5fd5b152716a97639b6fbab7"}], "stats": {"total": 69, "additions": 53, "deletions": 16}, "files": [{"sha": "4656a74f36f80451f363e9f1864191a87eaae9d2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e5bcef316b5e5562490257735d9c6be0529652c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e5bcef316b5e5562490257735d9c6be0529652c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3e5bcef316b5e5562490257735d9c6be0529652c", "patch": "@@ -1,3 +1,12 @@\n+2004-12-10  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR target/18002\n+\tPR middle-end/18424\n+\t* dojump.c (do_jump): When attempting to reverse the effects of\n+\tfold_single_bit_test, we need to STRIP_NOPS and narrowing type\n+\tconversions, and handle BIT_XOR_EXPR that's used to invert the\n+\tsense of the single bit test.\n+\n 2004-12-10  Devang Patel  <dpatel@apple.com>\n \n \tPR 18732"}, {"sha": "93bcb8be41a1f2131ea8138f76e519af65182922", "filename": "gcc/dojump.c", "status": "modified", "additions": 44, "deletions": 16, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e5bcef316b5e5562490257735d9c6be0529652c/gcc%2Fdojump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e5bcef316b5e5562490257735d9c6be0529652c/gcc%2Fdojump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdojump.c?ref=3e5bcef316b5e5562490257735d9c6be0529652c", "patch": "@@ -218,24 +218,52 @@ do_jump (tree exp, rtx if_false_label, rtx if_true_label)\n       /* fold_single_bit_test() converts (X & (1 << C)) into (X >> C) & 1.\n \t See if the former is preferred for jump tests and restore it\n \t if so.  */\n-      if (TREE_CODE (TREE_OPERAND (exp, 0)) == RSHIFT_EXPR\n-\t  && integer_onep (TREE_OPERAND (exp, 1)))\n+      if (integer_onep (TREE_OPERAND (exp, 1)))\n \t{\n-\t  tree arg = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n-\t  tree shift = TREE_OPERAND (TREE_OPERAND (exp, 0), 1);\n-\t  tree one = TREE_OPERAND (exp, 1);\n-\t  tree argtype = TREE_TYPE (arg);\n-\t  if (TREE_CODE (shift) == INTEGER_CST\n-\t      && compare_tree_int (shift, 0) > 0\n-\t      && compare_tree_int (shift, HOST_BITS_PER_WIDE_INT) < 0\n-\t      && prefer_and_bit_test (TYPE_MODE (argtype),\n-\t\t\t\t      TREE_INT_CST_LOW (shift)))\n+\t  tree exp0 = TREE_OPERAND (exp, 0);\n+\t  rtx set_label, clr_label;\n+\n+\t  /* Strip narrowing integral type conversions.  */\n+\t  while ((TREE_CODE (exp0) == NOP_EXPR\n+\t\t  || TREE_CODE (exp0) == CONVERT_EXPR\n+\t\t  || TREE_CODE (exp0) == NON_LVALUE_EXPR)\n+\t\t && TREE_OPERAND (exp0, 0) != error_mark_node\n+\t\t && TYPE_PRECISION (TREE_TYPE (exp0))\n+\t\t    <= TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (exp0, 0))))\n+\t    exp0 = TREE_OPERAND (exp0, 0);\n+\n+\t  /* \"exp0 ^ 1\" inverts the sense of the single bit test.  */\n+\t  if (TREE_CODE (exp0) == BIT_XOR_EXPR\n+\t      && integer_onep (TREE_OPERAND (exp0, 1)))\n \t    {\n-\t      do_jump (build2 (BIT_AND_EXPR, argtype, arg,\n-\t\t\t       fold (build2 (LSHIFT_EXPR, argtype,\n-\t\t\t\t\t     one, shift))),\n-\t\t       if_false_label, if_true_label);\n-\t      break;\n+\t      exp0 = TREE_OPERAND (exp0, 0);\n+\t      clr_label = if_true_label;\n+\t      set_label = if_false_label;\n+\t    }\n+\t  else\n+\t    {\n+\t      clr_label = if_false_label;\n+\t      set_label = if_true_label;\n+\t    }\n+\n+\t  if (TREE_CODE (exp0) == RSHIFT_EXPR)\n+\t    {\n+\t      tree arg = TREE_OPERAND (exp0, 0);\n+\t      tree shift = TREE_OPERAND (exp0, 1);\n+\t      tree argtype = TREE_TYPE (arg);\n+\t      if (TREE_CODE (shift) == INTEGER_CST\n+\t\t  && compare_tree_int (shift, 0) >= 0\n+\t\t  && compare_tree_int (shift, HOST_BITS_PER_WIDE_INT) < 0\n+\t\t  && prefer_and_bit_test (TYPE_MODE (argtype),\n+\t\t\t\t\t  TREE_INT_CST_LOW (shift)))\n+\t\t{\n+\t\t  HOST_WIDE_INT mask = (HOST_WIDE_INT) 1\n+\t\t\t\t       << TREE_INT_CST_LOW (shift);\n+\t\t  do_jump (build2 (BIT_AND_EXPR, argtype, arg,\n+\t\t\t\t   build_int_cst_type (argtype, mask)),\n+\t\t\t   clr_label, set_label);\n+\t\t  break;\n+\t\t}\n \t    }\n \t}\n "}]}