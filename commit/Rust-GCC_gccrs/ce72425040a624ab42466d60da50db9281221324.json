{"sha": "ce72425040a624ab42466d60da50db9281221324", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2U3MjQyNTA0MGE2MjRhYjQyNDY2ZDYwZGE1MGRiOTI4MTIyMTMyNA==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "1999-11-11T09:21:12Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-11-11T09:21:12Z"}, "message": "flow.c (compute_flow_dominators): Initially put all blocks on the worklist.\n\n        * flow.c (compute_flow_dominators): Initially put all blocks on\n        the worklist.\n        * lcm.c (compute_antinout_edge, compute_available): Similarly.\n        * gcse.c (compute_cprop_avinout): Remove.\n        (compute_cprop_data): Use compute_available.\n        (delete_null_pointer_checks_1): Use compute_available.\n\nFrom-SVN: r30484", "tree": {"sha": "62d2dd61bfefebccef8340515c5d9930c4e5d1f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62d2dd61bfefebccef8340515c5d9930c4e5d1f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce72425040a624ab42466d60da50db9281221324", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce72425040a624ab42466d60da50db9281221324", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce72425040a624ab42466d60da50db9281221324", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce72425040a624ab42466d60da50db9281221324/comments", "author": null, "committer": null, "parents": [{"sha": "cc2bd962dab4c5f4efddccca2e7beecf95102370", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc2bd962dab4c5f4efddccca2e7beecf95102370", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc2bd962dab4c5f4efddccca2e7beecf95102370"}], "stats": {"total": 142, "additions": 48, "deletions": 94}, "files": [{"sha": "7e410356911dbcf2161818e8d605922cc9fec8df", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72425040a624ab42466d60da50db9281221324/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72425040a624ab42466d60da50db9281221324/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ce72425040a624ab42466d60da50db9281221324", "patch": "@@ -4,6 +4,13 @@ Wed Nov 10 21:24:19 1999  Jason Eckhardt  <jle@cygnus.com>\n \n Wed Nov 10 15:56:16 1999  Jeffrey A Law  (law@cygnus.com)\n \n+\t* flow.c (compute_flow_dominators): Initially put all blocks on\n+\tthe worklist.\n+\t* lcm.c (compute_antinout_edge, compute_available): Similarly.\n+\t* gcse.c (compute_cprop_avinout): Remove.\n+\t(compute_cprop_data): Use compute_available.\n+\t(delete_null_pointer_checks_1): Use compute_available.\n+\n \t* basic-block.h (compute_available): Returns a void now.\n \t* gcse.c (one_classic_gcse_pass): Do not expect compute_available\n \tto return a value anymore."}, {"sha": "9ed2b35646a8eca4633a2c961c6761122328c072", "filename": "gcc/flow.c", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72425040a624ab42466d60da50db9281221324/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72425040a624ab42466d60da50db9281221324/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ce72425040a624ab42466d60da50db9281221324", "patch": "@@ -5339,24 +5339,21 @@ compute_flow_dominators (dominators, post_dominators)\n \n   if (dominators)\n     {\n-      /* Clear the AUX field for each basic block.  */\n+      /* The optimistic setting of dominators requires us to put every\n+\t block on the work list initially.  */\n       for (bb = 0; bb < n_basic_blocks; bb++)\n-\tBASIC_BLOCK (bb)->aux = NULL;\n+\t{\n+\t  *tos++ = BASIC_BLOCK (bb);\n+\t  BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n+\t}\n \n       /* We want a maximal solution, so initially assume everything dominates\n \t everything else.  */\n       sbitmap_vector_ones (dominators, n_basic_blocks);\n \n-      /* Put the successors of the entry block on the worklist.  */\n+      /* Mark successors of the entry block so we can identify them below.  */\n       for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n-\t{\n-\t  *tos++ = e->dest;\n-\n-\t  /* We use the block's aux field to track blocks which are in\n-\t     the worklist; we also use it to quickly determine which blocks\n-\t     are successors of the ENTRY block.  */\n-\t  e->dest->aux = ENTRY_BLOCK_PTR;\n-\t}\n+\te->dest->aux = ENTRY_BLOCK_PTR;\n \n       /* Iterate until the worklist is empty.  */\n       while (tos != worklist)\n@@ -5412,24 +5409,21 @@ compute_flow_dominators (dominators, post_dominators)\n \n   if (post_dominators)\n     {\n-      /* Clear the AUX field for each basic block.  */\n+      /* The optimistic setting of dominators requires us to put every\n+\t block on the work list initially.  */\n       for (bb = 0; bb < n_basic_blocks; bb++)\n-\tBASIC_BLOCK (bb)->aux = NULL;\n+\t{\n+\t  *tos++ = BASIC_BLOCK (bb);\n+\t  BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n+\t}\n \n       /* We want a maximal solution, so initially assume everything post\n \t dominates everything else.  */\n       sbitmap_vector_ones (post_dominators, n_basic_blocks);\n \n-      /* Put the predecessors of the exit block on the worklist.  */\n+      /* Mark predecessors of the exit block so we can identify them below.  */\n       for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n-\t{\n-\t  *tos++ = e->src;\n-\n-\t  /* We use the block's aux field to track blocks which are in\n-\t     the worklist; we also use it to quickly determine which blocks\n-\t     are predecessors of the EXIT block.  */\n-\t  e->src->aux = EXIT_BLOCK_PTR;\n-\t}\n+\te->src->aux = EXIT_BLOCK_PTR;\n \n       /* Iterate until the worklist is empty.  */\n       while (tos != worklist)"}, {"sha": "f1018d2c4adc74f922ccc09e624834a74446ab0f", "filename": "gcc/gcse.c", "status": "modified", "additions": 5, "deletions": 56, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72425040a624ab42466d60da50db9281221324/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72425040a624ab42466d60da50db9281221324/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=ce72425040a624ab42466d60da50db9281221324", "patch": "@@ -581,7 +581,6 @@ static void compute_transp\t    PROTO ((rtx, int, sbitmap *, int));\n static void compute_transpout\t    PROTO ((void));\n static void compute_local_properties  PROTO ((sbitmap *, sbitmap *,\n \t\t\t\t\t      sbitmap *, int));\n-static void compute_cprop_avinout     PROTO ((void));\n static void compute_cprop_data\tPROTO ((void));\n static void find_used_regs\t    PROTO ((rtx));\n static int try_replace_reg\t    PROTO ((rtx, rtx, rtx));\n@@ -3591,48 +3590,15 @@ compute_transp (x, indx, bmap, set_p)\n     }\n }\n \n-/* Compute the available expressions at the start and end of each\n-   basic block for cprop.  This particular dataflow equation is\n-   used often enough that we might want to generalize it and make\n-   as a subroutine for other global optimizations that need available\n-   in/out information.  */\n-static void\n-compute_cprop_avinout ()\n-{\n-  int bb, changed, passes;\n-\n-  sbitmap_zero (cprop_avin[0]);\n-  sbitmap_vector_ones (cprop_avout, n_basic_blocks);\n-\n-  passes = 0;\n-  changed = 1;\n-  while (changed)\n-    {\n-      changed = 0;\n-      for (bb = 0; bb < n_basic_blocks; bb++)\n-\t{\n-\t  if (bb != 0)\n-\t    sbitmap_intersection_of_preds (cprop_avin[bb], cprop_avout, bb);\n-\t  changed |= sbitmap_union_of_diff (cprop_avout[bb],\n-\t\t\t\t\t    cprop_pavloc[bb],\n-\t\t\t\t\t    cprop_avin[bb],\n-\t\t\t\t\t    cprop_absaltered[bb]);\n-\t}\n-      passes++;\n-    }\n-\n-  if (gcse_file)\n-    fprintf (gcse_file, \"cprop avail expr computation: %d passes\\n\", passes);\n-}\n-\n /* Top level routine to do the dataflow analysis needed by copy/const\n    propagation.  */\n \n static void\n compute_cprop_data ()\n {\n   compute_local_properties (cprop_absaltered, cprop_pavloc, NULL, 1);\n-  compute_cprop_avinout ();\n+  compute_available (cprop_pavloc, cprop_absaltered,\n+\t\t     cprop_avout, cprop_avin);\n }\n \f\n /* Copy/constant propagation.  */\n@@ -5030,7 +4996,7 @@ delete_null_pointer_checks_1 (s_preds, block_reg, nonnull_avin,\n      sbitmap *nonnull_avout;\n      struct null_pointer_info *npi;\n {\n-  int changed, bb;\n+  int bb;\n   int current_block;\n   sbitmap *nonnull_local = npi->nonnull_local;\n   sbitmap *nonnull_killed = npi->nonnull_killed;\n@@ -5103,25 +5069,8 @@ delete_null_pointer_checks_1 (s_preds, block_reg, nonnull_avin,\n \n   /* Now compute global properties based on the local properties.   This\n      is a classic global availablity algorithm.  */\n-  sbitmap_zero (nonnull_avin[0]);\n-  sbitmap_vector_ones (nonnull_avout, n_basic_blocks);\n-  changed = 1;\n-  while (changed)\n-    {\n-      changed = 0;\n-\n-      for (bb = 0; bb < n_basic_blocks; bb++)\n-\t{\n-\t  if (bb != 0)\n-\t    sbitmap_intersect_of_predecessors (nonnull_avin[bb],\n-\t\t\t\t\t       nonnull_avout, bb, s_preds);\n-\n-\t  changed |= sbitmap_union_of_diff (nonnull_avout[bb],\n-\t\t\t\t\t    nonnull_local[bb],\n-\t\t\t\t\t    nonnull_avin[bb],\n-\t\t\t\t\t    nonnull_killed[bb]);\n-\t}\n-    }\n+  compute_available (nonnull_local, nonnull_killed,\n+\t\t     nonnull_avout, nonnull_avin);\n \n   /* Now look at each bb and see if it ends with a compare of a value\n      against zero.  */"}, {"sha": "12a16ed87c096fe0d07076f9e74498f12ffc1dd2", "filename": "gcc/lcm.c", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce72425040a624ab42466d60da50db9281221324/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce72425040a624ab42466d60da50db9281221324/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=ce72425040a624ab42466d60da50db9281221324", "patch": "@@ -112,17 +112,19 @@ compute_antinout_edge (antloc, transp, antin, antout)\n      ANTIN.  */\n   sbitmap_vector_ones (antin, n_basic_blocks);\n \n-  /* Put the predecessors of the exit block on the worklist.  */\n-  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+  /* Put every block on the worklist; this is necessary because of the\n+     optimistic initialization of ANTIN above.  */\n+  for (bb = 0; bb < n_basic_blocks; bb++)\n     {\n-      *tos++ = e->src;\n-\n-      /* We use the block's aux field to track blocks which are in\n-\t the worklist; we also use it to quickly determine which blocks\n-\t are predecessors of the EXIT block.  */\n-      e->src->aux = EXIT_BLOCK_PTR;\n+      *tos++ = BASIC_BLOCK (bb);\n+      BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n     }\n \n+  /* Mark blocks which are predecessors of the exit block so that we\n+     can easily identify them below.  */\n+  for (e = EXIT_BLOCK_PTR->pred; e; e = e->pred_next)\n+    e->src->aux = EXIT_BLOCK_PTR;\n+\n   /* Iterate until the worklist is empty.  */\n   while (tos != worklist)\n     {\n@@ -467,17 +469,19 @@ compute_available (avloc, kill, avout, avin)\n   /* We want a maximal solution.  */\n   sbitmap_vector_ones (avout, n_basic_blocks);\n \n-  /* Put the successors of the entry block on the worklist.  */\n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+  /* Put every block on the worklist; this is necessary because of the\n+     optimistic initialization of AVOUT above.  */\n+  for (bb = n_basic_blocks - 1; bb >= 0; bb--)\n     {\n-      *tos++ = e->dest;\n-\n-      /* We use the block's aux field to track blocks which are in\n-\t the worklist; we also use it to quickly determine which blocks\n-\t are successors of the ENTRY block.  */\n-      e->dest->aux = ENTRY_BLOCK_PTR;\n+      *tos++ = BASIC_BLOCK (bb);\n+      BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n     }\n \n+  /* Mark blocks which are successors of the entry block so that we\n+     can easily identify them below.  */\n+  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n+    e->dest->aux = ENTRY_BLOCK_PTR;\n+\n   /* Iterate until the worklist is empty.  */\n   while (tos != worklist)\n     {"}]}