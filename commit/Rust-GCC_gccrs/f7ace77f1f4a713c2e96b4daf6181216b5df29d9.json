{"sha": "f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjdhY2U3N2YxZjRhNzEzYzJlOTZiNGRhZjYxODEyMTZiNWRmMjlkOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-01-04T11:34:45Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-01-04T11:34:45Z"}, "message": "sso_string_base.h (__sso_string_base<>::_M_dataplus): Use _CharT_alloc_type as base class.\n\n2006-01-04  Paolo Carlini  <pcarlini@suse.de>\n\n        * include/ext/sso_string_base.h (__sso_string_base<>::_M_dataplus):\n        Use _CharT_alloc_type as base class.\n        (_M_get_allocator, _M_swap, _M_create, _M_destroy): Adjust.\n        * include/ext/vstring.h (get_allocator): Tidy.\n\n2006-01-04  Paolo Carlini  <pcarlini@suse.de>\n\n\tImplement Option 3 of DR 431 for all the containers.\n\t* include/bits/allocator.h (struct __alloc_swap): Add, swaps\n\tallocators, optimized to nothing in case they are empty.\n\t* include/bits/stl_deque.h (deque<>::swap): Use it.\n\t* include/bits/stl_list.h (list<>::swap): Likewise.\n\t* include/bits/stl_tree.h (_Rb_tree<>::swap): Likewise.\n\t* include/bits/stl_vector.h (vector<>::swap): Likewise.\n\t* include/tr1/hashtable (hashtable<>::swap): Likewise.\n\t* include/ext/rc_string_base.h (__rc_string_base<>::_M_swap):\n\tLikewise.\n\t* include/ext/sso_string_base.h (__sso_string_base<>::_M_swap):\n\tLikewise.\n\t* include/ext/vstring_util.h (__vstring_utility<>::_Alloc_hider):\n\tClean-up (now vstring uses the generic __alloc_swap facility).\n\t* include/tr1/unordered_map: Adjust includes.\n\t* include/tr1/unordered_set: Likewise.\n\t* docs/html/ext/howto.html: Add an entry for DR 431.\n\t* testsuite/23_containers/deque/modifiers/swap.cc: Move to...\n\t* testsuite/23_containers/deque/modifiers/swap/1.cc: ... here.\t\t\n\t* testsuite/23_containers/deque/modifiers/swap/2.cc: New.\n\t* testsuite/23_containers/deque/modifiers/swap/3.cc: New.\n\t* testsuite/23_containers/list/modifiers/swap.cc: Move to...\n\t* testsuite/23_containers/list/modifiers/swap/1.cc: ... here.\t\t\n\t* testsuite/23_containers/list/modifiers/swap/2.cc: New.\n\t* testsuite/23_containers/list/modifiers/swap/3.cc: New.\n\t* testsuite/23_containers/vector/modifiers/swap.cc: Move to...\n\t* testsuite/23_containers/vector/modifiers/swap/1.cc: ... here.\t\t\n\t* testsuite/23_containers/vector/modifiers/swap/2.cc: New.\n\t* testsuite/23_containers/vector/modifiers/swap/3.cc: New.\n\t* testsuite/23_containers/set/modifiers/swap.cc: Move to...\n\t* testsuite/23_containers/set/modifiers/swap/1.cc: ... here.\t\t\n\t* testsuite/23_containers/set/modifiers/swap/2.cc: New.\n\t* testsuite/23_containers/set/modifiers/swap/3.cc: New.\n\t* testsuite/23_containers/map/modifiers/swap.cc: Move to...\n\t* testsuite/23_containers/map/modifiers/swap/1.cc: ... here.\t\t\n\t* testsuite/23_containers/map/modifiers/swap/2.cc: New.\n\t* testsuite/23_containers/map/modifiers/swap/3.cc: New.\n\t* testsuite/23_containers/multiset/modifiers/swap.cc: Move to...\n\t* testsuite/23_containers/multiset/modifiers/swap/1.cc: ... here.\t\t\n\t* testsuite/23_containers/multiset/modifiers/swap/2.cc: New.\n\t* testsuite/23_containers/multiset/modifiers/swap/3.cc: New.\n\t* testsuite/23_containers/multimap/modifiers/swap.cc: Move to...\n\t* testsuite/23_containers/multimap/modifiers/swap/1.cc: ... here.\t\t\n\t* testsuite/23_containers/multimap/modifiers/swap/2.cc: New.\n\t* testsuite/23_containers/multimap/modifiers/swap/3.cc: New.\n\t* testsuite/tr1/6_containers/unordered/swap/unordered_set/1.cc: New.\t\n\t* testsuite/tr1/6_containers/unordered/swap/unordered_set/2.cc: New.\n\t* testsuite/tr1/6_containers/unordered/swap/unordered_map/1.cc: New.\t\n\t* testsuite/tr1/6_containers/unordered/swap/unordered_map/2.cc: New.\n\t* testsuite/tr1/6_containers/unordered/swap/unordered_multiset/1.cc: New.\t\n\t* testsuite/tr1/6_containers/unordered/swap/unordered_multiset/2.cc: New.\n\t* testsuite/tr1/6_containers/unordered/swap/unordered_multimap/1.cc: New.\t\n\t* testsuite/tr1/6_containers/unordered/swap/unordered_multimap/2.cc: New.\n\nFrom-SVN: r109324", "tree": {"sha": "cd3bddece803156966caae41da6fe7437f45b8f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cd3bddece803156966caae41da6fe7437f45b8f1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/comments", "author": null, "committer": null, "parents": [{"sha": "db5d99e8b1c97aac22051f5dfd9296283e0d9848", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db5d99e8b1c97aac22051f5dfd9296283e0d9848", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db5d99e8b1c97aac22051f5dfd9296283e0d9848"}], "stats": {"total": 3671, "additions": 3619, "deletions": 52}, "files": [{"sha": "9d86bc04162617a07c5d8c60b2135c5e1e0da825", "filename": "libstdc++-v3/docs/html/ext/howto.html", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fext%2Fhowto.html?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -516,6 +516,12 @@ <h2><a name=\"5\">LWG Issues</a></h2>\n     <dd>Have <code>open</code> clear the error flags.\n     </dd>\n \n+    <dt><a href=\"lwg-active.html#431\">431</a>:\n+        <em>Swapping containers with unequal allocators</em>\n+    </dt>\n+    <dd>Implement Option 3, as per N1599.\n+    </dd>\n+\n     <dt><a href=\"lwg-defects.html#434\">434</a>:\n         <em>bitset::to_string() hard to use</em>\n     </dt>"}, {"sha": "3e8d94a26e1cbc266933d5f654011eb322e30ac0", "filename": "libstdc++-v3/include/bits/allocator.h", "status": "modified", "additions": 19, "deletions": 1, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fallocator.h?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -1,6 +1,7 @@\n // Allocators -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006\n+// Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -128,6 +129,23 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n   // Undefine.\n #undef __glibcxx_base_allocator\n \n+  // To implement Option 3 of DR 431.\n+  template<typename _Alloc, bool = std::__is_empty<_Alloc>::__value>\n+    struct __alloc_swap\n+    { static void _S_do_it(_Alloc&, _Alloc&) { } };\n+\n+  template<typename _Alloc>\n+    struct __alloc_swap<_Alloc, false>\n+    {\n+      static void\n+      _S_do_it(_Alloc& __one, _Alloc& __two)\n+      {\n+\t// Precondition: swappable allocators.\n+\tif (__one != __two)\n+\t  swap(__one, __two);\n+      }\n+    };\n+\n _GLIBCXX_END_NAMESPACE\n \n #endif"}, {"sha": "8f3fc99f61ef3797abe0bc2a8e0dc30656962a34", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -1195,6 +1195,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n \tstd::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n \tstd::swap(this->_M_impl._M_map, __x._M_impl._M_map);\n \tstd::swap(this->_M_impl._M_map_size, __x._M_impl._M_map_size);\n+\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 431. Swapping containers with unequal allocators.\n+\tstd::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),\n+\t\t\t\t\t\t    __x._M_get_Tp_allocator());\n       }\n \n       /**"}, {"sha": "513833c71efb3b7d5d34fb33f2f2893395aaa83a", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -888,7 +888,14 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n        */\n       void\n       swap(list& __x)\n-      { _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node); }\n+      {\n+\t_List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node);\n+\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 431. Swapping containers with unequal allocators.\n+\tstd::__alloc_swap<typename _Base::_Node_alloc_type>::\n+\t  _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());\n+      }\n \n       /**\n        *  Erases all the elements.  Note that this function only erases"}, {"sha": "01a8bad81c9b34208f0de5d2871b53bc659bf69b", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -912,6 +912,11 @@ _GLIBCXX_BEGIN_NAMESPACE(std)\n       // No need to swap header's color as it does not change.\n       std::swap(this->_M_impl._M_node_count, __t._M_impl._M_node_count);\n       std::swap(this->_M_impl._M_key_compare, __t._M_impl._M_key_compare);\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 431. Swapping containers with unequal allocators.\n+      std::__alloc_swap<_Node_allocator>::\n+\t_S_do_it(_M_get_Node_allocator(), __t._M_get_Node_allocator());\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,"}, {"sha": "b4434fca8631d2d342b44d57e2e49487f023a271", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -731,6 +731,11 @@ _GLIBCXX_BEGIN_NESTED_NAMESPACE(std, _GLIBCXX_STD)\n \tstd::swap(this->_M_impl._M_finish, __x._M_impl._M_finish);\n \tstd::swap(this->_M_impl._M_end_of_storage,\n \t\t  __x._M_impl._M_end_of_storage);\n+\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 431. Swapping containers with unequal allocators.\n+\tstd::__alloc_swap<_Tp_alloc_type>::_S_do_it(_M_get_Tp_allocator(),\n+\t\t\t\t\t\t    __x._M_get_Tp_allocator());\n       }\n \n       /**"}, {"sha": "dece887d1995fc1ece8dd6b81d15d62668e43416", "filename": "libstdc++-v3/include/ext/rc_string_base.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fext%2Frc_string_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fext%2Frc_string_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Frc_string_base.h?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -583,9 +583,11 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       _CharT* __tmp = _M_data();\n       _M_data(__rcs._M_data());\n       __rcs._M_data(__tmp);\n-      \n-      // NB: Implement Option 3 of DR 431 (see N1599).\n-      _M_dataplus._M_alloc_swap(__rcs._M_dataplus);\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 431. Swapping containers with unequal allocators.\n+      std::__alloc_swap<allocator_type>::_S_do_it(_M_get_allocator(),\n+\t\t\t\t\t\t  __rcs._M_get_allocator());\n     } \n \n   template<typename _CharT, typename _Traits, typename _Alloc>"}, {"sha": "0bf99cad53f4b3d81b78f7ceadb85a75194217ba", "filename": "libstdc++-v3/include/ext/sso_string_base.h", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fext%2Fsso_string_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fext%2Fsso_string_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fsso_string_base.h?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -1,6 +1,6 @@\n // Short-string-optimized versatile string base -*- C++ -*-\n \n-// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -45,7 +45,6 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     public:\n       typedef _Traits\t\t\t\t\t    traits_type;\n       typedef typename _Traits::char_type\t\t    value_type;\n-      typedef _Alloc\t\t\t\t\t    allocator_type;\n \n       typedef __vstring_utility<_CharT, _Traits, _Alloc>    _Util_Base;\n       typedef typename _Util_Base::_CharT_alloc_type        _CharT_alloc_type;\n@@ -67,7 +66,8 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \t\t\t      / sizeof(_CharT)) - 1) / 4) };\n \n       // Data Members (private):\n-      typename _Util_Base::template _Alloc_hider<_Alloc>    _M_dataplus;\n+      typename _Util_Base::template _Alloc_hider<_CharT_alloc_type>\n+                                                            _M_dataplus;\n       size_type                                             _M_string_length;\n \n       enum { _S_local_capacity = 15 };\n@@ -202,11 +202,11 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       ~__sso_string_base()\n       { _M_dispose(); }\n \n-      allocator_type&\n+      _CharT_alloc_type&\n       _M_get_allocator()\n       { return _M_dataplus; }\n \n-      const allocator_type&\n+      const _CharT_alloc_type&\n       _M_get_allocator() const\n       { return _M_dataplus; }\n \n@@ -235,15 +235,17 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n     void\n     __sso_string_base<_CharT, _Traits, _Alloc>::\n     _M_destroy(size_type __size) throw()\n-    { _CharT_alloc_type(_M_get_allocator()).deallocate(_M_data(), __size + 1); }\n+    { _M_dataplus._CharT_alloc_type::deallocate(_M_data(), __size + 1); }\n \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     void\n     __sso_string_base<_CharT, _Traits, _Alloc>::\n     _M_swap(__sso_string_base& __rcs)\n     {\n-      // NB: Implement Option 3 of DR 431 (see N1599).\n-      _M_dataplus._M_alloc_swap(__rcs._M_dataplus);\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 431. Swapping containers with unequal allocators.\n+      std::__alloc_swap<_CharT_alloc_type>::_S_do_it(_M_get_allocator(),\n+\t\t\t\t\t\t     __rcs._M_get_allocator());\n \n       if (_M_is_local())\n \tif (__rcs._M_is_local())\n@@ -327,7 +329,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n \n       // NB: Need an array of char_type[__capacity], plus a terminating\n       // null char_type() element.\n-      return _CharT_alloc_type(_M_get_allocator()).allocate(__capacity + 1);\n+      return _M_dataplus._CharT_alloc_type::allocate(__capacity + 1);\n     }\n \n   template<typename _CharT, typename _Traits, typename _Alloc>"}, {"sha": "a117c5826eebbb68dd7eda4e30b8fa7ae6bfb647", "filename": "libstdc++-v3/include/ext/vstring.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring.h?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -1,6 +1,6 @@\n // Versatile string -*- C++ -*-\n \n-// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -1271,7 +1271,7 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n       */\n       allocator_type\n       get_allocator() const\n-      { return this->_M_get_allocator(); }\n+      { return allocator_type(this->_M_get_allocator()); }\n \n       /**\n        *  @brief  Find position of a C substring."}, {"sha": "a17de08825224adc2d453a7f8dd6cd4081ec3e46", "filename": "libstdc++-v3/include/ext/vstring_util.h", "status": "modified", "additions": 3, "deletions": 27, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring_util.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring_util.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fvstring_util.h?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -1,6 +1,6 @@\n // Versatile string utility -*- C++ -*-\n \n-// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -83,38 +83,14 @@ _GLIBCXX_BEGIN_NAMESPACE(__gnu_cxx)\n         __const_rc_iterator;\n \n       // NB:  When the allocator is empty, deriving from it saves space \n-      // (http://www.cantrip.org/emptyopt.html).  We do that anyway for\n-      // consistency.\n-      template<typename _Alloc1, bool = std::__is_empty<_Alloc1>::__value>\n-        struct _Alloc_hider\n-\t: public _Alloc1\n-\t{\n-\t  _Alloc_hider(const _Alloc1& __a, _CharT* __ptr)\n-\t  : _Alloc1(__a), _M_p(__ptr) { }\n-\n-\t  void\n-\t  _M_alloc_swap(_Alloc_hider& __ah)\n-\t  {\n-\t    // Implement Option 3 of DR 431 (see N1599).\n-\t    // Precondition: swappable allocators.\n-\t    _Alloc1& __this = static_cast<_Alloc1&>(*this);\n-\t    _Alloc1& __that = static_cast<_Alloc1&>(__ah);\n-\t    if (__this != __that)\n-\t      swap(__this, __that);\n-\t  }\n-\n-\t  _CharT*  _M_p; // The actual data.\n-\t};\n-\n+      // (http://www.cantrip.org/emptyopt.html).\n       template<typename _Alloc1>\n-        struct _Alloc_hider<_Alloc1, true>\n+        struct _Alloc_hider\n \t: public _Alloc1\n \t{\n \t  _Alloc_hider(const _Alloc1& __a, _CharT* __ptr)\n \t  : _Alloc1(__a), _M_p(__ptr) { }\n \n-\t  void _M_alloc_swap(_Alloc_hider&) { }\n-\n \t  _CharT*  _M_p; // The actual data.\n \t};\n "}, {"sha": "0b9bc4184431041778c97969fdde544dab1b972c", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -1,6 +1,6 @@\n // Internal header for TR1 unordered_set and unordered_map -*- C++ -*-\n \n-// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -55,6 +55,7 @@\n #define GNU_LIBSTDCXX_TR1_HASHTABLE_\n \n #include <utility>\t\t// For std::pair\n+#include <memory>\n #include <iterator>\n #include <cstddef>\n #include <cstdlib>\n@@ -1443,8 +1444,11 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       // have different members.\n       Internal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>::m_swap(x);\n \n-      // open LWG issue 431\n-      // std::swap(m_node_allocator, x.m_node_allocator);\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 431. Swapping containers with unequal allocators.\n+      std::__alloc_swap<node_allocator_t>::_S_do_it(m_node_allocator,\n+\t\t\t\t\t\t    x.m_node_allocator);\n+\n       std::swap(m_rehash_policy, x.m_rehash_policy);\n       std::swap(m_buckets, x.m_buckets);\n       std::swap(m_bucket_count, x.m_bucket_count);"}, {"sha": "da0d86bf8b6f96f2f89d9608ff9e3724fa2555ba", "filename": "libstdc++-v3/include/tr1/unordered_map", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_map?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -1,6 +1,6 @@\n // TR1 unordered_map -*- C++ -*-\n \n-// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -36,9 +36,6 @@\n \n #include <tr1/hashtable>\n #include <tr1/functional>\n-#include <tr1/functional>\n-#include <utility>\n-#include <memory>\n \n namespace std\n {"}, {"sha": "02c518451af5157751b89d1dd9b0c0cb22dc73e6", "filename": "libstdc++-v3/include/tr1/unordered_set", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Funordered_set?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -1,6 +1,6 @@\n // TR1 unordered_set -*- C++ -*-\n \n-// Copyright (C) 2005 Free Software Foundation, Inc.\n+// Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -36,7 +36,6 @@\n \n #include <tr1/hashtable>\n #include <tr1/functional>\n-#include <memory>\n \n namespace std\n { "}, {"sha": "2834ae56d8282613272e8327d6dd0a0d10c9d57b", "filename": "libstdc++-v3/testsuite/23_containers/deque/modifiers/swap/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Fswap%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Fswap%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Fswap%2F1.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "previous_filename": "libstdc++-v3/testsuite/23_containers/deque/modifiers/swap.cc"}, {"sha": "25402a79178fa66c3cf568674cf1d6972dba1a19", "filename": "libstdc++-v3/testsuite/23_containers/deque/modifiers/swap/2.cc", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Fswap%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Fswap%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Fswap%2F2.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,133 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.1.3 deque::swap\n+\n+#include <deque>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef deque<char, my_alloc> my_deque;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  my_deque::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_deque deq01(alloc01);\n+  size01 = deq01.size();\n+  my_deque deq02(alloc01);\n+  size02 = deq02.size();\n+  \n+  deq01.swap(deq02);\n+  VERIFY( deq01.size() == size02 );\n+  VERIFY( deq01.empty() );\n+  VERIFY( deq02.size() == size01 );\n+  VERIFY( deq02.empty() );\n+\n+  my_deque deq03(alloc01);\n+  size01 = deq03.size();\n+  my_deque deq04(title02, title02 + N2, alloc01);\n+  size02 = deq04.size();\n+  \n+  deq03.swap(deq04);\n+  VERIFY( deq03.size() == size02 );\n+  VERIFY( equal(deq03.begin(), deq03.end(), title02) );\n+  VERIFY( deq04.size() == size01 );\n+  VERIFY( deq04.empty() );\n+  \n+  my_deque deq05(title01, title01 + N1, alloc01);\n+  size01 = deq05.size();\n+  my_deque deq06(title02, title02 + N2, alloc01);\n+  size02 = deq06.size();\n+  \n+  deq05.swap(deq06);\n+  VERIFY( deq05.size() == size02 );\n+  VERIFY( equal(deq05.begin(), deq05.end(), title02) );\n+  VERIFY( deq06.size() == size01 );\n+  VERIFY( equal(deq06.begin(), deq06.end(), title01) );\n+\n+  my_deque deq07(title01, title01 + N1, alloc01);\n+  size01 = deq07.size();\n+  my_deque deq08(title03, title03 + N3, alloc01);\n+  size02 = deq08.size();\n+\n+  deq07.swap(deq08);\n+  VERIFY( deq07.size() == size02 );\n+  VERIFY( equal(deq07.begin(), deq07.end(), title03) );\n+  VERIFY( deq08.size() == size01 );\n+  VERIFY( equal(deq08.begin(), deq08.end(), title01) );\n+\n+  my_deque deq09(title03, title03 + N3, alloc01);\n+  size01 = deq09.size();\n+  my_deque deq10(title04, title04 + N4, alloc01);\n+  size02 = deq10.size();\n+\n+  deq09.swap(deq10);\n+  VERIFY( deq09.size() == size02 );\n+  VERIFY( equal(deq09.begin(), deq09.end(), title04) );\n+  VERIFY( deq10.size() == size01 );\n+  VERIFY( equal(deq10.begin(), deq10.end(), title03) );\n+\n+  my_deque deq11(title04, title04 + N4, alloc01);\n+  size01 = deq11.size();\n+  my_deque deq12(title01, title01 + N1, alloc01);\n+  size02 = deq12.size();\n+\n+  deq11.swap(deq12);\n+  VERIFY( deq11.size() == size02 );\n+  VERIFY( equal(deq11.begin(), deq11.end(), title01) );\n+  VERIFY( deq12.size() == size01 );\n+  VERIFY( equal(deq12.begin(), deq12.end(), title04) );\n+\n+  my_deque deq13(title03, title03 + N3, alloc01);\n+  size01 = deq13.size();\n+  my_deque deq14(title03, title03 + N3, alloc01);\n+  size02 = deq14.size();\n+\n+  deq13.swap(deq14);\n+  VERIFY( deq13.size() == size02 );\n+  VERIFY( equal(deq13.begin(), deq13.end(), title03) );\n+  VERIFY( deq14.size() == size01 );\n+  VERIFY( equal(deq14.begin(), deq14.end(), title03) );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "70f5e2abf9cc9f61e4e8838291f421e7c6aa7659", "filename": "libstdc++-v3/testsuite/23_containers/deque/modifiers/swap/3.cc", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Fswap%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Fswap%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Fmodifiers%2Fswap%2F3.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,162 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.1.3 deque::swap\n+\n+#include <deque>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef deque<char, my_alloc> my_deque;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  my_deque::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_deque deq01(alloc01);\n+  size01 = deq01.size();\n+  personality01 = deq01.get_allocator().get_personality();\n+  my_deque deq02(alloc02);\n+  size02 = deq02.size();\n+  personality02 = deq02.get_allocator().get_personality();\n+\n+  deq01.swap(deq02);\n+  VERIFY( deq01.size() == size02 );\n+  VERIFY( deq01.empty() );\n+  VERIFY( deq02.size() == size01 );\n+  VERIFY( deq02.empty() );\n+  VERIFY( deq01.get_allocator().get_personality() == personality02 );\n+  VERIFY( deq02.get_allocator().get_personality() == personality01 );\n+\n+  my_deque deq03(alloc02);\n+  size01 = deq03.size();\n+  personality01 = deq03.get_allocator().get_personality();\n+  my_deque deq04(title02, title02 + N2, alloc01);\n+  size02 = deq04.size();\n+  personality02 = deq04.get_allocator().get_personality();\n+\n+  deq03.swap(deq04);\n+  VERIFY( deq03.size() == size02 );\n+  VERIFY( equal(deq03.begin(), deq03.end(), title02) );\n+  VERIFY( deq04.size() == size01 );\n+  VERIFY( deq04.empty() );\n+  VERIFY( deq03.get_allocator().get_personality() == personality02 );\n+  VERIFY( deq04.get_allocator().get_personality() == personality01 );\n+  \n+  my_deque deq05(title01, title01 + N1, alloc01);\n+  size01 = deq05.size();\n+  personality01 = deq05.get_allocator().get_personality();\n+  my_deque deq06(title02, title02 + N2, alloc02);\n+  size02 = deq06.size();\n+  personality02 = deq06.get_allocator().get_personality();\n+\n+  deq05.swap(deq06);\n+  VERIFY( deq05.size() == size02 );\n+  VERIFY( equal(deq05.begin(), deq05.end(), title02) );\n+  VERIFY( deq06.size() == size01 );\n+  VERIFY( equal(deq06.begin(), deq06.end(), title01) );\n+  VERIFY( deq05.get_allocator().get_personality() == personality02 );\n+  VERIFY( deq06.get_allocator().get_personality() == personality01 );\n+\n+  my_deque deq07(title01, title01 + N1, alloc02);\n+  size01 = deq07.size();\n+  personality01 = deq07.get_allocator().get_personality();\n+  my_deque deq08(title03, title03 + N3, alloc01);\n+  size02 = deq08.size();\n+  personality02 = deq08.get_allocator().get_personality();\n+\n+  deq07.swap(deq08);\n+  VERIFY( deq07.size() == size02 );\n+  VERIFY( equal(deq07.begin(), deq07.end(), title03) );\n+  VERIFY( deq08.size() == size01 );\n+  VERIFY( equal(deq08.begin(), deq08.end(), title01) );\n+  VERIFY( deq07.get_allocator().get_personality() == personality02 );\n+  VERIFY( deq08.get_allocator().get_personality() == personality01 );\n+\n+  my_deque deq09(title03, title03 + N3, alloc01);\n+  size01 = deq09.size();\n+  personality01 = deq09.get_allocator().get_personality();\n+  my_deque deq10(title04, title04 + N4, alloc02);\n+  size02 = deq10.size();\n+  personality02 = deq10.get_allocator().get_personality();\n+\n+  deq09.swap(deq10);\n+  VERIFY( deq09.size() == size02 );\n+  VERIFY( equal(deq09.begin(), deq09.end(), title04) );\n+  VERIFY( deq10.size() == size01 );\n+  VERIFY( equal(deq10.begin(), deq10.end(), title03) );\n+  VERIFY( deq09.get_allocator().get_personality() == personality02 );\n+  VERIFY( deq10.get_allocator().get_personality() == personality01 );\n+\n+  my_deque deq11(title04, title04 + N4, alloc02);\n+  size01 = deq11.size();\n+  personality01 = deq11.get_allocator().get_personality();\n+  my_deque deq12(title01, title01 + N1, alloc01);\n+  size02 = deq12.size();\n+  personality02 = deq12.get_allocator().get_personality();\n+\n+  deq11.swap(deq12);\n+  VERIFY( deq11.size() == size02 );\n+  VERIFY( equal(deq11.begin(), deq11.end(), title01) );\n+  VERIFY( deq12.size() == size01 );\n+  VERIFY( equal(deq12.begin(), deq12.end(), title04) );\n+  VERIFY( deq11.get_allocator().get_personality() == personality02 );\n+  VERIFY( deq12.get_allocator().get_personality() == personality01 );\n+\n+  my_deque deq13(title03, title03 + N3, alloc01);\n+  size01 = deq13.size();\n+  personality01 = deq13.get_allocator().get_personality();\n+  my_deque deq14(title03, title03 + N3, alloc02);\n+  size02 = deq14.size();\n+  personality02 = deq14.get_allocator().get_personality();\n+\n+  deq13.swap(deq14);\n+  VERIFY( deq13.size() == size02 );\n+  VERIFY( equal(deq13.begin(), deq13.end(), title03) );\n+  VERIFY( deq14.size() == size01 );\n+  VERIFY( equal(deq14.begin(), deq14.end(), title03) );\n+  VERIFY( deq13.get_allocator().get_personality() == personality02 );\n+  VERIFY( deq14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "a277ac5e43fcbf55303ca4fd1ec54eb3b16c69ee", "filename": "libstdc++-v3/testsuite/23_containers/list/modifiers/swap/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Fswap%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Fswap%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Fswap%2F1.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "previous_filename": "libstdc++-v3/testsuite/23_containers/list/modifiers/swap.cc"}, {"sha": "084143c4262092e2c6f6feb7b4507cb8d0b652e5", "filename": "libstdc++-v3/testsuite/23_containers/list/modifiers/swap/2.cc", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Fswap%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Fswap%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Fswap%2F2.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,133 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.2.3 list::swap\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef list<char, my_alloc> my_list;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  my_list::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_list lis01(alloc01);\n+  size01 = lis01.size();\n+  my_list lis02(alloc01);\n+  size02 = lis02.size();\n+  \n+  lis01.swap(lis02);\n+  VERIFY( lis01.size() == size02 );\n+  VERIFY( lis01.empty() );\n+  VERIFY( lis02.size() == size01 );\n+  VERIFY( lis02.empty() );\n+\n+  my_list lis03(alloc01);\n+  size01 = lis03.size();\n+  my_list lis04(title02, title02 + N2, alloc01);\n+  size02 = lis04.size();\n+  \n+  lis03.swap(lis04);\n+  VERIFY( lis03.size() == size02 );\n+  VERIFY( equal(lis03.begin(), lis03.end(), title02) );\n+  VERIFY( lis04.size() == size01 );\n+  VERIFY( lis04.empty() );\n+  \n+  my_list lis05(title01, title01 + N1, alloc01);\n+  size01 = lis05.size();\n+  my_list lis06(title02, title02 + N2, alloc01);\n+  size02 = lis06.size();\n+  \n+  lis05.swap(lis06);\n+  VERIFY( lis05.size() == size02 );\n+  VERIFY( equal(lis05.begin(), lis05.end(), title02) );\n+  VERIFY( lis06.size() == size01 );\n+  VERIFY( equal(lis06.begin(), lis06.end(), title01) );\n+\n+  my_list lis07(title01, title01 + N1, alloc01);\n+  size01 = lis07.size();\n+  my_list lis08(title03, title03 + N3, alloc01);\n+  size02 = lis08.size();\n+\n+  lis07.swap(lis08);\n+  VERIFY( lis07.size() == size02 );\n+  VERIFY( equal(lis07.begin(), lis07.end(), title03) );\n+  VERIFY( lis08.size() == size01 );\n+  VERIFY( equal(lis08.begin(), lis08.end(), title01) );\n+\n+  my_list lis09(title03, title03 + N3, alloc01);\n+  size01 = lis09.size();\n+  my_list lis10(title04, title04 + N4, alloc01);\n+  size02 = lis10.size();\n+\n+  lis09.swap(lis10);\n+  VERIFY( lis09.size() == size02 );\n+  VERIFY( equal(lis09.begin(), lis09.end(), title04) );\n+  VERIFY( lis10.size() == size01 );\n+  VERIFY( equal(lis10.begin(), lis10.end(), title03) );\n+\n+  my_list lis11(title04, title04 + N4, alloc01);\n+  size01 = lis11.size();\n+  my_list lis12(title01, title01 + N1, alloc01);\n+  size02 = lis12.size();\n+\n+  lis11.swap(lis12);\n+  VERIFY( lis11.size() == size02 );\n+  VERIFY( equal(lis11.begin(), lis11.end(), title01) );\n+  VERIFY( lis12.size() == size01 );\n+  VERIFY( equal(lis12.begin(), lis12.end(), title04) );\n+\n+  my_list lis13(title03, title03 + N3, alloc01);\n+  size01 = lis13.size();\n+  my_list lis14(title03, title03 + N3, alloc01);\n+  size02 = lis14.size();\n+\n+  lis13.swap(lis14);\n+  VERIFY( lis13.size() == size02 );\n+  VERIFY( equal(lis13.begin(), lis13.end(), title03) );\n+  VERIFY( lis14.size() == size01 );\n+  VERIFY( equal(lis14.begin(), lis14.end(), title03) );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "714e0ccea3fc01f02aa327d5cd2ddd39e3ab20a5", "filename": "libstdc++-v3/testsuite/23_containers/list/modifiers/swap/3.cc", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Fswap%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Fswap%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Fmodifiers%2Fswap%2F3.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,162 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.2.3 list::swap\n+\n+#include <list>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef list<char, my_alloc> my_list;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  my_list::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_list lis01(alloc01);\n+  size01 = lis01.size();\n+  personality01 = lis01.get_allocator().get_personality();\n+  my_list lis02(alloc02);\n+  size02 = lis02.size();\n+  personality02 = lis02.get_allocator().get_personality();\n+\n+  lis01.swap(lis02);\n+  VERIFY( lis01.size() == size02 );\n+  VERIFY( lis01.empty() );\n+  VERIFY( lis02.size() == size01 );\n+  VERIFY( lis02.empty() );\n+  VERIFY( lis01.get_allocator().get_personality() == personality02 );\n+  VERIFY( lis02.get_allocator().get_personality() == personality01 );\n+\n+  my_list lis03(alloc02);\n+  size01 = lis03.size();\n+  personality01 = lis03.get_allocator().get_personality();\n+  my_list lis04(title02, title02 + N2, alloc01);\n+  size02 = lis04.size();\n+  personality02 = lis04.get_allocator().get_personality();\n+\n+  lis03.swap(lis04);\n+  VERIFY( lis03.size() == size02 );\n+  VERIFY( equal(lis03.begin(), lis03.end(), title02) );\n+  VERIFY( lis04.size() == size01 );\n+  VERIFY( lis04.empty() );\n+  VERIFY( lis03.get_allocator().get_personality() == personality02 );\n+  VERIFY( lis04.get_allocator().get_personality() == personality01 );\n+  \n+  my_list lis05(title01, title01 + N1, alloc01);\n+  size01 = lis05.size();\n+  personality01 = lis05.get_allocator().get_personality();\n+  my_list lis06(title02, title02 + N2, alloc02);\n+  size02 = lis06.size();\n+  personality02 = lis06.get_allocator().get_personality();\n+\n+  lis05.swap(lis06);\n+  VERIFY( lis05.size() == size02 );\n+  VERIFY( equal(lis05.begin(), lis05.end(), title02) );\n+  VERIFY( lis06.size() == size01 );\n+  VERIFY( equal(lis06.begin(), lis06.end(), title01) );\n+  VERIFY( lis05.get_allocator().get_personality() == personality02 );\n+  VERIFY( lis06.get_allocator().get_personality() == personality01 );\n+\n+  my_list lis07(title01, title01 + N1, alloc02);\n+  size01 = lis07.size();\n+  personality01 = lis07.get_allocator().get_personality();\n+  my_list lis08(title03, title03 + N3, alloc01);\n+  size02 = lis08.size();\n+  personality02 = lis08.get_allocator().get_personality();\n+\n+  lis07.swap(lis08);\n+  VERIFY( lis07.size() == size02 );\n+  VERIFY( equal(lis07.begin(), lis07.end(), title03) );\n+  VERIFY( lis08.size() == size01 );\n+  VERIFY( equal(lis08.begin(), lis08.end(), title01) );\n+  VERIFY( lis07.get_allocator().get_personality() == personality02 );\n+  VERIFY( lis08.get_allocator().get_personality() == personality01 );\n+\n+  my_list lis09(title03, title03 + N3, alloc01);\n+  size01 = lis09.size();\n+  personality01 = lis09.get_allocator().get_personality();\n+  my_list lis10(title04, title04 + N4, alloc02);\n+  size02 = lis10.size();\n+  personality02 = lis10.get_allocator().get_personality();\n+\n+  lis09.swap(lis10);\n+  VERIFY( lis09.size() == size02 );\n+  VERIFY( equal(lis09.begin(), lis09.end(), title04) );\n+  VERIFY( lis10.size() == size01 );\n+  VERIFY( equal(lis10.begin(), lis10.end(), title03) );\n+  VERIFY( lis09.get_allocator().get_personality() == personality02 );\n+  VERIFY( lis10.get_allocator().get_personality() == personality01 );\n+\n+  my_list lis11(title04, title04 + N4, alloc02);\n+  size01 = lis11.size();\n+  personality01 = lis11.get_allocator().get_personality();\n+  my_list lis12(title01, title01 + N1, alloc01);\n+  size02 = lis12.size();\n+  personality02 = lis12.get_allocator().get_personality();\n+\n+  lis11.swap(lis12);\n+  VERIFY( lis11.size() == size02 );\n+  VERIFY( equal(lis11.begin(), lis11.end(), title01) );\n+  VERIFY( lis12.size() == size01 );\n+  VERIFY( equal(lis12.begin(), lis12.end(), title04) );\n+  VERIFY( lis11.get_allocator().get_personality() == personality02 );\n+  VERIFY( lis12.get_allocator().get_personality() == personality01 );\n+\n+  my_list lis13(title03, title03 + N3, alloc01);\n+  size01 = lis13.size();\n+  personality01 = lis13.get_allocator().get_personality();\n+  my_list lis14(title03, title03 + N3, alloc02);\n+  size02 = lis14.size();\n+  personality02 = lis14.get_allocator().get_personality();\n+\n+  lis13.swap(lis14);\n+  VERIFY( lis13.size() == size02 );\n+  VERIFY( equal(lis13.begin(), lis13.end(), title03) );\n+  VERIFY( lis14.size() == size01 );\n+  VERIFY( equal(lis14.begin(), lis14.end(), title03) );\n+  VERIFY( lis13.get_allocator().get_personality() == personality02 );\n+  VERIFY( lis14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "85aa95cf11d75c891bfc57f310b774bf84617ee0", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/swap/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fswap%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fswap%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fswap%2F1.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "previous_filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/swap.cc"}, {"sha": "5b1a17b8900e88b9ebfc5f075d7a559ff99cc042", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/swap/2.cc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fswap%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fswap%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fswap%2F2.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,147 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.3.1 map::swap\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef pair<const char, int> my_pair;\n+  typedef __gnu_test::uneq_allocator<my_pair> my_alloc;\n+  typedef map<char, int, less<char>, my_alloc> my_map;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  map<char, int> map01_ref;\n+  for (size_t i = 0; i < N1; ++i)\n+    map01_ref.insert(my_pair(title01[i], i));\n+  map<char, int> map02_ref;\n+  for (size_t i = 0; i < N2; ++i)\n+    map02_ref.insert(my_pair(title02[i], i));\n+  map<char, int> map03_ref;\n+  for (size_t i = 0; i < N3; ++i)\n+    map03_ref.insert(my_pair(title03[i], i));\n+  map<char, int> map04_ref;\n+  for (size_t i = 0; i < N4; ++i)\n+    map04_ref.insert(my_pair(title04[i], i));\n+\n+  my_map::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_map map01(less<char>(), alloc01);\n+  size01 = map01.size();\n+  my_map map02(less<char>(), alloc01);\n+  size02 = map02.size();\n+  \n+  map01.swap(map02);\n+  VERIFY( map01.size() == size02 );\n+  VERIFY( map01.empty() );\n+  VERIFY( map02.size() == size01 );\n+  VERIFY( map02.empty() );\n+\n+  my_map map03(less<char>(), alloc01);\n+  size01 = map03.size();\n+  my_map map04(map02_ref.begin(), map02_ref.end(), less<char>(), alloc01);\n+  size02 = map04.size();\n+\n+  map03.swap(map04);\n+  VERIFY( map03.size() == size02 );\n+  VERIFY( equal(map03.begin(), map03.end(), map02_ref.begin()) );\n+  VERIFY( map04.size() == size01 );\n+  VERIFY( map04.empty() );\n+  \n+  my_map map05(map01_ref.begin(), map01_ref.end(), less<char>(), alloc01);\n+  size01 = map05.size();\n+  my_map map06(map02_ref.begin(), map02_ref.end(), less<char>(), alloc01);\n+  size02 = map06.size();\n+\n+  map05.swap(map06);\n+  VERIFY( map05.size() == size02 );\n+  VERIFY( equal(map05.begin(), map05.end(), map02_ref.begin()) );\n+  VERIFY( map06.size() == size01 );\n+  VERIFY( equal(map06.begin(), map06.end(), map01_ref.begin()) );\n+\n+  my_map map07(map01_ref.begin(), map01_ref.end(), less<char>(), alloc01);\n+  size01 = map07.size();\n+  my_map map08(map03_ref.begin(), map03_ref.end(), less<char>(), alloc01);\n+  size02 = map08.size();\n+\n+  map07.swap(map08);\n+  VERIFY( map07.size() == size02 );\n+  VERIFY( equal(map07.begin(), map07.end(), map03_ref.begin()) );\n+  VERIFY( map08.size() == size01 );\n+  VERIFY( equal(map08.begin(), map08.end(), map01_ref.begin()) );\n+\n+  my_map map09(map03_ref.begin(), map03_ref.end(), less<char>(), alloc01);\n+  size01 = map09.size();\n+  my_map map10(map04_ref.begin(), map04_ref.end(), less<char>(), alloc01);\n+  size02 = map10.size();\n+\n+  map09.swap(map10);\n+  VERIFY( map09.size() == size02 );\n+  VERIFY( equal(map09.begin(), map09.end(), map04_ref.begin()) );\n+  VERIFY( map10.size() == size01 );\n+  VERIFY( equal(map10.begin(), map10.end(), map03_ref.begin()) );\n+\n+  my_map map11(map04_ref.begin(), map04_ref.end(), less<char>(), alloc01);\n+  size01 = map11.size();\n+  my_map map12(map01_ref.begin(), map01_ref.end(), less<char>(), alloc01);\n+  size02 = map12.size();\n+\n+  map11.swap(map12);\n+  VERIFY( map11.size() == size02 );\n+  VERIFY( equal(map11.begin(), map11.end(), map01_ref.begin()) );\n+  VERIFY( map12.size() == size01 );\n+  VERIFY( equal(map12.begin(), map12.end(), map04_ref.begin()) );\n+\n+  my_map map13(map03_ref.begin(), map03_ref.end(), less<char>(), alloc01);\n+  size01 = map13.size();\n+  my_map map14(map03_ref.begin(), map03_ref.end(), less<char>(), alloc01);\n+  size02 = map14.size();\n+\n+  map13.swap(map14);\n+  VERIFY( map13.size() == size02 );\n+  VERIFY( equal(map13.begin(), map13.end(), map03_ref.begin()) );\n+  VERIFY( map14.size() == size01 );\n+  VERIFY( equal(map14.begin(), map14.end(), map03_ref.begin()) );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "2152b4b001d514b6fe089163f78972273d2c32c6", "filename": "libstdc++-v3/testsuite/23_containers/map/modifiers/swap/3.cc", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fswap%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fswap%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Fmodifiers%2Fswap%2F3.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,176 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.3.1 map::swap\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef pair<const char, int> my_pair;\n+  typedef __gnu_test::uneq_allocator<my_pair> my_alloc;\n+  typedef map<char, int, less<char>, my_alloc> my_map;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  map<char, int> map01_ref;\n+  for (size_t i = 0; i < N1; ++i)\n+    map01_ref.insert(my_pair(title01[i], i));\n+  map<char, int> map02_ref;\n+  for (size_t i = 0; i < N2; ++i)\n+    map02_ref.insert(my_pair(title02[i], i));\n+  map<char, int> map03_ref;\n+  for (size_t i = 0; i < N3; ++i)\n+    map03_ref.insert(my_pair(title03[i], i));\n+  map<char, int> map04_ref;\n+  for (size_t i = 0; i < N4; ++i)\n+    map04_ref.insert(my_pair(title04[i], i));\n+\n+  my_map::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_map map01(less<char>(), alloc01);\n+  size01 = map01.size();\n+  personality01 = map01.get_allocator().get_personality();\n+  my_map map02(less<char>(), alloc02);\n+  size02 = map02.size();\n+  personality02 = map02.get_allocator().get_personality();\n+\n+  map01.swap(map02);\n+  VERIFY( map01.size() == size02 );\n+  VERIFY( map01.empty() );\n+  VERIFY( map02.size() == size01 );\n+  VERIFY( map02.empty() );\n+  VERIFY( map01.get_allocator().get_personality() == personality02 );\n+  VERIFY( map02.get_allocator().get_personality() == personality01 );\n+\n+  my_map map03(less<char>(), alloc02);\n+  size01 = map03.size();\n+  personality01 = map03.get_allocator().get_personality();\n+  my_map map04(map02_ref.begin(), map02_ref.end(), less<char>(), alloc01);\n+  size02 = map04.size();\n+  personality02 = map04.get_allocator().get_personality();\n+\n+  map03.swap(map04);\n+  VERIFY( map03.size() == size02 );\n+  VERIFY( equal(map03.begin(), map03.end(), map02_ref.begin()) );\n+  VERIFY( map04.size() == size01 );\n+  VERIFY( map04.empty() );\n+  VERIFY( map03.get_allocator().get_personality() == personality02 );\n+  VERIFY( map04.get_allocator().get_personality() == personality01 );\n+  \n+  my_map map05(map01_ref.begin(), map01_ref.end(), less<char>(), alloc01);\n+  size01 = map05.size();\n+  personality01 = map05.get_allocator().get_personality();\n+  my_map map06(map02_ref.begin(), map02_ref.end(), less<char>(), alloc02);\n+  size02 = map06.size();\n+  personality02 = map06.get_allocator().get_personality();\n+\n+  map05.swap(map06);\n+  VERIFY( map05.size() == size02 );\n+  VERIFY( equal(map05.begin(), map05.end(), map02_ref.begin()) );\n+  VERIFY( map06.size() == size01 );\n+  VERIFY( equal(map06.begin(), map06.end(), map01_ref.begin()) );\n+  VERIFY( map05.get_allocator().get_personality() == personality02 );\n+  VERIFY( map06.get_allocator().get_personality() == personality01 );\n+\n+  my_map map07(map01_ref.begin(), map01_ref.end(), less<char>(), alloc02);\n+  size01 = map07.size();\n+  personality01 = map07.get_allocator().get_personality();\n+  my_map map08(map03_ref.begin(), map03_ref.end(), less<char>(), alloc01);\n+  size02 = map08.size();\n+  personality02 = map08.get_allocator().get_personality();\n+\n+  map07.swap(map08);\n+  VERIFY( map07.size() == size02 );\n+  VERIFY( equal(map07.begin(), map07.end(), map03_ref.begin()) );\n+  VERIFY( map08.size() == size01 );\n+  VERIFY( equal(map08.begin(), map08.end(), map01_ref.begin()) );\n+  VERIFY( map07.get_allocator().get_personality() == personality02 );\n+  VERIFY( map08.get_allocator().get_personality() == personality01 );\n+\n+  my_map map09(map03_ref.begin(), map03_ref.end(), less<char>(), alloc01);\n+  size01 = map09.size();\n+  personality01 = map09.get_allocator().get_personality();\n+  my_map map10(map04_ref.begin(), map04_ref.end(), less<char>(), alloc02);\n+  size02 = map10.size();\n+  personality02 = map10.get_allocator().get_personality();\n+\n+  map09.swap(map10);\n+  VERIFY( map09.size() == size02 );\n+  VERIFY( equal(map09.begin(), map09.end(), map04_ref.begin()) );\n+  VERIFY( map10.size() == size01 );\n+  VERIFY( equal(map10.begin(), map10.end(), map03_ref.begin()) );\n+  VERIFY( map09.get_allocator().get_personality() == personality02 );\n+  VERIFY( map10.get_allocator().get_personality() == personality01 );\n+\n+  my_map map11(map04_ref.begin(), map04_ref.end(), less<char>(), alloc02);\n+  size01 = map11.size();\n+  personality01 = map11.get_allocator().get_personality();\n+  my_map map12(map01_ref.begin(), map01_ref.end(), less<char>(), alloc01);\n+  size02 = map12.size();\n+  personality02 = map12.get_allocator().get_personality();\n+\n+  map11.swap(map12);\n+  VERIFY( map11.size() == size02 );\n+  VERIFY( equal(map11.begin(), map11.end(), map01_ref.begin()) );\n+  VERIFY( map12.size() == size01 );\n+  VERIFY( equal(map12.begin(), map12.end(), map04_ref.begin()) );\n+  VERIFY( map11.get_allocator().get_personality() == personality02 );\n+  VERIFY( map12.get_allocator().get_personality() == personality01 );\n+\n+  my_map map13(map03_ref.begin(), map03_ref.end(), less<char>(), alloc01);\n+  size01 = map13.size();\n+  personality01 = map13.get_allocator().get_personality();\n+  my_map map14(map03_ref.begin(), map03_ref.end(), less<char>(), alloc02);\n+  size02 = map14.size();\n+  personality02 = map14.get_allocator().get_personality();\n+\n+  map13.swap(map14);\n+  VERIFY( map13.size() == size02 );\n+  VERIFY( equal(map13.begin(), map13.end(), map03_ref.begin()) );\n+  VERIFY( map14.size() == size01 );\n+  VERIFY( equal(map14.begin(), map14.end(), map03_ref.begin()) );\n+  VERIFY( map13.get_allocator().get_personality() == personality02 );\n+  VERIFY( map14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "76cbe465cc31cabd57faabad9bf874999131c372", "filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/swap/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fswap%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fswap%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fswap%2F1.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "previous_filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/swap.cc"}, {"sha": "dc2c9c9080d920ae05ade6be8dbcfc9dfe76fcd9", "filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/swap/2.cc", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fswap%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fswap%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fswap%2F2.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,147 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.3.2 multimap::swap\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef pair<const char, int> my_pair;\n+  typedef __gnu_test::uneq_allocator<my_pair> my_alloc;\n+  typedef multimap<char, int, less<char>, my_alloc> my_mmap;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  multimap<char, int> mmap01_ref;\n+  for (size_t i = 0; i < N1; ++i)\n+    mmap01_ref.insert(my_pair(title01[i], i));\n+  multimap<char, int> mmap02_ref;\n+  for (size_t i = 0; i < N2; ++i)\n+    mmap02_ref.insert(my_pair(title02[i], i));\n+  multimap<char, int> mmap03_ref;\n+  for (size_t i = 0; i < N3; ++i)\n+    mmap03_ref.insert(my_pair(title03[i], i));\n+  multimap<char, int> mmap04_ref;\n+  for (size_t i = 0; i < N4; ++i)\n+    mmap04_ref.insert(my_pair(title04[i], i));\n+\n+  my_mmap::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_mmap mmap01(less<char>(), alloc01);\n+  size01 = mmap01.size();\n+  my_mmap mmap02(less<char>(), alloc01);\n+  size02 = mmap02.size();\n+  \n+  mmap01.swap(mmap02);\n+  VERIFY( mmap01.size() == size02 );\n+  VERIFY( mmap01.empty() );\n+  VERIFY( mmap02.size() == size01 );\n+  VERIFY( mmap02.empty() );\n+\n+  my_mmap mmap03(less<char>(), alloc01);\n+  size01 = mmap03.size();\n+  my_mmap mmap04(mmap02_ref.begin(), mmap02_ref.end(), less<char>(), alloc01);\n+  size02 = mmap04.size();\n+\n+  mmap03.swap(mmap04);\n+  VERIFY( mmap03.size() == size02 );\n+  VERIFY( equal(mmap03.begin(), mmap03.end(), mmap02_ref.begin()) );\n+  VERIFY( mmap04.size() == size01 );\n+  VERIFY( mmap04.empty() );\n+  \n+  my_mmap mmap05(mmap01_ref.begin(), mmap01_ref.end(), less<char>(), alloc01);\n+  size01 = mmap05.size();\n+  my_mmap mmap06(mmap02_ref.begin(), mmap02_ref.end(), less<char>(), alloc01);\n+  size02 = mmap06.size();\n+\n+  mmap05.swap(mmap06);\n+  VERIFY( mmap05.size() == size02 );\n+  VERIFY( equal(mmap05.begin(), mmap05.end(), mmap02_ref.begin()) );\n+  VERIFY( mmap06.size() == size01 );\n+  VERIFY( equal(mmap06.begin(), mmap06.end(), mmap01_ref.begin()) );\n+\n+  my_mmap mmap07(mmap01_ref.begin(), mmap01_ref.end(), less<char>(), alloc01);\n+  size01 = mmap07.size();\n+  my_mmap mmap08(mmap03_ref.begin(), mmap03_ref.end(), less<char>(), alloc01);\n+  size02 = mmap08.size();\n+\n+  mmap07.swap(mmap08);\n+  VERIFY( mmap07.size() == size02 );\n+  VERIFY( equal(mmap07.begin(), mmap07.end(), mmap03_ref.begin()) );\n+  VERIFY( mmap08.size() == size01 );\n+  VERIFY( equal(mmap08.begin(), mmap08.end(), mmap01_ref.begin()) );\n+\n+  my_mmap mmap09(mmap03_ref.begin(), mmap03_ref.end(), less<char>(), alloc01);\n+  size01 = mmap09.size();\n+  my_mmap mmap10(mmap04_ref.begin(), mmap04_ref.end(), less<char>(), alloc01);\n+  size02 = mmap10.size();\n+\n+  mmap09.swap(mmap10);\n+  VERIFY( mmap09.size() == size02 );\n+  VERIFY( equal(mmap09.begin(), mmap09.end(), mmap04_ref.begin()) );\n+  VERIFY( mmap10.size() == size01 );\n+  VERIFY( equal(mmap10.begin(), mmap10.end(), mmap03_ref.begin()) );\n+\n+  my_mmap mmap11(mmap04_ref.begin(), mmap04_ref.end(), less<char>(), alloc01);\n+  size01 = mmap11.size();\n+  my_mmap mmap12(mmap01_ref.begin(), mmap01_ref.end(), less<char>(), alloc01);\n+  size02 = mmap12.size();\n+\n+  mmap11.swap(mmap12);\n+  VERIFY( mmap11.size() == size02 );\n+  VERIFY( equal(mmap11.begin(), mmap11.end(), mmap01_ref.begin()) );\n+  VERIFY( mmap12.size() == size01 );\n+  VERIFY( equal(mmap12.begin(), mmap12.end(), mmap04_ref.begin()) );\n+\n+  my_mmap mmap13(mmap03_ref.begin(), mmap03_ref.end(), less<char>(), alloc01);\n+  size01 = mmap13.size();\n+  my_mmap mmap14(mmap03_ref.begin(), mmap03_ref.end(), less<char>(), alloc01);\n+  size02 = mmap14.size();\n+\n+  mmap13.swap(mmap14);\n+  VERIFY( mmap13.size() == size02 );\n+  VERIFY( equal(mmap13.begin(), mmap13.end(), mmap03_ref.begin()) );\n+  VERIFY( mmap14.size() == size01 );\n+  VERIFY( equal(mmap14.begin(), mmap14.end(), mmap03_ref.begin()) );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "9214490f2b91f46cb33117b12093b988d6ad8781", "filename": "libstdc++-v3/testsuite/23_containers/multimap/modifiers/swap/3.cc", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fswap%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fswap%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Fmodifiers%2Fswap%2F3.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,176 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.3.2 multimap::swap\n+\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef pair<const char, int> my_pair;\n+  typedef __gnu_test::uneq_allocator<my_pair> my_alloc;\n+  typedef multimap<char, int, less<char>, my_alloc> my_mmap;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  multimap<char, int> mmap01_ref;\n+  for (size_t i = 0; i < N1; ++i)\n+    mmap01_ref.insert(my_pair(title01[i], i));\n+  multimap<char, int> mmap02_ref;\n+  for (size_t i = 0; i < N2; ++i)\n+    mmap02_ref.insert(my_pair(title02[i], i));\n+  multimap<char, int> mmap03_ref;\n+  for (size_t i = 0; i < N3; ++i)\n+    mmap03_ref.insert(my_pair(title03[i], i));\n+  multimap<char, int> mmap04_ref;\n+  for (size_t i = 0; i < N4; ++i)\n+    mmap04_ref.insert(my_pair(title04[i], i));\n+\n+  my_mmap::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_mmap mmap01(less<char>(), alloc01);\n+  size01 = mmap01.size();\n+  personality01 = mmap01.get_allocator().get_personality();\n+  my_mmap mmap02(less<char>(), alloc02);\n+  size02 = mmap02.size();\n+  personality02 = mmap02.get_allocator().get_personality();\n+\n+  mmap01.swap(mmap02);\n+  VERIFY( mmap01.size() == size02 );\n+  VERIFY( mmap01.empty() );\n+  VERIFY( mmap02.size() == size01 );\n+  VERIFY( mmap02.empty() );\n+  VERIFY( mmap01.get_allocator().get_personality() == personality02 );\n+  VERIFY( mmap02.get_allocator().get_personality() == personality01 );\n+\n+  my_mmap mmap03(less<char>(), alloc02);\n+  size01 = mmap03.size();\n+  personality01 = mmap03.get_allocator().get_personality();\n+  my_mmap mmap04(mmap02_ref.begin(), mmap02_ref.end(), less<char>(), alloc01);\n+  size02 = mmap04.size();\n+  personality02 = mmap04.get_allocator().get_personality();\n+\n+  mmap03.swap(mmap04);\n+  VERIFY( mmap03.size() == size02 );\n+  VERIFY( equal(mmap03.begin(), mmap03.end(), mmap02_ref.begin()) );\n+  VERIFY( mmap04.size() == size01 );\n+  VERIFY( mmap04.empty() );\n+  VERIFY( mmap03.get_allocator().get_personality() == personality02 );\n+  VERIFY( mmap04.get_allocator().get_personality() == personality01 );\n+  \n+  my_mmap mmap05(mmap01_ref.begin(), mmap01_ref.end(), less<char>(), alloc01);\n+  size01 = mmap05.size();\n+  personality01 = mmap05.get_allocator().get_personality();\n+  my_mmap mmap06(mmap02_ref.begin(), mmap02_ref.end(), less<char>(), alloc02);\n+  size02 = mmap06.size();\n+  personality02 = mmap06.get_allocator().get_personality();\n+\n+  mmap05.swap(mmap06);\n+  VERIFY( mmap05.size() == size02 );\n+  VERIFY( equal(mmap05.begin(), mmap05.end(), mmap02_ref.begin()) );\n+  VERIFY( mmap06.size() == size01 );\n+  VERIFY( equal(mmap06.begin(), mmap06.end(), mmap01_ref.begin()) );\n+  VERIFY( mmap05.get_allocator().get_personality() == personality02 );\n+  VERIFY( mmap06.get_allocator().get_personality() == personality01 );\n+\n+  my_mmap mmap07(mmap01_ref.begin(), mmap01_ref.end(), less<char>(), alloc02);\n+  size01 = mmap07.size();\n+  personality01 = mmap07.get_allocator().get_personality();\n+  my_mmap mmap08(mmap03_ref.begin(), mmap03_ref.end(), less<char>(), alloc01);\n+  size02 = mmap08.size();\n+  personality02 = mmap08.get_allocator().get_personality();\n+\n+  mmap07.swap(mmap08);\n+  VERIFY( mmap07.size() == size02 );\n+  VERIFY( equal(mmap07.begin(), mmap07.end(), mmap03_ref.begin()) );\n+  VERIFY( mmap08.size() == size01 );\n+  VERIFY( equal(mmap08.begin(), mmap08.end(), mmap01_ref.begin()) );\n+  VERIFY( mmap07.get_allocator().get_personality() == personality02 );\n+  VERIFY( mmap08.get_allocator().get_personality() == personality01 );\n+\n+  my_mmap mmap09(mmap03_ref.begin(), mmap03_ref.end(), less<char>(), alloc01);\n+  size01 = mmap09.size();\n+  personality01 = mmap09.get_allocator().get_personality();\n+  my_mmap mmap10(mmap04_ref.begin(), mmap04_ref.end(), less<char>(), alloc02);\n+  size02 = mmap10.size();\n+  personality02 = mmap10.get_allocator().get_personality();\n+\n+  mmap09.swap(mmap10);\n+  VERIFY( mmap09.size() == size02 );\n+  VERIFY( equal(mmap09.begin(), mmap09.end(), mmap04_ref.begin()) );\n+  VERIFY( mmap10.size() == size01 );\n+  VERIFY( equal(mmap10.begin(), mmap10.end(), mmap03_ref.begin()) );\n+  VERIFY( mmap09.get_allocator().get_personality() == personality02 );\n+  VERIFY( mmap10.get_allocator().get_personality() == personality01 );\n+\n+  my_mmap mmap11(mmap04_ref.begin(), mmap04_ref.end(), less<char>(), alloc02);\n+  size01 = mmap11.size();\n+  personality01 = mmap11.get_allocator().get_personality();\n+  my_mmap mmap12(mmap01_ref.begin(), mmap01_ref.end(), less<char>(), alloc01);\n+  size02 = mmap12.size();\n+  personality02 = mmap12.get_allocator().get_personality();\n+\n+  mmap11.swap(mmap12);\n+  VERIFY( mmap11.size() == size02 );\n+  VERIFY( equal(mmap11.begin(), mmap11.end(), mmap01_ref.begin()) );\n+  VERIFY( mmap12.size() == size01 );\n+  VERIFY( equal(mmap12.begin(), mmap12.end(), mmap04_ref.begin()) );\n+  VERIFY( mmap11.get_allocator().get_personality() == personality02 );\n+  VERIFY( mmap12.get_allocator().get_personality() == personality01 );\n+\n+  my_mmap mmap13(mmap03_ref.begin(), mmap03_ref.end(), less<char>(), alloc01);\n+  size01 = mmap13.size();\n+  personality01 = mmap13.get_allocator().get_personality();\n+  my_mmap mmap14(mmap03_ref.begin(), mmap03_ref.end(), less<char>(), alloc02);\n+  size02 = mmap14.size();\n+  personality02 = mmap14.get_allocator().get_personality();\n+\n+  mmap13.swap(mmap14);\n+  VERIFY( mmap13.size() == size02 );\n+  VERIFY( equal(mmap13.begin(), mmap13.end(), mmap03_ref.begin()) );\n+  VERIFY( mmap14.size() == size01 );\n+  VERIFY( equal(mmap14.begin(), mmap14.end(), mmap03_ref.begin()) );\n+  VERIFY( mmap13.get_allocator().get_personality() == personality02 );\n+  VERIFY( mmap14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "23851990016788d87ca3e96bdebbca412d78beed", "filename": "libstdc++-v3/testsuite/23_containers/multiset/modifiers/swap/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fswap%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fswap%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fswap%2F1.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "previous_filename": "libstdc++-v3/testsuite/23_containers/multiset/modifiers/swap.cc"}, {"sha": "587dc9c4b9e74511b37816b3fffca3868be8f0cf", "filename": "libstdc++-v3/testsuite/23_containers/multiset/modifiers/swap/2.cc", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fswap%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fswap%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fswap%2F2.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,138 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.3.4 multiset::swap\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef multiset<char, less<char>, my_alloc> my_multiset;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  const multiset<char> mset01_ref(title01, title01 + N1);\n+  const multiset<char> mset02_ref(title02, title02 + N2);\n+  const multiset<char> mset03_ref(title03, title03 + N3);\n+  const multiset<char> mset04_ref(title04, title04 + N4);\n+\n+  my_multiset::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_multiset mset01(less<char>(), alloc01);\n+  size01 = mset01.size();\n+  my_multiset mset02(less<char>(), alloc01);\n+  size02 = mset02.size();\n+  \n+  mset01.swap(mset02);\n+  VERIFY( mset01.size() == size02 );\n+  VERIFY( mset01.empty() );\n+  VERIFY( mset02.size() == size01 );\n+  VERIFY( mset02.empty() );\n+\n+  my_multiset mset03(less<char>(), alloc01);\n+  size01 = mset03.size();\n+  my_multiset mset04(title02, title02 + N2, less<char>(), alloc01);\n+  size02 = mset04.size();\n+  \n+  mset03.swap(mset04);\n+  VERIFY( mset03.size() == size02 );\n+  VERIFY( equal(mset03.begin(), mset03.end(), mset02_ref.begin()) );\n+  VERIFY( mset04.size() == size01 );\n+  VERIFY( mset04.empty() );\n+  \n+  my_multiset mset05(title01, title01 + N1, less<char>(), alloc01);\n+  size01 = mset05.size();\n+  my_multiset mset06(title02, title02 + N2, less<char>(), alloc01);\n+  size02 = mset06.size();\n+  \n+  mset05.swap(mset06);\n+  VERIFY( mset05.size() == size02 );\n+  VERIFY( equal(mset05.begin(), mset05.end(), mset02_ref.begin()) );\n+  VERIFY( mset06.size() == size01 );\n+  VERIFY( equal(mset06.begin(), mset06.end(), mset01_ref.begin()) );\n+\n+  my_multiset mset07(title01, title01 + N1, less<char>(), alloc01);\n+  size01 = mset07.size();\n+  my_multiset mset08(title03, title03 + N3, less<char>(), alloc01);\n+  size02 = mset08.size();\n+\n+  mset07.swap(mset08);\n+  VERIFY( mset07.size() == size02 );\n+  VERIFY( equal(mset07.begin(), mset07.end(), mset03_ref.begin()) );\n+  VERIFY( mset08.size() == size01 );\n+  VERIFY( equal(mset08.begin(), mset08.end(), mset01_ref.begin()) );\n+\n+  my_multiset mset09(title03, title03 + N3, less<char>(), alloc01);\n+  size01 = mset09.size();\n+  my_multiset mset10(title04, title04 + N4, less<char>(), alloc01);\n+  size02 = mset10.size();\n+\n+  mset09.swap(mset10);\n+  VERIFY( mset09.size() == size02 );\n+  VERIFY( equal(mset09.begin(), mset09.end(), mset04_ref.begin()) );\n+  VERIFY( mset10.size() == size01 );\n+  VERIFY( equal(mset10.begin(), mset10.end(), mset03_ref.begin()) );\n+\n+  my_multiset mset11(title04, title04 + N4, less<char>(), alloc01);\n+  size01 = mset11.size();\n+  my_multiset mset12(title01, title01 + N1, less<char>(), alloc01);\n+  size02 = mset12.size();\n+\n+  mset11.swap(mset12);\n+  VERIFY( mset11.size() == size02 );\n+  VERIFY( equal(mset11.begin(), mset11.end(), mset01_ref.begin()) );\n+  VERIFY( mset12.size() == size01 );\n+  VERIFY( equal(mset12.begin(), mset12.end(), mset04_ref.begin()) );\n+\n+  my_multiset mset13(title03, title03 + N3, less<char>(), alloc01);\n+  size01 = mset13.size();\n+  my_multiset mset14(title03, title03 + N3, less<char>(), alloc01);\n+  size02 = mset14.size();\n+\n+  mset13.swap(mset14);\n+  VERIFY( mset13.size() == size02 );\n+  VERIFY( equal(mset13.begin(), mset13.end(), mset03_ref.begin()) );\n+  VERIFY( mset14.size() == size01 );\n+  VERIFY( equal(mset14.begin(), mset14.end(), mset03_ref.begin()) );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "e5a05d7b138601a97ce4d3c0e412a71f363fcc64", "filename": "libstdc++-v3/testsuite/23_containers/multiset/modifiers/swap/3.cc", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fswap%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fswap%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Fmodifiers%2Fswap%2F3.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,167 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.3.4 multiset::swap\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef multiset<char, less<char>, my_alloc> my_multiset;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  const multiset<char> mset01_ref(title01, title01 + N1);\n+  const multiset<char> mset02_ref(title02, title02 + N2);\n+  const multiset<char> mset03_ref(title03, title03 + N3);\n+  const multiset<char> mset04_ref(title04, title04 + N4);\n+\n+  my_multiset::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_multiset mset01(less<char>(), alloc01);\n+  size01 = mset01.size();\n+  personality01 = mset01.get_allocator().get_personality();\n+  my_multiset mset02(less<char>(), alloc02);\n+  size02 = mset02.size();\n+  personality02 = mset02.get_allocator().get_personality();\n+\n+  mset01.swap(mset02);\n+  VERIFY( mset01.size() == size02 );\n+  VERIFY( mset01.empty() );\n+  VERIFY( mset02.size() == size01 );\n+  VERIFY( mset02.empty() );\n+  VERIFY( mset01.get_allocator().get_personality() == personality02 );\n+  VERIFY( mset02.get_allocator().get_personality() == personality01 );\n+\n+  my_multiset mset03(less<char>(), alloc02);\n+  size01 = mset03.size();\n+  personality01 = mset03.get_allocator().get_personality();\n+  my_multiset mset04(title02, title02 + N2, less<char>(), alloc01);\n+  size02 = mset04.size();\n+  personality02 = mset04.get_allocator().get_personality();\n+\n+  mset03.swap(mset04);\n+  VERIFY( mset03.size() == size02 );\n+  VERIFY( equal(mset03.begin(), mset03.end(), mset02_ref.begin()) );\n+  VERIFY( mset04.size() == size01 );\n+  VERIFY( mset04.empty() );\n+  VERIFY( mset03.get_allocator().get_personality() == personality02 );\n+  VERIFY( mset04.get_allocator().get_personality() == personality01 );\n+  \n+  my_multiset mset05(title01, title01 + N1, less<char>(), alloc01);\n+  size01 = mset05.size();\n+  personality01 = mset05.get_allocator().get_personality();\n+  my_multiset mset06(title02, title02 + N2, less<char>(), alloc02);\n+  size02 = mset06.size();\n+  personality02 = mset06.get_allocator().get_personality();\n+\n+  mset05.swap(mset06);\n+  VERIFY( mset05.size() == size02 );\n+  VERIFY( equal(mset05.begin(), mset05.end(), mset02_ref.begin()) );\n+  VERIFY( mset06.size() == size01 );\n+  VERIFY( equal(mset06.begin(), mset06.end(), mset01_ref.begin()) );\n+  VERIFY( mset05.get_allocator().get_personality() == personality02 );\n+  VERIFY( mset06.get_allocator().get_personality() == personality01 );\n+\n+  my_multiset mset07(title01, title01 + N1, less<char>(), alloc02);\n+  size01 = mset07.size();\n+  personality01 = mset07.get_allocator().get_personality();\n+  my_multiset mset08(title03, title03 + N3, less<char>(), alloc01);\n+  size02 = mset08.size();\n+  personality02 = mset08.get_allocator().get_personality();\n+\n+  mset07.swap(mset08);\n+  VERIFY( mset07.size() == size02 );\n+  VERIFY( equal(mset07.begin(), mset07.end(), mset03_ref.begin()) );\n+  VERIFY( mset08.size() == size01 );\n+  VERIFY( equal(mset08.begin(), mset08.end(), mset01_ref.begin()) );\n+  VERIFY( mset07.get_allocator().get_personality() == personality02 );\n+  VERIFY( mset08.get_allocator().get_personality() == personality01 );\n+\n+  my_multiset mset09(title03, title03 + N3, less<char>(), alloc01);\n+  size01 = mset09.size();\n+  personality01 = mset09.get_allocator().get_personality();\n+  my_multiset mset10(title04, title04 + N4, less<char>(), alloc02);\n+  size02 = mset10.size();\n+  personality02 = mset10.get_allocator().get_personality();\n+\n+  mset09.swap(mset10);\n+  VERIFY( mset09.size() == size02 );\n+  VERIFY( equal(mset09.begin(), mset09.end(), mset04_ref.begin()) );\n+  VERIFY( mset10.size() == size01 );\n+  VERIFY( equal(mset10.begin(), mset10.end(), mset03_ref.begin()) );\n+  VERIFY( mset09.get_allocator().get_personality() == personality02 );\n+  VERIFY( mset10.get_allocator().get_personality() == personality01 );\n+\n+  my_multiset mset11(title04, title04 + N4, less<char>(), alloc02);\n+  size01 = mset11.size();\n+  personality01 = mset11.get_allocator().get_personality();\n+  my_multiset mset12(title01, title01 + N1, less<char>(), alloc01);\n+  size02 = mset12.size();\n+  personality02 = mset12.get_allocator().get_personality();\n+\n+  mset11.swap(mset12);\n+  VERIFY( mset11.size() == size02 );\n+  VERIFY( equal(mset11.begin(), mset11.end(), mset01_ref.begin()) );\n+  VERIFY( mset12.size() == size01 );\n+  VERIFY( equal(mset12.begin(), mset12.end(), mset04_ref.begin()) );\n+  VERIFY( mset11.get_allocator().get_personality() == personality02 );\n+  VERIFY( mset12.get_allocator().get_personality() == personality01 );\n+\n+  my_multiset mset13(title03, title03 + N3, less<char>(), alloc01);\n+  size01 = mset13.size();\n+  personality01 = mset13.get_allocator().get_personality();\n+  my_multiset mset14(title03, title03 + N3, less<char>(), alloc02);\n+  size02 = mset14.size();\n+  personality02 = mset14.get_allocator().get_personality();\n+\n+  mset13.swap(mset14);\n+  VERIFY( mset13.size() == size02 );\n+  VERIFY( equal(mset13.begin(), mset13.end(), mset03_ref.begin()) );\n+  VERIFY( mset14.size() == size01 );\n+  VERIFY( equal(mset14.begin(), mset14.end(), mset03_ref.begin()) );\n+  VERIFY( mset13.get_allocator().get_personality() == personality02 );\n+  VERIFY( mset14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "7efa8a6bf601c5943e902d3bb5fd7fb7e1c56f1b", "filename": "libstdc++-v3/testsuite/23_containers/set/modifiers/swap/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fswap%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fswap%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fswap%2F1.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "previous_filename": "libstdc++-v3/testsuite/23_containers/set/modifiers/swap.cc"}, {"sha": "1849630f8c7b88b33ca53d73de664af603c39b7f", "filename": "libstdc++-v3/testsuite/23_containers/set/modifiers/swap/2.cc", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fswap%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fswap%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fswap%2F2.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,138 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.3.3 set::swap\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef set<char, less<char>, my_alloc> my_set;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  const set<char> set01_ref(title01, title01 + N1);\n+  const set<char> set02_ref(title02, title02 + N2);\n+  const set<char> set03_ref(title03, title03 + N3);\n+  const set<char> set04_ref(title04, title04 + N4);\n+\n+  my_set::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_set set01(less<char>(), alloc01);\n+  size01 = set01.size();\n+  my_set set02(less<char>(), alloc01);\n+  size02 = set02.size();\n+  \n+  set01.swap(set02);\n+  VERIFY( set01.size() == size02 );\n+  VERIFY( set01.empty() );\n+  VERIFY( set02.size() == size01 );\n+  VERIFY( set02.empty() );\n+\n+  my_set set03(less<char>(), alloc01);\n+  size01 = set03.size();\n+  my_set set04(title02, title02 + N2, less<char>(), alloc01);\n+  size02 = set04.size();\n+  \n+  set03.swap(set04);\n+  VERIFY( set03.size() == size02 );\n+  VERIFY( equal(set03.begin(), set03.end(), set02_ref.begin()) );\n+  VERIFY( set04.size() == size01 );\n+  VERIFY( set04.empty() );\n+  \n+  my_set set05(title01, title01 + N1, less<char>(), alloc01);\n+  size01 = set05.size();\n+  my_set set06(title02, title02 + N2, less<char>(), alloc01);\n+  size02 = set06.size();\n+  \n+  set05.swap(set06);\n+  VERIFY( set05.size() == size02 );\n+  VERIFY( equal(set05.begin(), set05.end(), set02_ref.begin()) );\n+  VERIFY( set06.size() == size01 );\n+  VERIFY( equal(set06.begin(), set06.end(), set01_ref.begin()) );\n+\n+  my_set set07(title01, title01 + N1, less<char>(), alloc01);\n+  size01 = set07.size();\n+  my_set set08(title03, title03 + N3, less<char>(), alloc01);\n+  size02 = set08.size();\n+\n+  set07.swap(set08);\n+  VERIFY( set07.size() == size02 );\n+  VERIFY( equal(set07.begin(), set07.end(), set03_ref.begin()) );\n+  VERIFY( set08.size() == size01 );\n+  VERIFY( equal(set08.begin(), set08.end(), set01_ref.begin()) );\n+\n+  my_set set09(title03, title03 + N3, less<char>(), alloc01);\n+  size01 = set09.size();\n+  my_set set10(title04, title04 + N4, less<char>(), alloc01);\n+  size02 = set10.size();\n+\n+  set09.swap(set10);\n+  VERIFY( set09.size() == size02 );\n+  VERIFY( equal(set09.begin(), set09.end(), set04_ref.begin()) );\n+  VERIFY( set10.size() == size01 );\n+  VERIFY( equal(set10.begin(), set10.end(), set03_ref.begin()) );\n+\n+  my_set set11(title04, title04 + N4, less<char>(), alloc01);\n+  size01 = set11.size();\n+  my_set set12(title01, title01 + N1, less<char>(), alloc01);\n+  size02 = set12.size();\n+\n+  set11.swap(set12);\n+  VERIFY( set11.size() == size02 );\n+  VERIFY( equal(set11.begin(), set11.end(), set01_ref.begin()) );\n+  VERIFY( set12.size() == size01 );\n+  VERIFY( equal(set12.begin(), set12.end(), set04_ref.begin()) );\n+\n+  my_set set13(title03, title03 + N3, less<char>(), alloc01);\n+  size01 = set13.size();\n+  my_set set14(title03, title03 + N3, less<char>(), alloc01);\n+  size02 = set14.size();\n+\n+  set13.swap(set14);\n+  VERIFY( set13.size() == size02 );\n+  VERIFY( equal(set13.begin(), set13.end(), set03_ref.begin()) );\n+  VERIFY( set14.size() == size01 );\n+  VERIFY( equal(set14.begin(), set14.end(), set03_ref.begin()) );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "8e71af46d46635979ab6f4803a1be92795543cc4", "filename": "libstdc++-v3/testsuite/23_containers/set/modifiers/swap/3.cc", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fswap%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fswap%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fmodifiers%2Fswap%2F3.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,167 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.3.3 set::swap\n+\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef set<char, less<char>, my_alloc> my_set;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  const set<char> set01_ref(title01, title01 + N1);\n+  const set<char> set02_ref(title02, title02 + N2);\n+  const set<char> set03_ref(title03, title03 + N3);\n+  const set<char> set04_ref(title04, title04 + N4);\n+\n+  my_set::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_set set01(less<char>(), alloc01);\n+  size01 = set01.size();\n+  personality01 = set01.get_allocator().get_personality();\n+  my_set set02(less<char>(), alloc02);\n+  size02 = set02.size();\n+  personality02 = set02.get_allocator().get_personality();\n+\n+  set01.swap(set02);\n+  VERIFY( set01.size() == size02 );\n+  VERIFY( set01.empty() );\n+  VERIFY( set02.size() == size01 );\n+  VERIFY( set02.empty() );\n+  VERIFY( set01.get_allocator().get_personality() == personality02 );\n+  VERIFY( set02.get_allocator().get_personality() == personality01 );\n+\n+  my_set set03(less<char>(), alloc02);\n+  size01 = set03.size();\n+  personality01 = set03.get_allocator().get_personality();\n+  my_set set04(title02, title02 + N2, less<char>(), alloc01);\n+  size02 = set04.size();\n+  personality02 = set04.get_allocator().get_personality();\n+\n+  set03.swap(set04);\n+  VERIFY( set03.size() == size02 );\n+  VERIFY( equal(set03.begin(), set03.end(), set02_ref.begin()) );\n+  VERIFY( set04.size() == size01 );\n+  VERIFY( set04.empty() );\n+  VERIFY( set03.get_allocator().get_personality() == personality02 );\n+  VERIFY( set04.get_allocator().get_personality() == personality01 );\n+  \n+  my_set set05(title01, title01 + N1, less<char>(), alloc01);\n+  size01 = set05.size();\n+  personality01 = set05.get_allocator().get_personality();\n+  my_set set06(title02, title02 + N2, less<char>(), alloc02);\n+  size02 = set06.size();\n+  personality02 = set06.get_allocator().get_personality();\n+\n+  set05.swap(set06);\n+  VERIFY( set05.size() == size02 );\n+  VERIFY( equal(set05.begin(), set05.end(), set02_ref.begin()) );\n+  VERIFY( set06.size() == size01 );\n+  VERIFY( equal(set06.begin(), set06.end(), set01_ref.begin()) );\n+  VERIFY( set05.get_allocator().get_personality() == personality02 );\n+  VERIFY( set06.get_allocator().get_personality() == personality01 );\n+\n+  my_set set07(title01, title01 + N1, less<char>(), alloc02);\n+  size01 = set07.size();\n+  personality01 = set07.get_allocator().get_personality();\n+  my_set set08(title03, title03 + N3, less<char>(), alloc01);\n+  size02 = set08.size();\n+  personality02 = set08.get_allocator().get_personality();\n+\n+  set07.swap(set08);\n+  VERIFY( set07.size() == size02 );\n+  VERIFY( equal(set07.begin(), set07.end(), set03_ref.begin()) );\n+  VERIFY( set08.size() == size01 );\n+  VERIFY( equal(set08.begin(), set08.end(), set01_ref.begin()) );\n+  VERIFY( set07.get_allocator().get_personality() == personality02 );\n+  VERIFY( set08.get_allocator().get_personality() == personality01 );\n+\n+  my_set set09(title03, title03 + N3, less<char>(), alloc01);\n+  size01 = set09.size();\n+  personality01 = set09.get_allocator().get_personality();\n+  my_set set10(title04, title04 + N4, less<char>(), alloc02);\n+  size02 = set10.size();\n+  personality02 = set10.get_allocator().get_personality();\n+\n+  set09.swap(set10);\n+  VERIFY( set09.size() == size02 );\n+  VERIFY( equal(set09.begin(), set09.end(), set04_ref.begin()) );\n+  VERIFY( set10.size() == size01 );\n+  VERIFY( equal(set10.begin(), set10.end(), set03_ref.begin()) );\n+  VERIFY( set09.get_allocator().get_personality() == personality02 );\n+  VERIFY( set10.get_allocator().get_personality() == personality01 );\n+\n+  my_set set11(title04, title04 + N4, less<char>(), alloc02);\n+  size01 = set11.size();\n+  personality01 = set11.get_allocator().get_personality();\n+  my_set set12(title01, title01 + N1, less<char>(), alloc01);\n+  size02 = set12.size();\n+  personality02 = set12.get_allocator().get_personality();\n+\n+  set11.swap(set12);\n+  VERIFY( set11.size() == size02 );\n+  VERIFY( equal(set11.begin(), set11.end(), set01_ref.begin()) );\n+  VERIFY( set12.size() == size01 );\n+  VERIFY( equal(set12.begin(), set12.end(), set04_ref.begin()) );\n+  VERIFY( set11.get_allocator().get_personality() == personality02 );\n+  VERIFY( set12.get_allocator().get_personality() == personality01 );\n+\n+  my_set set13(title03, title03 + N3, less<char>(), alloc01);\n+  size01 = set13.size();\n+  personality01 = set13.get_allocator().get_personality();\n+  my_set set14(title03, title03 + N3, less<char>(), alloc02);\n+  size02 = set14.size();\n+  personality02 = set14.get_allocator().get_personality();\n+\n+  set13.swap(set14);\n+  VERIFY( set13.size() == size02 );\n+  VERIFY( equal(set13.begin(), set13.end(), set03_ref.begin()) );\n+  VERIFY( set14.size() == size01 );\n+  VERIFY( equal(set14.begin(), set14.end(), set03_ref.begin()) );\n+  VERIFY( set13.get_allocator().get_personality() == personality02 );\n+  VERIFY( set14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "8489945354ac06b8d1c638962dae9110ea96ab97", "filename": "libstdc++-v3/testsuite/23_containers/vector/modifiers/swap/1.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2F1.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "previous_filename": "libstdc++-v3/testsuite/23_containers/vector/modifiers/swap.cc"}, {"sha": "ea41b4af38db099cb81e65a2f6c766431f98c3a8", "filename": "libstdc++-v3/testsuite/23_containers/vector/modifiers/swap/2.cc", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2F2.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,133 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.4.3 vector::swap\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef vector<char, my_alloc> my_vector;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  my_vector::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_vector vec01(alloc01);\n+  size01 = vec01.size();\n+  my_vector vec02(alloc01);\n+  size02 = vec02.size();\n+  \n+  vec01.swap(vec02);\n+  VERIFY( vec01.size() == size02 );\n+  VERIFY( vec01.empty() );\n+  VERIFY( vec02.size() == size01 );\n+  VERIFY( vec02.empty() );\n+\n+  my_vector vec03(alloc01);\n+  size01 = vec03.size();\n+  my_vector vec04(title02, title02 + N2, alloc01);\n+  size02 = vec04.size();\n+  \n+  vec03.swap(vec04);\n+  VERIFY( vec03.size() == size02 );\n+  VERIFY( equal(vec03.begin(), vec03.end(), title02) );\n+  VERIFY( vec04.size() == size01 );\n+  VERIFY( vec04.empty() );\n+  \n+  my_vector vec05(title01, title01 + N1, alloc01);\n+  size01 = vec05.size();\n+  my_vector vec06(title02, title02 + N2, alloc01);\n+  size02 = vec06.size();\n+  \n+  vec05.swap(vec06);\n+  VERIFY( vec05.size() == size02 );\n+  VERIFY( equal(vec05.begin(), vec05.end(), title02) );\n+  VERIFY( vec06.size() == size01 );\n+  VERIFY( equal(vec06.begin(), vec06.end(), title01) );\n+\n+  my_vector vec07(title01, title01 + N1, alloc01);\n+  size01 = vec07.size();\n+  my_vector vec08(title03, title03 + N3, alloc01);\n+  size02 = vec08.size();\n+\n+  vec07.swap(vec08);\n+  VERIFY( vec07.size() == size02 );\n+  VERIFY( equal(vec07.begin(), vec07.end(), title03) );\n+  VERIFY( vec08.size() == size01 );\n+  VERIFY( equal(vec08.begin(), vec08.end(), title01) );\n+\n+  my_vector vec09(title03, title03 + N3, alloc01);\n+  size01 = vec09.size();\n+  my_vector vec10(title04, title04 + N4, alloc01);\n+  size02 = vec10.size();\n+\n+  vec09.swap(vec10);\n+  VERIFY( vec09.size() == size02 );\n+  VERIFY( equal(vec09.begin(), vec09.end(), title04) );\n+  VERIFY( vec10.size() == size01 );\n+  VERIFY( equal(vec10.begin(), vec10.end(), title03) );\n+\n+  my_vector vec11(title04, title04 + N4, alloc01);\n+  size01 = vec11.size();\n+  my_vector vec12(title01, title01 + N1, alloc01);\n+  size02 = vec12.size();\n+\n+  vec11.swap(vec12);\n+  VERIFY( vec11.size() == size02 );\n+  VERIFY( equal(vec11.begin(), vec11.end(), title01) );\n+  VERIFY( vec12.size() == size01 );\n+  VERIFY( equal(vec12.begin(), vec12.end(), title04) );\n+\n+  my_vector vec13(title03, title03 + N3, alloc01);\n+  size01 = vec13.size();\n+  my_vector vec14(title03, title03 + N3, alloc01);\n+  size02 = vec14.size();\n+\n+  vec13.swap(vec14);\n+  VERIFY( vec13.size() == size02 );\n+  VERIFY( equal(vec13.begin(), vec13.end(), title03) );\n+  VERIFY( vec14.size() == size01 );\n+  VERIFY( equal(vec14.begin(), vec14.end(), title03) );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "7f1acdc645a992c3a8423415e1cb2724a0981cad", "filename": "libstdc++-v3/testsuite/23_containers/vector/modifiers/swap/3.cc", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Fmodifiers%2Fswap%2F3.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,162 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 23.2.4.3 vector::swap\n+\n+#include <vector>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef vector<char, my_alloc> my_vector;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  my_vector::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_vector vec01(alloc01);\n+  size01 = vec01.size();\n+  personality01 = vec01.get_allocator().get_personality();\n+  my_vector vec02(alloc02);\n+  size02 = vec02.size();\n+  personality02 = vec02.get_allocator().get_personality();\n+\n+  vec01.swap(vec02);\n+  VERIFY( vec01.size() == size02 );\n+  VERIFY( vec01.empty() );\n+  VERIFY( vec02.size() == size01 );\n+  VERIFY( vec02.empty() );\n+  VERIFY( vec01.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec02.get_allocator().get_personality() == personality01 );\n+\n+  my_vector vec03(alloc02);\n+  size01 = vec03.size();\n+  personality01 = vec03.get_allocator().get_personality();\n+  my_vector vec04(title02, title02 + N2, alloc01);\n+  size02 = vec04.size();\n+  personality02 = vec04.get_allocator().get_personality();\n+\n+  vec03.swap(vec04);\n+  VERIFY( vec03.size() == size02 );\n+  VERIFY( equal(vec03.begin(), vec03.end(), title02) );\n+  VERIFY( vec04.size() == size01 );\n+  VERIFY( vec04.empty() );\n+  VERIFY( vec03.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec04.get_allocator().get_personality() == personality01 );\n+  \n+  my_vector vec05(title01, title01 + N1, alloc01);\n+  size01 = vec05.size();\n+  personality01 = vec05.get_allocator().get_personality();\n+  my_vector vec06(title02, title02 + N2, alloc02);\n+  size02 = vec06.size();\n+  personality02 = vec06.get_allocator().get_personality();\n+\n+  vec05.swap(vec06);\n+  VERIFY( vec05.size() == size02 );\n+  VERIFY( equal(vec05.begin(), vec05.end(), title02) );\n+  VERIFY( vec06.size() == size01 );\n+  VERIFY( equal(vec06.begin(), vec06.end(), title01) );\n+  VERIFY( vec05.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec06.get_allocator().get_personality() == personality01 );\n+\n+  my_vector vec07(title01, title01 + N1, alloc02);\n+  size01 = vec07.size();\n+  personality01 = vec07.get_allocator().get_personality();\n+  my_vector vec08(title03, title03 + N3, alloc01);\n+  size02 = vec08.size();\n+  personality02 = vec08.get_allocator().get_personality();\n+\n+  vec07.swap(vec08);\n+  VERIFY( vec07.size() == size02 );\n+  VERIFY( equal(vec07.begin(), vec07.end(), title03) );\n+  VERIFY( vec08.size() == size01 );\n+  VERIFY( equal(vec08.begin(), vec08.end(), title01) );\n+  VERIFY( vec07.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec08.get_allocator().get_personality() == personality01 );\n+\n+  my_vector vec09(title03, title03 + N3, alloc01);\n+  size01 = vec09.size();\n+  personality01 = vec09.get_allocator().get_personality();\n+  my_vector vec10(title04, title04 + N4, alloc02);\n+  size02 = vec10.size();\n+  personality02 = vec10.get_allocator().get_personality();\n+\n+  vec09.swap(vec10);\n+  VERIFY( vec09.size() == size02 );\n+  VERIFY( equal(vec09.begin(), vec09.end(), title04) );\n+  VERIFY( vec10.size() == size01 );\n+  VERIFY( equal(vec10.begin(), vec10.end(), title03) );\n+  VERIFY( vec09.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec10.get_allocator().get_personality() == personality01 );\n+\n+  my_vector vec11(title04, title04 + N4, alloc02);\n+  size01 = vec11.size();\n+  personality01 = vec11.get_allocator().get_personality();\n+  my_vector vec12(title01, title01 + N1, alloc01);\n+  size02 = vec12.size();\n+  personality02 = vec12.get_allocator().get_personality();\n+\n+  vec11.swap(vec12);\n+  VERIFY( vec11.size() == size02 );\n+  VERIFY( equal(vec11.begin(), vec11.end(), title01) );\n+  VERIFY( vec12.size() == size01 );\n+  VERIFY( equal(vec12.begin(), vec12.end(), title04) );\n+  VERIFY( vec11.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec12.get_allocator().get_personality() == personality01 );\n+\n+  my_vector vec13(title03, title03 + N3, alloc01);\n+  size01 = vec13.size();\n+  personality01 = vec13.get_allocator().get_personality();\n+  my_vector vec14(title03, title03 + N3, alloc02);\n+  size02 = vec14.size();\n+  personality02 = vec14.get_allocator().get_personality();\n+\n+  vec13.swap(vec14);\n+  VERIFY( vec13.size() == size02 );\n+  VERIFY( equal(vec13.begin(), vec13.end(), title03) );\n+  VERIFY( vec14.size() == size01 );\n+  VERIFY( equal(vec14.begin(), vec14.end(), title03) );\n+  VERIFY( vec13.get_allocator().get_personality() == personality02 );\n+  VERIFY( vec14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "d379774926d2cb6d15b6228af44f87d4491516d0", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/swap/unordered_map/1.cc", "status": "added", "additions": 162, "deletions": 0, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_map%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_map%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_map%2F1.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,162 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.4 unordered_map::swap\n+\n+#include <tr1/unordered_map>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+  using namespace tr1;\n+\n+  typedef pair<const char, int> my_pair;\n+  typedef __gnu_test::uneq_allocator<my_pair> my_alloc;\n+  typedef unordered_map<char, int, hash<char>, equal_to<char>, my_alloc>\n+    my_umap;\n+  \n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  typedef map<char, int> my_map;\n+  my_map map01_ref;\n+  for (size_t i = 0; i < N1; ++i)\n+    map01_ref.insert(my_pair(title01[i], i));\n+  my_map map02_ref;\n+  for (size_t i = 0; i < N2; ++i)\n+    map02_ref.insert(my_pair(title02[i], i));\n+  my_map map03_ref;\n+  for (size_t i = 0; i < N3; ++i)\n+    map03_ref.insert(my_pair(title03[i], i));\n+  my_map map04_ref;\n+  for (size_t i = 0; i < N4; ++i)\n+    map04_ref.insert(my_pair(title04[i], i));\n+\n+  my_umap::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_umap umap01(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = umap01.size();\n+  my_umap umap02(10, hash<char>(), equal_to<char>(), alloc01);\n+  size02 = umap02.size();\n+  \n+  umap01.swap(umap02);\n+  VERIFY( umap01.size() == size02 );\n+  VERIFY( umap01.empty() );\n+  VERIFY( umap02.size() == size01 );\n+  VERIFY( umap02.empty() );\n+\n+  my_umap umap03(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = umap03.size();\n+  my_umap umap04(map02_ref.begin(), map02_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = umap04.size();\n+\n+  umap03.swap(umap04);\n+  VERIFY( umap03.size() == size02 );\n+  VERIFY( my_map(umap03.begin(), umap03.end()) == map02_ref );\n+  VERIFY( umap04.size() == size01 );\n+  VERIFY( umap04.empty() );\n+  \n+  my_umap umap05(map01_ref.begin(), map01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = umap05.size();\n+  my_umap umap06(map02_ref.begin(), map02_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = umap06.size();\n+\n+  umap05.swap(umap06);\n+  VERIFY( umap05.size() == size02 );\n+  VERIFY( my_map(umap05.begin(), umap05.end()) == map02_ref );\n+  VERIFY( umap06.size() == size01 );\n+  VERIFY( my_map(umap06.begin(), umap06.end()) == map01_ref );\n+\n+  my_umap umap07(map01_ref.begin(), map01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = umap07.size();\n+  my_umap umap08(map03_ref.begin(), map03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = umap08.size();\n+\n+  umap07.swap(umap08);\n+  VERIFY( umap07.size() == size02 );\n+  VERIFY( my_map(umap07.begin(), umap07.end()) == map03_ref );\n+  VERIFY( umap08.size() == size01 );\n+  VERIFY( my_map(umap08.begin(), umap08.end()) == map01_ref );\n+\n+  my_umap umap09(map03_ref.begin(), map03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = umap09.size();\n+  my_umap umap10(map04_ref.begin(), map04_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = umap10.size();\n+\n+  umap09.swap(umap10);\n+  VERIFY( umap09.size() == size02 );\n+  VERIFY( my_map(umap09.begin(), umap09.end()) == map04_ref );\n+  VERIFY( umap10.size() == size01 );\n+  VERIFY( my_map(umap10.begin(), umap10.end()) == map03_ref );\n+\n+  my_umap umap11(map04_ref.begin(), map04_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = umap11.size();\n+  my_umap umap12(map01_ref.begin(), map01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = umap12.size();\n+\n+  umap11.swap(umap12);\n+  VERIFY( umap11.size() == size02 );\n+  VERIFY( my_map(umap11.begin(), umap11.end()) == map01_ref );\n+  VERIFY( umap12.size() == size01 );\n+  VERIFY( my_map(umap12.begin(), umap12.end()) == map04_ref );\n+\n+  my_umap umap13(map03_ref.begin(), map03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = umap13.size();\n+  my_umap umap14(map03_ref.begin(), map03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = umap14.size();\n+\n+  umap13.swap(umap14);\n+  VERIFY( umap13.size() == size02 );\n+  VERIFY( my_map(umap13.begin(), umap13.end()) == map03_ref );\n+  VERIFY( umap14.size() == size01 );\n+  VERIFY( my_map(umap14.begin(), umap14.end()) == map03_ref );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "8d708292ae3447e675097f9f28fadaca2d19c262", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/swap/unordered_map/2.cc", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_map%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_map%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_map%2F2.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,191 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.4 unordered_map::swap\n+\n+#include <tr1/unordered_map>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+  using namespace tr1;\n+\n+  typedef pair<const char, int> my_pair;\n+  typedef __gnu_test::uneq_allocator<my_pair> my_alloc;\n+  typedef unordered_map<char, int, hash<char>, equal_to<char>, my_alloc>\n+    my_umap;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  typedef map<char, int> my_map;\n+  my_map map01_ref;\n+  for (size_t i = 0; i < N1; ++i)\n+    map01_ref.insert(my_pair(title01[i], i));\n+  my_map map02_ref;\n+  for (size_t i = 0; i < N2; ++i)\n+    map02_ref.insert(my_pair(title02[i], i));\n+  my_map map03_ref;\n+  for (size_t i = 0; i < N3; ++i)\n+    map03_ref.insert(my_pair(title03[i], i));\n+  my_map map04_ref;\n+  for (size_t i = 0; i < N4; ++i)\n+    map04_ref.insert(my_pair(title04[i], i));\n+\n+  my_umap::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_umap umap01(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = umap01.size();\n+  personality01 = umap01.get_allocator().get_personality();\n+  my_umap umap02(10, hash<char>(), equal_to<char>(), alloc02);\n+  size02 = umap02.size();\n+  personality02 = umap02.get_allocator().get_personality();\n+\n+  umap01.swap(umap02);\n+  VERIFY( umap01.size() == size02 );\n+  VERIFY( umap01.empty() );\n+  VERIFY( umap02.size() == size01 );\n+  VERIFY( umap02.empty() );\n+  VERIFY( umap01.get_allocator().get_personality() == personality02 );\n+  VERIFY( umap02.get_allocator().get_personality() == personality01 );\n+\n+  my_umap umap03(10, hash<char>(), equal_to<char>(), alloc02);\n+  size01 = umap03.size();\n+  personality01 = umap03.get_allocator().get_personality();\n+  my_umap umap04(map02_ref.begin(), map02_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = umap04.size();\n+  personality02 = umap04.get_allocator().get_personality();\n+\n+  umap03.swap(umap04);\n+  VERIFY( umap03.size() == size02 );\n+  VERIFY( my_map(umap03.begin(), umap03.end()) == map02_ref );\n+  VERIFY( umap04.size() == size01 );\n+  VERIFY( umap04.empty() );\n+  VERIFY( umap03.get_allocator().get_personality() == personality02 );\n+  VERIFY( umap04.get_allocator().get_personality() == personality01 );\n+  \n+  my_umap umap05(map01_ref.begin(), map01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = umap05.size();\n+  personality01 = umap05.get_allocator().get_personality();\n+  my_umap umap06(map02_ref.begin(), map02_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc02);\n+  size02 = umap06.size();\n+  personality02 = umap06.get_allocator().get_personality();\n+\n+  umap05.swap(umap06);\n+  VERIFY( umap05.size() == size02 );\n+  VERIFY( my_map(umap05.begin(), umap05.end()) == map02_ref );\n+  VERIFY( umap06.size() == size01 );\n+  VERIFY( my_map(umap06.begin(), umap06.end()) == map01_ref );\n+  VERIFY( umap05.get_allocator().get_personality() == personality02 );\n+  VERIFY( umap06.get_allocator().get_personality() == personality01 );\n+\n+  my_umap umap07(map01_ref.begin(), map01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc02);\n+  size01 = umap07.size();\n+  personality01 = umap07.get_allocator().get_personality();\n+  my_umap umap08(map03_ref.begin(), map03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = umap08.size();\n+  personality02 = umap08.get_allocator().get_personality();\n+\n+  umap07.swap(umap08);\n+  VERIFY( umap07.size() == size02 );\n+  VERIFY( my_map(umap07.begin(), umap07.end()) == map03_ref );\n+  VERIFY( umap08.size() == size01 );\n+  VERIFY( my_map(umap08.begin(), umap08.end()) == map01_ref );\n+  VERIFY( umap07.get_allocator().get_personality() == personality02 );\n+  VERIFY( umap08.get_allocator().get_personality() == personality01 );\n+\n+  my_umap umap09(map03_ref.begin(), map03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = umap09.size();\n+  personality01 = umap09.get_allocator().get_personality();\n+  my_umap umap10(map04_ref.begin(), map04_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc02);\n+  size02 = umap10.size();\n+  personality02 = umap10.get_allocator().get_personality();\n+\n+  umap09.swap(umap10);\n+  VERIFY( umap09.size() == size02 );\n+  VERIFY( my_map(umap09.begin(), umap09.end()) == map04_ref );\n+  VERIFY( umap10.size() == size01 );\n+  VERIFY( my_map(umap10.begin(), umap10.end()) == map03_ref );\n+  VERIFY( umap09.get_allocator().get_personality() == personality02 );\n+  VERIFY( umap10.get_allocator().get_personality() == personality01 );\n+\n+  my_umap umap11(map04_ref.begin(), map04_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc02);\n+  size01 = umap11.size();\n+  personality01 = umap11.get_allocator().get_personality();\n+  my_umap umap12(map01_ref.begin(), map01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = umap12.size();\n+  personality02 = umap12.get_allocator().get_personality();\n+\n+  umap11.swap(umap12);\n+  VERIFY( umap11.size() == size02 );\n+  VERIFY( my_map(umap11.begin(), umap11.end()) == map01_ref );\n+  VERIFY( umap12.size() == size01 );\n+  VERIFY( my_map(umap12.begin(), umap12.end()) == map04_ref );\n+  VERIFY( umap11.get_allocator().get_personality() == personality02 );\n+  VERIFY( umap12.get_allocator().get_personality() == personality01 );\n+\n+  my_umap umap13(map03_ref.begin(), map03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = umap13.size();\n+  personality01 = umap13.get_allocator().get_personality();\n+  my_umap umap14(map03_ref.begin(), map03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc02);\n+  size02 = umap14.size();\n+  personality02 = umap14.get_allocator().get_personality();\n+\n+  umap13.swap(umap14);\n+  VERIFY( umap13.size() == size02 );\n+  VERIFY( my_map(umap13.begin(), umap13.end()) == map03_ref );\n+  VERIFY( umap14.size() == size01 );\n+  VERIFY( my_map(umap14.begin(), umap14.end()) == map03_ref );\n+  VERIFY( umap13.get_allocator().get_personality() == personality02 );\n+  VERIFY( umap14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "7648e08bd6260fd90290e5fb383885c9f4ea8712", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/swap/unordered_multimap/1.cc", "status": "added", "additions": 175, "deletions": 0, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multimap%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multimap%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multimap%2F1.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,175 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.6 unordered_multimap::swap\n+\n+#include <tr1/unordered_map>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+  using namespace tr1;\n+\n+  typedef pair<const char, int> my_pair;\n+  typedef __gnu_test::uneq_allocator<my_pair> my_alloc;\n+  typedef unordered_multimap<char, int, hash<char>, equal_to<char>, my_alloc>\n+    my_ummap;\n+  \n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  typedef multimap<char, int> my_mmap;\n+  my_mmap mmap01_ref;\n+  for (size_t i = 0; i < N1; ++i)\n+    mmap01_ref.insert(my_pair(title01[i], i));\n+  my_mmap mmap02_ref;\n+  for (size_t i = 0; i < N2; ++i)\n+    mmap02_ref.insert(my_pair(title02[i], i));\n+  my_mmap mmap03_ref;\n+  for (size_t i = 0; i < N3; ++i)\n+    mmap03_ref.insert(my_pair(title03[i], i));\n+  my_mmap mmap04_ref;\n+  for (size_t i = 0; i < N4; ++i)\n+    mmap04_ref.insert(my_pair(title04[i], i));\n+\n+  typedef map<char, int> my_map;\n+\n+  my_ummap::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_ummap ummap01(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = ummap01.size();\n+  my_ummap ummap02(10, hash<char>(), equal_to<char>(), alloc01);\n+  size02 = ummap02.size();\n+  \n+  ummap01.swap(ummap02);\n+  VERIFY( ummap01.size() == size02 );\n+  VERIFY( ummap01.empty() );\n+  VERIFY( ummap02.size() == size01 );\n+  VERIFY( ummap02.empty() );\n+\n+  my_ummap ummap03(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = ummap03.size();\n+  my_ummap ummap04(mmap02_ref.begin(), mmap02_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = ummap04.size();\n+\n+  ummap03.swap(ummap04);\n+  VERIFY( ummap03.size() == size02 );\n+  VERIFY( my_map(ummap03.begin(), ummap03.end())\n+\t  == my_map(mmap02_ref.begin(), mmap02_ref.end()) );\n+  VERIFY( ummap04.size() == size01 );\n+  VERIFY( ummap04.empty() );\n+  \n+  my_ummap ummap05(mmap01_ref.begin(), mmap01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = ummap05.size();\n+  my_ummap ummap06(mmap02_ref.begin(), mmap02_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = ummap06.size();\n+\n+  ummap05.swap(ummap06);\n+  VERIFY( ummap05.size() == size02 );\n+  VERIFY( my_map(ummap05.begin(), ummap05.end())\n+\t  == my_map(mmap02_ref.begin(), mmap02_ref.end()) );\n+  VERIFY( ummap06.size() == size01 );\n+  VERIFY( my_map(ummap06.begin(), ummap06.end())\n+\t  == my_map(mmap01_ref.begin(), mmap01_ref.end()) );\n+\n+  my_ummap ummap07(mmap01_ref.begin(), mmap01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = ummap07.size();\n+  my_ummap ummap08(mmap03_ref.begin(), mmap03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = ummap08.size();\n+\n+  ummap07.swap(ummap08);\n+  VERIFY( ummap07.size() == size02 );\n+  VERIFY( my_map(ummap07.begin(), ummap07.end())\n+\t  == my_map(mmap03_ref.begin(), mmap03_ref.end()) );\n+  VERIFY( ummap08.size() == size01 );\n+  VERIFY( my_map(ummap08.begin(), ummap08.end())\n+\t  == my_map(mmap01_ref.begin(), mmap01_ref.end()) );\n+\n+  my_ummap ummap09(mmap03_ref.begin(), mmap03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = ummap09.size();\n+  my_ummap ummap10(mmap04_ref.begin(), mmap04_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = ummap10.size();\n+\n+  ummap09.swap(ummap10);\n+  VERIFY( ummap09.size() == size02 );\n+  VERIFY( my_map(ummap09.begin(), ummap09.end())\n+\t  == my_map(mmap04_ref.begin(), mmap04_ref.end()) );\n+  VERIFY( ummap10.size() == size01 );\n+  VERIFY( my_map(ummap10.begin(), ummap10.end())\n+\t  == my_map(mmap03_ref.begin(), mmap03_ref.end()) );\n+\n+  my_ummap ummap11(mmap04_ref.begin(), mmap04_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = ummap11.size();\n+  my_ummap ummap12(mmap01_ref.begin(), mmap01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = ummap12.size();\n+\n+  ummap11.swap(ummap12);\n+  VERIFY( ummap11.size() == size02 );\n+  VERIFY( my_map(ummap11.begin(), ummap11.end())\n+\t  == my_map(mmap01_ref.begin(), mmap01_ref.end()) );\n+  VERIFY( ummap12.size() == size01 );\n+  VERIFY( my_map(ummap12.begin(), ummap12.end())\n+\t  == my_map(mmap04_ref.begin(), mmap04_ref.end()) );\n+\n+  my_ummap ummap13(mmap03_ref.begin(), mmap03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = ummap13.size();\n+  my_ummap ummap14(mmap03_ref.begin(), mmap03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = ummap14.size();\n+\n+  ummap13.swap(ummap14);\n+  VERIFY( ummap13.size() == size02 );\n+  VERIFY( my_map(ummap13.begin(), ummap13.end())\n+\t  == my_map(mmap03_ref.begin(), mmap03_ref.end()) );\n+  VERIFY( ummap14.size() == size01 );\n+  VERIFY( my_map(ummap14.begin(), ummap14.end())\n+\t  == my_map(mmap03_ref.begin(), mmap03_ref.end()) );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "f7744ebe854a9e38f20aa76334360fe2442ac802", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/swap/unordered_multimap/2.cc", "status": "added", "additions": 204, "deletions": 0, "changes": 204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multimap%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multimap%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multimap%2F2.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,204 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.6 unordered_multimap::swap\n+\n+#include <tr1/unordered_map>\n+#include <map>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+  using namespace tr1;\n+\n+  typedef pair<const char, int> my_pair;\n+  typedef __gnu_test::uneq_allocator<my_pair> my_alloc;\n+  typedef unordered_multimap<char, int, hash<char>, equal_to<char>, my_alloc>\n+    my_ummap;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  typedef multimap<char, int> my_mmap;\n+  my_mmap mmap01_ref;\n+  for (size_t i = 0; i < N1; ++i)\n+    mmap01_ref.insert(my_pair(title01[i], i));\n+  my_mmap mmap02_ref;\n+  for (size_t i = 0; i < N2; ++i)\n+    mmap02_ref.insert(my_pair(title02[i], i));\n+  my_mmap mmap03_ref;\n+  for (size_t i = 0; i < N3; ++i)\n+    mmap03_ref.insert(my_pair(title03[i], i));\n+  my_mmap mmap04_ref;\n+  for (size_t i = 0; i < N4; ++i)\n+    mmap04_ref.insert(my_pair(title04[i], i));\n+\n+  typedef map<char, int> my_map;\n+\n+  my_ummap::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_ummap ummap01(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = ummap01.size();\n+  personality01 = ummap01.get_allocator().get_personality();\n+  my_ummap ummap02(10, hash<char>(), equal_to<char>(), alloc02);\n+  size02 = ummap02.size();\n+  personality02 = ummap02.get_allocator().get_personality();\n+\n+  ummap01.swap(ummap02);\n+  VERIFY( ummap01.size() == size02 );\n+  VERIFY( ummap01.empty() );\n+  VERIFY( ummap02.size() == size01 );\n+  VERIFY( ummap02.empty() );\n+  VERIFY( ummap01.get_allocator().get_personality() == personality02 );\n+  VERIFY( ummap02.get_allocator().get_personality() == personality01 );\n+\n+  my_ummap ummap03(10, hash<char>(), equal_to<char>(), alloc02);\n+  size01 = ummap03.size();\n+  personality01 = ummap03.get_allocator().get_personality();\n+  my_ummap ummap04(mmap02_ref.begin(), mmap02_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = ummap04.size();\n+  personality02 = ummap04.get_allocator().get_personality();\n+\n+  ummap03.swap(ummap04);\n+  VERIFY( ummap03.size() == size02 );\n+  VERIFY( my_map(ummap03.begin(), ummap03.end())\n+\t  == my_map(mmap02_ref.begin(), mmap02_ref.end()) );\n+  VERIFY( ummap04.size() == size01 );\n+  VERIFY( ummap04.empty() );\n+  VERIFY( ummap03.get_allocator().get_personality() == personality02 );\n+  VERIFY( ummap04.get_allocator().get_personality() == personality01 );\n+  \n+  my_ummap ummap05(mmap01_ref.begin(), mmap01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = ummap05.size();\n+  personality01 = ummap05.get_allocator().get_personality();\n+  my_ummap ummap06(mmap02_ref.begin(), mmap02_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc02);\n+  size02 = ummap06.size();\n+  personality02 = ummap06.get_allocator().get_personality();\n+\n+  ummap05.swap(ummap06);\n+  VERIFY( ummap05.size() == size02 );\n+  VERIFY( my_map(ummap05.begin(), ummap05.end())\n+\t  == my_map(mmap02_ref.begin(), mmap02_ref.end()) );\n+  VERIFY( ummap06.size() == size01 );\n+  VERIFY( my_map(ummap06.begin(), ummap06.end())\n+\t  == my_map(mmap01_ref.begin(), mmap01_ref.end()) );\n+  VERIFY( ummap05.get_allocator().get_personality() == personality02 );\n+  VERIFY( ummap06.get_allocator().get_personality() == personality01 );\n+\n+  my_ummap ummap07(mmap01_ref.begin(), mmap01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc02);\n+  size01 = ummap07.size();\n+  personality01 = ummap07.get_allocator().get_personality();\n+  my_ummap ummap08(mmap03_ref.begin(), mmap03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = ummap08.size();\n+  personality02 = ummap08.get_allocator().get_personality();\n+\n+  ummap07.swap(ummap08);\n+  VERIFY( ummap07.size() == size02 );\n+  VERIFY( my_map(ummap07.begin(), ummap07.end())\n+\t  == my_map(mmap03_ref.begin(), mmap03_ref.end()) );\n+  VERIFY( ummap08.size() == size01 );\n+  VERIFY( my_map(ummap08.begin(), ummap08.end()) \n+\t  == my_map(mmap01_ref.begin(), mmap01_ref.end()) );\n+  VERIFY( ummap07.get_allocator().get_personality() == personality02 );\n+  VERIFY( ummap08.get_allocator().get_personality() == personality01 );\n+\n+  my_ummap ummap09(mmap03_ref.begin(), mmap03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = ummap09.size();\n+  personality01 = ummap09.get_allocator().get_personality();\n+  my_ummap ummap10(mmap04_ref.begin(), mmap04_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc02);\n+  size02 = ummap10.size();\n+  personality02 = ummap10.get_allocator().get_personality();\n+\n+  ummap09.swap(ummap10);\n+  VERIFY( ummap09.size() == size02 );\n+  VERIFY( my_map(ummap09.begin(), ummap09.end())\n+\t  == my_map(mmap04_ref.begin(), mmap04_ref.end()) );\n+  VERIFY( ummap10.size() == size01 );\n+  VERIFY( my_map(ummap10.begin(), ummap10.end())\n+\t  == my_map(mmap03_ref.begin(), mmap03_ref.end()) );\n+  VERIFY( ummap09.get_allocator().get_personality() == personality02 );\n+  VERIFY( ummap10.get_allocator().get_personality() == personality01 );\n+\n+  my_ummap ummap11(mmap04_ref.begin(), mmap04_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc02);\n+  size01 = ummap11.size();\n+  personality01 = ummap11.get_allocator().get_personality();\n+  my_ummap ummap12(mmap01_ref.begin(), mmap01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = ummap12.size();\n+  personality02 = ummap12.get_allocator().get_personality();\n+\n+  ummap11.swap(ummap12);\n+  VERIFY( ummap11.size() == size02 );\n+  VERIFY( my_map(ummap11.begin(), ummap11.end())\n+\t  == my_map(mmap01_ref.begin(), mmap01_ref.end()) );\n+  VERIFY( ummap12.size() == size01 );\n+  VERIFY( my_map(ummap12.begin(), ummap12.end())\n+\t  == my_map(mmap04_ref.begin(), mmap04_ref.end()) );\n+  VERIFY( ummap11.get_allocator().get_personality() == personality02 );\n+  VERIFY( ummap12.get_allocator().get_personality() == personality01 );\n+\n+  my_ummap ummap13(mmap03_ref.begin(), mmap03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = ummap13.size();\n+  personality01 = ummap13.get_allocator().get_personality();\n+  my_ummap ummap14(mmap03_ref.begin(), mmap03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc02);\n+  size02 = ummap14.size();\n+  personality02 = ummap14.get_allocator().get_personality();\n+\n+  ummap13.swap(ummap14);\n+  VERIFY( ummap13.size() == size02 );\n+  VERIFY( my_map(ummap13.begin(), ummap13.end())\n+\t  == my_map(mmap03_ref.begin(), mmap03_ref.end()) );\n+  VERIFY( ummap14.size() == size01 );\n+  VERIFY( my_map(ummap14.begin(), ummap14.end())\n+\t  == my_map(mmap03_ref.begin(), mmap03_ref.end()) );\n+  VERIFY( ummap13.get_allocator().get_personality() == personality02 );\n+  VERIFY( ummap14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "ca0194e337520681bd7c4707ab14a40804ecc9c3", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/swap/unordered_multiset/1.cc", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multiset%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multiset%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multiset%2F1.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,153 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.5 unordered_multiset::swap\n+\n+#include <tr1/unordered_set>\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+  using namespace tr1;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef unordered_multiset<char, hash<char>, equal_to<char>, my_alloc>\n+    my_umset;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  typedef multiset<char> my_mset;\n+  const my_mset mset01_ref(title01, title01 + N1);\n+  const my_mset mset02_ref(title02, title02 + N2);\n+  const my_mset mset03_ref(title03, title03 + N3);\n+  const my_mset mset04_ref(title04, title04 + N4);\n+\n+  my_umset::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_umset umset01(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = umset01.size();\n+  my_umset umset02(10, hash<char>(), equal_to<char>(), alloc01);\n+  size02 = umset02.size();\n+  \n+  umset01.swap(umset02);\n+  VERIFY( umset01.size() == size02 );\n+  VERIFY( umset01.empty() );\n+  VERIFY( umset02.size() == size01 );\n+  VERIFY( umset02.empty() );\n+\n+  my_umset umset03(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = umset03.size();\n+  my_umset umset04(mset02_ref.begin(), mset02_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = umset04.size();\n+  \n+  umset03.swap(umset04);\n+  VERIFY( umset03.size() == size02 );\n+  VERIFY( my_mset(umset03.begin(), umset03.end()) == mset02_ref );\n+  VERIFY( umset04.size() == size01 );\n+  VERIFY( umset04.empty() );\n+  \n+  my_umset umset05(mset01_ref.begin(), mset01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = umset05.size();\n+  my_umset umset06(mset02_ref.begin(), mset02_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = umset06.size();\n+  \n+  umset05.swap(umset06);\n+  VERIFY( umset05.size() == size02 );\n+  VERIFY( my_mset(umset05.begin(), umset05.end()) == mset02_ref );\n+  VERIFY( umset06.size() == size01 );\n+  VERIFY( my_mset(umset06.begin(), umset06.end()) == mset01_ref );\n+\n+  my_umset umset07(mset01_ref.begin(), mset01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = umset07.size();\n+  my_umset umset08(mset03_ref.begin(), mset03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = umset08.size();\n+\n+  umset07.swap(umset08);\n+  VERIFY( umset07.size() == size02 );\n+  VERIFY( my_mset(umset07.begin(), umset07.end()) == mset03_ref );\n+  VERIFY( umset08.size() == size01 );\n+  VERIFY( my_mset(umset08.begin(), umset08.end()) == mset01_ref );\n+\n+  my_umset umset09(mset03_ref.begin(), mset03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = umset09.size();\n+  my_umset umset10(mset04_ref.begin(), mset04_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = umset10.size();\n+\n+  umset09.swap(umset10);\n+  VERIFY( umset09.size() == size02 );\n+  VERIFY( my_mset(umset09.begin(), umset09.end()) == mset04_ref );\n+  VERIFY( umset10.size() == size01 );\n+  VERIFY( my_mset(umset10.begin(), umset10.end()) == mset03_ref );\n+\n+  my_umset umset11(mset04_ref.begin(), mset04_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = umset11.size();\n+  my_umset umset12(mset01_ref.begin(), mset01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = umset12.size();\n+\n+  umset11.swap(umset12);\n+  VERIFY( umset11.size() == size02 );\n+  VERIFY( my_mset(umset11.begin(), umset11.end()) == mset01_ref );\n+  VERIFY( umset12.size() == size01 );\n+  VERIFY( my_mset(umset12.begin(), umset12.end()) == mset04_ref );\n+\n+  my_umset umset13(mset03_ref.begin(), mset03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = umset13.size();\n+  my_umset umset14(mset03_ref.begin(), mset03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = umset14.size();\n+\n+  umset13.swap(umset14);\n+  VERIFY( umset13.size() == size02 );\n+  VERIFY( my_mset(umset13.begin(), umset13.end()) == mset03_ref );\n+  VERIFY( umset14.size() == size01 );\n+  VERIFY( my_mset(umset14.begin(), umset14.end()) == mset03_ref );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "a95ddd51fc8c927fe9e66f488cf15e1ea55b218e", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/swap/unordered_multiset/2.cc", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multiset%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multiset%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_multiset%2F2.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,182 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.5 unordered_multiset::swap\n+\n+#include <tr1/unordered_set>\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+  using namespace tr1;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef unordered_multiset<char, hash<char>, equal_to<char>, my_alloc>\n+    my_umset;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  typedef multiset<char> my_mset;\n+  const my_mset mset01_ref(title01, title01 + N1);\n+  const my_mset mset02_ref(title02, title02 + N2);\n+  const my_mset mset03_ref(title03, title03 + N3);\n+  const my_mset mset04_ref(title04, title04 + N4);\n+\n+  my_umset::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_umset umset01(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = umset01.size();\n+  personality01 = umset01.get_allocator().get_personality();\n+  my_umset umset02(10, hash<char>(), equal_to<char>(), alloc02);\n+  size02 = umset02.size();\n+  personality02 = umset02.get_allocator().get_personality();\n+\n+  umset01.swap(umset02);\n+  VERIFY( umset01.size() == size02 );\n+  VERIFY( umset01.empty() );\n+  VERIFY( umset02.size() == size01 );\n+  VERIFY( umset02.empty() );\n+  VERIFY( umset01.get_allocator().get_personality() == personality02 );\n+  VERIFY( umset02.get_allocator().get_personality() == personality01 );\n+\n+  my_umset umset03(10, hash<char>(), equal_to<char>(), alloc02);\n+  size01 = umset03.size();\n+  personality01 = umset03.get_allocator().get_personality();\n+  my_umset umset04(mset02_ref.begin(), mset02_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = umset04.size();\n+  personality02 = umset04.get_allocator().get_personality();\n+\n+  umset03.swap(umset04);\n+  VERIFY( umset03.size() == size02 );\n+  VERIFY( my_mset(umset03.begin(), umset03.end()) == mset02_ref );\n+  VERIFY( umset04.size() == size01 );\n+  VERIFY( umset04.empty() );\n+  VERIFY( umset03.get_allocator().get_personality() == personality02 );\n+  VERIFY( umset04.get_allocator().get_personality() == personality01 );\n+  \n+  my_umset umset05(mset01_ref.begin(), mset01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = umset05.size();\n+  personality01 = umset05.get_allocator().get_personality();\n+  my_umset umset06(mset02_ref.begin(), mset02_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc02);\n+  size02 = umset06.size();\n+  personality02 = umset06.get_allocator().get_personality();\n+\n+  umset05.swap(umset06);\n+  VERIFY( umset05.size() == size02 );\n+  VERIFY( my_mset(umset05.begin(), umset05.end()) == mset02_ref );\n+  VERIFY( umset06.size() == size01 );\n+  VERIFY( my_mset(umset06.begin(), umset06.end()) == mset01_ref );\n+  VERIFY( umset05.get_allocator().get_personality() == personality02 );\n+  VERIFY( umset06.get_allocator().get_personality() == personality01 );\n+\n+  my_umset umset07(mset01_ref.begin(), mset01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc02);\n+  size01 = umset07.size();\n+  personality01 = umset07.get_allocator().get_personality();\n+  my_umset umset08(mset03_ref.begin(), mset03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = umset08.size();\n+  personality02 = umset08.get_allocator().get_personality();\n+\n+  umset07.swap(umset08);\n+  VERIFY( umset07.size() == size02 );\n+  VERIFY( my_mset(umset07.begin(), umset07.end()) == mset03_ref );\n+  VERIFY( umset08.size() == size01 );\n+  VERIFY( my_mset(umset08.begin(), umset08.end()) == mset01_ref );\n+  VERIFY( umset07.get_allocator().get_personality() == personality02 );\n+  VERIFY( umset08.get_allocator().get_personality() == personality01 );\n+\n+  my_umset umset09(mset03_ref.begin(), mset03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = umset09.size();\n+  personality01 = umset09.get_allocator().get_personality();\n+  my_umset umset10(mset04_ref.begin(), mset04_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc02);\n+  size02 = umset10.size();\n+  personality02 = umset10.get_allocator().get_personality();\n+\n+  umset09.swap(umset10);\n+  VERIFY( umset09.size() == size02 );\n+  VERIFY( my_mset(umset09.begin(), umset09.end()) == mset04_ref );\n+  VERIFY( umset10.size() == size01 );\n+  VERIFY( my_mset(umset10.begin(), umset10.end()) == mset03_ref );\n+  VERIFY( umset09.get_allocator().get_personality() == personality02 );\n+  VERIFY( umset10.get_allocator().get_personality() == personality01 );\n+\n+  my_umset umset11(mset04_ref.begin(), mset04_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc02);\n+  size01 = umset11.size();\n+  personality01 = umset11.get_allocator().get_personality();\n+  my_umset umset12(mset01_ref.begin(), mset01_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size02 = umset12.size();\n+  personality02 = umset12.get_allocator().get_personality();\n+\n+  umset11.swap(umset12);\n+  VERIFY( umset11.size() == size02 );\n+  VERIFY( my_mset(umset11.begin(), umset11.end()) == mset01_ref );\n+  VERIFY( umset12.size() == size01 );\n+  VERIFY( my_mset(umset12.begin(), umset12.end()) == mset04_ref );\n+  VERIFY( umset11.get_allocator().get_personality() == personality02 );\n+  VERIFY( umset12.get_allocator().get_personality() == personality01 );\n+\n+  my_umset umset13(mset03_ref.begin(), mset03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc01);\n+  size01 = umset13.size();\n+  personality01 = umset13.get_allocator().get_personality();\n+  my_umset umset14(mset03_ref.begin(), mset03_ref.end(), 10, hash<char>(),\n+\t\t   equal_to<char>(), alloc02);\n+  size02 = umset14.size();\n+  personality02 = umset14.get_allocator().get_personality();\n+\n+  umset13.swap(umset14);\n+  VERIFY( umset13.size() == size02 );\n+  VERIFY( my_mset(umset13.begin(), umset13.end()) == mset03_ref );\n+  VERIFY( umset14.size() == size01 );\n+  VERIFY( my_mset(umset14.begin(), umset14.end()) == mset03_ref );\n+  VERIFY( umset13.get_allocator().get_personality() == personality02 );\n+  VERIFY( umset14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "1928c9e1bdc3165eadf2369106d733f8e8ca5b8c", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/swap/unordered_set/1.cc", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_set%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_set%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_set%2F1.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,152 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.3 unordered_set::swap\n+\n+#include <tr1/unordered_set>\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator as a non-empty allocator.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+  using namespace tr1;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef unordered_set<char, hash<char>, equal_to<char>, my_alloc> my_uset;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  typedef set<char> my_set;\n+  const my_set set01_ref(title01, title01 + N1);\n+  const my_set set02_ref(title02, title02 + N2);\n+  const my_set set03_ref(title03, title03 + N3);\n+  const my_set set04_ref(title04, title04 + N4);\n+\n+  my_uset::size_type size01, size02;\n+\n+  my_alloc alloc01(1);\n+\n+  my_uset uset01(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = uset01.size();\n+  my_uset uset02(10, hash<char>(), equal_to<char>(), alloc01);\n+  size02 = uset02.size();\n+  \n+  uset01.swap(uset02);\n+  VERIFY( uset01.size() == size02 );\n+  VERIFY( uset01.empty() );\n+  VERIFY( uset02.size() == size01 );\n+  VERIFY( uset02.empty() );\n+\n+  my_uset uset03(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = uset03.size();\n+  my_uset uset04(set02_ref.begin(), set02_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = uset04.size();\n+  \n+  uset03.swap(uset04);\n+  VERIFY( uset03.size() == size02 );\n+  VERIFY( my_set(uset03.begin(), uset03.end()) == set02_ref );\n+  VERIFY( uset04.size() == size01 );\n+  VERIFY( uset04.empty() );\n+  \n+  my_uset uset05(set01_ref.begin(), set01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = uset05.size();\n+  my_uset uset06(set02_ref.begin(), set02_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = uset06.size();\n+  \n+  uset05.swap(uset06);\n+  VERIFY( uset05.size() == size02 );\n+  VERIFY( my_set(uset05.begin(), uset05.end()) == set02_ref );\n+  VERIFY( uset06.size() == size01 );\n+  VERIFY( my_set(uset06.begin(), uset06.end()) == set01_ref );\n+\n+  my_uset uset07(set01_ref.begin(), set01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = uset07.size();\n+  my_uset uset08(set03_ref.begin(), set03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = uset08.size();\n+\n+  uset07.swap(uset08);\n+  VERIFY( uset07.size() == size02 );\n+  VERIFY( my_set(uset07.begin(), uset07.end()) == set03_ref );\n+  VERIFY( uset08.size() == size01 );\n+  VERIFY( my_set(uset08.begin(), uset08.end()) == set01_ref );\n+\n+  my_uset uset09(set03_ref.begin(), set03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = uset09.size();\n+  my_uset uset10(set04_ref.begin(), set04_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = uset10.size();\n+\n+  uset09.swap(uset10);\n+  VERIFY( uset09.size() == size02 );\n+  VERIFY( my_set(uset09.begin(), uset09.end()) == set04_ref );\n+  VERIFY( uset10.size() == size01 );\n+  VERIFY( my_set(uset10.begin(), uset10.end()) == set03_ref );\n+\n+  my_uset uset11(set04_ref.begin(), set04_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = uset11.size();\n+  my_uset uset12(set01_ref.begin(), set01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = uset12.size();\n+\n+  uset11.swap(uset12);\n+  VERIFY( uset11.size() == size02 );\n+  VERIFY( my_set(uset11.begin(), uset11.end()) == set01_ref );\n+  VERIFY( uset12.size() == size01 );\n+  VERIFY( my_set(uset12.begin(), uset12.end()) == set04_ref );\n+\n+  my_uset uset13(set03_ref.begin(), set03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = uset13.size();\n+  my_uset uset14(set03_ref.begin(), set03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = uset14.size();\n+\n+  uset13.swap(uset14);\n+  VERIFY( uset13.size() == size02 );\n+  VERIFY( my_set(uset13.begin(), uset13.end()) == set03_ref );\n+  VERIFY( uset14.size() == size01 );\n+  VERIFY( my_set(uset14.begin(), uset14.end()) == set03_ref );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}, {"sha": "46e859cabacb832305bc8a67198e3fdad6ba2d05", "filename": "libstdc++-v3/testsuite/tr1/6_containers/unordered/swap/unordered_set/2.cc", "status": "added", "additions": 181, "deletions": 0, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_set%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7ace77f1f4a713c2e96b4daf6181216b5df29d9/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_set%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Ftr1%2F6_containers%2Funordered%2Fswap%2Funordered_set%2F2.cc?ref=f7ace77f1f4a713c2e96b4daf6181216b5df29d9", "patch": "@@ -0,0 +1,181 @@\n+// 2005-12-20  Paolo Carlini  <pcarlini@suse.de>\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 6.3.4.3 unordered_set::swap\n+\n+#include <tr1/unordered_set>\n+#include <set>\n+#include <testsuite_hooks.h>\n+#include <testsuite_allocator.h>\n+\n+// uneq_allocator, two different personalities.\n+void\n+test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using namespace std;\n+  using namespace tr1;\n+\n+  typedef __gnu_test::uneq_allocator<char> my_alloc;\n+  typedef unordered_set<char, hash<char>, equal_to<char>, my_alloc> my_uset;\n+\n+  const char title01[] = \"Rivers of sand\";\n+  const char title02[] = \"Concret PH\";\n+  const char title03[] = \"Sonatas and Interludes for Prepared Piano\";\n+  const char title04[] = \"never as tired as when i'm waking up\";\n+\n+  const size_t N1 = sizeof(title01);\n+  const size_t N2 = sizeof(title02);\n+  const size_t N3 = sizeof(title03);\n+  const size_t N4 = sizeof(title04);\n+\n+  typedef set<char> my_set;\n+  const my_set set01_ref(title01, title01 + N1);\n+  const my_set set02_ref(title02, title02 + N2);\n+  const my_set set03_ref(title03, title03 + N3);\n+  const my_set set04_ref(title04, title04 + N4);\n+\n+  my_uset::size_type size01, size02;\n+\n+  my_alloc alloc01(1), alloc02(2);\n+  int personality01, personality02;\n+\n+  my_uset uset01(10, hash<char>(), equal_to<char>(), alloc01);\n+  size01 = uset01.size();\n+  personality01 = uset01.get_allocator().get_personality();\n+  my_uset uset02(10, hash<char>(), equal_to<char>(), alloc02);\n+  size02 = uset02.size();\n+  personality02 = uset02.get_allocator().get_personality();\n+\n+  uset01.swap(uset02);\n+  VERIFY( uset01.size() == size02 );\n+  VERIFY( uset01.empty() );\n+  VERIFY( uset02.size() == size01 );\n+  VERIFY( uset02.empty() );\n+  VERIFY( uset01.get_allocator().get_personality() == personality02 );\n+  VERIFY( uset02.get_allocator().get_personality() == personality01 );\n+\n+  my_uset uset03(10, hash<char>(), equal_to<char>(), alloc02);\n+  size01 = uset03.size();\n+  personality01 = uset03.get_allocator().get_personality();\n+  my_uset uset04(set02_ref.begin(), set02_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = uset04.size();\n+  personality02 = uset04.get_allocator().get_personality();\n+\n+  uset03.swap(uset04);\n+  VERIFY( uset03.size() == size02 );\n+  VERIFY( my_set(uset03.begin(), uset03.end()) == set02_ref );\n+  VERIFY( uset04.size() == size01 );\n+  VERIFY( uset04.empty() );\n+  VERIFY( uset03.get_allocator().get_personality() == personality02 );\n+  VERIFY( uset04.get_allocator().get_personality() == personality01 );\n+  \n+  my_uset uset05(set01_ref.begin(), set01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = uset05.size();\n+  personality01 = uset05.get_allocator().get_personality();\n+  my_uset uset06(set02_ref.begin(), set02_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc02);\n+  size02 = uset06.size();\n+  personality02 = uset06.get_allocator().get_personality();\n+\n+  uset05.swap(uset06);\n+  VERIFY( uset05.size() == size02 );\n+  VERIFY( my_set(uset05.begin(), uset05.end()) == set02_ref );\n+  VERIFY( uset06.size() == size01 );\n+  VERIFY( my_set(uset06.begin(), uset06.end()) == set01_ref );\n+  VERIFY( uset05.get_allocator().get_personality() == personality02 );\n+  VERIFY( uset06.get_allocator().get_personality() == personality01 );\n+\n+  my_uset uset07(set01_ref.begin(), set01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc02);\n+  size01 = uset07.size();\n+  personality01 = uset07.get_allocator().get_personality();\n+  my_uset uset08(set03_ref.begin(), set03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = uset08.size();\n+  personality02 = uset08.get_allocator().get_personality();\n+\n+  uset07.swap(uset08);\n+  VERIFY( uset07.size() == size02 );\n+  VERIFY( my_set(uset07.begin(), uset07.end()) == set03_ref );\n+  VERIFY( uset08.size() == size01 );\n+  VERIFY( my_set(uset08.begin(), uset08.end()) == set01_ref );\n+  VERIFY( uset07.get_allocator().get_personality() == personality02 );\n+  VERIFY( uset08.get_allocator().get_personality() == personality01 );\n+\n+  my_uset uset09(set03_ref.begin(), set03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = uset09.size();\n+  personality01 = uset09.get_allocator().get_personality();\n+  my_uset uset10(set04_ref.begin(), set04_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc02);\n+  size02 = uset10.size();\n+  personality02 = uset10.get_allocator().get_personality();\n+\n+  uset09.swap(uset10);\n+  VERIFY( uset09.size() == size02 );\n+  VERIFY( my_set(uset09.begin(), uset09.end()) == set04_ref );\n+  VERIFY( uset10.size() == size01 );\n+  VERIFY( my_set(uset10.begin(), uset10.end()) == set03_ref );\n+  VERIFY( uset09.get_allocator().get_personality() == personality02 );\n+  VERIFY( uset10.get_allocator().get_personality() == personality01 );\n+\n+  my_uset uset11(set04_ref.begin(), set04_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc02);\n+  size01 = uset11.size();\n+  personality01 = uset11.get_allocator().get_personality();\n+  my_uset uset12(set01_ref.begin(), set01_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size02 = uset12.size();\n+  personality02 = uset12.get_allocator().get_personality();\n+\n+  uset11.swap(uset12);\n+  VERIFY( uset11.size() == size02 );\n+  VERIFY( my_set(uset11.begin(), uset11.end()) == set01_ref );\n+  VERIFY( uset12.size() == size01 );\n+  VERIFY( my_set(uset12.begin(), uset12.end()) == set04_ref );\n+  VERIFY( uset11.get_allocator().get_personality() == personality02 );\n+  VERIFY( uset12.get_allocator().get_personality() == personality01 );\n+\n+  my_uset uset13(set03_ref.begin(), set03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc01);\n+  size01 = uset13.size();\n+  personality01 = uset13.get_allocator().get_personality();\n+  my_uset uset14(set03_ref.begin(), set03_ref.end(), 10, hash<char>(),\n+\t\t equal_to<char>(), alloc02);\n+  size02 = uset14.size();\n+  personality02 = uset14.get_allocator().get_personality();\n+\n+  uset13.swap(uset14);\n+  VERIFY( uset13.size() == size02 );\n+  VERIFY( my_set(uset13.begin(), uset13.end()) == set03_ref );\n+  VERIFY( uset14.size() == size01 );\n+  VERIFY( my_set(uset14.begin(), uset14.end()) == set03_ref );\n+  VERIFY( uset13.get_allocator().get_personality() == personality02 );\n+  VERIFY( uset14.get_allocator().get_personality() == personality01 );\n+}\n+\n+int main()\n+{ \n+  test01();\n+  return 0;\n+}"}]}