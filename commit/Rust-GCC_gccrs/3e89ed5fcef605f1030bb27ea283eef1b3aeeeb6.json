{"sha": "3e89ed5fcef605f1030bb27ea283eef1b3aeeeb6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2U4OWVkNWZjZWY2MDVmMTAzMGJiMjdlYTI4M2VlZjFiM2FlZWViNg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-06-18T20:48:07Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1992-06-18T20:48:07Z"}, "message": "(andsi3...\n\n(andsi3, iorsi3, xorsi3): Make the constraints match\nthe real machine (the predicate still is more general in order\nto optimize bitfields at the expense of not CSE'ing large\nconstants used in logical ops, and making reload load it into\na scratch register).  Don't use $1 as a temporary register any\nmore.\n\nFrom-SVN: r1217", "tree": {"sha": "14c74b3d9ffaa50fb965f843a552df093170eab3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14c74b3d9ffaa50fb965f843a552df093170eab3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e89ed5fcef605f1030bb27ea283eef1b3aeeeb6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e89ed5fcef605f1030bb27ea283eef1b3aeeeb6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e89ed5fcef605f1030bb27ea283eef1b3aeeeb6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e89ed5fcef605f1030bb27ea283eef1b3aeeeb6/comments", "author": null, "committer": null, "parents": [{"sha": "4763b498568d51040743e338fb6fec3d6a042cbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4763b498568d51040743e338fb6fec3d6a042cbe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4763b498568d51040743e338fb6fec3d6a042cbe"}], "stats": {"total": 271, "additions": 16, "deletions": 255}, "files": [{"sha": "8b7c2288aa560822cb5cf94ae44317af042be505", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 16, "deletions": 255, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e89ed5fcef605f1030bb27ea283eef1b3aeeeb6/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e89ed5fcef605f1030bb27ea283eef1b3aeeeb6/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=3e89ed5fcef605f1030bb27ea283eef1b3aeeeb6", "patch": "@@ -1148,52 +1148,17 @@ move\\\\t%0,%z4\\\\n\\\\\n ;;  ....................\n ;;\n \n-;; Be more liberal in allowing logical operations than the machine actually\n-;; supports.  This causes better code to be generated for bitfields, since\n-;; the optimizer can fold things together, at the expense of not moving the\n-;; constant out of loops.\n-\n-(define_expand \"andsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(and:SI (match_operand:SI 1 \"arith32_operand\" \"dKIM\")\n-\t\t(match_operand:SI 2 \"arith32_operand\" \"dKIM\")))]\n-  \"\"\n-  \"\n-{\n-  extern rtx gen_andsi3_internal2 ();\n-\n-  /* Canonlicalize */\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      rtx temp;\n-\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  emit_move_insn (operands[0],\n-\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t   INTVAL (operands[1]) & INTVAL (operands[2])));\n-\t  DONE;\n-\t}\n-\n-      temp = operands[1];\n-      operands[1] = operands[2];\n-      operands[2] = temp;\n-    }\n-\n-  if (GET_CODE (operands[2]) == CONST_INT && !SMALL_INT_UNSIGNED (operands[2]))\n-    {\n-      emit_insn (gen_andsi3_internal2 (operands[0],\n-\t\t\t\t       operands[1],\n-\t\t\t\t       operands[2],\n-\t\t\t\t       gen_reg_rtx (SImode)));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"andsi3_internal1\"\n+;; Be more liberal in allowing logical operations than the machine\n+;; actually supports, until the reload phase forces the large integers\n+;; into registers.  This causes better code to be generated for\n+;; bitfields, since the optimizer can fold things together, at the\n+;; expense of not CSE'ing or moving the constant out of loops, and\n+;; having reload load the constant into a scratch register.\n+\n+(define_insn \"andsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n-\t\t(match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+\t(and:SI (match_operand:SI 1 \"arith32_operand\" \"%d,d\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K\")))]\n   \"\"\n   \"@\n    and\\\\t%0,%1,%2\n@@ -1202,49 +1167,6 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"andsi3_internal2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"d,d,d,d\")\n-\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K,I,M\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d,d,d,d\"))]\n-  \"\"\n-  \"@\n-   and\\\\t%0,%1,%2\n-   andi\\\\t%0,%1,%x2\n-   li\\\\t%3,%X2\\\\t\\\\t# %2\\;and\\\\t%0,%1,%3\n-   li\\\\t%3,%X2\\\\t\\\\t# %2\\;and\\\\t%0,%1,%3\"\n-  [(set_attr \"type\"\t\"arith,arith,multi,multi\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"1,1,2,3\")])\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"lui_int\" \"\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n-\n-  [(set (match_dup 3) (match_dup 2))\n-   (set (match_dup 0) (and:SI (match_dup 1) (match_dup 3)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"large_int\" \"\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n-\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 5)))\n-   (set (match_dup 0) (and:SI (match_dup 1) (match_dup 3)))]\n-  \"\n-{\n-  int val = INTVAL (operands[2]);\n-  operands[4] = gen_rtx (CONST_INT, VOIDmode, val & 0xffff0000);\n-  operands[5] = gen_rtx (CONST_INT, VOIDmode, val & 0x0000ffff);\n-}\")\n-\n (define_insn \"anddi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(and:DI (match_operand:DI 1 \"register_operand\" \"d\")\n@@ -1268,47 +1190,10 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set (subreg:SI (match_dup 0) 1) (and:SI (subreg:SI (match_dup 1) 1) (subreg:SI (match_dup 2) 1)))]\n   \"\")\n \n-(define_expand \"iorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(ior:SI (match_operand:SI 1 \"arith32_operand\" \"dKIM\")\n-\t\t(match_operand:SI 2 \"arith32_operand\" \"dKIM\")))]\n-  \"\"\n-  \"\n-{\n-  extern rtx gen_iorsi3_internal2 ();\n-\n-  /* Canonlicalize */\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      rtx temp;\n-\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  emit_move_insn (operands[0],\n-\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t   INTVAL (operands[1]) | INTVAL (operands[2])));\n-\t  DONE;\n-\t}\n-\n-      temp = operands[1];\n-      operands[1] = operands[2];\n-      operands[2] = temp;\n-    }\n-\n-  if (GET_CODE (operands[2]) == CONST_INT && !SMALL_INT_UNSIGNED (operands[2]))\n-    {\n-      emit_insn (gen_iorsi3_internal2 (operands[0],\n-\t\t\t\t       operands[1],\n-\t\t\t\t       operands[2],\n-\t\t\t\t       gen_reg_rtx (SImode)));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"iorsi3_internal1\"\n+(define_insn \"iorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n-\t\t(match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+\t(ior:SI (match_operand:SI 1 \"arith32_operand\" \"%d,d\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K\")))]\n   \"\"\n   \"@\n    or\\\\t%0,%1,%2\n@@ -1317,49 +1202,6 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"iorsi3_internal2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"d,d,d,d\")\n-\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K,I,M\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d,d,d,d\"))]\n-  \"\"\n-  \"@\n-   or\\\\t%0,%1,%2\n-   ori\\\\t%0,%1,%x2\n-   li\\\\t%3,%X2\\\\t\\\\t# %2\\;or\\\\t%0,%1,%3\n-   li\\\\t%3,%X2\\\\t\\\\t# %2\\;or\\\\t%0,%1,%3\"\n-  [(set_attr \"type\"\t\"arith,arith,multi,multi\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"1,1,2,3\")])\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"lui_int\" \"\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n-\n-  [(set (match_dup 3) (match_dup 2))\n-   (set (match_dup 0) (ior:SI (match_dup 1) (match_dup 3)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"large_int\" \"\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n-\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 5)))\n-   (set (match_dup 0) (ior:SI (match_dup 1) (match_dup 3)))]\n-  \"\n-{\n-  int val = INTVAL (operands[2]);\n-  operands[4] = gen_rtx (CONST_INT, VOIDmode, val & 0xffff0000);\n-  operands[5] = gen_rtx (CONST_INT, VOIDmode, val & 0x0000ffff);\n-}\")\n-\n (define_insn \"iordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(ior:DI (match_operand:DI 1 \"register_operand\" \"d\")\n@@ -1383,47 +1225,10 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set (subreg:SI (match_dup 0) 1) (ior:SI (subreg:SI (match_dup 1) 1) (subreg:SI (match_dup 2) 1)))]\n   \"\")\n \n-(define_expand \"xorsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(xor:SI (match_operand:SI 1 \"arith32_operand\" \"dKIM\")\n-\t\t(match_operand:SI 2 \"arith32_operand\" \"dKIM\")))]\n-  \"\"\n-  \"\n-{\n-  extern rtx gen_xorsi3_internal2 ();\n-\n-  /* Canonlicalize */\n-  if (GET_CODE (operands[1]) == CONST_INT)\n-    {\n-      rtx temp;\n-\n-      if (GET_CODE (operands[2]) == CONST_INT)\n-\t{\n-\t  emit_move_insn (operands[0],\n-\t\t\t  gen_rtx (CONST_INT, VOIDmode,\n-\t\t\t\t   INTVAL (operands[1]) ^ INTVAL (operands[2])));\n-\t  DONE;\n-\t}\n-\n-      temp = operands[1];\n-      operands[1] = operands[2];\n-      operands[2] = temp;\n-    }\n-\n-  if (GET_CODE (operands[2]) == CONST_INT && !SMALL_INT_UNSIGNED (operands[2]))\n-    {\n-      emit_insn (gen_xorsi3_internal2 (operands[0],\n-\t\t\t\t       operands[1],\n-\t\t\t\t       operands[2],\n-\t\t\t\t       gen_reg_rtx (SImode)));\n-      DONE;\n-    }\n-}\")\n-\n-(define_insn \"xorsi3_internal1\"\n+(define_insn \"xorsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"d,d\")\n-\t\t(match_operand:SI 2 \"uns_arith_operand\" \"d,K\")))]\n+\t(xor:SI (match_operand:SI 1 \"arith32_operand\" \"%d,d\")\n+\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K\")))]\n   \"\"\n   \"@\n    xor\\\\t%0,%1,%2\n@@ -1432,50 +1237,6 @@ move\\\\t%0,%z4\\\\n\\\\\n    (set_attr \"mode\"\t\"SI\")\n    (set_attr \"length\"\t\"1\")])\n \n-(define_insn \"xorsi3_internal2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d,d,d\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"d,d,d,d\")\n-\t\t(match_operand:SI 2 \"arith32_operand\" \"d,K,I,M\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"=d,d,d,d\"))]\n-  \"\"\n-  \"@\n-   xor\\\\t%0,%1,%2\n-   xori\\\\t%0,%1,%x2\n-   li\\\\t%3,%X2\\\\t\\\\t# %2\\;xor\\\\t%0,%1,%3\n-   li\\\\t%3,%X2\\\\t\\\\t# %2\\;xor\\\\t%0,%1,%3\"\n-  [(set_attr \"type\"\t\"arith,arith,multi,multi\")\n-   (set_attr \"mode\"\t\"SI\")\n-   (set_attr \"length\"\t\"1,1,2,3\")])\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"lui_int\" \"\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n-\n-  [(set (match_dup 3) (match_dup 2))\n-   (set (match_dup 0) (xor:SI (match_dup 1) (match_dup 3)))]\n-  \"\")\n-\n-(define_split\n-  [(set (match_operand:SI 0 \"register_operand\" \"\")\n-\t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"large_int\" \"\")))\n-   (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"reload_completed && !TARGET_DEBUG_D_MODE\"\n-\n-  [(set (match_dup 3) (match_dup 4))\n-   (set (match_dup 3) (ior:SI (match_dup 3) (match_dup 5)))\n-   (set (match_dup 0) (xor:SI (match_dup 1) (match_dup 3)))]\n-  \"\n-{\n-  int val = INTVAL (operands[2]);\n-  operands[4] = gen_rtx (CONST_INT, VOIDmode, val & 0xffff0000);\n-  operands[5] = gen_rtx (CONST_INT, VOIDmode, val & 0x0000ffff);\n-}\")\n-\n-\n (define_insn \"xordi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=d\")\n \t(xor:DI (match_operand:DI 1 \"register_operand\" \"d\")"}]}