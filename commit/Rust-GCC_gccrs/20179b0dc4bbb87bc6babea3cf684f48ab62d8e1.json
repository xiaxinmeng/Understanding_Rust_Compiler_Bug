{"sha": "20179b0dc4bbb87bc6babea3cf684f48ab62d8e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAxNzliMGRjNGJiYjg3YmM2YmFiZWEzY2Y2ODRmNDhhYjYyZDhlMQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "sebastian.pop@amd.com", "date": "2009-11-25T04:32:35Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2009-11-25T04:32:35Z"}, "message": "tree-scalar-evolution.c (instantiate_scev_assign): New.\n\n2009-09-01  Sebastian Pop  <sebastian.pop@amd.com>\n\n\t* tree-scalar-evolution.c (instantiate_scev_assign): New.\n\tDo not call analyze_scalar_evolution on assignments.\n\t(instantiate_scev_phi): Call analyze_scalar_evolution.\n\t(instantiate_scev_name): Call instantiate_scev_assign and\n\tinstantiate_scev_phi.\n\t(instantiate_scev_not): Adapted to pass as parameters the operands\n\tof the not expression.\n\nFrom-SVN: r154541", "tree": {"sha": "f07834764ebb24043e1136742123ecb44f026efc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f07834764ebb24043e1136742123ecb44f026efc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20179b0dc4bbb87bc6babea3cf684f48ab62d8e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20179b0dc4bbb87bc6babea3cf684f48ab62d8e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20179b0dc4bbb87bc6babea3cf684f48ab62d8e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20179b0dc4bbb87bc6babea3cf684f48ab62d8e1/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ffa34f4ba28f411d65af4fa598c82c0d879f8a23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ffa34f4ba28f411d65af4fa598c82c0d879f8a23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ffa34f4ba28f411d65af4fa598c82c0d879f8a23"}], "stats": {"total": 192, "additions": 160, "deletions": 32}, "files": [{"sha": "7c2b950ecac91fcbd0d6a22554c055abc1ea36aa", "filename": "gcc/ChangeLog.graphite", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20179b0dc4bbb87bc6babea3cf684f48ab62d8e1/gcc%2FChangeLog.graphite", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20179b0dc4bbb87bc6babea3cf684f48ab62d8e1/gcc%2FChangeLog.graphite", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.graphite?ref=20179b0dc4bbb87bc6babea3cf684f48ab62d8e1", "patch": "@@ -1,3 +1,13 @@\n+2009-09-01  Sebastian Pop  <sebastian.pop@amd.com>\n+\n+\t* tree-scalar-evolution.c (instantiate_scev_assign): New.\n+\tDo not call analyze_scalar_evolution on assignments.\n+\t(instantiate_scev_phi): Call analyze_scalar_evolution.\n+\t(instantiate_scev_name): Call instantiate_scev_assign and\n+\tinstantiate_scev_phi.\n+\t(instantiate_scev_not): Adapted to pass as parameters the operands\n+\tof the not expression.\n+\n 2009-09-01  Sebastian Pop  <sebastian.pop@amd.com>\n \n \t* tree-scalar-evolution.c (instantiate_scev_binary): Adapted"}, {"sha": "41e95b48917c34c7e98c1590051a6c2e284ce5c6", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 150, "deletions": 32, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20179b0dc4bbb87bc6babea3cf684f48ab62d8e1/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20179b0dc4bbb87bc6babea3cf684f48ab62d8e1/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=20179b0dc4bbb87bc6babea3cf684f48ab62d8e1", "patch": "@@ -2109,13 +2109,21 @@ loop_closed_phi_def (tree var)\n   return NULL_TREE;\n }\n \n+static tree instantiate_scev_binary (basic_block, struct loop *, tree,\n+\t\t\t\t     enum tree_code, tree, tree, tree,\n+\t\t\t\t     bool, htab_t, int);\n+static tree instantiate_scev_convert (basic_block, struct loop *, tree, tree,\n+\t\t\t\t      tree, bool, htab_t, int);\n+static tree instantiate_scev_not (basic_block, struct loop *, tree,\n+\t\t\t\t  enum tree_code, tree, tree,\n+\t\t\t\t  bool, htab_t, int);\n static tree instantiate_scev_r (basic_block, struct loop *, tree, bool,\n \t\t\t\thtab_t, int);\n \n /* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n    and EVOLUTION_LOOP, that were left under a symbolic form.\n \n-   CHREC is an SSA_NAME to be instantiated.\n+   STMT is a GIMPLE assignment to be instantiated.\n \n    CACHE is the cache of already instantiated values.\n \n@@ -2127,38 +2135,90 @@ static tree instantiate_scev_r (basic_block, struct loop *, tree, bool,\n    instantiated, and to stop if it exceeds some limit.  */\n \n static tree\n-instantiate_scev_name (basic_block instantiate_below,\n-\t\t       struct loop *evolution_loop, tree chrec,\n-\t\t       bool fold_conversions, htab_t cache, int size_expr)\n+instantiate_scev_assign (basic_block instantiate_below,\n+\t\t\t struct loop *evolution_loop, gimple stmt,\n+\t\t\t bool fold_conversions, htab_t cache, int size_expr)\n {\n-  tree res;\n-  struct loop *def_loop;\n-  basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (chrec));\n+  tree type = TREE_TYPE (gimple_assign_lhs (stmt));\n+  tree rhs1 = gimple_assign_rhs1 (stmt);\n+  tree rhs2 = gimple_assign_rhs2 (stmt);\n+  enum tree_code code = gimple_assign_rhs_code (stmt);\n \n-  /* A parameter (or loop invariant and we do not want to include\n-     evolutions in outer loops), nothing to do.  */\n-  if (!def_bb\n-      || loop_depth (def_bb->loop_father) == 0\n-      || dominated_by_p (CDI_DOMINATORS, instantiate_below, def_bb))\n-    return chrec;\n+  if (get_gimple_rhs_class (code) == GIMPLE_SINGLE_RHS)\n+    {\n+      if (is_gimple_min_invariant (rhs1))\n+\treturn chrec_convert (type, rhs1, stmt);\n \n-  /* We cache the value of instantiated variable to avoid exponential\n-     time complexity due to reevaluations.  We also store the convenient\n-     value in the cache in order to prevent infinite recursion -- we do\n-     not want to instantiate the SSA_NAME if it is in a mixer\n-     structure.  This is used for avoiding the instantiation of\n-     recursively defined functions, such as:\n+      if (code == SSA_NAME)\n+\t{\n+\t  rhs1 = instantiate_scev_r (instantiate_below, evolution_loop, rhs1,\n+\t\t\t\t     fold_conversions, cache, size_expr);\n+\t  return chrec_convert (type, rhs1, stmt);\n+\t}\n \n-     | a_2 -> {0, +, 1, +, a_2}_1  */\n+      if (code == ASSERT_EXPR)\n+\t{\n+\t  rhs1 = ASSERT_EXPR_VAR (rhs1);\n+\t  rhs1 = instantiate_scev_r (instantiate_below, evolution_loop, rhs1,\n+\t\t\t\t     fold_conversions, cache, size_expr);\n+\t  return chrec_convert (type, rhs1, stmt);\n+\t}\n \n-  res = get_instantiated_value (cache, instantiate_below, chrec);\n-  if (res)\n-    return res;\n+      return chrec_dont_know;\n+    }\n \n-  res = chrec_dont_know;\n-  set_instantiated_value (cache, instantiate_below, chrec, res);\n+  switch (code)\n+    {\n+    case POINTER_PLUS_EXPR:\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+      return instantiate_scev_binary (instantiate_below, evolution_loop,\n+\t\t\t\t      NULL_TREE, code, type, rhs1, rhs2,\n+\t\t\t\t      fold_conversions, cache, size_expr);\n \n-  def_loop = find_common_loop (evolution_loop, def_bb->loop_father);\n+    case NEGATE_EXPR:\n+    case BIT_NOT_EXPR:\n+      return instantiate_scev_not (instantiate_below, evolution_loop,\n+\t\t\t\t   NULL_TREE, code, type, rhs1,\n+\t\t\t\t   fold_conversions, cache, size_expr);\n+\n+    CASE_CONVERT:\n+      return instantiate_scev_convert (instantiate_below, evolution_loop,\n+\t\t\t\t       NULL_TREE, type, rhs1,\n+\t\t\t\t       fold_conversions, cache, size_expr);\n+    default:\n+      return chrec_dont_know;\n+    }\n+}\n+\n+/* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n+   and EVOLUTION_LOOP, that were left under a symbolic form.\n+\n+   CHREC is an SSA_NAME defined by a GIMPLE PHI node.  As the PHI node\n+   belongs to the region to be instantiated, it is fully analyzed and\n+   transformed into a chain of recurrence.\n+\n+   CACHE is the cache of already instantiated values.\n+\n+   FOLD_CONVERSIONS should be set to true when the conversions that\n+   may wrap in signed/pointer type are folded, as long as the value of\n+   the chrec is preserved.\n+\n+   SIZE_EXPR is used for computing the size of the expression to be\n+   instantiated, and to stop if it exceeds some limit.  */\n+\n+static tree\n+instantiate_scev_phi (basic_block instantiate_below,\n+\t\t      struct loop *evolution_loop, tree chrec,\n+\t\t      bool fold_conversions, htab_t cache, int size_expr)\n+{\n+  tree res = chrec_dont_know;\n+  gimple def = SSA_NAME_DEF_STMT (chrec);\n+  basic_block def_bb = gimple_bb (def);\n+  loop_p def_loop = find_common_loop (evolution_loop, def_bb->loop_father);\n+\n+  set_instantiated_value (cache, instantiate_below, chrec, res);\n \n   /* If the analysis yields a parametric chrec, instantiate the\n      result again.  */\n@@ -2188,7 +2248,63 @@ instantiate_scev_name (basic_block instantiate_below,\n   /* Store the correct value to the cache.  */\n   set_instantiated_value (cache, instantiate_below, chrec, res);\n   return res;\n+}\n+\n+/* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n+   and EVOLUTION_LOOP, that were left under a symbolic form.\n+\n+   CHREC is an SSA_NAME to be instantiated.\n+\n+   CACHE is the cache of already instantiated values.\n+\n+   FOLD_CONVERSIONS should be set to true when the conversions that\n+   may wrap in signed/pointer type are folded, as long as the value of\n+   the chrec is preserved.\n+\n+   SIZE_EXPR is used for computing the size of the expression to be\n+   instantiated, and to stop if it exceeds some limit.  */\n+\n+static tree\n+instantiate_scev_name (basic_block instantiate_below,\n+\t\t       struct loop *evolution_loop, tree chrec,\n+\t\t       bool fold_conversions, htab_t cache, int size_expr)\n+{\n+  tree res;\n+  gimple def = SSA_NAME_DEF_STMT (chrec);\n+  basic_block def_bb = gimple_bb (def);\n+\n+  /* A parameter (or loop invariant and we do not want to include\n+     evolutions in outer loops), nothing to do.  */\n+  if (!def_bb\n+      || loop_depth (def_bb->loop_father) == 0\n+      || dominated_by_p (CDI_DOMINATORS, instantiate_below, def_bb))\n+    return chrec;\n \n+  /* We cache the value of instantiated variable to avoid exponential\n+     time complexity due to reevaluations.  We also store the convenient\n+     value in the cache in order to prevent infinite recursion -- we do\n+     not want to instantiate the SSA_NAME if it is in a mixer\n+     structure.  This is used for avoiding the instantiation of\n+     recursively defined functions, such as:\n+\n+     | a_2 -> {0, +, 1, +, a_2}_1  */\n+\n+  res = get_instantiated_value (cache, instantiate_below, chrec);\n+  if (res)\n+    return res;\n+\n+  /* Return the RHS  */\n+  switch (gimple_code (def))\n+    {\n+    case GIMPLE_ASSIGN:\n+      return instantiate_scev_assign (instantiate_below, evolution_loop, def,\n+\t\t\t\t      fold_conversions, cache, size_expr);\n+    case GIMPLE_PHI:\n+      return instantiate_scev_phi (instantiate_below, evolution_loop, chrec,\n+\t\t\t\t   fold_conversions, cache, size_expr);\n+    default:\n+      return chrec_dont_know;\n+    }\n }\n \n /* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n@@ -2356,20 +2472,20 @@ instantiate_scev_convert (basic_block instantiate_below,\n static tree\n instantiate_scev_not (basic_block instantiate_below,\n \t\t      struct loop *evolution_loop, tree chrec,\n+\t\t      enum tree_code code, tree type, tree op,\n \t\t      bool fold_conversions, htab_t cache, int size_expr)\n {\n-  tree type = chrec_type (chrec);\n-  tree op0 = instantiate_scev_r (instantiate_below, evolution_loop,\n-\t\t\t\t TREE_OPERAND (chrec, 0),\n+  tree op0 = instantiate_scev_r (instantiate_below, evolution_loop, op,\n \t\t\t\t fold_conversions, cache, size_expr);\n+\n   if (op0 == chrec_dont_know)\n     return chrec_dont_know;\n \n-  if (TREE_OPERAND (chrec, 0) != op0)\n+  if (op != op0)\n     {\n       op0 = chrec_convert (type, op0, NULL);\n \n-      switch (TREE_CODE (chrec))\n+      switch (code)\n \t{\n \tcase BIT_NOT_EXPR:\n \t  return chrec_fold_minus\n@@ -2384,7 +2500,7 @@ instantiate_scev_not (basic_block instantiate_below,\n \t}\n     }\n \n-  return chrec;\n+  return chrec ? chrec : fold_build1 (code, type, op0);\n }\n \n /* Analyze all the parameters of the chrec, between INSTANTIATE_BELOW\n@@ -2560,6 +2676,8 @@ instantiate_scev_r (basic_block instantiate_below,\n     case NEGATE_EXPR:\n     case BIT_NOT_EXPR:\n       return instantiate_scev_not (instantiate_below, evolution_loop, chrec,\n+\t\t\t\t   TREE_CODE (chrec), TREE_TYPE (chrec),\n+\t\t\t\t   TREE_OPERAND (chrec, 0),\n \t\t\t\t   fold_conversions, cache, size_expr);\n \n     case SCEV_NOT_KNOWN:"}]}