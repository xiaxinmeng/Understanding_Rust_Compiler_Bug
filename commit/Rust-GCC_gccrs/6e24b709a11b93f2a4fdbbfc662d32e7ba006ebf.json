{"sha": "6e24b709a11b93f2a4fdbbfc662d32e7ba006ebf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmUyNGI3MDlhMTFiOTNmMmE0ZmRiYmZjNjYyZDMyZTdiYTAwNmViZg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-03-14T03:21:43Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-03-14T03:21:43Z"}, "message": "alias.c (handled_component_p, [...]): New functions.\n\n\t* alias.c (handled_component_p, can_address_p): New functions.\n\t(get_alias_set): Use them.\n\nFrom-SVN: r40449", "tree": {"sha": "d754afaf3e715d73ac6c2dd0917606a98c462b82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d754afaf3e715d73ac6c2dd0917606a98c462b82"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e24b709a11b93f2a4fdbbfc662d32e7ba006ebf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e24b709a11b93f2a4fdbbfc662d32e7ba006ebf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e24b709a11b93f2a4fdbbfc662d32e7ba006ebf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e24b709a11b93f2a4fdbbfc662d32e7ba006ebf/comments", "author": null, "committer": null, "parents": [{"sha": "9502c55830f2de2066d1671567d88a2a78361103", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9502c55830f2de2066d1671567d88a2a78361103", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9502c55830f2de2066d1671567d88a2a78361103"}], "stats": {"total": 91, "additions": 62, "deletions": 29}, "files": [{"sha": "d723d45dc0cf8f459cc7ebdcac9c5c06fe241b29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e24b709a11b93f2a4fdbbfc662d32e7ba006ebf/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e24b709a11b93f2a4fdbbfc662d32e7ba006ebf/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e24b709a11b93f2a4fdbbfc662d32e7ba006ebf", "patch": "@@ -1,3 +1,8 @@\n+Tue Mar 13 22:22:04 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* alias.c (handled_component_p, can_address_p): New functions.\n+\t(get_alias_set): Use them.\n+\n 2001-03-13  Jim Wilson  <wilson@redhat.com>\n \n \t* config/ia64/ia64.c (find_gr_spill): Subtract frame_pointer_needed"}, {"sha": "4aca90d5b7c2f1c419ab07b657da034436873f05", "filename": "gcc/alias.c", "status": "modified", "additions": 57, "deletions": 29, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e24b709a11b93f2a4fdbbfc662d32e7ba006ebf/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e24b709a11b93f2a4fdbbfc662d32e7ba006ebf/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=6e24b709a11b93f2a4fdbbfc662d32e7ba006ebf", "patch": "@@ -1,5 +1,5 @@\n /* Alias analysis for GNU C\n-   Copyright (C) 1997, 1998, 1999, 2000 Free Software Foundation, Inc.\n+   Copyright (C) 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n    Contributed by John Carr (jfc@mit.edu).\n \n This file is part of GNU CC.\n@@ -95,6 +95,8 @@ static void record_set\t\t\tPARAMS ((rtx, rtx, void *));\n static rtx find_base_term\t\tPARAMS ((rtx));\n static int base_alias_check\t\tPARAMS ((rtx, rtx, enum machine_mode,\n \t\t\t\t\t\t enum machine_mode));\n+static int handled_component_p\t\tPARAMS ((tree));\n+static int can_address_p\t\tPARAMS ((tree));\n static rtx find_base_value\t\tPARAMS ((rtx));\n static int mems_in_disjoint_alias_sets_p PARAMS ((rtx, rtx));\n static int insert_subset_children       PARAMS ((splay_tree_node, void*));\n@@ -400,6 +402,58 @@ find_base_decl (t)\n     }\n }\n \n+/* Return 1 if T is an expression that get_inner_reference handles.  */\n+\n+static int\n+handled_component_p (t)\n+     tree t;\n+{\n+  switch (TREE_CODE (t))\n+    {\n+    case BIT_FIELD_REF:\n+    case COMPONENT_REF:\n+    case ARRAY_REF:\n+    case NON_LVALUE_EXPR:\n+      return 1;\n+\n+    case NOP_EXPR:\n+    case CONVERT_EXPR:\n+      return (TYPE_MODE (TREE_TYPE (t))\n+\t      == TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 0))));\n+\n+    default:\n+      return 0;\n+    }\n+}\n+\n+/* Return 1 if all the nested component references handled by\n+   get_inner_reference in T are such that we can address the object in T.  */\n+\n+static int\n+can_address_p (t)\n+     tree t;\n+{\n+  /* If we're at the end, it is vacuously addressable.  */\n+  if (! handled_component_p (t))\n+    return 1;\n+\n+  /* Bitfields are never addressable.  */\n+  else if (TREE_CODE (t) == BIT_FIELD_REF)\n+    return 0;\n+\n+  else if (TREE_CODE (t) == COMPONENT_REF\n+\t   && ! DECL_NONADDRESSABLE_P (TREE_OPERAND (t, 1))\n+\t   && can_address_p (TREE_OPERAND (t, 0)))\n+    return 1;\n+\n+  else if (TREE_CODE (t) == ARRAY_REF\n+\t   && ! TYPE_NONALIASED_COMPONENT (TREE_TYPE (TREE_OPERAND (t, 0)))\n+\t   && can_address_p (TREE_OPERAND (t, 0)))\n+    return 1;\n+\n+  return 0;\n+}\n+\n /* Return the alias set for T, which may be either a type or an\n    expression.  Call language-specific routine for help, if needed.  */\n \n@@ -439,35 +493,9 @@ get_alias_set (t)\n       /* Now loop the same way as get_inner_reference and get the alias\n \t set to use.  Pick up the outermost object that we could have\n \t a pointer to.  */\n-      while (1)\n-\t{\n-\t  /* Unnamed bitfields are not an addressable object.  */\n-\t  if (TREE_CODE (t) == BIT_FIELD_REF)\n-\t    ;\n-\t  else if (TREE_CODE (t) == COMPONENT_REF)\n-\t    {\n-\t      if (! DECL_NONADDRESSABLE_P (TREE_OPERAND (t, 1)))\n-\t\t/* Stop at an adressable decl.  */\n-\t\tbreak;\n-\t    }\n-\t  else if (TREE_CODE (t) == ARRAY_REF)\n-\t    {\n-\t      if (! TYPE_NONALIASED_COMPONENT\n-\t\t  (TREE_TYPE (TREE_OPERAND (t, 0))))\n-\t\t/* Stop at an addresssable array element.  */\n-\t\tbreak;\n-\t    }\n-\t  else if (TREE_CODE (t) != NON_LVALUE_EXPR\n-\t\t   && ! ((TREE_CODE (t) == NOP_EXPR\n-\t\t      || TREE_CODE (t) == CONVERT_EXPR)\n-\t\t     && (TYPE_MODE (TREE_TYPE (t))\n-\t\t\t == TYPE_MODE (TREE_TYPE (TREE_OPERAND (t, 0))))))\n-\t    /* Stop if not one of above and not mode-preserving conversion. */\n-\t    break;\n+      while (handled_component_p (t) && ! can_address_p (t))\n+\tt = TREE_OPERAND (t, 0);\n \n-\t  t = TREE_OPERAND (t, 0);\n-\t}\n-\t\t   \n       if (TREE_CODE (t) == INDIRECT_REF)\n \t{\n \t  /* Check for accesses through restrict-qualified pointers.  */"}]}