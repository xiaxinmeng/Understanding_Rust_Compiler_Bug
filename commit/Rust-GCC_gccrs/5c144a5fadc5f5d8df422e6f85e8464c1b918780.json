{"sha": "5c144a5fadc5f5d8df422e6f85e8464c1b918780", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMxNDRhNWZhZGM1ZjVkOGRmNDIyZTZmODVlODQ2NGMxYjkxODc4MA==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-07-05T14:49:04Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-07-05T14:49:04Z"}, "message": "constants.c (build_constants_constructor): Use build_constructor instead of build_constructor_from_list.\n\n\t* constants.c (build_constants_constructor): Use build_constructor\n\tinstead of build_constructor_from_list.\n\t* class.c (make_method_value): Likewise.\n\t(get_dispatch_table): Likewise.\n\t(make_class_data): Likewise.\n\t(emit_indirect_register_classes): Likewise.\n\t(emit_symbol_table): Likewise.\n\t(add_assertion_table_entry): Likewise.\n\t(emit_assertion_table): Likewise.\n\t(make_field_value): Use build_constructor_single instead of\n\tbuild_constructor_from_list.\n\nFrom-SVN: r161839", "tree": {"sha": "0d67528841d30ebb60491a66310a253baac963b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0d67528841d30ebb60491a66310a253baac963b2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c144a5fadc5f5d8df422e6f85e8464c1b918780", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c144a5fadc5f5d8df422e6f85e8464c1b918780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c144a5fadc5f5d8df422e6f85e8464c1b918780", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c144a5fadc5f5d8df422e6f85e8464c1b918780/comments", "author": null, "committer": null, "parents": [{"sha": "f2896bc9618bdc052563ee59d479b425a8442943", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2896bc9618bdc052563ee59d479b425a8442943", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2896bc9618bdc052563ee59d479b425a8442943"}], "stats": {"total": 242, "additions": 138, "deletions": 104}, "files": [{"sha": "47f6cb0329cb8e36672167565f622fc235673320", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c144a5fadc5f5d8df422e6f85e8464c1b918780/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c144a5fadc5f5d8df422e6f85e8464c1b918780/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=5c144a5fadc5f5d8df422e6f85e8464c1b918780", "patch": "@@ -1,3 +1,17 @@\n+2010-07-05  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* constants.c (build_constants_constructor): Use build_constructor\n+\tinstead of build_constructor_from_list.\n+\t* class.c (make_method_value): Likewise.\n+\t(get_dispatch_table): Likewise.\n+\t(make_class_data): Likewise.\n+\t(emit_indirect_register_classes): Likewise.\n+\t(emit_symbol_table): Likewise.\n+\t(add_assertion_table_entry): Likewise.\n+\t(emit_assertion_table): Likewise.\n+\t(make_field_value): Use build_constructor_single instead of\n+\tbuild_constructor_from_list.\n+\n 2010-06-28  Nathan Froyd  <froydnj@codesourcery.com>\n \n \t* java-tree.h (struct lang_type) [catch_classes]: Change type to a"}, {"sha": "3380af2fe8db4dbb0e6a071f6fd7d9fcff39ce55", "filename": "gcc/java/class.c", "status": "modified", "additions": 95, "deletions": 82, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c144a5fadc5f5d8df422e6f85e8464c1b918780/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c144a5fadc5f5d8df422e6f85e8464c1b918780/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=5c144a5fadc5f5d8df422e6f85e8464c1b918780", "patch": "@@ -1453,20 +1453,21 @@ make_field_value (tree fdecl)\n \n   {\n     tree field_address = integer_zero_node;\n+    tree index, value;\n     if ((DECL_INITIAL (fdecl) || ! flag_indirect_classes) \n \t&& FIELD_STATIC (fdecl))\n       field_address = build_address_of (fdecl);\n \n-    PUSH_FIELD_VALUE\n-      (v, \"info\",\n-       build_constructor_from_list (field_info_union_node,\n-\t build_tree_list\n-\t   ((FIELD_STATIC (fdecl)\n+    index = (FIELD_STATIC (fdecl)\n \t     ? TREE_CHAIN (TYPE_FIELDS (field_info_union_node))\n-\t     : TYPE_FIELDS (field_info_union_node)),\n-\t    (FIELD_STATIC (fdecl)\n+\t     : TYPE_FIELDS (field_info_union_node));\n+    value = (FIELD_STATIC (fdecl)\n \t     ? field_address\n-\t     : byte_position (fdecl)))));\n+\t     : byte_position (fdecl));\n+\n+    PUSH_FIELD_VALUE\n+      (v, \"info\",\n+       build_constructor_single (field_info_union_node, index, value));\n   }\n \n   FINISH_RECORD_CONSTRUCTOR (finit, v, field_type_node);\n@@ -1524,14 +1525,23 @@ make_method_value (tree mdecl)\n   {\n     /* Compute the `throws' information for the method.  */\n     tree table = null_pointer_node;\n-    if (DECL_FUNCTION_THROWS (mdecl) != NULL)\n+\n+    if (!VEC_empty (tree, DECL_FUNCTION_THROWS (mdecl)))\n       {\n \tint length = 1 + VEC_length (tree, DECL_FUNCTION_THROWS (mdecl));\n \ttree t, type, array;\n \tchar buf[60];\n-        unsigned ix;\n+\tVEC(constructor_elt,gc) *v = NULL;\n+\tint idx = length - 1;\n+\tunsigned ix;\n+\tconstructor_elt *e;\n+\n+\tv = VEC_alloc (constructor_elt, gc, length);\n+\tVEC_safe_grow_cleared (constructor_elt, gc, v, length);\n+\n+\te = VEC_index (constructor_elt, v, idx--);\n+\te->value = null_pointer_node;\n \n-\ttable = tree_cons (NULL_TREE, table, NULL_TREE);\n \tfor (ix = 0;\n \t     VEC_iterate (tree, DECL_FUNCTION_THROWS (mdecl), ix, t);\n \t     ix++)\n@@ -1540,10 +1550,12 @@ make_method_value (tree mdecl)\n \t    tree utf8\n \t      = build_utf8_ref (unmangle_classname (IDENTIFIER_POINTER (sig),\n \t\t\t\t\t\t    IDENTIFIER_LENGTH (sig)));\n-\t    table = tree_cons (NULL_TREE, utf8, table);\n+\t    e = VEC_index (constructor_elt, v, idx--);\n+\t    e->value = utf8;\n \t  }\n+\tgcc_assert (idx == -1);\n \ttype = build_prim_array_type (ptr_type_node, length);\n-\ttable = build_constructor_from_list (type, table);\n+\ttable = build_constructor (type, v);\n \t/* Compute something unique enough.  */\n \tsprintf (buf, \"_methods%d\", method_name_count++);\n \tarray = build_decl (input_location,\n@@ -1604,11 +1616,22 @@ get_dispatch_table (tree type, tree this_class_addr)\n   int abstract_p = CLASS_ABSTRACT (TYPE_NAME (type));\n   tree vtable = get_dispatch_vector (type);\n   int i, j;\n-  tree list = NULL_TREE;\n   int nvirtuals = TREE_VEC_LENGTH (vtable);\n   int arraysize;\n   tree gc_descr;\n+  VEC(constructor_elt,gc) *v = NULL;\n+  constructor_elt *e;\n+  tree arraytype;\n+\n+  arraysize = (TARGET_VTABLE_USES_DESCRIPTORS? nvirtuals + 1 : nvirtuals + 2);\n+  if (TARGET_VTABLE_USES_DESCRIPTORS)\n+    arraysize *= TARGET_VTABLE_USES_DESCRIPTORS;\n+  arraysize += 2;\n \n+  VEC_safe_grow_cleared (constructor_elt, gc, v, arraysize);\n+  e = VEC_index (constructor_elt, v, arraysize - 1);\n+\n+#define CONSTRUCTOR_PREPEND_VALUE(E, V) E->value = V, E--\n   for (i = nvirtuals;  --i >= 0; )\n     {\n       tree method = TREE_VEC_ELT (vtable, i);\n@@ -1620,9 +1643,9 @@ get_dispatch_table (tree type, tree this_class_addr)\n \n \t  if (TARGET_VTABLE_USES_DESCRIPTORS)\n \t    for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; ++j)\n-\t      list = tree_cons (NULL_TREE, null_pointer_node, list);\n+\t      CONSTRUCTOR_PREPEND_VALUE (e, null_pointer_node);\n \t  else\n-\t    list = tree_cons (NULL_TREE, null_pointer_node, list);\n+\t    CONSTRUCTOR_PREPEND_VALUE (e, null_pointer_node);\n \t}\n       else\n \t{\n@@ -1632,13 +1655,13 @@ get_dispatch_table (tree type, tree this_class_addr)\n \t\ttree fdesc = build2 (FDESC_EXPR, nativecode_ptr_type_node, \n \t\t\t\t     method, build_int_cst (NULL_TREE, j));\n \t\tTREE_CONSTANT (fdesc) = 1;\n-\t        list = tree_cons (NULL_TREE, fdesc, list);\n+\t\tCONSTRUCTOR_PREPEND_VALUE (e, fdesc);\n \t      }\n \t  else\n-\t    list = tree_cons (NULL_TREE,\n-\t\t\t      build1 (ADDR_EXPR, nativecode_ptr_type_node,\n-\t\t\t\t      method),\n-\t\t\t      list);\n+\t    CONSTRUCTOR_PREPEND_VALUE (e,\n+\t\t\t\t       build1 (ADDR_EXPR,\n+\t\t\t\t\t       nativecode_ptr_type_node,\n+\t\t\t\t\t       method));\n \t}\n     }\n \n@@ -1651,23 +1674,21 @@ get_dispatch_table (tree type, tree this_class_addr)\n      pointer, and subsequent words (usually one) contain the GC descriptor.\n      In all other cases, we reserve two extra vtable slots. */\n   gc_descr =  get_boehm_type_descriptor (type);\n-  list = tree_cons (NULL_TREE, gc_descr, list);\n+  CONSTRUCTOR_PREPEND_VALUE (e, gc_descr);\n   for (j = 1; j < TARGET_VTABLE_USES_DESCRIPTORS-1; ++j)\n-    list = tree_cons (NULL_TREE, gc_descr, list);\n-  list = tree_cons (NULL_TREE, this_class_addr, list);\n+    CONSTRUCTOR_PREPEND_VALUE (e, gc_descr);\n+  CONSTRUCTOR_PREPEND_VALUE (e, this_class_addr);\n \n   /** Pointer to type_info object (to be implemented), according to g++ ABI. */\n-  list = tree_cons (NULL_TREE, null_pointer_node, list);\n+  CONSTRUCTOR_PREPEND_VALUE (e, null_pointer_node);\n   /** Offset to start of whole object.  Always (ptrdiff_t)0 for Java. */\n-  list = tree_cons (integer_zero_node, null_pointer_node, list);\n+  gcc_assert (e == VEC_address (constructor_elt, v));\n+  e->index = integer_zero_node;\n+  e->value = null_pointer_node;\n+#undef CONSTRUCTOR_PREPEND_VALUE\n \n-  arraysize = (TARGET_VTABLE_USES_DESCRIPTORS? nvirtuals + 1 : nvirtuals + 2);\n-  if (TARGET_VTABLE_USES_DESCRIPTORS)\n-    arraysize *= TARGET_VTABLE_USES_DESCRIPTORS;\n-  arraysize += 2;\n-  return build_constructor_from_list\n-\t  (build_prim_array_type (nativecode_ptr_type_node,\n-\t\t\t\t  arraysize), list);\n+  arraytype = build_prim_array_type (nativecode_ptr_type_node, arraysize);\n+  return build_constructor (arraytype, v);\n }\n \n \n@@ -1751,14 +1772,11 @@ make_class_data (tree type)\n {\n   tree decl, cons, temp;\n   tree field, fields_decl;\n-  tree static_fields = NULL_TREE;\n-  tree instance_fields = NULL_TREE;\n   HOST_WIDE_INT static_field_count = 0;\n   HOST_WIDE_INT instance_field_count = 0;\n   HOST_WIDE_INT field_count;\n   tree field_array_type;\n   tree method;\n-  tree methods = NULL_TREE;\n   tree dtable_decl = NULL_TREE;\n   HOST_WIDE_INT method_count = 0;\n   tree method_array_type;\n@@ -1779,6 +1797,9 @@ make_class_data (tree type)\n   tree first_real_field;\n   VEC(constructor_elt,gc) *v1 = NULL, *v2 = NULL;\n   tree reflection_data;\n+  VEC(constructor_elt,gc) *static_fields = NULL;\n+  VEC(constructor_elt,gc) *instance_fields = NULL;\n+  VEC(constructor_elt,gc) *methods = NULL;\n \n   this_class_addr = build_static_class_ref (type);\n   decl = TREE_OPERAND (this_class_addr, 0);\n@@ -1882,7 +1903,7 @@ make_class_data (tree type)\n                  as it is used in the creation of the field itself. */\n               tree init = make_field_value (field);\n \t      tree initial = DECL_INITIAL (field);\n-\t      static_fields = tree_cons (NULL_TREE, init, static_fields);\n+              CONSTRUCTOR_APPEND_ELT (static_fields, NULL_TREE, init);\n \t      /* If the initial value is a string constant,\n \t\t prevent output_constant from trying to assemble the value. */\n \t      if (initial != NULL_TREE\n@@ -1894,22 +1915,25 @@ make_class_data (tree type)\n \t  else if (uses_jv_markobj || !flag_reduced_reflection)\n \t    {\n               tree init = make_field_value (field);\n-\t      instance_fields = tree_cons (NULL_TREE, init, instance_fields);\n+              CONSTRUCTOR_APPEND_ELT (instance_fields, NULL_TREE, init);\n \t    }\n \t}\n     }\n \n+  gcc_assert (static_field_count\n+              == VEC_length (constructor_elt, static_fields));\n+  gcc_assert (instance_field_count\n+              == VEC_length (constructor_elt, instance_fields));\n+\n   if (field_count > 0)\n     {\n-      static_fields = nreverse (static_fields);\n-      instance_fields = nreverse (instance_fields);\n-      static_fields = chainon (static_fields, instance_fields);\n+      VEC_safe_splice (constructor_elt, gc, static_fields, instance_fields);\n       field_array_type = build_prim_array_type (field_type_node, field_count);\n       fields_decl = build_decl (input_location,\n \t\t\t\tVAR_DECL, mangled_classname (\"_FL_\", type),\n \t\t\t\tfield_array_type);\n-      DECL_INITIAL (fields_decl) = build_constructor_from_list\n-\t\t\t\t    (field_array_type, static_fields);\n+      DECL_INITIAL (fields_decl)\n+        = build_constructor (field_array_type, static_fields);\n       TREE_STATIC (fields_decl) = 1;\n       DECL_ARTIFICIAL (fields_decl) = 1;\n       DECL_IGNORED_P (fields_decl) = 1;\n@@ -1958,15 +1982,14 @@ make_class_data (tree type)\n         {\n           init = make_method_value (method);\n           method_count++;\n-          methods = tree_cons (NULL_TREE, init, methods);\n+          CONSTRUCTOR_APPEND_ELT (methods, NULL_TREE, init);\n         }\n     }\n   method_array_type = build_prim_array_type (method_type_node, method_count);\n   methods_decl = build_decl (input_location,\n \t\t\t     VAR_DECL, mangled_classname (\"_MT_\", type),\n \t\t\t     method_array_type);\n-  DECL_INITIAL (methods_decl) = build_constructor_from_list\n-\t\t\t\t (method_array_type, nreverse (methods));\n+  DECL_INITIAL (methods_decl) = build_constructor (method_array_type, methods);\n   TREE_STATIC (methods_decl) = 1;\n   DECL_ARTIFICIAL (methods_decl) = 1;\n   DECL_IGNORED_P (methods_decl) = 1;\n@@ -2004,16 +2027,17 @@ make_class_data (tree type)\n   \n   if (interface_len > 0)\n     {\n-      tree init = NULL_TREE;\n       int i;\n       tree interface_array_type, idecl;\n+      VEC(constructor_elt,gc) *init = VEC_alloc (constructor_elt, gc,\n+\t\t\t\t\t\t interface_len);\n       interface_array_type\n \t= build_prim_array_type (class_ptr_type, interface_len);\n       idecl = build_decl (input_location,\n \t\t\t  VAR_DECL, mangled_classname (\"_IF_\", type),\n \t\t\t  interface_array_type);\n       \n-      for (i = interface_len;  i > 0; i--)\n+      for (i = 1; i <= interface_len; i++)\n \t{\n \t  tree child = BINFO_BASE_BINFO (TYPE_BINFO (type), i);\n \t  tree iclass = BINFO_TYPE (child);\n@@ -2027,10 +2051,9 @@ make_class_data (tree type)\n \t      int int_index = alloc_class_constant (iclass);\n \t      index = build_int_cst (ptr_type_node, int_index);\n \t    }\n-\t  init = tree_cons (NULL_TREE, index, init); \n+\t  CONSTRUCTOR_APPEND_ELT (init, NULL_TREE, index);\n \t}\n-      DECL_INITIAL (idecl) = build_constructor_from_list (interface_array_type,\n-\t\t\t\t\t\t\t  init);\n+      DECL_INITIAL (idecl) = build_constructor (interface_array_type, init);\n       TREE_STATIC (idecl) = 1;\n       DECL_ARTIFICIAL (idecl) = 1;\n       DECL_IGNORED_P (idecl) = 1;\n@@ -2729,8 +2752,8 @@ emit_indirect_register_classes (tree *list_p)\n   tree klass, t, register_class_fn;\n   int i;\n \n-  tree init = NULL_TREE;\n   int size = VEC_length (tree, registered_class) * 2 + 1;\n+  VEC(constructor_elt,gc) *init = VEC_alloc (constructor_elt, gc, size);\n   tree class_array_type\n     = build_prim_array_type (ptr_type_node, size);\n   tree cdecl = build_decl (input_location,\n@@ -2739,18 +2762,14 @@ emit_indirect_register_classes (tree *list_p)\n   tree reg_class_list;\n   for (i = 0; VEC_iterate (tree, registered_class, i, klass); ++i)\n     {\n-      init = tree_cons (NULL_TREE, \n-\t\t\tfold_convert (ptr_type_node, \n-\t\t\t\t      build_static_class_ref (klass)), init);\n-      init = tree_cons \n-\t(NULL_TREE, \n-\t fold_convert (ptr_type_node, \n-\t\t       build_address_of (build_classdollar_field (klass))),\n-\t init);\n-    }\n-  init = tree_cons (NULL_TREE, integer_zero_node, init); \n-  DECL_INITIAL (cdecl) = build_constructor_from_list (class_array_type,\n-\t\t\t\t\t\t      nreverse (init));\n+      t = fold_convert (ptr_type_node, build_static_class_ref (klass));\n+      CONSTRUCTOR_APPEND_ELT (init, NULL_TREE, t);\n+      t = fold_convert (ptr_type_node,\n+                        build_address_of (build_classdollar_field (klass)));\n+      CONSTRUCTOR_APPEND_ELT (init, NULL_TREE, t);\n+    }\n+  CONSTRUCTOR_APPEND_ELT (init, NULL_TREE, integer_zero_node);\n+  DECL_INITIAL (cdecl) = build_constructor (class_array_type, init);\n   TREE_CONSTANT (DECL_INITIAL (cdecl)) = 1;\n   TREE_STATIC (cdecl) = 1;\n   DECL_ARTIFICIAL (cdecl) = 1;\n@@ -2896,32 +2915,28 @@ emit_symbol_table (tree name, tree the_table,\n                    tree the_syms_decl, tree the_array_element_type,\n \t\t   int element_size)\n {\n-  tree table, list, null_symbol;\n-  tree table_size, the_array_type;\n+  tree table, null_symbol, table_size, the_array_type;\n   unsigned index;\n   method_entry *e;\n+  VEC(constructor_elt,gc) *v = NULL;\n   \n   /* Only emit a table if this translation unit actually made any\n      references via it. */\n   if (decl_table == NULL)\n     return the_table;\n \n   /* Build a list of _Jv_MethodSymbols for each entry in otable_methods. */\n-  list = NULL_TREE;\n   for (index = 0; VEC_iterate (method_entry, decl_table, index, e); index++)\n-    list = tree_cons (NULL_TREE,\n-\t\t      build_symbol_entry (e->method, e->special),\n-\t\t      list);\n+    CONSTRUCTOR_APPEND_ELT (v, NULL_TREE,\n+\t\t\t    build_symbol_entry (e->method, e->special));\n \n   /* Terminate the list with a \"null\" entry. */\n   null_symbol = build_symbol_table_entry (null_pointer_node,\n                                           null_pointer_node,\n                                           null_pointer_node);\n-  list = tree_cons (NULL_TREE, null_symbol, list);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, null_symbol);\n \n-  /* Put the list in the right order and make it a constructor. */\n-  list = nreverse (list);\n-  table = build_constructor_from_list (symbols_array_type, list);  \n+  table = build_constructor (symbols_array_type, v);\n \n   /* Make it the initial value for otable_syms and emit the decl. */\n   DECL_INITIAL (the_syms_decl) = table;\n@@ -3033,7 +3048,7 @@ add_assertion_table_entry (void **htab_entry, void *ptr)\n {\n   tree entry;\n   tree code_val, op1_utf8, op2_utf8;\n-  tree *list = (tree *) ptr;\n+  VEC(constructor_elt,gc) **v = (VEC(constructor_elt,gc) **) ptr;\n   type_assertion *as = (type_assertion *) *htab_entry;\n \n   code_val = build_int_cst (NULL_TREE, as->assertion_code);\n@@ -3050,7 +3065,7 @@ add_assertion_table_entry (void **htab_entry, void *ptr)\n \n   entry = build_assertion_table_entry (code_val, op1_utf8, op2_utf8);\n   \n-  *list = tree_cons (NULL_TREE, entry, *list);\n+  CONSTRUCTOR_APPEND_ELT (*v, NULL_TREE, entry);\n   return true;\n }\n \n@@ -3060,22 +3075,20 @@ static tree\n emit_assertion_table (tree klass)\n {\n   tree null_entry, ctor, table_decl;\n-  tree list = NULL_TREE;\n   htab_t assertions_htab = TYPE_ASSERTIONS (klass);\n+  VEC(constructor_elt,gc) *v = NULL;\n \n   /* Iterate through the hash table.  */\n-  htab_traverse (assertions_htab, add_assertion_table_entry, &list);\n+  htab_traverse (assertions_htab, add_assertion_table_entry, &v);\n \n   /* Finish with a null entry.  */\n   null_entry = build_assertion_table_entry (integer_zero_node,\n                                             null_pointer_node,\n                                             null_pointer_node);\n   \n-  list = tree_cons (NULL_TREE, null_entry, list);\n+  CONSTRUCTOR_APPEND_ELT (v, NULL_TREE, null_entry);\n   \n-  /* Put the list in the right order and make it a constructor. */\n-  list = nreverse (list);\n-  ctor = build_constructor_from_list (assertion_table_type, list);\n+  ctor = build_constructor (assertion_table_type, v);\n \n   table_decl = build_decl (input_location,\n \t\t\t   VAR_DECL, mangled_classname (\"_type_assert_\", klass),"}, {"sha": "1bb434ff00040917057685d47899b2ed95fdfa56", "filename": "gcc/java/constants.c", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c144a5fadc5f5d8df422e6f85e8464c1b918780/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c144a5fadc5f5d8df422e6f85e8464c1b918780/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=5c144a5fadc5f5d8df422e6f85e8464c1b918780", "patch": "@@ -501,11 +501,23 @@ build_constants_constructor (void)\n   CPool *outgoing_cpool = cpool_for_class (current_class);\n   tree tags_value, data_value;\n   tree cons;\n-  tree tags_list = NULL_TREE;\n-  tree data_list = NULL_TREE;\n   VEC(constructor_elt,gc) *v = NULL;\n   int i;\n+  VEC(constructor_elt,gc) *tags = NULL;\n+  VEC(constructor_elt,gc) *data = NULL;\n+  constructor_elt *t = NULL;\n+  constructor_elt *d = NULL;\n \n+  if (outgoing_cpool->count > 0)\n+    {\n+      int c = outgoing_cpool->count;\n+      VEC_safe_grow_cleared (constructor_elt, gc, tags, c);\n+      VEC_safe_grow_cleared (constructor_elt, gc, data, c);\n+      t = VEC_index (constructor_elt, tags, c-1);\n+      d = VEC_index (constructor_elt, data, c-1);\n+    }\n+\n+#define CONSTRUCTOR_PREPEND_VALUE(E, V) E->value = V, E--\n   for (i = outgoing_cpool->count;  --i > 0; )\n     switch (outgoing_cpool->tags[i] & ~CONSTANT_LazyFlag)\n       {\n@@ -530,32 +542,27 @@ build_constants_constructor (void)\n \t  if (BYTES_BIG_ENDIAN && POINTER_SIZE > 32)\n \t    temp <<= POINTER_SIZE - 32;\n \n-\t  tags_list\n-\t    = tree_cons (NULL_TREE, get_tag_node (outgoing_cpool->tags[i]),\n-\t\t\t tags_list);\n-\t  data_list\n-\t    = tree_cons (NULL_TREE, \n-\t\t\t fold_convert (ptr_type_node, \n-\t\t\t\t       (build_int_cst (NULL_TREE, temp))),\n-\t\t\t data_list);\n+          CONSTRUCTOR_PREPEND_VALUE (t, get_tag_node (outgoing_cpool->tags[i]));\n+          CONSTRUCTOR_PREPEND_VALUE (d,\n+                                     fold_convert (ptr_type_node, \n+                                                   (build_int_cst (NULL_TREE,\n+                                                                   temp))));\n \t}\n \tbreak;\n \n       case CONSTANT_Class:\n       case CONSTANT_String:\n       case CONSTANT_Unicode:\n       case CONSTANT_Utf8:\n-\ttags_list\n-\t  = tree_cons (NULL_TREE, get_tag_node (outgoing_cpool->tags[i]),\n-\t\t       tags_list);\n-\tdata_list\n-\t  = tree_cons (NULL_TREE, build_utf8_ref (outgoing_cpool->data[i].t),\n-\t\t       data_list);\n+        CONSTRUCTOR_PREPEND_VALUE (t, get_tag_node (outgoing_cpool->tags[i]));\n+        CONSTRUCTOR_PREPEND_VALUE (d, build_utf8_ref (outgoing_cpool->data[i].t));\n \tbreak;\n \n       default:\n \tgcc_assert (false);\n       }\n+#undef CONSTRUCTOR_PREPEND_VALUE\n+\n   if (outgoing_cpool->count > 0)\n     {\n       tree data_decl, tags_decl, tags_type;\n@@ -564,8 +571,10 @@ build_constants_constructor (void)\n       tree tem;\n \n       /* Add dummy 0'th element of constant pool. */\n-      tags_list = tree_cons (NULL_TREE, get_tag_node (0), tags_list);\n-      data_list = tree_cons (NULL_TREE, null_pointer_node, data_list);\n+      gcc_assert (t == VEC_address (constructor_elt, tags));\n+      gcc_assert (d == VEC_address (constructor_elt, data));\n+      t->value = get_tag_node (0);\n+      d->value = null_pointer_node;\n   \n       /* Change the type of the decl to have the proper array size.\n          ???  Make sure to transition the old type-pointer-to list to this\n@@ -577,8 +586,7 @@ build_constants_constructor (void)\n       TYPE_POINTER_TO (TREE_TYPE (data_decl)) = NULL_TREE;\n       TREE_TYPE (data_decl) = build_array_type (ptr_type_node, index_type);\n       TYPE_POINTER_TO (TREE_TYPE (data_decl)) = tem;\n-      DECL_INITIAL (data_decl) = build_constructor_from_list\n-\t\t\t\t  (TREE_TYPE (data_decl), data_list);\n+      DECL_INITIAL (data_decl) = build_constructor (TREE_TYPE (data_decl), data);\n       DECL_SIZE (data_decl) = TYPE_SIZE (TREE_TYPE (data_decl));\n       DECL_SIZE_UNIT (data_decl) = TYPE_SIZE_UNIT (TREE_TYPE (data_decl));\n       rest_of_decl_compilation (data_decl, 1, 0);\n@@ -590,8 +598,7 @@ build_constants_constructor (void)\n \t\t\t\t\t\t\t   current_class),\n \t\t\t      tags_type);\n       TREE_STATIC (tags_decl) = 1;\n-      DECL_INITIAL (tags_decl) = build_constructor_from_list\n-\t\t\t\t (tags_type, tags_list);\n+      DECL_INITIAL (tags_decl) = build_constructor (tags_type, tags);\n       rest_of_decl_compilation (tags_decl, 1, 0);\n       tags_value = build_address_of (tags_decl);\n     }"}]}