{"sha": "05d106753da1441283c516251fa6b1c8aa559892", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVkMTA2NzUzZGExNDQxMjgzYzUxNjI1MWZhNmIxYzhhYTU1OTg5Mg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@cygnus.co.uk", "date": "1999-09-01T14:30:35Z"}, "committer": {"name": "Bernd Schmidt", "email": "crux@gcc.gnu.org", "date": "1999-09-01T14:30:35Z"}, "message": "Fix indentation problems\n\nFrom-SVN: r29027", "tree": {"sha": "bc8443c47bc5265fc61708c7789930b1b150a2a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc8443c47bc5265fc61708c7789930b1b150a2a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05d106753da1441283c516251fa6b1c8aa559892", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05d106753da1441283c516251fa6b1c8aa559892", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05d106753da1441283c516251fa6b1c8aa559892", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05d106753da1441283c516251fa6b1c8aa559892/comments", "author": null, "committer": null, "parents": [{"sha": "3b3958fc9adc9beb91b192855b71a2048c1b024d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b3958fc9adc9beb91b192855b71a2048c1b024d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b3958fc9adc9beb91b192855b71a2048c1b024d"}], "stats": {"total": 595, "additions": 300, "deletions": 295}, "files": [{"sha": "e9353ce72ee6ae8ccbfca7f80a811f2dd3fb161d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05d106753da1441283c516251fa6b1c8aa559892/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05d106753da1441283c516251fa6b1c8aa559892/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05d106753da1441283c516251fa6b1c8aa559892", "patch": "@@ -1,3 +1,8 @@\n+Wed Sep  1 11:32:00 1999  Bernd Schmidt  <bernds@cygnus.co.uk>\n+\n+\t* reload1.c: Fix many indentation problems.\n+\t* reload.c: Likewise.\n+\n Tue Aug 31 22:08:03 1999  Marc Espie <espie@cvs.openbsd.org>\n \n \t* alias.c (non_local_reference_p): Constify fmt."}, {"sha": "1ebe140a39fa32010ccb3b808d8b7e1b8362928f", "filename": "gcc/reload.c", "status": "modified", "additions": 136, "deletions": 136, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05d106753da1441283c516251fa6b1c8aa559892/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05d106753da1441283c516251fa6b1c8aa559892/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=05d106753da1441283c516251fa6b1c8aa559892", "patch": "@@ -161,7 +161,7 @@ a register with any other reload.  */\n \t\t\t   or more reloads.\n    reload_secondary_in_reload\n    reload_secondary_out_reload\n-   \t\t\t  int, gives the reload number of a secondary\n+\t\t\t  int, gives the reload number of a secondary\n \t\t\t   reload, when needed; otherwise -1\n    reload_secondary_in_icode\n    reload_secondary_out_icode\n@@ -237,9 +237,9 @@ struct decomposition\n #ifdef SECONDARY_MEMORY_NEEDED\n \n /* Save MEMs needed to copy from one class of registers to another.  One MEM\n-   is used per mode, but normally only one or two modes are ever used.  \n+   is used per mode, but normally only one or two modes are ever used.\n \n-   We keep two versions, before and after register elimination.  The one \n+   We keep two versions, before and after register elimination.  The one\n    after register elimination is record separately for each operand.  This\n    is done in case the address is not valid to be sure that we separately\n    reload each.  */\n@@ -439,7 +439,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \n   if (icode != CODE_FOR_nothing)\n     {\n-      /* If IN_P is non-zero, the reload register will be the output in \n+      /* If IN_P is non-zero, the reload register will be the output in\n \t operand 0.  If IN_P is zero, the reload register will be the input\n \t in operand 1.  Outputs should have an initial \"=\", which we must\n \t skip.  */\n@@ -587,7 +587,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n #ifdef SECONDARY_MEMORY_NEEDED\n       /* If we need a memory location to copy between the two reload regs,\n \t set it up now.  Note that we do the input case before making\n-\t the reload and the output case after.  This is due to the \n+\t the reload and the output case after.  This is due to the\n \t way reloads are output.  */\n \n       if (in_p && icode == CODE_FOR_nothing\n@@ -613,7 +613,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n       reload_when_needed[s_reload] = secondary_type;\n       reload_secondary_in_reload[s_reload] = in_p ? t_reload : -1;\n       reload_secondary_out_reload[s_reload] = ! in_p ? t_reload : -1;\n-      reload_secondary_in_icode[s_reload] = in_p ? t_icode : CODE_FOR_nothing; \n+      reload_secondary_in_icode[s_reload] = in_p ? t_icode : CODE_FOR_nothing;\n       reload_secondary_out_icode[s_reload]\n \t= ! in_p ? t_icode : CODE_FOR_nothing;\n       reload_secondary_p[s_reload] = 1;\n@@ -634,7 +634,7 @@ push_secondary_reload (in_p, x, opnum, optional, reload_class, reload_mode,\n \f\n #ifdef SECONDARY_MEMORY_NEEDED\n \n-/* Return a memory location that will be used to copy X in mode MODE.  \n+/* Return a memory location that will be used to copy X in mode MODE.\n    If we haven't already made a location for this mode in this insn,\n    call find_reloads_address on the location being returned.  */\n \n@@ -664,7 +664,7 @@ get_secondary_mem (x, mode, opnum, type)\n   if (secondary_memlocs_elim[(int) mode][opnum] != 0)\n     return secondary_memlocs_elim[(int) mode][opnum];\n \n-  /* If this is the first time we've tried to get a MEM for this mode, \n+  /* If this is the first time we've tried to get a MEM for this mode,\n      allocate a new one.  `something_changed' in reload will get set\n      by noticing that the frame size has changed.  */\n \n@@ -774,12 +774,12 @@ find_reusable_reload (p_in, out, class, type, opnum, dont_share)\n   /* We can use an existing reload if the class is right\n      and at least one of IN and OUT is a match\n      and the other is at worst neutral.\n-     (A zero compared against anything is neutral.) \n+     (A zero compared against anything is neutral.)\n \n      If SMALL_REGISTER_CLASSES, don't use existing reloads unless they are\n      for the same thing since that can cause us to need more reload registers\n      than we otherwise would.  */\n-   \n+\n   for (i = 0; i < n_reloads; i++)\n     if ((reg_class_subset_p (class, reload_reg_class[i])\n \t || reg_class_subset_p (reload_reg_class[i], class))\n@@ -794,8 +794,8 @@ find_reusable_reload (p_in, out, class, type, opnum, dont_share)\n \t     && (in == 0 || reload_in[i] == 0 || MATCHES (reload_in[i], in))))\n \t&& (reload_out[i] == 0 || ! earlyclobber_operand_p (reload_out[i]))\n \t&& (reg_class_size[(int) class] == 1 || SMALL_REGISTER_CLASSES)\n-\t    && MERGABLE_RELOADS (type, reload_when_needed[i],\n-\t\t\t\t opnum, reload_opnum[i]))\n+\t&& MERGABLE_RELOADS (type, reload_when_needed[i],\n+\t\t\t     opnum, reload_opnum[i]))\n       return i;\n \n   /* Reloading a plain reg for input can match a reload to postincrement\n@@ -900,7 +900,7 @@ push_reload (in, out, inloc, outloc, class,\n   if (outmode == VOIDmode && out != 0)\n     outmode = GET_MODE (out);\n \n-  /* If IN is a pseudo register everywhere-equivalent to a constant, and \n+  /* If IN is a pseudo register everywhere-equivalent to a constant, and\n      it is not in a hard register, reload straight from the constant,\n      since we want to get rid of such pseudo registers.\n      Often this is done earlier, but not always in find_reloads_address.  */\n@@ -1104,7 +1104,7 @@ push_reload (in, out, inloc, outloc, class,\n \t\t\t  ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (out))) - 1)\n \t\t\t   / UNITS_PER_WORD)))\n #endif\n-\t          ))\n+\t\t  ))\n \t  || (GET_CODE (SUBREG_REG (out)) == REG\n \t      && REGNO (SUBREG_REG (out)) < FIRST_PSEUDO_REGISTER\n \t      && ((GET_MODE_SIZE (outmode) <= UNITS_PER_WORD\n@@ -1137,9 +1137,9 @@ push_reload (in, out, inloc, outloc, class,\n     {\n       out_subreg_loc = outloc;\n       outloc = &SUBREG_REG (out);\n-      out = *outloc; \n+      out = *outloc;\n #if ! defined (LOAD_EXTEND_OP) && ! defined (WORD_REGISTER_OPERATIONS)\n-     if (GET_CODE (out) == MEM\n+      if (GET_CODE (out) == MEM\n \t  && GET_MODE_SIZE (GET_MODE (out)) > GET_MODE_SIZE (outmode))\n \tabort ();\n #endif\n@@ -1304,7 +1304,7 @@ push_reload (in, out, inloc, outloc, class,\n       if (in != 0 && GET_CODE (in) == REG\n \t  && REGNO (in) < FIRST_PSEUDO_REGISTER\n \t  && SECONDARY_MEMORY_NEEDED (REGNO_REG_CLASS (REGNO (in)),\n-\t\t\t\t     class, inmode))\n+\t\t\t\t      class, inmode))\n \tget_secondary_mem (in, inmode, opnum, type);\n #endif\n \n@@ -1634,10 +1634,10 @@ loc_mentioned_in_p (loc, in)\n       if (loc == &in->fld[i].rtx)\n \treturn 1;\n       if (fmt[i] == 'e')\n-        {\n+\t{\n \t  if (loc_mentioned_in_p (loc, XEXP (in, i)))\n \t    return 1;\n-        }\n+\t}\n       else if (fmt[i] == 'E')\n \tfor (j = XVECLEN (in, i) - 1; i >= 0; i--)\n \t  if (loc_mentioned_in_p (loc, XVECEXP (in, i, j)))\n@@ -1806,10 +1806,10 @@ combine_reloads ()\n \t    <= HARD_REGNO_NREGS (REGNO (XEXP (note, 0)), GET_MODE (XEXP (note, 0))))\n \t/* Ensure that a secondary or tertiary reload for this output\n \t   won't want this register.  */\n-        && ((secondary_out = reload_secondary_out_reload[output_reload]) == -1\n-            || (! (TEST_HARD_REG_BIT\n-\t\t    (reg_class_contents[(int) reload_reg_class[secondary_out]],\n-\t\t     REGNO (XEXP (note, 0))))\n+\t&& ((secondary_out = reload_secondary_out_reload[output_reload]) == -1\n+\t    || (! (TEST_HARD_REG_BIT\n+\t\t   (reg_class_contents[(int) reload_reg_class[secondary_out]],\n+\t\t    REGNO (XEXP (note, 0))))\n \t\t&& ((secondary_out = reload_secondary_out_reload[secondary_out]) == -1\n \t\t    ||  ! (TEST_HARD_REG_BIT\n \t\t\t   (reg_class_contents[(int) reload_reg_class[secondary_out]],\n@@ -2077,7 +2077,7 @@ operands_match_p (x, y)\n   register RTX_CODE code = GET_CODE (x);\n   register const char *fmt;\n   int success_2;\n-      \n+\n   if (x == y)\n     return 1;\n   if ((code == REG || (code == SUBREG && GET_CODE (SUBREG_REG (x)) == REG))\n@@ -2136,7 +2136,7 @@ operands_match_p (x, y)\n \n  slow:\n \n-  /* Now we have disposed of all the cases \n+  /* Now we have disposed of all the cases\n      in which different rtx codes can match.  */\n   if (code != GET_CODE (y))\n     return 0;\n@@ -2207,11 +2207,11 @@ operands_match_p (x, y)\n }\n \f\n /* Describe the range of registers or memory referenced by X.\n-   If X is a register, set REG_FLAG and put the first register \n+   If X is a register, set REG_FLAG and put the first register\n    number into START and the last plus one into END.\n-   If X is a memory reference, put a base address into BASE \n+   If X is a memory reference, put a base address into BASE\n    and a range of integer offsets into START and END.\n-   If X is pushing on the stack, we can assume it causes no trouble, \n+   If X is pushing on the stack, we can assume it causes no trouble,\n    so we set the SAFE field.  */\n \n static struct decomposition\n@@ -2262,7 +2262,7 @@ decompose (x)\n \t{\n \t  base = addr;\n \t  offset = const0_rtx;\n-\t} \n+\t}\n       if (GET_CODE (offset) == CONST)\n \toffset = XEXP (offset, 0);\n       if (GET_CODE (offset) == PLUS)\n@@ -2303,7 +2303,7 @@ decompose (x)\n   else if (GET_CODE (x) == REG)\n     {\n       val.reg_flag = 1;\n-      val.start = true_regnum (x); \n+      val.start = true_regnum (x);\n       if (val.start < 0)\n \t{\n \t  /* A pseudo with no hard reg.  */\n@@ -2320,7 +2320,7 @@ decompose (x)\n \t/* This could be more precise, but it's good enough.  */\n \treturn decompose (SUBREG_REG (x));\n       val.reg_flag = 1;\n-      val.start = true_regnum (x); \n+      val.start = true_regnum (x);\n       if (val.start < 0)\n \treturn decompose (SUBREG_REG (x));\n       else\n@@ -2496,7 +2496,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n   if (reg_set_p (cc0_rtx, PATTERN (insn)))\n     no_output_reloads = 1;\n #endif\n-     \n+\n #ifdef SECONDARY_MEMORY_NEEDED\n   /* The eliminated forms of any secondary memory locations are per-insn, so\n      clear them out here.  */\n@@ -2550,7 +2550,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n       modified[i] = RELOAD_READ;\n \n-      /* Scan this operand's constraint to see if it is an output operand, \n+      /* Scan this operand's constraint to see if it is an output operand,\n \t an in-out operand, is commutative, or should match another.  */\n \n       while ((c = *p++))\n@@ -2605,7 +2605,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n      and reload parts of the addresses into index registers.\n      Also here any references to pseudo regs that didn't get hard regs\n      but are equivalent to constants get replaced in the insn itself\n-     with those constants.  Nobody will ever see them again. \n+     with those constants.  Nobody will ever see them again.\n \n      Finally, set up the preferred classes of each operand.  */\n \n@@ -2631,7 +2631,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t\trecog_operand[i], recog_operand_loc[i],\n \t\t\t\ti, operand_type[i], ind_levels, insn);\n \n-\t  /* If we now have a simple operand where we used to have a \n+\t  /* If we now have a simple operand where we used to have a\n \t     PLUS or MULT, re-recognize and try again.  */\n \t  if ((GET_RTX_CLASS (GET_CODE (*recog_operand_loc[i])) == 'o'\n \t       || GET_CODE (*recog_operand_loc[i]) == SUBREG)\n@@ -2670,14 +2670,14 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     that didn't get a hard register, emit a USE with a REG_EQUAL\n \t     note in front so that we might inherit a previous, possibly\n \t     wider reload.  */\n-\t     \n+\n \t  if (replace\n \t      && GET_CODE (op) == MEM\n \t      && GET_CODE (reg) == REG\n \t      && (GET_MODE_SIZE (GET_MODE (reg))\n \t\t  >= GET_MODE_SIZE (GET_MODE (op))))\n-            REG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode, reg), insn))\n-              = gen_rtx_EXPR_LIST (REG_EQUAL,\n+\t    REG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode, reg), insn))\n+\t      = gen_rtx_EXPR_LIST (REG_EQUAL,\n \t\t\t\t   reg_equiv_memory_loc[REGNO (reg)], NULL_RTX);\n \n \t  substed_operand[i] = recog_operand[i] = op;\n@@ -2702,13 +2702,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      && (set == 0 || &SET_DEST (set) != recog_operand_loc[i]))\n \t    {\n \t      /* Record the existing mode so that the check if constants are\n-\t         allowed will work when operand_mode isn't specified. */\n+\t\t allowed will work when operand_mode isn't specified. */\n \n \t      if (operand_mode[i] == VOIDmode)\n \t\toperand_mode[i] = GET_MODE (recog_operand[i]);\n \n \t      substed_operand[i] = recog_operand[i]\n-\t        = reg_equiv_constant[regno];\n+\t\t= reg_equiv_constant[regno];\n \t    }\n \t  if (reg_equiv_memory_loc[regno] != 0\n \t      && (reg_equiv_address[regno] != 0 || num_not_at_initial_offset))\n@@ -2780,7 +2780,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       /* REJECT is a count of how undesirable this alternative says it is\n \t if any reloading is required.  If the alternative matches exactly\n \t then REJECT is ignored, but otherwise it gets this much\n-\t counted against it in addition to the reloading needed.  Each \n+\t counted against it in addition to the reloading needed.  Each\n \t ? counts three times here since we want the disparaging caused by\n \t a bad register class to only count 1/3 as much.  */\n       int reject = 0;\n@@ -2808,7 +2808,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  int earlyclobber = 0;\n \n \t  /* If the predicate accepts a unary operator, it means that\n-             we need to reload the operand, but do not do this for\n+\t     we need to reload the operand, but do not do this for\n \t     match_operator and friends.  */\n \t  if (GET_RTX_CLASS (GET_CODE (operand)) == '1' && *p != 0)\n \t    operand = XEXP (operand, 0);\n@@ -2838,10 +2838,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t     made assumptions about the behavior of the machine in such\n \t\t     register access.  If the data is, in fact, in memory we\n \t\t     must always load using the size assumed to be in the\n-\t\t     register and let the insn do the different-sized \n+\t\t     register and let the insn do the different-sized\n \t\t     accesses.\n \n-\t\t     This is doubly true if WORD_REGISTER_OPERATIONS.  In \n+\t\t     This is doubly true if WORD_REGISTER_OPERATIONS.  In\n \t\t     this case eliminate_regs has left non-paradoxical\n \t\t     subregs for push_reloads to see.  Make sure it does\n \t\t     by forcing the reload.\n@@ -2955,10 +2955,10 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t       don't exchange them, because operands_match is valid\n \t\t       only on one side of its diagonal.  */\n \t\t    ? (operands_match\n-\t\t        [(c == commutative || c == commutative + 1)\n-\t\t\t ? 2*commutative + 1 - c : c]\n-\t\t        [(i == commutative || i == commutative + 1)\n-\t\t\t ? 2*commutative + 1 - i : i])\n+\t\t       [(c == commutative || c == commutative + 1)\n+\t\t       ? 2*commutative + 1 - c : c]\n+\t\t       [(i == commutative || i == commutative + 1)\n+\t\t       ? 2*commutative + 1 - i : i])\n \t\t    : operands_match[c][i])\n \t\t  {\n \t\t    /* If we are matching a non-offsettable address where an\n@@ -3176,8 +3176,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t    /* A SCRATCH is not a valid operand.  */\n \t\t    && GET_CODE (operand) != SCRATCH\n #ifdef LEGITIMATE_PIC_OPERAND_P\n-\t\t    && (! CONSTANT_P (operand) \n-\t\t\t|| ! flag_pic \n+\t\t    && (! CONSTANT_P (operand)\n+\t\t\t|| ! flag_pic\n \t\t\t|| LEGITIMATE_PIC_OPERAND_P (operand))\n #endif\n \t\t    && (GENERAL_REGS == ALL_REGS\n@@ -3193,20 +3193,20 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\tgoto reg;\n \n #ifdef EXTRA_CONSTRAINT\n-              case 'Q':\n-              case 'R':\n-              case 'S':\n-              case 'T':\n-              case 'U':\n+\t      case 'Q':\n+\t      case 'R':\n+\t      case 'S':\n+\t      case 'T':\n+\t      case 'U':\n \t\tif (EXTRA_CONSTRAINT (operand, c))\n \t\t  win = 1;\n \t\tbreak;\n #endif\n-  \n+\n \t      default:\n \t\tthis_alternative[i]\n \t\t  = (int) reg_class_subunion[this_alternative[i]][(int) REG_CLASS_FROM_LETTER (c)];\n-\t\t\n+\n \t      reg:\n \t\tif (GET_MODE (operand) == BLKmode)\n \t\t  break;\n@@ -3247,7 +3247,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      /* If this is a pseudo-register that is set in the previous\n \t\t insns, there's a good chance that it will already be in a\n \t\t spill register and we can use that spill register.  So\n-\t\t make this case cheaper. \n+\t\t make this case cheaper.\n \n \t\t Disabled for egcs.  egcs has better inheritance code and\n \t\t this change causes problems with the improved reload\n@@ -3263,14 +3263,14 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t reload.  This is consistent with other code and is\n \t\t required to avoid choosing another alternative when\n \t\t the constant is moved into memory by this function on\n-\t\t an early reload pass.  Note that the test here is \n+\t\t an early reload pass.  Note that the test here is\n \t\t precisely the same as in the code below that calls\n \t\t force_const_mem.  */\n \t      if (CONSTANT_P (operand)\n \t\t  /* force_const_mem does not accept HIGH.  */\n \t\t  && GET_CODE (operand) != HIGH\n \t\t  && ((PREFERRED_RELOAD_CLASS (operand,\n-\t\t\t\t\t      (enum reg_class) this_alternative[i])\n+\t\t\t\t\t       (enum reg_class) this_alternative[i])\n \t\t       == NO_REGS)\n \t\t      || no_input_reloads)\n \t\t  && operand_mode[i] != VOIDmode)\n@@ -3296,8 +3296,8 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t permitted for this insn.  We can always reload SCRATCH\n \t\t and objects with a REG_UNUSED note.  */\n \t      else if (GET_CODE (operand) != SCRATCH\n-\t\t  && modified[i] != RELOAD_READ && no_output_reloads\n-\t\t  && ! find_reg_note (insn, REG_UNUSED, operand))\n+\t\t       && modified[i] != RELOAD_READ && no_output_reloads\n+\t\t       && ! find_reg_note (insn, REG_UNUSED, operand))\n \t\tbad = 1;\n \t      else if (modified[i] != RELOAD_WRITE && no_input_reloads\n \t\t       && ! const_to_mem)\n@@ -3307,7 +3307,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      /* We prefer to reload pseudos over reloading other things,\n \t\t since such reloads may be able to be eliminated later.\n \t\t If we are reloading a SCRATCH, we won't be generating any\n-\t\t insns, just using a register, so it is also preferred. \n+\t\t insns, just using a register, so it is also preferred.\n \t\t So bump REJECT in other cases.  Don't do this in the\n \t\t case where we are forcing a constant into memory and\n \t\t it will then win since we don't want to have a different\n@@ -3325,7 +3325,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\treject++;\n \t    }\n \n-\t  /* If this operand is a pseudo register that didn't get a hard \n+\t  /* If this operand is a pseudo register that didn't get a hard\n \t     reg and this alternative accepts some register, see if the\n \t     class that we want is a subset of the preferred class for this\n \t     register.  If not, but it intersects that class, use the\n@@ -3356,7 +3356,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t{\n \t\t  /* Since we don't have a way of forming the intersection,\n \t\t     we just do something special if the preferred class\n-\t\t     is a subset of the class we have; that's the most \n+\t\t     is a subset of the class we have; that's the most\n \t\t     common case anyway.  */\n \t\t  if (reg_class_subset_p (preferred_class[i],\n \t\t\t\t\t  this_alternative[i]))\n@@ -3375,13 +3375,13 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \tif (this_alternative_earlyclobber[i]\n \t    && this_alternative_win[i])\n \t  {\n-\t    struct decomposition early_data; \n+\t    struct decomposition early_data;\n \n \t    early_data = decompose (recog_operand[i]);\n \n \t    if (modified[i] == RELOAD_READ)\n \t      abort ();\n-\t    \n+\n \t    if (this_alternative[i] == NO_REGS)\n \t      {\n \t\tthis_alternative_earlyclobber[i] = 0;\n@@ -3600,9 +3600,9 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \n \t One special case that is worth checking is when we have an\n \t output that is earlyclobber but isn't used past the insn (typically\n-\t a SCRATCH).  In this case, we only need have the reload live \n+\t a SCRATCH).  In this case, we only need have the reload live\n \t through the insn itself, but not for any of our input or output\n-\t reloads. \n+\t reloads.\n \t But we must not accidentally narrow the scope of an existing\n \t RELOAD_OTHER reload - leave these alone.\n \n@@ -3623,7 +3623,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t/* force_const_mem does not accept HIGH.  */\n \t&& GET_CODE (recog_operand[i]) != HIGH\n \t&& ((PREFERRED_RELOAD_CLASS (recog_operand[i],\n-\t\t\t\t    (enum reg_class) goal_alternative[i])\n+\t\t\t\t     (enum reg_class) goal_alternative[i])\n \t     == NO_REGS)\n \t    || no_input_reloads)\n \t&& operand_mode[i] != VOIDmode)\n@@ -3763,7 +3763,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t     && goal_alternative_matches[i] < 0\n \t     && optimize)\n       {\n-\t/* For each non-matching operand that's a MEM or a pseudo-register \n+\t/* For each non-matching operand that's a MEM or a pseudo-register\n \t   that didn't get a hard register, make an optional reload.\n \t   This may get done even if the insn needs no reloads otherwise.  */\n \n@@ -3857,17 +3857,17 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t\t\t   operand_mode[i],\n \t\t\t   0, 1, goal_alternative_matches[i], RELOAD_OTHER);\n       }\n-  \n+\n   /* Perform whatever substitutions on the operands we are supposed\n      to make due to commutativity or replacement of registers\n      with equivalent constants or memory slots.  */\n \n   for (i = 0; i < noperands; i++)\n     {\n       /* We only do this on the last pass through reload, because it is\n-       possible for some data (like reg_equiv_address) to be changed during\n-       later passes.  Moreover, we loose the opportunity to get a useful\n-       reload_{in,out}_reg when we do these replacements.  */\n+\t possible for some data (like reg_equiv_address) to be changed during\n+\t later passes.  Moreover, we loose the opportunity to get a useful\n+\t reload_{in,out}_reg when we do these replacements.  */\n \n       if (replace)\n \t{\n@@ -3978,7 +3978,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t  }\n     }\n \n-  /* Scan all the reloads and update their type. \n+  /* Scan all the reloads and update their type.\n      If a reload is for the address of an operand and we didn't reload\n      that operand, change the type.  Similarly, change the operand number\n      of a reload when two operands match.  If a reload is optional, treat it\n@@ -4023,7 +4023,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_in_reload > 0\n \t\t  && reload_secondary_in_reload[secondary_in_reload] != -1)\n-\t\treload_when_needed[reload_secondary_in_reload[secondary_in_reload]] \n+\t\treload_when_needed[reload_secondary_in_reload[secondary_in_reload]]\n \t\t  = RELOAD_FOR_OPADDR_ADDR;\n \t    }\n \n@@ -4039,7 +4039,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n \t      /* If there's a tertiary reload we have to change it also.  */\n \t      if (secondary_out_reload\n \t\t  && reload_secondary_out_reload[secondary_out_reload] != -1)\n-\t\treload_when_needed[reload_secondary_out_reload[secondary_out_reload]] \n+\t\treload_when_needed[reload_secondary_out_reload[secondary_out_reload]]\n \t\t  = RELOAD_FOR_OPADDR_ADDR;\n \t    }\n \n@@ -4053,7 +4053,7 @@ find_reloads (insn, replace, ind_levels, live_known, reload_reg_p)\n       if ((reload_when_needed[i] == RELOAD_FOR_INPUT_ADDRESS\n \t   || reload_when_needed[i] == RELOAD_FOR_INPADDR_ADDRESS)\n \t  && operand_reloadnum[reload_opnum[i]] >= 0\n-\t  && (reload_when_needed[operand_reloadnum[reload_opnum[i]]] \n+\t  && (reload_when_needed[operand_reloadnum[reload_opnum[i]]]\n \t      == RELOAD_OTHER))\n \treload_when_needed[i] = RELOAD_FOR_OTHER_ADDRESS;\n \n@@ -4392,8 +4392,8 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn)\n       if (reg_equiv_constant[regno] != 0 && !is_set_dest)\n \tx = reg_equiv_constant[regno];\n #if 0\n-/*  This creates (subreg (mem...)) which would cause an unnecessary\n-    reload of the mem.  */\n+      /*  This creates (subreg (mem...)) which would cause an unnecessary\n+\t  reload of the mem.  */\n       else if (reg_equiv_mem[regno] != 0)\n \tx = reg_equiv_mem[regno];\n #endif\n@@ -4426,7 +4426,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn)\n \n   if (code == SUBREG && GET_CODE (SUBREG_REG (x)) == REG)\n     {\n-      /* Check for SUBREG containing a REG that's equivalent to a constant. \n+      /* Check for SUBREG containing a REG that's equivalent to a constant.\n \t If the constant has a known value, truncate it right now.\n \t Similarly if we are extracting a single-word of a multi-word\n \t constant.  If the constant is symbolic, allow it to be substituted\n@@ -4474,18 +4474,18 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn)\n \t  && GET_CODE (reg_equiv_constant[regno]) == CONST_INT\n \t  && (GET_MODE_SIZE (GET_MODE (x))\n \t      < GET_MODE_SIZE (GET_MODE (SUBREG_REG (x)))))\n-\t  {\n-\t    int shift = SUBREG_WORD (x) * BITS_PER_WORD;\n-\t    if (WORDS_BIG_ENDIAN)\n-\t      shift = (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n-\t\t       - GET_MODE_BITSIZE (GET_MODE (x))\n-\t\t       - shift);\n-\t    /* Here we use the knowledge that CONST_INTs have a\n-\t       HOST_WIDE_INT field.  */\n-\t    if (shift >= HOST_BITS_PER_WIDE_INT)\n-\t      shift = HOST_BITS_PER_WIDE_INT - 1;\n-\t    return GEN_INT (INTVAL (reg_equiv_constant[regno]) >> shift);\n-\t  }\n+\t{\n+\t  int shift = SUBREG_WORD (x) * BITS_PER_WORD;\n+\t  if (WORDS_BIG_ENDIAN)\n+\t    shift = (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n+\t\t     - GET_MODE_BITSIZE (GET_MODE (x))\n+\t\t     - shift);\n+\t  /* Here we use the knowledge that CONST_INTs have a\n+\t     HOST_WIDE_INT field.  */\n+\t  if (shift >= HOST_BITS_PER_WIDE_INT)\n+\t    shift = HOST_BITS_PER_WIDE_INT - 1;\n+\t  return GEN_INT (INTVAL (reg_equiv_constant[regno]) >> shift);\n+\t}\n \n       if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] < 0\n \t  && reg_equiv_constant[regno] != 0\n@@ -4512,7 +4512,7 @@ find_reloads_toplev (x, opnum, type, ind_levels, is_set_dest, insn)\n #endif\n \t       && (reg_equiv_address[regno] != 0\n \t\t   || (reg_equiv_mem[regno] != 0\n-\t\t       && (! strict_memory_address_p (GET_MODE (x), \n+\t\t       && (! strict_memory_address_p (GET_MODE (x),\n \t\t\t\t\t\t      XEXP (reg_equiv_mem[regno], 0))\n \t\t\t   || ! offsettable_memref_p (reg_equiv_mem[regno])\n \t\t\t   || num_not_at_initial_offset))))\n@@ -4827,7 +4827,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n   /* If we have an indexed stack slot, there are three possible reasons why\n      it might be invalid: The index might need to be reloaded, the address\n      might have been made by frame pointer elimination and hence have a\n-     constant out of range, or both reasons might apply.  \n+     constant out of range, or both reasons might apply.\n \n      We can easily check for an index needing reload, but even if that is the\n      case, we might also have an invalid constant.  To avoid making the\n@@ -4868,15 +4868,15 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n       *loc = ad = gen_rtx_PLUS (GET_MODE (ad),\n \t\t\t\tplus_constant (XEXP (XEXP (ad, 0), 0),\n \t\t\t\t\t       INTVAL (XEXP (ad, 1))),\n-\t\t\t   XEXP (XEXP (ad, 0), 1));\n+\t\t\t\tXEXP (XEXP (ad, 0), 1));\n       find_reloads_address_part (XEXP (ad, 0), &XEXP (ad, 0), BASE_REG_CLASS,\n \t\t\t\t GET_MODE (ad), opnum, type, ind_levels);\n       find_reloads_address_1 (mode, XEXP (ad, 1), 1, &XEXP (ad, 1), opnum,\n \t\t\t      type, 0, insn);\n \n       return 0;\n     }\n-\t\t\t   \n+\n   else if (GET_CODE (ad) == PLUS && GET_CODE (XEXP (ad, 1)) == CONST_INT\n \t   && GET_CODE (XEXP (ad, 0)) == PLUS\n \t   && (XEXP (XEXP (ad, 0), 1) == frame_pointer_rtx\n@@ -4900,7 +4900,7 @@ find_reloads_address (mode, memrefloc, ad, loc, opnum, type, ind_levels, insn)\n \n       return 0;\n     }\n-\t\t\t   \n+\n   /* See if address becomes valid when an eliminable register\n      in a sum is replaced.  */\n \n@@ -5003,7 +5003,7 @@ subst_reg_equivs (ad, insn)\n \t  && GET_CODE (XEXP (ad, 1)) == CONST_INT)\n \treturn ad;\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -5095,9 +5095,9 @@ subst_indexed_address (addr)\n \t  && reg_equiv_constant[regno] != 0)\n \top0 = reg_equiv_constant[regno];\n       else if (GET_CODE (op1) == REG\n-\t  && (regno = REGNO (op1)) >= FIRST_PSEUDO_REGISTER\n-\t  && reg_renumber[regno] < 0\n-\t  && reg_equiv_constant[regno] != 0)\n+\t       && (regno = REGNO (op1)) >= FIRST_PSEUDO_REGISTER\n+\t       && reg_renumber[regno] < 0\n+\t       && reg_equiv_constant[regno] != 0)\n \top1 = reg_equiv_constant[regno];\n       else if (GET_CODE (op0) == PLUS\n \t       && (tem = subst_indexed_address (op0)) != op0)\n@@ -5191,7 +5191,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t\t REGNO (op1) + SUBREG_WORD (orig_op1));\n \t  }\n \n-\tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE \n+\tif (code0 == MULT || code0 == SIGN_EXTEND || code0 == TRUNCATE\n \t    || code0 == ZERO_EXTEND || code1 == MEM)\n \t  {\n \t    find_reloads_address_1 (mode, orig_op0, 1, &XEXP (x, 0), opnum,\n@@ -5352,8 +5352,8 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t  reloadnum\n \t\t    = push_reload (x, x, loc, loc,\n \t\t\t\t   (context ? INDEX_REG_CLASS : BASE_REG_CLASS),\n-\t\t\t\t    GET_MODE (x), GET_MODE (x), 0, 0,\n-\t\t\t\t    opnum, RELOAD_OTHER);\n+\t\t\t\t   GET_MODE (x), GET_MODE (x), 0, 0,\n+\t\t\t\t   opnum, RELOAD_OTHER);\n \n \t\t  /* If we created a new MEM based on reg_equiv_mem[REGNO], then\n \t\t     LOC above is part of the new MEM, not the MEM in INSN.\n@@ -5372,7 +5372,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t\t\t\t   opnum, type);\n \t\t  reload_inc[reloadnum]\n \t\t    = find_inc_amount (PATTERN (this_insn), XEXP (x_orig, 0));\n-    \n+\n \t\t  value = 1;\n \t\t}\n \n@@ -5548,7 +5548,7 @@ find_reloads_address_1 (mode, x, context, loc, opnum, type, ind_levels, insn)\n \t    }\n \t}\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -5926,7 +5926,7 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n \t}\n \n       return (endregno > i\n-\t      && regno < i + (i < FIRST_PSEUDO_REGISTER \n+\t      && regno < i + (i < FIRST_PSEUDO_REGISTER\n \t\t\t      ? HARD_REGNO_NREGS (i, GET_MODE (x))\n \t\t\t      : 1));\n \n@@ -5970,7 +5970,7 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n \treturn 0;\n       x = SET_SRC (x);\n       goto repeat;\n-      \n+\n     default:\n       break;\n     }\n@@ -6009,7 +6009,7 @@ refers_to_regno_for_reload_p (regno, endregno, x, loc)\n    we check if any register number in X conflicts with the relevant register\n    numbers.  If X is a constant, return 0.  If X is a MEM, return 1 iff IN\n    contains a MEM (we don't bother checking for memory addresses that can't\n-   conflict because we expect this to be a rare case. \n+   conflict because we expect this to be a rare case.\n \n    This function is similar to reg_overlap_mention_p in rtlanal.c except\n    that we look at equivalences for pseudos that didn't get hard registers.  */\n@@ -6079,14 +6079,14 @@ refers_to_mem_for_reload_p (x)\n   if (GET_CODE (x) == REG)\n     return (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t    && reg_equiv_memory_loc[REGNO (x)]);\n-\t\t\t\n+\n   fmt = GET_RTX_FORMAT (GET_CODE (x));\n   for (i = GET_RTX_LENGTH (GET_CODE (x)) - 1; i >= 0; i--)\n     if (fmt[i] == 'e'\n \t&& (GET_CODE (XEXP (x, i)) == MEM\n \t    || refers_to_mem_for_reload_p (XEXP (x, i))))\n       return 1;\n-  \n+\n   return 0;\n }\n \f\n@@ -6178,12 +6178,12 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \n   /* On some machines, certain regs must always be rejected\n      because they don't behave the way ordinary registers do.  */\n-  \n+\n #ifdef OVERLAPPING_REGNO_P\n-   if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER\n-       && OVERLAPPING_REGNO_P (regno))\n-     return 0;\n-#endif      \n+  if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER\n+      && OVERLAPPING_REGNO_P (regno))\n+    return 0;\n+#endif\n \n   /* Scan insns back from INSN, looking for one that copies\n      a value into or out of GOAL.\n@@ -6198,13 +6198,13 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t  /* If we don't want spill regs ...  */\n \t  && (! (reload_reg_p != 0\n \t\t && reload_reg_p != (short *) (HOST_WIDE_INT) 1)\n-\t  /* ... then ignore insns introduced by reload; they aren't useful\n-\t     and can cause results in reload_as_needed to be different\n-\t     from what they were when calculating the need for spills.\n-\t     If we notice an input-reload insn here, we will reject it below,\n-\t     but it might hide a usable equivalent.  That makes bad code.\n-\t     It may even abort: perhaps no reg was spilled for this insn\n-\t     because it was assumed we would find that equivalent.  */\n+\t      /* ... then ignore insns introduced by reload; they aren't useful\n+\t\t and can cause results in reload_as_needed to be different\n+\t\t from what they were when calculating the need for spills.\n+\t\t If we notice an input-reload insn here, we will reject it below,\n+\t\t but it might hide a usable equivalent.  That makes bad code.\n+\t\t It may even abort: perhaps no reg was spilled for this insn\n+\t\t because it was assumed we would find that equivalent.  */\n \t      || INSN_UID (p) < reload_first_uid))\n \t{\n \t  rtx tem;\n@@ -6325,11 +6325,11 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \n   /* On some machines, certain regs must always be rejected\n      because they don't behave the way ordinary registers do.  */\n-  \n+\n #ifdef OVERLAPPING_REGNO_P\n   if (OVERLAPPING_REGNO_P (valueno))\n     return 0;\n-#endif      \n+#endif\n \n   nregs = HARD_REGNO_NREGS (regno, mode);\n   valuenregs = HARD_REGNO_NREGS (valueno, mode);\n@@ -6380,26 +6380,26 @@ find_equiv_reg (goal, insn, class, other, reload_reg_p, goalreg, mode)\n \t      || need_stable_sp))\n \treturn 0;\n \n-#ifdef NON_SAVING_SETJMP \n+#ifdef NON_SAVING_SETJMP\n       if (NON_SAVING_SETJMP && GET_CODE (p) == NOTE\n \t  && NOTE_LINE_NUMBER (p) == NOTE_INSN_SETJMP)\n \treturn 0;\n #endif\n \n #ifdef INSN_CLOBBERS_REGNO_P\n       if ((valueno >= 0 && valueno < FIRST_PSEUDO_REGISTER\n-\t  && INSN_CLOBBERS_REGNO_P (p, valueno))\n+\t   && INSN_CLOBBERS_REGNO_P (p, valueno))\n \t  || (regno >= 0 && regno < FIRST_PSEUDO_REGISTER\n-\t  && INSN_CLOBBERS_REGNO_P (p, regno)))\n+\t      && INSN_CLOBBERS_REGNO_P (p, regno)))\n \treturn 0;\n #endif\n \n       if (GET_RTX_CLASS (GET_CODE (p)) == 'i')\n \t{\n \t  pat = PATTERN (p);\n \n-          /* Watch out for unspec_volatile, and volatile asms.  */\n-          if (volatile_insn_p (pat))\n+\t  /* Watch out for unspec_volatile, and volatile asms.  */\n+\t  if (volatile_insn_p (pat))\n \t    return 0;\n \n \t  /* If this insn P stores in either GOAL or VALUE, return 0.\n@@ -6640,16 +6640,16 @@ regno_clobbered_p (regno, insn)\n \n static const char *reload_when_needed_name[] =\n {\n-  \"RELOAD_FOR_INPUT\", \n-  \"RELOAD_FOR_OUTPUT\", \n+  \"RELOAD_FOR_INPUT\",\n+  \"RELOAD_FOR_OUTPUT\",\n   \"RELOAD_FOR_INSN\",\n   \"RELOAD_FOR_INPUT_ADDRESS\",\n   \"RELOAD_FOR_INPADDR_ADDRESS\",\n   \"RELOAD_FOR_OUTPUT_ADDRESS\",\n   \"RELOAD_FOR_OUTADDR_ADDRESS\",\n-  \"RELOAD_FOR_OPERAND_ADDRESS\", \n+  \"RELOAD_FOR_OPERAND_ADDRESS\",\n   \"RELOAD_FOR_OPADDR_ADDR\",\n-  \"RELOAD_OTHER\", \n+  \"RELOAD_OTHER\",\n   \"RELOAD_FOR_OTHER_ADDRESS\"\n };\n "}, {"sha": "8b92b431effa7d792e651652446b532eaa9dc20b", "filename": "gcc/reload1.c", "status": "modified", "additions": 159, "deletions": 159, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05d106753da1441283c516251fa6b1c8aa559892/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05d106753da1441283c516251fa6b1c8aa559892/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=05d106753da1441283c516251fa6b1c8aa559892", "patch": "@@ -165,7 +165,7 @@ static rtx spill_reg_stored_to[FIRST_PSEUDO_REGISTER];\n /* This table is the inverse mapping of spill_regs:\n    indexed by hard reg number,\n    it contains the position of that reg in spill_regs,\n-   or -1 for something that is not in spill_regs. \n+   or -1 for something that is not in spill_regs.\n \n    ?!?  This is no longer accurate.  */\n static short spill_reg_order[FIRST_PSEUDO_REGISTER];\n@@ -680,7 +680,7 @@ reload (first, global, dumpfile)\n   /* Look for REG_EQUIV notes; record what each pseudo is equivalent to.\n      Also find all paradoxical subregs and find largest such for each pseudo.\n      On machines with small register classes, record hard registers that\n-     are used for user variables.  These can never be used for spills. \n+     are used for user variables.  These can never be used for spills.\n      Also look for a \"constant\" NOTE_INSN_SETJMP.  This means that all\n      caller-saved registers must be marked live.  */\n \n@@ -837,7 +837,7 @@ reload (first, global, dumpfile)\n \n   insns_need_reload = 0;\n   something_needs_elimination = 0;\n-  \n+\n   /* Initialize to -1, which means take the first spill register.  */\n   last_spill_reg = -1;\n \n@@ -1179,14 +1179,14 @@ reload (first, global, dumpfile)\n   if (flag_stack_check && ! STACK_CHECK_BUILTIN)\n     {\n       HOST_WIDE_INT size = get_frame_size () + STACK_CHECK_FIXED_FRAME_SIZE;\n-      static int verbose_warned = 0; \n-   \n+      static int verbose_warned = 0;\n+\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (regs_ever_live[i] && ! fixed_regs[i] && call_used_regs[i])\n \t  size += UNITS_PER_WORD;\n \n       if (size > STACK_CHECK_MAX_FRAME_SIZE)\n-\t{ \n+\t{\n \t  warning (\"frame size too large for reliable stack checking\");\n \t  if (! verbose_warned)\n \t    {\n@@ -1324,7 +1324,7 @@ maybe_fix_stack_asms ()\n \n \t\tdefault:\n \t\t  cls = (int) reg_class_subunion[cls][(int) REG_CLASS_FROM_LETTER (c)];\n-\t\t\n+\n \t\t}\n \t    }\n \t}\n@@ -2009,7 +2009,7 @@ find_reload_regs (chain, dumpfile)\n \t    return;\n \t}\n     }\n-  \n+\n   /* We know which hard regs to use, now mark the pseudos that live in them\n      as needing to be kicked out.  */\n   EXECUTE_IF_SET_IN_REG_SET\n@@ -2296,9 +2296,9 @@ new_spill_reg (chain, i, class, nongroup, dumpfile)\n \n       if (asm_noperands (PATTERN (chain->insn)) < 0)\n \t{\n-\t/* The error message is still correct - we know only that it wasn't\n-\t   an asm statement that caused the problem, but one of the global\n-\t   registers declared by the users might have screwed us.  */\n+\t  /* The error message is still correct - we know only that it wasn't\n+\t     an asm statement that caused the problem, but one of the global\n+\t     registers declared by the users might have screwed us.  */\n \t  error (\"fixed or forbidden register %d (%s) was spilled for class %s.\",\n \t\t regno, reg_names[regno], reg_class_names[class]);\n \t  error (\"This may be due to a compiler bug or to impossible asm\");\n@@ -2464,7 +2464,7 @@ alter_reg (i, from_reg)\n \t\tstack_slot = gen_rtx_MEM (mode_for_size (total_size\n \t\t\t\t\t\t\t * BITS_PER_UNIT,\n \t\t\t\t\t\t\t MODE_INT, 1),\n-\t\t\t\t      plus_constant (XEXP (x, 0), adjust));\n+\t\t\t\t\t  plus_constant (XEXP (x, 0), adjust));\n \t    }\n \t  spill_stack_slot[from_reg] = stack_slot;\n \t  spill_stack_slot_width[from_reg] = total_size;\n@@ -2480,7 +2480,7 @@ alter_reg (i, from_reg)\n       if (adjust != 0 || GET_MODE (x) != GET_MODE (regno_reg_rtx[i]))\n \t{\n \t  x = gen_rtx_MEM (GET_MODE (regno_reg_rtx[i]),\n-\t\t       plus_constant (XEXP (x, 0), adjust));\n+\t\t\t   plus_constant (XEXP (x, 0), adjust));\n \n \t  /* If this was shared among registers, must ensure we never\n \t     set it readonly since that can cause scheduling\n@@ -2656,7 +2656,7 @@ set_label_offsets (x, insn, initial_p)\n \tif (p->offset != p->initial_offset)\n \t  p->can_eliminate = 0;\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -2851,7 +2851,7 @@ eliminate_regs (x, mem_mode, insn)\n       return x;\n \n     case MULT:\n-      /* If this is the product of an eliminable register and a \n+      /* If this is the product of an eliminable register and a\n \t constant, apply the distribute law and move the constant out\n \t so that we have (plus (mult ..) ..).  This is needed in order\n \t to keep load-address insns valid.   This case is pathological.\n@@ -2993,7 +2993,7 @@ eliminate_regs (x, mem_mode, insn)\n \t\t  && GET_CODE (insn) != INSN_LIST)\n \t\tREG_NOTES (emit_insn_before (gen_rtx_USE (VOIDmode,\n \t\t\t\t\t\t\t  SUBREG_REG (x)),\n-\t\t\t\t\t\t\t  insn))\n+\t\t\t\t\t     insn))\n \t\t  = gen_rtx_EXPR_LIST (REG_EQUAL, new, NULL_RTX);\n \n \t      /* Ensure NEW isn't shared in case we have to reload it.  */\n@@ -3016,10 +3016,10 @@ eliminate_regs (x, mem_mode, insn)\n #ifdef WORD_REGISTER_OPERATIONS\n \t\t   /* On these machines, combine can create rtl of the form\n \t\t      (set (subreg:m1 (reg:m2 R) 0) ...)\n-\t\t      where m1 < m2, and expects something interesting to \n+\t\t      where m1 < m2, and expects something interesting to\n \t\t      happen to the entire word.  Moreover, it will use the\n \t\t      (reg:m2 R) later, expecting all bits to be preserved.\n-\t\t      So if the number of words is the same, preserve the \n+\t\t      So if the number of words is the same, preserve the\n \t\t      subreg so that push_reloads can see it.  */\n \t\t   && ! ((x_size-1)/UNITS_PER_WORD == (new_size-1)/UNITS_PER_WORD)\n #endif\n@@ -3193,7 +3193,7 @@ eliminate_regs (x, mem_mode, insn)\n \t}\n       else\n \treturn x;\n-      \n+\n     default:\n       break;\n     }\n@@ -3399,7 +3399,7 @@ eliminate_regs_in_insn (insn, replace)\n   old_asm_operands_vec = 0;\n \n   /* Replace the body of this insn with a substituted form.  If we changed\n-     something, return non-zero.  \n+     something, return non-zero.\n \n      If we are replacing a body that was a (set X (plus Y Z)), try to\n      re-recognize the insn.  We do this in case we had a simple addition\n@@ -3573,7 +3573,7 @@ verify_initial_elim_offsets ()\n   INITIAL_FRAME_POINTER_OFFSET (t);\n   if (t != reg_eliminate[0].initial_offset)\n     abort ();\n-#endif  \n+#endif\n }\n \n /* Reset all offsets on eliminable registers to their initial values.  */\n@@ -3734,7 +3734,7 @@ init_elim_table ()\n       bzero ((PTR) reg_eliminate,\n \t     sizeof(struct elim_table) * NUM_ELIMINABLE_REGS);\n     }\n-  \n+\n   /* Does this function require a frame pointer?  */\n \n   frame_pointer_needed = (! flag_omit_frame_pointer\n@@ -3826,7 +3826,7 @@ ior_hard_reg_set (set1, set2)\n {\n   IOR_HARD_REG_SET (*set1, *set2);\n }\n-  \n+\n /* After find_reload_regs has been run for all insn that need reloads,\n    and/or spill_hard_regs was called, this function is used to actually\n    spill pseudo registers and try to reallocate them.  It also sets up the\n@@ -3907,7 +3907,7 @@ finish_spills (global, dumpfile)\n       /* Retry allocating the spilled pseudos.  For each reg, merge the\n \t various reg sets that indicate which hard regs can't be used,\n \t and call retry_global_alloc.\n-         We change spill_pseudos here to only contain pseudos that did not\n+\t We change spill_pseudos here to only contain pseudos that did not\n \t get a new hard register.  */\n       for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n \tif (reg_old_renumber[i] != reg_renumber[i])\n@@ -3962,7 +3962,7 @@ finish_spills (global, dumpfile)\n       int regno = reg_renumber[i];\n       if (reg_old_renumber[i] == regno)\n \tcontinue;\n-      \n+\n       alter_reg (i, reg_old_renumber[i]);\n       reg_old_renumber[i] = regno;\n       if (dumpfile)\n@@ -3978,7 +3978,7 @@ finish_spills (global, dumpfile)\n   return something_changed;\n }\n \f\n-/* Find all paradoxical subregs within X and update reg_max_ref_width. \n+/* Find all paradoxical subregs within X and update reg_max_ref_width.\n    Also mark any hard registers used to store user variables as\n    forbidden from being used for spill registers.  */\n \n@@ -4017,7 +4017,7 @@ scan_paradoxical_subregs (x)\n \treg_max_ref_width[REGNO (SUBREG_REG (x))]\n \t  = GET_MODE_SIZE (GET_MODE (x));\n       return;\n-      \n+\n     default:\n       break;\n     }\n@@ -4040,7 +4040,7 @@ static int\n hard_reg_use_compare (p1p, p2p)\n      const GENERIC_PTR p1p;\n      const GENERIC_PTR p2p;\n-{  \n+{\n   struct hard_reg_n_uses *p1 = (struct hard_reg_n_uses *)p1p;\n   struct hard_reg_n_uses *p2 = (struct hard_reg_n_uses *)p2p;\n   int bad1 = TEST_HARD_REG_BIT (bad_spill_regs, p1->regno);\n@@ -4082,7 +4082,7 @@ count_pseudo (n_uses, reg)\n \n   nregs = HARD_REGNO_NREGS (r, PSEUDO_REGNO_MODE (reg));\n   while (nregs-- > 0)\n-    n_uses[r++].uses += REG_N_REFS (reg);  \n+    n_uses[r++].uses += REG_N_REFS (reg);\n }\n /* Choose the order to consider regs for use as reload registers\n    based on how much trouble would be caused by spilling one.\n@@ -4287,7 +4287,7 @@ reload_as_needed (live_known)\n \t\t Record the choices of reload reg in reload_reg_rtx.  */\n \t      choose_reload_regs (chain);\n \n-\t      /* Merge any reloads that we didn't combine for fear of \n+\t      /* Merge any reloads that we didn't combine for fear of\n \t\t increasing the number of spill registers needed but now\n \t\t discover can be safely merged.  */\n \t      if (SMALL_REGISTER_CLASSES)\n@@ -4357,7 +4357,7 @@ reload_as_needed (live_known)\n \t\t\t some other (e.g. output operand) pseudo.  */\n \t\t      && (reg_reloaded_contents[REGNO (reload_reg_rtx[i])]\n \t\t\t  == REGNO (XEXP (in_reg, 0))))\n-\t\t\t\t\t      \n+\n \t\t    {\n \t\t      rtx reload_reg = reload_reg_rtx[i];\n \t\t      enum machine_mode mode = GET_MODE (reload_reg);\n@@ -4397,7 +4397,7 @@ reload_as_needed (live_known)\n \t\t\t\t\t\t\treload_reg, p);\n \t\t\t\t  break;\n \t\t\t\t}\n-\t\t\t\t\n+\n \t\t\t    }\n \t\t\t  break;\n \t\t\t}\n@@ -4755,7 +4755,7 @@ clear_reload_reg_in_use (regno, opnum, type, mode)\n      more then what would be necessary if we used a HARD_REG_SET here.\n      But this should only happen very infrequently, so there should\n      be no reason to worry about it.  */\n-    \n+\n   start_regno = regno;\n   end_regno = regno + nregs;\n   if (check_opnum || check_any)\n@@ -4857,8 +4857,8 @@ reload_reg_free_p (regno, opnum, type)\n \n     case RELOAD_FOR_INPADDR_ADDRESS:\n       /* Can't use a register if it is used for an input address\n-         for this operand or used as an input in an earlier\n-         one.  */\n+\t for this operand or used as an input in an earlier\n+\t one.  */\n       if (TEST_HARD_REG_BIT (reload_reg_used_in_inpaddr_addr[opnum], regno))\n \treturn 0;\n \n@@ -4882,8 +4882,8 @@ reload_reg_free_p (regno, opnum, type)\n \n     case RELOAD_FOR_OUTADDR_ADDRESS:\n       /* Can't use a register if it is used for an output address\n-         for this operand or used as an output in this or a\n-         later operand.  */\n+\t for this operand or used as an output in this or a\n+\t later operand.  */\n       if (TEST_HARD_REG_BIT (reload_reg_used_in_outaddr_addr[opnum], regno))\n \treturn 0;\n \n@@ -4903,8 +4903,8 @@ reload_reg_free_p (regno, opnum, type)\n \n     case RELOAD_FOR_OPADDR_ADDR:\n       for (i = 0; i < reload_n_operands; i++)\n-        if (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n-          return 0;\n+\tif (TEST_HARD_REG_BIT (reload_reg_used_in_input[i], regno))\n+\t  return 0;\n \n       return (!TEST_HARD_REG_BIT (reload_reg_used_in_op_addr_reload, regno));\n \n@@ -4964,7 +4964,7 @@ reload_reg_reaches_end_p (regno, opnum, type)\n       return 1;\n \n       /* If this use is for part of the insn,\n-\t its value reaches if no subsequent part uses the same register. \n+\t its value reaches if no subsequent part uses the same register.\n \t Just like the above function, don't try to do this with lots\n \t of fallthroughs.  */\n \n@@ -5015,7 +5015,7 @@ reload_reg_reaches_end_p (regno, opnum, type)\n \n     case RELOAD_FOR_INPUT:\n       /* Similar to input address, except we start at the next operand for\n-\t both input and input address and we do not check for \n+\t both input and input address and we do not check for\n \t RELOAD_FOR_OPERAND_ADDRESS and RELOAD_FOR_INSN since these\n \t would conflict.  */\n \n@@ -5095,7 +5095,7 @@ reloads_conflict (r1, r2)\n   switch (r1_type)\n     {\n     case RELOAD_FOR_INPUT:\n-      return (r2_type == RELOAD_FOR_INSN \n+      return (r2_type == RELOAD_FOR_INSN\n \t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS\n \t      || r2_type == RELOAD_FOR_OPADDR_ADDR\n \t      || r2_type == RELOAD_FOR_INPUT\n@@ -5124,7 +5124,7 @@ reloads_conflict (r1, r2)\n \t      || r2_type == RELOAD_FOR_OPERAND_ADDRESS);\n \n     case RELOAD_FOR_OPADDR_ADDR:\n-      return (r2_type == RELOAD_FOR_INPUT \n+      return (r2_type == RELOAD_FOR_INPUT\n \t      || r2_type == RELOAD_FOR_OPADDR_ADDR);\n \n     case RELOAD_FOR_OUTPUT:\n@@ -5190,7 +5190,7 @@ int reload_spill_index[MAX_RELOADS];\n    register.  */\n static int\n reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n-                             ignore_address_reloads)\n+\t\t\t     ignore_address_reloads)\n      int regno;\n      int opnum;\n      enum reload_type type;\n@@ -5231,12 +5231,12 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n     case RELOAD_OTHER:\n       time1 = copy ? 1 : MAX_RECOG_OPERANDS * 5 + 5;\n       break;\n-    /* For each input, we might have a sequence of RELOAD_FOR_INPADDR_ADDRESS,\n-       RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_INPUT.  By adding 0 / 1 / 2 ,\n-       respectively, to the time values for these, we get distinct time\n-       values.  To get distinct time values for each operand, we have to\n-       multiply opnum by at least three.  We round that up to four because\n-       multiply by four is often cheaper.  */\n+      /* For each input, we may have a sequence of RELOAD_FOR_INPADDR_ADDRESS,\n+\t RELOAD_FOR_INPUT_ADDRESS and RELOAD_FOR_INPUT.  By adding 0 / 1 / 2 ,\n+\t respectively, to the time values for these, we get distinct time\n+\t values.  To get distinct time values for each operand, we have to\n+\t multiply opnum by at least three.  We round that up to four because\n+\t multiply by four is often cheaper.  */\n     case RELOAD_FOR_INPADDR_ADDRESS:\n       time1 = opnum * 4 + 2;\n       break;\n@@ -5249,8 +5249,8 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n       time1 = copy ? opnum * 4 + 4 : MAX_RECOG_OPERANDS * 4 + 3;\n       break;\n     case RELOAD_FOR_OPADDR_ADDR:\n-    /* opnum * 4 + 4\n-       <= (MAX_RECOG_OPERANDS - 1) * 4 + 4 == MAX_RECOG_OPERANDS * 4 */\n+      /* opnum * 4 + 4\n+\t <= (MAX_RECOG_OPERANDS - 1) * 4 + 4 == MAX_RECOG_OPERANDS * 4 */\n       time1 = MAX_RECOG_OPERANDS * 4 + 1;\n       break;\n     case RELOAD_FOR_OPERAND_ADDRESS:\n@@ -5319,8 +5319,8 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\tcase RELOAD_FOR_INPUT:\n \t\t  time2 = reload_opnum[i] * 4 + 4;\n \t\t  break;\n-\t\t/* reload_opnum[i] * 4 + 4 <= (MAX_RECOG_OPERAND - 1) * 4 + 4\n-\t\t   == MAX_RECOG_OPERAND * 4  */\n+\t\t  /* reload_opnum[i] * 4 + 4 <= (MAX_RECOG_OPERAND - 1) * 4 + 4\n+\t\t     == MAX_RECOG_OPERAND * 4  */\n \t\tcase RELOAD_FOR_OPADDR_ADDR:\n \t\t  if (type == RELOAD_FOR_OPERAND_ADDRESS && reloadnum == i + 1\n \t\t      && ignore_address_reloads\n@@ -5335,13 +5335,13 @@ reload_reg_free_for_value_p (regno, opnum, type, value, out, reloadnum,\n \t\t  time2 = MAX_RECOG_OPERANDS * 4 + 3;\n \t\t  break;\n \t\tcase RELOAD_FOR_OUTPUT:\n-\t\t/* All RELOAD_FOR_OUTPUT reloads become live just after the\n-\t\t   instruction is executed.  */\n+\t\t  /* All RELOAD_FOR_OUTPUT reloads become live just after the\n+\t\t     instruction is executed.  */\n \t\t  time2 = MAX_RECOG_OPERANDS * 4 + 4;\n \t\t  break;\n-\t\t/* The first RELOAD_FOR_OUTADDR_ADDRESS reload conflicts with\n-\t\t   the RELOAD_FOR_OUTPUT reloads, so assign it the same time\n-\t\t   value.  */\n+\t\t  /* The first RELOAD_FOR_OUTADDR_ADDRESS reload conflicts with\n+\t\t     the RELOAD_FOR_OUTPUT reloads, so assign it the same time\n+\t\t     value.  */\n \t\tcase RELOAD_FOR_OUTADDR_ADDRESS:\n \t\t  if (type == RELOAD_FOR_OUTPUT_ADDRESS && reloadnum == i + 1\n \t\t      && ignore_address_reloads\n@@ -5438,15 +5438,15 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \t of leapfrogging each other.  Don't do this, however, when we have\n \t group needs and failure would be fatal; if we only have a relatively\n \t small number of spill registers, and more than one of them has\n-\t group needs, then by starting in the middle, we may end up \n+\t group needs, then by starting in the middle, we may end up\n \t allocating the first one in such a way that we are not left with\n \t sufficient groups to handle the rest.  */\n \n       if (noerror || ! force_group)\n \ti = last_spill_reg;\n       else\n \ti = -1;\n-\t  \n+\n       for (count = 0; count < n_spills; count++)\n \t{\n \t  int class = (int) reload_reg_class[r];\n@@ -5460,14 +5460,14 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n \t  if ((reload_reg_free_p (regnum, reload_opnum[r],\n \t\t\t\t  reload_when_needed[r])\n \t       || (reload_in[r]\n-\t\t      /* We check reload_reg_used to make sure we\n-\t\t\t don't clobber the return register.  */\n+\t\t   /* We check reload_reg_used to make sure we\n+\t\t      don't clobber the return register.  */\n \t\t   && ! TEST_HARD_REG_BIT (reload_reg_used, regnum)\n \t\t   && reload_reg_free_for_value_p (regnum,\n-\t\t\t\t\t\t  reload_opnum[r],\n-\t\t\t\t\t\t  reload_when_needed[r],\n-\t\t\t\t\t\t  reload_in[r],\n-\t\t\t\t\t\t  reload_out[r], r, 1)))\n+\t\t\t\t\t\t   reload_opnum[r],\n+\t\t\t\t\t\t   reload_when_needed[r],\n+\t\t\t\t\t\t   reload_in[r],\n+\t\t\t\t\t\t   reload_out[r], r, 1)))\n \t      && TEST_HARD_REG_BIT (reg_class_contents[class], regnum)\n \t      && HARD_REGNO_MODE_OK (regnum, reload_mode[r])\n \t      /* Look first for regs to share, then for unshared.  But\n@@ -5536,7 +5536,7 @@ allocate_reload_reg (chain, r, last_reload, noerror)\n   if (new == 0 || GET_MODE (new) != reload_mode[r])\n     spill_reg_rtx[i] = new\n       = gen_rtx_REG (reload_mode[r], spill_regs[i]);\n-\t    \n+\n   regno = true_regnum (new);\n \n   /* Detect when the reload reg can't hold the reload mode.\n@@ -5661,7 +5661,7 @@ choose_reload_regs (chain)\n     }\n \n   IOR_COMPL_HARD_REG_SET (reload_reg_used, chain->used_spill_regs);\n-  \n+\n #if 0  /* Not needed, now that we can always retry without inheritance.  */\n   /* See if we have more mandatory reloads than spill regs.\n      If so, then we cannot risk optimizations that could prevent\n@@ -5699,10 +5699,10 @@ choose_reload_regs (chain)\n       reload_spill_index[j] = -1;\n \n       reload_mode[j]\n-\t= (reload_inmode[j] == VOIDmode\n+\t= ((reload_inmode[j] == VOIDmode\n \t   || (GET_MODE_SIZE (reload_outmode[j])\n \t       > GET_MODE_SIZE (reload_inmode[j])))\n-\t  ? reload_outmode[j] : reload_inmode[j];\n+\t   ? reload_outmode[j] : reload_inmode[j]);\n \n       reload_nregs[j] = CLASS_MAX_NREGS (reload_reg_class[j], reload_mode[j]);\n \n@@ -5893,7 +5893,7 @@ choose_reload_regs (chain)\n \t\t{\n \t\t  enum reg_class class = reload_reg_class[r], last_class;\n \t\t  rtx last_reg = reg_last_reload_reg[regno];\n-\t\t  \n+\n \t\t  i = REGNO (last_reg) + word;\n \t\t  last_class = REGNO_REG_CLASS (i);\n \t\t  if ((GET_MODE_SIZE (GET_MODE (last_reg))\n@@ -6177,7 +6177,7 @@ choose_reload_regs (chain)\n \t\t   && reg_classes_intersect_p (reload_reg_class[r],\n \t\t\t\t\t       reload_reg_class[s]))\n \t\t  || reload_nregs[s] < reload_nregs[r])\n-\t      break;\n+\t\tbreak;\n \t    }\n \n \t  if (i == n_reloads)\n@@ -6270,15 +6270,15 @@ choose_reload_regs (chain)\n \t    check_reg = reload_reg_rtx[r];\n \t  else if (reload_override_in[r]\n \t\t   && (GET_CODE (reload_override_in[r]) == REG\n-\t    \t\t     || GET_CODE (reload_override_in[r]) == SUBREG))\n+\t\t       || GET_CODE (reload_override_in[r]) == SUBREG))\n \t    check_reg = reload_override_in[r];\n \t  else\n \t    continue;\n \t  if (! reload_reg_free_for_value_p (true_regnum (check_reg),\n-\t    \t\t\t\t     reload_opnum[r],\n-\t    \t\t\t\t     reload_when_needed[r],\n-\t    \t\t\t\t     reload_in[r],\n-\t    \t\t\t\t     (reload_inherited[r]\n+\t\t\t\t\t     reload_opnum[r],\n+\t\t\t\t\t     reload_when_needed[r],\n+\t\t\t\t\t     reload_in[r],\n+\t\t\t\t\t     (reload_inherited[r]\n \t\t\t\t\t      ? reload_out[r] : const0_rtx),\n \t\t\t\t\t     r, 1))\n \t    {\n@@ -6387,7 +6387,7 @@ deallocate_reload_reg (r)\n /* If SMALL_REGISTER_CLASSES is non-zero, we may not have merged two\n    reloads of the same item for fear that we might not have enough reload\n    registers. However, normally they will get the same reload register\n-   and hence actually need not be loaded twice.  \n+   and hence actually need not be loaded twice.\n \n    Here we check for the most common case of this phenomenon: when we have\n    a number of reloads for the same object, each of which were allocated\n@@ -6492,7 +6492,7 @@ merge_assigned_reloads (insn)\n \t\t     ? RELOAD_FOR_OTHER_ADDRESS : RELOAD_OTHER);\n \t}\n     }\n-}\t    \n+}\n \n \f\n /* Output insns to reload values in and out of the chosen reload regs.  */\n@@ -6790,7 +6790,7 @@ emit_reload_insns (chain)\n \t\t      uses the same reg first.  */\n \t\t   && reload_reg_free_for_value_p (REGNO (reloadreg),\n \t\t\t\t\t\t   reload_opnum[j],\n-\t\t\t\t\t\t   reload_when_needed[j], \n+\t\t\t\t\t\t   reload_when_needed[j],\n \t\t\t\t\t\t   old, reload_out[j],\n \t\t\t\t\t\t   j, 0))\n \t    {\n@@ -6871,12 +6871,12 @@ emit_reload_insns (chain)\n \t\t     equivalent MEM, we must fall back to reload_in, which\n \t\t     will have all the necessary substitutions registered.\n \t\t     Likewise for a pseudo that can't be replaced with its\n-\t\t     equivalent constant. \n+\t\t     equivalent constant.\n \n \t\t     Take extra care for subregs of such pseudos.  Note that\n \t\t     we cannot use reg_equiv_mem in this case because it is\n \t\t     not in the right mode.  */\n-\t\t\t\t\n+\n \t\t  tmp = oldequiv;\n \t\t  if (GET_CODE (tmp) == SUBREG)\n \t\t    tmp = SUBREG_REG (tmp);\n@@ -6964,7 +6964,7 @@ emit_reload_insns (chain)\n \t\t     to see if it is being used as a scratch or intermediate\n \t\t     register and generate code appropriately.  If we need\n \t\t     a scratch register, use REAL_OLDEQUIV since the form of\n-\t\t     the insn may depend on the actual address if it is \n+\t\t     the insn may depend on the actual address if it is\n \t\t     a MEM.  */\n \n \t\t  if (second_reload_reg)\n@@ -6985,7 +6985,7 @@ emit_reload_insns (chain)\n \t\t\t  if (tertiary_icode != CODE_FOR_nothing)\n \t\t\t    {\n \t\t\t      rtx third_reload_reg\n-\t\t\t        = reload_reg_rtx[reload_secondary_in_reload[secondary_reload]];\n+\t\t\t\t= reload_reg_rtx[reload_secondary_in_reload[secondary_reload]];\n \n \t\t\t      emit_insn ((GEN_FCN (tertiary_icode)\n \t\t\t\t\t  (second_reload_reg, real_oldequiv,\n@@ -7064,12 +7064,12 @@ emit_reload_insns (chain)\n \t  /* There doesn't seem to be any reason to restrict this to pseudos\n \t     and doing so loses in the case where we are copying from a\n \t     register of the wrong class.  */\n-\t  && REGNO (spill_reg_stored_to[REGNO (reload_reg_rtx[j])])\n-\t     >= FIRST_PSEUDO_REGISTER\n+\t  && (REGNO (spill_reg_stored_to[REGNO (reload_reg_rtx[j])])\n+\t      >= FIRST_PSEUDO_REGISTER)\n #endif\n-\t     /* The insn might have already some references to stackslots\n-\t\treplaced by MEMs, while reload_out_reg still names the\n-\t\toriginal pseudo.  */\n+\t  /* The insn might have already some references to stackslots\n+\t     replaced by MEMs, while reload_out_reg still names the\n+\t     original pseudo.  */\n \t  && (dead_or_set_p (insn,\n \t\t\t     spill_reg_stored_to[REGNO (reload_reg_rtx[j])])\n \t      || rtx_equal_p (spill_reg_stored_to[REGNO (reload_reg_rtx[j])],\n@@ -7088,7 +7088,7 @@ emit_reload_insns (chain)\n \t store.  */\n       {\n \trtx pseudo = reload_out_reg[j];\n-\t  \n+\n \tif (pseudo\n \t    && GET_CODE (pseudo) == REG\n \t    && ! rtx_equal_p (reload_in_reg[j], pseudo)\n@@ -7320,8 +7320,8 @@ emit_reload_insns (chain)\n \t\t\t       has and where the actual store to the pseudo is\n \t\t\t       made; leave new_spill_reg_store alone.  */\n \t\t\telse if (s >= 0\n-\t\t\t    && SET_SRC (set) == reload_reg_rtx[j]\n-\t\t\t    && SET_DEST (set) == reload_reg_rtx[s])\n+\t\t\t\t && SET_SRC (set) == reload_reg_rtx[j]\n+\t\t\t\t && SET_DEST (set) == reload_reg_rtx[s])\n \t\t\t  {\n \t\t\t    /* Usually the next instruction will be the\n \t\t\t       secondary reload insn;  if we can confirm\n@@ -7407,9 +7407,9 @@ emit_reload_insns (chain)\n   if (n_basic_blocks)\n     {\n       if (BLOCK_HEAD (chain->block) == insn)\n-        BLOCK_HEAD (chain->block) = NEXT_INSN (before_insn);\n+\tBLOCK_HEAD (chain->block) = NEXT_INSN (before_insn);\n       if (BLOCK_END (chain->block) == insn)\n-        BLOCK_END (chain->block) = PREV_INSN (following_insn);\n+\tBLOCK_END (chain->block) = PREV_INSN (following_insn);\n     }\n \n   /* For all the spill regs newly reloaded in this instruction,\n@@ -7425,33 +7425,33 @@ emit_reload_insns (chain)\n       register int i = reload_spill_index[r];\n \n       /* If this is a non-inherited input reload from a pseudo, we must\n-         clear any memory of a previous store to the same pseudo.  Only do\n-         something if there will not be an output reload for the pseudo\n-         being reloaded.  */\n+\t clear any memory of a previous store to the same pseudo.  Only do\n+\t something if there will not be an output reload for the pseudo\n+\t being reloaded.  */\n       if (reload_in_reg[r] != 0\n-          && ! (reload_inherited[r] || reload_override_in[r]))\n-        {\n-          rtx reg = reload_in_reg[r];\n+\t  && ! (reload_inherited[r] || reload_override_in[r]))\n+\t{\n+\t  rtx reg = reload_in_reg[r];\n \n-          if (GET_CODE (reg) == SUBREG)\n+\t  if (GET_CODE (reg) == SUBREG)\n \t    reg = SUBREG_REG (reg);\n-\t\n-          if (GET_CODE (reg) == REG\n+\n+\t  if (GET_CODE (reg) == REG\n \t      && REGNO (reg) >= FIRST_PSEUDO_REGISTER\n \t      && ! reg_has_output_reload[REGNO (reg)])\n \t    {\n \t      int nregno = REGNO (reg);\n \n \t      if (reg_last_reload_reg[nregno])\n-\t        {\n-\t          int last_regno = REGNO (reg_last_reload_reg[nregno]);\n+\t\t{\n+\t\t  int last_regno = REGNO (reg_last_reload_reg[nregno]);\n \n-\t          if (reg_reloaded_contents[last_regno] == nregno)\n+\t\t  if (reg_reloaded_contents[last_regno] == nregno)\n \t\t    spill_reg_store[last_regno] = 0;\n-\t        }\n+\t\t}\n \t    }\n \t}\n-\t\t  \n+\n       /* I is nonneg if this reload used a register.\n \t If reload_reg_rtx[r] is 0, this is an optional reload\n \t that we opted to ignore.  */\n@@ -7508,7 +7508,7 @@ emit_reload_insns (chain)\n \t\t  reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n \n \t\t  /* If NREGNO is a hard register, it may occupy more than\n-\t\t     one register.  If it does, say what is in the \n+\t\t     one register.  If it does, say what is in the\n \t\t     rest of the registers assuming that both registers\n \t\t     agree on how many words the object takes.  If not,\n \t\t     invalidate the subsequent registers.  */\n@@ -7560,7 +7560,7 @@ emit_reload_insns (chain)\n \t\t  nnr = (nregno >= FIRST_PSEUDO_REGISTER ? 1\n \t\t\t : HARD_REGNO_NREGS (nregno,\n \t\t\t\t\t     GET_MODE (reload_reg_rtx[r])));\n-\t\t  \n+\n \t\t  reg_last_reload_reg[nregno] = reload_reg_rtx[r];\n \n \t\t  if (nregno < FIRST_PSEUDO_REGISTER)\n@@ -7697,7 +7697,7 @@ emit_reload_insns (chain)\n \f\n /* Emit code to perform a reload from IN (which may be a reload register) to\n    OUT (which may also be a reload register).  IN or OUT is from operand\n-   OPNUM with reload type TYPE. \n+   OPNUM with reload type TYPE.\n \n    Returns first insn emitted.  */\n \n@@ -7936,7 +7936,7 @@ delete_output_reload (insn, j, last_reload_reg)\n   int n_inherited = 0;\n   register rtx i1;\n   rtx substed;\n-  \n+\n   /* Get the raw pseudo-register referred to.  */\n \n   while (GET_CODE (reg) == SUBREG)\n@@ -8288,7 +8288,7 @@ inc_for_reload (reloadreg, in, value, inc_amount)\n       add_insn = emit_insn (gen_rtx_SET (VOIDmode, incloc,\n \t\t\t\t\t gen_rtx_PLUS (GET_MODE (incloc),\n \t\t\t\t\t\t       incloc, inc)));\n-\t\t\t\t\t\t\t  \n+\n       code = recog_memoized (add_insn);\n       if (code >= 0)\n \t{\n@@ -8423,7 +8423,7 @@ count_occurrences (x, find)\n       if (SET_DEST (x) == find)\n \treturn count_occurrences (SET_SRC (x), find);\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -8519,8 +8519,8 @@ reload_cse_invalidate_regno (regno, mode, clobber)\n \t      && refers_to_regno_p (regno, endregno, XEXP (x, 0), NULL_PTR))\n \t    {\n \t      /* If this is the only entry on the list, clear\n-                 reg_values[i].  Otherwise, just clear this entry on\n-                 the list.  */\n+\t\t reg_values[i].  Otherwise, just clear this entry on\n+\t\t the list.  */\n \t      if (XEXP (x, 1) == 0 && x == reg_values[i])\n \t\t{\n \t\t  reg_values[i] = 0;\n@@ -8641,8 +8641,8 @@ reload_cse_invalidate_mem (mem_rtx)\n \t      && reload_cse_mem_conflict_p (mem_rtx, XEXP (x, 0)))\n \t    {\n \t      /* If this is the only entry on the list, clear\n-                 reg_values[i].  Otherwise, just clear this entry on\n-                 the list.  */\n+\t\t reg_values[i].  Otherwise, just clear this entry on\n+\t\t the list.  */\n \t      if (XEXP (x, 1) == 0 && x == reg_values[i])\n \t\t{\n \t\t  reg_values[i] = 0;\n@@ -8685,7 +8685,7 @@ reload_cse_invalidate_rtx (dest, ignore)\n    This function also detects cases where we load a value from memory\n    into two different registers, and (if memory is more expensive than\n    registers) changes it to simply copy the first register into the\n-   second register.  \n+   second register.\n \n    Another optimization is performed that scans the operands of each\n    instruction to see whether the value is already available in a\n@@ -8726,14 +8726,14 @@ reload_cse_regs_1 (first)\n       if (GET_CODE (insn) == CODE_LABEL)\n \t{\n \t  /* Forget all the register values at a code label.  We don't\n-             try to do anything clever around jumps.  */\n+\t     try to do anything clever around jumps.  */\n \t  for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \t    reg_values[i] = 0;\n \n \t  continue;\n \t}\n \n-#ifdef NON_SAVING_SETJMP \n+#ifdef NON_SAVING_SETJMP\n       if (NON_SAVING_SETJMP && GET_CODE (insn) == NOTE\n \t  && NOTE_LINE_NUMBER (insn) == NOTE_INSN_SETJMP)\n \t{\n@@ -8760,7 +8760,7 @@ reload_cse_regs_1 (first)\n \t    reload_cse_invalidate_mem (callmem);\n \t}\n \n-      \n+\n       /* Forget all the register values at a volatile asm.  */\n       if (GET_CODE (insn) == INSN\n \t  && GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n@@ -8807,7 +8807,7 @@ reload_cse_regs_1 (first)\n \t    apply_change_group ();\n \t  else\n \t    reload_cse_simplify_operands (insn);\n-\t    \n+\n \t  reload_cse_record_set (body, body);\n \t}\n       else if (GET_CODE (body) == PARALLEL)\n@@ -8816,7 +8816,7 @@ reload_cse_regs_1 (first)\n \t  rtx value = NULL_RTX;\n \n \t  /* If every action in a PARALLEL is a noop, we can delete\n-             the entire PARALLEL.  */\n+\t     the entire PARALLEL.  */\n \t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n \t    {\n \t      rtx part = XVECEXP (body, 0, i);\n@@ -8854,7 +8854,7 @@ reload_cse_regs_1 (first)\n \t      /* We're done with this insn.  */\n \t      continue;\n \t    }\n-\t  \n+\n \t  /* It's not a no-op, but we can try to simplify it.  */\n \t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n \t    if (GET_CODE (XVECEXP (body, 0, i)) == SET)\n@@ -8866,7 +8866,7 @@ reload_cse_regs_1 (first)\n \t    reload_cse_simplify_operands (insn);\n \n \t  /* Look through the PARALLEL and record the values being\n-             set, if possible.  Also handle any CLOBBERs.  */\n+\t     set, if possible.  Also handle any CLOBBERs.  */\n \t  for (i = XVECLEN (body, 0) - 1; i >= 0; --i)\n \t    {\n \t      rtx x = XVECEXP (body, 0, i);\n@@ -8882,8 +8882,8 @@ reload_cse_regs_1 (first)\n \n #ifdef AUTO_INC_DEC\n       /* Clobber any registers which appear in REG_INC notes.  We\n-         could keep track of the changes to their values, but it is\n-         unlikely to help.  */\n+\t could keep track of the changes to their values, but it is\n+\t unlikely to help.  */\n       {\n \trtx x;\n \n@@ -8894,7 +8894,7 @@ reload_cse_regs_1 (first)\n #endif\n \n       /* Look for any CLOBBERs in CALL_INSN_FUNCTION_USAGE, but only\n-         after we have processed the insn.  */\n+\t after we have processed the insn.  */\n       if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx x;\n@@ -8998,12 +8998,12 @@ reload_cse_noop_set_p (set, insn)\n \tret = 1;\n \n       /* Check for setting a register to a value which we already know\n-         is in the register.  */\n+\t is in the register.  */\n       else if (reload_cse_regno_equal_p (dreg, src, dest_mode))\n \tret = 1;\n \n       /* Check for setting a register DREG to another register SREG\n-         where SREG is equal to a value which is already in DREG.  */\n+\t where SREG is equal to a value which is already in DREG.  */\n       else if (sreg >= 0)\n \t{\n \t  rtx x;\n@@ -9035,7 +9035,7 @@ reload_cse_noop_set_p (set, insn)\n   else if (GET_CODE (dest) == MEM)\n     {\n       /* Check for storing a register to memory when we know that the\n-         register is equivalent to the memory location. */\n+\t register is equivalent to the memory location. */\n       if (sreg >= 0\n \t  && reload_cse_regno_equal_p (sreg, dest, dest_mode)\n \t  && ! side_effects_p (dest))\n@@ -9098,7 +9098,7 @@ reload_cse_simplify_set (set, insn)\n \t\t\t\t       gen_rtx_REG (dest_mode, i), 1);\n \n \t  /* Go back to the obstack we are using for temporary\n-             storage.  */\n+\t     storage.  */\n \t  push_obstacks (&reload_obstack, &reload_obstack);\n \n \t  if (validated)\n@@ -9109,8 +9109,8 @@ reload_cse_simplify_set (set, insn)\n }\n \n /* Try to replace operands in INSN with equivalent values that are already\n-   in registers.  This can be viewed as optional reloading.  \n- \n+   in registers.  This can be viewed as optional reloading.\n+\n    For each non-register operand in the insn, see if any hard regs are\n    known to be equivalent to that operand.  Record the alternatives which\n    can accept these hard registers.  Among all alternatives, select the\n@@ -9127,7 +9127,7 @@ reload_cse_simplify_operands (insn)\n   int i,j;\n \n   const char *constraints[MAX_RECOG_OPERANDS];\n-  \n+\n   /* Vector recording how bad an alternative is.  */\n   int *alternative_reject;\n   /* Vector recording how many registers can be introduced by choosing\n@@ -9140,7 +9140,7 @@ reload_cse_simplify_operands (insn)\n   /* Array of alternatives, sorted in order of decreasing desirability.  */\n   int *alternative_order;\n   rtx reg = gen_rtx_REG (VOIDmode, -1);\n-  \n+\n   extract_insn (insn);\n \n   if (recog_n_alternatives == 0 || recog_n_operands == 0)\n@@ -9209,12 +9209,12 @@ reload_cse_simplify_operands (insn)\n \t  for (;;)\n \t    {\n \t      char c = *p++;\n-\t      \n+\n \t      switch (c)\n \t\t{\n \t\tcase '=':  case '+':  case '?':\n \t\tcase '#':  case '&':  case '!':\n-\t\tcase '*':  case '%':  \n+\t\tcase '*':  case '%':\n \t\tcase '0':  case '1':  case '2':  case '3':  case '4':\n \t\tcase 'm':  case '<':  case '>':  case 'V':  case 'o':\n \t\tcase 'E':  case 'F':  case 'G':  case 'H':\n@@ -9289,12 +9289,12 @@ reload_cse_simplify_operands (insn)\n \t      best_nregs = this_nregs;\n \t    }\n \t}\n-      \n+\n       tmp = alternative_order[best];\n       alternative_order[best] = alternative_order[i];\n       alternative_order[i] = tmp;\n     }\n-  \n+\n   /* Substitute the operands as determined by op_alt_regno for the best\n      alternative.  */\n   j = alternative_order[0];\n@@ -9441,7 +9441,7 @@ reload_cse_record_set (set, body)\n       int i;\n \n       /* This is an assignment to a register.  Update the value we\n-         have stored for the register.  */\n+\t have stored for the register.  */\n       if (sreg >= 0)\n \t{\n \t  rtx x;\n@@ -9460,24 +9460,24 @@ reload_cse_record_set (set, body)\n \t      if (dest_mode == GET_MODE (XEXP (x, 0)))\n \t\ttmp = XEXP (x, 0);\n \t      else if (GET_MODE_BITSIZE (dest_mode)\n-\t\t        > GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))))\n+\t\t\t> GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))))\n \t\tcontinue;\n \t      else\n \t\ttmp = gen_lowpart_common (dest_mode, XEXP (x, 0));\n \t      if (tmp)\n \t\treg_values[dreg] = gen_rtx_EXPR_LIST (dest_mode, tmp,\n \t\t\t\t\t\t      reg_values[dreg]);\n-\t    }\t      \n+\t    }\n \t}\n       else\n \treg_values[dreg] = gen_rtx_EXPR_LIST (dest_mode, src, NULL_RTX);\n \n       /* We've changed DREG, so invalidate any values held by other\n-         registers that depend upon it.  */\n+\t registers that depend upon it.  */\n       reload_cse_invalidate_regno (dreg, dest_mode, 0);\n \n       /* If this assignment changes more than one hard register,\n-         forget anything we know about the others.  */\n+\t forget anything we know about the others.  */\n       for (i = 1; i < HARD_REGNO_NREGS (dreg, dest_mode); i++)\n \treg_values[dreg + i] = 0;\n     }\n@@ -9487,7 +9487,7 @@ reload_cse_record_set (set, body)\n       reload_cse_invalidate_mem (dest);\n \n       /* If we're storing a register to memory, add DEST to the list\n-         in REG_VALUES.  */\n+\t in REG_VALUES.  */\n       if (sreg >= 0 && ! side_effects_p (dest))\n \treg_values[sreg] = gen_rtx_EXPR_LIST (dest_mode, dest,\n \t\t\t\t    reg_values[sreg]);\n@@ -9610,7 +9610,7 @@ reload_combine ()\n \n       /* We cannot do our optimization across labels.  Invalidating all the use\n \t information we have would be costly, so we just note where the label\n-         is and then later disable any optimization that would cross it.  */\n+\t is and then later disable any optimization that would cross it.  */\n       if (GET_CODE (insn) == CODE_LABEL)\n \tlast_label_ruid = reload_combine_ruid;\n       if (GET_CODE (insn) == BARRIER)\n@@ -9670,11 +9670,11 @@ reload_combine ()\n \t    }\n \t  else\n \t    {\n-\t       /* Otherwise, look for a free index register.  Since we have\n-\t\t  checked above that neiter REG nor BASE are index registers,\n-\t\t  if we find anything at all, it will be different from these\n-\t\t  two registers.  */\n-\t       for (i = first_index_reg; i <= last_index_reg; i++)\n+\t      /* Otherwise, look for a free index register.  Since we have\n+\t\t checked above that neiter REG nor BASE are index registers,\n+\t\t if we find anything at all, it will be different from these\n+\t\t two registers.  */\n+\t      for (i = first_index_reg; i <= last_index_reg; i++)\n \t\t{\n \t\t  if (TEST_HARD_REG_BIT (reg_class_contents[INDEX_REG_CLASS], i)\n \t\t      && reg_state[i].use_index == RELOAD_COMBINE_MAX_USES\n@@ -9825,7 +9825,7 @@ reload_combine_note_store (dst, set)\n   regno += REGNO (dst);\n \n   /* note_stores might have stripped a STRICT_LOW_PART, so we have to be\n-     careful with registers / register parts that are not full words. \n+     careful with registers / register parts that are not full words.\n \n      Similarly for ZERO_EXTRACT and SIGN_EXTRACT.  */\n   if (GET_CODE (set) != SET\n@@ -9884,7 +9884,7 @@ reload_combine_note_use (xp, insn)\n \tbreak;\n       offset = XEXP (x, 1);\n       x = XEXP (x, 0);\n-    /* Fall through.  */\n+      /* Fall through.  */\n     case REG:\n       {\n \tint regno = REGNO (x);\n@@ -10023,9 +10023,9 @@ reload_cse_move2add (first)\n \t  /* ??? We don't know how zero / sign extension is handled, hence\n \t     we can't go from a narrower to a wider mode.  */\n \t  if (reg_set_luid[regno] > last_label_luid\n-\t     && (GET_MODE_SIZE (GET_MODE (reg))\n-\t\t <= GET_MODE_SIZE (reg_mode[regno]))\n-\t     && GET_CODE (reg_offset[regno]) == CONST_INT)\n+\t      && (GET_MODE_SIZE (GET_MODE (reg))\n+\t\t  <= GET_MODE_SIZE (reg_mode[regno]))\n+\t      && GET_CODE (reg_offset[regno]) == CONST_INT)\n \t    {\n \t      /* Try to transform (set (REGX) (CONST_INT A))\n \t\t\t\t  ..."}]}