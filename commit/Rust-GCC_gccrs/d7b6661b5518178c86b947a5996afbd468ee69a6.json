{"sha": "d7b6661b5518178c86b947a5996afbd468ee69a6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdiNjY2MWI1NTE4MTc4Yzg2Yjk0N2E1OTk2YWZiZDQ2OGVlNjlhNg==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-11-13T22:55:49Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2013-11-13T22:55:49Z"}, "message": "cfgrtl.c (can_fallthru): Reorder code to move tablejump check up.\n\n\n\t* cfgrtl.c (can_fallthru): Reorder code to move tablejump check up.\n\tMake that check explicit.  BB_HEAD cannot be NULL, remove check for it.\n\t* haifa-sched.c (ready_remove_first_dispatch): Check INSN_P before\n\tlooking at INSN_CODE.\n\t* reload1.c (delete_dead_insn) Do not expect JUMP_TABLE_DATA to be an\n\tactive_insn_p object, respect basic block boundaries.\n\t* reorg.c (follow_jumps): Use invariant that JUMP_TABLE_DATA always\n\tfollows immediately after the jump table data label.\n\t* config/nds32/nds32.c (nds32_output_casesi_pc_relative): Likewise.\n\t* config/sh/sh.c (barrier_align): Likewise.  Rearrange code such\n\tthat JUMP_TABLE_DATA is not expected to be an active_insn_p object.\n\nFrom-SVN: r204758", "tree": {"sha": "c0544da5ab78cc2a30727ef7c2fc441c94407305", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0544da5ab78cc2a30727ef7c2fc441c94407305"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7b6661b5518178c86b947a5996afbd468ee69a6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7b6661b5518178c86b947a5996afbd468ee69a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7b6661b5518178c86b947a5996afbd468ee69a6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7b6661b5518178c86b947a5996afbd468ee69a6/comments", "author": null, "committer": null, "parents": [{"sha": "c3d77f3add93300df9893709111089f2a9650e83", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3d77f3add93300df9893709111089f2a9650e83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3d77f3add93300df9893709111089f2a9650e83"}], "stats": {"total": 92, "additions": 58, "deletions": 34}, "files": [{"sha": "c5448784624fed42e4c11af823e741a0ec4610a8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d7b6661b5518178c86b947a5996afbd468ee69a6", "patch": "@@ -1,3 +1,17 @@\n+2013-11-13  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\t* cfgrtl.c (can_fallthru): Reorder code to move tablejump check up.\n+\tMake that check explicit.  BB_HEAD cannot be NULL, remove check for it.\n+\t* haifa-sched.c (ready_remove_first_dispatch): Check INSN_P before\n+\tlooking at INSN_CODE.\n+\t* reload1.c (delete_dead_insn) Do not expect JUMP_TABLE_DATA to be an\n+\tactive_insn_p object, respect basic block boundaries.\n+\t* reorg.c (follow_jumps): Use invariant that JUMP_TABLE_DATA always\n+\tfollows immediately after the jump table data label.\n+\t* config/nds32/nds32.c (nds32_output_casesi_pc_relative): Likewise.\n+\t* config/sh/sh.c (barrier_align): Likewise.  Rearrange code such\n+\tthat JUMP_TABLE_DATA is not expected to be an active_insn_p object.\n+\n 2013-11-13  Teresa Johnson  <tejohnson@google.com>\n \n \tPR ipa/58862"}, {"sha": "c7ee7eee6362bbdd7efa3011f94989f9c1eafcd5", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=d7b6661b5518178c86b947a5996afbd468ee69a6", "patch": "@@ -610,7 +610,7 @@ forwarder_block_p (const_basic_block bb)\n }\n \n /* Return nonzero if we can reach target from src by falling through.  */\n-/* FIXME: Make this a cfg hook.  */\n+/* FIXME: Make this a cfg hook, the result is only valid in cfgrtl mode.  */\n \n bool\n can_fallthru (basic_block src, basic_block target)\n@@ -623,17 +623,21 @@ can_fallthru (basic_block src, basic_block target)\n   if (target == EXIT_BLOCK_PTR)\n     return true;\n   if (src->next_bb != target)\n-    return 0;\n+    return false;\n+\n+  /* ??? Later we may add code to move jump tables offline.  */\n+  if (tablejump_p (insn, NULL, NULL))\n+    return false;\n+\n   FOR_EACH_EDGE (e, ei, src->succs)\n     if (e->dest == EXIT_BLOCK_PTR\n \t&& e->flags & EDGE_FALLTHRU)\n-      return 0;\n+      return false;\n \n   insn2 = BB_HEAD (target);\n-  if (insn2 && !active_insn_p (insn2))\n+  if (!active_insn_p (insn2))\n     insn2 = next_active_insn (insn2);\n \n-  /* ??? Later we may add code to move jump tables offline.  */\n   return next_active_insn (insn) == insn2;\n }\n "}, {"sha": "f039e2789c5fd3dc0ea9424a0a78c3003a2be4fc", "filename": "gcc/config/nds32/nds32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Fconfig%2Fnds32%2Fnds32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Fconfig%2Fnds32%2Fnds32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnds32%2Fnds32.c?ref=d7b6661b5518178c86b947a5996afbd468ee69a6", "patch": "@@ -4677,7 +4677,7 @@ nds32_output_casesi_pc_relative (rtx *operands)\n   enum machine_mode mode;\n   rtx diff_vec;\n \n-  diff_vec = PATTERN (next_active_insn (operands[1]));\n+  diff_vec = PATTERN (NEXT_INSN (operands[1]));\n \n   gcc_assert (GET_CODE (diff_vec) == ADDR_DIFF_VEC);\n "}, {"sha": "973d25ae38bb4bc569bc4822d1ae3f7fbb525bbe", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 22, "deletions": 18, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=d7b6661b5518178c86b947a5996afbd468ee69a6", "patch": "@@ -5774,24 +5774,18 @@ fixup_addr_diff_vecs (rtx first)\n int\n barrier_align (rtx barrier_or_label)\n {\n-  rtx next = next_active_insn (barrier_or_label), pat, prev;\n+  rtx next, pat;\n \n-  if (! next)\n-    return 0;\n-\n-  pat = PATTERN (next);\n-\n-  if (GET_CODE (pat) == ADDR_DIFF_VEC)\n+  if (LABEL_P (barrier_or_label)\n+      && NEXT_INSN (barrier_or_label)\n+      && JUMP_TABLE_DATA_P (NEXT_INSN (barrier_or_label)))\n     return 2;\n \n-  if (GET_CODE (pat) == UNSPEC_VOLATILE && XINT (pat, 1) == UNSPECV_ALIGN)\n-    /* This is a barrier in front of a constant table.  */\n-    return 0;\n-\n-  prev = prev_active_insn (barrier_or_label);\n-  if (GET_CODE (PATTERN (prev)) == ADDR_DIFF_VEC)\n+  if (BARRIER_P (barrier_or_label)\n+      && PREV_INSN (barrier_or_label)\n+      && JUMP_TABLE_DATA_P (PREV_INSN (barrier_or_label)))\n     {\n-      pat = PATTERN (prev);\n+      pat = PATTERN (PREV_INSN (barrier_or_label));\n       /* If this is a very small table, we want to keep the alignment after\n \t the table to the minimum for proper code alignment.  */\n       return ((optimize_size\n@@ -5800,6 +5794,17 @@ barrier_align (rtx barrier_or_label)\n \t      ? 1 << TARGET_SHMEDIA : align_jumps_log);\n     }\n \n+  next = next_active_insn (barrier_or_label);\n+\n+  if (! next)\n+    return 0;\n+\n+  pat = PATTERN (next);\n+\n+  if (GET_CODE (pat) == UNSPEC_VOLATILE && XINT (pat, 1) == UNSPECV_ALIGN)\n+    /* This is a barrier in front of a constant table.  */\n+    return 0;\n+\n   if (optimize_size)\n     return 0;\n \n@@ -5824,13 +5829,12 @@ barrier_align (rtx barrier_or_label)\n \t (fill_eager_delay_slots) and the branch is to the insn after the insn\n \t after the barrier.  */\n \n-      /* PREV is presumed to be the JUMP_INSN for the barrier under\n-\t investigation.  Skip to the insn before it.  */\n-\n       int slot, credit;\n       bool jump_to_next = false;\n \n-      prev = prev_real_insn (prev);\n+      /* Skip to the insn before the JUMP_INSN before the barrier under\n+\t investigation.  */\n+      rtx prev = prev_real_insn (prev_active_insn (barrier_or_label));\n \n       for (slot = 2, credit = (1 << (CACHE_LOG - 2)) + 2;\n \t   credit >= 0 && prev && NONJUMP_INSN_P (prev);"}, {"sha": "5edf57496b520a7b87f9f9856e75e71fc34c3467", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=d7b6661b5518178c86b947a5996afbd468ee69a6", "patch": "@@ -8589,8 +8589,8 @@ ready_remove_first_dispatch (struct ready_list *ready)\n   rtx insn = ready_element (ready, 0);\n \n   if (ready->n_ready == 1\n-      || INSN_CODE (insn) < 0\n       || !INSN_P (insn)\n+      || INSN_CODE (insn) < 0\n       || !active_insn_p (insn)\n       || targetm.sched.dispatch (insn, FITS_DISPATCH_WINDOW))\n     return ready_remove_first (ready);\n@@ -8599,8 +8599,8 @@ ready_remove_first_dispatch (struct ready_list *ready)\n     {\n       insn = ready_element (ready, i);\n \n-      if (INSN_CODE (insn) < 0\n-\t  || !INSN_P (insn)\n+      if (!INSN_P (insn)\n+\t  || INSN_CODE (insn) < 0\n \t  || !active_insn_p (insn))\n \tcontinue;\n \n@@ -8619,8 +8619,8 @@ ready_remove_first_dispatch (struct ready_list *ready)\n     {\n       insn = ready_element (ready, i);\n \n-      if (INSN_CODE (insn) < 0\n-\t  || !INSN_P (insn)\n+      if (! INSN_P (insn)\n+\t  || INSN_CODE (insn) < 0\n \t  || !active_insn_p (insn))\n \tcontinue;\n "}, {"sha": "2b2d963631e0a05c1d106efb9fb9e4d0a90afe65", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=d7b6661b5518178c86b947a5996afbd468ee69a6", "patch": "@@ -124,7 +124,7 @@\n \n 2012-07-16  Steven Bosscher  <steven@gcc.gnu.org>\n \n-\t* java-gimplify.c Include dumpfile.h instead of tree-dump.h\n+\t* java-gimplify.c: Include dumpfile.h instead of tree-dump.h\n \t* Make-lang.in: Fix dependencies.\n \n 2012-07-11  Steven Bosscher  <steven@gcc.gnu.org>"}, {"sha": "a40e16b12c328c0c8f8495253b7f9e4c33971ca4", "filename": "gcc/reload1.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=d7b6661b5518178c86b947a5996afbd468ee69a6", "patch": "@@ -2123,7 +2123,8 @@ delete_dead_insn (rtx insn)\n      block local equivalences.  Instead of trying to figure out the exact\n      circumstances where we can delete the potentially dead insns, just\n      let DCE do the job.  */\n-  if (prev && GET_CODE (PATTERN (prev)) == SET\n+  if (prev && BLOCK_FOR_INSN (prev) == BLOCK_FOR_INSN (insn)\n+      && GET_CODE (PATTERN (prev)) == SET\n       && (prev_dest = SET_DEST (PATTERN (prev)), REG_P (prev_dest))\n       && reg_mentioned_p (prev_dest, PATTERN (insn))\n       && find_regno_note (insn, REG_DEAD, REGNO (prev_dest))"}, {"sha": "a87979db2934899ccda2b8b57f005baaa563f8a4", "filename": "gcc/reorg.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7b6661b5518178c86b947a5996afbd468ee69a6/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=d7b6661b5518178c86b947a5996afbd468ee69a6", "patch": "@@ -2302,15 +2302,16 @@ follow_jumps (rtx label, rtx jump, bool *crossing)\n        depth++)\n     {\n       rtx this_label = JUMP_LABEL (insn);\n-      rtx tem;\n \n       /* If we have found a cycle, make the insn jump to itself.  */\n       if (this_label == label)\n \treturn label;\n+\n+      /* Cannot follow returns and cannot look through tablejumps.  */\n       if (ANY_RETURN_P (this_label))\n \treturn this_label;\n-      tem = next_active_insn (this_label);\n-      if (tem && JUMP_TABLE_DATA_P (tem))\n+      if (NEXT_INSN (this_label)\n+\t  && JUMP_TABLE_DATA_P (NEXT_INSN (this_label)))\n \tbreak;\n \n       if (!targetm.can_follow_jump (jump, insn))"}]}