{"sha": "c1f76af469388d3df815c82de566387da5ae000f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFmNzZhZjQ2OTM4OGQzZGY4MTVjODJkZTU2NjM4N2RhNWFlMDAwZg==", "commit": {"author": {"name": "Indu Bhagat", "email": "indu.bhagat@oracle.com", "date": "2021-05-20T18:19:04Z"}, "committer": {"name": "Jose E. Marchesi", "email": "jose.marchesi@oracle.com", "date": "2021-06-28T16:47:21Z"}, "message": "CTF/BTF testsuites\n\nThis commit adds a new testsuite for the CTF debug format.\n\n2021-06-28  Indu Bhagat  <indu.bhagat@oracle.com>\n\t    David Faust  <david.faust@oracle.com>\n\ngcc/testsuite/\n\n\t* lib/gcc-dg.exp (gcc-dg-frontend-supports-ctf): New procedure.\n\t(gcc-dg-debug-runtest): Add -gctf support.\n\t* gcc.dg/debug/btf/btf-1.c: New test.\n\t* gcc.dg/debug/btf/btf-2.c: Likewise.\n\t* gcc.dg/debug/btf/btf-anonymous-struct-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-anonymous-union-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-array-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-bitfields-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-bitfields-2.c: Likewise.\n\t* gcc.dg/debug/btf/btf-bitfields-3.c: Likewise.\n\t* gcc.dg/debug/btf/btf-cvr-quals-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-enum-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-forward-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-function-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-function-2.c: Likewise.\n\t* gcc.dg/debug/btf/btf-int-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-pointers-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-struct-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-typedef-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-union-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf-variables-1.c: Likewise.\n\t* gcc.dg/debug/btf/btf.exp: Likewise.\n\t* gcc.dg/debug/ctf/ctf-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-anonymous-struct-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-anonymous-union-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-array-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-array-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-array-3.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-array-4.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-attr-mode-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-attr-used-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-bitfields-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-bitfields-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-bitfields-3.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-bitfields-4.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-complex-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-cvr-quals-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-cvr-quals-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-cvr-quals-3.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-cvr-quals-4.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-enum-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-enum-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-file-scope-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-float-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-forward-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-forward-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-func-index-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-function-pointers-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-function-pointers-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-function-pointers-3.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-functions-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-int-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-objt-index-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-pointers-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-pointers-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-preamble-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-skip-types-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-skip-types-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-skip-types-3.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-skip-types-4.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-skip-types-5.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-skip-types-6.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-str-table-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-struct-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-struct-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-struct-array-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-struct-pointer-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-struct-pointer-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-typedef-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-typedef-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-typedef-3.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-typedef-struct-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-typedef-struct-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-typedef-struct-3.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-union-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-variables-1.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf-variables-2.c: Likewise.\n\t* gcc.dg/debug/ctf/ctf.exp: Likewise.", "tree": {"sha": "5bfb5145325e9e86d4e7b4c6ee7050a52a5c82cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bfb5145325e9e86d4e7b4c6ee7050a52a5c82cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1f76af469388d3df815c82de566387da5ae000f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1f76af469388d3df815c82de566387da5ae000f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1f76af469388d3df815c82de566387da5ae000f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1f76af469388d3df815c82de566387da5ae000f/comments", "author": {"login": "ibhagatgnu", "id": 51812649, "node_id": "MDQ6VXNlcjUxODEyNjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/51812649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibhagatgnu", "html_url": "https://github.com/ibhagatgnu", "followers_url": "https://api.github.com/users/ibhagatgnu/followers", "following_url": "https://api.github.com/users/ibhagatgnu/following{/other_user}", "gists_url": "https://api.github.com/users/ibhagatgnu/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibhagatgnu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibhagatgnu/subscriptions", "organizations_url": "https://api.github.com/users/ibhagatgnu/orgs", "repos_url": "https://api.github.com/users/ibhagatgnu/repos", "events_url": "https://api.github.com/users/ibhagatgnu/events{/privacy}", "received_events_url": "https://api.github.com/users/ibhagatgnu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jemarch", "id": 7061875, "node_id": "MDQ6VXNlcjcwNjE4NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/7061875?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jemarch", "html_url": "https://github.com/jemarch", "followers_url": "https://api.github.com/users/jemarch/followers", "following_url": "https://api.github.com/users/jemarch/following{/other_user}", "gists_url": "https://api.github.com/users/jemarch/gists{/gist_id}", "starred_url": "https://api.github.com/users/jemarch/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jemarch/subscriptions", "organizations_url": "https://api.github.com/users/jemarch/orgs", "repos_url": "https://api.github.com/users/jemarch/repos", "events_url": "https://api.github.com/users/jemarch/events{/privacy}", "received_events_url": "https://api.github.com/users/jemarch/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7e215a8ee81d44281d9e0a2a25eceb47b6911dd"}], "stats": {"total": 2391, "additions": 2376, "deletions": 15}, "files": [{"sha": "bcbc949243987672242503dcf0cac21f587eefee", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-gbtf\" } */\n+\n+void func(void)\n+{\n+}"}, {"sha": "70e2ff1e0536443c5d1fd7c78ebdfb8f4c2782f8", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,10 @@\n+/* Check the BTF header information.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"0xeb9f.*btf_magic\" 1} } */\n+/* { dg-final { scan-assembler-times \"0x1.*btf_version\" 1 } } */\n+/* { dg-final { scan-assembler-times \"0.*btf_flags\" 1 } } */\n+\n+int foo;"}, {"sha": "89a5701bba0d370d43c18b11ee962d693f46b090", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-anonymous-struct-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-anonymous-struct-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-anonymous-struct-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-anonymous-struct-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,23 @@\n+/* Test BTF generation of anonymous struct.\n+\n+   We expect two BTF struct records:\n+   - struct foo, with two fields \"a\" and \"bar\"\n+   - struct <anonymous> with one field \"b\"\n+\n+   The anonymous struct should have a name of 0, pointing to the null string\n+   at the start of the string table.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* Struct type with 2 members (struct foo).  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4000002\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* Struct type with 1 member (anon struct).  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4000001\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*btt_name\" 1 } } */\n+\n+struct foo\n+{\n+  int a;\n+  struct { int b; } bar;\n+} myfoo;"}, {"sha": "f3b120bb4588d79378ebf5d330512571d382711e", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-anonymous-union-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-anonymous-union-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-anonymous-union-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-anonymous-union-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,23 @@\n+/* Test BTF generation of anonymous union.\n+\n+   We expect a named struct type and an anonymous union type record to\n+   be generated. The anonymous union record should have a name of 0,\n+   pointing to the null string at the start of the string table.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* Struct type with 1 member.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4000001\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* Union type with 2 members.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x5000002\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*btt_name\" 1 } } */\n+\n+struct foo\n+{\n+  union\n+    {\n+      int value;\n+      char ascii;\n+    };\n+} myfoo;"}, {"sha": "ab55445bd355ed095e2af991e985e910a3041000", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-array-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-array-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-array-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-array-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,31 @@\n+/* BTF generation for array type.\n+\n+   Unsized arrays are encoded with a 0 for the number of elements.\n+\n+   In this testcase, 5 distinct BTF records for arrays are expected\n+   b1 : cta_nelems = 2\n+   c1 : cta_nelems = 3\n+   a1 : cta_nelems = 2, 5\n+   buf : cta_nelems = 0.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"0x3000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 5 } } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2\\[\\t \\]+\\[^\\n\\]*bta_nelems\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x3\\[\\t \\]+\\[^\\n\\]*bta_nelems\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x5\\[\\t \\]+\\[^\\n\\]*bta_nelems\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*bta_nelems\" 1 } } */\n+\n+int b1[2] = {0,1};\n+int c1[5] = {0,1,2,3,4};\n+int a1[2][3] = { {3,4,5}, {2,3,4} };\n+\n+/* Variable length struct using arrays.  */\n+struct my_array\n+{\n+  int flags;\n+  int length;\n+  int buf[];\n+} my_array_obj;"}, {"sha": "c6bf52130dc0cf8effa7d46bb563fc5e45b92fc8", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-bitfields-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,34 @@\n+/* Basic tests for BTF bitfields.\n+\n+   The structure containing bitfield members should be marked with KIND_FLAG=1\n+   The bitfield member offsets should be encoded as:\n+     (bit_size << 24) | bit_offset\n+     - (0xa  << 24) | 0x20\n+     - (0x7  << 24) | 0x2a\n+     - (0x13 << 24) | 0x40 - note that this is aligned to 0x40.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x84000004\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xa000020\\[\\t \\]+\\[^\\n\\]*btm_offset\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x700002a\\[\\t \\]+\\[^\\n\\]*btm_offset\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x13000040\\[\\t \\]+\\[^\\n\\]*btm_offset\" 1 } } */\n+\n+struct bitt {\n+  int a;\n+  unsigned int bitfield_a : 10;\n+  unsigned int bitfield_b : 7;\n+  unsigned int bitfield_c : 19;\n+} bitty;\n+\n+struct no_bitt {\n+  int a;\n+  int b;\n+} no_bitty;\n+\n+int main ()\n+{\n+  return bitty.bitfield_b + bitty.a;\n+}"}, {"sha": "9665ab67145dd421761a1d09a655cb44d2a9b79e", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-bitfields-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,26 @@\n+/* Test BTF generation for struct with 0 size bitfield.\n+\n+   We expect a struct with 2 members to be generated. The size 0 bitfield\n+   should not have any entry in the member list.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* Struct with bitfield members, and 2 members.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x84000002\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+\n+/* Bitfield size 31 (0x1f) at offset 0.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x1f000000\\[\\t \\]+\\[^\\n\\]*btm_offset\" 1 } } */\n+\n+/* Bitfield size 32 (0x20) at offset 32.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x20000020\\[\\t \\]+\\[^\\n\\]*btm_offset\" 1 } } */\n+\n+/* Only 2 members.  */\n+/* { dg-final { scan-assembler-times \"btm_name\" 2 } } */\n+\n+struct foo\n+{\n+  unsigned a : 31;\n+  unsigned   : 0;\n+  unsigned c : 32;\n+} myfoo;"}, {"sha": "440623c3b16c50204f16fc33b67f34ab7760069e", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-bitfields-3.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-3.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,43 @@\n+/* Test BTF generation for enum-type bitfields\n+\n+   It is allowed to have a bitfield type be an enum type.\n+   We expect the following types:\n+\n+     [1] enum 'foo'(1U#B) size=4U#B\n+\t 'BAR' value=0\n+\t 'BAZ' value=1\n+\t 'QUZ' value=2\n+\t 'QUX' value=3\n+     [2] int 'unsigned int' size=4 offset=0 bits=32\n+     [3] struct 'bitt' size=4\n+         member 'f' type=1 bitfield_size=2 bit_offset=0\n+         member 'data' type=2 bitfield_size=14 bit_offset=2\n+   */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* Enum with 4 members.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x6000004\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* Struct with bitfield members, and 2 members.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x84000002\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+\n+/* Bitfield \"f\" points to type ID 1.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x1\\[\\t \\]+\\[^\\n\\]*btm_type\" 1 } } */\n+\n+/* Bitfield \"data\" points to type ID 2.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2\\[\\t \\]+\\[^\\n\\]*btm_type\" 1 } } */\n+\n+enum foo\n+{\n+  BAR = 0,\n+  BAZ = 1,\n+  QUZ = 2,\n+  QUX = 3\n+};\n+\n+struct bitt\n+{\n+  enum foo f : 2;\n+  unsigned data : 14;\n+} bitty;"}, {"sha": "af91845726f172eb821c3cc7740904d6572f628c", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-bitfields-4.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-bitfields-4.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,23 @@\n+/* Test BTF generation for non-representable bitfields.\n+\n+   Due to the limitations of BTF, we only have 24 bits in which to store\n+   the bitfield offset (in bits, from the beginning of the struct).\n+\n+   In this test, we construct a structure such that the bitfield will have\n+   an offset so large as to be unrepresentable in BTF. We expect that the\n+   resulting BTF will describe the rest of the structure, ignoring the\n+   non-representable bitfield.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* Struct with 3 members and no bitfield (kind_flag not set).  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4000003\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+\n+struct bigly\n+{\n+  int a;\n+  int b[((0xffffff + 1) / (8 * sizeof (int)))];\n+  unsigned unsup : 7;\n+  char c;\n+} big;"}, {"sha": "79e9f52a479e57a6c3171e4f851fe105f32b2a7a", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-cvr-quals-1.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-cvr-quals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-cvr-quals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-cvr-quals-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,52 @@\n+/* Test BTF generation of BTF_KIND_{CONST,VOLATILE,RESTRICT} records.\n+\n+   BTF const, volatile and restrict records are nameless type records pointing\n+   to the type they modify.\n+\n+   Types:\n+     [1] int 'int' size=4U offset=0 bits=32 SIGNED\n+     [2] const <anonymous> type=1\n+     [3] volatile <anonymous> type=1\n+     [4] const <anonymous> type=3\n+     [5] ptr <anonymous> type=1\n+     [6] restrict <anonymous> type=5\n+     [7] ptr <anonymous> type=2\n+     [8] restrict <anonymous> type=7\n+\n+   Note:\n+   - Type id 3 describes a volatile int.\n+   - Type id 2 describes a const int.\n+   - Type id 4 describes a const volatile int by modifying id 3.\n+   - Type id 6 describes a restrict pointer to int.\n+   - Type id 8 describes a restrict pointer to const int.\n+ */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"int.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+\n+/* types 5 and 7 are pointers, to 'int' and 'const int' respectively.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 2 } } */\n+\n+/* type 3 has VOLATILE qualifier */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x9000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+\n+/* types 2 and 4 have CONST qualifier.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xa000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 2 } } */\n+\n+/* types 6 and 8 have RESTRICT qualifier.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xb000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 2 } } */\n+\n+const int a = 10;\n+\n+volatile int b;\n+\n+int * restrict c;\n+\n+const volatile int d = 20;\n+\n+const int * restrict e;\n+\n+const int * f;\n+int const * g;"}, {"sha": "88ae4c4edfd940eabd8f264af95fa24431135e12", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-datasec-1.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-datasec-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-datasec-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-datasec-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,45 @@\n+/* BTF generation of BTF_KIND_DATASEC records.\n+\n+   We expect 3 DATASEC records: one for each of .data, .rodata and .bss.\n+   .rodata: the consts; c,e,my_cstruct\n+   .bss:    a,b,bigarr\n+   .data:   d\n+\n+   The type IDs of the variables placed in each section are not deterministic\n+   so we cannot check them.\n+ */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* Check for two DATASEC entries with vlen 3, and one with vlen 1.  */\n+/* { dg-final { scan-assembler-times \"0xf000003\\[\\t \\]+\\[^\\n\\]*btt_info\" 2 } } */\n+/* { dg-final { scan-assembler-times \"0xf000001\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+\n+/* The offset entry for each variable in a DATSEC should be 0 at compile time.  */\n+/* { dg-final { scan-assembler-times \"0\\[\\t \\]+\\[^\\n\\]*bts_offset\" 7 } } */\n+\n+/* Check that strings for each DATASEC have been added to the BTF string table.  */\n+/* { dg-final { scan-assembler-times \"ascii \\\".data.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\".rodata.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\".bss.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+int a;\n+long long b;\n+const long unsigned int c;\n+\n+int d = 137;\n+\n+const int e = -55;\n+\n+int bigarr[20][10];\n+\n+struct c_struct {\n+  long x;\n+  char c;\n+};\n+\n+const struct c_struct my_cstruct = {\n+  99,\n+  '?'\n+};"}, {"sha": "728493b0804640633fa4138c1ba592f01e1b507b", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-enum-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-enum-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-enum-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-enum-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,30 @@\n+/* Test BTF generation for enums.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x6000004\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x6000003\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"QAD.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"QED.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"QOD.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"QUD.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"YES.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"NO.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"IDUNNO.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"bte_value\" 7 } } */\n+\n+enum foo\n+{\n+  QAD,\n+  QED,\n+  QOD,\n+  QUD,\n+} a;\n+\n+enum barsigned\n+{\n+  YES=1000,\n+  NO=-1000,\n+  IDUNNO=0,\n+} b;"}, {"sha": "c894fa26bc7c546ee93c1bbf3a9da81bb249d4c0", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-forward-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-forward-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-forward-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-forward-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,24 @@\n+/* Test BTF generation of forwards.\n+\n+   Check that the KIND_FLAG (bit 31) of btt_info is set (1) for the forward to\n+   union, and not set (0) for forward to struct.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x87000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x7000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+\n+typedef struct _fwd_st\n+{\n+  struct unk_struct_type *data[4];\n+} fwd_st_t;\n+\n+fwd_st_t struct_container;\n+\n+typedef struct _fwd_un\n+{\n+  union unk_union_type *options[4];\n+} fwd_un_t;\n+\n+fwd_un_t union_container;"}, {"sha": "9fa1498bd8e789d9f7ceaaa117e725fc6d594489", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-function-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,18 @@\n+/* Test BTF generation for functions.\n+\n+   We expect to see one BTF_KIND_FUNC_PROTO with 2 named arguments.\n+   The parameter names should appear in the auxilliary string table.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xd000002\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"farg_name\" 2 } } */\n+/* { dg-final { scan-assembler-times \"farg_type\" 2 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"alpha.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"bravo.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_aux_string\" 1 } } */\n+\n+int funfoo (int alpha, long bravo)\n+{\n+  return 0;\n+}"}, {"sha": "3c7fda9ee355a1f0b41c07627150125ac1f70770", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-function-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,18 @@\n+/* Test BTF generation for functions with varargs.\n+\n+   We expect one BTF_KIND_FUNC_PROTO with two arguments. The second argument\n+   should have \"farg_name\" and \"farg_type\" both of 0, representing varargs.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xd000002\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"farg_name\" 2 } } */\n+/* { dg-final { scan-assembler-times \"farg_type\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*farg_name\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*farg_type\" 1 } } */\n+\n+int fmt (const char * format, ...)\n+{\n+  return 0;\n+}"}, {"sha": "35f96a2152cb58d6285aef9b43fbf6bcd8b4b79b", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-function-3.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-function-3.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,22 @@\n+/* Test BTF generation for a function with an unrepresentable parameter.\n+\n+   BTF has no encoding for floating point types, among others. Function\n+   parameters of unrepresentable types are emitted as 'void' types.\n+\n+   We expect one BTF_KIND_FUNC_PROTO with 3 parameters, one of which\n+   has type_id=0.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xd000003\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"farg_name\" 3 } } */\n+/* { dg-final { scan-assembler-times \"farg_type\" 3 } } */\n+\n+/* Exactly one function parameter should have type_id=0.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*farg_type\" 1 } } */\n+\n+int foo (int a, float f, long b)\n+{\n+  return 0;\n+}"}, {"sha": "2381decd6ff68946e929d3284c1ae47d4508011b", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-int-1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-int-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-int-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-int-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,44 @@\n+/* Tests for BTF integer base types.\n+\n+     0       f       ff      00   ff\n+   | 0 | encoding | offset | 00 | bits |\n+   encoding:\n+     signed  1 << 24\n+     char    2 << 24\n+\n+   All offsets in this test should be 0.\n+   This test does _not_ check number of bits, as it may vary between targets.\n+ */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* Check for 8 BTF_KIND_INT types.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x1000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 8 } } */\n+\n+/* Check the signed/char flags, but not bit size. */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x10000..\\[\\t \\]+\\[^\\n\\]*bti_encoding\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x20000..\\[\\t \\]+\\[^\\n\\]*bti_encoding\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x30000..\\[\\t \\]+\\[^\\n\\]*bti_encoding\" 1 } } */\n+\n+/* Check that there is a string entry for each type name.  */\n+/* { dg-final { scan-assembler-times \"ascii \\\"unsigned char.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"signed char.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"short unsigned int.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"short int.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"unsigned int.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"int.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"long unsigned int.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"long int.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+\n+unsigned char a = 11;\n+signed char b = -22;\n+\n+unsigned short c = 33;\n+signed short d = 44;\n+\n+unsigned int e = 55;\n+signed int f = -66;\n+\n+unsigned long int g = 77;\n+signed long int h = 88;"}, {"sha": "a14ac0f89b239941ae6ee101062694a94498b20b", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-pointers-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-pointers-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-pointers-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-pointers-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,25 @@\n+/* Test BTF generation for pointer types.\n+\n+   Two pointer types are expected:\n+    - int *\n+    - struct st *\n+   */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 2 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"int.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"st.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+\n+int foo = 10;\n+int *pfoo = &foo;\n+\n+struct st\n+{\n+  int a;\n+  int *pb;\n+  struct st * next;\n+};\n+\n+struct st * bar;"}, {"sha": "c77b224d7111b7864319babb1a193ce020e72e92", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-pointers-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-pointers-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-pointers-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-pointers-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,13 @@\n+/* Test BTF generation for pointers to void.\n+\n+   In this test, we expect that the pointer references type ID 0, the reserved\n+   void typeid, and that no intermediate type is generated for void. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x1000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 0 } } */\n+\n+void *ptr;"}, {"sha": "bc3281437c9567237ff0350abe7949dce1e04693", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-struct-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-struct-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-struct-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-struct-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,22 @@\n+/* Test BTF generation of struct type.\n+\n+   Two BTF_KIND_STRUCT records are expected.\n+   - struct foo with 3 members\n+   - struct data with 2 members  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4000003\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4000002\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"btm_name\" 5 } } */\n+\n+struct foo\n+{\n+  int after;\n+  int before;\n+  struct {\n+    unsigned short n_valid;\n+    int set[10];\n+  } data;\n+} my_foo;"}, {"sha": "24514fcb31e794559d2697150620d97b15d0fca8", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-struct-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-struct-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-struct-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-struct-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,19 @@\n+/* Test BTF generation for struct type with a member which refers to an\n+   unsupported type.\n+\n+   BTF does not support floating point types (among other things). When\n+   generating BTF for a struct (or union) type, members which refer to\n+   unsupported types should be skipped.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* Expect a struct with only 2 members - 'f' should not be present.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4000002\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+\n+struct with_float\n+{\n+  int a;\n+  float f;\n+  char c;\n+} instance;"}, {"sha": "472cc63f600ff4d380bafbff915ec2ddb7742674", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-typedef-1.c", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-typedef-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-typedef-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-typedef-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,82 @@\n+/* Test BTF generation for BTF_KIND_TYPEDEF records.\n+\n+   7 typedef records are expected. We expect the following types (among others):\n+     [1] int 'int' size=4 offset=0 bits=32 SIGNED\n+     [2] typedef 'my_int' type=1\n+     [3] typedef 'foo_int' type=1\n+     [4] typedef 'bar_int' type=1\n+     ..\n+     [6] typedef 'CBAR' type=5\n+     ..\n+     [8] typedef 'CBARP' type=7\n+     [9] struct '_node' size=16\n+     ..\n+     [11] typedef 'node_t' type=9\n+     [12] struct '_arena'\n+     ..\n+     [15] typedef 'arena_t' type=12\n+     [16] var 'a' type=2 linkage=1 (global)\n+     [17] var 'suitcase' type=15 linkage=1 (global)\n+     [18] var 'b' type=3 linkage=1 (global)\n+     [19] var 'c' type=4 linkage=1 (global)\n+     [20] var 'd' type=11 linkage=1 (global)\n+     [21] var 'destination' type=6 linkage=1 (global)\n+     [22] var 'ticket' type=8 linkage=1 (global)\n+\n+   Note that the order of the variables is not guaranteed, so we do not check\n+   particular variables have exactly the right typedef. Instead, we check:\n+   1. 7 typedef records are generated, along with the correct strings for them.\n+   2. There is one variable pointing to each typedef.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x8000000\\[\\t \\]+\\[^\\n\\]*btt_info\" 7 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"my_int.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"foo_int.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"bar_int.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"CBAR.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"CBARP.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"node_t.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"arena_t.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2\\[\\t \\]+\\[^\\n\\]*btv_type\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x3\\[\\t \\]+\\[^\\n\\]*btv_type\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4\\[\\t \\]+\\[^\\n\\]*btv_type\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x6\\[\\t \\]+\\[^\\n\\]*btv_type\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x8\\[\\t \\]+\\[^\\n\\]*btv_type\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xb\\[\\t \\]+\\[^\\n\\]*btv_type\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xf\\[\\t \\]+\\[^\\n\\]*btv_type\" 1 } } */\n+\n+typedef int my_int;\n+typedef int foo_int;\n+typedef int bar_int;\n+\n+typedef const bar_int CBAR;\n+typedef const bar_int * CBARP;\n+\n+typedef struct _node\n+{\n+  foo_int name_off;\n+  bar_int info;\n+  struct _node * next;\n+} node_t;\n+\n+\n+typedef struct _arena\n+{\n+  node_t nodes[16];\n+  my_int vardata;\n+  bar_int flags;\n+} arena_t;\n+\n+my_int a;\n+foo_int b;\n+bar_int c;\n+node_t d;\n+\n+CBAR destination;\n+CBARP ticket = &destination;\n+\n+arena_t suitcase;"}, {"sha": "d66843717b33bed449845bcb1eb226751a1afc19", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-union-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-union-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-union-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-union-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,16 @@\n+/* Test BTF generation for union type.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* One union type with 4 members */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x5000004\\[\\t \\]+\\[^\\n\\]*btt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"btm_name\" 4 } } */\n+\n+union onion\n+{\n+  int redness;\n+  char *name;\n+  unsigned short freshness;\n+  unsigned short flavor;\n+} my_onion;"}, {"sha": "a79ed1d53b7f273ee49c1df23d5c0bd558d847ee", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-variables-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-variables-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-variables-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-variables-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,33 @@\n+/* BTF generation for variables. */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* We expect 6 variables */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xe000000\\[\\t \\]+\\[^\\n\\]*btv_info\" 6 } } */\n+\n+unsigned int x1;\n+\n+struct st\n+{\n+  int a;\n+  int b;\n+};\n+\n+union {\n+  long int value;\n+  struct st * pointer;\n+} bar;\n+\n+enum\n+{\n+  FOO = 0,\n+  BAR = 2,\n+  BAZ,\n+} lala;\n+\n+int arr[10][20];\n+\n+unsigned long * plong;\n+\n+struct st st_inst;"}, {"sha": "0f9742e9ac5c70a5675f3173fbfd611aafba6198", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-variables-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-variables-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-variables-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-variables-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,27 @@\n+/* BTF generation for variables with removed type.\n+\n+   BTF does not support floating point types, so no representation for the type\n+   'float' will be emitted. In this test, we check to also ensure that the\n+   variable 'bar' is not emitted, as it references a type that is not supported\n+   in BTF.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* We expect only 3 variables.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xe000000\\[\\t \\]+\\[^\\n\\]*btv_info\" 3 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"foo.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"baz.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"myst.0\\\"\\[\\t \\]+\\[^\\n\\]*btf_string\" 1 } } */\n+\n+int foo;\n+float bar;\n+int baz[10];\n+\n+struct st\n+{\n+  int a;\n+  int b : 6;\n+  int c : 2;\n+} myst;"}, {"sha": "8cae22123af997fc036365d35b3f5d480004bf1e", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf-variables-3.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-variables-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-variables-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf-variables-3.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,36 @@\n+/* Test BTF generation for static versus global variables.\n+\n+   BTF_KIND_VAR types represeting variables are followed by a 32-bit\n+   \"linkage\", which can take one of currently two valid values:\n+      0 = static\n+      1 = global\n+\n+   In this test, make a few static and a few global variables, and ensure\n+   they are noted with the correct \"linkage\" values.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gbtf -dA\" } */\n+\n+/* Expect 6 variables.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xe000000\\[\\t \\]+\\[^\\n\\]*btv_info\" 6 } } */\n+\n+/* 3 global, 3 static.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*btv_linkage\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x1\\[\\t \\]+\\[^\\n\\]*btv_linkage\" 3 } } */\n+\n+int a;\n+\n+static long b;\n+\n+struct foo {\n+  int x;\n+  int y;\n+};\n+\n+struct foo g_foo;\n+\n+static struct foo s_foo;\n+\n+static unsigned int s_arr [10][5];\n+\n+unsigned int g_arr [20];"}, {"sha": "e72a2be8516ee1db0ddef8a5ad8e00484b62aae0", "filename": "gcc/testsuite/gcc.dg/debug/btf/btf.exp", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fbtf%2Fbtf.exp?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,41 @@\n+#   Copyright (C) 2002-2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+#\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Disable on ptx (in sync with DWARF testsuite)\n+if { [istarget nvptx-*-*] } {\n+    return\n+}\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\] ]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "6f637df5be83a621d36e5c52d2ab9587ad2978f8", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-1.c", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,6 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-gctf\" } */\n+\n+void func(void)\n+{\n+}"}, {"sha": "ccbb109cdbdc67a145627c8aadfb7664e16503ab", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,10 @@\n+/* A LEVEL of 0 with -gctf turns off CTF debug info generation.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-gctf0 -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"0xdff2.*CTF preamble magic number\" 0} } */\n+/* { dg-final { scan-assembler-times \"0x4.*CTF preamble version\" 0 } } */\n+/* { dg-final { scan-assembler-times \"0.*CTF preamble flags\" 0 } } */\n+\n+const char * _CONTEXT_NAME = \"foobar\";"}, {"sha": "93547d458186cf2edc6ca7fa37cbf833c33156ea", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-anonymous-struct-1.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-anonymous-struct-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-anonymous-struct-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-anonymous-struct-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,23 @@\n+/* Test compilation and CTF generation of anonymous structs.  An anonymous\n+   struct type is encoded as no-name CTF struct type.\n+\n+   For this testcase, a single CTF anonymous struct is expected.\n+   struct {} : ctt_name = 0 (point to offset 0 in the CTF string table to\n+\t\t\t    denote empty string)\n+   \n+   Two CTF struct records should be generated in total.\n+   struct a : ctt_info = 0x1a000002 (2 fields)\n+   struct {} : ctt_info = 0x1a000001 (1 field)  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*ctt_name\" 1 } } */\n+/* { dg-final { scan-assembler-times \"0x1a000002\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"0x1a000001\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+\n+struct a\n+{\n+  struct { int b1; } a1;\n+  int a2;\n+} my_a;"}, {"sha": "f45af9b742d42603d21e35153a340f855ad64fbb", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-anonymous-union-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-anonymous-union-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-anonymous-union-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-anonymous-union-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,26 @@\n+/* Test compilation and CTF generation of anonymous union.  An anonymous union\n+   is encoded as no-name CTF union type.\n+\n+   For this testcase, a single CTF anonymous union is expected.\n+   struct {} : ctt_name = 0 (point to offset 0 in the CTF string table to\n+\t\t\t    denote empty string)\n+   \n+   Two CTF struct records should be generated in total.\n+   struct anon_union : ctt_info = 0x1a000001 (1 field)\n+   union {} : ctt_info = 0x1e000002 (2 fields)  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*ctt_name\" 1 } } */\n+/* { dg-final { scan-assembler-times \"0x1a000001\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"0x1e000002\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+\n+struct anon_union\n+{\n+  union\n+    {\n+      char name;\n+      int value;\n+    };\n+} my_anon_u;"}, {"sha": "006a7582f0b666eacb6dc7e163982b640dcae2c4", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-array-1.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,31 @@\n+/* CTF generation for array type.\n+\n+   Unsized arrays are encoded with a 0 for the number of elements.\n+\n+   In this testcase, 5 distinct CTF records for arrays are expected\n+   b1 : cta_nelems = 2\n+   c1 : cta_nelems = 3\n+   a1 : cta_nelems = 2, 5\n+   buf : cta_nelems = 0.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"0x12000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 5 } } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2\\[\\t \\]+\\[^\\n\\]*cta_nelems\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x3\\[\\t \\]+\\[^\\n\\]*cta_nelems\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x5\\[\\t \\]+\\[^\\n\\]*cta_nelems\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*cta_nelems\" 1 } } */\n+\n+int b1[2] = {0,1};\n+int c1[5] = {0,1,2,3,4};\n+int a1[2][3] = { {3,4,5}, {2,3,4} };\n+\n+/* Variable length struct using arrays.  */\n+struct my_array\n+{\n+  int flags;\n+  int length;\n+  int buf[];\n+} my_array_obj;"}, {"sha": "2a19da050fe7430aa5f3a01ec1dc5928256ec5a0", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-array-2.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,38 @@\n+/* CTF generation for unsized arrays.\n+\n+   Unsized arrays are encoded with a 0 for the number of elements.  The type\n+   of array index is the INT type.\n+\n+   TBD_CTF_FORMAT_OPEN_ISSUES (1) - \n+   This testcase makes a note of the case of a probable misrepresentation.\n+   See Note 1 and Note 2 below.\n+\n+   In the CTF section, these types are encoded as :\n+\n+     Variables:\n+      _CTF_NEWSTR ->  7: const char [0] (size 0x0)\n+      _CTF_SECTION ->  6: const char [5] (size 0x5)\n+      b1 ->  2: int [0] (size 0x0)\n+      b2 ->  3: int [0] (size 0x0)\n+\n+    Note 1 : There is misrepresentation in that b1 and b2 are specified\n+    differently by the user.\n+    Note 2 : It is arguable though whether the representation for\n+    _CTF_NEWSTR is incorrect.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"0x12000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 5 } } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*cta_nelems\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x5\\[\\t \\]+\\[^\\n\\]*cta_nelems\" 1 } } */\n+\n+static int b1[] = {};\n+\n+int b2[0];\n+\n+const char _CTF_SECTION[] = \".ctf\";\n+\n+extern const char _CTF_NEWSTR[];\n+const char _CTF_NEWSTR[] = \"ctfinfo\"; "}, {"sha": "8def2084c6d2ffcebf684bd4ec9fdcd27bd0539a", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-array-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-3.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,17 @@\n+/* CTF generation for variable length arrays.\n+\n+   In this testcase, a specific flavor of vla appears in the function\n+   signature.\n+\n+   TBD_CTF_FORMAT_OPEN_ISSUES (1) -\n+   This testcase makes a note of another case of a probable misrepresentation.\n+   See ctf-array-2.c for some context on how vla's are a case of a probable\n+   misrepresentation in CTF.  Nevertheless, compilation should not fail.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-gctf\" } */\n+\n+int foo (int a, int b[a][a])\n+{\n+  return b[a-1][a-3];\n+}"}, {"sha": "013a8ff98d7f9440c3baee2fdf9f49702bf0ed81", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-array-4.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-array-4.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,13 @@\n+/* CTF generation for array type.\n+\n+   Test CTF generation for single element arrays.  In this testcase, one CTF\n+   record for array is expected with cta_nelems = 1.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"0x12000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x1\\[\\t \\]+\\[^\\n\\]*cta_nelems\" 1 } } */\n+\n+int b[1];"}, {"sha": "fc3af037b8bd650c4739624b5dcc4df8862604b7", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-attr-mode-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-attr-mode-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-attr-mode-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-attr-mode-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,22 @@\n+/* Test CTF generation works well with ((mode)) attribute.\n+\n+   In this testcase, CTF should report type of bqi to be an enum and\n+   not an int.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"B1.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"B2.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"B3.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"cte_value\" 3} } */\n+\n+/* There are no better/direct methods to assert that the CTF for typedef of\n+   enum has been added.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x22000003\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2a000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x3\\[\\t \\]+\\[^\\n\\]*ctv_typeidx\" 1} } */\n+\n+typedef enum { B1 = 1, B2 = 2, B3 = 3 } B;\n+B __attribute__ ((mode (QI))) bqi;"}, {"sha": "61f6b6410deed919c4c1b53e064b3d4b35e72b36", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-attr-used-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-attr-used-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-attr-used-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-attr-used-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,22 @@\n+/* Test CTF generation works well with ((used)) function attribute.\n+\n+   This attribute, attached to a function, means that code must be emitted for\n+   the function even if it appears that the function is not referenced.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O2 -gctf -dA\" } */\n+\n+/* These should be true for higher optimization levels.  */\n+/* { dg-final { scan-assembler-times \"ascii \\\"keep_this.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"lose_this.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 0 } } */\n+\n+static int lose_this(int a)\n+{\n+    return a + 2;\n+}\n+\n+__attribute__((used))\n+static int keep_this(double a)\n+{\n+    return a * 2;\n+}"}, {"sha": "1deac90f256f71ac444ad5b2471c062c60a9a68c", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-bitfields-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,30 @@\n+/* CTF generation for bitfields.\n+   \n+   In this testcase, two slices are expected - one for enum and the other for\n+   int.  CTF slices are unnamed records.  */\n+   \n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2\\[\\t \\]+\\[^\\n\\]*cts_bits\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x3\\[\\t \\]+\\[^\\n\\]*cts_bits\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*ctt_name\" 2 } } */\n+\n+enum color\n+{\n+  RED,\n+  GREEN,\n+  BLUE,\n+  YELLOW,\n+  ORANGE,\n+  BLACK\n+};\n+\n+struct quickcolor\n+{\n+  enum color col:3;\n+  int brushid:2;\n+  int strokes;\n+};\n+\n+struct quickcolor qc;"}, {"sha": "aea09219dba6f1929dd5ff69bf83a86e081c6d83", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-bitfields-2.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,39 @@\n+/* The bitfield type (int) may be shared, but slices are not de-duplicated.\n+\n+   In this testcase, it is expected to see a total of 6 CTF slices and 2 CTF\n+   integer types for the bitfields - unsigned long long and signed long long.\n+   \n+   cts_offset is the offset of the bitfield into a machine word.\n+   TBD - hardcoding cts_offset checks into the testcase will cause it to break\n+   across targets with different BIT_PER_WORD.  Is there a way to add\n+   cts_offset related checks in the testcase?  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x6\\[\\t \\]+\\[^\\n\\]*cts_type\" 3 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2\\[\\t \\]+\\[^\\n\\]*cts_type\" 3 } } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xf\\[\\t \\]+\\[^\\n\\]*cts_bits\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x21\\[\\t \\]+\\[^\\n\\]*cts_bits\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x10\\[\\t \\]+\\[^\\n\\]*cts_bits\" 2 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"long long unsigned int.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"long long int.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+struct fields\n+{\n+  unsigned long long u1 : 15;\n+  unsigned long long u2 : 33;\n+  unsigned long long u3 : 16;\n+  signed long long   s1 : 15;\n+  signed long long   s2 : 33;\n+  signed long long   s3 : 16;\n+} flags;\n+\n+int i = 33;\n+\n+int main ()\n+{\n+    return flags.u1 + i;\n+}"}, {"sha": "8fbcf122f80f3417d585aa9e5b375b3dcd8825da", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-bitfields-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-3.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,16 @@\n+/* The bool bitfield type.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2\\[\\t \\]+\\[^\\n\\]*cts_type\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x1\\[\\t \\]+\\[^\\n\\]*cts_bits\" 2 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"_Bool.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+#include <stdbool.h>\n+\n+struct open_file {\n+  bool mmapped:1;\n+  bool released:1;\n+} of;"}, {"sha": "012069ac9181c65b21cd1937bc87b75bdb1f6e76", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-bitfields-4.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-bitfields-4.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,19 @@\n+/* The zero sized bitfield.\n+\n+   In this testcase, two slices are expected.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2\\[\\t \\]+\\[^\\n\\]*cts_type\" 2 } } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x5\\[\\t \\]+\\[^\\n\\]*cts_bits\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xa\\[\\t \\]+\\[^\\n\\]*cts_bits\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"ctm_name\" 2 } } */\n+struct foo\n+{\n+  int a:5;\n+  unsigned:0;\n+  int b:10;\n+} foome;"}, {"sha": "a36dd9b6b90a982060a15c8b0ff5cacffa41a48e", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-complex-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-complex-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-complex-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-complex-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,21 @@\n+/* Tests for CTF complex base types.\n+\n+   CTF does not have representation for complex integer types.\n+   \n+   This testcase has a mix of C constructs containing COMPLEX_TYPE.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+/* { dg-require-effective-target libc_has_complex_functions } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"complex double.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"complex long double.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"complex float.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+#include <complex.h>\n+\n+double complex z1 = I * I;\n+\n+const long double complex z2 = I * I;\n+\n+float complex z4 = 1+2.11*I;"}, {"sha": "9368d47ea0cdee25e9a91a07a588dd8af14602d2", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-cvr-quals-1.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,65 @@\n+/* Test compilation of stubs with various qualifiers - const, restrict and\n+   volatile.\n+\n+   Testcase includes a std header to allow testing of shared types across\n+   files.  Only one CTF record for int is expected.\n+   \n+   CTF records for CVR qualifiers are no-name records.  In this testcase, there\n+   are 5 qualifiers across constructs.  2 more no-name CTF records correspond to\n+   CTF pointer records.\n+\n+    TYPEID: name string (size) -> ref TYPEID : ref name string (size) -> ...\n+\n+   Types:\n+      1: long int (size 0x8)\n+      2: long unsigned int (size 0x8)\n+      3: size_t (size 0x8) -> 2: long unsigned int (size 0x8)\n+      4: int (size 0x4)\n+      5: const int (size 0x4) -> 4: int (size 0x4)\n+      6: volatile const int (size 0x4) -> 5: const int (size 0x4) -> 4: int (size 0x4)\n+      7: long long int (size 0x8)\n+      8: long double (size 0x10)\n+      9: int * (size 0x8) -> 4: int (size 0x4)\n+      a: int *restrict (size 0x8) -> 9: int * (size 0x8) -> 4: int (size 0x4)\n+      b: const int * (size 0x8) -> 5: const int (size 0x4) -> 4: int (size 0x4)\n+      c: const int *restrict (size 0x8) -> b: const int * (size 0x8) -> 5: const int (size 0x4) -> 4: int (size 0x4)\n+      d: INTP (size 0x8) -> 9: int * (size 0x8) -> 4: int (size 0x4)\n+      e: const INTP (size 0x8) -> d: INTP (size 0x8) -> 9: int * (size 0x8) -> 4: int (size 0x4)\n+      f: void (size 0x0)\n+      10: void (*) (size_t, int *restrict, const int *restrict) (size 0x0)\n+    */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"int.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*ctt_name\" 7 } } */\n+\n+/* type id 9, b have POINTER type.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xe000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 2 } } */\n+\n+/* type id 5, e have CONST qualifier.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x32000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 2 } } */\n+\n+/* type id a, c have RESTRICT qualifier.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x36000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 2 } } */\n+\n+/* type id 6 has VOLATILE qualifier.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2e000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+\n+#include \"stddef.h\"\n+\n+const volatile int a = 5;\n+int *restrict b;\n+\n+const int * i;\n+int const * j;\n+\n+typedef int * INTP;\n+const INTP int_p;\n+\n+void foo (size_t n, int *restrict p, const int *restrict q)\n+{\n+  while (n-- > 0)\n+    *p++ = *q++;\n+}"}, {"sha": "4f328f3a5ac0277c10efc9ab5df5deaa941b1004", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-cvr-quals-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,30 @@\n+/* Test compilation of stubs with various expressions involving const\n+   qualifier.\n+   \n+   In this testcase, a single CTF record for const int is expected. A total of\n+   two const qualifier CTF records are expected (const int and const struct\n+   s1).  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"int.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x32000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 2 } } */\n+\n+struct mystruct\n+{\n+  struct\n+    {\n+      int a; \n+      const int b;\n+    } s1;\n+  char * name;\n+} my_a;\n+\n+struct s1\n+{\n+  int i;\n+  const int ci;\n+} s;\n+\n+const struct s1 cs;"}, {"sha": "97317a47b8f52c40b6103abaf88b62a27d6f6ab6", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-cvr-quals-3.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-3.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,25 @@\n+/* Test compilation of stubs with various expressions involving const and\n+   volatile qualifiers.\n+   \n+   In this testcase, it is expected to have const and volatile CTF\n+   records.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"unsigned char.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2e000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 5 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x32000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 3 } } */\n+/* Two arrays.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x12000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 2 } } */\n+\n+\n+const volatile unsigned char  vicar = 11;\n+\n+const volatile unsigned char * vicarage = &vicar;\n+\n+volatile float vilify[2];\n+\n+const volatile char victor = 'Y';\n+\n+const volatile char vindictive[2];"}, {"sha": "c1633ee935d2b58d1e6a5db179a8370e83b5d9a4", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-cvr-quals-4.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-cvr-quals-4.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,23 @@\n+/* Test compilation of stubs with various qualifiers - const, restrict and\n+   volatile.\n+\n+   CTF records for CVR qualifiers are no-name records.  In this testcase, there\n+   is 1 const qualifier. 1 more no-name CTF record corresponds to the CTF\n+   pointer record.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*ctt_name\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xe000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x32000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+\n+typedef const struct howto_struct howto_type;\n+\n+typedef struct entry\n+{\n+  int addend;\n+  howto_type *howto;\n+} how_ent;\n+\n+how_ent hent;"}, {"sha": "1ad5f2593dfa92c0accc578260a5ca5b1d0b5d25", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-debug-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-debug-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-debug-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-debug-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,7 @@\n+/* Verify that CTF debug info can co-exist with dwarf.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-gctf -gdwarf -dA\" } */\n+/* { dg-final { scan-assembler \"0xdff2.*CTF preamble magic number\" } } */\n+\n+void func (void)\n+{ }"}, {"sha": "df2c1ebbb3093959815c77aa29aaef83d20f2181", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-debug-2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-debug-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-debug-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-debug-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,7 @@\n+/* Verify that CTF debug info can co-exist with dwarf.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-gdwarf -gctf -dA\" } */\n+/* { dg-final { scan-assembler \"0xdff2.*CTF preamble magic number\" } } */\n+\n+void func (void)\n+{ }"}, {"sha": "969354431ba48ca00c96b26d8d709b557e7adf1f", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-enum-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-enum-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-enum-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-enum-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,21 @@\n+/* CTF generation for enums.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"RED.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"GREEN.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"BLUE.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"YELLOW.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"cte_value\" 4} } */\n+\n+\n+enum foo_color\n+{\n+  RED,\n+  GREEN,\n+  BLUE,\n+  YELLOW\n+};\n+\n+enum foo_color my_color;"}, {"sha": "fd8aaeced84aa71c5e8bd93bef1a4baa10484702", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-enum-2.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-enum-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-enum-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-enum-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,27 @@\n+/* CTF generation for enums.\n+\n+   CTF represents enum values with an int32_t.  For enum values not\n+   representable with int32_t data type, the compiler skips adding CTF for\n+   them.  This will be fixed soon in the CTF format.\n+   TBD_CTF_REPRESENTATION_LIMIT.\n+   \n+   In this testcase, CTF for enumerator GFS_MONOTONIC will not be generated.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"GFS_MONOTONIC.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 0 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"GFS_RUNTIME.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"GFS_STATIC.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"cte_value\" 2} } */\n+\n+\n+enum gomp_schedule_type\n+{\n+  GFS_RUNTIME,\n+  GFS_STATIC,\n+  GFS_MONOTONIC = 0x80000000U\n+};\n+\n+enum gomp_schedule_type gsch_type;\n+"}, {"sha": "a683113e505e4cdd49accd0cce619e142b61acc4", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-file-scope-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-file-scope-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-file-scope-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-file-scope-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,25 @@\n+/* CTF is not generated for entities not at file-scope.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"SFOO.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 0 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"gfoo.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 0 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"foo.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+int foo (int n)\n+{\n+  typedef struct { int a[n]; } SFOO;\n+\n+  SFOO a;\n+  __attribute__ ((noinline)) SFOO gfoo (void) { return a; }\n+\n+  a.a[0] = 1;\n+  a.a[9] = 2;\n+\n+  SFOO b;\n+  b = gfoo ();\n+\n+  return b.a[0] == 1 && b.a[9] == 2;\n+}\n+"}, {"sha": "9e24b450ea5c84ca9a0422698e1a2c1f2f117daf", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-float-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-float-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-float-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-float-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,16 @@\n+/* Tests for CTF float base types.\n+   - Verify that there is a single record for the base types.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"float.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"double.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"long double.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+float a;\n+float b = 33;\n+\n+double c = 44;\n+double d = 45;\n+\n+long double e;"}, {"sha": "fdec74332883444cdab84677eed30a4bb5cab4a8", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-forward-1.c", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-forward-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-forward-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-forward-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,40 @@\n+/* CTF forward type is generated for forward declarations of types in C.\n+   \n+   Check that the ctf-kind of CTF_K_FOWARD type is CTF_K_STRUCT or CTF_K_UNION.\n+   For forward types, the compiler encodes the CTF kind in the ctt_type field.\n+   CTF_K_FORWARD is used as the CTF type as usual in the ctt_info.  */\n+\n+/* Note - A value of 6 in \"ctt_size or ctt_type\" appears twice in this\n+   testcase. This might be misconstrued as  2 CTK_K_FORWARD records of struct\n+   type.  The second assembler tag is due to a ref type in a CVR CTF record.\n+   TBD - perhaps a more robust string pattern is needed.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x26000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x6\\[\\t \\]+\\[^\\n\\]*ctt_size or ctt_type\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x7\\[\\t \\]+\\[^\\n\\]*ctt_size or ctt_type\" 2 } } */\n+\n+typedef struct __locale_struct\n+{\n+  struct __locale_data *__locales[13]; /* forward struct type.  */\n+\n+  const int *__ctype_toupper;\n+  const char *__names[13];\n+} *__locale_t;\n+\n+typedef __locale_t locale_t;\n+\n+locale_t loc;\n+\n+typedef struct __inter_struct\n+{\n+  union __inter_data * __inters[13]; /* forward union type.  */\n+\n+  const int * __ctype_kind;\n+} * __inter_t;\n+\n+typedef __inter_t inter_t;\n+\n+inter_t inter;"}, {"sha": "a3154f2b2d40b8a7144c4f4e112083b15c169207", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-forward-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-forward-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-forward-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-forward-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,16 @@\n+/* CTF forward type is generated for forward declarations of enum types in C.\n+   \n+   Check that the ctf-kind of CTF_K_FOWARD type is CTF_K_ENUM.\n+   For forward types, the compiler encodes the CTF kind in the ctt_type field.\n+   CTF_K_FORWARD is used as the CTF type as usual in the ctt_info.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x26000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x8\\[\\t \\]+\\[^\\n\\]*ctt_size or ctt_type\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"vibgyor.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+enum vibgyor;\n+\n+char * (*get_color_name) (enum vibgyor);"}, {"sha": "86ca795c9ab1da8b23156d6b163af99028e2dbc6", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-func-index-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-func-index-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-func-index-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-func-index-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,25 @@\n+/* CTF function index sub-section.\n+\n+   A function index sub-section in the CTF section contains the offset to the\n+   string name of the global function symbols.  The number of entries in the\n+   func info section and the func index section are always the same.\n+\n+   In this testcase, 2 records in the function index section are expected.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"funcinfo_name\" 2 } } */\n+/* { dg-final { scan-assembler-times \"funcinfo_func_type\" 2 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"bar.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"foo.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+int foo (void)\n+{\n+  return 0;\n+}\n+\n+int bar (int a)\n+{\n+  return 33 + a;\n+}"}, {"sha": "cc1a600adbd336e08af56a38cef26d35a2ee989c", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-function-pointers-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,24 @@\n+/* CTF generation of function pointers.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x16000001\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x16000002\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x16000003\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"__foo_fn.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"destroy.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"func.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+int (*func) (int *, char);\n+\n+typedef int (*__foo_fn) (void *__cookie, char *__buf, int __nbytes);\n+\n+typedef struct object\n+{\n+   int myint;\n+   char mychar;\n+   void (*destroy)(struct object *);\n+} object_t;\n+\n+object_t myobj;\n+__foo_fn fooit;"}, {"sha": "a4a1104ae8c6dfd2acda3dcc5ae8d9c3f1d5ade2", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-function-pointers-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,22 @@\n+/* CTF generation of function pointers.\n+\n+   In this testcase,  there is a single function type expected for two\n+   different function pointer types.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x16000001\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"rcu_callback_t.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"func.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+struct callback_head {\n+      struct callback_head *next;\n+        void (*func) (struct callback_head *head);\n+} __attribute__ (( aligned (sizeof (void *))));\n+#define rcu_head callback_head\n+\n+struct callback_head chead;\n+\n+typedef void (*rcu_callback_t) (struct rcu_head *head);\n+\n+rcu_callback_t rcb;"}, {"sha": "fe35d6c7f2e227a5561b53afa4eb22b450cc89ad", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-function-pointers-3.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-3.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,21 @@\n+/* CTF generation of function pointers.\n+\n+   In this testcase,  there is a single function type expected.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x16000001\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"foo_init_callback.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"fn.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+struct foo;\n+\n+typedef void (* foo_init_callback) (struct foo *f1);\n+\n+struct foo\n+{\n+  /* Function to call to initialize.  */\n+  foo_init_callback fn;\n+};\n+\n+struct foo f;"}, {"sha": "b8a741766ed303f8a053b835e9d359e6a1e7c883", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-function-pointers-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-function-pointers-4.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,18 @@\n+/* CTF generation of function pointers.\n+\n+   In this testcase, Type de-duplication of function type is exercised.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x16000001\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"var_assign_func_t.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+struct variable;\n+\n+typedef struct variable *var_assign_func_t (struct variable *);\n+\n+typedef struct variable {\n+  var_assign_func_t *assign_func;\n+} shell_var_t;\n+\n+shell_var_t a;"}, {"sha": "0b086a5af3df1062383dabd9c46e293ea2c97294", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-functions-1.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-functions-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-functions-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-functions-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,34 @@\n+/* CTF generation for functions with varargs or otherwise.\n+\n+   In this testcase, it is expected to see one CTF_K_FUNCTION record with two\n+   function arguments.  The second function argument with a value of 0\n+   corresponds to the ellipsis.\n+\n+   Example CTF section excerpt on x86_64 :\n+\n+    .long   0x5     # ctt_name\t\t    (name = format)\n+    .long   0x16000002      # ctt_info\t    (CTF_K_FUNCTION with 2 arguments)\n+    .long   0x2     # ctt_size or ctt_type  (return typeID)\n+    .long   0x2     # dtu_argv\t\t    (TypeID of the First argument)\n+    .long   0       # dtu_argv\t\t    (TypeID of the second argument)\n+    .ascii \"\\0\"     # ctf_string\n+    .ascii \"int\\0\"  # ctf_string\n+    .ascii \"format\\0\"       # ctf_string\n+\n+    */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x16000002\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"dtu_argv\" 2 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*dtu_argv\" 1 } } */\n+\n+int foo (void);\n+\n+int bar (int);\n+\n+int * format (int * fmt, ...)\n+{\n+  return fmt;\n+}"}, {"sha": "8c68b2e7edead2c39fcbfad6c9021f4977d0b6d2", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-int-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-int-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-int-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-int-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,17 @@\n+/* Tests for CTF integer base types.\n+   - Verify that there is a single record for the base types.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"int.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"short int.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"long int.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+int a;\n+int b = 33;\n+\n+short int c = 44;\n+short int d = 45;\n+\n+long int e = 90;\n+long int f;"}, {"sha": "ee3481af72358ce31974fcf95813c3ac5a2170a7", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-objt-index-1.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-objt-index-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-objt-index-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-objt-index-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,30 @@\n+/* CTF objext index sub-section.\n+\n+   An object index sub-section in the CTF section contains the offset to the\n+   string name of the global object symbols.  The number of entries in the\n+   obj info section and objt index section are always the same. \n+\n+   In this testcase, 4 records in the object index section are expected.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"objtinfo_name\" 4 } } */\n+/* { dg-final { scan-assembler-times \"objtinfo_var_type\" 4 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"a.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"b.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"a1.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"d_instance.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+static int b = 33;\n+\n+int a = 44;\n+int a1[2] = {22, 33};\n+\n+struct d\n+{\n+  int d1;\n+  int d2;\n+};\n+\n+struct d d_instance;"}, {"sha": "e1fccec2d032366ae29a27aab5347c67f77fed29", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-pointers-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-pointers-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-pointers-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-pointers-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,26 @@\n+/* CTF generation for pointer types.\n+\n+   In this testcase, two CTF pointer type records are expected\n+     - int *\n+     - struct foo_struct *\n+  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"foo_struct.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"int.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xe000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 2 } } */\n+\n+int b = 44;\n+int * a = &b;\n+\n+struct foo_struct\n+{\n+  int bar_mem_1;\n+  int bar_mem_2;\n+  float d;\n+  struct foo_struct *next;\n+};\n+\n+struct foo_struct * node;"}, {"sha": "e36e5ec741bcf4c81be005d2edd9a7117722f6cc", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-pointers-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-pointers-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-pointers-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-pointers-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,25 @@\n+/* CTF generation for pointer types.\n+\n+   In this testcase, de-duplication of pointer types is exercised.  The\n+   compostition of structs in this testcase is such that when adding CTF for\n+   pointer type (link), the pointed-to-type type already adds the pointer to\n+   struct link.\n+   \n+   In this testcase, one CTF pointer type record is expected.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xe000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+\n+struct link;\n+\n+typedef struct items {\n+    struct link * link; \n+    int str;\n+} itemslist;\n+\n+itemslist il;\n+\n+struct link { struct link * next; };\n+"}, {"sha": "28547fae9a97ce3d3f16c64fa473cc2c9ea0d149", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-preamble-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-preamble-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-preamble-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-preamble-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,11 @@\n+/* Verify the CTF preamble in the CTF section.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+/* { dg-final { scan-assembler \"0xdff2.*CTF preamble magic number\" } } */\n+/* { dg-final { scan-assembler \"0x4.*CTF preamble version\" } } */\n+/* { dg-final { scan-assembler \"0.*CTF preamble flags\" } } */\n+\n+void func (void)\n+{\n+}"}, {"sha": "0c51839460c267c96969936a7b94005803827c75", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-skip-types-1.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,38 @@\n+/* CTF does not have representation for some types at this time.  These types\n+   are skipped in the CTF generation phase in the compiler.\n+   \n+   An explicit CTF type with kind CTF_K_UNKNOWN is created for types that do\n+   not have representation in CTF.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-gctf -dA\" } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"unknown.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+/* { dg-require-effective-target libc_has_complex_functions } */\n+\n+#include <complex.h>\n+\n+typedef float La_x86_64_xmm __attribute__ ((__vector_size__ (16)));\n+La_x86_64_xmm a1;\n+\n+/* GCC also supports complex integer data types.  */\n+complex char a;\n+complex signed char b;\n+complex unsigned char c;\n+complex short int d;\n+complex short unsigned int e;\n+complex int f;\n+complex unsigned int g;\n+complex long int h;\n+complex long unsigned int i;\n+complex long long int j;\n+\n+enum gomp_schedule_type\n+{\n+  GFS_RUNTIME,\n+  GFS_STATIC,\n+  GFS_MONOTONIC = 0x80000000U\n+};\n+\n+enum gomp_schedule_type gsch_type;"}, {"sha": "7c8b17df6db8492f1a458580fd460a7527c10d57", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-skip-types-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,17 @@\n+/* CTF does not have representation for some types at this time.  These types\n+   are skipped in the CTF generation phase in the compiler.\n+\n+   Skip IEEE interchange and extended formats for CTF generation.\n+\n+   In this testcase, CTF records for types are not added as CTF has no\n+   representation for IEEE interchange and extended formats.\n+\n+   CTF records for variables do exist, however.  The referenced type is\n+   CTF_TYPE_NULLID.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-gctf\" } */\n+\n+/* { dg-require-effective-target float16 } */\n+\n+_Float16 f16;"}, {"sha": "394fa2f7b418abc4b2c54e79b0808654de6e4633", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-skip-types-3.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-3.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,20 @@\n+/* CTF does not have representation for some types at this time.  These types\n+   are skipped in the CTF generation phase in the compiler.\n+\n+   Skip IEEE interchange and extended formats for CTF generation.\n+\n+   In this testcase, CTF records for types are not added as CTF has no\n+   representation for IEEE interchange and extended formats.\n+\n+   CTF records for variables and pointer do exist, however.  The referenced\n+   type is CTF_TYPE_NULLID.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-gctf\" } */\n+\n+/* { dg-require-effective-target float32 } */\n+/* { dg-require-effective-target float32x } */\n+\n+_Float32 f32;\n+_Float32x f32x;\n+_Float32 * f32p;"}, {"sha": "f4374e6f0f74b27900405306a0364b2ea683b0a1", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-skip-types-4.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-4.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,19 @@\n+/* CTF does not have representation for some types at this time.  These types\n+   are skipped in the CTF generation phase in the compiler.\n+\n+   Skip IEEE interchange and extended formats for CTF generation.\n+\n+   In this testcase, CTF records for types are not added as CTF has no\n+   representation for IEEE interchange and extended formats.\n+\n+   CTF records for variables and pointer do exist, however.  The referenced\n+   type is CTF_TYPE_NULLID.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-gctf\" } */\n+\n+/* { dg-require-effective-target float64 } */\n+/* { dg-require-effective-target float64x } */\n+\n+_Float64 f64;\n+_Float64x f64x;"}, {"sha": "026f9e06f672dac1ee685ffff775ac1c767c1784", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-skip-types-5.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-5.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,19 @@\n+/* CTF does not have representation for some types at this time.  These types\n+   are skipped in the CTF generation phase in the compiler.\n+\n+   Skip IEEE interchange and extended formats for CTF generation.\n+\n+   In this testcase, CTF records for types are not added as CTF has no\n+   representation for IEEE interchange and extended formats.\n+\n+   CTF records for variables and pointer do exist, however.  The referenced\n+   type is CTF_TYPE_NULLID.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-gctf\" } */\n+\n+/* { dg-require-effective-target float128 } */\n+/* { dg-require-effective-target float128x } */\n+\n+_Float128 f128;\n+_Float128x f128x;"}, {"sha": "f2dbe08774f4b008eea29d0b7ec3612a9b427144", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-skip-types-6.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-6.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,18 @@\n+/* CTF does not have representation for some types at this time.  These types\n+   are skipped in the CTF generation phase in the compiler.\n+\n+   Skip Decimal Floating Point format types for CTF generation.\n+\n+   In this testcase, CTF records for types are not added as CTF has no\n+   representation for Decimal floating point format.\n+\n+   CTF records for variables do exist, however.  The referenced type is\n+   CTF_TYPE_NULLID.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-gctf\" } */\n+/* { dg-require-effective-target dfp } */\n+\n+_Decimal32 d32;\n+_Decimal64 d64;\n+_Decimal128 d128;"}, {"sha": "a9d86de64822374f8b9e7c4b345015d55af6e35e", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-skip-types-7.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-7.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,18 @@\n+/* CTF does not have representation for some types at this time.  These types\n+   are skipped in the CTF generation phase in the compiler.\n+\n+   Skip IEEE interchange and extended formats for CTF generation.\n+\n+   In this testcase, CTF records for types are not added as CTF has no\n+   representation for IEEE interchange and extended formats.  This testcase\n+   checks that CTF generation skips the 128-bit float gracefully, when code\n+   generation is for a 32-bit environment.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-gctf -m32\" } */\n+\n+/* { dg-require-effective-target float128 } */\n+/* { dg-require-effective-target float128x } */\n+\n+_Float128 f128;\n+_Float128x f128x;"}, {"sha": "2413e91d30717980db497891882a6ef5ba4f7408", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-skip-types-8.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-skip-types-8.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,27 @@\n+/* CTF does not have representation for _Atomic qualifier.  This qualifier is\n+   skipped in the CTF generation phase in the compiler.\n+\n+   In this testcase, CTF records for the _Atomic qualifier are not added as\n+   CTF has no representation for it. CTF records for the underlying type are,\n+   however, added.  So, CTF records for typedef, const and the underlying\n+   struct are expected.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2a000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x32000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x1a000003\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ctm_name\" 3 } } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"comp_type.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"comp_type_t.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"c1.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+typedef struct comp_type\n+{\n+  int a;\n+  float b;\n+  char c;\n+} comp_type_t;\n+\n+_Atomic const comp_type_t c1;"}, {"sha": "0a0f1f033f726149b6c2b2a37c835855ee5ae339", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-str-table-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-str-table-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-str-table-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-str-table-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,26 @@\n+/* CTF String Table as generated by the compiler is expected to have only a\n+   single empty string.  Just an optimization by the compiler, it is not\n+   mandated by the CTF format.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+/* { dg-final { scan-assembler-times \"ascii \\\".0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+union wait\n+{\n+  int w_status;\n+  struct\n+    {\n+      int __w_termsig;\n+      int __w_coredump;\n+    } __wait_terminated;\n+   struct\n+    {\n+      int __w_stopval;\n+      int __w_stopsig;\n+    } __wait_stopped;\n+};\n+\n+typedef union { union wait * __uptr; int * iptr; } __WAIT_STATUS;\n+\n+__WAIT_STATUS waitstatus;"}, {"sha": "19711c04bf7e8c759074d55c826e4cfebb2b319a", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-struct-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,25 @@\n+/* Test compilation of struct type.\n+\n+   In this testcase, two CTF_K_STRUCT records are expected\n+   struct a : ctt_info = 0x1a000004 (4 field members)\n+   struct b : ctt_into = 0x1a000002 (2 field members)\n+*/\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x1a000004\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x1a000002\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ctm_name\" 6 } } */\n+\n+struct a\n+{\n+  int d1;\n+  int d2;\n+  float c;\n+  struct b\n+    {\n+      int time;\n+      int wall;\n+    } b1;\n+} my_a;"}, {"sha": "09b4d2f8f789d6c44a4e3f7b49609a2be3abffc3", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-struct-2.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,32 @@\n+/* Test for compilation of self-referntial structs.\n+\n+   Further, the compiler is expected to generate a single CTF struct type for\n+   struct dmx_dtdef (due to Type de-duplication at CTF generation).  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"dmx_dtdef.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"dtd_name.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"dtd_type.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"dmx_dtdef_t.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+struct link\n+{\n+  struct link * next;\n+} * s_link;\n+\n+typedef long dmx_id_t;\n+\n+typedef struct dmx_dtdef\n+{\n+  char * dtd_name;\n+  dmx_id_t dtd_type;\n+} dmx_dtdef_t;\n+\n+typedef struct dmx_bundle\n+{\n+  dmx_id_t dmb_type;\n+  dmx_dtdef_t * dmb_dtd;\n+} dmx_bundle_t;\n+\n+dmx_bundle_t dbt;"}, {"sha": "d6c6b6be91fdf7ffc500e36fd7c63309bb267adf", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-struct-array-1.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-array-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-array-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-array-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,65 @@\n+/* Test Compilation of mixed constructs containing structs and arrays.\n+\n+   Further, the compiler is expected to generate a single CTF struct type for\n+   struct cmodel (due to Type de-duplication at the time of CTF generation).\n+   \n+   const qualifier in fields of structs should be processed.  It appears as a\n+   no-name CTF record with appropriate ctt_info.  In this testcase, there are\n+   two const qualifiers - const char and const struct cmodel.  However, due to\n+   way the debug information is represented in DWARF die, 3 const qualifier\n+   records appear in the CTF section.\n+\n+   <1><e1>: Abbrev Number: 14 (DW_TAG_typedef)\n+      <e2>   DW_AT_name        : (indirect string, offset: 0x114): cmodel_t\n+      <e9>   DW_AT_type        : <0x9a>\n+   <1><ed>: Abbrev Number: 13 (DW_TAG_const_type)\n+      <ee>   DW_AT_type        : <0xe1>\n+   <1><f2>: Abbrev Number: 4 (DW_TAG_array_type)\n+      <f3>   DW_AT_type        : <0xed>\n+      <f7>   DW_AT_sibling     : <0x102>\n+\n+   <2><101>: Abbrev Number: 0\n+   <1><102>: Abbrev Number: 13 (DW_TAG_const_type)\n+      <103>   DW_AT_type        : <0xf2>\n+   <1><107>: Abbrev Number: 15 (DW_TAG_variable)\n+      <108>   DW_AT_name        : (indirect string, offset: 0x57): _models\n+      <10f>   DW_AT_type        : <0x102>\n+   <1><11d>: Abbrev Number: 0\n+\n+   This results in:\n+\n+   _models ->  e: const const cmodel_t [3] (size 0x30) -> d: const cmodel_t [3] (size 0x30)\n+\n+   Deemed as acceptable for now.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ascii \\\"cmodel.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"cname.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"cpointer.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"cmodel_t.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+/* 3 const records are expected.  */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x32000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 3 } } */\n+\n+struct a\n+{\n+  int a1[2];\n+  struct { int b[3]; } a2;\n+};\n+\n+struct a my_a;\n+\n+typedef struct cmodel\n+{\n+  const char *cname;\n+  int ccode;\n+  int cpointer;\n+} cmodel_t;\n+\n+static const cmodel_t _models[] = {\n+  {\"ILP32\", 0, 4},\n+  {\"LP64\", 0, 8},\n+  {\"\", 0, 0}\n+};"}, {"sha": "9e698fde89ee4cb8062f970e0fb393c1726411a1", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-struct-array-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-array-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-array-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-array-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,15 @@\n+/* CTF generation for struct type in presence of DWARF2.\n+\n+   In case of DWARF2, the data member location is an expression containing\n+   the location.  CTF generation feeds off DWARF dies; this testcase tests\n+   that the location expr is handled.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA -gdwarf-2\" } */\n+\n+/* { dg-final { scan-assembler-times \"0x12000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4\\[\\t \\]+\\[^\\n\\]*cta_nelems\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0\\[\\t \\]+\\[^\\n\\]*ctm_offset\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4\\[\\t \\]+\\[^\\n\\]*ctm_offset\" 1 } } */\n+\n+static struct ranges {int from, to;} lim_regs[] = {{ 16, 7}, { 16, 6}, { 20, 7},{ 20, 6}};"}, {"sha": "22005ed035032f289db4c3b0d57a766eb9aa99a2", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-struct-pointer-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-pointer-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-pointer-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-pointer-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* This tests the following scenario:\n+\n+   1. struct foo;\n+   2. struct foo *a_foo;\n+   3. struct foo { int bar; };\n+   4. void baz (struct foo *f) { f->bar = 0; }\n+\n+   At 2. a forward for struct foo is generated and at 3. the struct\n+   type is fully defined.  When a pointer to foo is encountered at 4.,\n+   an additional CTF type for the completed struct shall be emitted as\n+   well.  The linker will deduplicate both types.  */\n+\n+struct foo;\n+struct foo *a_foo;\n+struct foo { int bar; };\n+void baz (struct foo *f) { f->bar = 0; }\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]\\\"bar.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */"}, {"sha": "569e5e237d926570b4dcb3d36b7161e1e02c4367", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-struct-pointer-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-pointer-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-pointer-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-struct-pointer-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* This tests the following scenario:\n+\n+   1. struct foo;\n+   2. struct foo *a_foo;\n+   3. struct foo { int bar; };\n+   4. void baz (struct foo **f) { f->bar = 0; }\n+\n+   At 2. a forward for struct foo is generated and at 3. the struct\n+   type is fully defined.  When a pointer to a pointer to foo is\n+   encountered at 4., an additional CTF type for the completed struct\n+   shall be emitted as well.  The linker will deduplicate both\n+   types.  */\n+\n+struct foo;\n+struct foo *a_foo;\n+struct foo { int bar; };\n+void baz (struct foo **f) { (*f)->bar = 0; }\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]\\\"bar.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */"}, {"sha": "aa40ab0a6715ab483a6fb78c5a0be03cf4504038", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-typedef-1.c", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,68 @@\n+/* CTF_K_TYPEDEF record generation.\n+\n+   In this testcase, 7 typedef records are expected.\n+\n+   Further, the declared variables must be of type typedef\n+\n+     Variables:\n+\ta ->  2: my_int (size 0x4) -> 1: int (size 0x4)\n+\tb ->  3: bar_int (size 0x4) -> 1: int (size 0x4)\n+\tc ->  4: foo_int (size 0x4) -> 1: int (size 0x4)\n+\td ->  7: my_array (size 0x8) -> 5: struct  (size 0x8)\n+\te ->  9: CINT (size 0x4) -> 8: const int (size 0x4) -> 1: int (size 0x4)\n+\tf ->  c: CINTP (size 0x8) -> b: const int * (size 0x8) -> a: const int (size 0x4) -> 1: int (size 0x4)\n+\tg ->  f: my_node_t (size 0x8) -> d: struct my_node (size 0x8)\n+\n+    There is no direct way to check that the variables are of type typedef.\n+    So in this testcase, we simply check that:\n+    1. The typedef records are generated (Check for 7 specific ctt_info, and\n+       check for the ascii strings for the typedef names).\n+    2. The ctv_typeidx are distinct (each pointing to a specfic unique type).\n+       Note that if variables were not of type typedef, ctv_typeidx will not be\n+       unique (type of a, b, c will all point to int); hence, the check.\n+   */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"0x2a000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 7 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"my_int.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"bar_int.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"foo_int.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"my_array.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"CINT.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"CINTP.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"my_node_t.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2\\[\\t \\]+\\[^\\n\\]*ctv_typeidx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4\\[\\t \\]+\\[^\\n\\]*ctv_typeidx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x5\\[\\t \\]+\\[^\\n\\]*ctv_typeidx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x9\\[\\t \\]+\\[^\\n\\]*ctv_typeidx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xa\\[\\t \\]+\\[^\\n\\]*ctv_typeidx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xc\\[\\t \\]+\\[^\\n\\]*ctv_typeidx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0xf\\[\\t \\]+\\[^\\n\\]*ctv_typeidx\" 1 } } */\n+\n+typedef int my_int;\n+typedef int bar_int;\n+typedef int foo_int;\n+\n+typedef struct { int a[2]; } my_array;\n+\n+typedef const int CINT;\n+typedef const int * CINTP;\n+\n+typedef struct my_node\n+{\n+  int flags;\n+  char value;\n+} my_node_t;\n+\n+my_int a;\n+bar_int b;\n+foo_int c;\n+\n+my_array d;\n+CINT e = 3;\n+CINTP f = &e;\n+\n+my_node_t g;"}, {"sha": "8c9d3bb19ce24f500b2abc968d6bc280d01697e9", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-typedef-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,20 @@\n+/* CTF_K_TYPEDEF record generation.\n+\n+   In this testcase, typedef of type void should be generated.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"0x2a000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"foo_void_type.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"void.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+typedef void foo_void_type;\n+\n+struct bar\n+{\n+  int a;\n+  foo_void_type *b;\n+};\n+\n+struct bar c;"}, {"sha": "93d0845b042754a9483e3b9ff6453821864edf3f", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-typedef-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-3.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,24 @@\n+/* Type de-duplication of CTF_K_TYPEDEF records.\n+\n+   In this testcase, a single CTF record for typedef is expected.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"0x2a000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"foo_type.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"foo.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 1 } } */\n+\n+typedef struct foo foo_type;\n+\n+struct bar\n+{\n+  struct foo * f1;\n+  foo_type * f2;\n+};\n+\n+struct testme {\n+    struct bar * b1;\n+};\n+\n+struct testme * t1;"}, {"sha": "19e8f496105c98032fdb9413b38ea7fbb1e2eb02", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-typedef-struct-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-struct-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-struct-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-struct-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+typedef struct my_int\n+{\n+  int upper;\n+  int lower;\n+  struct bitmask\n+    {\n+      int flags;\n+    } my_mask;\n+} my_int_t;\n+\n+my_int_t mit;"}, {"sha": "deeb85aab9da7211f36a47dcdf2bec34dda71ce5", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-typedef-struct-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-struct-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-struct-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-struct-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,17 @@\n+/* Test compilation of typedef composition in structs.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+typedef struct\n+{\n+  int day, month, year;\n+} Date;\n+\n+typedef struct\n+{\n+  Date filedDate, fixedDate;\n+  int severity;\n+} BugRef;\n+\n+BugRef CR2112;"}, {"sha": "6d6918b15368719a459bb12b4ea5878a1731a2c4", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-typedef-struct-3.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-struct-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-struct-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-typedef-struct-3.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,32 @@\n+/* Test CTF generation for a typedef instantiation with CVR quals.\n+\n+   Caveat: There is no direct way to test that the type of foo is\n+   \"const my_int_t\" via scanning the assembly. This test instead\n+   checks for the presence of some of the CTF constructs involved\n+   individually. Specifically, it checks for CTF const record and\n+   CTF typedef record.\n+\n+  Variables:\n+      foo ->  4: const my_int_t (size 0x8) -> 3: my_int_t (size 0x8) -> 1: struct my_int (size 0x8)\n+\n+   Types:\n+      1: struct my_int (size 0x8)\n+      2: int (size 0x4)\n+      3: my_int_t (size 0x8) -> 1: struct my_int (size 0x8)\n+      4: const my_int_t (size 0x8) -> 3: my_int_t (size 0x8) -> 1: struct my_int (size 0x8)\n+*/\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x4\\[\\t \\]+\\[^\\n\\]*ctv_typeidx\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x2a000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x32000000\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+\n+typedef struct my_int\n+{\n+    int upper;\n+      int lower;\n+} my_int_t;\n+\n+const my_int_t foo = {10, 20};"}, {"sha": "929d53298394caa2b7d3aca5646385e680d14e7f", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-union-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-union-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-union-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-union-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,14 @@\n+/* CTF generation for union type.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+/* { dg-final { scan-assembler-times \"\\[\\t \\]0x1e000004\\[\\t \\]+\\[^\\n\\]*ctt_info\" 1 } } */\n+/* { dg-final { scan-assembler-times \"ctm_name\" 4 } } */\n+\n+union c\n+{\n+  int c1;\n+  int c2;\n+  int c3;\n+  int c4;\n+} my_u_c;"}, {"sha": "8c3ab1050e0ca9fa2dcaf6b2ab44bac54bcb12e2", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-variables-1.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-variables-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-variables-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-variables-1.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,25 @@\n+/* CTF generation for global variables.\n+\n+   In this testcase, 7 records in the variable info section are expected.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ctv_name\" 7 } } */\n+\n+float var1;\n+double var2;\n+long double var3;\n+\n+char ascii = 'a';\n+\n+int a = 33;\n+int a1[2] = {22, 33};\n+\n+struct d\n+{\n+  int d1;\n+  int d2;\n+};\n+\n+struct d d_instance;"}, {"sha": "75c3ed790f4e24d59f001f5f52b48a37b457cf5a", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf-variables-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-variables-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-variables-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf-variables-2.c?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,16 @@\n+/* CTF generation for static variables inside a function.\n+\n+   In this testcase, CTF record for bstatic is NOT expected.  CTF generation\n+   is only carried out for variables at file-scope or global-scope.  */\n+\n+/* { dg-do compile )  */\n+/* { dg-options \"-O0 -gctf -dA\" } */\n+\n+/* { dg-final { scan-assembler-times \"ctv_name\" 0 } } */\n+/* { dg-final { scan-assembler-times \"ascii \\\"bstatic.0\\\"\\[\\t \\]+\\[^\\n\\]*ctf_string\" 0 } } */\n+\n+int foo (int a)\n+{\n+  static int bstatic = 3;\n+  return a + bstatic;\n+}"}, {"sha": "46055f8a2bf19d342e20ff594778364b4605172b", "filename": "gcc/testsuite/gcc.dg/debug/ctf/ctf.exp", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug%2Fctf%2Fctf.exp?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -0,0 +1,41 @@\n+#   Copyright (C) 2002-2019 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3 of the License, or\n+# (at your option) any later version.\n+# \n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+# \n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# GCC testsuite that uses the `dg.exp' driver.\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+\n+# Disable on ptx (in sync with DWARF testsuite)\n+if { [istarget nvptx-*-*] } {\n+    return\n+}\n+\n+# If a testcase doesn't have special options, use these.\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+    set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Initialize `dg'.\n+dg-init\n+\n+# Main loop.\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.\\[cS\\] ]] \\\n+\t\"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "51d8a11f878c1e5ddf43c6986d33427d678f9d78", "filename": "gcc/testsuite/lib/gcc-dg.exp", "status": "modified", "additions": 49, "deletions": 15, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1f76af469388d3df815c82de566387da5ae000f/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Fgcc-dg.exp?ref=c1f76af469388d3df815c82de566387da5ae000f", "patch": "@@ -621,6 +621,22 @@ proc gcc-dg-runtest { testcases flags default-extra-flags } {\n     }\n }\n \n+# Check if frontend has CTF support\n+proc gcc-dg-frontend-supports-ctf { target_compile trivial } {\n+    global srcdir subdir\n+\n+    set comp_output [$target_compile \\\n+\t    \"$srcdir/$subdir/$trivial\" \"trivial.S\" assembly \\\n+\t    \"additional_flags=-gctf\"]\n+    if { ! [string match \\\n+\t    \"*CTF debug info requested, but not supported for * frontend*\" \\\n+\t    $comp_output] } {\n+\tremove-build-file \"trivial.S\"\n+\treturn 1\n+    }\n+    return 0\n+}\n+\n # Check if the target system supports the debug format\n proc gcc-dg-target-supports-debug-format { target_compile trivial type } {\n     global srcdir subdir\n@@ -639,21 +655,30 @@ proc gcc-dg-target-supports-debug-format { target_compile trivial type } {\n proc gcc-dg-debug-runtest { target_compile trivial opt_opts testcases } {\n     if ![info exists DEBUG_TORTURE_OPTIONS] {\n \tset DEBUG_TORTURE_OPTIONS \"\"\n-\tforeach type {-gdwarf-2 -gstabs -gstabs+ -gxcoff -gxcoff+} {\n-\t    if [expr [gcc-dg-target-supports-debug-format \\\n-\t\t      $target_compile $trivial $type]] {\n-\t\tforeach level {1 \"\" 3} {\n-\t\t    if { ($type == \"-gdwarf-2\") && ($level != \"\") } {\n-\t\t\tlappend DEBUG_TORTURE_OPTIONS [list \"${type}\" \"-g${level}\"]\n-\t\t\tforeach opt $opt_opts {\n-\t\t\t    lappend DEBUG_TORTURE_OPTIONS \\\n-\t\t\t\t    [list \"${type}\" \"-g${level}\" \"$opt\" ]\n-\t\t\t}\n-\t\t    } else {\n-\t\t\tlappend DEBUG_TORTURE_OPTIONS [list \"${type}${level}\"]\n-\t\t\tforeach opt $opt_opts {\n-\t\t\t    lappend DEBUG_TORTURE_OPTIONS \\\n-\t\t\t\t    [list \"${type}${level}\" \"$opt\" ]\n+\tforeach type {-gctf -gdwarf-2 -gstabs -gstabs+ -gxcoff -gxcoff+} {\n+\t    if { $type == \"-gctf\" } {\n+\t\tif [expr [gcc-dg-frontend-supports-ctf \\\n+\t\t\t  $target_compile $trivial]] {\n+\t\t    # At this time, running tests with various opt levels or\n+\t\t    # ctf debug info levels does not add value.\n+\t\t    lappend DEBUG_TORTURE_OPTIONS  [list \"${type}\"]\n+\t\t}\n+\t    } else {\n+\t\tif [expr [gcc-dg-target-supports-debug-format \\\n+\t\t\t  $target_compile $trivial $type]] {\n+\t\t    foreach level {1 \"\" 3} {\n+\t\t\tif { ($type == \"-gdwarf-2\") && ($level != \"\") } {\n+\t\t\t    lappend DEBUG_TORTURE_OPTIONS [list \"${type}\" \"-g${level}\"]\n+\t\t\t    foreach opt $opt_opts {\n+\t\t\t\tlappend DEBUG_TORTURE_OPTIONS \\\n+\t\t\t\t\t[list \"${type}\" \"-g${level}\" \"$opt\" ]\n+\t\t\t    }\n+\t\t\t} else {\n+\t\t\t    lappend DEBUG_TORTURE_OPTIONS [list \"${type}${level}\"]\n+\t\t\t    foreach opt $opt_opts {\n+\t\t\t\tlappend DEBUG_TORTURE_OPTIONS \\\n+\t\t\t\t\t[list \"${type}${level}\" \"$opt\" ]\n+\t\t\t    }\n \t\t\t}\n \t\t    }\n \t\t}\n@@ -698,6 +723,15 @@ proc gcc-dg-debug-runtest { target_compile trivial opt_opts testcases } {\n \t\tset doit 0\n \t    }\n \n+\t    # These tests check for information which is not emitted for CTF\n+\t    # as CTF type information is emitted for entities at file and \n+\t    # global scope only.\n+\t    if { ([string match {*/debug-[126].c} \"$nshort\"] \\\n+\t\t  || [string match {*/enum-[12].C} \"$nshort\"] ) \\\n+\t\t  && [string match \"*ctf*\" \"$flags\"] } {\n+\t\tset doit 0\n+\t    }\n+\n \t    if { $doit } {\n \t\tverbose -log \"Testing $nshort, $flags\" 1\n \t\tdg-test $test $flags \"\""}]}