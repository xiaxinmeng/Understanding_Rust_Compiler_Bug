{"sha": "65d169d922a0ae5a5a4570edca5ce94ab3d7f2aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjVkMTY5ZDkyMmEwYWU1YTVhNDU3MGVkY2E1Y2U5NGFiM2Q3ZjJhYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-07-26T22:51:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-07-26T22:51:56Z"}, "message": "re PR middle-end/28071 (A file that can not be compiled in reasonable time/space)\n\n\tPR rtl-optimization/28071\n\t* regmove.c (reg_is_remote_constant_p): Avoid quadratic behaviour.\n\t(reg_set_in_bb, max_reg_computed): New static variables.\n\t(regmove_optimize): Free the new array.\n\t(fixup_match_1): Update call of reg_is_remote_constant_p.\n\nFrom-SVN: r115765", "tree": {"sha": "f8d00326ee6111946d13f5402f15fd26e7c0cd74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f8d00326ee6111946d13f5402f15fd26e7c0cd74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/65d169d922a0ae5a5a4570edca5ce94ab3d7f2aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d169d922a0ae5a5a4570edca5ce94ab3d7f2aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/65d169d922a0ae5a5a4570edca5ce94ab3d7f2aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/65d169d922a0ae5a5a4570edca5ce94ab3d7f2aa/comments", "author": null, "committer": null, "parents": [{"sha": "96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96fc428c75cc0b52a53f6f8231be83dd78dcec4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96fc428c75cc0b52a53f6f8231be83dd78dcec4e"}], "stats": {"total": 88, "additions": 57, "deletions": 31}, "files": [{"sha": "6987f9c9b6dafd160dc18314405744352b600f29", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d169d922a0ae5a5a4570edca5ce94ab3d7f2aa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d169d922a0ae5a5a4570edca5ce94ab3d7f2aa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=65d169d922a0ae5a5a4570edca5ce94ab3d7f2aa", "patch": "@@ -1,3 +1,11 @@\n+2006-07-27  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR rtl-optimization/28071\n+\t* regmove.c (reg_is_remote_constant_p): Avoid quadratic behaviour.\n+\t(reg_set_in_bb, max_reg_computed): New static variables.\n+\t(regmove_optimize): Free the new array.\n+\t(fixup_match_1): Update call of reg_is_remote_constant_p.\n+\n 2006-07-26  Jan Hubicka  <jh@suse.cz>\n \n \tPR tree-optimization/27882"}, {"sha": "84c811a1d648e036db5645c9dd01fc4ae33e6a2a", "filename": "gcc/regmove.c", "status": "modified", "additions": 49, "deletions": 31, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/65d169d922a0ae5a5a4570edca5ce94ab3d7f2aa/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/65d169d922a0ae5a5a4570edca5ce94ab3d7f2aa/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=65d169d922a0ae5a5a4570edca5ce94ab3d7f2aa", "patch": "@@ -77,7 +77,6 @@ static int try_auto_increment (rtx, rtx, rtx, rtx, HOST_WIDE_INT, int);\n static int find_matches (rtx, struct match *);\n static void replace_in_call_usage (rtx *, unsigned int, rtx, rtx);\n static int fixup_match_1 (rtx, rtx, rtx, rtx, rtx, int, int, int);\n-static int reg_is_remote_constant_p (rtx, rtx, rtx);\n static int stable_and_no_regs_but_for_p (rtx, rtx, rtx);\n static int regclass_compatible_p (int, int);\n static int replacement_quality (rtx);\n@@ -839,6 +838,14 @@ copy_src_to_dest (rtx insn, rtx src, rtx dest, int old_max_uid)\n     }\n }\n \n+/* reg_set_in_bb[REGNO] points to basic block iff the register is set\n+   only once in the given block and has REG_EQUAL note.  */\n+\n+basic_block *reg_set_in_bb;\n+\n+/* Size of reg_set_in_bb array.  */\n+static unsigned int max_reg_computed;\n+\n \f\n /* Return whether REG is set in only one location, and is set to a\n    constant, but is set in a different basic block from INSN (an\n@@ -850,51 +857,57 @@ copy_src_to_dest (rtx insn, rtx src, rtx dest, int old_max_uid)\n    is used in a different basic block as well as this one?).  FIRST is\n    the first insn in the function.  */\n \n-static int\n-reg_is_remote_constant_p (rtx reg, rtx insn, rtx first)\n+static bool\n+reg_is_remote_constant_p (rtx reg, rtx insn)\n {\n+  basic_block bb;\n   rtx p;\n+  int max;\n \n-  if (REG_N_SETS (REGNO (reg)) != 1)\n-    return 0;\n-\n-  /* Look for the set.  */\n-  for (p = BB_HEAD (BLOCK_FOR_INSN (insn)); p != insn; p = NEXT_INSN (p))\n+  if (!reg_set_in_bb)\n     {\n-      rtx s;\n+      max_reg_computed = max = max_reg_num ();\n+      reg_set_in_bb = xcalloc (max, sizeof (*reg_set_in_bb));\n \n-      if (!INSN_P (p))\n-\tcontinue;\n-      s = single_set (p);\n-      if (s != 0\n-\t  && REG_P (SET_DEST (s))\n-\t  && REGNO (SET_DEST (s)) == REGNO (reg))\n+      FOR_EACH_BB (bb)\n+\tfor (p = BB_HEAD (bb); p != NEXT_INSN (BB_END (bb));\n+\t     p = NEXT_INSN (p))\n \t{\n-\t  /* The register is set in the same basic block.  */\n-\t  return 0;\n+\t  rtx s;\n+\n+\t  if (!INSN_P (p))\n+\t    continue;\n+\t  s = single_set (p);\n+\t  /* This is the instruction which sets REG.  If there is a\n+\t     REG_EQUAL note, then REG is equivalent to a constant.  */\n+\t  if (s != 0\n+\t      && REG_P (SET_DEST (s))\n+\t      && REG_N_SETS (REGNO (SET_DEST (s))) == 1\n+\t      && find_reg_note (p, REG_EQUAL, NULL_RTX))\n+\t    reg_set_in_bb[REGNO (SET_DEST (s))] = bb;\n \t}\n     }\n-\n-  for (p = first; p && p != insn; p = NEXT_INSN (p))\n+  gcc_assert (REGNO (reg) < max_reg_computed);\n+  if (reg_set_in_bb[REGNO (reg)] == NULL)\n+    return false;\n+  if (reg_set_in_bb[REGNO (reg)] != BLOCK_FOR_INSN (insn))\n+    return true;\n+  /* Look for the set.  */\n+  for (p = BB_HEAD (BLOCK_FOR_INSN (insn)); p != insn; p = NEXT_INSN (p))\n     {\n       rtx s;\n \n-      if (! INSN_P (p))\n+      if (!INSN_P (p))\n \tcontinue;\n       s = single_set (p);\n       if (s != 0\n-\t  && REG_P (SET_DEST (s))\n-\t  && REGNO (SET_DEST (s)) == REGNO (reg))\n+\t  && REG_P (SET_DEST (s)) && REGNO (SET_DEST (s)) == REGNO (reg))\n \t{\n-\t  /* This is the instruction which sets REG.  If there is a\n-             REG_EQUAL note, then REG is equivalent to a constant.  */\n-\t  if (find_reg_note (p, REG_EQUAL, NULL_RTX))\n-\t    return 1;\n-\t  return 0;\n+\t  /* The register is set in the same basic block.  */\n+\t  return false;\n \t}\n     }\n-\n-  return 0;\n+  return true;\n }\n \n /* INSN is adding a CONST_INT to a REG.  We search backwards looking for\n@@ -1355,7 +1368,7 @@ regmove_optimize (rtx f, int nregs)\n \t\t it for this optimization, as this would make it\n \t\t no longer equivalent to a constant.  */\n \n-\t      if (reg_is_remote_constant_p (src, insn, f))\n+\t      if (reg_is_remote_constant_p (src, insn))\n \t\t{\n \t\t  if (!copy_src)\n \t\t    {\n@@ -1504,6 +1517,11 @@ regmove_optimize (rtx f, int nregs)\n   /* Clean up.  */\n   free (regno_src_regno);\n   free (regmove_bb_head);\n+  if (reg_set_in_bb)\n+    {\n+      free (reg_set_in_bb);\n+      reg_set_in_bb = NULL;\n+    }\n }\n \n /* Returns nonzero if INSN's pattern has matching constraints for any operand.\n@@ -1685,7 +1703,7 @@ fixup_match_1 (rtx insn, rtx set, rtx src, rtx src_subreg, rtx dst,\n      then do not use it for this optimization.  We want the equivalence\n      so that if we have to reload this register, we can reload the\n      constant, rather than extending the lifespan of the register.  */\n-  if (reg_is_remote_constant_p (src, insn, get_insns ()))\n+  if (reg_is_remote_constant_p (src, insn))\n     return 0;\n \n   /* Scan forward to find the next instruction that"}]}