{"sha": "03ba64bb82a8dec984d3ef1f8fedaac55ed20130", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNiYTY0YmI4MmE4ZGVjOTg0ZDNlZjFmOGZlZGFhYzU1ZWQyMDEzMA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-02-22T00:42:04Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-02-22T00:42:04Z"}, "message": "hashtable: Trivial formatting fixes.\n\n2006-02-21  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/hashtable: Trivial formatting fixes.\n\nFrom-SVN: r111355", "tree": {"sha": "55b286d7a750987d78dc73bd0ad9367cd7e2fc4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55b286d7a750987d78dc73bd0ad9367cd7e2fc4d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03ba64bb82a8dec984d3ef1f8fedaac55ed20130", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03ba64bb82a8dec984d3ef1f8fedaac55ed20130", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03ba64bb82a8dec984d3ef1f8fedaac55ed20130", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03ba64bb82a8dec984d3ef1f8fedaac55ed20130/comments", "author": null, "committer": null, "parents": [{"sha": "411c6f862fe61005f0b32cfad808f2ce0cf5371d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/411c6f862fe61005f0b32cfad808f2ce0cf5371d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/411c6f862fe61005f0b32cfad808f2ce0cf5371d"}], "stats": {"total": 158, "additions": 83, "deletions": 75}, "files": [{"sha": "4ded6e7878196abe56c0d2f361abb79b8ae953ac", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ba64bb82a8dec984d3ef1f8fedaac55ed20130/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ba64bb82a8dec984d3ef1f8fedaac55ed20130/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=03ba64bb82a8dec984d3ef1f8fedaac55ed20130", "patch": "@@ -1,3 +1,7 @@\n+2006-02-21  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/hashtable: Trivial formatting fixes.\n+\n 2006-02-20  Paolo Carlini  <pcarlini@suse.de>\n \n \tRevert recent commit for libstdc++/26211, now suspended waiting for"}, {"sha": "ac3658f0148a85708aef5e52984c967783e9d109", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "modified", "additions": 79, "deletions": 75, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03ba64bb82a8dec984d3ef1f8fedaac55ed20130/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03ba64bb82a8dec984d3ef1f8fedaac55ed20130/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=03ba64bb82a8dec984d3ef1f8fedaac55ed20130", "patch": "@@ -101,6 +101,7 @@ namespace Internal\n   \n } // namespace Internal\n \n+\n //----------------------------------------------------------------------\n // Auxiliary types used for all instantiations of hashtable: nodes\n // and iterators.\n@@ -118,16 +119,16 @@ namespace Internal\n   template<typename Value>\n     struct hash_node<Value, true>\n     {\n-      Value m_v;\n+      Value       m_v;\n       std::size_t hash_code;\n-      hash_node* m_next;\n+      hash_node*  m_next;\n     };\n \n   template<typename Value>\n     struct hash_node<Value, false>\n     {\n-      Value m_v;\n-      hash_node* m_next;\n+      Value       m_v;\n+      hash_node*  m_next;\n     };\n \n   // Local iterators, used to iterate within a bucket but not between\n@@ -259,7 +260,7 @@ namespace Internal\n       void\n       m_incr_bucket();\n \n-      hash_node<Value, cache>* m_cur_node;\n+      hash_node<Value, cache>*  m_cur_node;\n       hash_node<Value, cache>** m_cur_bucket;\n     };\n \n@@ -381,6 +382,7 @@ namespace Internal\n     };\n } // namespace Internal\n \n+\n // ----------------------------------------------------------------------\n // Many of class template hashtable's template parameters are policy\n // classes.  These are defaults for the policies.\n@@ -413,7 +415,7 @@ namespace Internal\n     typedef std::size_t result_type;\n \n     result_type\n-    operator() (first_argument_type r, second_argument_type N) const\n+    operator()(first_argument_type r, second_argument_type N) const\n     { return r % N; }\n   };\n \n@@ -448,8 +450,8 @@ namespace Internal\n     std::pair<bool, std::size_t>\n     need_rehash(std::size_t n_bkt, std::size_t n_elt, std::size_t n_ins) const;\n     \n-    float m_max_load_factor;\n-    float m_growth_factor;\n+    float               m_max_load_factor;\n+    float               m_growth_factor;\n     mutable std::size_t m_next_resize;\n   };\n \n@@ -542,7 +544,7 @@ namespace Internal\n   next_bkt(std::size_t n) const\n   {\n     const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n-    const unsigned long* p = std::lower_bound (X<0>::primes, last, n);\n+    const unsigned long* p = std::lower_bound(X<0>::primes, last, n);\n     m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n     return *p;\n   }\n@@ -555,8 +557,8 @@ namespace Internal\n   {\n     const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n     const float min_bkts = n / m_max_load_factor;\n-    const unsigned long* p = std::lower_bound (X<0>::primes, last,\n-\t\t\t\t\t       min_bkts, lt());\n+    const unsigned long* p = std::lower_bound(X<0>::primes, last,\n+\t\t\t\t\t      min_bkts, lt());\n     m_next_resize = static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n     return *p;\n   }\n@@ -579,10 +581,10 @@ namespace Internal\n \tfloat min_bkts = (float(n_ins) + float(n_elt)) / m_max_load_factor;\n \tif (min_bkts > n_bkt)\n \t  {\n-\t    min_bkts = std::max (min_bkts, m_growth_factor * n_bkt);\n+\t    min_bkts = std::max(min_bkts, m_growth_factor * n_bkt);\n \t    const unsigned long* const last = X<0>::primes + X<0>::n_primes;\n-\t    const unsigned long* p = std::lower_bound (X<0>::primes, last,\n-\t\t\t\t\t\t       min_bkts, lt());\n+\t    const unsigned long* p = std::lower_bound(X<0>::primes, last,\n+\t\t\t\t\t\t      min_bkts, lt());\n \t    m_next_resize = \n \t      static_cast<std::size_t>(std::ceil(*p * m_max_load_factor));\n \t    return std::make_pair(true, *p);\n@@ -600,6 +602,7 @@ namespace Internal\n \n } // namespace Internal\n \n+\n //----------------------------------------------------------------------\n // Base classes for std::tr1::hashtable.  We define these base classes\n // because in some cases we want to do different things depending on\n@@ -703,15 +706,15 @@ namespace Internal\n   \n       std::size_t\n       bucket_index(const Key& k, hash_code_t, std::size_t N) const\n-      { return m_ranged_hash (k, N); }\n+      { return m_ranged_hash(k, N); }\n \n       std::size_t\n       bucket_index(const hash_node<Value, false>* p, std::size_t N) const\n-      { return m_ranged_hash (m_extract (p->m_v), N); }\n+      { return m_ranged_hash(m_extract(p->m_v), N); }\n   \n       bool\n       compare(const Key& k, hash_code_t, hash_node<Value, false>* n) const\n-      { return m_eq (k, m_extract(n->m_v)); }\n+      { return m_eq(k, m_extract(n->m_v)); }\n \n       void\n       store_code(hash_node<Value, false>*, hash_code_t) const\n@@ -731,8 +734,8 @@ namespace Internal\n \n     protected:\n       ExtractKey m_extract;\n-      Equal m_eq;\n-      H m_ranged_hash;\n+      Equal      m_eq;\n+      H          m_ranged_hash;\n     };\n \n \n@@ -779,15 +782,15 @@ namespace Internal\n       \n       std::size_t\n       bucket_index(const Key&, hash_code_t c, std::size_t N) const\n-      { return m_h2 (c, N); }\n+      { return m_h2(c, N); }\n \n       std::size_t\n       bucket_index(const hash_node<Value, false>* p, std::size_t N) const\n-      { return m_h2 (m_h1 (m_extract (p->m_v)), N); }\n+      { return m_h2(m_h1(m_extract(p->m_v)), N); }\n \n       bool\n       compare(const Key& k, hash_code_t, hash_node<Value, false>* n) const\n-      { return m_eq (k, m_extract(n->m_v)); }\n+      { return m_eq(k, m_extract(n->m_v)); }\n \n       void\n       store_code(hash_node<Value, false>*, hash_code_t) const\n@@ -808,9 +811,9 @@ namespace Internal\n \n     protected:\n       ExtractKey m_extract;\n-      Equal m_eq;\n-      H1 m_h1;\n-      H2 m_h2;\n+      Equal      m_eq;\n+      H1         m_h1;\n+      H2         m_h2;\n     };\n \n   // Specialization: hash function and range-hashing function, \n@@ -841,11 +844,11 @@ namespace Internal\n   \n       std::size_t\n       bucket_index(const Key&, hash_code_t c, std::size_t N) const\n-      { return m_h2 (c, N); }\n+      { return m_h2(c, N); }\n \n       std::size_t\n       bucket_index(const hash_node<Value, true>* p, std::size_t N) const\n-      { return m_h2 (p->hash_code, N); }\n+      { return m_h2(p->hash_code, N); }\n \n       bool\n       compare(const Key& k, hash_code_t c, hash_node<Value, true>* n) const\n@@ -871,9 +874,9 @@ namespace Internal\n       \n     protected:\n       ExtractKey m_extract;\n-      Equal m_eq;\n-      H1 m_h1;\n-      H2 m_h2;\n+      Equal      m_eq;\n+      H1         m_h1;\n+      H2         m_h2;\n     };\n \n } // namespace internal\n@@ -962,44 +965,44 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t\t\t\t  unique_keys> >\n     {\n     public:\n-      typedef Allocator                                      allocator_type;\n-      typedef Value                                          value_type;\n-      typedef Key                                            key_type;\n-      typedef Equal                                          key_equal;\n+      typedef Allocator                                   allocator_type;\n+      typedef Value                                       value_type;\n+      typedef Key                                         key_type;\n+      typedef Equal                                       key_equal;\n       // mapped_type, if present, comes from map_base.\n       // hasher, if present, comes from hash_code_base.\n-      typedef typename Allocator::difference_type            difference_type;\n-      typedef typename Allocator::size_type                  size_type;\n-      typedef typename Allocator::reference                  reference;\n-      typedef typename Allocator::const_reference            const_reference;\n+      typedef typename Allocator::difference_type         difference_type;\n+      typedef typename Allocator::size_type               size_type;\n+      typedef typename Allocator::reference               reference;\n+      typedef typename Allocator::const_reference         const_reference;\n       \n       typedef Internal::node_iterator<value_type, constant_iterators,\n \t\t\t\t      cache_hash_code>\n-        local_iterator;\n+                                                          local_iterator;\n       typedef Internal::node_const_iterator<value_type, constant_iterators,\n \t\t\t\t\t    cache_hash_code>\n-        const_local_iterator;\n+                                                          const_local_iterator;\n \n       typedef Internal::hashtable_iterator<value_type, constant_iterators,\n \t\t\t\t\t   cache_hash_code>\n-        iterator;\n+                                                          iterator;\n       typedef Internal::hashtable_const_iterator<value_type, constant_iterators,\n \t\t\t\t\t\t cache_hash_code>\n-        const_iterator;\n+                                                          const_iterator;\n \n     private:\n-      typedef Internal::hash_node<Value, cache_hash_code>    node;\n+      typedef Internal::hash_node<Value, cache_hash_code> node;\n       typedef typename Allocator::template rebind<node>::other\n-        node_allocator_t;\n+                                                          node_allocator_t;\n       typedef typename Allocator::template rebind<node*>::other\n-        bucket_allocator_t;\n+                                                          bucket_allocator_t;\n \n     private:\n-      node_allocator_t m_node_allocator;\n-      node** m_buckets;\n-      size_type m_bucket_count;\n-      size_type m_element_count;\n-      RehashPolicy m_rehash_policy;\n+      node_allocator_t      m_node_allocator;\n+      node**                m_buckets;\n+      size_type             m_bucket_count;\n+      size_type             m_element_count;\n+      RehashPolicy          m_rehash_policy;\n       \n       node*\n       m_allocate_node(const value_type& v);\n@@ -1025,7 +1028,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       template<typename InIter>\n         hashtable(InIter first, InIter last,\n \t\t  size_type bucket_hint,\n-\t\t  const H1&, const H2&, const H&,\n+\t\t  const H1&, const H2&, const H&, \n \t\t  const Equal&, const ExtractKey&,\n \t\t  const allocator_type&);\n   \n@@ -1231,9 +1234,10 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       void m_rehash(size_type n);\n     };\n \n+\n   //----------------------------------------------------------------------\n   // Definitions of class template hashtable's out-of-line member functions.\n-  \n+\n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n@@ -1283,7 +1287,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t    {\n \t      node* tmp = p;\n \t      p = p->m_next;\n-\t      m_deallocate_node (tmp);\n+\t      m_deallocate_node(tmp);\n \t    }\n \t  array[i] = 0;\n \t}\n@@ -1301,7 +1305,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       // We allocate one extra bucket to hold a sentinel, an arbitrary\n       // non-null pointer.  Iterator increment relies on this.\n-      node** p = alloc.allocate(n+1);\n+      node** p = alloc.allocate(n + 1);\n       std::fill(p, p+n, (node*) 0);\n       p[n] = reinterpret_cast<node*>(0x1000);\n       return p;\n@@ -1328,7 +1332,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t      const H1& h1, const H2& h2, const H& h,\n \t      const Eq& eq, const Ex& exk,\n \t      const allocator_type& a)\n-    : Internal::rehash_base<RP,hashtable>(),\n+    : Internal::rehash_base<RP, hashtable>(),\n       Internal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c>(exk, eq, h1, h2, h),\n       Internal::map_base<K, V, Ex, u, hashtable>(),\n       m_node_allocator(a),\n@@ -1351,10 +1355,10 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\tconst H1& h1, const H2& h2, const H& h,\n \t\tconst Eq& eq, const Ex& exk,\n \t\tconst allocator_type& a)\n-      : Internal::rehash_base<RP,hashtable>(),\n+      : Internal::rehash_base<RP, hashtable>(),\n \tInternal::hash_code_base<K, V, Ex, Eq, H1, H2, H, c> (exk, eq,\n \t\t\t\t\t\t\t      h1, h2, h),\n-\tInternal::map_base<K,V,Ex,u,hashtable>(),\n+\tInternal::map_base<K, V, Ex, u, hashtable>(),\n \tm_node_allocator(a),\n \tm_bucket_count (0),\n \tm_element_count(0),\n@@ -1408,7 +1412,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t\t}\n \t    }\n \t}\n-      catch (...)\n+      catch(...)\n \t{\n \t  clear();\n \t  m_deallocate_buckets (m_buckets, m_bucket_count);\n@@ -1475,7 +1479,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       m_rehash_policy = pol;\n       size_type n_bkt = pol.bkt_for_elements(m_element_count);\n       if (n_bkt > m_bucket_count)\n-\tm_rehash (n_bkt);\n+\tm_rehash(n_bkt);\n     }\n \n   template<typename K, typename V, \n@@ -1517,7 +1521,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n       std::size_t n = this->bucket_index(k, code, this->bucket_count());\n       size_t result = 0;\n-      for (node* p = m_buckets[n]; p ; p = p->m_next)\n+      for (node* p = m_buckets[n]; p; p = p->m_next)\n \tif (this->compare(k, code, p))\n \t  ++result;\n       return result;\n@@ -1542,8 +1546,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       if (p)\n \t{\n \t  node* p1 = p->m_next;\n-\t  for (; p1 ; p1 = p1->m_next)\n-\t    if (!this->compare (k, code, p1))\n+\t  for (; p1; p1 = p1->m_next)\n+\t    if (!this->compare(k, code, p1))\n \t      break;\n \n \t  iterator first(p, head);\n@@ -1575,7 +1579,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       if (p)\n \t{\n \t  node* p1 = p->m_next;\n-\t  for (; p1 ; p1 = p1->m_next)\n+\t  for (; p1; p1 = p1->m_next)\n \t    if (!this->compare(k, code, p1))\n \t      break;\n \n@@ -1600,8 +1604,8 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     find_node(node* p, const key_type& k,\n \t      typename hashtable::hash_code_t code) const\n     {\n-      for ( ; p ; p = p->m_next)\n-\tif (this->compare (k, code, p))\n+      for (; p ; p = p->m_next)\n+\tif (this->compare(k, code, p))\n \t  return p;\n       return false;\n     }\n@@ -1628,7 +1632,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \n       // Allocate the new node before doing the rehash so that we don't\n       // do a rehash if the allocation throws.\n-      node* new_node = m_allocate_node (v);\n+      node* new_node = m_allocate_node(v);\n       \n       try\n \t{\n@@ -1644,9 +1648,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t  ++m_element_count;\n \t  return std::make_pair(iterator(new_node, m_buckets + n), true);\n \t}\n-      catch (...)\n+      catch(...)\n \t{\n-\t  m_deallocate_node (new_node);\n+\t  m_deallocate_node(new_node);\n \t  __throw_exception_again;\n \t}\n     }\n@@ -1669,7 +1673,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n       size_type n = this->bucket_index(k, code, m_bucket_count);\n       \n-      node* new_node = m_allocate_node (v);\n+      node* new_node = m_allocate_node(v);\n       node* prev = find_node(m_buckets[n], k, code);\n       if (prev)\n \t{\n@@ -1710,7 +1714,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t  cur->m_next = next->m_next;\n \t}\n \n-      m_deallocate_node (p);\n+      m_deallocate_node(p);\n       --m_element_count;\n     }\n \n@@ -1730,7 +1734,7 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t  m_rehash(do_rehash.second);\n \n \tfor (; first != last; ++first)\n-\t  this->insert (*first);\n+\t  this->insert(*first);\n       }\n \n   template<typename K, typename V, \n@@ -1774,14 +1778,14 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       size_type result = 0;\n       \n       node** slot = m_buckets + n;\n-      while (*slot && ! this->compare(k, code, *slot))\n+      while (*slot && !this->compare(k, code, *slot))\n \tslot = &((*slot)->m_next);\n \n       while (*slot && this->compare(k, code, *slot))\n \t{\n \t  node* n = *slot;\n \t  *slot = n->m_next;\n-\t  m_deallocate_node (n);\n+\t  m_deallocate_node(n);\n \t  --m_element_count;\n \t  ++result;\n \t}\n@@ -1838,13 +1842,13 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n     m_rehash(size_type N)\n     {\n-      node** new_array = m_allocate_buckets (N);\n+      node** new_array = m_allocate_buckets(N);\n       try\n \t{\n \t  for (size_type i = 0; i < m_bucket_count; ++i)\n \t    while (node* p = m_buckets[i])\n \t      {\n-\t\tsize_type new_index = this->bucket_index (p, N);\n+\t\tsize_type new_index = this->bucket_index(p, N);\n \t\tm_buckets[i] = p->m_next;\n \t\tp->m_next = new_array[new_index];\n \t\tnew_array[new_index] = p;"}]}