{"sha": "1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWM0YTQyOWFiMDliNDYxMDBjZDRiMDQ0NGU2ZDVlMmU4NDcyZTcyMQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2003-02-22T10:02:31Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2003-02-22T10:02:31Z"}, "message": "expmed.c (expand_divmod): Undo sign extensions for unsigned operands\n\n\t* expmed.c (expand_divmod): Undo sign extensions for unsigned operands\n\n\t* cfgcleanup.c (try_forward_edges):  Don't check loop structures\n\twhen not optimizing.\n\t(cleanup_cfg): Do not iterate trought delete_trivially_dead_insns\n\twhen not expensive.\n\t* toplev.c (rest_of_compilation):  Duplicate loop headers only when\n\toptimizing;  Delete trivially dead insns early; fix optimize check.\n\n\t* Makefile.in (c-decl.o, c-objc-common.o, cgraph.o, tree-inline.o): Add\n\tdependency on cgraph.h\n\t* c-decl.c: Include cgraph.h\n\t(finish_function): Update call of tree_inlinable_function_p.\n\t* c-objc-common.c: Include cgraph.h\n\t* cgraph.h: New file.\n\t* cgraphunit.c: New file.\n\t* cgraph.c (cgraph_node, cgraph_edge): Move into cgraph.h\n\t(cgraph_nodes, cgraph_n_nodes): Globalize.\n\t(cgraph_finalize_function, cgraph_finalize_compilation_unit\n\tcgraph_create_edges, cgraph_optimize, cgraph_mark_needed_node):\n\tMove into cgraphunit.c\n\t* tree-inline.c: Include cgraph.h\n\t* tree-inline.c: Include cgraph.h\n\nFrom-SVN: r63281", "tree": {"sha": "257ede1e5a0927db4b10d7b84ff244d229c10cd4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/257ede1e5a0927db4b10d7b84ff244d229c10cd4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/comments", "author": null, "committer": null, "parents": [{"sha": "1e2115dcc04ef844f63f22923b83439bcbf31b1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2115dcc04ef844f63f22923b83439bcbf31b1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2115dcc04ef844f63f22923b83439bcbf31b1c"}], "stats": {"total": 905, "additions": 506, "deletions": 399}, "files": [{"sha": "59050a52dbd031f18d3cf6cf1b276d995031fbeb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -1,3 +1,29 @@\n+Sat Feb 22 03:13:36 CET 2003  Jan Hubicka  <jh@suse.cz>\n+\n+\t* expmed.c (expand_divmod): Undo sign extensions for unsigned operands\n+\n+\t* cfgcleanup.c (try_forward_edges):  Don't check loop structures\n+\twhen not optimizing.\n+\t(cleanup_cfg): Do not iterate trought delete_trivially_dead_insns\n+\twhen not expensive.\n+\t* toplev.c (rest_of_compilation):  Duplicate loop headers only when\n+\toptimizing;  Delete trivially dead insns early; fix optimize check.\n+\n+\t* Makefile.in (c-decl.o, c-objc-common.o, cgraph.o, tree-inline.o): Add\n+\tdependency on cgraph.h\n+\t* c-decl.c: Include cgraph.h\n+\t(finish_function): Update call of tree_inlinable_function_p.\n+\t* c-objc-common.c: Include cgraph.h\n+\t* cgraph.h: New file.\n+\t* cgraphunit.c: New file.\n+\t* cgraph.c (cgraph_node, cgraph_edge): Move into cgraph.h\n+\t(cgraph_nodes, cgraph_n_nodes): Globalize.\n+\t(cgraph_finalize_function, cgraph_finalize_compilation_unit\n+\tcgraph_create_edges, cgraph_optimize, cgraph_mark_needed_node):\n+\tMove into cgraphunit.c\n+\t* tree-inline.c: Include cgraph.h\n+\t* tree-inline.c: Include cgraph.h\n+\n 2003-02-22  Josef Zlomek  <zlomekj@suse.cz>\n \n \t* config/i386/i386.md: Use gen_lowpart instead of gen_rtx_REG"}, {"sha": "271f3e040a7de9782752aa38e751ebbe0694d92c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -785,7 +785,7 @@ OBJS = alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t   \\\n  sibcall.o simplify-rtx.o sreal.o ssa.o ssa-ccp.o ssa-dce.o stmt.o\t   \\\n  stor-layout.o stringpool.o timevar.o toplev.o tracer.o tree.o tree-dump.o \\\n  tree-inline.o unroll.o varasm.o varray.o version.o vmsdbgout.o xcoffout.o \\\n- alloc-pool.o et-forest.o cgraph.o\t\t\t\t\t   \\\n+ alloc-pool.o et-forest.o cgraph.o cgraphunit.o\t\t\t\t   \\\n  $(GGC) $(out_object_file) $(EXTRA_OBJS) $(host_hook_obj)\n \n BACKEND = main.o libbackend.a\n@@ -1221,7 +1221,7 @@ $(parsedir)/c-parse.y: c-parse.in\n c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H) \\\n     $(C_TREE_H) $(GGC_H) $(TARGET_H) flags.h function.h output.h $(EXPR_H) \\\n     debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) c-pragma.h \\\n-    gt-c-decl.h\n+    gt-c-decl.h cgraph.h\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n     $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H)\n c-lang.o : c-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n@@ -1233,7 +1233,7 @@ c-lex.o : c-lex.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_H)\n c-objc-common.o : c-objc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(C_TREE_H) $(RTL_H) insn-config.h integrate.h $(EXPR_H) $(C_TREE_H) \\\n     flags.h toplev.h tree-inline.h diagnostic.h integrate.h $(VARRAY_H) \\\n-    langhooks.h $(GGC_H) gt-c-objc-common.h $(TARGET_H)\n+    langhooks.h $(GGC_H) gt-c-objc-common.h $(TARGET_H) cgraph.h\n c-aux-info.o : c-aux-info.c  $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(C_TREE_H) flags.h toplev.h\n c-convert.o : c-convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -1413,7 +1413,7 @@ tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(RTL_H) expr.h flags.h params.h input.h insn-config.h $(INTEGRATE_H) \\\n    $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h langhooks.h \\\n-   $(C_COMMON_H) tree-inline.h\n+   $(C_COMMON_H) tree-inline.h cgraph.h\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(GGC_H) langhooks.h real.h\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n@@ -1532,7 +1532,9 @@ simplify-rtx.o : simplify-rtx.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RT\n    $(REGS_H) hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h $(GGC_H) $(OBSTACK_H) $(TM_P_H) $(TREE_H) $(TARGET_H)\n cgraph.o : cgraph.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   langhooks.h tree-inline.h toplev.h flags.h ggc.h  $(TARGET_H)\n+   langhooks.h tree-inline.h toplev.h flags.h ggc.h  $(TARGET_H) cgraph.h\n+cgraphunit.o : cgraphunit.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n+   langhooks.h tree-inline.h toplev.h flags.h ggc.h  $(TARGET_H) cgraph.h\n cselib.o : cselib.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(RECOG_H) $(EXPR_H) toplev.h \\\n    output.h function.h cselib.h $(GGC_H) $(TM_P_H) gt-cselib.h"}, {"sha": "df3390c2121872e5d845a8a239e51a2fc4d0c1f5", "filename": "gcc/c-decl.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -48,6 +48,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"timevar.h\"\n #include \"c-common.h\"\n #include \"c-pragma.h\"\n+#include \"cgraph.h\"\n \n /* In grokdeclarator, distinguish syntactic contexts of declarators.  */\n enum decl_context"}, {"sha": "4ef748ca44ac4d5f3346eb4103e96d53ad06e857", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -37,6 +37,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n+#include \"cgraph.h\"\n \n static bool c_tree_printer PARAMS ((output_buffer *, text_info *));\n static tree inline_forbidden_p PARAMS ((tree *, int *, void *));"}, {"sha": "eaefdf2e381da13f70048e91eca6cbab3f771014", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -502,7 +502,7 @@ try_forward_edges (mode, b)\n \t     For fallthru forwarders, the LOOP_BEG note must appear between\n \t     the header of block and CODE_LABEL of the loop, for non forwarders\n \t     it must appear before the JUMP_INSN.  */\n-\t  if (mode & CLEANUP_PRE_LOOP)\n+\t  if ((mode & CLEANUP_PRE_LOOP) && optimize)\n \t    {\n \t      rtx insn = (target->succ->flags & EDGE_FALLTHRU\n \t\t\t  ? target->head : prev_nonnote_insn (target->end));\n@@ -1795,6 +1795,7 @@ cleanup_cfg (mode)\n \t    break;\n \t}\n       else if (!(mode & (CLEANUP_NO_INSN_DEL | CLEANUP_PRE_SIBCALL))\n+\t       && (mode & CLEANUP_EXPENSIVE)\n \t       && !reload_completed)\n \t{\n \t  if (!delete_trivially_dead_insns (get_insns(), max_reg_num ()))"}, {"sha": "7df18f148911e5a3895645477f8c271800ee4179", "filename": "gcc/cgraph.c", "status": "modified", "additions": 6, "deletions": 371, "changes": 377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -32,67 +32,22 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"debug.h\"\n #include \"target.h\"\n-\n-/* The cgraph data strutcture.\n-   Each function decl has assigned cgraph_node listing calees and callers.  */\n-\n-struct cgraph_node\n-{\n-  tree decl;\n-  struct cgraph_edge *callees;\n-  struct cgraph_edge *callers;\n-  struct cgraph_node *next;\n-  /* For nested functions points to function the node is nested in.  */\n-  struct cgraph_node *origin;\n-  /* Points to first nested function, if any.  */\n-  struct cgraph_node *nested;\n-  /* Pointer to the next function with same origin, if any.  */\n-  struct cgraph_node *next_nested;\n-  void *aux;\n-\n-  /* Set when function must be output - it is externally visible\n-     or it's address is taken.  */\n-  bool needed;\n-  /* Set when function is reachable by call from other function\n-     that is eighter reachable or needed.  */\n-  bool reachable;\n-  /* Set when the frontend has been asked to lower representation of this\n-     function into trees.  Callees lists are not available when lowered\n-     is not set.  */\n-  bool lowered;\n-  /* Set when function is scheduled to be assembled.  */\n-  bool output;\n-};\n-\n-struct cgraph_edge\n-{\n-  struct cgraph_node *caller, *callee;\n-  struct cgraph_edge *next_caller;\n-  struct cgraph_edge *next_callee;\n-};\n+#include \"cgraph.h\"\n \n /* Hash table used to convert declarations into nodes.  */\n static htab_t cgraph_hash = 0;\n \n /* The linked list of cgraph nodes.  */\n-static struct cgraph_node *cgraph_nodes;\n+struct cgraph_node *cgraph_nodes;\n \n /* Number of nodes in existence.  */\n-static int cgraph_n_nodes;\n+int cgraph_n_nodes;\n \n-static struct cgraph_node *cgraph_node PARAMS ((tree decl));\n static struct cgraph_edge *create_edge PARAMS ((struct cgraph_node *,\n \t\t\t\t\t\tstruct cgraph_node *));\n static void remove_edge PARAMS ((struct cgraph_node *, struct cgraph_node *));\n-static struct cgraph_edge *record_call PARAMS ((tree, tree));\n-static tree record_call_1 PARAMS ((tree *, int *, void *));\n static hashval_t hash_node PARAMS ((const PTR));\n static int eq_node PARAMS ((const PTR, const PTR));\n-static struct cgraph_node *cgraph_node PARAMS ((tree));\n-static void cgraph_expand_functions PARAMS ((void));\n-static void cgraph_mark_functions_to_output PARAMS ((void));\n-static void cgraph_expand_function PARAMS ((struct cgraph_node *));\n-static void cgraph_mark_needed_node PARAMS ((struct cgraph_node *, int));\n \n /* Returns a hash code for P.  */\n \n@@ -117,7 +72,7 @@ eq_node (p1, p2)\n }\n \n /* Return cgraph node assigned to DECL.  Create new one when needed.  */\n-static struct cgraph_node *\n+struct cgraph_node *\n cgraph_node (decl)\n      tree decl;\n {\n@@ -190,8 +145,8 @@ remove_edge (caller, callee)\n \n /* Record call from CALLER to CALLEE  */\n \n-static struct cgraph_edge *\n-record_call (caller, callee)\n+struct cgraph_edge *\n+cgraph_record_call (caller, callee)\n      tree caller, callee;\n {\n   return create_edge (cgraph_node (caller), cgraph_node (callee));\n@@ -220,66 +175,6 @@ cgraph_calls_p (caller_decl, callee_decl)\n   return edge != NULL;\n }\n \n-/* Walk tree and record all calls.  Called via walk_tree.  */\n-static tree\n-record_call_1 (tp, walk_subtrees, data)\n-     tree *tp;\n-     int *walk_subtrees;\n-     void *data;\n-{\n-  /* Record dereferences to the functions.  This makes the functions\n-     reachable unconditionally.  */\n-  if (TREE_CODE (*tp) == ADDR_EXPR)\n-    {\n-      tree decl = TREE_OPERAND (*tp, 0);\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-        cgraph_mark_needed_node (cgraph_node (decl), 1);\n-    }\n-  else if (TREE_CODE (*tp) == CALL_EXPR)\n-    {\n-      tree decl = TREE_OPERAND (*tp, 0);\n-      if (TREE_CODE (decl) == ADDR_EXPR)\n-\tdecl = TREE_OPERAND (decl, 0);\n-      if (TREE_CODE (decl) == FUNCTION_DECL)\n-\t{\n-\t  if (DECL_BUILT_IN (decl))\n-\t    return NULL;\n-\t  record_call (data, decl);\n-\t  walk_tree (&TREE_OPERAND (*tp, 1), record_call_1, data, NULL);\n-\t  *walk_subtrees = 0;\n-\t}\n-    }\n-  return NULL;\n-}\n-\n-/* Create cgraph edges for function calles via BODY.  */\n-\n-void\n-cgraph_create_edges (decl, body)\n-     tree decl;\n-     tree body;\n-{\n-  walk_tree (&body, record_call_1, decl, NULL);\n-}\n-\n-/* Analyze function once it is parsed.  Set up the local information\n-   available - create cgraph edges for function calles via BODY.  */\n-\n-void\n-cgraph_finalize_function (decl, body)\n-     tree decl;\n-     tree body ATTRIBUTE_UNUSED;\n-{\n-  struct cgraph_node *node = cgraph_node (decl);\n-\n-  node->decl = decl;\n-\n-  /* Set TREE_UNINLINABLE flag.  */\n-  tree_inlinable_function_p (decl);\n-\n-  (*debug_hooks->deferred_inline_function) (decl);\n-}\n-\n /* Dump the callgraph.  */\n \n void\n@@ -315,263 +210,3 @@ dump_cgraph (f)\n       fprintf (f, \"\\n\");\n     }\n }\n-\n-static struct cgraph_node *queue = NULL;\n-\n-/* Notify finalize_compilation_unit that given node is reachable\n-   or needed.  */\n-static void\n-cgraph_mark_needed_node (node, needed)\n-     struct cgraph_node *node;\n-     int needed;\n-{\n-  if (needed)\n-    {\n-      if (DECL_SAVED_TREE (node->decl))\n-        announce_function (node->decl);\n-      node->needed = 1;\n-    }\n-  if (!node->reachable)\n-    {\n-      node->reachable = 1;\n-      if (DECL_SAVED_TREE (node->decl))\n-\t{\n-\t  node->aux = queue;\n-\t  queue = node;\n-        }\n-    }\n-}\n-\n-/* Analyze the whole compilation unit once it is parsed completely.  */\n-\n-void\n-cgraph_finalize_compilation_unit ()\n-{\n-  struct cgraph_node *node;\n-  struct cgraph_edge *edge;\n-\n-  /* Collect entry points to the unit.  */\n-\n-  if (!quiet_flag)\n-    fprintf (stderr, \"\\n\\nUnit entry points:\");\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      tree decl = node->decl;\n-\n-      if (!DECL_SAVED_TREE (decl))\n-\tcontinue;\n-      if ((TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n-\t  || (DECL_ASSEMBLER_NAME_SET_P (decl)\n-\t      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n-\t{\n-          cgraph_mark_needed_node (node, 1);\n-\t}\n-    }\n-\n-  /*  Propagate reachability flag and lower representation of all reachable\n-      functions.  In the future, lowering will introduce new functions and\n-      new entry points on the way (by template instantiation and virtual\n-      method table generation for instance).  */\n-  while (queue)\n-    {\n-      tree decl = queue->decl;\n-\n-      node = queue;\n-      queue = queue->aux;\n-      if (node->lowered || !node->reachable || !DECL_SAVED_TREE (decl))\n-\tabort ();\n-\n-      /* At the moment frontend automatically emits all nested functions.  */\n-      if (node->nested)\n-\t{\n-\t  struct cgraph_node *node2;\n-\n-\t  for (node2 = node->nested; node2; node2 = node2->next_nested)\n-\t    if (!node2->reachable)\n-\t      cgraph_mark_needed_node (node2, 0);\n-\t}\n-\n-      if (lang_hooks.callgraph.lower_function)\n-\t(*lang_hooks.callgraph.lower_function) (decl);\n-      /* First kill forward declaration so reverse inling works properly.  */\n-      cgraph_create_edges (decl, DECL_SAVED_TREE (decl));\n-\n-      for (edge = node->callees; edge; edge = edge->next_callee)\n-\t{\n-\t  if (!edge->callee->reachable)\n-            cgraph_mark_needed_node (edge->callee, 0);\n-\t}\n-      node->lowered = true;\n-    }\n-  if (!quiet_flag)\n-    fprintf (stderr, \"\\n\\nReclaiming functions:\");\n-\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      tree decl = node->decl;\n-\n-      if (!node->reachable && DECL_SAVED_TREE (decl))\n-\t{\n-\t  DECL_SAVED_TREE (decl) = NULL;\n-\t  announce_function (decl);\n-\t}\n-    }\n-  ggc_collect ();\n-}\n-\n-/* Figure out what functions we want to assemble.  */\n-\n-static void\n-cgraph_mark_functions_to_output ()\n-{\n-  struct cgraph_node *node;\n-\n-  /* Figure out functions we want to assemble.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    {\n-      tree decl = node->decl;\n-\n-      if (DECL_SAVED_TREE (decl)\n-\t  && (node->needed\n-\t      || (DECL_UNINLINABLE (decl) && node->reachable)\n-\t      || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n-\t  && !TREE_ASM_WRITTEN (decl) && !node->origin\n-\t  && !DECL_EXTERNAL (decl))\n-\tnode->output = 1;\n-    }\n-}\n-\n-/* Expand function specified by NODE.  */\n-static void\n-cgraph_expand_function (node)\n-     struct cgraph_node *node;\n-{\n-  tree decl = node->decl;\n-\n-  announce_function (decl);\n-  if (flag_inline_trees)\n-    optimize_inline_calls (decl);\n-  (*lang_hooks.callgraph.expand_function) (decl);\n-  if (DECL_UNINLINABLE (decl))\n-    DECL_SAVED_TREE (decl) = NULL;\n-  current_function_decl = NULL;\n-}\n-\n-\n-/* Expand all functions that must be output. \n-  \n-   Attempt to topologically sort the nodes so function is output when\n-   all called functions are already assembled to allow data to be propagated\n-   accross the callgraph.  Use stack to get smaller distance between function\n-   and it's callees (later we may use more sophisticated algorithm for\n-   function reordering, we will likely want to use subsections to make output\n-   functions to appear in top-down order, not bottom-up they are assembled).  */\n-\n-static void\n-cgraph_expand_functions ()\n-{\n-  struct cgraph_node *node, *node2;\n-  struct cgraph_node **stack =\n-    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n-  struct cgraph_node **order =\n-    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n-  int stack_size = 0;\n-  int order_pos = 0;\n-  struct cgraph_edge *edge, last;\n-  int i;\n-\n-  cgraph_mark_functions_to_output ();\n-\n-  /*  We have to deal with cycles nicely, so use depth first traversal\n-      algorithm.  Ignore the fact that some functions won't need to be output\n-      and put them into order as well, so we get dependencies right trought inlined\n-      functions.  */\n-  for (node = cgraph_nodes; node; node = node->next)\n-    node->aux = NULL;\n-  for (node = cgraph_nodes; node; node = node->next)\n-    if (node->output && !node->aux)\n-      {\n-\tnode2 = node;\n-\tif (!node->callers)\n-\t  node->aux = &last;\n-\telse\n-\t  node->aux = node->callers;\n-\twhile (node2)\n-\t  {\n-\t    while (node2->aux != &last)\n-\t      {\n-\t\tedge = node2->aux;\n-\t\tif (edge->next_caller)\n-\t\t  node2->aux = edge->next_caller;\n-\t\telse\n-\t\t  node2->aux = &last;\n-\t\tif (!edge->caller->aux)\n-\t\t  {\n-\t\t    if (!edge->caller->callers)\n-\t\t      edge->caller->aux = &last;\n-\t\t    else\n-\t\t      edge->caller->aux = edge->caller->callers;\n-\t\t    stack[stack_size++] = node2;\n-\t\t    node2 = edge->caller;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    if (node2->aux == &last)\n-\t      {\n-\t\torder[order_pos++] = node2;\n-\t\tif (stack_size)\n-\t\t  node2 = stack[--stack_size];\n-\t\telse\n-\t\t  node2 = NULL;\n-\t      }\n-\t  }\n-      }\n-  for (i = order_pos - 1; i >=0; i--)\n-    {\n-      node = order[i];\n-      if (node->output)\n-\t{\n-\t  if (!node->reachable)\n-\t    abort ();\n-\t  node->output = 0;\n-\t  cgraph_expand_function (node);\n-\t}\n-    }\n-  free (stack);\n-  free (order);\n-}\n-\n-/* Perform simple optimizations based on callgraph.  */\n-\n-void\n-cgraph_optimize ()\n-{\n-  struct cgraph_node *node;\n-  bool changed = true;\n-  struct cgraph_edge *edge;\n-\n-  if (!quiet_flag)\n-    fprintf (stderr, \"\\n\\nAssembling functions:\");\n-\n-  /* Output everything.  \n-     ??? Our inline heuristic may decide to not inline functions previously\n-     marked as inlinable thus adding new function bodies that must be output.\n-     Later we should move all inlining decisions to callgraph code to make\n-     this impossible.  */\n-  cgraph_expand_functions ();\n-  while (changed)\n-    {\n-      changed = false;\n-      for (node = cgraph_nodes; node; node = node->next)\n-\t{\n-\t  if (!node->needed)\n-\t    continue;\n-\n-\t  for (edge = node->callees; edge; edge = edge->next_callee)\n-\t    if (!edge->callee->needed)\n-\t      changed = edge->callee->needed = true;\n-\t}\n-    }\n-  cgraph_expand_functions ();\n-}"}, {"sha": "8dd37ed9e32e351f17377887e2c5cf4e3535ad47", "filename": "gcc/cgraph.h", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -0,0 +1,80 @@\n+/* Callgraph handling code.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef GCC_CGRAPH_H\n+#define GCC_CGRAPH_H\n+\n+/* The cgraph data strutcture.\n+   Each function decl has assigned cgraph_node listing calees and callers.  */\n+\n+struct cgraph_node\n+{\n+  tree decl;\n+  struct cgraph_edge *callees;\n+  struct cgraph_edge *callers;\n+  struct cgraph_node *next;\n+  /* For nested functions points to function the node is nested in.  */\n+  struct cgraph_node *origin;\n+  /* Points to first nested function, if any.  */\n+  struct cgraph_node *nested;\n+  /* Pointer to the next function with same origin, if any.  */\n+  struct cgraph_node *next_nested;\n+  void *aux;\n+\n+  /* Set when function must be output - it is externally visible\n+     or it's address is taken.  */\n+  bool needed;\n+  /* Set when function is reachable by call from other function\n+     that is eighter reachable or needed.  */\n+  bool reachable;\n+  /* Set when the frontend has been asked to lower representation of this\n+     function into trees.  Callees lists are not available when lowered\n+     is not set.  */\n+  bool lowered;\n+  /* Set when function is scheduled to be assembled.  */\n+  bool output;\n+};\n+\n+struct cgraph_edge\n+{\n+  struct cgraph_node *caller, *callee;\n+  struct cgraph_edge *next_caller;\n+  struct cgraph_edge *next_callee;\n+};\n+\n+extern struct cgraph_node *cgraph_nodes;\n+extern int cgraph_n_nodes;\n+\n+/* In cgraph.c  */\n+void dump_cgraph\t\t\tPARAMS ((FILE *));\n+void cgraph_remove_call\t\t\tPARAMS ((tree, tree));\n+struct cgraph_edge *cgraph_record_call\tPARAMS ((tree, tree));\n+struct cgraph_node *cgraph_node\t\tPARAMS ((tree decl));\n+bool cgraph_calls_p\t\t\tPARAMS ((tree, tree));\n+\n+/* In cgraphunit.c  */\n+void cgraph_finalize_function\t\tPARAMS ((tree, tree));\n+void cgraph_finalize_compilation_unit\tPARAMS ((void));\n+void cgraph_create_edges\t\tPARAMS ((tree, tree));\n+void cgraph_optimize\t\t\tPARAMS ((void));\n+void cgraph_mark_needed_node\t\tPARAMS ((struct cgraph_node *, int));\n+\n+#endif  /* GCC_CGRAPH_H  */"}, {"sha": "0a12ddad8563fba8252821e9cd51ebac3c2e5f0c", "filename": "gcc/cgraphunit.c", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -0,0 +1,360 @@\n+/* Callgraph handling code.\n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+   Contributed by Jan Hubicka\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"tree-inline.h\"\n+#include \"langhooks.h\"\n+#include \"hashtab.h\"\n+#include \"toplev.h\"\n+#include \"flags.h\"\n+#include \"ggc.h\"\n+#include \"debug.h\"\n+#include \"target.h\"\n+#include \"cgraph.h\"\n+\n+static void cgraph_expand_functions PARAMS ((void));\n+static void cgraph_mark_functions_to_output PARAMS ((void));\n+static void cgraph_expand_function PARAMS ((struct cgraph_node *));\n+static tree record_call_1 PARAMS ((tree *, int *, void *));\n+\n+/* Analyze function once it is parsed.  Set up the local information\n+   available - create cgraph edges for function calles via BODY.  */\n+\n+void\n+cgraph_finalize_function (decl, body)\n+     tree decl;\n+     tree body ATTRIBUTE_UNUSED;\n+{\n+  struct cgraph_node *node = cgraph_node (decl);\n+\n+  node->decl = decl;\n+\n+  /* Set TREE_UNINLINABLE flag.  */\n+  tree_inlinable_function_p (decl);\n+\n+  (*debug_hooks->deferred_inline_function) (decl);\n+}\n+\n+static struct cgraph_node *queue = NULL;\n+\n+/* Notify finalize_compilation_unit that given node is reachable\n+   or needed.  */\n+void\n+cgraph_mark_needed_node (node, needed)\n+     struct cgraph_node *node;\n+     int needed;\n+{\n+  if (needed)\n+    {\n+      if (DECL_SAVED_TREE (node->decl))\n+        announce_function (node->decl);\n+      node->needed = 1;\n+    }\n+  if (!node->reachable)\n+    {\n+      node->reachable = 1;\n+      if (DECL_SAVED_TREE (node->decl))\n+\t{\n+\t  node->aux = queue;\n+\t  queue = node;\n+        }\n+    }\n+}\n+\n+/* Walk tree and record all calls.  Called via walk_tree.  */\n+static tree\n+record_call_1 (tp, walk_subtrees, data)\n+     tree *tp;\n+     int *walk_subtrees;\n+     void *data;\n+{\n+  /* Record dereferences to the functions.  This makes the functions\n+     reachable unconditionally.  */\n+  if (TREE_CODE (*tp) == ADDR_EXPR)\n+    {\n+      tree decl = TREE_OPERAND (*tp, 0);\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+        cgraph_mark_needed_node (cgraph_node (decl), 1);\n+    }\n+  else if (TREE_CODE (*tp) == CALL_EXPR)\n+    {\n+      tree decl = TREE_OPERAND (*tp, 0);\n+      if (TREE_CODE (decl) == ADDR_EXPR)\n+\tdecl = TREE_OPERAND (decl, 0);\n+      if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t{\n+\t  if (DECL_BUILT_IN (decl))\n+\t    return NULL;\n+\t  cgraph_record_call (data, decl);\n+\t  walk_tree (&TREE_OPERAND (*tp, 1), record_call_1, data, NULL);\n+\t  *walk_subtrees = 0;\n+\t}\n+    }\n+  return NULL;\n+}\n+\n+/* Create cgraph edges for function calles via BODY.  */\n+\n+void\n+cgraph_create_edges (decl, body)\n+     tree decl;\n+     tree body;\n+{\n+  walk_tree (&body, record_call_1, decl, NULL);\n+}\n+\n+/* Analyze the whole compilation unit once it is parsed completely.  */\n+\n+void\n+cgraph_finalize_compilation_unit ()\n+{\n+  struct cgraph_node *node;\n+  struct cgraph_edge *edge;\n+\n+  /* Collect entry points to the unit.  */\n+\n+  if (!quiet_flag)\n+    fprintf (stderr, \"\\n\\nUnit entry points:\");\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      tree decl = node->decl;\n+\n+      if (!DECL_SAVED_TREE (decl))\n+\tcontinue;\n+      if ((TREE_PUBLIC (decl) && !DECL_COMDAT (decl) && !DECL_EXTERNAL (decl))\n+\t  || (DECL_ASSEMBLER_NAME_SET_P (decl)\n+\t      && TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))))\n+\t{\n+          cgraph_mark_needed_node (node, 1);\n+\t}\n+    }\n+\n+  /*  Propagate reachability flag and lower representation of all reachable\n+      functions.  In the future, lowering will introduce new functions and\n+      new entry points on the way (by template instantiation and virtual\n+      method table generation for instance).  */\n+  while (queue)\n+    {\n+      tree decl = queue->decl;\n+\n+      node = queue;\n+      queue = queue->aux;\n+      if (node->lowered || !node->reachable || !DECL_SAVED_TREE (decl))\n+\tabort ();\n+\n+      /* At the moment frontend automatically emits all nested functions.  */\n+      if (node->nested)\n+\t{\n+\t  struct cgraph_node *node2;\n+\n+\t  for (node2 = node->nested; node2; node2 = node2->next_nested)\n+\t    if (!node2->reachable)\n+\t      cgraph_mark_needed_node (node2, 0);\n+\t}\n+\n+      if (lang_hooks.callgraph.lower_function)\n+\t(*lang_hooks.callgraph.lower_function) (decl);\n+      /* First kill forward declaration so reverse inling works properly.  */\n+      cgraph_create_edges (decl, DECL_SAVED_TREE (decl));\n+\n+      for (edge = node->callees; edge; edge = edge->next_callee)\n+\t{\n+\t  if (!edge->callee->reachable)\n+            cgraph_mark_needed_node (edge->callee, 0);\n+\t}\n+      node->lowered = true;\n+    }\n+  if (!quiet_flag)\n+    fprintf (stderr, \"\\n\\nReclaiming functions:\");\n+\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      tree decl = node->decl;\n+\n+      if (!node->reachable && DECL_SAVED_TREE (decl))\n+\t{\n+\t  DECL_SAVED_TREE (decl) = NULL;\n+\t  announce_function (decl);\n+\t}\n+    }\n+  ggc_collect ();\n+}\n+\n+/* Figure out what functions we want to assemble.  */\n+\n+static void\n+cgraph_mark_functions_to_output ()\n+{\n+  struct cgraph_node *node;\n+\n+  /* Figure out functions we want to assemble.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    {\n+      tree decl = node->decl;\n+\n+      if (DECL_SAVED_TREE (decl)\n+\t  && (node->needed\n+\t      || (DECL_UNINLINABLE (decl) && node->reachable)\n+\t      || TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl)))\n+\t  && !TREE_ASM_WRITTEN (decl) && !node->origin\n+\t  && !DECL_EXTERNAL (decl))\n+\tnode->output = 1;\n+    }\n+}\n+\n+/* Expand function specified by NODE.  */\n+static void\n+cgraph_expand_function (node)\n+     struct cgraph_node *node;\n+{\n+  tree decl = node->decl;\n+\n+  announce_function (decl);\n+  if (flag_inline_trees)\n+    optimize_inline_calls (decl);\n+  (*lang_hooks.callgraph.expand_function) (decl);\n+  if (DECL_UNINLINABLE (decl))\n+    DECL_SAVED_TREE (decl) = NULL;\n+  current_function_decl = NULL;\n+}\n+\n+\n+/* Expand all functions that must be output. \n+  \n+   Attempt to topologically sort the nodes so function is output when\n+   all called functions are already assembled to allow data to be propagated\n+   accross the callgraph.  Use stack to get smaller distance between function\n+   and it's callees (later we may use more sophisticated algorithm for\n+   function reordering, we will likely want to use subsections to make output\n+   functions to appear in top-down order, not bottom-up they are assembled).  */\n+\n+static void\n+cgraph_expand_functions ()\n+{\n+  struct cgraph_node *node, *node2;\n+  struct cgraph_node **stack =\n+    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+  struct cgraph_node **order =\n+    xcalloc (sizeof (struct cgraph_node *), cgraph_n_nodes);\n+  int stack_size = 0;\n+  int order_pos = 0;\n+  struct cgraph_edge *edge, last;\n+  int i;\n+\n+  cgraph_mark_functions_to_output ();\n+\n+  /*  We have to deal with cycles nicely, so use depth first traversal\n+      algorithm.  Ignore the fact that some functions won't need to be output\n+      and put them into order as well, so we get dependencies right trought inlined\n+      functions.  */\n+  for (node = cgraph_nodes; node; node = node->next)\n+    node->aux = NULL;\n+  for (node = cgraph_nodes; node; node = node->next)\n+    if (node->output && !node->aux)\n+      {\n+\tnode2 = node;\n+\tif (!node->callers)\n+\t  node->aux = &last;\n+\telse\n+\t  node->aux = node->callers;\n+\twhile (node2)\n+\t  {\n+\t    while (node2->aux != &last)\n+\t      {\n+\t\tedge = node2->aux;\n+\t\tif (edge->next_caller)\n+\t\t  node2->aux = edge->next_caller;\n+\t\telse\n+\t\t  node2->aux = &last;\n+\t\tif (!edge->caller->aux)\n+\t\t  {\n+\t\t    if (!edge->caller->callers)\n+\t\t      edge->caller->aux = &last;\n+\t\t    else\n+\t\t      edge->caller->aux = edge->caller->callers;\n+\t\t    stack[stack_size++] = node2;\n+\t\t    node2 = edge->caller;\n+\t\t    break;\n+\t\t  }\n+\t      }\n+\t    if (node2->aux == &last)\n+\t      {\n+\t\torder[order_pos++] = node2;\n+\t\tif (stack_size)\n+\t\t  node2 = stack[--stack_size];\n+\t\telse\n+\t\t  node2 = NULL;\n+\t      }\n+\t  }\n+      }\n+  for (i = order_pos - 1; i >=0; i--)\n+    {\n+      node = order[i];\n+      if (node->output)\n+\t{\n+\t  if (!node->reachable)\n+\t    abort ();\n+\t  node->output = 0;\n+\t  cgraph_expand_function (node);\n+\t}\n+    }\n+  free (stack);\n+  free (order);\n+}\n+\n+/* Perform simple optimizations based on callgraph.  */\n+\n+void\n+cgraph_optimize ()\n+{\n+  struct cgraph_node *node;\n+  bool changed = true;\n+  struct cgraph_edge *edge;\n+\n+  if (!quiet_flag)\n+    fprintf (stderr, \"\\n\\nAssembling functions:\");\n+\n+  /* Output everything.  \n+     ??? Our inline heuristic may decide to not inline functions previously\n+     marked as inlinable thus adding new function bodies that must be output.\n+     Later we should move all inlining decisions to callgraph code to make\n+     this impossible.  */\n+  cgraph_expand_functions ();\n+  while (changed)\n+    {\n+      changed = false;\n+      for (node = cgraph_nodes; node; node = node->next)\n+\t{\n+\t  if (!node->needed)\n+\t    continue;\n+\n+\t  for (edge = node->callees; edge; edge = edge->next_callee)\n+\t    if (!edge->callee->needed)\n+\t      changed = edge->callee->needed = true;\n+\t}\n+    }\n+  cgraph_expand_functions ();\n+}"}, {"sha": "09cd54ebb580293295f307d021eff82e2678dbda", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -22864,7 +22864,7 @@\n   \"@\n    movq\\t{%1, %0|%0, %1}\n    movdq2q\\t{%1, %0|%0, %1}\n-   movq\\t{%1, %0|%0, %1}\"\n+   movd\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssecvt\")\n    (set_attr \"mode\" \"TI\")])\n \n@@ -22887,7 +22887,7 @@\n   \"@\n    movq\\t{%1, %0|%0, %1}\n    movq2dq\\t{%1, %0|%0, %1}\n-   movq\\t{%1, %0|%0, %1}\"\n+   movd\\t{%1, %0|%0, %1}\"\n   [(set_attr \"type\" \"ssecvt,ssemov,ssecvt\")\n    (set_attr \"mode\" \"TI\")])\n "}, {"sha": "33d815280bf0c3bf0d32ece6f972bffd26387859", "filename": "gcc/expmed.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -2955,14 +2955,20 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n   int size;\n   rtx insn, set;\n   optab optab1, optab2;\n-  int op1_is_constant, op1_is_pow2;\n+  int op1_is_constant, op1_is_pow2 = 0;\n   int max_cost, extra_cost;\n   static HOST_WIDE_INT last_div_const = 0;\n+  static HOST_WIDE_INT ext_op1;\n \n   op1_is_constant = GET_CODE (op1) == CONST_INT;\n-  op1_is_pow2 = (op1_is_constant\n-\t\t && ((EXACT_POWER_OF_2_OR_ZERO_P (INTVAL (op1))\n-\t\t      || (! unsignedp && EXACT_POWER_OF_2_OR_ZERO_P (-INTVAL (op1))))));\n+  if (op1_is_constant)\n+    {\n+      ext_op1 = INTVAL (op1);\n+      if (unsignedp)\n+\text_op1 &= GET_MODE_MASK (mode);\n+      op1_is_pow2 = ((EXACT_POWER_OF_2_OR_ZERO_P (ext_op1)\n+\t\t     || (! unsignedp && EXACT_POWER_OF_2_OR_ZERO_P (-ext_op1))));\n+    }\n \n   /*\n      This is the structure of expand_divmod:\n@@ -3142,7 +3148,8 @@ expand_divmod (rem_flag, code, mode, op0, op1, target, unsignedp)\n \t\tunsigned HOST_WIDE_INT mh, ml;\n \t\tint pre_shift, post_shift;\n \t\tint dummy;\n-\t\tunsigned HOST_WIDE_INT d = INTVAL (op1);\n+\t\tunsigned HOST_WIDE_INT d = (INTVAL (op1)\n+\t\t\t\t\t    & GET_MODE_MASK (compute_mode));\n \n \t\tif (EXACT_POWER_OF_2_OR_ZERO_P (d))\n \t\t  {"}, {"sha": "acb98eec96b545899b9c40f45ec285c05e8359e0", "filename": "gcc/toplev.c", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -2697,16 +2697,19 @@ rest_of_compilation (decl)\n   reg_scan (insns, max_reg_num (), 0);\n   rebuild_jump_labels (insns);\n   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+  delete_trivially_dead_insns (insns, max_reg_num ());\n   if (rtl_dump_file)\n     dump_flow_info (rtl_dump_file);\n   cleanup_cfg ((optimize ? CLEANUP_EXPENSIVE : 0) | CLEANUP_PRE_LOOP\n \t       | (flag_thread_jumps ? CLEANUP_THREADING : 0));\n \n-  /* CFG is no longer maintained up-to-date.  */\n-  free_bb_for_insn ();\n-  copy_loop_headers (insns);\n+  if (optimize)\n+    {\n+      free_bb_for_insn ();\n+      copy_loop_headers (insns);\n+      find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n+    }\n   purge_line_number_notes (insns);\n-  find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n \n   timevar_pop (TV_JUMP);\n   close_dump_file (DFI_jump, print_rtl, insns);\n@@ -3052,7 +3055,7 @@ rest_of_compilation (decl)\n       close_dump_file (DFI_bp, print_rtl_with_bb, insns);\n       timevar_pop (TV_BRANCH_PROB);\n     }\n-  if (optimize >= 0)\n+  if (optimize > 0)\n     {\n       open_dump_file (DFI_ce1, decl);\n       if (flag_if_conversion)"}, {"sha": "71c4018d98f7455333412f764dbdbc4075f23249", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -37,6 +37,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"hashtab.h\"\n #include \"splay-tree.h\"\n #include \"langhooks.h\"\n+#include \"cgraph.h\"\n \n /* This should be eventually be generalized to other languages, but\n    this would require a shared function-as-trees infrastructure.  */"}, {"sha": "de9668b391851c3119b1a688285f96551c1eba81", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1c4a429ab09b46100cd4b0444e6d5e2e8472e721/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1c4a429ab09b46100cd4b0444e6d5e2e8472e721", "patch": "@@ -3157,16 +3157,6 @@ extern const char *dump_flag_name\tPARAMS ((enum tree_dump_index));\n /* Assign the RTX to declaration.  */\n \n extern void set_decl_rtl\t\tPARAMS ((tree, rtx));\n-\n-/* In callgraph.c  */\n-void cgraph_finalize_function\t\tPARAMS ((tree, tree));\n-void cgraph_finalize_compilation_unit\tPARAMS ((void));\n-void cgraph_create_edges\t\tPARAMS ((tree, tree));\n-void dump_cgraph\t\t\tPARAMS ((FILE *));\n-void cgraph_optimize\t\t\tPARAMS ((void));\n-void cgraph_remove_call\t\t\tPARAMS ((tree, tree));\n-bool cgraph_calls_p\t\t\tPARAMS ((tree, tree));\n-\n \f\n /* Redefine abort to report an internal error w/o coredump, and\n    reporting the location of the error in the source file.  This logic"}]}