{"sha": "8097203fc3a4cbd63b668dac627739abd2b40445", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA5NzIwM2ZjM2E0Y2JkNjNiNjY4ZGFjNjI3NzM5YWJkMmI0MDQ0NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-13T10:22:28Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2011-10-13T10:22:28Z"}, "message": "[multiple changes]\n\n2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch12.adb (Analyze_Formal_{Floating_Type,\n\tSigned_Integer_Type,  Decimal_Fixed_Point_Type, Discrete_Type}):\n\tUse sloc of defining identifier of farmal type declaration,\n\tas sloc of generated internal entity, to prevent misplaced\n\treferences in ali.\n\n2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_intr.adb (Check_Intrinsic_Operator): Check that type\n\tis fully defined before checking that it is a numeric type.\n\n2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_aggr.adb (Resolve_Record_Aggregate): If a component\n\tassociation for component X has a box, then X is covered in the\n\taggregate even if there is not default value for X in the type\n\tdeclaration, and X has to be default-initialized.\n\n2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_attr.adb (Check_Enum_Image, Analyze_Attribute case\n\t'Value): Mark literals as referenced only if reference is in\n\tcurrent source unit.\n\n2011-10-13  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-csquin.ads (Enque, Dequeue): Mark interface operations as entries.\n\n2011-10-13  Olivier Hainque  <hainque@adacore.com>\n\n\t* sigtramp.h: New file.  Prototype and spec of the signal\n\ttrampoline to be called by an established handler to provide\n\tdwarf call frame info before the real signal processing code.\n\t* sigtramp-ppcvxw.c: New file.\tImplementation of the signal\n\ttrampoline for ppc-vxworks.\n\t* init.c (vxworks section): Use it for ppc.\n\nFrom-SVN: r179899", "tree": {"sha": "55ac24cad2bc7f6de6233500cd26d00143a0d077", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/55ac24cad2bc7f6de6233500cd26d00143a0d077"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8097203fc3a4cbd63b668dac627739abd2b40445", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8097203fc3a4cbd63b668dac627739abd2b40445", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8097203fc3a4cbd63b668dac627739abd2b40445", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8097203fc3a4cbd63b668dac627739abd2b40445/comments", "author": null, "committer": null, "parents": [{"sha": "e192a2cd62f2ed824f93edab18d9a5aabf764784", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e192a2cd62f2ed824f93edab18d9a5aabf764784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e192a2cd62f2ed824f93edab18d9a5aabf764784"}], "stats": {"total": 430, "additions": 415, "deletions": 15}, "files": [{"sha": "7abe47af1555cd8dee18fadbb0179e1853be92b7", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=8097203fc3a4cbd63b668dac627739abd2b40445", "patch": "@@ -1,3 +1,42 @@\n+2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch12.adb (Analyze_Formal_{Floating_Type,\n+\tSigned_Integer_Type,  Decimal_Fixed_Point_Type, Discrete_Type}):\n+\tUse sloc of defining identifier of farmal type declaration,\n+\tas sloc of generated internal entity, to prevent misplaced\n+\treferences in ali.\n+\n+2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_intr.adb (Check_Intrinsic_Operator): Check that type\n+\tis fully defined before checking that it is a numeric type.\n+\n+2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_aggr.adb (Resolve_Record_Aggregate): If a component\n+\tassociation for component X has a box, then X is covered in the\n+\taggregate even if there is not default value for X in the type\n+\tdeclaration, and X has to be default-initialized.\n+\n+2011-10-13  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_attr.adb (Check_Enum_Image, Analyze_Attribute case\n+\t'Value): Mark literals as referenced only if reference is in\n+\tcurrent source unit.\n+\n+2011-10-13  Matthew Heaney  <heaney@adacore.com>\n+\n+\t* a-csquin.ads (Enque, Dequeue): Mark interface operations as entries.\n+\n+2011-10-13  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* sigtramp.h: New file.  Prototype and spec of the signal\n+\ttrampoline to be called by an established handler to provide\n+\tdwarf call frame info before the real signal processing code.\n+\t* sigtramp-ppcvxw.c: New file.\tImplementation of the signal\n+\ttrampoline for ppc-vxworks.\n+\t* init.c (vxworks section): Use it for ppc.\n+\n 2011-10-13  Thomas Quinot  <quinot@adacore.com>\n \n \t* par-ch2.adb, par.adb, par-util.adb, par-ch3.adb"}, {"sha": "7567444177e691d982428c16213cb5f4c5b09835", "filename": "gcc/ada/a-csquin.ads", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fa-csquin.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fa-csquin.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-csquin.ads?ref=8097203fc3a4cbd63b668dac627739abd2b40445", "patch": "@@ -42,12 +42,24 @@ package Ada.Containers.Synchronized_Queue_Interfaces is\n    procedure Enqueue\n      (Container : in out Queue;\n       New_Item  : Element_Type) is abstract;\n-   --  with Is_Synchronized => By_Entry;  ???\n+\n+   --  ???\n+   --  This is the official Ada 2012 syntax:\n+   --  with Synchronization => By_Entry;\n+\n+   --  This is the temporary work-around:\n+   pragma Implemented (Enqueue, By_Entry);\n \n    procedure Dequeue\n      (Container : in out Queue;\n       Element   : out Element_Type) is abstract;\n-   --  with Is_Synchronized => By_Entry;  ???\n+\n+   --  ???\n+   --  This is the official Ada 2012 syntax:\n+   --  with Synchronization => By_Entry;\n+\n+   --  This is the temporary work-around:\n+   pragma Implemented (Dequeue, By_Entry);\n \n    function Current_Use (Container : Queue) return Count_Type is abstract;\n "}, {"sha": "9b24395e8d452e8bb2fca5c2d8e409397a68cd89", "filename": "gcc/ada/init.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Finit.c?ref=8097203fc3a4cbd63b668dac627739abd2b40445", "patch": "@@ -1906,7 +1906,8 @@ __gnat_clear_exception_count (void)\n /* Handle different SIGnal to exception mappings in different VxWorks\n    versions.   */\n static void\n-__gnat_map_signal (int sig)\n+__gnat_map_signal (int sig, void *si ATTRIBUTE_UNUSED,\n+\t\t   struct sigcontext *sc ATTRIBUTE_UNUSED)\n {\n   struct Exception_Data *exception;\n   const char *msg;\n@@ -2001,9 +2002,7 @@ __gnat_map_signal (int sig)\n    propagation after the required low level adjustments.  */\n \n void\n-__gnat_error_handler (int sig,\n-\t\t      void *si ATTRIBUTE_UNUSED,\n-\t\t      struct sigcontext *sc ATTRIBUTE_UNUSED)\n+__gnat_error_handler (int sig, void *si, struct sigcontext *sc)\n {\n   sigset_t mask;\n \n@@ -2015,7 +2014,17 @@ __gnat_error_handler (int sig,\n   sigdelset (&mask, sig);\n   sigprocmask (SIG_SETMASK, &mask, NULL);\n \n-  __gnat_map_signal (sig);\n+#if defined (__PPC__)\n+  /* We process signals through a Call Frame Info trampoline, voiding\n+     the need for myriads of fallback_frame_state variants.  */\n+\n+  #include \"sigtramp.h\"\n+\n+  __gnat_sigtramp (sig, si, sc, &__gnat_map_signal);\n+\n+#else\n+  __gnat_map_signal (sig, si, sc);\n+#endif\n }\n \n void"}, {"sha": "82c7547360d6530cc2e6064391ae693664a424c2", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=8097203fc3a4cbd63b668dac627739abd2b40445", "patch": "@@ -3121,6 +3121,13 @@ package body Sem_Aggr is\n \n                         Expr := New_Copy_Tree (Expression (Parent (Compon)));\n \n+                        --  Component may have no default, in which case the\n+                        --  expression is empty and the component is default-\n+                        --  initialized, but an association for the component\n+                        --  exists, and it is not covered by an others clause.\n+\n+                        return Expr;\n+\n                      else\n                         if Present (Next (Selector_Name)) then\n                            Expr := New_Copy_Tree (Expression (Assoc));"}, {"sha": "7b15644e70e7947fe39a9039d9c0ebe56ef28361", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=8097203fc3a4cbd63b668dac627739abd2b40445", "patch": "@@ -264,6 +264,10 @@ package body Sem_Attr is\n       --  If the prefix type is an enumeration type, set all its literals\n       --  as referenced, since the image function could possibly end up\n       --  referencing any of the literals indirectly. Same for Enum_Val.\n+      --  Set the flag only if the reference is in the main code unit. Same\n+      --  restriction when resolving 'Value; otherwise an improperly set\n+      --  reference when analyzing an inlined body will lose a proper warning\n+      --  on a useless with_clause.\n \n       procedure Check_Fixed_Point_Type;\n       --  Verify that prefix of attribute N is a fixed type\n@@ -1226,7 +1230,9 @@ package body Sem_Attr is\n       procedure Check_Enum_Image is\n          Lit : Entity_Id;\n       begin\n-         if Is_Enumeration_Type (P_Base_Type) then\n+         if Is_Enumeration_Type (P_Base_Type)\n+           and then In_Extended_Main_Code_Unit (N)\n+         then\n             Lit := First_Literal (P_Base_Type);\n             while Present (Lit) loop\n                Set_Referenced (Lit);\n@@ -5031,7 +5037,9 @@ package body Sem_Attr is\n \n          --  Case of enumeration type\n \n-         if Is_Enumeration_Type (P_Type) then\n+         if Is_Enumeration_Type (P_Type)\n+           and then In_Extended_Main_Code_Unit (N)\n+         then\n             Check_Restriction (No_Enumeration_Maps, N);\n \n             --  Mark all enumeration literals as referenced, since the use of"}, {"sha": "9da8614aea5d8a8e82c7ea07873166bf3b218651", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=8097203fc3a4cbd63b668dac627739abd2b40445", "patch": "@@ -1565,6 +1565,9 @@ package body Sem_Ch12 is\n    --  static. For all scalar types we introduce an anonymous base type, with\n    --  the same attributes. We choose the corresponding integer type to be\n    --  Standard_Integer.\n+   --  Here and in other similar routines, the Sloc of the generated internal\n+   --  type must be the same as the sloc of the defining identifier of the\n+   --  formal type declaration, to provide proper source navigation.\n \n    procedure Analyze_Formal_Decimal_Fixed_Point_Type\n      (T   : Entity_Id;\n@@ -1574,7 +1577,8 @@ package body Sem_Ch12 is\n       Base      : constant Entity_Id :=\n                     New_Internal_Entity\n                       (E_Decimal_Fixed_Point_Type,\n-                       Current_Scope, Sloc (Def), 'G');\n+                       Current_Scope,\n+                         Sloc (Defining_Identifier (Parent (Def))), 'G');\n       Int_Base  : constant Entity_Id := Standard_Integer;\n       Delta_Val : constant Ureal := Ureal_1;\n       Digs_Val  : constant Uint  := Uint_6;\n@@ -1714,7 +1718,8 @@ package body Sem_Ch12 is\n \n       Base : constant Entity_Id :=\n                New_Internal_Entity\n-                 (E_Floating_Point_Type, Current_Scope, Sloc (Def), 'G');\n+                 (E_Floating_Point_Type, Current_Scope,\n+                    Sloc (Defining_Identifier (Parent (Def))), 'G');\n    begin\n       Enter_Name          (T);\n       Set_Ekind           (T, E_Enumeration_Subtype);\n@@ -1762,7 +1767,8 @@ package body Sem_Ch12 is\n    procedure Analyze_Formal_Floating_Type (T : Entity_Id; Def : Node_Id) is\n       Base : constant Entity_Id :=\n                New_Internal_Entity\n-                 (E_Floating_Point_Type, Current_Scope, Sloc (Def), 'G');\n+                 (E_Floating_Point_Type, Current_Scope,\n+                    Sloc (Defining_Identifier (Parent (Def))), 'G');\n \n    begin\n       --  The various semantic attributes are taken from the predefined type\n@@ -1980,7 +1986,8 @@ package body Sem_Ch12 is\n       Loc  : constant Source_Ptr := Sloc (Def);\n       Base : constant Entity_Id :=\n                New_Internal_Entity\n-                 (E_Ordinary_Fixed_Point_Type, Current_Scope, Sloc (Def), 'G');\n+                 (E_Ordinary_Fixed_Point_Type, Current_Scope,\n+                    Sloc (Defining_Identifier (Parent (Def))), 'G');\n    begin\n       --  The semantic attributes are set for completeness only, their values\n       --  will never be used, since all properties of the type are non-static.\n@@ -2403,7 +2410,9 @@ package body Sem_Ch12 is\n    is\n       Base : constant Entity_Id :=\n                New_Internal_Entity\n-                 (E_Signed_Integer_Type, Current_Scope, Sloc (Def), 'G');\n+          (E_Signed_Integer_Type,\n+           Current_Scope,\n+             Sloc (Defining_Identifier (Parent (Def))), 'G');\n \n    begin\n       Enter_Name (T);"}, {"sha": "26f9ff4a74b0ea58188abc8e0928f5b0e0ab2b07", "filename": "gcc/ada/sem_intr.adb", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsem_intr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsem_intr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_intr.adb?ref=8097203fc3a4cbd63b668dac627739abd2b40445", "patch": "@@ -317,7 +317,11 @@ package body Sem_Intr is\n          return;\n       end if;\n \n-      if not Is_Numeric_Type (Underlying_Type (T1)) then\n+      --  The type must be fully defined and numeric.\n+\n+      if No (Underlying_Type (T1))\n+        or else not Is_Numeric_Type (Underlying_Type (T1))\n+      then\n          Errint (\"intrinsic operator can only apply to numeric types\", E, N);\n       end if;\n    end Check_Intrinsic_Operator;"}, {"sha": "57a02a7d162b02d61351901ecf5a340d71445a71", "filename": "gcc/ada/sigtramp-ppcvxw.c", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsigtramp-ppcvxw.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsigtramp-ppcvxw.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp-ppcvxw.c?ref=8097203fc3a4cbd63b668dac627739abd2b40445", "patch": "@@ -0,0 +1,256 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             S I G T R A M P                              *\n+ *                                                                          *\n+ *                         Asm Implementation File                          *\n+ *                                                                          *\n+ *            Copyright (C) 2011, Free Software Foundation, Inc.            *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * In particular,  you can freely  distribute your programs  built with the *\n+ * GNAT Pro compiler, including any required library run-time units,  using *\n+ * any licensing terms  of your choosing.  See the AdaCore Software License *\n+ * for full details.                                                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/**********************************************************\n+ * PowerPC-VxWorks version of the __gnat_sigtramp service *\n+ **********************************************************/\n+\n+#include \"sigtramp.h\"\n+\n+#include <vxWorks.h>\n+#include <arch/../regs.h>\n+#include <sigLib.h>\n+\n+/* ----------------------\n+   -- General comments --\n+   ----------------------\n+\n+   Stubs are generated from toplevel asms and .cfi directives, much simpler\n+   to use and check for correctness than manual encodings of CFI byte\n+   sequences.  The general idea is to establish CFA as sigcontext->sc_pregs\n+   and state where to find the registers as offsets from there.\n+\n+   As of today, we support a single stub, providing CFI info for common\n+   registers (GPRs, LR, ...). We might need variants with support for floating\n+   point or altivec registers as well at some point.\n+\n+   Checking which variant should apply and getting at sc_pregs is simpler\n+   to express in C (we can't use offsetof in toplevel asms and hardcoding\n+   constants is not workable with the flurry of VxWorks variants), so this\n+   is the choice for our toplevel interface.  */\n+\n+/* -----------------------------------------\n+   -- Protypes for our internal asm stubs --\n+   -----------------------------------------\n+\n+   SC_PREGS is always expected to be SIGCONTEXT->sc_pregs.  Eventhough our\n+   symbols will remain local, the prototype claims \"extern\" and not\n+   \"static\" to prevent compiler complaints about a symbol used but never\n+   defined.  */\n+\n+/* sigtramp stub providing CFI info for common registers.  */\n+\n+extern void __gnat_sigtramp_common\n+(int signo, void *siginfo, void *sigcontext,\n+ sighandler_t * handler, void * sc_pregs);\n+\n+\n+/* -------------------------------------\n+   -- Common interface implementation --\n+   -------------------------------------\n+\n+   We enforce optimization to minimize the overhead of the extra layer.  */\n+\n+void __gnat_sigtramp (int signo, void *si, void *sc,\n+\t\t      sighandler_t * handler)\n+     __attribute__((optimize(2)));\n+\n+void __gnat_sigtramp (int signo, void *si, void *sc,\n+\t\t      sighandler_t * handler)\n+{\n+  struct sigcontext * sctx = (struct sigcontext *) sc;\n+\n+  __gnat_sigtramp_common (signo, si, sctx, handler, sctx->sc_pregs);\n+}\n+\n+\n+/* ---------------------------\n+   -- And now the asm stubs --\n+   ---------------------------\n+\n+   They all have a common structure with blocks of asm sequences queued one\n+   after the others.  Typically:\n+\n+   SYMBOL_START\n+\n+   CFI_DIRECTIVES\n+     CFI_DEF_CFA,\n+     CFI_COMMON_REGISTERS,\n+     ...\n+\n+   STUB_BODY\n+     asm code to establish frame, setup the cfa reg value,\n+     call the real signal handler, ...\n+\n+   SYMBOL_END\n+*/\n+\n+/*--------------------------------\n+  -- Misc constants and helpers --\n+  -------------------------------- */\n+\n+/* REGNO constants, dwarf column numbers for registers of interest.  */\n+\n+#define REGNO_LR  65\n+#define REGNO_XER 76\n+#define REGNO_CR  70\n+#define REGNO_GR(N) (N)\n+\n+#define REGNO_PC  67  /* ARG_POINTER_REGNUM  */\n+\n+/* asm string contruction helpers.  */\n+\n+#define STR(TEXT) #TEXT\n+/* stringify expanded TEXT, surrounding it with double quotes.  */\n+\n+#define S(E) STR(E)\n+/* stringify E, which will resolve as text but may contain macros\n+   still to be expanded.  */\n+\n+/* asm (TEXT) outputs <tab>TEXT. These facilitate the output of\n+   multine contents:  */\n+#define TAB(S) \"\\t\" S\n+#define CR(S)  S \"\\n\"\n+#define TCR(S) TAB(CR(S))\n+\n+/*------------------------------\n+  -- Stub construction blocks --\n+  ------------------------------ */\n+\n+/* CFA setup block\n+   ---------------\n+   Only non-volatile registers are suitable for a CFA base.  We use r14\n+   here and set it to the value we need in stub body that follows.  */\n+\n+#define CFI_DEF_CFA \\\n+CR(\".cfi_def_cfa 14, 0\")\n+\n+/* Register location blocks\n+   ------------------------\n+   Rules to find registers of interest from the CFA. This should\n+   comprise all the non-volatile registers relevant to the interrupted\n+   context.  */\n+\n+#define COMMON_CFI(REG) \\\n+  \".cfi_offset \" S(REGNO_##REG) \",\" S(REG_SET_##REG)\n+\n+#define CFI_COMMON_REGS \\\n+CR(\"# CFI for common registers\\n\") \\\n+TCR(COMMON_CFI(GR(1)))  \\\n+TCR(COMMON_CFI(GR(14))) \\\n+TCR(COMMON_CFI(GR(15))) \\\n+TCR(COMMON_CFI(GR(16))) \\\n+TCR(COMMON_CFI(GR(17))) \\\n+TCR(COMMON_CFI(GR(18))) \\\n+TCR(COMMON_CFI(GR(19))) \\\n+TCR(COMMON_CFI(GR(20))) \\\n+TCR(COMMON_CFI(GR(21))) \\\n+TCR(COMMON_CFI(GR(22))) \\\n+TCR(COMMON_CFI(GR(23))) \\\n+TCR(COMMON_CFI(GR(24))) \\\n+TCR(COMMON_CFI(GR(25))) \\\n+TCR(COMMON_CFI(GR(26))) \\\n+TCR(COMMON_CFI(GR(27))) \\\n+TCR(COMMON_CFI(GR(28))) \\\n+TCR(COMMON_CFI(GR(29))) \\\n+TCR(COMMON_CFI(GR(30))) \\\n+TCR(COMMON_CFI(GR(31))) \\\n+TCR(COMMON_CFI(LR)) \\\n+TCR(COMMON_CFI(CR)) \\\n+TCR(COMMON_CFI(PC)) \\\n+TCR(\".cfi_return_column \" S(REGNO_PC))\n+\n+/* Trampoline body block\n+   ---------------------  */\n+\n+#define SIGTRAMP_BODY \\\n+CR(\"\") \\\n+TCR(\"# Allocate frame and save the non-volatile\") \\\n+TCR(\"# registers we're going to modify\") \\\n+TCR(\"stwu %r1,-16(%r1)\")  \\\n+TCR(\"mflr %r0\")\t\\\n+TCR(\"stw %r0,20(%r1)\")\t\\\n+TCR(\"stw %r14,8(%r1)\")\t\\\n+TCR(\"\")\t\t\t\\\n+TCR(\"# Setup r14 = sc_pregs, that we'll retrieve as our CFA value\") \\\n+TCR(\"mr %r14, %r7\") \\\n+TCR(\"\")\t\t\t\\\n+TCR(\"# Call the real handler. The signo, siginfo and sigcontext\") \\\n+TCR(\"# arguments are the same as those we received in r3, r4 and r5\") \\\n+TCR(\"mtctr %r6\") \\\n+TCR(\"bctrl\")\t\\\n+TCR(\"\")\t\t\\\n+TCR(\"# Restore our callee-saved items, release our frame and return\") \\\n+TCR(\"lwz %r14,8(%r1)\")\t\\\n+TCR(\"lwz %r0,20(%r1)\")\t\\\n+TCR(\"mtlr %r0\")\t\t\\\n+TCR(\"\")\t\t\t\\\n+TCR(\"addi %r1,%r1,16\")\t\\\n+TCR(\"blr\")\n+\n+/* Symbol definition block\n+   -----------------------  */\n+\n+#define SIGTRAMP_START(SYM) \\\n+CR(\"# \" S(SYM) \" cfi trampoline\") \\\n+TCR(\".type \" S(SYM) \", @function\") \\\n+CR(\"\") \\\n+CR(S(SYM) \":\") \\\n+TCR(\".cfi_startproc\") \\\n+TCR(\".cfi_signal_frame\")\n+\n+/* Symbol termination block\n+   ------------------------  */\n+\n+#define SIGTRAMP_END(SYM) \\\n+CR(\".cfi_endproc\") \\\n+TCR(\".size \" S(SYM) \", .-\" S(SYM))\n+\n+/*----------------------------\n+  -- And now, the real code --\n+  ---------------------------- */\n+\n+/* Text section start.  The compiler isn't aware of that switch.  */\n+\n+asm (\".text\\n\"\n+     TCR(\".align 2\"));\n+\n+/* sigtramp stub for common registers.  */\n+\n+#define TRAMP_COMMON __gnat_sigtramp_common\n+\n+asm (SIGTRAMP_START(TRAMP_COMMON));\n+asm (CFI_DEF_CFA);\n+asm (CFI_COMMON_REGS);\n+asm (SIGTRAMP_BODY);\n+asm (SIGTRAMP_END(TRAMP_COMMON));\n+\n+"}, {"sha": "5e3cc5b77c974c975952be8167e56f54045008df", "filename": "gcc/ada/sigtramp.h", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsigtramp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8097203fc3a4cbd63b668dac627739abd2b40445/gcc%2Fada%2Fsigtramp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsigtramp.h?ref=8097203fc3a4cbd63b668dac627739abd2b40445", "patch": "@@ -0,0 +1,56 @@\n+/****************************************************************************\n+ *                                                                          *\n+ *                         GNAT COMPILER COMPONENTS                         *\n+ *                                                                          *\n+ *                             S I G T R A M P                              *\n+ *                                                                          *\n+ *                              C Header File                               *\n+ *                                                                          *\n+ *            Copyright (C) 2011, Free Software Foundation, Inc.            *\n+ *                                                                          *\n+ * GNAT is free software;  you can  redistribute it  and/or modify it under *\n+ * terms of the  GNU General Public License as published  by the Free Soft- *\n+ * ware  Foundation;  either version 3,  or (at your option) any later ver- *\n+ * sion.  GNAT is distributed in the hope that it will be useful, but WITH- *\n+ * OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY *\n+ * or FITNESS FOR A PARTICULAR PURPOSE.                                     *\n+ *                                                                          *\n+ * As a special exception under Section 7 of GPL version 3, you are granted *\n+ * additional permissions described in the GCC Runtime Library Exception,   *\n+ * version 3.1, as published by the Free Software Foundation.               *\n+ *                                                                          *\n+ * In particular,  you can freely  distribute your programs  built with the *\n+ * GNAT Pro compiler, including any required library run-time units,  using *\n+ * any licensing terms  of your choosing.  See the AdaCore Software License *\n+ * for full details.                                                        *\n+ *                                                                          *\n+ * GNAT was originally developed  by the GNAT team at  New York University. *\n+ * Extensive contributions were provided by Ada Core Technologies Inc.      *\n+ *                                                                          *\n+ ****************************************************************************/\n+\n+/* On targets where this is implemented, we resort to a signal handler\n+   trampoline to set-up the DWARF Call Frame Information that let unwinders\n+   walk through the signal frame up into the interrupted application code.\n+   This file introduces the relevant declarations.  */\n+\n+/* This file should only be #included on targets that do implement the\n+   trampoline, which needs to expose the following interface:  */\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+  typedef void sighandler_t (int signo, void *siginfo, void *sigcontext);\n+\n+  void __gnat_sigtramp  (int signo, void *siginfo, void *sigcontext,\n+\t\t\t sighandler_t * handler);\n+\n+  /* To be called from an established signal handler.  Setup the DWARF CFI\n+     bits letting unwinders walk through the signal frame up into the\n+     interrupted application code, and then call HANDLER (SIGNO, SIGINFO,\n+     SIGCONTEXT).  */\n+\n+#ifdef __cplusplus\n+}\n+#endif"}]}