{"sha": "eb6eb8623701589015d966a71970c1893a92884c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWI2ZWI4NjIzNzAxNTg5MDE1ZDk2NmE3MTk3MGMxODkzYTkyODg0Yw==", "commit": {"author": {"name": "Chris Manghane", "email": "cmang@google.com", "date": "2014-01-15T00:17:22Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-01-15T00:17:22Z"}, "message": "compiler: Use backend interface for interface info and field expressions.\n\n\t* go-gcc.cc (Gcc_backend::compound_expression): New function.\n\t(Gcc_backend::conditional_expression): New function.\n\nFrom-SVN: r206615", "tree": {"sha": "2b571552fe5d06bd3ad28d1e52b28da5b8b963e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2b571552fe5d06bd3ad28d1e52b28da5b8b963e2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/eb6eb8623701589015d966a71970c1893a92884c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6eb8623701589015d966a71970c1893a92884c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6eb8623701589015d966a71970c1893a92884c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6eb8623701589015d966a71970c1893a92884c/comments", "author": null, "committer": null, "parents": [{"sha": "3f3bd8aa27b17af34cfd338f6d1f20cc62dba075", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f3bd8aa27b17af34cfd338f6d1f20cc62dba075", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f3bd8aa27b17af34cfd338f6d1f20cc62dba075"}], "stats": {"total": 446, "additions": 305, "deletions": 141}, "files": [{"sha": "5c8cae02d298b1d9a26389c9b4be415742f5cbfd", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6eb8623701589015d966a71970c1893a92884c/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6eb8623701589015d966a71970c1893a92884c/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=eb6eb8623701589015d966a71970c1893a92884c", "patch": "@@ -1,3 +1,8 @@\n+2014-01-14  Chris Manghane  <cmang@google.com>\n+\n+\t* go-gcc.cc (Gcc_backend::compound_expression): New function.\n+\t(Gcc_backend::conditional_expression): New function.\n+\n 2014-01-02  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \tUpdate copyright years"}, {"sha": "3f61860091f0bae0f97277361ebf7bf3c3b57ff9", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6eb8623701589015d966a71970c1893a92884c/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6eb8623701589015d966a71970c1893a92884c/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=eb6eb8623701589015d966a71970c1893a92884c", "patch": "@@ -246,6 +246,12 @@ class Gcc_backend : public Backend\n   Bexpression*\n   struct_field_expression(Bexpression*, size_t, Location);\n \n+  Bexpression*\n+  compound_expression(Bstatement*, Bexpression*, Location);\n+\n+  Bexpression*\n+  conditional_expression(Bexpression*, Bexpression*, Bexpression*, Location);\n+\n   // Statements.\n \n   Bstatement*\n@@ -1034,6 +1040,41 @@ Gcc_backend::struct_field_expression(Bexpression* bstruct, size_t index,\n   return tree_to_expr(ret);\n }\n \n+// Return an expression that executes BSTAT before BEXPR.\n+\n+Bexpression*\n+Gcc_backend::compound_expression(Bstatement* bstat, Bexpression* bexpr,\n+                                 Location location)\n+{\n+  tree stat = bstat->get_tree();\n+  tree expr = bexpr->get_tree();\n+  if (stat == error_mark_node || expr == error_mark_node)\n+    return this->error_expression();\n+  tree ret = fold_build2_loc(location.gcc_location(), COMPOUND_EXPR,\n+                             TREE_TYPE(expr), stat, expr);\n+  return this->make_expression(ret);\n+}\n+\n+// Return an expression that executes THEN_EXPR if CONDITION is true, or\n+// ELSE_EXPR otherwise.\n+\n+Bexpression*\n+Gcc_backend::conditional_expression(Bexpression* condition,\n+                                    Bexpression* then_expr,\n+                                    Bexpression* else_expr, Location location)\n+{\n+  tree cond_tree = condition->get_tree();\n+  tree then_tree = then_expr->get_tree();\n+  tree else_tree = else_expr == NULL ? NULL_TREE : else_expr->get_tree();\n+  if (cond_tree == error_mark_node\n+      || then_tree == error_mark_node\n+      || else_tree == error_mark_node)\n+    return this->error_expression();\n+  tree ret = build3_loc(location.gcc_location(), COND_EXPR, void_type_node,\n+                        cond_tree, then_tree, else_tree);\n+  return this->make_expression(ret);\n+}\n+\n // An expression as a statement.\n \n Bstatement*"}, {"sha": "6e852161b3f019f23d423c2ca3d8e1bc2fd1bdb6", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6eb8623701589015d966a71970c1893a92884c/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6eb8623701589015d966a71970c1893a92884c/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=eb6eb8623701589015d966a71970c1893a92884c", "patch": "@@ -284,6 +284,16 @@ class Backend\n   virtual Bexpression*\n   struct_field_expression(Bexpression* bstruct, size_t index, Location) = 0;\n \n+  // Create an expression that executes BSTAT before BEXPR.\n+  virtual Bexpression*\n+  compound_expression(Bstatement* bstat, Bexpression* bexpr, Location) = 0;\n+\n+  // Return an expression that executes THEN_EXPR if CONDITION is true, or\n+  // ELSE_EXPR otherwise.  ELSE_EXPR may be NULL.\n+  virtual Bexpression*\n+  conditional_expression(Bexpression* condition, Bexpression* then_expr,\n+                         Bexpression* else_expr, Location) = 0;\n+\n   // Statements.\n \n   // Create an error statement.  This is used for cases which should"}, {"sha": "c283db1a553d19bd3d63c2fc75324391773219f8", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 223, "deletions": 128, "changes": 351, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6eb8623701589015d966a71970c1893a92884c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6eb8623701589015d966a71970c1893a92884c/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=eb6eb8623701589015d966a71970c1893a92884c", "patch": "@@ -6473,11 +6473,11 @@ Expression::make_binary(Operator op, Expression* left, Expression* right,\n \n tree\n Expression::comparison_tree(Translate_context* context, Type* result_type,\n-\t\t\t    Operator op, Expression* left_expr,\n-\t\t\t    Expression* right_expr, Location location)\n+\t\t\t    Operator op, Expression* left, Expression* right,\n+\t\t\t    Location location)\n {\n-  Type* left_type = left_expr->type();\n-  Type* right_type = right_expr->type();\n+  Type* left_type = left->type();\n+  Type* right_type = right->type();\n \n   mpz_t zval;\n   mpz_init_set_ui(zval, 0UL);\n@@ -6509,17 +6509,11 @@ Expression::comparison_tree(Translate_context* context, Type* result_type,\n       go_unreachable();\n     }\n \n-  // FIXME: Computing the tree here means it will be computed multiple times,\n-  // which is wasteful.  This is a temporary modification until all tree code\n-  // here can be replaced with frontend expressions.\n-  tree left_tree = left_expr->get_tree(context);\n-  tree right_tree = right_expr->get_tree(context);\n   if (left_type->is_string_type() && right_type->is_string_type())\n     {\n-      Expression* strcmp_call = Runtime::make_call(Runtime::STRCMP, location, 2,\n-                                                   left_expr, right_expr);\n-      left_tree = strcmp_call->get_tree(context);\n-      right_tree = zexpr->get_tree(context);\n+      left = Runtime::make_call(Runtime::STRCMP, location, 2,\n+                                left, right);\n+      right = zexpr;\n     }\n   else if ((left_type->interface_type() != NULL\n \t    && right_type->interface_type() == NULL\n@@ -6532,31 +6526,30 @@ Expression::comparison_tree(Translate_context* context, Type* result_type,\n       if (left_type->interface_type() == NULL)\n \t{\n \t  std::swap(left_type, right_type);\n-\t  std::swap(left_expr, right_expr);\n+\t  std::swap(left, right);\n \t}\n \n       // The right operand is not an interface.  We need to take its\n       // address if it is not a pointer.\n       Expression* pointer_arg = NULL;\n       if (right_type->points_to() != NULL)\n-        pointer_arg = right_expr;\n+        pointer_arg = right;\n       else\n \t{\n-          go_assert(right_expr->is_addressable());\n-          pointer_arg = Expression::make_unary(OPERATOR_AND, right_expr,\n+          go_assert(right->is_addressable());\n+          pointer_arg = Expression::make_unary(OPERATOR_AND, right,\n                                                location);\n \t}\n \n-      Expression* descriptor_expr = Expression::make_type_descriptor(right_type,\n-                                                                     location);\n-      Call_expression* iface_valcmp =\n+      Expression* descriptor =\n+          Expression::make_type_descriptor(right_type, location);\n+      left =\n           Runtime::make_call((left_type->interface_type()->is_empty()\n                               ? Runtime::EMPTY_INTERFACE_VALUE_COMPARE\n                               : Runtime::INTERFACE_VALUE_COMPARE),\n-                             location, 3, left_expr, descriptor_expr,\n+                             location, 3, left, descriptor,\n                              pointer_arg);\n-      left_tree = iface_valcmp->get_tree(context);\n-      right_tree = zexpr->get_tree(context);\n+      right = zexpr;\n     }\n   else if (left_type->interface_type() != NULL\n \t   && right_type->interface_type() != NULL)\n@@ -6574,56 +6567,42 @@ Expression::comparison_tree(Translate_context* context, Type* result_type,\n \t    {\n \t      go_assert(op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ);\n \t      std::swap(left_type, right_type);\n-\t      std::swap(left_expr, right_expr);\n+\t      std::swap(left, right);\n \t    }\n \t  go_assert(!left_type->interface_type()->is_empty());\n \t  go_assert(right_type->interface_type()->is_empty());\n \t  compare_function = Runtime::INTERFACE_EMPTY_COMPARE;\n \t}\n \n-      Call_expression* ifacecmp_call =\n-          Runtime::make_call(compare_function, location, 2,\n-                             left_expr, right_expr);\n-\n-      left_tree = ifacecmp_call->get_tree(context);\n-      right_tree = zexpr->get_tree(context);\n+      left = Runtime::make_call(compare_function, location, 2, left, right);\n+      right = zexpr;\n     }\n \n   if (left_type->is_nil_type()\n       && (op == OPERATOR_EQEQ || op == OPERATOR_NOTEQ))\n     {\n       std::swap(left_type, right_type);\n-      std::swap(left_tree, right_tree);\n-      std::swap(left_expr, right_expr);\n+      std::swap(left, right);\n     }\n \n   if (right_type->is_nil_type())\n     {\n+      right = Expression::make_nil(location);\n       if (left_type->array_type() != NULL\n \t  && left_type->array_type()->length() == NULL)\n \t{\n \t  Array_type* at = left_type->array_type();\n-          left_expr = at->get_value_pointer(context->gogo(), left_expr);\n-          left_tree = left_expr->get_tree(context);\n-\t  right_tree = fold_convert(TREE_TYPE(left_tree), null_pointer_node);\n+          left = at->get_value_pointer(context->gogo(), left);\n \t}\n       else if (left_type->interface_type() != NULL)\n \t{\n \t  // An interface is nil if the first field is nil.\n-\t  tree left_type_tree = TREE_TYPE(left_tree);\n-\t  go_assert(TREE_CODE(left_type_tree) == RECORD_TYPE);\n-\t  tree field = TYPE_FIELDS(left_type_tree);\n-\t  left_tree = build3(COMPONENT_REF, TREE_TYPE(field), left_tree,\n-\t\t\t     field, NULL_TREE);\n-\t  right_tree = fold_convert(TREE_TYPE(left_tree), null_pointer_node);\n-\t}\n-      else\n-\t{\n-\t  go_assert(POINTER_TYPE_P(TREE_TYPE(left_tree)));\n-\t  right_tree = fold_convert(TREE_TYPE(left_tree), null_pointer_node);\n+          left = Expression::make_field_reference(left, 0, location);\n \t}\n     }\n \n+  tree left_tree = left->get_tree(context);\n+  tree right_tree = right->get_tree(context);\n   if (left_tree == error_mark_node || right_tree == error_mark_node)\n     return error_mark_node;\n \n@@ -9745,21 +9724,13 @@ Call_expression::do_must_eval_in_order() const\n // Get the function and the first argument to use when calling an\n // interface method.\n \n-tree\n+Expression*\n Call_expression::interface_method_function(\n-    Translate_context* context,\n     Interface_field_reference_expression* interface_method,\n-    tree* first_arg_ptr)\n+    Expression** first_arg_ptr)\n {\n-  tree expr = interface_method->expr()->get_tree(context);\n-  if (expr == error_mark_node)\n-    return error_mark_node;\n-  expr = save_expr(expr);\n-  tree first_arg = interface_method->get_underlying_object_tree(context, expr);\n-  if (first_arg == error_mark_node)\n-    return error_mark_node;\n-  *first_arg_ptr = first_arg;\n-  return interface_method->get_function_tree(context, expr);\n+  *first_arg_ptr = interface_method->get_underlying_object();\n+  return interface_method->get_function();\n }\n \n // Build the call expression.\n@@ -9889,8 +9860,12 @@ Call_expression::do_get_tree(Translate_context* context)\n     }      \n   else\n     {\n-      fn = this->interface_method_function(context, interface_method,\n-\t\t\t\t\t   &args[0]);\n+      Expression* first_arg;\n+      Expression* fn_expr =\n+          this->interface_method_function(interface_method, &first_arg);\n+      args[0] = first_arg->get_tree(context);\n+      fn = fn_expr->get_tree(context);\n+\n       if (fn == error_mark_node)\n \treturn error_mark_node;\n       closure_tree = NULL_TREE;\n@@ -11623,58 +11598,39 @@ Expression::make_field_reference(Expression* expr, unsigned int field_index,\n \n // Class Interface_field_reference_expression.\n \n-// Return a tree for the pointer to the function to call.\n+// Return an expression for the pointer to the function to call.\n \n-tree\n-Interface_field_reference_expression::get_function_tree(Translate_context*,\n-\t\t\t\t\t\t\ttree expr)\n+Expression*\n+Interface_field_reference_expression::get_function()\n {\n-  if (this->expr_->type()->points_to() != NULL)\n-    expr = build_fold_indirect_ref(expr);\n-\n-  tree expr_type = TREE_TYPE(expr);\n-  go_assert(TREE_CODE(expr_type) == RECORD_TYPE);\n-\n-  tree field = TYPE_FIELDS(expr_type);\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__methods\") == 0);\n-\n-  tree table = build3(COMPONENT_REF, TREE_TYPE(field), expr, field, NULL_TREE);\n-  go_assert(POINTER_TYPE_P(TREE_TYPE(table)));\n+  Expression* ref = this->expr_;\n+  Location loc = this->location();\n+  if (ref->type()->points_to() != NULL)\n+    ref = Expression::make_unary(OPERATOR_MULT, ref, loc);\n \n-  table = build_fold_indirect_ref(table);\n-  go_assert(TREE_CODE(TREE_TYPE(table)) == RECORD_TYPE);\n+  Expression* mtable =\n+      Expression::make_interface_info(ref, INTERFACE_INFO_METHODS, loc);\n+  Struct_type* mtable_type = mtable->type()->points_to()->struct_type();\n \n   std::string name = Gogo::unpack_hidden_name(this->name_);\n-  for (field = DECL_CHAIN(TYPE_FIELDS(TREE_TYPE(table)));\n-       field != NULL_TREE;\n-       field = DECL_CHAIN(field))\n-    {\n-      if (name == IDENTIFIER_POINTER(DECL_NAME(field)))\n-\tbreak;\n-    }\n-  go_assert(field != NULL_TREE);\n-\n-  return build3(COMPONENT_REF, TREE_TYPE(field), table, field, NULL_TREE);\n+  unsigned int index;\n+  const Struct_field* field = mtable_type->find_local_field(name, &index);\n+  go_assert(field != NULL);\n+  mtable = Expression::make_unary(OPERATOR_MULT, mtable, loc);\n+  return Expression::make_field_reference(mtable, index, loc);\n }\n \n-// Return a tree for the first argument to pass to the interface\n+// Return an expression for the first argument to pass to the interface\n // function.\n \n-tree\n-Interface_field_reference_expression::get_underlying_object_tree(\n-    Translate_context*,\n-    tree expr)\n+Expression*\n+Interface_field_reference_expression::get_underlying_object()\n {\n-  if (this->expr_->type()->points_to() != NULL)\n-    expr = build_fold_indirect_ref(expr);\n-\n-  tree expr_type = TREE_TYPE(expr);\n-  go_assert(TREE_CODE(expr_type) == RECORD_TYPE);\n-\n-  tree field = DECL_CHAIN(TYPE_FIELDS(expr_type));\n-  go_assert(strcmp(IDENTIFIER_POINTER(DECL_NAME(field)), \"__object\") == 0);\n-\n-  return build3(COMPONENT_REF, TREE_TYPE(field), expr, field, NULL_TREE);\n+  Expression* expr = this->expr_;\n+  if (expr->type()->points_to() != NULL)\n+    expr = Expression::make_unary(OPERATOR_MULT, expr, this->location());\n+  return Expression::make_interface_info(expr, INTERFACE_INFO_OBJECT,\n+                                         this->location());\n }\n \n // Traversal.\n@@ -11694,9 +11650,7 @@ Interface_field_reference_expression::do_lower(Gogo*, Named_object*,\n \t\t\t\t\t       Statement_inserter* inserter,\n \t\t\t\t\t       int)\n {\n-  if (this->expr_->var_expression() == NULL\n-      && this->expr_->temporary_reference_expression() == NULL\n-      && this->expr_->set_and_use_temporary_expression() == NULL)\n+  if (!this->expr_->is_variable())\n     {\n       Temporary_statement* temp =\n \tStatement::make_temporary(this->expr_->type(), NULL, this->location());\n@@ -11923,30 +11877,22 @@ Interface_field_reference_expression::do_get_tree(Translate_context* context)\n   Expression* expr = Expression::make_struct_composite_literal(st, vals, loc);\n   expr = Expression::make_heap_composite(expr, loc);\n \n-  tree closure_tree = expr->get_tree(context);\n+  Bexpression* bclosure = tree_to_expr(expr->get_tree(context));\n+  Expression* nil_check =\n+      Expression::make_binary(OPERATOR_EQEQ, this->expr_,\n+                              Expression::make_nil(loc), loc);\n+  Bexpression* bnil_check = tree_to_expr(nil_check->get_tree(context));\n \n-  // Note that we are evaluating this->expr_ twice, but that is OK\n-  // because in the lowering pass we forced it into a temporary\n-  // variable.\n-  tree nil_check_tree = Expression::comparison_tree(context,\n-\t\t\t\t\t\t    Type::lookup_bool_type(),\n-\t\t\t\t\t\t    OPERATOR_EQEQ,\n-\t\t\t\t\t\t    this->expr_,\n-\t\t\t\t\t\t    Expression::make_nil(loc),\n-\t\t\t\t\t\t    loc);\n-  Expression* crash_expr =\n-      context->gogo()->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE, loc);\n-  tree crash = crash_expr->get_tree(context);\n-  if (closure_tree == error_mark_node\n-      || nil_check_tree == error_mark_node\n-      || crash == error_mark_node)\n-    return error_mark_node;\n-  return fold_build2_loc(loc.gcc_location(), COMPOUND_EXPR,\n-\t\t\t TREE_TYPE(closure_tree),\n-\t\t\t build3_loc(loc.gcc_location(), COND_EXPR,\n-\t\t\t\t    void_type_node, nil_check_tree, crash,\n-\t\t\t\t    NULL_TREE),\n-\t\t\t closure_tree);\n+  Gogo* gogo = context->gogo();\n+  Expression* crash = gogo->runtime_error(RUNTIME_ERROR_NIL_DEREFERENCE, loc);\n+  Bexpression* bcrash = tree_to_expr(crash->get_tree(context));\n+\n+  Bexpression* bcond =\n+      gogo->backend()->conditional_expression(bnil_check, bcrash, NULL, loc);\n+  Bstatement* cond_statement = gogo->backend()->expression_statement(bcond);\n+  Bexpression* ret =\n+      gogo->backend()->compound_expression(cond_statement, bclosure, loc);\n+  return expr_to_tree(ret);\n }\n \n // Dump ast representation for an interface field reference.\n@@ -14754,6 +14700,155 @@ Expression::make_slice_info(Expression* slice, Slice_info slice_info,\n   return new Slice_info_expression(slice, slice_info, location);\n }\n \n+\n+// An expression that evaluates to some characteristic of a non-empty interface.\n+// This is used to access the method table or underlying object of an interface.\n+\n+class Interface_info_expression : public Expression\n+{\n+ public:\n+  Interface_info_expression(Expression* iface, Interface_info iface_info,\n+                        Location location)\n+    : Expression(EXPRESSION_INTERFACE_INFO, location),\n+      iface_(iface), iface_info_(iface_info)\n+  { }\n+\n+ protected:\n+  Type*\n+  do_type();\n+\n+  void\n+  do_determine_type(const Type_context*)\n+  { }\n+\n+  Expression*\n+  do_copy()\n+  {\n+    return new Interface_info_expression(this->iface_->copy(),\n+                                         this->iface_info_, this->location());\n+  }\n+\n+  tree\n+  do_get_tree(Translate_context* context);\n+\n+  void\n+  do_dump_expression(Ast_dump_context*) const;\n+\n+  void\n+  do_issue_nil_check()\n+  { this->iface_->issue_nil_check(); }\n+\n+ private:\n+  // The interface for which we are getting information.\n+  Expression* iface_;\n+  // What information we want.\n+  Interface_info iface_info_;\n+};\n+\n+// Return the type of the interface info.\n+\n+Type*\n+Interface_info_expression::do_type()\n+{\n+  switch (this->iface_info_)\n+    {\n+    case INTERFACE_INFO_METHODS:\n+      {\n+        Location loc = this->location();\n+        Struct_field_list* sfl = new Struct_field_list();\n+        Type* pdt = Type::make_type_descriptor_ptr_type();\n+        sfl->push_back(\n+            Struct_field(Typed_identifier(\"__type_descriptor\", pdt, loc)));\n+\n+        Interface_type* itype = this->iface_->type()->interface_type();\n+        for (Typed_identifier_list::const_iterator p = itype->methods()->begin();\n+             p != itype->methods()->end();\n+             ++p)\n+          {\n+            Function_type* ft = p->type()->function_type();\n+            go_assert(ft->receiver() == NULL);\n+\n+            const Typed_identifier_list* params = ft->parameters();\n+            Typed_identifier_list* mparams = new Typed_identifier_list();\n+            if (params != NULL)\n+              mparams->reserve(params->size() + 1);\n+            Type* vt = Type::make_pointer_type(Type::make_void_type());\n+            mparams->push_back(Typed_identifier(\"\", vt, ft->location()));\n+            if (params != NULL)\n+              {\n+                for (Typed_identifier_list::const_iterator pp = params->begin();\n+                     pp != params->end();\n+                     ++pp)\n+                  mparams->push_back(*pp);\n+              }\n+\n+            Typed_identifier_list* mresults = (ft->results() == NULL\n+                                               ? NULL\n+                                               : ft->results()->copy());\n+            Backend_function_type* mft =\n+                Type::make_backend_function_type(NULL, mparams, mresults,\n+                                                 ft->location());\n+\n+            std::string fname = Gogo::unpack_hidden_name(p->name());\n+            sfl->push_back(Struct_field(Typed_identifier(fname, mft, loc)));\n+          }\n+\n+        return Type::make_pointer_type(Type::make_struct_type(sfl, loc));\n+      }\n+    case INTERFACE_INFO_OBJECT:\n+      return Type::make_pointer_type(Type::make_void_type());\n+    default:\n+      go_unreachable();\n+    }\n+}\n+\n+// Return interface information in GENERIC.\n+\n+tree\n+Interface_info_expression::do_get_tree(Translate_context* context)\n+{\n+  Gogo* gogo = context->gogo();\n+\n+  Bexpression* biface = tree_to_expr(this->iface_->get_tree(context));\n+  Bexpression* ret;\n+  switch (this->iface_info_)\n+    {\n+    case INTERFACE_INFO_METHODS:\n+    case INTERFACE_INFO_OBJECT:\n+      ret = gogo->backend()->struct_field_expression(biface, this->iface_info_,\n+                                                     this->location());\n+      break;\n+    default:\n+      go_unreachable();\n+    }\n+  return expr_to_tree(ret);\n+}\n+\n+// Dump ast representation for an interface info expression.\n+\n+void\n+Interface_info_expression::do_dump_expression(\n+    Ast_dump_context* ast_dump_context) const\n+{\n+  ast_dump_context->ostream() << \"interfaceinfo(\";\n+  this->iface_->dump_expression(ast_dump_context);\n+  ast_dump_context->ostream() << \",\";\n+  ast_dump_context->ostream() <<\n+      (this->iface_info_ == INTERFACE_INFO_METHODS ? \"methods\"\n+    : this->iface_info_ == INTERFACE_INFO_OBJECT ? \"object\"\n+    : \"unknown\");\n+  ast_dump_context->ostream() << \")\";\n+}\n+\n+// Make an interface info expression.\n+\n+Expression*\n+Expression::make_interface_info(Expression* iface, Interface_info iface_info,\n+                                Location location)\n+{\n+  return new Interface_info_expression(iface, iface_info, location);\n+}\n+\n // An expression which evaluates to the offset of a field within a\n // struct.  This, like Type_info_expression, q.v., is only used to\n // initialize fields of a type descriptor."}, {"sha": "83bc72414806321871efa9f4b4433d54e4bf8e01", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/eb6eb8623701589015d966a71970c1893a92884c/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/eb6eb8623701589015d966a71970c1893a92884c/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=eb6eb8623701589015d966a71970c1893a92884c", "patch": "@@ -103,6 +103,7 @@ class Expression\n     EXPRESSION_TYPE_DESCRIPTOR,\n     EXPRESSION_TYPE_INFO,\n     EXPRESSION_SLICE_INFO,\n+    EXPRESSION_INTERFACE_INFO,\n     EXPRESSION_STRUCT_FIELD_OFFSET,\n     EXPRESSION_MAP_DESCRIPTOR,\n     EXPRESSION_LABEL_ADDR\n@@ -356,6 +357,21 @@ class Expression\n   static Expression*\n   make_slice_info(Expression* slice, Slice_info, Location);\n \n+\n+  // Make an expression that evaluates to some characteristic of a\n+  // interface.  For simplicity, the enum values must match the field indexes\n+  // of a non-empty interface in the underlying struct.\n+  enum Interface_info\n+    {\n+      // The methods of an interface.\n+      INTERFACE_INFO_METHODS,\n+      // The first argument to pass to an interface method.\n+      INTERFACE_INFO_OBJECT\n+    };\n+\n+  static Expression*\n+  make_interface_info(Expression* iface, Interface_info, Location);\n+\n   // Make an expression which evaluates to the offset of a field in a\n   // struct.  This is only used for type descriptors, so there is no\n   // location parameter.\n@@ -1508,10 +1524,9 @@ class Call_expression : public Expression\n   bool\n   check_argument_type(int, const Type*, const Type*, Location, bool);\n \n-  tree\n-  interface_method_function(Translate_context*,\n-\t\t\t    Interface_field_reference_expression*,\n-\t\t\t    tree*);\n+  Expression*\n+  interface_method_function(Interface_field_reference_expression*,\n+\t\t\t    Expression**);\n \n   tree\n   set_results(Translate_context*, tree);\n@@ -2115,16 +2130,14 @@ class Interface_field_reference_expression : public Expression\n   static Named_object*\n   create_thunk(Gogo*, Interface_type* type, const std::string& name);\n \n-  // Return a tree for the pointer to the function to call, given a\n-  // tree for the expression.\n-  tree\n-  get_function_tree(Translate_context*, tree);\n+  // Return an expression for the pointer to the function to call.\n+  Expression*\n+  get_function();\n \n-  // Return a tree for the first argument to pass to the interface\n-  // function, given a tree for the expression.  This is the real\n-  // object associated with the interface object.\n-  tree\n-  get_underlying_object_tree(Translate_context*, tree);\n+  // Return an expression for the first argument to pass to the interface\n+  // function.  This is the real object associated with the interface object.\n+  Expression*\n+  get_underlying_object();\n \n  protected:\n   int"}]}