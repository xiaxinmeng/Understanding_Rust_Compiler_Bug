{"sha": "a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZjMGE3NmM1ZjllYjIxNmI1ZjA4ZmZjNDYyNGE2ZDAzOWNhMzk3Nw==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2004-07-20T09:57:13Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2004-07-20T09:57:13Z"}, "message": "c-common.h (check_case_value): Remove prototype.\n\n        * c-common.h (check_case_value): Remove prototype.\n        (c_add_case_label): Adjust prototype.\n        * c-common.c (check_case_value): Make static.\n        (check_case_bounds): New function.\n        (c_add_case_label): Use it.  Take new argument orig_type.\n        * c-typeck.c (struct c_switch): New orig_type field.\n        (c_start_case): Set it.\n        (do_case): Pass it to c_add_case_label.\n        * expr.c (expand_expr_real_1): Don't warn for out-of-bounds\n        cases from here.  Add the labels in reverse order.\n        * stmt.c (struct case_node): Adjust comment.  Remove balance field.\n        (add_case_node): Return nothing, don't check for duplicate cases.\n        Insert new case nodes in a list, not in an AVL tree.\n        (expand_end_case_type): Don't turn a case tree into a case list.\n        (case_tree2list): Remove.\n        * tree.h (add_case_node): Adjust prototype.\n\ncp/\n        * cp-tree.h (struct lang_decl_flags): Unify the template_info and\n        thunk_alias, and the access and virtual_offset fields.\n        (THUNK_VIRTUAL_OFFSET, THUNK_ALIAS): Adjust.\n        * decl.c (finish_case_label): Update c_add_case_node call.\n\ntestsuite/\n\t* testsuite/gcc.dg/switch-warn-1.c: New test.\n\t* testsuite/gcc.dg/switch-warn-2.c: New test.\n        * gcc.c-torture/compile/pr14730.c: Update\n\nFrom-SVN: r84947", "tree": {"sha": "134a4370313a4f575f6aa704b0deb37112d1b859", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/134a4370313a4f575f6aa704b0deb37112d1b859"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/comments", "author": null, "committer": null, "parents": [{"sha": "5794581363d5c74938f0e200b4c899a5b26229e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5794581363d5c74938f0e200b4c899a5b26229e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5794581363d5c74938f0e200b4c899a5b26229e9"}], "stats": {"total": 572, "additions": 241, "deletions": 331}, "files": [{"sha": "fae5ace8b400fac3df9516f11fc9f46bdae6a535", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -1,3 +1,22 @@\n+2004-07-20  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* c-common.h (check_case_value): Remove prototype.\n+\t(c_add_case_label): Adjust prototype.\n+\t* c-common.c (check_case_value): Make static.\n+\t(check_case_bounds): New function.\n+\t(c_add_case_label): Use it.  Take new argument orig_type.\n+\t* c-typeck.c (struct c_switch): New orig_type field.\n+\t(c_start_case): Set it.\n+\t(do_case): Pass it to c_add_case_label.\n+\t* expr.c (expand_expr_real_1): Don't warn for out-of-bounds\n+\tcases from here.  Add the labels in reverse order.\n+\t* stmt.c (struct case_node): Adjust comment.  Remove balance field.\n+\t(add_case_node): Return nothing, don't check for duplicate cases.\n+\tInsert new case nodes in a list, not in an AVL tree.\n+\t(expand_end_case_type): Don't turn a case tree into a case list.\n+\t(case_tree2list): Remove.\n+\t* tree.h (add_case_node): Adjust prototype.\n+\n 2004-07-19  Paolo Bonzini  <bonzini@gnu.org>\n \n \t* genattr.c (struct range, struct function_unit,"}, {"sha": "093e839b5c83410cd6738d47d4dc4d4308155675", "filename": "gcc/c-common.c", "status": "modified", "additions": 82, "deletions": 3, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -510,6 +510,8 @@ const struct fname_var_t fname_vars[] =\n };\n \n static int constant_fits_type_p (tree, tree);\n+static tree check_case_value (tree);\n+static bool check_case_bounds (tree, tree, tree *, tree *);\n \n static tree handle_packed_attribute (tree *, tree, tree, int, bool *);\n static tree handle_nocommon_attribute (tree *, tree, tree, int, bool *);\n@@ -1400,7 +1402,7 @@ verify_sequence_points (tree expr)\n \f\n /* Validate the expression after `case' and apply default promotions.  */\n \n-tree\n+static tree\n check_case_value (tree value)\n {\n   if (value == NULL_TREE)\n@@ -1436,6 +1438,75 @@ check_case_value (tree value)\n   return value;\n }\n \f\n+/* See if the case values LOW and HIGH are in the range of the original\n+   type (ie. before the default conversion to int) of the switch testing\n+   expression.\n+   TYPE is the promoted type of the testing expression, and ORIG_TYPE is\n+   the type before promiting it.  CASE_LOW_P is a pointer to the lower\n+   bound of the case label, and CASE_HIGH_P is the upper bound or NULL\n+   if the case is not a case range.\n+   The caller has to make sure that we are not called with NULL for\n+   CASE_LOW_P (ie. the defualt case).\n+   Returns true if the case label is in range of ORIG_TYPE (satured or\n+   untouched) or false if the label is out of range.  */\n+\n+static bool\n+check_case_bounds (tree type, tree orig_type,\n+\t\t   tree *case_low_p, tree *case_high_p)\n+{\n+  tree min_value, max_value;\n+  tree case_low = *case_low_p;\n+  tree case_high = case_high_p ? *case_high_p : case_low;\n+\n+  /* If there was a problem with the original type, do nothing.  */\n+  if (orig_type == error_mark_node)\n+    return true;\n+\n+  min_value = TYPE_MIN_VALUE (orig_type);\n+  max_value = TYPE_MAX_VALUE (orig_type);\n+\n+  /* Case label is less than minimum for type.  */\n+  if (tree_int_cst_compare (case_low, min_value) < 0\n+      && tree_int_cst_compare (case_high, min_value) < 0)\n+    {\n+      warning (\"case label value is less than minimum value for type\");\n+      return false;\n+    }\n+ \n+  /* Case value is greater than maximum for type.  */\n+  if (tree_int_cst_compare (case_low, max_value) > 0\n+      && tree_int_cst_compare (case_high, max_value) > 0)\n+    {\n+      warning (\"case label value exceeds maximum value for type\");\n+      return false;\n+    }\n+\n+  /* Saturate lower case label value to minimum.  */\n+  if (tree_int_cst_compare (case_high, min_value) >= 0\n+      && tree_int_cst_compare (case_low, min_value) < 0)\n+    {\n+      warning (\"lower value in case label range\"\n+\t       \" less than minimum value for type\");\n+      case_low = min_value;\n+    }\n+ \n+  /* Saturate upper case label value to maximum.  */\n+  if (tree_int_cst_compare (case_low, max_value) <= 0\n+      && tree_int_cst_compare (case_high, max_value) > 0)\n+    {\n+      warning (\"upper value in case label range\"\n+\t       \" exceeds maximum value for type\");\n+      case_high = max_value;\n+    }\n+\n+  if (*case_low_p != case_low)\n+    *case_low_p = convert (type, case_low);\n+  if (case_high_p && *case_high_p != case_high)\n+    *case_high_p = convert (type, case_high);\n+\n+  return true;\n+}\n+\f\n /* Return an integer type with BITS bits of precision,\n    that is unsigned if UNSIGNEDP is nonzero, otherwise signed.  */\n \n@@ -3402,8 +3473,8 @@ case_compare (splay_tree_key k1, splay_tree_key k2)\n    ERROR_MARK_NODE if no CASE_LABEL_EXPR is created.  */\n \n tree\n-c_add_case_label (splay_tree cases, tree cond, tree low_value,\n-\t\t  tree high_value)\n+c_add_case_label (splay_tree cases, tree cond, tree orig_type,\n+\t\t  tree low_value, tree high_value)\n {\n   tree type;\n   tree label;\n@@ -3453,6 +3524,14 @@ c_add_case_label (splay_tree cases, tree cond, tree low_value,\n       && !tree_int_cst_lt (low_value, high_value))\n     warning (\"empty range specified\");\n \n+  /* See if the case is in range of the type of the original testing\n+     expression.  If both low_value and high_value are out of range,\n+     don't insert the case label and return NULL_TREE.  */\n+  if (low_value\n+      && ! check_case_bounds (type, orig_type,\n+\t\t\t      &low_value, high_value ? &high_value : NULL))\n+    return NULL_TREE;\n+\n   /* Look up the LOW_VALUE in the table of case labels we already\n      have.  */\n   node = splay_tree_lookup (cases, (splay_tree_key) low_value);"}, {"sha": "8529acec8f6654c3f50f9bf3b43baf0d60df34ab", "filename": "gcc/c-common.h", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -644,8 +644,6 @@ extern void binary_op_error (enum tree_code);\n #define my_friendly_assert(EXP, N) (void) \\\n  (((EXP) == 0) ? (fancy_abort (__FILE__, __LINE__, __FUNCTION__), 0) : 0)\n \n-/* Validate the expression after `case' and apply default promotions.  */\n-extern tree check_case_value (tree);\n extern tree fix_string_type (tree);\n struct varray_head_tag;\n extern void constant_expression_warning (tree);\n@@ -818,7 +816,7 @@ extern void extract_interface_info (void);\n \n extern int case_compare (splay_tree_key, splay_tree_key);\n \n-extern tree c_add_case_label (splay_tree, tree, tree, tree);\n+extern tree c_add_case_label (splay_tree, tree, tree, tree, tree);\n \n extern void c_do_switch_warnings (splay_tree, tree);\n "}, {"sha": "82b0108bee3dad454d66f2cfaf14cfd970fb92ea", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -6270,12 +6270,18 @@ c_finish_return (tree retval)\n struct c_switch {\n   /* The SWITCH_STMT being built.  */\n   tree switch_stmt;\n+\n+  /* The original type of the testing expression, ie. before the\n+     default conversion is applied.  */\n+  tree orig_type;\n+\n   /* A splay-tree mapping the low element of a case range to the high\n      element, or NULL_TREE if there is no high element.  Used to\n      determine whether or not a new case label duplicates an old case\n      label.  We need a tree, rather than simply a hash table, because\n      of the GNU case range extension.  */\n   splay_tree cases;\n+\n   /* The next node on the stack.  */\n   struct c_switch *next;\n };\n@@ -6326,6 +6332,7 @@ c_start_case (tree exp)\n   /* Add this new SWITCH_STMT to the stack.  */\n   cs = xmalloc (sizeof (*cs));\n   cs->switch_stmt = build_stmt (SWITCH_STMT, exp, NULL_TREE, orig_type);\n+  cs->orig_type = orig_type;\n   cs->cases = splay_tree_new (case_compare, NULL, NULL);\n   cs->next = c_switch_stack;\n   c_switch_stack = cs;\n@@ -6344,6 +6351,7 @@ do_case (tree low_value, tree high_value)\n     {\n       label = c_add_case_label (c_switch_stack->cases,\n \t\t\t\tSWITCH_COND (c_switch_stack->switch_stmt),\n+\t\t\t\tc_switch_stack->orig_type,\n \t\t\t\tlow_value, high_value);\n       if (label == error_mark_node)\n \tlabel = NULL_TREE;"}, {"sha": "0a038fc88dd46b7ff23101f893ed9697820d71b7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -1,3 +1,10 @@\n+2004-07-20  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* cp-tree.h (struct lang_decl_flags): Unify the template_info and\n+\tthunk_alias, and the access and virtual_offset fields.\n+\t(THUNK_VIRTUAL_OFFSET, THUNK_ALIAS): Adjust.\n+\t* decl.c (finish_case_label): Update c_add_case_node call.\n+\n 2004-07-19  Mark Mitchell  <mark@codesourcery.com>\n \n \tRevert patch for PR c++/16623."}, {"sha": "4b717de85f98b67c79b07076963849cca243ade0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -1544,29 +1544,25 @@ struct lang_decl_flags GTY(())\n   unsigned this_thunk_p : 1;\n \n   union lang_decl_u {\n-    /* In a FUNCTION_DECL for which DECL_THUNK_P does not hold,\n+    /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n+       THUNK_ALIAS.\n+       In a FUNCTION_DECL for which DECL_THUNK_P does not hold,\n        VAR_DECL, TYPE_DECL, or TEMPLATE_DECL, this is\n        DECL_TEMPLATE_INFO.  */\n     tree GTY ((tag (\"0\"))) template_info;\n \n     /* In a NAMESPACE_DECL, this is NAMESPACE_LEVEL.  */\n     struct cp_binding_level * GTY ((tag (\"1\"))) level;\n-\n-    /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n-       THUNK_ALIAS.  */\n-    tree GTY ((tag (\"2\"))) thunk_alias;\n   } GTY ((desc (\"%1.u1sel\"))) u;\n \n   union lang_decl_u2 {\n-    /* This is DECL_ACCESS.  */\n+    /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n+       THUNK_VIRTUAL_OFFSET.\n+       Otherwise this is DECL_ACCESS.  */\n     tree GTY ((tag (\"0\"))) access;\n \n     /* For VAR_DECL in function, this is DECL_DISCRIMINATOR.  */\n     int GTY ((tag (\"1\"))) discriminator;\n-\n-    /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n-       THUNK_VIRTUAL_OFFSET.  */\n-    tree GTY((tag (\"2\"))) virtual_offset;\n   } GTY ((desc (\"%1.u2sel\"))) u2;\n };\n \n@@ -2827,11 +2823,11 @@ struct lang_decl GTY(())\n    binfos.)  */\n \n #define THUNK_VIRTUAL_OFFSET(DECL) \\\n-  (LANG_DECL_U2_CHECK (FUNCTION_DECL_CHECK (DECL), 0)->virtual_offset)\n+  (LANG_DECL_U2_CHECK (FUNCTION_DECL_CHECK (DECL), 0)->access)\n \n /* A thunk which is equivalent to another thunk.  */\n #define THUNK_ALIAS(DECL) \\\n-  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->decl_flags.u.thunk_alias)\n+  (DECL_LANG_SPECIFIC (FUNCTION_DECL_CHECK (DECL))->decl_flags.u.template_info)\n \n /* For thunk NODE, this is the FUNCTION_DECL thunked to.  */\n #define THUNK_TARGET(NODE)\t\t\t\t\\"}, {"sha": "2d4fa895b5035a5add02a56d6ea27b28ac2b4e53", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -2444,7 +2444,8 @@ finish_case_label (tree low_value, tree high_value)\n   if (cond && TREE_CODE (cond) == TREE_LIST)\n     cond = TREE_VALUE (cond);\n \n-  r = c_add_case_label (switch_stack->cases, cond, low_value, high_value);\n+  r = c_add_case_label (switch_stack->cases, cond, TREE_TYPE (cond),\n+\t\t\tlow_value, high_value);\n \n   check_switch_goto (switch_stack->level);\n "}, {"sha": "858a7ff2400159b5cbe2c49db20f8b1f71bee025", "filename": "gcc/expr.c", "status": "modified", "additions": 8, "deletions": 56, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -8569,67 +8569,19 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n         abort ();\n       if (SWITCH_LABELS (exp))\n \t{\n-\t  tree duplicate = 0;\n \t  tree vec = SWITCH_LABELS (exp);\n-\t  size_t i, n = TREE_VEC_LENGTH (vec);\n+\t  size_t i = TREE_VEC_LENGTH (vec);\n \n-\t  for (i = 0; i < n; ++i)\n+\t  do\n \t    {\n-\t      tree elt = TREE_VEC_ELT (vec, i);\n-\t      tree controlling_expr_type = TREE_TYPE (SWITCH_COND (exp));\n-\t      tree min_value = TYPE_MIN_VALUE (controlling_expr_type);\n-\t      tree max_value = TYPE_MAX_VALUE (controlling_expr_type);\n-\t      \n-\t      tree case_low = CASE_LOW (elt);\n-\t      tree case_high = CASE_HIGH (elt) ? CASE_HIGH (elt) : case_low;\n-\t      if (case_low && case_high)\n-\t\t{\n-\t\t  /* Case label is less than minimum for type.  */\n-\t\t  if (TREE_CODE (min_value) == INTEGER_CST\n-\t\t      && tree_int_cst_compare (case_low, min_value) < 0\n-\t\t      && tree_int_cst_compare (case_high, min_value) < 0)\n-\t\t    {\n-\t\t      warning (\"case label value %d is less than minimum value for type\",\n-\t\t\t       TREE_INT_CST (case_low));\n-\t\t      continue;\n-\t\t    }\n-\t\t  \n-\t\t  /* Case value is greater than maximum for type.  */\n-\t\t  if (TREE_CODE (max_value) == INTEGER_CST\n-\t\t      && tree_int_cst_compare (case_low, max_value) > 0\n-\t\t      && tree_int_cst_compare (case_high, max_value) > 0)\n-\t\t    {\n-\t\t      warning (\"case label value %d exceeds maximum value for type\",\n-\t\t\t       TREE_INT_CST (case_high));\n-\t\t      continue;\n-\t\t    }\n-\t\t  \n-\t\t  /* Saturate lower case label value to minimum.  */\n-\t\t  if (TREE_CODE (min_value) == INTEGER_CST\n-\t\t      && tree_int_cst_compare (case_high, min_value) >= 0\n-\t\t      && tree_int_cst_compare (case_low, min_value) < 0)\n-\t\t    {\n-\t\t      warning (\"lower value %d in case label range less than minimum value for type\",\n-\t\t\t       TREE_INT_CST (case_low));\n-\t\t      case_low = min_value;\n-\t\t    }\n-\t\t  \n-\t\t  /* Saturate upper case label value to maximum.  */\n-\t\t  if (TREE_CODE (max_value) == INTEGER_CST\n-\t\t      && tree_int_cst_compare (case_low, max_value) <= 0\n-\t\t      && tree_int_cst_compare (case_high, max_value) > 0)\n-\t\t    {\n-\t\t      warning (\"upper value %d in case label range exceeds maximum value for type\",\n-\t\t\t       TREE_INT_CST (case_high));\n-\t\t      case_high = max_value;\n-\t\t    }\n-\t\t}\n-\t      \n-\t      add_case_node (case_low, case_high, CASE_LABEL (elt), &duplicate);\n-\t      if (duplicate)\n-\t\tabort ();\n+\t      tree elt = TREE_VEC_ELT (vec, --i);\n+\t      add_case_node (CASE_LOW (elt), CASE_HIGH (elt),\n+\t\t\t     CASE_LABEL (elt));\n \t    }\n+\t  while (i);\n \t}\n+      else\n+\tabort ();\n       expand_end_case_type (SWITCH_COND (exp), TREE_TYPE (exp));\n       return const0_rtx;\n "}, {"sha": "6d3043b3869315de83979086e61c336cfe53ab6d", "filename": "gcc/stmt.c", "status": "modified", "additions": 31, "deletions": 254, "changes": 285, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -66,12 +66,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    statements.  We handle \"range\" labels; for a single-value label\n    as in C, the high and low limits are the same.\n \n-   An AVL tree of case nodes is initially created, and later transformed\n-   to a list linked via the RIGHT fields in the nodes.  Nodes with\n-   higher case values are later in the list.\n-\n-   Switch statements can be output in one of two forms.  A branch table\n-   is used if there are more than a few labels and the labels are dense\n+   We start with a vector of case nodes sorted in ascending order, and\n+   the default label as the last element in the vector.  Before expanding\n+   to RTL, we transform this vector into a list linked via the RIGHT\n+   fields in the case_node struct.  Nodes with higher case values are\n+   later in the list.\n+\n+   Switch statements can be output in three forms.  A branch table is\n+   used if there are more than a few labels and the labels are dense\n    within the range between the smallest and largest case value.  If a\n    branch table is used, no further manipulations are done with the case\n    node chain.\n@@ -82,7 +84,10 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    totally unbalanced, with everything on the right.  We balance the tree\n    with nodes on the left having lower case values than the parent\n    and nodes on the right having higher values.  We then output the tree\n-   in order.  */\n+   in order.\n+\n+   For very small, suitable switch statements, we can generate a series\n+   of simple bit test and branches instead.  */\n \n struct case_node GTY(())\n {\n@@ -92,7 +97,6 @@ struct case_node GTY(())\n   tree\t\t\tlow;\t/* Lowest index value for this label */\n   tree\t\t\thigh;\t/* Highest index value for this label */\n   tree\t\t\tcode_label; /* Label to jump to when node matches */\n-  int\t\t\tbalance;\n };\n \n typedef struct case_node case_node;\n@@ -274,7 +278,6 @@ static int node_has_low_bound (case_node_ptr, tree);\n static int node_has_high_bound (case_node_ptr, tree);\n static int node_is_bounded (case_node_ptr, tree);\n static void emit_case_nodes (rtx, case_node_ptr, rtx, tree);\n-static struct case_node *case_tree2list (case_node *, case_node *);\n \f\n void\n init_stmt_for_function (void)\n@@ -2727,241 +2730,42 @@ expand_start_case (tree index_expr)\n }\n \n /* Do the insertion of a case label into\n-   case_stack->data.case_stmt.case_list.  Use an AVL tree to avoid\n-   slowdown for large switch statements.  */\n+   case_stack->data.case_stmt.case_list.  The labels are fed to us\n+   in descending order from the sorted vector of case labels used\n+   in the tree part of the middle end.  So the list we construct is\n+   sorted in ascending order.  */\n \n-int\n-add_case_node (tree low, tree high, tree label, tree *duplicate)\n+void\n+add_case_node (tree low, tree high, tree label)\n {\n-  struct case_node *p, **q, *r;\n+  struct case_node *r;\n \n   /* If there's no HIGH value, then this is not a case range; it's\n      just a simple case label.  But that's just a degenerate case\n-     range.  */\n-  if (!high)\n+     range.\n+     If the bounds are equal, turn this into the one-value case.  */\n+  if (!high || tree_int_cst_equal (low, high))\n     high = low;\n \n   /* Handle default labels specially.  */\n   if (!high && !low)\n     {\n+#ifdef ENABLE_CHECKING\n       if (case_stack->data.case_stmt.default_label != 0)\n-\t{\n-\t  *duplicate = case_stack->data.case_stmt.default_label;\n-\t  return 2;\n-\t}\n+\tabort ();\n+#endif\n       case_stack->data.case_stmt.default_label = label;\n-      return 0;\n-    }\n-\n-  q = &case_stack->data.case_stmt.case_list;\n-  p = *q;\n-\n-  while ((r = *q))\n-    {\n-      p = r;\n-\n-      /* Keep going past elements distinctly greater than HIGH.  */\n-      if (tree_int_cst_lt (high, p->low))\n-\tq = &p->left;\n-\n-      /* or distinctly less than LOW.  */\n-      else if (tree_int_cst_lt (p->high, low))\n-\tq = &p->right;\n-\n-      else\n-\t{\n-\t  /* We have an overlap; this is an error.  */\n-\t  *duplicate = p->code_label;\n-\t  return 2;\n-\t}\n+      return;\n     }\n \n-  /* Add this label to the chain, and succeed.  */\n-\n+  /* Add this label to the chain.  */\n   r = ggc_alloc (sizeof (struct case_node));\n   r->low = low;\n-\n-  /* If the bounds are equal, turn this into the one-value case.  */\n-  if (tree_int_cst_equal (low, high))\n-    r->high = r->low;\n-  else\n-    r->high = high;\n-\n+  r->high = high;\n   r->code_label = label;\n-\n-  *q = r;\n-  r->parent = p;\n-  r->left = 0;\n-  r->right = 0;\n-  r->balance = 0;\n-\n-  while (p)\n-    {\n-      struct case_node *s;\n-\n-      if (r == p->left)\n-\t{\n-\t  int b;\n-\n-\t  if (! (b = p->balance))\n-\t    /* Growth propagation from left side.  */\n-\t    p->balance = -1;\n-\t  else if (b < 0)\n-\t    {\n-\t      if (r->balance < 0)\n-\t\t{\n-\t\t  /* R-Rotation */\n-\t\t  if ((p->left = s = r->right))\n-\t\t    s->parent = p;\n-\n-\t\t  r->right = p;\n-\t\t  p->balance = 0;\n-\t\t  r->balance = 0;\n-\t\t  s = p->parent;\n-\t\t  p->parent = r;\n-\n-\t\t  if ((r->parent = s))\n-\t\t    {\n-\t\t      if (s->left == p)\n-\t\t\ts->left = r;\n-\t\t      else\n-\t\t\ts->right = r;\n-\t\t    }\n-\t\t  else\n-\t\t    case_stack->data.case_stmt.case_list = r;\n-\t\t}\n-\t      else\n-\t\t/* r->balance == +1 */\n-\t\t{\n-\t\t  /* LR-Rotation */\n-\n-\t\t  int b2;\n-\t\t  struct case_node *t = r->right;\n-\n-\t\t  if ((p->left = s = t->right))\n-\t\t    s->parent = p;\n-\n-\t\t  t->right = p;\n-\t\t  if ((r->right = s = t->left))\n-\t\t    s->parent = r;\n-\n-\t\t  t->left = r;\n-\t\t  b = t->balance;\n-\t\t  b2 = b < 0;\n-\t\t  p->balance = b2;\n-\t\t  b2 = -b2 - b;\n-\t\t  r->balance = b2;\n-\t\t  t->balance = 0;\n-\t\t  s = p->parent;\n-\t\t  p->parent = t;\n-\t\t  r->parent = t;\n-\n-\t\t  if ((t->parent = s))\n-\t\t    {\n-\t\t      if (s->left == p)\n-\t\t\ts->left = t;\n-\t\t      else\n-\t\t\ts->right = t;\n-\t\t    }\n-\t\t  else\n-\t\t    case_stack->data.case_stmt.case_list = t;\n-\t\t}\n-\t      break;\n-\t    }\n-\n-\t  else\n-\t    {\n-\t      /* p->balance == +1; growth of left side balances the node.  */\n-\t      p->balance = 0;\n-\t      break;\n-\t    }\n-\t}\n-      else\n-\t/* r == p->right */\n-\t{\n-\t  int b;\n-\n-\t  if (! (b = p->balance))\n-\t    /* Growth propagation from right side.  */\n-\t    p->balance++;\n-\t  else if (b > 0)\n-\t    {\n-\t      if (r->balance > 0)\n-\t\t{\n-\t\t  /* L-Rotation */\n-\n-\t\t  if ((p->right = s = r->left))\n-\t\t    s->parent = p;\n-\n-\t\t  r->left = p;\n-\t\t  p->balance = 0;\n-\t\t  r->balance = 0;\n-\t\t  s = p->parent;\n-\t\t  p->parent = r;\n-\t\t  if ((r->parent = s))\n-\t\t    {\n-\t\t      if (s->left == p)\n-\t\t\ts->left = r;\n-\t\t      else\n-\t\t\ts->right = r;\n-\t\t    }\n-\n-\t\t  else\n-\t\t    case_stack->data.case_stmt.case_list = r;\n-\t\t}\n-\n-\t      else\n-\t\t/* r->balance == -1 */\n-\t\t{\n-\t\t  /* RL-Rotation */\n-\t\t  int b2;\n-\t\t  struct case_node *t = r->left;\n-\n-\t\t  if ((p->right = s = t->left))\n-\t\t    s->parent = p;\n-\n-\t\t  t->left = p;\n-\n-\t\t  if ((r->left = s = t->right))\n-\t\t    s->parent = r;\n-\n-\t\t  t->right = r;\n-\t\t  b = t->balance;\n-\t\t  b2 = b < 0;\n-\t\t  r->balance = b2;\n-\t\t  b2 = -b2 - b;\n-\t\t  p->balance = b2;\n-\t\t  t->balance = 0;\n-\t\t  s = p->parent;\n-\t\t  p->parent = t;\n-\t\t  r->parent = t;\n-\n-\t\t  if ((t->parent = s))\n-\t\t    {\n-\t\t      if (s->left == p)\n-\t\t\ts->left = t;\n-\t\t      else\n-\t\t\ts->right = t;\n-\t\t    }\n-\n-\t\t  else\n-\t\t    case_stack->data.case_stmt.case_list = t;\n-\t\t}\n-\t      break;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* p->balance == -1; growth of right side balances the node.  */\n-\t      p->balance = 0;\n-\t      break;\n-\t    }\n-\t}\n-\n-      r = p;\n-      p = p->parent;\n-    }\n-\n-  return 0;\n+  r->parent = r->left = NULL;\n+  r->right = case_stack->data.case_stmt.case_list;\n+  case_stack->data.case_stmt.case_list = r;\n }\n \f\n /* Maximum number of case bit tests.  */\n@@ -3174,11 +2978,6 @@ expand_end_case_type (tree orig_index, tree orig_type)\n \n       before_case = get_last_insn ();\n \n-      if (thiscase->data.case_stmt.case_list\n-\t  && thiscase->data.case_stmt.case_list->left)\n-\tthiscase->data.case_stmt.case_list\n-\t  = case_tree2list (thiscase->data.case_stmt.case_list, 0);\n-\n       /* Get upper and lower bounds of case values.\n \t Also convert all the case values to the index expr's data type.  */\n \n@@ -3446,28 +3245,6 @@ expand_end_case_type (tree orig_index, tree orig_type)\n   free_temp_slots ();\n }\n \n-/* Convert the tree NODE into a list linked by the right field, with the left\n-   field zeroed.  RIGHT is used for recursion; it is a list to be placed\n-   rightmost in the resulting list.  */\n-\n-static struct case_node *\n-case_tree2list (struct case_node *node, struct case_node *right)\n-{\n-  struct case_node *left;\n-\n-  if (node->right)\n-    right = case_tree2list (node->right, right);\n-\n-  node->right = right;\n-  if ((left = node->left))\n-    {\n-      node->left = 0;\n-      return case_tree2list (left, node);\n-    }\n-\n-  return node;\n-}\n-\n /* Generate code to jump to LABEL if OP1 and OP2 are equal.  */\n \n static void"}, {"sha": "51c125813d8b07630e30cc5400088c0eed7f02a3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -1,3 +1,9 @@\n+2004-07-20  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* testsuite/gcc.dg/switch-warn-1.c: New test.\n+\t* testsuite/gcc.dg/switch-warn-2.c: New test.\n+\t* gcc.c-torture/compile/pr14730.c: Update.\n+\n 2004-07-19  Kelley Cook  <kcook@gcc.gnu.org>\n \n \t* g++.dg/lookup/java1.C, g++.dg/lookup/java2.C, g++.dg/other/crash-2.C,"}, {"sha": "6f08ab4658fd2149928d9f468ad2314c646445d3", "filename": "gcc/testsuite/gcc.c-torture/compile/pr14730.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr14730.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr14730.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2Fpr14730.c?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -12,5 +12,5 @@ int t (char i)\n     case 256:\n       return 0;\n     }\n-  return 0;\n+  return 1;\n }"}, {"sha": "d98bfa892d6a3dfe95c1735ad329b4d302ab602c", "filename": "gcc/testsuite/gcc.dg/switch-warn-1.c", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-warn-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-warn-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-warn-1.c?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -0,0 +1,44 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O0\" } */\n+\n+/* Check that out-of-bounds case warnings work in the case that the\n+   testing expression is promoted.  */\n+int\n+foo1 (unsigned char i)\n+{\n+  switch (i)\n+    {\n+    case -1:   /* { dg-warning \"case label value is less than minimum value for type\" } */\n+      return 1;\n+    case 256:  /* { dg-warning \"case label value exceeds maximum value for type\" } */\n+      return 2;\n+    default:\n+      return 3;\n+    }\n+}\n+\n+/* Like above, but for case ranges that need to be satured.  */\n+int\n+foo2 (unsigned char i)\n+{\n+  switch (i)\n+    {\n+    case -1 ... 1:   /* { dg-warning \"lower value in case label range less than minimum value for type\" } */\n+      return 1;\n+    case 254 ... 256:  /* { dg-warning \"upper value in case label range exceeds maximum value for type\" } */\n+      return 2;\n+    default:\n+      return 3;\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  if (foo1 (10) != 3)\n+    abort ();\n+  if (foo2 (10) != 3)\n+    abort ();\n+  exit (0);\n+}\n+"}, {"sha": "ab742669163f941524bc8912985238fe37327e75", "filename": "gcc/testsuite/gcc.dg/switch-warn-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-warn-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-warn-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fswitch-warn-2.c?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -0,0 +1,23 @@\n+/* This should not warn about the case label being out of range.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O0\" } */\n+\n+int\n+foo (unsigned int i)\n+{\n+  switch (i)\n+  {\n+    case 123456123456ULL: /* { dg-warning \"large integer implicitly truncated to unsigned type\" } */\n+      return 0;\n+    default:\n+      return 3;\n+  }\n+}\n+\n+int\n+main (void)\n+{\n+  if (foo (10) != 3)\n+    abort ();\n+  exit (0);\n+}"}, {"sha": "f37c7a355daec7c046d25b8626c42a227db218a2", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=a6c0a76c5f9eb216b5f08ffc4624a6d039ca3977", "patch": "@@ -3361,7 +3361,7 @@ extern struct nesting * current_nesting_level (void);\n extern void expand_start_case (tree);\n extern void expand_end_case_type (tree, tree);\n #define expand_end_case(cond) expand_end_case_type (cond, NULL)\n-extern int add_case_node (tree, tree, tree, tree *);\n+extern void add_case_node (tree, tree, tree);\n \n /* In tree-eh.c */\n extern void using_eh_for_cleanups (void);"}]}