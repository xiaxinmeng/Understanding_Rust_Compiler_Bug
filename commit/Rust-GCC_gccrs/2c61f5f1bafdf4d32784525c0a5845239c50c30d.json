{"sha": "2c61f5f1bafdf4d32784525c0a5845239c50c30d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM2MWY1ZjFiYWZkZjRkMzI3ODQ1MjVjMGE1ODQ1MjM5YzUwYzMwZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-08-21T00:00:14Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-08-21T00:00:14Z"}, "message": "re PR middle-end/28071 (A file that can not be compiled in reasonable time/space)\n\n\tPR rtl-optimization/28071\n\t* reload1.c (reg_has_output_reload): Turn into regset.\n\t(reload_as_needed, forget_old_reloads_1, forget_marked_reloads,\n\tchoose_reload_regs, emit_reload_insns): Update to new\n\treg_has_output_reload.\n\nFrom-SVN: r116277", "tree": {"sha": "51e52f845eb47d6363cca6ae2beac3a5940c95c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51e52f845eb47d6363cca6ae2beac3a5940c95c8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c61f5f1bafdf4d32784525c0a5845239c50c30d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c61f5f1bafdf4d32784525c0a5845239c50c30d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c61f5f1bafdf4d32784525c0a5845239c50c30d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c61f5f1bafdf4d32784525c0a5845239c50c30d/comments", "author": null, "committer": null, "parents": [{"sha": "015c2c66b2dd446ba94955f0794ca06ce3b0d267", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/015c2c66b2dd446ba94955f0794ca06ce3b0d267", "html_url": "https://github.com/Rust-GCC/gccrs/commit/015c2c66b2dd446ba94955f0794ca06ce3b0d267"}], "stats": {"total": 42, "additions": 29, "deletions": 13}, "files": [{"sha": "513277212df2ccacdc36a2f8e49c4520ac7463e3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c61f5f1bafdf4d32784525c0a5845239c50c30d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c61f5f1bafdf4d32784525c0a5845239c50c30d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c61f5f1bafdf4d32784525c0a5845239c50c30d", "patch": "@@ -1,3 +1,11 @@\n+2006-08-20  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR rtl-optimization/28071\n+\t* reload1.c (reg_has_output_reload): Turn into regset.\n+\t(reload_as_needed, forget_old_reloads_1, forget_marked_reloads,\n+\tchoose_reload_regs, emit_reload_insns): Update to new\n+\treg_has_output_reload.\n+\n 2006-08-20  Jan Hubicka  <jh@suse.cz>\n \n \tPR middle-end/28779"}, {"sha": "0c76942283153e6da9daa194a7b7bc44b13fcfd3", "filename": "gcc/reload1.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c61f5f1bafdf4d32784525c0a5845239c50c30d/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c61f5f1bafdf4d32784525c0a5845239c50c30d/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=2c61f5f1bafdf4d32784525c0a5845239c50c30d", "patch": "@@ -87,7 +87,7 @@ static rtx *reg_last_reload_reg;\n \n /* Elt N nonzero if reg_last_reload_reg[N] has been set in this insn\n    for an output reload that stores into reg N.  */\n-static char *reg_has_output_reload;\n+static regset_head reg_has_output_reload;\n \n /* Indicates which hard regs are reload-registers for an output reload\n    in the current insn.  */\n@@ -3889,7 +3889,7 @@ reload_as_needed (int live_known)\n   memset (spill_reg_rtx, 0, sizeof spill_reg_rtx);\n   memset (spill_reg_store, 0, sizeof spill_reg_store);\n   reg_last_reload_reg = XCNEWVEC (rtx, max_regno);\n-  reg_has_output_reload = XNEWVEC (char, max_regno);\n+  INIT_REG_SET (&reg_has_output_reload);\n   CLEAR_HARD_REG_SET (reg_reloaded_valid);\n   CLEAR_HARD_REG_SET (reg_reloaded_call_part_clobbered);\n \n@@ -3952,7 +3952,7 @@ reload_as_needed (int live_known)\n \t     rtx's for those pseudo regs.  */\n \t  else\n \t    {\n-\t      memset (reg_has_output_reload, 0, max_regno);\n+\t      CLEAR_REG_SET (&reg_has_output_reload);\n \t      CLEAR_HARD_REG_SET (reg_is_output_reload);\n \n \t      find_reloads (insn, 1, spill_indirect_levels, live_known,\n@@ -4106,7 +4106,8 @@ reload_as_needed (int live_known)\n \t\t\t     the reload for inheritance.  */\n \t\t\t  SET_HARD_REG_BIT (reg_is_output_reload,\n \t\t\t\t\t    REGNO (reload_reg));\n-\t\t\t  reg_has_output_reload[REGNO (XEXP (in_reg, 0))] = 1;\n+\t\t\t  SET_REGNO_REG_SET (&reg_has_output_reload,\n+\t\t\t\t\t     REGNO (XEXP (in_reg, 0)));\n \t\t\t}\n \t\t      else\n \t\t\tforget_old_reloads_1 (XEXP (in_reg, 0), NULL_RTX,\n@@ -4122,7 +4123,8 @@ reload_as_needed (int live_known)\n \t\t    {\n \t\t      SET_HARD_REG_BIT (reg_is_output_reload,\n \t\t\t\t\tREGNO (rld[i].reg_rtx));\n-\t\t      reg_has_output_reload[REGNO (XEXP (in_reg, 0))] = 1;\n+\t\t      SET_REGNO_REG_SET (&reg_has_output_reload,\n+\t\t\t\t\t REGNO (XEXP (in_reg, 0)));\n \t\t    }\n \t\t}\n \t    }\n@@ -4160,7 +4162,7 @@ reload_as_needed (int live_known)\n \n   /* Clean up.  */\n   free (reg_last_reload_reg);\n-  free (reg_has_output_reload);\n+  CLEAR_REG_SET (&reg_has_output_reload);\n }\n \n /* Discard all record of any value reloaded from X,\n@@ -4231,7 +4233,8 @@ forget_old_reloads_1 (rtx x, rtx ignored ATTRIBUTE_UNUSED,\n       while (nr-- > 0)\n \t/* But don't forget a copy if this is the output reload\n \t   that establishes the copy's validity.  */\n-\tif (n_reloads == 0 || reg_has_output_reload[regno + nr] == 0)\n+\tif (n_reloads == 0\n+\t    || !REGNO_REG_SET_P (&reg_has_output_reload, regno + nr))\n \t  reg_last_reload_reg[regno + nr] = 0;\n      }\n }\n@@ -4254,7 +4257,8 @@ forget_marked_reloads (regset regs)\n \t    CLEAR_HARD_REG_BIT (reg_reloaded_call_part_clobbered, reg);\n \t    spill_reg_store[reg] = 0;\n \t  }\n-      if (n_reloads == 0 || reg_has_output_reload[reg] == 0)\n+      if (n_reloads == 0\n+\t  || !REGNO_REG_SET_P (&reg_has_output_reload, reg))\n \treg_last_reload_reg[reg] = 0;\n     }\n }\n@@ -6084,7 +6088,8 @@ choose_reload_regs (struct insn_chain *chain)\n \t    nr = hard_regno_nregs[nregno][rld[r].mode];\n \n \t  while (--nr >= 0)\n-\t    reg_has_output_reload[nregno + nr] = 1;\n+\t    SET_REGNO_REG_SET (&reg_has_output_reload,\n+\t\t\t       nregno + nr);\n \n \t  if (i >= 0)\n \t    {\n@@ -7274,7 +7279,7 @@ emit_reload_insns (struct insn_chain *chain)\n \n \t  if (REG_P (reg)\n \t      && REGNO (reg) >= FIRST_PSEUDO_REGISTER\n-\t      && ! reg_has_output_reload[REGNO (reg)])\n+\t      && !REGNO_REG_SET_P (&reg_has_output_reload, REGNO (reg)))\n \t    {\n \t      int nregno = REGNO (reg);\n \n@@ -7385,9 +7390,11 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t       && rld[r].in != 0\n \t\t       && ((REG_P (rld[r].in)\n \t\t\t    && REGNO (rld[r].in) >= FIRST_PSEUDO_REGISTER\n-\t\t\t    && ! reg_has_output_reload[REGNO (rld[r].in)])\n+\t                    && !REGNO_REG_SET_P (&reg_has_output_reload,\n+\t\t\t      \t\t\t REGNO (rld[r].in))\n \t\t\t   || (REG_P (rld[r].in_reg)\n-\t\t\t       && ! reg_has_output_reload[REGNO (rld[r].in_reg)]))\n+\t\t\t       && !REGNO_REG_SET_P (&reg_has_output_reload,\n+\t\t\t\t\t\t    REGNO (rld[r].in)))))\n \t\t       && ! reg_set_p (rld[r].reg_rtx, PATTERN (insn)))\n \t\t{\n \t\t  int nregno;\n@@ -7545,7 +7552,8 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t  /* We have to set reg_has_output_reload here, or else \n \t\t     forget_old_reloads_1 will clear reg_last_reload_reg\n \t\t     right away.  */\n-\t\t  reg_has_output_reload[nregno] = 1;\n+\t\t  SET_REGNO_REG_SET (&reg_has_output_reload,\n+\t\t\t\t     nregno);\n \t\t}\n \t    }\n \t  else"}]}