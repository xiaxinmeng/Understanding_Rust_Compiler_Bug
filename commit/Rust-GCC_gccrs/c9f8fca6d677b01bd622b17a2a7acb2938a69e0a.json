{"sha": "c9f8fca6d677b01bd622b17a2a7acb2938a69e0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzlmOGZjYTZkNjc3YjAxYmQ2MjJiMTdhMmE3YWNiMjkzOGE2OWUwYQ==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2018-08-03T11:31:22Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@gcc.gnu.org", "date": "2018-08-03T11:31:22Z"}, "message": "Makefile.in (wide-int-range.o): New.\n\n\t* Makefile.in (wide-int-range.o): New.\n\t* tree-vrp.c: Move all the wide_int_* functions to...\n\t* wide-int-range.cc: ...here.\n\t* tree-vrp.h: Move all the wide_int_* prototypes to...\n\t* wide-int-range.h: ...here.\n\nFrom-SVN: r263288", "tree": {"sha": "8ae0c2f389a780db93911161b97ae474ce447f49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ae0c2f389a780db93911161b97ae474ce447f49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d989dba8ef02c2406b7c9e62b352197dffc6b880", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d989dba8ef02c2406b7c9e62b352197dffc6b880", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d989dba8ef02c2406b7c9e62b352197dffc6b880"}], "stats": {"total": 1419, "additions": 737, "deletions": 682}, "files": [{"sha": "08e2d79aa69052e5959ac1cb2d7c02cbd4fc4e0e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c9f8fca6d677b01bd622b17a2a7acb2938a69e0a", "patch": "@@ -1,3 +1,11 @@\n+2018-08-03  Aldy Hernandez  <aldyh@redhat.com>\n+\n+\t* Makefile.in (wide-int-range.o): New.\n+\t* tree-vrp.c: Move all the wide_int_* functions to...\n+\t* wide-int-range.cc: ...here.\n+\t* tree-vrp.h: Move all the wide_int_* prototypes to...\n+\t* wide-int-range.h: ...here.\n+\n 2018-08-03  Tom de Vries  <tdevries@suse.de>\n \n \t* common/config/nvptx/nvptx-common.c (nvptx_except_unwind_info): Return"}, {"sha": "e7d818d174c8ec05a89c50942550765a18876a1a", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=c9f8fca6d677b01bd622b17a2a7acb2938a69e0a", "patch": "@@ -1601,6 +1601,7 @@ OBJS = \\\n \tweb.o \\\n \twide-int.o \\\n \twide-int-print.o \\\n+\twide-int-range.o \\\n \txcoffout.o \\\n \t$(out_object_file) \\\n \t$(EXTRA_OBJS) \\"}, {"sha": "e1875d8d46e75f9747fbebbd47e099f8e498b538", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 6, "deletions": 605, "changes": 611, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=c9f8fca6d677b01bd622b17a2a7acb2938a69e0a", "patch": "@@ -67,6 +67,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"attribs.h\"\n #include \"vr-values.h\"\n #include \"builtins.h\"\n+#include \"wide-int-range.h\"\n \n /* Set of SSA names found live during the RPO traversal of the function\n    for still active basic-blocks.  */\n@@ -956,98 +957,7 @@ value_range_constant_singleton (value_range *vr)\n   return NULL_TREE;\n }\n \n-/* Wrapper around wide_int_binop that adjusts for overflow.\n-\n-   Return true if we can compute the result; i.e. if the operation\n-   doesn't overflow or if the overflow is undefined.  In the latter\n-   case (if the operation overflows and overflow is undefined), then\n-   adjust the result to be -INF or +INF depending on CODE, VAL1 and\n-   VAL2.  Return the value in *RES.\n-\n-   Return false for division by zero, for which the result is\n-   indeterminate.  */\n-\n-static bool\n-wide_int_binop_overflow (wide_int &res,\n-\t\t\t enum tree_code code,\n-\t\t\t const wide_int &w0, const wide_int &w1,\n-\t\t\t signop sign, bool overflow_undefined)\n-{\n-  wi::overflow_type overflow;\n-  if (!wide_int_binop (res, code, w0, w1, sign, &overflow))\n-    return false;\n-\n-  /* If the operation overflowed return -INF or +INF depending on the\n-     operation and the combination of signs of the operands.  */\n-  if (overflow && overflow_undefined)\n-    {\n-      switch (code)\n-\t{\n-\tcase MULT_EXPR:\n-\t  /* For multiplication, the sign of the overflow is given\n-\t     by the comparison of the signs of the operands.  */\n-\t  if (sign == UNSIGNED || w0.sign_mask () == w1.sign_mask ())\n-\t    res = wi::max_value (w0.get_precision (), sign);\n-\t  else\n-\t    res = wi::min_value (w0.get_precision (), sign);\n-\t  return true;\n-\n-\tcase TRUNC_DIV_EXPR:\n-\tcase FLOOR_DIV_EXPR:\n-\tcase CEIL_DIV_EXPR:\n-\tcase EXACT_DIV_EXPR:\n-\tcase ROUND_DIV_EXPR:\n-\t  /* For division, the only case is -INF / -1 = +INF.  */\n-\t  res = wi::max_value (w0.get_precision (), sign);\n-\t  return true;\n-\n-\tdefault:\n-\t  gcc_unreachable ();\n-\t}\n-    }\n-  return !overflow;\n-}\n-\n-/* For range [LB, UB] compute two wide_int bit masks.\n-\n-   In the MAY_BE_NONZERO bit mask, if some bit is unset, it means that\n-   for all numbers in the range the bit is 0, otherwise it might be 0\n-   or 1.\n-\n-   In the MUST_BE_NONZERO bit mask, if some bit is set, it means that\n-   for all numbers in the range the bit is 1, otherwise it might be 0\n-   or 1.  */\n-\n-void\n-wide_int_set_zero_nonzero_bits (signop sign,\n-\t\t\t\tconst wide_int &lb, const wide_int &ub,\n-\t\t\t\twide_int &may_be_nonzero,\n-\t\t\t\twide_int &must_be_nonzero)\n-{\n-  may_be_nonzero = wi::minus_one (lb.get_precision ());\n-  must_be_nonzero = wi::zero (lb.get_precision ());\n-\n-  if (wi::eq_p (lb, ub))\n-    {\n-      may_be_nonzero = lb;\n-      must_be_nonzero = may_be_nonzero;\n-    }\n-  else if (wi::ge_p (lb, 0, sign) || wi::lt_p (ub, 0, sign))\n-    {\n-      wide_int xor_mask = lb ^ ub;\n-      may_be_nonzero = lb | ub;\n-      must_be_nonzero = lb & ub;\n-      if (xor_mask != 0)\n-\t{\n-\t  wide_int mask = wi::mask (wi::floor_log2 (xor_mask), false,\n-\t\t\t\t    may_be_nonzero.get_precision ());\n-\t  may_be_nonzero = may_be_nonzero | mask;\n-\t  must_be_nonzero = wi::bit_and_not (must_be_nonzero, mask);\n-\t}\n-    }\n-}\n-\n-/* Value range wrapper for wide_int_set_zero_nonzero_bits.\n+/* Value range wrapper for wide_int_range_set_zero_nonzero_bits.\n \n    Compute MAY_BE_NONZERO and MUST_BE_NONZERO bit masks for range in VR.\n \n@@ -1066,9 +976,10 @@ vrp_set_zero_nonzero_bits (const tree expr_type,\n       *must_be_nonzero = wi::zero (TYPE_PRECISION (expr_type));\n       return false;\n     }\n-  wide_int_set_zero_nonzero_bits (TYPE_SIGN (expr_type),\n-\t\t\t\t wi::to_wide (vr->min), wi::to_wide (vr->max),\n-\t\t\t\t *may_be_nonzero, *must_be_nonzero);\n+  wide_int_range_set_zero_nonzero_bits (TYPE_SIGN (expr_type),\n+\t\t\t\t\twi::to_wide (vr->min),\n+\t\t\t\t\twi::to_wide (vr->max),\n+\t\t\t\t\t*may_be_nonzero, *must_be_nonzero);\n   return true;\n }\n \n@@ -1114,516 +1025,6 @@ ranges_from_anti_range (value_range *ar,\n   return vr0->type != VR_UNDEFINED;\n }\n \n-/* Order 2 sets of wide int ranges (w0/w1, w2/w3) and set MIN/MAX\n-   accordingly.  */\n-\n-static void\n-wide_int_range_min_max (wide_int &min, wide_int &max,\n-\t\t\twide_int &w0, wide_int &w1, wide_int &w2, wide_int &w3,\n-\t\t\tsignop sign)\n-{\n-  /* Order pairs w0,w1 and w2,w3.  */\n-  if (wi::gt_p (w0, w1, sign))\n-    std::swap (w0, w1);\n-  if (wi::gt_p (w2, w3, sign))\n-    std::swap (w2, w3);\n-\n-  /* Choose min and max from the ordered pairs.  */\n-  min = wi::min (w0, w2, sign);\n-  max = wi::max (w1, w3, sign);\n-}\n-\n-/* Calculate the cross product of two sets of ranges (VR0 and VR1) and\n-   store the result in [RES_LB, RES_UB].\n-\n-   CODE is the operation to perform with sign SIGN.\n-\n-   OVERFLOW_UNDEFINED is set if overflow is undefined for the operation type.\n-\n-   Return TRUE if we were able to calculate the cross product.  */\n-\n-bool\n-wide_int_range_cross_product (wide_int &res_lb, wide_int &res_ub,\n-\t\t\t      enum tree_code code, signop sign,\n-\t\t\t      const wide_int &vr0_lb, const wide_int &vr0_ub,\n-\t\t\t      const wide_int &vr1_lb, const wide_int &vr1_ub,\n-\t\t\t      bool overflow_undefined)\n-{\n-  wide_int cp1, cp2, cp3, cp4;\n-\n-  /* Compute the 4 cross operations, bailing if we get an overflow we\n-     can't handle.  */\n-\n-  if (!wide_int_binop_overflow (cp1, code, vr0_lb, vr1_lb, sign,\n-\t\t\t\toverflow_undefined))\n-    return false;\n-\n-  if (wi::eq_p (vr0_lb, vr0_ub))\n-    cp3 = cp1;\n-  else if (!wide_int_binop_overflow (cp3, code, vr0_ub, vr1_lb, sign,\n-\t\t\t\t     overflow_undefined))\n-    return false;\n-\n-  if (wi::eq_p (vr1_lb, vr1_ub))\n-    cp2 = cp1;\n-  else if (!wide_int_binop_overflow (cp2, code, vr0_lb, vr1_ub, sign,\n-\t\t\t\t     overflow_undefined))\n-    return false;\n-\n-  if (wi::eq_p (vr0_lb, vr0_ub))\n-    cp4 = cp2;\n-  else if (!wide_int_binop_overflow (cp4, code, vr0_ub, vr1_ub, sign,\n-\t\t\t\t     overflow_undefined))\n-    return false;\n-\n-  wide_int_range_min_max (res_lb, res_ub, cp1, cp2, cp3, cp4, sign);\n-  return true;\n-}\n-\n-/* Multiply two ranges when TYPE_OVERFLOW_WRAPS:\n-\n-     [RES_LB, RES_UB] = [MIN0, MAX0] * [MIN1, MAX1]\n-\n-   This is basically fancy code so we don't drop to varying with an\n-   unsigned [-3,-1]*[-3,-1].\n-\n-   Return TRUE if we were able to perform the operation.  */\n-\n-bool\n-wide_int_range_mult_wrapping (wide_int &res_lb,\n-\t\t\t      wide_int &res_ub,\n-\t\t\t      signop sign,\n-\t\t\t      unsigned prec,\n-\t\t\t      const wide_int &min0_,\n-\t\t\t      const wide_int &max0_,\n-\t\t\t      const wide_int &min1_,\n-\t\t\t      const wide_int &max1_)\n-{\n-  /* This test requires 2*prec bits if both operands are signed and\n-     2*prec + 2 bits if either is not.  Therefore, extend the values\n-     using the sign of the result to PREC2.  From here on out,\n-     everthing is just signed math no matter what the input types\n-     were.  */\n-  widest2_int min0 = widest2_int::from (min0_, sign);\n-  widest2_int max0 = widest2_int::from (max0_, sign);\n-  widest2_int min1 = widest2_int::from (min1_, sign);\n-  widest2_int max1 = widest2_int::from (max1_, sign);\n-  widest2_int sizem1 = wi::mask <widest2_int> (prec, false);\n-  widest2_int size = sizem1 + 1;\n-\n-  /* Canonicalize the intervals.  */\n-  if (sign == UNSIGNED)\n-    {\n-      if (wi::ltu_p (size, min0 + max0))\n-\t{\n-\t  min0 -= size;\n-\t  max0 -= size;\n-\t}\n-\n-      if (wi::ltu_p (size, min1 + max1))\n-\t{\n-\t  min1 -= size;\n-\t  max1 -= size;\n-\t}\n-    }\n-\n-  widest2_int prod0 = min0 * min1;\n-  widest2_int prod1 = min0 * max1;\n-  widest2_int prod2 = max0 * min1;\n-  widest2_int prod3 = max0 * max1;\n-\n-  /* Sort the 4 products so that min is in prod0 and max is in\n-     prod3.  */\n-  /* min0min1 > max0max1 */\n-  if (prod0 > prod3)\n-    std::swap (prod0, prod3);\n-\n-  /* min0max1 > max0min1 */\n-  if (prod1 > prod2)\n-    std::swap (prod1, prod2);\n-\n-  if (prod0 > prod1)\n-    std::swap (prod0, prod1);\n-\n-  if (prod2 > prod3)\n-    std::swap (prod2, prod3);\n-\n-  /* diff = max - min.  */\n-  prod2 = prod3 - prod0;\n-  if (wi::geu_p (prod2, sizem1))\n-    /* The range covers all values.  */\n-    return false;\n-\n-  res_lb = wide_int::from (prod0, prec, sign);\n-  res_ub = wide_int::from (prod3, prec, sign);\n-  return true;\n-}\n-\n-/* Perform multiplicative operation CODE on two ranges:\n-\n-     [RES_LB, RES_UB] = [VR0_LB, VR0_UB] .CODE. [VR1_LB, VR1_LB]\n-\n-   Return TRUE if we were able to perform the operation.\n-\n-   NOTE: If code is MULT_EXPR and TYPE_OVERFLOW_WRAPS, the resulting\n-   range must be canonicalized by the caller because its components\n-   may be swapped.  */\n-\n-bool\n-wide_int_range_multiplicative_op (wide_int &res_lb, wide_int &res_ub,\n-\t\t\t\t  enum tree_code code,\n-\t\t\t\t  signop sign,\n-\t\t\t\t  unsigned prec,\n-\t\t\t\t  const wide_int &vr0_lb,\n-\t\t\t\t  const wide_int &vr0_ub,\n-\t\t\t\t  const wide_int &vr1_lb,\n-\t\t\t\t  const wide_int &vr1_ub,\n-\t\t\t\t  bool overflow_undefined,\n-\t\t\t\t  bool overflow_wraps)\n-{\n-  /* Multiplications, divisions and shifts are a bit tricky to handle,\n-     depending on the mix of signs we have in the two ranges, we\n-     need to operate on different values to get the minimum and\n-     maximum values for the new range.  One approach is to figure\n-     out all the variations of range combinations and do the\n-     operations.\n-\n-     However, this involves several calls to compare_values and it\n-     is pretty convoluted.  It's simpler to do the 4 operations\n-     (MIN0 OP MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP\n-     MAX1) and then figure the smallest and largest values to form\n-     the new range.  */\n-  if (code == MULT_EXPR && overflow_wraps)\n-    return wide_int_range_mult_wrapping (res_lb, res_ub,\n-\t\t\t\t\t sign, prec,\n-\t\t\t\t\t vr0_lb, vr0_ub, vr1_lb, vr1_ub);\n-  return wide_int_range_cross_product (res_lb, res_ub,\n-\t\t\t\t       code, sign,\n-\t\t\t\t       vr0_lb, vr0_ub, vr1_lb, vr1_ub,\n-\t\t\t\t       overflow_undefined);\n-}\n-\n-/* Perform a left shift operation on two ranges:\n-\n-     [RES_LB, RES_UB] = [VR0_LB, VR0_UB] << [VR1_LB, VR1_LB]\n-\n-   Return TRUE if we were able to perform the operation.\n-\n-   NOTE: The resulting range must be canonicalized by the caller\n-   because its contents components may be swapped.  */\n-\n-bool\n-wide_int_range_lshift (wide_int &res_lb, wide_int &res_ub,\n-\t\t       signop sign, unsigned prec,\n-\t\t       const wide_int &vr0_lb, const wide_int &vr0_ub,\n-\t\t       const wide_int &vr1_lb, const wide_int &vr1_ub,\n-\t\t       bool overflow_undefined, bool overflow_wraps)\n-{\n-  /* Transform left shifts by constants into multiplies.  */\n-  if (wi::eq_p (vr1_lb, vr1_ub))\n-    {\n-      int shift = wi::extract_uhwi (vr1_ub, 0, vr1_ub.get_precision ());\n-      wide_int tmp = wi::set_bit_in_zero (shift, prec);\n-      return wide_int_range_multiplicative_op (res_lb, res_ub,\n-\t\t\t\t\t       MULT_EXPR, sign, prec,\n-\t\t\t\t\t       vr0_lb, vr0_ub, tmp, tmp,\n-\t\t\t\t\t       overflow_undefined,\n-\t\t\t\t\t       /*overflow_wraps=*/true);\n-    }\n-\n-  int overflow_pos = prec;\n-  if (sign == SIGNED)\n-    overflow_pos -= 1;\n-  int bound_shift = overflow_pos - vr1_ub.to_shwi ();\n-  /* If bound_shift == HOST_BITS_PER_WIDE_INT, the llshift can\n-     overflow.  However, for that to happen, vr1.max needs to be\n-     zero, which means vr1 is a singleton range of zero, which\n-     means it should be handled by the previous LSHIFT_EXPR\n-     if-clause.  */\n-  wide_int bound = wi::set_bit_in_zero (bound_shift, prec);\n-  wide_int complement = ~(bound - 1);\n-  wide_int low_bound, high_bound;\n-  bool in_bounds = false;\n-  if (sign == UNSIGNED)\n-    {\n-      low_bound = bound;\n-      high_bound = complement;\n-      if (wi::ltu_p (vr0_ub, low_bound))\n-\t{\n-\t  /* [5, 6] << [1, 2] == [10, 24].  */\n-\t  /* We're shifting out only zeroes, the value increases\n-\t     monotonically.  */\n-\t  in_bounds = true;\n-\t}\n-      else if (wi::ltu_p (high_bound, vr0_lb))\n-\t{\n-\t  /* [0xffffff00, 0xffffffff] << [1, 2]\n-\t     == [0xfffffc00, 0xfffffffe].  */\n-\t  /* We're shifting out only ones, the value decreases\n-\t     monotonically.  */\n-\t  in_bounds = true;\n-\t}\n-    }\n-  else\n-    {\n-      /* [-1, 1] << [1, 2] == [-4, 4].  */\n-      low_bound = complement;\n-      high_bound = bound;\n-      if (wi::lts_p (vr0_ub, high_bound)\n-\t  && wi::lts_p (low_bound, vr0_lb))\n-\t{\n-\t  /* For non-negative numbers, we're shifting out only\n-\t     zeroes, the value increases monotonically.\n-\t     For negative numbers, we're shifting out only ones, the\n-\t     value decreases monotomically.  */\n-\t  in_bounds = true;\n-\t}\n-    }\n-  if (in_bounds)\n-    return wide_int_range_multiplicative_op (res_lb, res_ub,\n-\t\t\t\t\t     LSHIFT_EXPR, sign, prec,\n-\t\t\t\t\t     vr0_lb, vr0_ub,\n-\t\t\t\t\t     vr1_lb, vr1_ub,\n-\t\t\t\t\t     overflow_undefined,\n-\t\t\t\t\t     overflow_wraps);\n-  return false;\n-}\n-\n-/* Return TRUE if a bit operation on two ranges can be easily\n-   optimized in terms of a mask.\n-\n-   Basically, for BIT_AND_EXPR or BIT_IOR_EXPR see if we can optimize:\n-\n-\t[LB, UB] op Z\n-   into:\n-\t[LB op Z, UB op Z]\n-\n-   It is up to the caller to perform the actual folding above.  */\n-\n-bool\n-wide_int_range_can_optimize_bit_op (tree_code code,\n-\t\t\t\t    const wide_int &lb, const wide_int &ub,\n-\t\t\t\t    const wide_int &mask)\n-\n-{\n-  if (code != BIT_AND_EXPR && code != BIT_IOR_EXPR)\n-    return false;\n-  /* If Z is a constant which (for op | its bitwise not) has n\n-     consecutive least significant bits cleared followed by m 1\n-     consecutive bits set immediately above it and either\n-     m + n == precision, or (x >> (m + n)) == (y >> (m + n)).\n-\n-     The least significant n bits of all the values in the range are\n-     cleared or set, the m bits above it are preserved and any bits\n-     above these are required to be the same for all values in the\n-     range.  */\n-\n-  wide_int w = mask;\n-  int m = 0, n = 0;\n-  if (code == BIT_IOR_EXPR)\n-    w = ~w;\n-  if (wi::eq_p (w, 0))\n-    n = w.get_precision ();\n-  else\n-    {\n-      n = wi::ctz (w);\n-      w = ~(w | wi::mask (n, false, w.get_precision ()));\n-      if (wi::eq_p (w, 0))\n-\tm = w.get_precision () - n;\n-      else\n-\tm = wi::ctz (w) - n;\n-    }\n-  wide_int new_mask = wi::mask (m + n, true, w.get_precision ());\n-  if ((new_mask & lb) == (new_mask & ub))\n-    return true;\n-\n-  return false;\n-}\n-\n-/* Return TRUE if shifting by range [MIN, MAX] is undefined behavior.\n-\n-   FIXME: Make this inline when it moves outside of tree-vrp.  */\n-\n-bool\n-wide_int_range_shift_undefined_p (signop sign, unsigned prec,\n-\t\t\t\t  const wide_int &min, const wide_int &max)\n-{\n-  /* ?? Note: The original comment said this only applied to\n-     RSHIFT_EXPR, but it was being applied to both left and right\n-     shifts.  Is this OK?  */\n-\n-  /* Shifting by any values outside [0..prec-1], gets undefined\n-     behavior from the shift operation.  We cannot even trust\n-     SHIFT_COUNT_TRUNCATED at this stage, because that applies to rtl\n-     shifts, and the operation at the tree level may be widened.  */\n-  return wi::lt_p (min, 0, sign) || wi::ge_p (max, prec, sign);\n-}\n-\n-/* Calculate the XOR of two ranges and store the result in [WMIN,WMAX].\n-   The two input ranges are described by their MUST_BE_NONZERO and\n-   MAY_BE_NONZERO bit masks.\n-\n-   Return TRUE if we were able to successfully calculate the new range.  */\n-\n-bool\n-wide_int_range_bit_xor (wide_int &wmin, wide_int &wmax,\n-\t\t\tsignop sign,\n-\t\t\tunsigned prec,\n-\t\t\tconst wide_int &must_be_nonzero0,\n-\t\t\tconst wide_int &may_be_nonzero0,\n-\t\t\tconst wide_int &must_be_nonzero1,\n-\t\t\tconst wide_int &may_be_nonzero1)\n-{\n-  wide_int result_zero_bits = ((must_be_nonzero0 & must_be_nonzero1)\n-\t\t\t       | ~(may_be_nonzero0 | may_be_nonzero1));\n-  wide_int result_one_bits\n-    = (wi::bit_and_not (must_be_nonzero0, may_be_nonzero1)\n-       | wi::bit_and_not (must_be_nonzero1, may_be_nonzero0));\n-  wmax = ~result_zero_bits;\n-  wmin = result_one_bits;\n-  /* If the range has all positive or all negative values, the result\n-     is better than VARYING.  */\n-  if (wi::lt_p (wmin, 0, sign) || wi::ge_p (wmax, 0, sign))\n-    return true;\n-  wmin = wi::min_value (prec, sign);\n-  wmax = wi::max_value (prec, sign);\n-  return false;\n-}\n-\n-/* Calculate the IOR of two ranges and store the result in [WMIN,WMAX].\n-   Return TRUE if we were able to successfully calculate the new range.  */\n-\n-bool\n-wide_int_range_bit_ior (wide_int &wmin, wide_int &wmax,\n-\t\t\tsignop sign,\n-\t\t\tconst wide_int &vr0_min,\n-\t\t\tconst wide_int &vr0_max,\n-\t\t\tconst wide_int &vr1_min,\n-\t\t\tconst wide_int &vr1_max,\n-\t\t\tconst wide_int &must_be_nonzero0,\n-\t\t\tconst wide_int &may_be_nonzero0,\n-\t\t\tconst wide_int &must_be_nonzero1,\n-\t\t\tconst wide_int &may_be_nonzero1)\n-{\n-  wmin = must_be_nonzero0 | must_be_nonzero1;\n-  wmax = may_be_nonzero0 | may_be_nonzero1;\n-  /* If the input ranges contain only positive values we can\n-     truncate the minimum of the result range to the maximum\n-     of the input range minima.  */\n-  if (wi::ge_p (vr0_min, 0, sign)\n-      && wi::ge_p (vr1_min, 0, sign))\n-    {\n-      wmin = wi::max (wmin, vr0_min, sign);\n-      wmin = wi::max (wmin, vr1_min, sign);\n-    }\n-  /* If either input range contains only negative values\n-     we can truncate the minimum of the result range to the\n-     respective minimum range.  */\n-  if (wi::lt_p (vr0_max, 0, sign))\n-    wmin = wi::max (wmin, vr0_min, sign);\n-  if (wi::lt_p (vr1_max, 0, sign))\n-    wmin = wi::max (wmin, vr1_min, sign);\n-  /* If the limits got swapped around, indicate error so we can adjust\n-     the range to VARYING.  */\n-  if (wi::gt_p (wmin, wmax,sign))\n-    return false;\n-  return true;\n-}\n-\n-/* Calculate the bitwise AND of two ranges and store the result in [WMIN,WMAX].\n-   Return TRUE if we were able to successfully calculate the new range.  */\n-\n-bool\n-wide_int_range_bit_and (wide_int &wmin, wide_int &wmax,\n-\t\t\tsignop sign,\n-\t\t\tunsigned prec,\n-\t\t\tconst wide_int &vr0_min,\n-\t\t\tconst wide_int &vr0_max,\n-\t\t\tconst wide_int &vr1_min,\n-\t\t\tconst wide_int &vr1_max,\n-\t\t\tconst wide_int &must_be_nonzero0,\n-\t\t\tconst wide_int &may_be_nonzero0,\n-\t\t\tconst wide_int &must_be_nonzero1,\n-\t\t\tconst wide_int &may_be_nonzero1)\n-{\n-  wmin = must_be_nonzero0 & must_be_nonzero1;\n-  wmax = may_be_nonzero0 & may_be_nonzero1;\n-  /* If both input ranges contain only negative values we can\n-     truncate the result range maximum to the minimum of the\n-     input range maxima.  */\n-  if (wi::lt_p (vr0_max, 0, sign) && wi::lt_p (vr1_max, 0, sign))\n-    {\n-      wmax = wi::min (wmax, vr0_max, sign);\n-      wmax = wi::min (wmax, vr1_max, sign);\n-    }\n-  /* If either input range contains only non-negative values\n-     we can truncate the result range maximum to the respective\n-     maximum of the input range.  */\n-  if (wi::ge_p (vr0_min, 0, sign))\n-    wmax = wi::min (wmax, vr0_max, sign);\n-  if (wi::ge_p (vr1_min, 0, sign))\n-    wmax = wi::min (wmax, vr1_max, sign);\n-  /* PR68217: In case of signed & sign-bit-CST should\n-     result in [-INF, 0] instead of [-INF, INF].  */\n-  if (wi::gt_p (wmin, wmax, sign))\n-    {\n-      wide_int sign_bit = wi::set_bit_in_zero (prec - 1, prec);\n-      if (sign == SIGNED\n-\t  && ((wi::eq_p (vr0_min, vr0_max)\n-\t       && !wi::cmps (vr0_min, sign_bit))\n-\t      || (wi::eq_p (vr1_min, vr1_max)\n-\t\t  && !wi::cmps (vr1_min, sign_bit))))\n-\t{\n-\t  wmin = wi::min_value (prec, sign);\n-\t  wmax = wi::zero (prec);\n-\t}\n-    }\n-  /* If the limits got swapped around, indicate error so we can adjust\n-     the range to VARYING.  */\n-  if (wi::gt_p (wmin, wmax,sign))\n-    return false;\n-  return true;\n-}\n-\n-/* Calculate TRUNC_MOD_EXPR on two ranges and store the result in\n-   [WMIN,WMAX].  */\n-\n-void\n-wide_int_range_trunc_mod (wide_int &wmin, wide_int &wmax,\n-\t\t\t  signop sign,\n-\t\t\t  unsigned prec,\n-\t\t\t  const wide_int &vr0_min,\n-\t\t\t  const wide_int &vr0_max,\n-\t\t\t  const wide_int &vr1_min,\n-\t\t\t  const wide_int &vr1_max)\n-{\n-  wide_int tmp;\n-\n-  /* ABS (A % B) < ABS (B) and either\n-     0 <= A % B <= A or A <= A % B <= 0.  */\n-  wmax = vr1_max - 1;\n-  if (sign == SIGNED)\n-    {\n-      tmp = -1 - vr1_min;\n-      wmax = wi::smax (wmax, tmp);\n-    }\n-\n-  if (sign == UNSIGNED)\n-    wmin = wi::zero (prec);\n-  else\n-    {\n-      wmin = -wmax;\n-      tmp = vr0_min;\n-      if (wi::gts_p (tmp, 0))\n-\ttmp = wi::zero (prec);\n-      wmin = wi::smax (wmin, tmp);\n-    }\n-  tmp = vr0_max;\n-  if (sign == SIGNED && wi::neg_p (tmp))\n-    tmp = wi::zero (prec);\n-  wmax = wi::min (wmax, tmp, sign);\n-}\n-\n /* Extract the components of a value range into a pair of wide ints in\n    [WMIN, WMAX].\n "}, {"sha": "0c1fb3637cf2409be95afc8bed83f88f4f4efc38", "filename": "gcc/tree-vrp.h", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2Ftree-vrp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2Ftree-vrp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.h?ref=c9f8fca6d677b01bd622b17a2a7acb2938a69e0a", "patch": "@@ -105,83 +105,6 @@ extern bool vrp_val_is_min (const_tree);\n extern bool vrp_val_is_max (const_tree);\n extern void copy_value_range (value_range *, value_range *);\n extern void set_value_range_to_value (value_range *, tree, bitmap);\n-extern bool wide_int_range_cross_product (wide_int &res_lb, wide_int &res_ub,\n-\t\t\t\t\t  enum tree_code code, signop sign,\n-\t\t\t\t\t  const wide_int &, const wide_int &,\n-\t\t\t\t\t  const wide_int &, const wide_int &,\n-\t\t\t\t\t  bool overflow_undefined);\n-extern bool wide_int_range_mult_wrapping (wide_int &res_lb,\n-\t\t\t\t\t  wide_int &res_ub,\n-\t\t\t\t\t  signop sign,\n-\t\t\t\t\t  unsigned prec,\n-\t\t\t\t\t  const wide_int &min0_,\n-\t\t\t\t\t  const wide_int &max0_,\n-\t\t\t\t\t  const wide_int &min1_,\n-\t\t\t\t\t  const wide_int &max1_);\n-extern bool wide_int_range_multiplicative_op (wide_int &res_lb,\n-\t\t\t\t\t      wide_int &res_ub,\n-\t\t\t\t\t      enum tree_code code,\n-\t\t\t\t\t      signop sign,\n-\t\t\t\t\t      unsigned prec,\n-\t\t\t\t\t      const wide_int &vr0_lb,\n-\t\t\t\t\t      const wide_int &vr0_ub,\n-\t\t\t\t\t      const wide_int &vr1_lb,\n-\t\t\t\t\t      const wide_int &vr1_ub,\n-\t\t\t\t\t      bool overflow_undefined,\n-\t\t\t\t\t      bool overflow_wraps);\n-extern bool wide_int_range_lshift (wide_int &res_lb, wide_int &res_ub,\n-\t\t\t\t   signop sign, unsigned prec,\n-\t\t\t\t   const wide_int &, const wide_int &,\n-\t\t\t\t   const wide_int &, const wide_int &,\n-\t\t\t\t   bool overflow_undefined,\n-\t\t\t\t   bool overflow_wraps);\n-extern bool wide_int_range_shift_undefined_p (signop sign, unsigned prec,\n-\t\t\t\t\t      const wide_int &min,\n-\t\t\t\t\t      const wide_int &max);\n-extern void wide_int_set_zero_nonzero_bits (signop,\n-\t\t\t\t\t    const wide_int &lb,\n-\t\t\t\t\t    const wide_int &ub,\n-\t\t\t\t\t    wide_int &may_be_nonzero,\n-\t\t\t\t\t    wide_int &must_be_nonzero);\n-extern bool wide_int_range_can_optimize_bit_op (tree_code,\n-\t\t\t\t\t\tconst wide_int &lb,\n-\t\t\t\t\t\tconst wide_int &ub,\n-\t\t\t\t\t\tconst wide_int &mask);\n-extern bool wide_int_range_bit_xor (wide_int &wmin, wide_int &wmax,\n-\t\t\t\t    signop sign,\n-\t\t\t\t    unsigned prec,\n-\t\t\t\t    const wide_int &must_be_nonzero0,\n-\t\t\t\t    const wide_int &may_be_nonzero0,\n-\t\t\t\t    const wide_int &must_be_nonzero1,\n-\t\t\t\t    const wide_int &may_be_nonzero1);\n-extern bool wide_int_range_bit_ior (wide_int &wmin, wide_int &wmax,\n-\t\t\t\t    signop sign,\n-\t\t\t\t    const wide_int &vr0_min,\n-\t\t\t\t    const wide_int &vr0_max,\n-\t\t\t\t    const wide_int &vr1_min,\n-\t\t\t\t    const wide_int &vr1_max,\n-\t\t\t\t    const wide_int &must_be_nonzero0,\n-\t\t\t\t    const wide_int &may_be_nonzero0,\n-\t\t\t\t    const wide_int &must_be_nonzero1,\n-\t\t\t\t    const wide_int &may_be_nonzero1);\n-extern bool wide_int_range_bit_and (wide_int &wmin, wide_int &wmax,\n-\t\t\t\t    signop sign,\n-\t\t\t\t    unsigned prec,\n-\t\t\t\t    const wide_int &vr0_min,\n-\t\t\t\t    const wide_int &vr0_max,\n-\t\t\t\t    const wide_int &vr1_min,\n-\t\t\t\t    const wide_int &vr1_max,\n-\t\t\t\t    const wide_int &must_be_nonzero0,\n-\t\t\t\t    const wide_int &may_be_nonzero0,\n-\t\t\t\t    const wide_int &must_be_nonzero1,\n-\t\t\t\t    const wide_int &may_be_nonzero1);\n-extern void wide_int_range_trunc_mod (wide_int &wmin, wide_int &wmax,\n-\t\t\t\t      signop sign,\n-\t\t\t\t      unsigned prec,\n-\t\t\t\t      const wide_int &vr0_min,\n-\t\t\t\t      const wide_int &vr0_max,\n-\t\t\t\t      const wide_int &vr1_min,\n-\t\t\t\t      const wide_int &vr1_max);\n extern void extract_range_from_binary_expr_1 (value_range *, enum tree_code,\n \t\t\t\t\t      tree, value_range *,\n \t\t\t\t\t      value_range *);"}, {"sha": "3491d89664d8296a3b72b60c09800964604ea8ec", "filename": "gcc/wide-int-range.cc", "status": "added", "additions": 607, "deletions": 0, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2Fwide-int-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2Fwide-int-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int-range.cc?ref=c9f8fca6d677b01bd622b17a2a7acb2938a69e0a", "patch": "@@ -0,0 +1,607 @@\n+/* Support routines for range operations on wide ints.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"fold-const.h\"\n+#include \"wide-int-range.h\"\n+\n+/* Wrapper around wide_int_binop that adjusts for overflow.\n+\n+   Return true if we can compute the result; i.e. if the operation\n+   doesn't overflow or if the overflow is undefined.  In the latter\n+   case (if the operation overflows and overflow is undefined), then\n+   adjust the result to be -INF or +INF depending on CODE, VAL1 and\n+   VAL2.  Return the value in *RES.\n+\n+   Return false for division by zero, for which the result is\n+   indeterminate.  */\n+\n+static bool\n+wide_int_binop_overflow (wide_int &res,\n+\t\t\t enum tree_code code,\n+\t\t\t const wide_int &w0, const wide_int &w1,\n+\t\t\t signop sign, bool overflow_undefined)\n+{\n+  wi::overflow_type overflow;\n+  if (!wide_int_binop (res, code, w0, w1, sign, &overflow))\n+    return false;\n+\n+  /* If the operation overflowed return -INF or +INF depending on the\n+     operation and the combination of signs of the operands.  */\n+  if (overflow && overflow_undefined)\n+    {\n+      switch (code)\n+\t{\n+\tcase MULT_EXPR:\n+\t  /* For multiplication, the sign of the overflow is given\n+\t     by the comparison of the signs of the operands.  */\n+\t  if (sign == UNSIGNED || w0.sign_mask () == w1.sign_mask ())\n+\t    res = wi::max_value (w0.get_precision (), sign);\n+\t  else\n+\t    res = wi::min_value (w0.get_precision (), sign);\n+\t  return true;\n+\n+\tcase TRUNC_DIV_EXPR:\n+\tcase FLOOR_DIV_EXPR:\n+\tcase CEIL_DIV_EXPR:\n+\tcase EXACT_DIV_EXPR:\n+\tcase ROUND_DIV_EXPR:\n+\t  /* For division, the only case is -INF / -1 = +INF.  */\n+\t  res = wi::max_value (w0.get_precision (), sign);\n+\t  return true;\n+\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+    }\n+  return !overflow;\n+}\n+\n+/* For range [LB, UB] compute two wide_int bit masks.\n+\n+   In the MAY_BE_NONZERO bit mask, if some bit is unset, it means that\n+   for all numbers in the range the bit is 0, otherwise it might be 0\n+   or 1.\n+\n+   In the MUST_BE_NONZERO bit mask, if some bit is set, it means that\n+   for all numbers in the range the bit is 1, otherwise it might be 0\n+   or 1.  */\n+\n+void\n+wide_int_range_set_zero_nonzero_bits (signop sign,\n+\t\t\t\t      const wide_int &lb, const wide_int &ub,\n+\t\t\t\t      wide_int &may_be_nonzero,\n+\t\t\t\t      wide_int &must_be_nonzero)\n+{\n+  may_be_nonzero = wi::minus_one (lb.get_precision ());\n+  must_be_nonzero = wi::zero (lb.get_precision ());\n+\n+  if (wi::eq_p (lb, ub))\n+    {\n+      may_be_nonzero = lb;\n+      must_be_nonzero = may_be_nonzero;\n+    }\n+  else if (wi::ge_p (lb, 0, sign) || wi::lt_p (ub, 0, sign))\n+    {\n+      wide_int xor_mask = lb ^ ub;\n+      may_be_nonzero = lb | ub;\n+      must_be_nonzero = lb & ub;\n+      if (xor_mask != 0)\n+\t{\n+\t  wide_int mask = wi::mask (wi::floor_log2 (xor_mask), false,\n+\t\t\t\t    may_be_nonzero.get_precision ());\n+\t  may_be_nonzero = may_be_nonzero | mask;\n+\t  must_be_nonzero = wi::bit_and_not (must_be_nonzero, mask);\n+\t}\n+    }\n+}\n+\n+/* Order 2 sets of wide int ranges (w0/w1, w2/w3) and set MIN/MAX\n+   accordingly.  */\n+\n+static void\n+wide_int_range_min_max (wide_int &min, wide_int &max,\n+\t\t\twide_int &w0, wide_int &w1, wide_int &w2, wide_int &w3,\n+\t\t\tsignop sign)\n+{\n+  /* Order pairs w0,w1 and w2,w3.  */\n+  if (wi::gt_p (w0, w1, sign))\n+    std::swap (w0, w1);\n+  if (wi::gt_p (w2, w3, sign))\n+    std::swap (w2, w3);\n+\n+  /* Choose min and max from the ordered pairs.  */\n+  min = wi::min (w0, w2, sign);\n+  max = wi::max (w1, w3, sign);\n+}\n+\n+/* Calculate the cross product of two sets of ranges (VR0 and VR1) and\n+   store the result in [RES_LB, RES_UB].\n+\n+   CODE is the operation to perform with sign SIGN.\n+\n+   OVERFLOW_UNDEFINED is set if overflow is undefined for the operation type.\n+\n+   Return TRUE if we were able to calculate the cross product.  */\n+\n+bool\n+wide_int_range_cross_product (wide_int &res_lb, wide_int &res_ub,\n+\t\t\t      enum tree_code code, signop sign,\n+\t\t\t      const wide_int &vr0_lb, const wide_int &vr0_ub,\n+\t\t\t      const wide_int &vr1_lb, const wide_int &vr1_ub,\n+\t\t\t      bool overflow_undefined)\n+{\n+  wide_int cp1, cp2, cp3, cp4;\n+\n+  /* Compute the 4 cross operations, bailing if we get an overflow we\n+     can't handle.  */\n+\n+  if (!wide_int_binop_overflow (cp1, code, vr0_lb, vr1_lb, sign,\n+\t\t\t\toverflow_undefined))\n+    return false;\n+\n+  if (wi::eq_p (vr0_lb, vr0_ub))\n+    cp3 = cp1;\n+  else if (!wide_int_binop_overflow (cp3, code, vr0_ub, vr1_lb, sign,\n+\t\t\t\t     overflow_undefined))\n+    return false;\n+\n+  if (wi::eq_p (vr1_lb, vr1_ub))\n+    cp2 = cp1;\n+  else if (!wide_int_binop_overflow (cp2, code, vr0_lb, vr1_ub, sign,\n+\t\t\t\t     overflow_undefined))\n+    return false;\n+\n+  if (wi::eq_p (vr0_lb, vr0_ub))\n+    cp4 = cp2;\n+  else if (!wide_int_binop_overflow (cp4, code, vr0_ub, vr1_ub, sign,\n+\t\t\t\t     overflow_undefined))\n+    return false;\n+\n+  wide_int_range_min_max (res_lb, res_ub, cp1, cp2, cp3, cp4, sign);\n+  return true;\n+}\n+\n+/* Multiply two ranges when TYPE_OVERFLOW_WRAPS:\n+\n+     [RES_LB, RES_UB] = [MIN0, MAX0] * [MIN1, MAX1]\n+\n+   This is basically fancy code so we don't drop to varying with an\n+   unsigned [-3,-1]*[-3,-1].\n+\n+   Return TRUE if we were able to perform the operation.  */\n+\n+bool\n+wide_int_range_mult_wrapping (wide_int &res_lb,\n+\t\t\t      wide_int &res_ub,\n+\t\t\t      signop sign,\n+\t\t\t      unsigned prec,\n+\t\t\t      const wide_int &min0_,\n+\t\t\t      const wide_int &max0_,\n+\t\t\t      const wide_int &min1_,\n+\t\t\t      const wide_int &max1_)\n+{\n+  /* This test requires 2*prec bits if both operands are signed and\n+     2*prec + 2 bits if either is not.  Therefore, extend the values\n+     using the sign of the result to PREC2.  From here on out,\n+     everthing is just signed math no matter what the input types\n+     were.  */\n+  widest2_int min0 = widest2_int::from (min0_, sign);\n+  widest2_int max0 = widest2_int::from (max0_, sign);\n+  widest2_int min1 = widest2_int::from (min1_, sign);\n+  widest2_int max1 = widest2_int::from (max1_, sign);\n+  widest2_int sizem1 = wi::mask <widest2_int> (prec, false);\n+  widest2_int size = sizem1 + 1;\n+\n+  /* Canonicalize the intervals.  */\n+  if (sign == UNSIGNED)\n+    {\n+      if (wi::ltu_p (size, min0 + max0))\n+\t{\n+\t  min0 -= size;\n+\t  max0 -= size;\n+\t}\n+\n+      if (wi::ltu_p (size, min1 + max1))\n+\t{\n+\t  min1 -= size;\n+\t  max1 -= size;\n+\t}\n+    }\n+\n+  widest2_int prod0 = min0 * min1;\n+  widest2_int prod1 = min0 * max1;\n+  widest2_int prod2 = max0 * min1;\n+  widest2_int prod3 = max0 * max1;\n+\n+  /* Sort the 4 products so that min is in prod0 and max is in\n+     prod3.  */\n+  /* min0min1 > max0max1 */\n+  if (prod0 > prod3)\n+    std::swap (prod0, prod3);\n+\n+  /* min0max1 > max0min1 */\n+  if (prod1 > prod2)\n+    std::swap (prod1, prod2);\n+\n+  if (prod0 > prod1)\n+    std::swap (prod0, prod1);\n+\n+  if (prod2 > prod3)\n+    std::swap (prod2, prod3);\n+\n+  /* diff = max - min.  */\n+  prod2 = prod3 - prod0;\n+  if (wi::geu_p (prod2, sizem1))\n+    /* The range covers all values.  */\n+    return false;\n+\n+  res_lb = wide_int::from (prod0, prec, sign);\n+  res_ub = wide_int::from (prod3, prec, sign);\n+  return true;\n+}\n+\n+/* Perform multiplicative operation CODE on two ranges:\n+\n+     [RES_LB, RES_UB] = [VR0_LB, VR0_UB] .CODE. [VR1_LB, VR1_LB]\n+\n+   Return TRUE if we were able to perform the operation.\n+\n+   NOTE: If code is MULT_EXPR and TYPE_OVERFLOW_WRAPS, the resulting\n+   range must be canonicalized by the caller because its components\n+   may be swapped.  */\n+\n+bool\n+wide_int_range_multiplicative_op (wide_int &res_lb, wide_int &res_ub,\n+\t\t\t\t  enum tree_code code,\n+\t\t\t\t  signop sign,\n+\t\t\t\t  unsigned prec,\n+\t\t\t\t  const wide_int &vr0_lb,\n+\t\t\t\t  const wide_int &vr0_ub,\n+\t\t\t\t  const wide_int &vr1_lb,\n+\t\t\t\t  const wide_int &vr1_ub,\n+\t\t\t\t  bool overflow_undefined,\n+\t\t\t\t  bool overflow_wraps)\n+{\n+  /* Multiplications, divisions and shifts are a bit tricky to handle,\n+     depending on the mix of signs we have in the two ranges, we\n+     need to operate on different values to get the minimum and\n+     maximum values for the new range.  One approach is to figure\n+     out all the variations of range combinations and do the\n+     operations.\n+\n+     However, this involves several calls to compare_values and it\n+     is pretty convoluted.  It's simpler to do the 4 operations\n+     (MIN0 OP MIN1, MIN0 OP MAX1, MAX0 OP MIN1 and MAX0 OP MAX0 OP\n+     MAX1) and then figure the smallest and largest values to form\n+     the new range.  */\n+  if (code == MULT_EXPR && overflow_wraps)\n+    return wide_int_range_mult_wrapping (res_lb, res_ub,\n+\t\t\t\t\t sign, prec,\n+\t\t\t\t\t vr0_lb, vr0_ub, vr1_lb, vr1_ub);\n+  return wide_int_range_cross_product (res_lb, res_ub,\n+\t\t\t\t       code, sign,\n+\t\t\t\t       vr0_lb, vr0_ub, vr1_lb, vr1_ub,\n+\t\t\t\t       overflow_undefined);\n+}\n+\n+/* Perform a left shift operation on two ranges:\n+\n+     [RES_LB, RES_UB] = [VR0_LB, VR0_UB] << [VR1_LB, VR1_LB]\n+\n+   Return TRUE if we were able to perform the operation.\n+\n+   NOTE: The resulting range must be canonicalized by the caller\n+   because its contents components may be swapped.  */\n+\n+bool\n+wide_int_range_lshift (wide_int &res_lb, wide_int &res_ub,\n+\t\t       signop sign, unsigned prec,\n+\t\t       const wide_int &vr0_lb, const wide_int &vr0_ub,\n+\t\t       const wide_int &vr1_lb, const wide_int &vr1_ub,\n+\t\t       bool overflow_undefined, bool overflow_wraps)\n+{\n+  /* Transform left shifts by constants into multiplies.  */\n+  if (wi::eq_p (vr1_lb, vr1_ub))\n+    {\n+      int shift = wi::extract_uhwi (vr1_ub, 0, vr1_ub.get_precision ());\n+      wide_int tmp = wi::set_bit_in_zero (shift, prec);\n+      return wide_int_range_multiplicative_op (res_lb, res_ub,\n+\t\t\t\t\t       MULT_EXPR, sign, prec,\n+\t\t\t\t\t       vr0_lb, vr0_ub, tmp, tmp,\n+\t\t\t\t\t       overflow_undefined,\n+\t\t\t\t\t       /*overflow_wraps=*/true);\n+    }\n+\n+  int overflow_pos = prec;\n+  if (sign == SIGNED)\n+    overflow_pos -= 1;\n+  int bound_shift = overflow_pos - vr1_ub.to_shwi ();\n+  /* If bound_shift == HOST_BITS_PER_WIDE_INT, the llshift can\n+     overflow.  However, for that to happen, vr1.max needs to be\n+     zero, which means vr1 is a singleton range of zero, which\n+     means it should be handled by the previous LSHIFT_EXPR\n+     if-clause.  */\n+  wide_int bound = wi::set_bit_in_zero (bound_shift, prec);\n+  wide_int complement = ~(bound - 1);\n+  wide_int low_bound, high_bound;\n+  bool in_bounds = false;\n+  if (sign == UNSIGNED)\n+    {\n+      low_bound = bound;\n+      high_bound = complement;\n+      if (wi::ltu_p (vr0_ub, low_bound))\n+\t{\n+\t  /* [5, 6] << [1, 2] == [10, 24].  */\n+\t  /* We're shifting out only zeroes, the value increases\n+\t     monotonically.  */\n+\t  in_bounds = true;\n+\t}\n+      else if (wi::ltu_p (high_bound, vr0_lb))\n+\t{\n+\t  /* [0xffffff00, 0xffffffff] << [1, 2]\n+\t     == [0xfffffc00, 0xfffffffe].  */\n+\t  /* We're shifting out only ones, the value decreases\n+\t     monotonically.  */\n+\t  in_bounds = true;\n+\t}\n+    }\n+  else\n+    {\n+      /* [-1, 1] << [1, 2] == [-4, 4].  */\n+      low_bound = complement;\n+      high_bound = bound;\n+      if (wi::lts_p (vr0_ub, high_bound)\n+\t  && wi::lts_p (low_bound, vr0_lb))\n+\t{\n+\t  /* For non-negative numbers, we're shifting out only\n+\t     zeroes, the value increases monotonically.\n+\t     For negative numbers, we're shifting out only ones, the\n+\t     value decreases monotomically.  */\n+\t  in_bounds = true;\n+\t}\n+    }\n+  if (in_bounds)\n+    return wide_int_range_multiplicative_op (res_lb, res_ub,\n+\t\t\t\t\t     LSHIFT_EXPR, sign, prec,\n+\t\t\t\t\t     vr0_lb, vr0_ub,\n+\t\t\t\t\t     vr1_lb, vr1_ub,\n+\t\t\t\t\t     overflow_undefined,\n+\t\t\t\t\t     overflow_wraps);\n+  return false;\n+}\n+\n+/* Return TRUE if a bit operation on two ranges can be easily\n+   optimized in terms of a mask.\n+\n+   Basically, for BIT_AND_EXPR or BIT_IOR_EXPR see if we can optimize:\n+\n+\t[LB, UB] op Z\n+   into:\n+\t[LB op Z, UB op Z]\n+\n+   It is up to the caller to perform the actual folding above.  */\n+\n+bool\n+wide_int_range_can_optimize_bit_op (tree_code code,\n+\t\t\t\t    const wide_int &lb, const wide_int &ub,\n+\t\t\t\t    const wide_int &mask)\n+\n+{\n+  if (code != BIT_AND_EXPR && code != BIT_IOR_EXPR)\n+    return false;\n+  /* If Z is a constant which (for op | its bitwise not) has n\n+     consecutive least significant bits cleared followed by m 1\n+     consecutive bits set immediately above it and either\n+     m + n == precision, or (x >> (m + n)) == (y >> (m + n)).\n+\n+     The least significant n bits of all the values in the range are\n+     cleared or set, the m bits above it are preserved and any bits\n+     above these are required to be the same for all values in the\n+     range.  */\n+\n+  wide_int w = mask;\n+  int m = 0, n = 0;\n+  if (code == BIT_IOR_EXPR)\n+    w = ~w;\n+  if (wi::eq_p (w, 0))\n+    n = w.get_precision ();\n+  else\n+    {\n+      n = wi::ctz (w);\n+      w = ~(w | wi::mask (n, false, w.get_precision ()));\n+      if (wi::eq_p (w, 0))\n+\tm = w.get_precision () - n;\n+      else\n+\tm = wi::ctz (w) - n;\n+    }\n+  wide_int new_mask = wi::mask (m + n, true, w.get_precision ());\n+  if ((new_mask & lb) == (new_mask & ub))\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Calculate the XOR of two ranges and store the result in [WMIN,WMAX].\n+   The two input ranges are described by their MUST_BE_NONZERO and\n+   MAY_BE_NONZERO bit masks.\n+\n+   Return TRUE if we were able to successfully calculate the new range.  */\n+\n+bool\n+wide_int_range_bit_xor (wide_int &wmin, wide_int &wmax,\n+\t\t\tsignop sign,\n+\t\t\tunsigned prec,\n+\t\t\tconst wide_int &must_be_nonzero0,\n+\t\t\tconst wide_int &may_be_nonzero0,\n+\t\t\tconst wide_int &must_be_nonzero1,\n+\t\t\tconst wide_int &may_be_nonzero1)\n+{\n+  wide_int result_zero_bits = ((must_be_nonzero0 & must_be_nonzero1)\n+\t\t\t       | ~(may_be_nonzero0 | may_be_nonzero1));\n+  wide_int result_one_bits\n+    = (wi::bit_and_not (must_be_nonzero0, may_be_nonzero1)\n+       | wi::bit_and_not (must_be_nonzero1, may_be_nonzero0));\n+  wmax = ~result_zero_bits;\n+  wmin = result_one_bits;\n+  /* If the range has all positive or all negative values, the result\n+     is better than VARYING.  */\n+  if (wi::lt_p (wmin, 0, sign) || wi::ge_p (wmax, 0, sign))\n+    return true;\n+  wmin = wi::min_value (prec, sign);\n+  wmax = wi::max_value (prec, sign);\n+  return false;\n+}\n+\n+/* Calculate the IOR of two ranges and store the result in [WMIN,WMAX].\n+   Return TRUE if we were able to successfully calculate the new range.  */\n+\n+bool\n+wide_int_range_bit_ior (wide_int &wmin, wide_int &wmax,\n+\t\t\tsignop sign,\n+\t\t\tconst wide_int &vr0_min,\n+\t\t\tconst wide_int &vr0_max,\n+\t\t\tconst wide_int &vr1_min,\n+\t\t\tconst wide_int &vr1_max,\n+\t\t\tconst wide_int &must_be_nonzero0,\n+\t\t\tconst wide_int &may_be_nonzero0,\n+\t\t\tconst wide_int &must_be_nonzero1,\n+\t\t\tconst wide_int &may_be_nonzero1)\n+{\n+  wmin = must_be_nonzero0 | must_be_nonzero1;\n+  wmax = may_be_nonzero0 | may_be_nonzero1;\n+  /* If the input ranges contain only positive values we can\n+     truncate the minimum of the result range to the maximum\n+     of the input range minima.  */\n+  if (wi::ge_p (vr0_min, 0, sign)\n+      && wi::ge_p (vr1_min, 0, sign))\n+    {\n+      wmin = wi::max (wmin, vr0_min, sign);\n+      wmin = wi::max (wmin, vr1_min, sign);\n+    }\n+  /* If either input range contains only negative values\n+     we can truncate the minimum of the result range to the\n+     respective minimum range.  */\n+  if (wi::lt_p (vr0_max, 0, sign))\n+    wmin = wi::max (wmin, vr0_min, sign);\n+  if (wi::lt_p (vr1_max, 0, sign))\n+    wmin = wi::max (wmin, vr1_min, sign);\n+  /* If the limits got swapped around, indicate error so we can adjust\n+     the range to VARYING.  */\n+  if (wi::gt_p (wmin, wmax,sign))\n+    return false;\n+  return true;\n+}\n+\n+/* Calculate the bitwise AND of two ranges and store the result in [WMIN,WMAX].\n+   Return TRUE if we were able to successfully calculate the new range.  */\n+\n+bool\n+wide_int_range_bit_and (wide_int &wmin, wide_int &wmax,\n+\t\t\tsignop sign,\n+\t\t\tunsigned prec,\n+\t\t\tconst wide_int &vr0_min,\n+\t\t\tconst wide_int &vr0_max,\n+\t\t\tconst wide_int &vr1_min,\n+\t\t\tconst wide_int &vr1_max,\n+\t\t\tconst wide_int &must_be_nonzero0,\n+\t\t\tconst wide_int &may_be_nonzero0,\n+\t\t\tconst wide_int &must_be_nonzero1,\n+\t\t\tconst wide_int &may_be_nonzero1)\n+{\n+  wmin = must_be_nonzero0 & must_be_nonzero1;\n+  wmax = may_be_nonzero0 & may_be_nonzero1;\n+  /* If both input ranges contain only negative values we can\n+     truncate the result range maximum to the minimum of the\n+     input range maxima.  */\n+  if (wi::lt_p (vr0_max, 0, sign) && wi::lt_p (vr1_max, 0, sign))\n+    {\n+      wmax = wi::min (wmax, vr0_max, sign);\n+      wmax = wi::min (wmax, vr1_max, sign);\n+    }\n+  /* If either input range contains only non-negative values\n+     we can truncate the result range maximum to the respective\n+     maximum of the input range.  */\n+  if (wi::ge_p (vr0_min, 0, sign))\n+    wmax = wi::min (wmax, vr0_max, sign);\n+  if (wi::ge_p (vr1_min, 0, sign))\n+    wmax = wi::min (wmax, vr1_max, sign);\n+  /* PR68217: In case of signed & sign-bit-CST should\n+     result in [-INF, 0] instead of [-INF, INF].  */\n+  if (wi::gt_p (wmin, wmax, sign))\n+    {\n+      wide_int sign_bit = wi::set_bit_in_zero (prec - 1, prec);\n+      if (sign == SIGNED\n+\t  && ((wi::eq_p (vr0_min, vr0_max)\n+\t       && !wi::cmps (vr0_min, sign_bit))\n+\t      || (wi::eq_p (vr1_min, vr1_max)\n+\t\t  && !wi::cmps (vr1_min, sign_bit))))\n+\t{\n+\t  wmin = wi::min_value (prec, sign);\n+\t  wmax = wi::zero (prec);\n+\t}\n+    }\n+  /* If the limits got swapped around, indicate error so we can adjust\n+     the range to VARYING.  */\n+  if (wi::gt_p (wmin, wmax,sign))\n+    return false;\n+  return true;\n+}\n+\n+/* Calculate TRUNC_MOD_EXPR on two ranges and store the result in\n+   [WMIN,WMAX].  */\n+\n+void\n+wide_int_range_trunc_mod (wide_int &wmin, wide_int &wmax,\n+\t\t\t  signop sign,\n+\t\t\t  unsigned prec,\n+\t\t\t  const wide_int &vr0_min,\n+\t\t\t  const wide_int &vr0_max,\n+\t\t\t  const wide_int &vr1_min,\n+\t\t\t  const wide_int &vr1_max)\n+{\n+  wide_int tmp;\n+\n+  /* ABS (A % B) < ABS (B) and either\n+     0 <= A % B <= A or A <= A % B <= 0.  */\n+  wmax = vr1_max - 1;\n+  if (sign == SIGNED)\n+    {\n+      tmp = -1 - vr1_min;\n+      wmax = wi::smax (wmax, tmp);\n+    }\n+\n+  if (sign == UNSIGNED)\n+    wmin = wi::zero (prec);\n+  else\n+    {\n+      wmin = -wmax;\n+      tmp = vr0_min;\n+      if (wi::gts_p (tmp, 0))\n+\ttmp = wi::zero (prec);\n+      wmin = wi::smax (wmin, tmp);\n+    }\n+  tmp = vr0_max;\n+  if (sign == SIGNED && wi::neg_p (tmp))\n+    tmp = wi::zero (prec);\n+  wmax = wi::min (wmax, tmp, sign);\n+}"}, {"sha": "4421bc8aecad90a1718b4e94ff67153ec1b390f9", "filename": "gcc/wide-int-range.h", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2Fwide-int-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c9f8fca6d677b01bd622b17a2a7acb2938a69e0a/gcc%2Fwide-int-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fwide-int-range.h?ref=c9f8fca6d677b01bd622b17a2a7acb2938a69e0a", "patch": "@@ -0,0 +1,115 @@\n+/* Support routines for range operations on wide ints.\n+   Copyright (C) 2018 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_WIDE_INT_RANGE_H\n+#define GCC_WIDE_INT_RANGE_H\n+\n+extern bool wide_int_range_cross_product (wide_int &res_lb, wide_int &res_ub,\n+\t\t\t\t\t  enum tree_code code, signop sign,\n+\t\t\t\t\t  const wide_int &, const wide_int &,\n+\t\t\t\t\t  const wide_int &, const wide_int &,\n+\t\t\t\t\t  bool overflow_undefined);\n+extern bool wide_int_range_mult_wrapping (wide_int &res_lb,\n+\t\t\t\t\t  wide_int &res_ub,\n+\t\t\t\t\t  signop sign,\n+\t\t\t\t\t  unsigned prec,\n+\t\t\t\t\t  const wide_int &min0_,\n+\t\t\t\t\t  const wide_int &max0_,\n+\t\t\t\t\t  const wide_int &min1_,\n+\t\t\t\t\t  const wide_int &max1_);\n+extern bool wide_int_range_multiplicative_op (wide_int &res_lb,\n+\t\t\t\t\t      wide_int &res_ub,\n+\t\t\t\t\t      enum tree_code code,\n+\t\t\t\t\t      signop sign,\n+\t\t\t\t\t      unsigned prec,\n+\t\t\t\t\t      const wide_int &vr0_lb,\n+\t\t\t\t\t      const wide_int &vr0_ub,\n+\t\t\t\t\t      const wide_int &vr1_lb,\n+\t\t\t\t\t      const wide_int &vr1_ub,\n+\t\t\t\t\t      bool overflow_undefined,\n+\t\t\t\t\t      bool overflow_wraps);\n+extern bool wide_int_range_lshift (wide_int &res_lb, wide_int &res_ub,\n+\t\t\t\t   signop sign, unsigned prec,\n+\t\t\t\t   const wide_int &, const wide_int &,\n+\t\t\t\t   const wide_int &, const wide_int &,\n+\t\t\t\t   bool overflow_undefined,\n+\t\t\t\t   bool overflow_wraps);\n+extern void wide_int_range_set_zero_nonzero_bits (signop,\n+\t\t\t\t\t\t  const wide_int &lb,\n+\t\t\t\t\t\t  const wide_int &ub,\n+\t\t\t\t\t\t  wide_int &may_be_nonzero,\n+\t\t\t\t\t\t  wide_int &must_be_nonzero);\n+extern bool wide_int_range_can_optimize_bit_op (tree_code,\n+\t\t\t\t\t\tconst wide_int &lb,\n+\t\t\t\t\t\tconst wide_int &ub,\n+\t\t\t\t\t\tconst wide_int &mask);\n+extern bool wide_int_range_bit_xor (wide_int &wmin, wide_int &wmax,\n+\t\t\t\t    signop sign,\n+\t\t\t\t    unsigned prec,\n+\t\t\t\t    const wide_int &must_be_nonzero0,\n+\t\t\t\t    const wide_int &may_be_nonzero0,\n+\t\t\t\t    const wide_int &must_be_nonzero1,\n+\t\t\t\t    const wide_int &may_be_nonzero1);\n+extern bool wide_int_range_bit_ior (wide_int &wmin, wide_int &wmax,\n+\t\t\t\t    signop sign,\n+\t\t\t\t    const wide_int &vr0_min,\n+\t\t\t\t    const wide_int &vr0_max,\n+\t\t\t\t    const wide_int &vr1_min,\n+\t\t\t\t    const wide_int &vr1_max,\n+\t\t\t\t    const wide_int &must_be_nonzero0,\n+\t\t\t\t    const wide_int &may_be_nonzero0,\n+\t\t\t\t    const wide_int &must_be_nonzero1,\n+\t\t\t\t    const wide_int &may_be_nonzero1);\n+extern bool wide_int_range_bit_and (wide_int &wmin, wide_int &wmax,\n+\t\t\t\t    signop sign,\n+\t\t\t\t    unsigned prec,\n+\t\t\t\t    const wide_int &vr0_min,\n+\t\t\t\t    const wide_int &vr0_max,\n+\t\t\t\t    const wide_int &vr1_min,\n+\t\t\t\t    const wide_int &vr1_max,\n+\t\t\t\t    const wide_int &must_be_nonzero0,\n+\t\t\t\t    const wide_int &may_be_nonzero0,\n+\t\t\t\t    const wide_int &must_be_nonzero1,\n+\t\t\t\t    const wide_int &may_be_nonzero1);\n+extern void wide_int_range_trunc_mod (wide_int &wmin, wide_int &wmax,\n+\t\t\t\t      signop sign,\n+\t\t\t\t      unsigned prec,\n+\t\t\t\t      const wide_int &vr0_min,\n+\t\t\t\t      const wide_int &vr0_max,\n+\t\t\t\t      const wide_int &vr1_min,\n+\t\t\t\t      const wide_int &vr1_max);\n+\n+/* Return TRUE if shifting by range [MIN, MAX] is undefined behavior.  */\n+\n+inline bool\n+wide_int_range_shift_undefined_p (signop sign, unsigned prec,\n+\t\t\t\t  const wide_int &min, const wide_int &max)\n+{\n+  /* ?? Note: The original comment said this only applied to\n+     RSHIFT_EXPR, but it was being applied to both left and right\n+     shifts.  */\n+\n+  /* Shifting by any values outside [0..prec-1], gets undefined\n+     behavior from the shift operation.  We cannot even trust\n+     SHIFT_COUNT_TRUNCATED at this stage, because that applies to rtl\n+     shifts, and the operation at the tree level may be widened.  */\n+  return wi::lt_p (min, 0, sign) || wi::ge_p (max, prec, sign);\n+}\n+\n+#endif /* GCC_WIDE_INT_RANGE_H */"}]}