{"sha": "6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmI1ZTE2NWJkODIzNmUxYmNkNGU3YmMzYTZmZGMwZjYzZWQ5NDEwYQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-07-03T13:44:13Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-07-03T13:44:13Z"}, "message": "re PR tree-optimization/60510 (SLP blocks loop vectorization (with reduction))\n\n2017-07-03  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/60510\n\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Pass in\n\tthe scalar reduction PHI and use it.\n\t(vectorizable_reduction): Properly guard the single_defuse_cycle\n\tpath for non-SLP reduction chains where we cannot use it.\n\tRework reduc_def/index and vector type deduction.  Rework\n\tvector operand gathering during reduction op code-gen.\n\t* tree-vect-slp.c (vect_analyze_slp): For failed SLP reduction\n\tchains dissolve the chain and leave it to non-SLP reduction\n\thandling.\n\n\t* gfortran.dg/vect/pr60510.f: New testcase.\n\nFrom-SVN: r249919", "tree": {"sha": "0f6bd84c32cd696d16c9597b34acd016ebf22683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0f6bd84c32cd696d16c9597b34acd016ebf22683"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9607b014b29416b51200e8b7167bf47354d4b4f9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9607b014b29416b51200e8b7167bf47354d4b4f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9607b014b29416b51200e8b7167bf47354d4b4f9"}], "stats": {"total": 230, "additions": 160, "deletions": 70}, "files": [{"sha": "21e392f05c268bed9e74714de44335c0a7e80486", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a", "patch": "@@ -1,3 +1,16 @@\n+2017-07-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/60510\n+\t* tree-vect-loop.c (vect_create_epilog_for_reduction): Pass in\n+\tthe scalar reduction PHI and use it.\n+\t(vectorizable_reduction): Properly guard the single_defuse_cycle\n+\tpath for non-SLP reduction chains where we cannot use it.\n+\tRework reduc_def/index and vector type deduction.  Rework\n+\tvector operand gathering during reduction op code-gen.\n+\t* tree-vect-slp.c (vect_analyze_slp): For failed SLP reduction\n+\tchains dissolve the chain and leave it to non-SLP reduction\n+\thandling.\n+\n 2017-07-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-data-ref.h (dr_alignment): Declare."}, {"sha": "6158e3719b323562fc996bd55920501569559288", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a", "patch": "@@ -1,3 +1,8 @@\n+2017-07-03  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/60510\n+\t* gfortran.dg/vect/pr60510.f: New testcase.\n+\n 2017-07-03  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \t* gcc.target/i386/mvc6.c: Require ifunc support."}, {"sha": "2d1b6a9ff3ebe4234d32347922927a51fba65f6e", "filename": "gcc/testsuite/gfortran.dg/vect/pr60510.f", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr60510.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr60510.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fvect%2Fpr60510.f?ref=6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do run }\n+! { dg-additional-options \"-fno-inline -ffast-math\" }\n+      subroutine foo(a,x,y,n)\n+      implicit none\n+      integer n,i\n+\n+      real*8 y(n),x(n),a\n+\n+      do i=1,n\n+         a=a+x(i)*y(i)+x(i)\n+      enddo\n+\n+      return\n+      end\n+\n+      program test\n+      real*8 x(1024),y(1024),a\n+      do i=1,1024\n+        x(i) = i\n+        y(i) = i+1\n+      enddo\n+      call foo(a,x,y,1024)\n+      if (a.ne.359488000.0) call abort()\n+      end\n+! If there's no longer a reduction chain detected this doesn't test what\n+! it was supposed to test, vectorizing a reduction chain w/o SLP.\n+! { dg-final { scan-tree-dump \"reduction chain\" \"vect\" } }\n+! We should vectorize the reduction in foo and the induction in test.\n+! { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } }"}, {"sha": "599a328123598bd9f66704cd206ea15e30067c86", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 99, "deletions": 69, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a", "patch": "@@ -4313,6 +4313,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n \n static void\n vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n+\t\t\t\t  gimple *reduc_def_stmt,\n \t\t\t\t  int ncopies, enum tree_code reduc_code,\n \t\t\t\t  vec<gimple *> reduction_phis,\n                                   int reduc_index, bool double_reduc, \n@@ -4401,9 +4402,8 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n     {\n       /* Get at the scalar def before the loop, that defines the initial value\n \t of the reduction variable.  */\n-      tree reduction_op = get_reduction_op (stmt, reduc_index);\n-      gimple *def_stmt = SSA_NAME_DEF_STMT (reduction_op);\n-      initial_def = PHI_ARG_DEF_FROM_EDGE (def_stmt,\n+      gimple *def_stmt;\n+      initial_def = PHI_ARG_DEF_FROM_EDGE (reduc_def_stmt,\n \t\t\t\t\t   loop_preheader_edge (loop));\n       vect_is_simple_use (initial_def, loop_vinfo, &def_stmt, &initial_def_dt);\n       vec_initial_def = get_initial_def_for_reduction (stmt, initial_def,\n@@ -5581,26 +5581,25 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree scalar_type;\n   bool is_simple_use;\n   gimple *orig_stmt;\n-  stmt_vec_info orig_stmt_info;\n+  stmt_vec_info orig_stmt_info = NULL;\n   int i;\n   int ncopies;\n   int epilog_copies;\n   stmt_vec_info prev_stmt_info, prev_phi_info;\n   bool single_defuse_cycle = false;\n-  tree reduc_def = NULL_TREE;\n   gimple *new_stmt = NULL;\n   int j;\n   tree ops[3];\n   enum vect_def_type dts[3];\n   bool nested_cycle = false, found_nested_cycle_def = false;\n-  gimple *reduc_def_stmt = NULL;\n   bool double_reduc = false;\n   basic_block def_bb;\n   struct loop * def_stmt_loop, *outer_loop = NULL;\n   tree def_arg;\n   gimple *def_arg_stmt;\n   auto_vec<tree> vec_oprnds0;\n   auto_vec<tree> vec_oprnds1;\n+  auto_vec<tree> vec_oprnds2;\n   auto_vec<tree> vect_defs;\n   auto_vec<gimple *> phis;\n   int vec_num;\n@@ -5643,8 +5642,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       gimple *reduc_stmt = STMT_VINFO_REDUC_DEF (stmt_info);\n       if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (reduc_stmt)))\n \treduc_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (reduc_stmt));\n-      if (STMT_VINFO_RELEVANT (vinfo_for_stmt (reduc_stmt)) <= vect_used_only_live)\n-\tsingle_defuse_cycle = true;\n \n       gcc_assert (is_gimple_assign (reduc_stmt));\n       for (unsigned k = 1; k < gimple_num_ops (reduc_stmt); ++k)\n@@ -5666,6 +5663,17 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \tncopies = (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n \t\t   / TYPE_VECTOR_SUBPARTS (vectype_in));\n \n+      use_operand_p use_p;\n+      gimple *use_stmt;\n+      if (ncopies > 1\n+\t  && (STMT_VINFO_RELEVANT (vinfo_for_stmt (reduc_stmt))\n+\t      <= vect_used_only_live)\n+\t  && single_imm_use (gimple_phi_result (stmt), &use_p, &use_stmt)\n+\t  && (use_stmt == reduc_stmt\n+\t      || (STMT_VINFO_RELATED_STMT (vinfo_for_stmt (use_stmt))\n+\t\t  == reduc_stmt)))\n+\tsingle_defuse_cycle = true;\n+\n       /* Create the destination vector  */\n       scalar_dest = gimple_assign_lhs (reduc_stmt);\n       vec_dest = vect_create_destination_var (scalar_dest, vectype_out);\n@@ -5769,10 +5777,6 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     default:\n       gcc_unreachable ();\n     }\n-  /* The default is that the reduction variable is the last in statement.  */\n-  int reduc_index = op_type - 1;\n-  if (code == MINUS_EXPR)\n-    reduc_index = 0;\n \n   if (code == COND_EXPR && slp_node)\n     return false;\n@@ -5792,22 +5796,30 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n      The last use is the reduction variable.  In case of nested cycle this\n      assumption is not true: we use reduc_index to record the index of the\n      reduction variable.  */\n+  gimple *reduc_def_stmt = NULL;\n+  int reduc_index = -1;\n   for (i = 0; i < op_type; i++)\n     {\n-      if (i == reduc_index)\n-\tcontinue;\n-\n       /* The condition of COND_EXPR is checked in vectorizable_condition().  */\n       if (i == 0 && code == COND_EXPR)\n         continue;\n \n       is_simple_use = vect_is_simple_use (ops[i], loop_vinfo,\n \t\t\t\t\t  &def_stmt, &dts[i], &tem);\n-      if (!vectype_in)\n-\tvectype_in = tem;\n+      dt = dts[i];\n       gcc_assert (is_simple_use);\n+      if (dt == vect_reduction_def)\n+\t{\n+          reduc_def_stmt = def_stmt;\n+\t  reduc_index = i;\n+\t  continue;\n+\t}\n+      else\n+\t{\n+\t  if (!vectype_in)\n+\t    vectype_in = tem;\n+\t}\n \n-      dt = dts[i];\n       if (dt != vect_internal_def\n \t  && dt != vect_external_def\n \t  && dt != vect_constant_def\n@@ -5836,22 +5848,29 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t}\n     }\n \n-  is_simple_use = vect_is_simple_use (ops[reduc_index], loop_vinfo,\n-\t\t\t\t      &def_stmt, &dts[reduc_index], &tem);\n   if (!vectype_in)\n-    vectype_in = tem;\n-  gcc_assert (is_simple_use);\n-  if (!found_nested_cycle_def)\n-    reduc_def_stmt = def_stmt;\n+    vectype_in = vectype_out;\n \n-  if (reduc_def_stmt && gimple_code (reduc_def_stmt) != GIMPLE_PHI)\n+  /* When vectorizing a reduction chain w/o SLP the reduction PHI is not\n+     directy used in stmt.  */\n+  if (reduc_index == -1)\n+    {\n+      if (orig_stmt)\n+\treduc_def_stmt = STMT_VINFO_REDUC_DEF (orig_stmt_info);\n+      else\n+\treduc_def_stmt = STMT_VINFO_REDUC_DEF (stmt_info);\n+    }\n+\n+  if (! reduc_def_stmt || gimple_code (reduc_def_stmt) != GIMPLE_PHI)\n     return false;\n \n-  dt = dts[reduc_index];\n-  if (!(dt == vect_reduction_def\n-\t|| dt == vect_nested_cycle\n-\t|| ((dt == vect_internal_def || dt == vect_external_def\n-\t     || dt == vect_constant_def || dt == vect_induction_def)\n+  if (!(reduc_index == -1\n+\t|| dts[reduc_index] == vect_reduction_def\n+\t|| dts[reduc_index] == vect_nested_cycle\n+\t|| ((dts[reduc_index] == vect_internal_def\n+\t     || dts[reduc_index] == vect_external_def\n+\t     || dts[reduc_index] == vect_constant_def\n+\t     || dts[reduc_index] == vect_induction_def)\n \t    && nested_cycle && found_nested_cycle_def)))\n     {\n       /* For pattern recognized stmts, orig_stmt might be a reduction,\n@@ -6249,9 +6268,17 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n    (i.e. we generate VF/2 results in a single register).\n    In this case for each copy we get the vector def for the reduction variable\n    from the vectorized reduction operation generated in the previous iteration.\n-  */\n \n-  if (STMT_VINFO_RELEVANT (stmt_info) <= vect_used_only_live)\n+   This only works when we see both the reduction PHI and its only consumer\n+   in vectorizable_reduction and there are no intermediate stmts\n+   participating.  */\n+  use_operand_p use_p;\n+  gimple *use_stmt;\n+  if (ncopies > 1\n+      && (STMT_VINFO_RELEVANT (stmt_info) <= vect_used_only_live)\n+      && single_imm_use (gimple_phi_result (reduc_def_stmt), &use_p, &use_stmt)\n+      && (use_stmt == stmt\n+\t  || STMT_VINFO_RELATED_STMT (vinfo_for_stmt (use_stmt)) == stmt))\n     {\n       single_defuse_cycle = true;\n       epilog_copies = 1;\n@@ -6267,8 +6294,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     {\n       vec_num = 1;\n       vec_oprnds0.create (1);\n+      vec_oprnds1.create (1);\n       if (op_type == ternary_op)\n-        vec_oprnds1.create (1);\n+        vec_oprnds2.create (1);\n     }\n \n   phis.create (vec_num);\n@@ -6321,65 +6349,66 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      auto_vec<tree, 3> slp_ops;\n \t      auto_vec<vec<tree>, 3> vec_defs;\n \n-\t      slp_ops.quick_push (reduc_index == 0 ? NULL : ops[0]);\n-\t      slp_ops.quick_push (reduc_index == 1 ? NULL : ops[1]);\n+\t      slp_ops.quick_push (ops[0]);\n+\t      slp_ops.quick_push (ops[1]);\n \t      if (op_type == ternary_op)\n-\t\tslp_ops.quick_push (reduc_index == 2 ? NULL : ops[2]);\n+\t\tslp_ops.quick_push (ops[2]);\n \n \t      vect_get_slp_defs (slp_ops, slp_node, &vec_defs);\n \n-\t      vec_oprnds0.safe_splice (vec_defs[reduc_index == 0 ? 1 : 0]);\n-\t      vec_defs[reduc_index == 0 ? 1 : 0].release ();\n+\t      vec_oprnds0.safe_splice (vec_defs[0]);\n+\t      vec_defs[0].release ();\n+\t      vec_oprnds1.safe_splice (vec_defs[1]);\n+\t      vec_defs[1].release ();\n \t      if (op_type == ternary_op)\n \t\t{\n-\t\t  vec_oprnds1.safe_splice (vec_defs[reduc_index == 2 ? 1 : 2]);\n-\t\t  vec_defs[reduc_index == 2 ? 1 : 2].release ();\n+\t\t  vec_oprnds2.safe_splice (vec_defs[2]);\n+\t\t  vec_defs[2].release ();\n \t\t}\n \t    }\n           else\n \t    {\n               vec_oprnds0.quick_push\n-\t\t(vect_get_vec_def_for_operand (ops[!reduc_index], stmt));\n+\t\t(vect_get_vec_def_for_operand (ops[0], stmt));\n+              vec_oprnds1.quick_push\n+\t\t(vect_get_vec_def_for_operand (ops[1], stmt));\n               if (op_type == ternary_op)\n-\t\tvec_oprnds1.quick_push \n-\t\t  (vect_get_vec_def_for_operand (reduc_index == 0\n-\t\t\t\t\t\t ? ops[2] : ops[1], stmt));\n+\t\tvec_oprnds2.quick_push \n+\t\t  (vect_get_vec_def_for_operand (ops[2], stmt));\n \t    }\n         }\n       else\n         {\n           if (!slp_node)\n             {\n-              vec_oprnds0[0]\n-\t\t= vect_get_vec_def_for_stmt_copy (dts[!reduc_index],\n-\t\t\t\t\t\t  vec_oprnds0[0]);\n-              if (op_type == ternary_op)\n-                vec_oprnds1[0] \n-\t\t  = vect_get_vec_def_for_stmt_copy (dts[reduc_index == 0\n-\t\t\t\t\t\t        ? 2 : 1],\n-\t\t\t\t\t\t    vec_oprnds1[0]);\n-            }\n+\t      gcc_assert (reduc_index != -1 || ! single_defuse_cycle);\n \n-          if (single_defuse_cycle)\n-            reduc_def = gimple_assign_lhs (new_stmt);\n+\t      if (single_defuse_cycle && reduc_index == 0)\n+\t\tvec_oprnds0[0] = gimple_assign_lhs (new_stmt);\n+\t      else\n+\t\tvec_oprnds0[0]\n+\t\t  = vect_get_vec_def_for_stmt_copy (dts[0], vec_oprnds0[0]);\n+\t      if (single_defuse_cycle && reduc_index == 1)\n+\t\tvec_oprnds1[0] = gimple_assign_lhs (new_stmt);\n+\t      else\n+\t\tvec_oprnds1[0]\n+\t\t  = vect_get_vec_def_for_stmt_copy (dts[1], vec_oprnds1[0]);\n+\t      if (op_type == ternary_op)\n+\t\t{\n+\t\t  if (single_defuse_cycle && reduc_index == 2)\n+\t\t    vec_oprnds2[0] = gimple_assign_lhs (new_stmt);\n+\t\t  else\n+\t\t    vec_oprnds2[0] \n+\t\t      = vect_get_vec_def_for_stmt_copy (dts[2], vec_oprnds2[0]);\n+\t\t}\n+            }\n         }\n \n       FOR_EACH_VEC_ELT (vec_oprnds0, i, def0)\n         {\n-          if (slp_node)\n-            reduc_def = PHI_RESULT (phis[i]);\n-          else\n-            {\n-              if (!single_defuse_cycle || j == 0)\n-                reduc_def = PHI_RESULT (new_phi);\n-            }\n-\n-\t  tree vop[3] = { def0, NULL_TREE, NULL_TREE };\n+\t  tree vop[3] = { def0, vec_oprnds1[i], NULL_TREE };\n \t  if (op_type == ternary_op)\n-\t    vop[1] = vec_oprnds1[i];\n-\t  for (int k = 2; k > reduc_index; --k)\n-\t    vop[k] = vop[k - 1];\n-\t  vop[reduc_index] = reduc_def;\n+\t    vop[2] = vec_oprnds2[i];\n \n           new_temp = make_ssa_name (vec_dest, new_stmt);\n           new_stmt = gimple_build_assign (new_temp, code,\n@@ -6411,7 +6440,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   if ((!single_defuse_cycle || code == COND_EXPR) && !slp_node)\n     vect_defs[0] = gimple_assign_lhs (*vec_stmt);\n \n-  vect_create_epilog_for_reduction (vect_defs, stmt, epilog_copies,\n+  vect_create_epilog_for_reduction (vect_defs, stmt, reduc_def_stmt,\n+\t\t\t\t    epilog_copies,\n                                     epilog_reduc_code, phis, reduc_index,\n \t\t\t\t    double_reduc, slp_node);\n "}, {"sha": "4502146595ddec9b2305b6321bb8fd8ea1c95adb", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=6b5e165bd8236e1bcd4e7bc3a6fdc0f63ed9410a", "patch": "@@ -2121,7 +2121,20 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \t  FOR_EACH_VEC_ELT (loop_vinfo->reduction_chains, i, first_element)\n \t    if (! vect_analyze_slp_instance (vinfo, first_element,\n \t\t\t\t\t     max_tree_size))\n-\t      return false;\n+\t      {\n+\t\t/* Dissolve reduction chain group.  */\n+\t\tgimple *next, *stmt = first_element;\n+\t\twhile (stmt)\n+\t\t  {\n+\t\t    stmt_vec_info vinfo = vinfo_for_stmt (stmt);\n+\t\t    next = GROUP_NEXT_ELEMENT (vinfo);\n+\t\t    GROUP_FIRST_ELEMENT (vinfo) = NULL;\n+\t\t    GROUP_NEXT_ELEMENT (vinfo) = NULL;\n+\t\t    stmt = next;\n+\t\t  }\n+\t\tSTMT_VINFO_DEF_TYPE (vinfo_for_stmt (first_element))\n+\t\t  = vect_internal_def;\n+\t      }\n \t}\n \n       /* Find SLP sequences starting from groups of reductions.  */"}]}