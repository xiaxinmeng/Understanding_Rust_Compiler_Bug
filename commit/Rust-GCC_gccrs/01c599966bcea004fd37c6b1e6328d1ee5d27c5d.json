{"sha": "01c599966bcea004fd37c6b1e6328d1ee5d27c5d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDFjNTk5OTY2YmNlYTAwNGZkMzdjNmIxZTYzMjhkMWVlNWQyN2M1ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-26T19:48:47Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-01-26T19:48:47Z"}, "message": "Copy initializer to heap if it may contain pointers.\n\nFrom-SVN: r169297", "tree": {"sha": "e9c89bf845eb427a7d933ace41b34b9148b4bec3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e9c89bf845eb427a7d933ace41b34b9148b4bec3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/01c599966bcea004fd37c6b1e6328d1ee5d27c5d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c599966bcea004fd37c6b1e6328d1ee5d27c5d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/01c599966bcea004fd37c6b1e6328d1ee5d27c5d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/01c599966bcea004fd37c6b1e6328d1ee5d27c5d/comments", "author": null, "committer": null, "parents": [{"sha": "e435f0985f7bd7155531d2c31ab2be113be12909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e435f0985f7bd7155531d2c31ab2be113be12909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e435f0985f7bd7155531d2c31ab2be113be12909"}], "stats": {"total": 27, "additions": 17, "deletions": 10}, "files": [{"sha": "739032b3290ab525c0b8073c4608531b7ce933df", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/01c599966bcea004fd37c6b1e6328d1ee5d27c5d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/01c599966bcea004fd37c6b1e6328d1ee5d27c5d/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=01c599966bcea004fd37c6b1e6328d1ee5d27c5d", "patch": "@@ -11138,7 +11138,15 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n     return error_mark_node;\n \n   bool is_constant_initializer = TREE_CONSTANT(values);\n-  bool is_in_function = context->function() != NULL;\n+\n+  // We have to copy the initial values into heap memory if we are in\n+  // a function or if the values are not constants.  We also have to\n+  // copy them if they may contain pointers in a non-constant context,\n+  // as otherwise the garbage collector won't see them.\n+  bool copy_to_heap = (context->function() != NULL\n+\t\t       || !is_constant_initializer\n+\t\t       || (element_type->has_pointer()\n+\t\t\t   && !context->is_const()));\n \n   if (is_constant_initializer)\n     {\n@@ -11148,12 +11156,12 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n       TREE_PUBLIC(tmp) = 0;\n       TREE_STATIC(tmp) = 1;\n       DECL_ARTIFICIAL(tmp) = 1;\n-      if (is_in_function)\n+      if (copy_to_heap)\n \t{\n-\t  // If this is not a function, we will only initialize the\n-\t  // value once, so we can use this directly rather than\n-\t  // copying it.  In that case we can't make it read-only,\n-\t  // because the program is permitted to change it.\n+\t  // If we are not copying the value to the heap, we will only\n+\t  // initialize the value once, so we can use this directly\n+\t  // rather than copying it.  In that case we can't make it\n+\t  // read-only, because the program is permitted to change it.\n \t  TREE_READONLY(tmp) = 1;\n \t  TREE_CONSTANT(tmp) = 1;\n \t}\n@@ -11164,10 +11172,9 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n \n   tree space;\n   tree set;\n-  if (!is_in_function && is_constant_initializer)\n+  if (!copy_to_heap)\n     {\n-      // Outside of a function, we know the initializer will only run\n-      // once.\n+      // the initializer will only run once.\n       space = build_fold_addr_expr(values);\n       set = NULL_TREE;\n     }\n@@ -11214,7 +11221,7 @@ Open_array_construction_expression::do_get_tree(Translate_context* context)\n   tree constructor = build_constructor(type_tree, init);\n   if (constructor == error_mark_node)\n     return error_mark_node;\n-  if (!is_in_function && is_constant_initializer)\n+  if (!copy_to_heap)\n     TREE_CONSTANT(constructor) = 1;\n \n   if (set == NULL_TREE)"}]}