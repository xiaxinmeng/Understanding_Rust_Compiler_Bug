{"sha": "3928bd5fc16719d56d6f99514148d4b05fcb9cc0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkyOGJkNWZjMTY3MTlkNTZkNmY5OTUxNDE0OGQ0YjA1ZmNiOWNjMA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-08-23T19:43:38Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-08-23T19:43:38Z"}, "message": "semantics.c (finish_member_declaration): Move USING_DECL check earlier.\n\n\t* semantics.c (finish_member_declaration): Move USING_DECL check\n\tearlier.  Always set C++ linkage.  Commonize TYPE_FIELD and\n\ttemplate decl list insertion.\n\nFrom-SVN: r251317", "tree": {"sha": "b151354daeecc119e542e5fed89789a62d400f91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b151354daeecc119e542e5fed89789a62d400f91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3928bd5fc16719d56d6f99514148d4b05fcb9cc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3928bd5fc16719d56d6f99514148d4b05fcb9cc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3928bd5fc16719d56d6f99514148d4b05fcb9cc0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3928bd5fc16719d56d6f99514148d4b05fcb9cc0/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "25d203fbadc0302b8bbdf948a46ba84cee1db335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25d203fbadc0302b8bbdf948a46ba84cee1db335", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25d203fbadc0302b8bbdf948a46ba84cee1db335"}], "stats": {"total": 67, "additions": 27, "deletions": 40}, "files": [{"sha": "94c55eded4d7091ac7089d4b757912f58024698e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3928bd5fc16719d56d6f99514148d4b05fcb9cc0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3928bd5fc16719d56d6f99514148d4b05fcb9cc0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3928bd5fc16719d56d6f99514148d4b05fcb9cc0", "patch": "@@ -1,5 +1,9 @@\n 2017-08-23  Nathan Sidwell  <nathan@acm.org>\n \n+\t* semantics.c (finish_member_declaration): Move USING_DECL check\n+\tearlier.  Always set C++ linkage.  Commonize TYPE_FIELD and\n+\ttemplate decl list insertion.\n+\n \t* cp-tree.h (maybe_version_functions): Declare.\n \t* decl.c (decls_match): Break function versioning check to\n \tseparate function.  Call it."}, {"sha": "14e680f39f5de98ba9f0ddf03fc0ea56c2aee5de", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 23, "deletions": 40, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3928bd5fc16719d56d6f99514148d4b05fcb9cc0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3928bd5fc16719d56d6f99514148d4b05fcb9cc0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=3928bd5fc16719d56d6f99514148d4b05fcb9cc0", "patch": "@@ -3025,7 +3025,13 @@ finish_member_declaration (tree decl)\n   if (TREE_CODE (decl) != CONST_DECL)\n     DECL_CONTEXT (decl) = current_class_type;\n \n-  /* Check for bare parameter packs in the member variable declaration.  */\n+  if (TREE_CODE (decl) == USING_DECL)\n+    /* For now, ignore class-scope USING_DECLS, so that debugging\n+       backends do not see them. */\n+    DECL_IGNORED_P (decl) = 1;\n+\n+  /* Check for bare parameter packs in the non-static data member\n+     declaration.  */\n   if (TREE_CODE (decl) == FIELD_DECL)\n     {\n       if (check_for_bare_parameter_packs (TREE_TYPE (decl)))\n@@ -3038,54 +3044,31 @@ finish_member_declaration (tree decl)\n \n      A C language linkage is ignored for the names of class members\n      and the member function type of class member functions.  */\n-  if (DECL_LANG_SPECIFIC (decl) && DECL_LANGUAGE (decl) == lang_c)\n+  if (DECL_LANG_SPECIFIC (decl))\n     SET_DECL_LANGUAGE (decl, lang_cplusplus);\n \n-  /* Put the decl on the TYPE_FIELDS list.  Note that this is built up\n-     in reverse order.  We reverse it (to obtain declaration order) in\n-     finish_struct.  */\n-  if (DECL_DECLARES_FUNCTION_P (decl))\n-    {\n-      /* We also need to add this function to the\n-\t CLASSTYPE_METHOD_VEC.  */\n-      if (add_method (current_class_type, decl, false))\n-\t{\n-\t  gcc_assert (TYPE_MAIN_VARIANT (current_class_type) == current_class_type);\n-\t  DECL_CHAIN (decl) = TYPE_FIELDS (current_class_type);\n-\t  TYPE_FIELDS (current_class_type) = decl;\n+  bool add = false;\n \n-\t  maybe_add_class_template_decl_list (current_class_type, decl,\n-\t\t\t\t\t      /*friend_p=*/0);\n-\t}\n-    }\n+  /* Functions and non-functions are added differently.  */\n+  if (DECL_DECLARES_FUNCTION_P (decl))\n+    add = add_method (current_class_type, decl, false);\n   /* Enter the DECL into the scope of the class, if the class\n      isn't a closure (whose fields are supposed to be unnamed).  */\n   else if (CLASSTYPE_LAMBDA_EXPR (current_class_type)\n \t   || pushdecl_class_level (decl))\n-    {\n-      if (TREE_CODE (decl) == USING_DECL)\n-\t{\n-\t  /* For now, ignore class-scope USING_DECLS, so that\n-\t     debugging backends do not see them. */\n-\t  DECL_IGNORED_P (decl) = 1;\n-\t}\n+    add = true;\n \n+  if (add)\n+    {\n       /* All TYPE_DECLs go at the end of TYPE_FIELDS.  Ordinary fields\n-\t go at the beginning.  The reason is that lookup_field_1\n-\t searches the list in order, and we want a field name to\n-\t override a type name so that the \"struct stat hack\" will\n-\t work.  In particular:\n-\n-\t   struct S { enum E { }; int E } s;\n-\t   s.E = 3;\n-\n-\t is valid.  In addition, the FIELD_DECLs must be maintained in\n-\t declaration order so that class layout works as expected.\n-\t However, we don't need that order until class layout, so we\n-\t save a little time by putting FIELD_DECLs on in reverse order\n-\t here, and then reversing them in finish_struct_1.  (We could\n-\t also keep a pointer to the correct insertion points in the\n-\t list.)  */\n+\t go at the beginning.  The reason is that\n+\t legacy_nonfn_member_lookup searches the list in order, and we\n+\t want a field name to override a type name so that the \"struct\n+\t stat hack\" will work.  In particular:\n+\n+\t   struct S { enum E { }; static const int E = 5; int ary[S::E]; } s;\n+\n+\t is valid.  */\n \n       if (TREE_CODE (decl) == TYPE_DECL)\n \tTYPE_FIELDS (current_class_type)"}]}