rust
///! This code is from the core runtime crate, it is linked in to compiled executables to act as the main entry point
#![feature(main)]

mod atoms;
mod symbols;

extern "Rust" {
    /// We support linking against different high-level runtime implementations, they are required to
    /// export an `rt_entry` function.
    #[link_name = "rt_entry"]
    fn rt_entry() -> i32;

    /// The symbol `__rt_lang_start_internal` is generated by our compiler by first discovering the
    /// name of the real Rust lang_start_internal symbol of the Rust toolchain it is built against, and then generating
    /// code to act as a shim for calling that symbol, but exported with a consistent name
    #[link_name = "__rt_lang_start_internal"]
    fn lang_start(main: &dyn Fn() -> i32, argc: isize, argv: *const *const i8) -> isize;
}

#[no_mangle]
pub extern "C" fn main(argc: i32, argv: *const *const std::os::raw::c_char) -> i32 {
    unsafe { lang_start(&move || main_internal(), argc as isize, argv) as i32 }
}

/// The primary entry point for our runtime
///
/// This function is responsible for setting up any core functionality required
/// by the higher-level runtime, e.g. initializing the atom table. Once initialized,
/// this function invokes the platform-specific entry point which handles starting
/// up the scheduler and other high-level runtime functionality.
#[main]
pub fn main_internal() -> i32 {
    use crate::atoms::*;
    use crate::symbols::*;

    // Initialize atom table
    if unsafe { InitializeAtomTable(ATOM_TABLE, NUM_ATOMS) } == false {
        return 102;
    }

    // Initialize the dispatch table
    if unsafe { InitializeDispatchTable(SYMBOL_TABLE, NUM_SYMBOLS) } == false {
        return 103;
    }

    // Invoke platform-specific entry point
    unsafe { rt_entry() }
}
