compile_fail,E0107\nstruct Foo<'a, 'b>(&'a str, &'b str);\nenum Bar { A, B, C }\n\nstruct Baz<'a> {\n    foo: Foo<'a>, // error: wrong number of lifetime arguments:\n                  //        expected 2, found 1\n    bar: Bar<'a>, // error: wrong number of lifetime arguments:\n                  //        expectch it must\nalready specify all requirements that will be used for every type parameter.\n"},"level":"error","spans":[{"file_name":"/checkout/src/test/ui/traits/trait-test-2.rs","byte_start":904,"byte_end":907,"line_start":20,"line_end":20,"column_start":26,"column_end":29,"is_primary":true,"text":[{"text":"    (box 10 as Box<bar>).dup();","highlight_start":26,"highlight_end":29}],"label":"the trait `bar` is not implemented for `dyn bar`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error[E0277]: the trait bound `dyn bar: bar` is not satisfied\n  --> /checkout/src/test/ui/traits/trait-test-2.rs:20:26\n   |\nLL |     (box 10 as Box<bar>).dup();\n   |                          ^^^ the trait `bar` is not implemented for `dyn bar`\n\n"}
[00:47:09] {"message":"the trait `bar` cannot be made into an object","code":{"code":"E0038","explanation":"\nTrait objects like `Box<Trait>` can only be constructed when certain\nrequirements are satisfied by the trait in question.\n\nTrait objects are a form of dynamic dispatch and use a dynamically sized type\nfor the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\ntype, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed\npointer is a 'fat pointer' that contains an extra pointer to a table of methods\n(among other things) for dynamic dispatch. This design mandates some\nrestrictions on the types of traits that are allowed to be used in trait\nobjects, which are collectively termed as 'object safety' rules.\n\nAttempting to create a trait object for a non object-safe trait will trigger\nths called with unparametrized substitutions\n(i.e., substitutions where none of the substituted types are themselves\nparametrized).\n\nHowever, with trait objects we have to make a table containing _every_ object\nthat implements the trait. Now, if it has type parameters, we need to add\nimplementations for every type that implements the trait, and there could\ntheoretically be an infinite number of types.\n\nFor example, with:\n\n