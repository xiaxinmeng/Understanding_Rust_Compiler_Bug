\n"},"level":"error","spans":[{"file_name":"<::rustc_data_structures::indexed_vec::newtype_index macros>","byte_start":6098,"byte_end":6105,"line_start":112,"line_end":112,"column_start":17,"column_end":24,"is_primary":true,"text":[{"text":"fn decode < D : Decoder > ( d : & mut D ) -> Result < Self , D :: Error > {","highlight_start":17,"highlight_end":24}],"label":"not found in this scope","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"<::rustc_data_structures::indexed_vec::newtype_index macros>","byte_start":219,"byte_end":335,"line_start":5,"line_end":7,"column_start":1,"column_end":21,"is_primary":false,"text":[{"text":"newtype_index ! (","highlight_start":1,"highlight_end":18},{"text":"@ type [ $ name ] @ max [ 0xFFFF_FF00 ] @ vis [ $ v ] @ debug_format [ \"{}\" ]","highlight_start":1,"highlight_end":78},{"text":"$ ( $ tokens ) + ) ; ) ; (","highlight_start":1,"highlight_end":21}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"/checkout/src/test/run-pass-fulldeps/newtype_index.rs","byte_start":179,"byte_end":230,"line_start":8,"line_end":8,"column_start":1,"column_end":52,"is_primary":false,"text":[{"text":"newtype_index!(struct MyIdx { MAX = 0xFFFF_FFFA });","highlight_start":1,"highlight_end":52}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"newtype_index!","def_site_span":{"file_name":"<::rustc_data_structures::indexed_vec::newtype_index macros>","byte_start":0,"byte_end":8246,"line_start":1,"line_end":146,"column_start":1,"column_end":65,"is_primary":false,"text":[{"text":"( $ v : vis struct $ name : ident { .. } ) => (","highlight_start":1,"highlight_end":48},{"text":"newtype_index ! (","highlight_start":1,"highlight_end":18},{"text":"@ type [ $ name ] @ max [ 0xFFFF_FF00 ] @ vis [ $ v ] @ debug_format [ \"{}\" ]","highlight_start":1,"highlight_end":78},{"text":") ; ) ; ( $ v : vis struct $ name : ident { $ ( $ tokens : tt ) + } ) => (","highlight_start":1,"highlight_end":75},{"text":"newtype_index ! (","highlight_start":1,"highlight_end":18},{"text":"@ type [ $ name ] @ max [ 0xFFFF_FF00 ] @ vis [ $ v ] @ debug_format [ \"{}\" ]","highlight_start":1,"highlight_end":78},{"text":"$ ( $ tokens ) + ) ; ) ; (","highlight_start":1,"highlight_end":27},{"text":"@ derives [ $ ( $ derives : ident , ) * ] @ type [ $ type : ident ] @ max [","highlight_start":1,"highlight_end":76},{"text":"$ max : expr ] @ vis [ $ v : vis ] @ debug_format [ $ debug_format : tt ] ) =>","highlight_start":1,"highlight_end":79},{"text":"(","highlight_start":1,"highlight_end":2},{"text":"# [","highlight_start":1,"highlight_end":4},{"text":"derive ( Copy , PartialEq , Eq , Hash , PartialOrd , Ord , $ ( $ derives ) , *","highlight_start":1,"highlight_end":79},{"text":") ] # [ rustc_layout_scalar_valid_range_end ( $ max ) ] $ v struct $ type {","highlight_start":1,"highlight_end":76},{"text":"private : u32 } impl Clone for $ type { fn clone ( & self ) -> Self { * self }","highlight_start":1,"highlight_end":79},{"text":"} impl $ type {","highlight_start":1,"highlight_end":16},{"text":"$ v const MAX_AS_U32 : u32 = $ max ; $ v const MAX : $ type = $ type ::","highlight_start":1,"highlight_end":72},{"text":"from_u32_const ( $ max ) ; # [ inline ] $ v fn from_usize ( value : usize ) ->","highlight_start":1,"highlight_end":79},{"text":"Self {","highlight_start":1,"highlight_end":7},{"text":"assert ! ( value <= ( $ max as usize ) ) ; unsafe {","highlight_start":1,"highlight_end":52},{"text":"$ type :: from_u32_unchecked ( value as u32 ) } } # [ inline ] $ v fn from_u32","highlight_start":1,"highlight_end":79},{"text":"( value : u32 ) -> Self {","highlight_start":1,"highlight_end":26},{"text":"assert ! ( value <= $ max ) ; unsafe { $ type :: from_u32_unchecked ( value )","highlight_start":1,"highlight_end":78},{"text":"} } /// Hacky variant of `from_u32` for use in constants.","highlight_start":1,"highlight_end":58},{"text":" /// This version checks the \"max\" constraint by using an","highlight_start":1,"highlight_end":58},{"text":" /// invalid array dereference.","highlight_start":1,"highlight_end":32},{"text":" # [ inline ] $ v const fn from_u32_const ( value : u32 ) -> Self {","highlight_start":1,"highlight_end":68},{"text":"let _ = [ \"out of range value used\" ] [ ! ( value <= $ max ) as usize ] ;","highlight_start":1,"highlight_end":74},{"text":"unsafe { $ type { private : value } } } # [ inline ] $ v const unsafe fn","highlight_start":1,"highlight_end":73},{"text":"from_u32_unchecked ( value : u32 ) -> Self {","highlight_start":1,"highlight_end":45},{"text":"unsafe { $ type { private : value } } }","highlight_start":1,"highlight_end":40},{"text":"/// Extract value of this index as an integer.","highlight_start":1,"highlight_end":47},{"text":" # [ inline ] $ v fn index ( self ) -> usize { self . as_usize (  ) }","highlight_start":1,"highlight_end":70},{"text":"/// Extract value of this index as a usize.","highlight_start":1,"highlight_end":44},{"text":" # [ inline ] $ v fn as_u32 ( self ) -> u32 { self . private }","highlight_start":1,"highlight_end":63},{"text":"/// Extract value of this index as a u32.","highlight_start":1,"highlight_end":42},{"text":" # [ inline ] $ v fn as_usize ( self ) -> usize { self . as_u32 (  ) as usize","highlight_start":1,"highlight_end":78},{"text":"} } impl Idx for $ type {","highlight_start":1,"highlight_end":26},{"text":"# [ inline ] fn new ( value : usize ) -> Self { Self :: from ( value ) } # [","highlight_start":1,"highlight_end":77},{"text":"inline ] fn index ( self ) -> usize { usize :: from ( self ) } } impl :: std","highlight_start":1,"highlight_ghlight_start":1,"highlight_end":79},{"text":"type > for usize {","highlight_start":1,"highlight_end":19},{"text":"# [ inline ] fn from ( v : $ type ) -> usize { v . as_usize (  ) } } impl From","highlight_start":1,"highlight_end":79},{"text":"< usize > for $ type {","highlight_start":1,"highlight_end":23},{"text":"# [ inline ] fn from ( value : usize ) -> Self {","highlight_start":1,"highlight_end":49},{"text":"$ type :: from_usize ( value ) } } impl From < u32 > for $ type {","highlight_start":1,"highlight_end":66},{"text":"# [ inline ] fn from ( value : u32 ) -> Self { $ type :: from_u32 ( value ) }","highlight_start":1,"highlight_end":78},{"text":"} newtype_index ! (","highlight_start":1,"highlight_end":20},{"text":"@ handle_debug @ derives [ $ ( $ derives , ) * ] @ type [ $ type ] @","highlight_start":1,"highlight_end":69},{"text":"debug_format [ $ debug_format ] ) ; ) ; (","highlight_start":1,"highlight_end":42},{"text":"@ handle_debug @ derives [ $ ( $ _derives : ident , ) * ] @ type [","highlight_start":1,"highlight_end":67},{"text":"$ type : ident ] @ debug_format [ custom ] ) => (  ) ; (","highlight_start":1,"highlight_end":57},{"text":"@ handle_debug @ derives [  ] @ type [ $ type : ident ] @ debug_format [","highlight_start":1,"highlight_end":73},{"text":"$ debug_format : tt ] ) => (","highlight_start":1,"highlight_end":29},{"text":"impl :: std :: fmt :: Debug for $ type {","highlight_start":1,"highlight_end":41},{"text":"fn fmt ( & self , fmt : & mut :: std :: fmt :: Formatter ) -> :: std :: fmt ::","highlight_start":1,"highlight_end":79},{"text":"Result { write ! ( fmt , $ debug_format , self . as_u32 (  ) ) } } ) + ]","highlight_start":1,"highlight_end":76},{"text":"ENCODABLE = custom $ ( $ tokens : tt ) * ) => (","highlight_start":1,"highlight_end":48},{"text":"newtype_index ! (","highlight_start":1,"highlight_end":18},{"text":"@ derives [ $ ( $ derives , ) + ] @ type [ $ type ] @ max [ $ max ] @ vis [","highlight_start":1,"highlight_end":76},{"text":"$ v ] @ debug_format [ $ debug_format ] $ ( $ tokens ) * ) ; ) ; (","highlight_start":1,"highlight_end":67},{"text":"@ type [ $ type : ident ] @ max [ $ max : expr ] @ vis [ $ v : vis ] @","highlight_start":1,"highlight_end":71},{"text":"debug_format [ $ debug_format : tt ] derive [ $ ( $ derives : ident , ) + ] $","highlight_start":1,"highlight_end":78},{"text":"( $ tokens : tt ) * ) => (","highlight_start":1,"highlight_end":27},{"text":"newtype_index ! (","highlight_start":1,"highlight_end":18},{"text":"@ derives [ $ ( $ derives , ) + RustcEncodable , ] @ type [ $ type ] @ max [","highlight_start":1,"highlight_end":77},{"text":"$ max ] @ vis [ $ v ] @ debug_format [ $ debug_format ] $ ( $ tokens ) * ) ;","highlight_start":1,"highlight_end":77},{"text":"impl Decodable for $ type {","highlight_start":1,"highlight_end":28},{"text":"fn decode < D : Decoder > ( d : & mut D ) -> Result < Self , D :: Error > {","highlight_start":1,"highlight_end":76},{"text":"d . read_u32 (  ) . into (  ) } } ) ; (","highlight_start":1,"highlight_end":40},{"text":"@ type [ $ type : ident ] @ max [ $ max : expr ] @ vis [ $ v : vis ] @","highlight_start":1,"highlight_end":71},{"text":"debug_format [ $ debug_format : tt ] ENCODABLE = custom $ ( $ tokens : tt ) *","highlight_start":1,"highlight_end":78},{"tex18},{"text":"@ derives [ $ ( $ derives , ) * ] @ type [ $ type ] @ max [ $ max ] @ vis [","highlight_start":1,"highlight_end":76},{"text":"$ v ] @ debug_format [ $ debug_format ] $ ( # [ doc = $ doc ] ) * const $ name","highlight_start":1,"highlight_end":79},{"text":"= $ constant , ) ; ) ; (","highlight_start":1,"highlight_end":25},{"text":"@ derives [ $ ( $ derives : ident , ) * ] @ type [ $ type : ident ] @ max [","highlight_start":1,"highlight_end":76},{"text":"$ _max : expr ] @ vis [ $ v : vis ] @ debug_format [ $ debug_format : tt ] MAX","highlight_start":1,"highlight_end":79},{"text":"= $ max : expr , $ ( $ tokens : tt ) * ) => (","highlight_start":1,"highlight_end":46},{"text":"newtype_index ! (","highlight_start":1,"highlight_end":18},{"text":"@ derives [ $ ( $ derives , ) * ] @ type [ $ type ] @ max [ $ max ] @ vis [","highlight_start":1,"highlight_end":76},{"text":"$ v ] @ debug_format [ $ debug_format ] $ ( $ tokens ) * ) ; ) ; (","highlight_start":1,"highlight_end":67},{"text":"@ derives [ $ ( $ derives : ident , ) * ] @ type [ $ type : ident ] @ max [","highlight_start":1,"highlight_end":76},{"text":"$ max : expr ] @ vis [ $ v : vis ] @ debug_format [ $ _debug_format : tt ]","highlight_start":1,"highlight_end":75},{"text":"DEBUG_FORMAT = $ debug_format : tt , $ ( $ tokens : tt ) * ) => (","highlight_start":1,"highlight_end":66},{"text":"newtype_index ! (","highlight_start":1,"highlight_end":18},{"text":"@ derives [ $ ( $ derives , ) * ] @ type [ $ type ] @ max [ $ max ] @ vis [","highlight_start":1,"highlight_end":76},{"text":"$ v ] @ debug_format [ $ debug_format ] $ ( $ tokens ) * ) ; ) ; (","highlight_start":1`Decoder` in this scope\n  --> /checkout/src/test/run-pass-fulldeps/newtype_index.rs:8:1\n   |\nLL | newtype_index!(struct MyIdx { MAX = 0xFFFF_FFFA });\n   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ not found in this scope\n   |\n   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\nhelp: possible candidate is found in another module, you can import it into scope\n   |\nLL | use rustc_serialize::Decoder;\n   |\n\n"}
[01:11:10] {"message":"aborting due to 2 previous errors","code":null,"level":"error","spans":[],"children":[],"rendered":"error: aborting due to 2 previous errors\n\n"}
[01:11:10] {"message":"For more information about this error, try `rustc --explain E0405`.","code":null,"level":"","spans":[],"children":[],"rendered":"For more information about this error, try `rustc --explain E0405`.\n"}
[01:11:10] ------------------------------------------
[01:11:10] 
[01:11:10] thread '[run-pass] run-pass-fulldeps/newtype_index.rs' panicked at 'explicit panic', tools/compiletest/src/runtest.rs:3284:9
[01:11:10] note: Run with `RUST_BACKTRACE=1` for a backtrace.
---
[01:11:10] test result: FAILED. 96 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out
[01:11:10] 
[01:11:10] 
[01:11:10] 
[01:11:10] command did not execute successfully: "/checkout/obj/build/x86_64-unknown-linux-gnu/stage0-tools-bin/compiletest" "--compile-lib-path" "/checkout/obj/build/x86_64-unknown-linux-gnu/stage2/lib" "--run-lib-path" "/checkout/obj/build/x86_64-unknown-linux-gnu/stage2/lib/rustlib/x86_64-unknown-linux-gnu/lib" "--rustc-path" "/checkout/obj/build/x86_64-unknown-linux-gnu/stage2/bin/rustc" "--src-base" "/checkout/src/test/run-pass-fulldeps" "--build-base" "/checkout/obj/build/x86_64-unknown-linux-gnu/test/run-pass-fulldeps" "--stage-id" "stage2-x86_64-unknown-linux-gnu" "--mode" "run-pass" "--target" "x86_64-unknown-linux-gnu" "--host" "x86_64-unknown-linux-gnu" "--llvm-filecheck" "/usr/lib/llvm-5.0/bin/FileCheck" "--host-rustcflags" "-Crpath -O -Zunstable-options " "--target-rustcflags" "-Crpath -O -Zunstable-options  -Lnative=/checkout/obj/build/x86_64-unknown-linux-gnu/native/rust-test-helpers" "--docck-python" "/usr/bin/python2.7" "--lldb-python" "/usr/bin/python2.7" "--gdb" "/usr/bin/gdb" "--quiet" "--llvm-version" "5.0.0\n" "--system-llvm" "--cc" "" "--cxx" "" "--cflags" "" "--llvm-components" "" "--llvm-cxxflags" "" "--adb-path" "adb" "--adb-test-dir" "/data/tmp/work" "--android-cross-path" "" "--color" "always"
[01:11:10] 
[01:11:10] 
[01:11:10] failed to run: /checkout/obj/build/bootstrap/debug/bootstrap test
[01:11:10] Build completed unsuccessfully in 0:24:46
[01:11:10] Build completed unsuccessfully in 0:24:46
[01:11:10] make: *** [check] Error 1
[01:11:10] Makefile:58: recipe for target 'check' failed

The command "stamp sh -x -c "$RUN_SCRIPT"" exited with 2.
travis_time:start:14156274
$ date && (curl -fs --head https://google.com | grep ^Date: | sed 's/Date: //g' || true)
