\n"},"level":"error","spans":[{"file_name":"/checkout/src/test/ui/error-codes/E0030-teach.rs","byte_start":532,"byte_end":536,"line_start":15,"line_end":15,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"        1000 ... 5 => {}","highlight_start":9,"highlight_end":13}],"label":"lower bound larger than upper bound","suggested_replacement":null,"expansion":null}],"children":[],"rendered":"error[E0030]: lower range bound must be less than or equal to upper\n  --> /checkout/src/test/ui/error-codes/E0030-teach.rs:15:9\n   |\nLL |         1000 ... 5 => {}\n   |         ^^^^ lower bound larger than upper bound\n\n"}
[00:50:54] {"message":"aborting due to previous error","code":null,"level":"error","spans":[],"children":[],"rendered":"error: aborting due to previous error\n\n"}
[00:50:54] {"message":"For more information about this error, try `rustc --explain E0030`.","code":null,"level":"","spans":[],"children":[],"rendered":"For more information about this error, try `rustc --explain E0030`.\n"}
---
[00:50:54] 18 LL |     let &invalid = trait_obj;
[00:50:54] 19    |         ^^^^^^^^ type `&SomeTrait` cannot be dereferenced
[00:50:54] -    |
[00:50:54] -    = note: This error indicates that a pointer to a trait type cannot be implicitly dereferenced by a pattern. Every trait defines a type, but because the size of trait implementors isn't fixed, this type has no compile-time size. Therefore, all accesses to trait types must be through pointers. If you encounter this error you should try to avoid dereferencing the pointer.
[00:50:54] -
[00:50:54] -            You can read more about trait objects in the Trait Objects section of the Reference: https://doc.rust-lang.org/reference/types.html#trait-objects
---
[00:50:54] /checkout/src/test/ui/update-references.sh '/checkout/obj/build/x86_64-unknown-linux-gnu/test/ui' 'error-codes/E0033-teach.rs'
[00:50:54]
[00:50:54] error: 1 errors occurred comparing output.
[00:50:54] status: exit code: 101
[00:50:54] command: "/checkout/obj/build/x86_64-unknown-linux-gnu/stage2/bin/rustc" "/checkout/src/test/ui/error-codes/E0033-teach.rs" "-L" "/checkout/obj/build/x86_64-unknown-linux-gnu/test/ui" "--target=x86_64-unknown-linux-gnu" "--error-format" "json" "-Zui-testing" "-C" "prefer-dynamic" "-o" "/checkout/obj/build/x86_64-unknown-linux-gnu/test/ui/error-codes/E0033-teach.stage2-x86_64-unknown-linux-gnu" "-Crpath" "-O" "-Zmiri" "-Zunstable-options" "-Lnative=/checkout/obj/build/x86_64-unknown-l":"E0038","explanation":"\nTrait objects like `Box<Trait>` can only be constructed when certain\nrequirements are satisfied by the trait in question.\n\nTrait objects are a form of dynamic dispatch and use a dynamically sized type\nfor the inner type. So, for a given trait `Trait`, when `Trait` is treated as a\ntype, as in `Box<Trait>`, the inner type is 'unsized'. In such cases the boxed\npointer is a 'fat pointer' that contains an extra pointer to a table of methods\n(among other things) for dynamic dispatch. This design mandates some\nrestrictions on the types of traits that are allowed to be used in trait\nobjects, which are collectively termed as 'object safety' rules.\n\nAttempting to create a trait object for a non object-safe trait will trigger\nthis error.\n\nThere are various rules:\n\n### The trait cannot require `Self: Sized`\n\nWhen `Trait` is treated as a type, the type does not implement the special\n`Sized` trait, because the type does not have a known size at compile time and\ncan only be accessed behind a pointer. Thus, if we have a trait like the\nfollowing:\n\n