plain
2019-12-13T01:31:16.1877701Z ---- /checkout/src/doc/reference/src/types/never.md - Never_type (line 10) stdout ----
2019-12-13T01:31:16.1878040Z error[E0658]: The `!` type is experimental
2019-12-13T01:31:16.1878537Z  --> /checkout/src/doc/reference/src/types/never.md:11:8
2019-12-13T01:31:16.1879093Z   |
2019-12-13T01:31:16.1879359Z 3 | let x: ! = panic!();
2019-12-13T01:31:16.1879843Z   |
2019-12-13T01:31:16.1884454Z   = note: for more information, see https://github.com/rust-lang/rust/issues/35121
2019-12-13T01:31:16.1884454Z   = note: for more information, see https://github.com/rust-lang/rust/issues/35121
2019-12-13T01:31:16.1884817Z   = help: add `#![feature(never_type)]` to the crate attributes to enable
2019-12-13T01:31:16.1884986Z error: aborting due to previous error
2019-12-13T01:31:16.1885034Z 
2019-12-13T01:31:16.1885454Z For more information about this error, try `rustc --explain E0658`.
2019-12-13T01:31:16.1885709Z Couldn't compile the test.
---
2019-12-13T01:44:49.9903660Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9904015Z 
2019-12-13T01:44:49.9904538Z     ┌── borrow_check/region_inference.md:34:5 ───
2019-12-13T01:44:49.9905290Z     │
2019-12-13T01:44:49.9905850Z  34 │     [`RegionInferenceContext`] and invoking its [`solve`]
2019-12-13T01:44:49.9907370Z     │
2019-12-13T01:44:49.9907590Z 
2019-12-13T01:44:49.9908250Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9908708Z 
2019-12-13T01:44:49.9908708Z 
2019-12-13T01:44:49.9909206Z     ┌── borrow_check/region_inference.md:34:49 ───
2019-12-13T01:44:49.9909790Z     │
2019-12-13T01:44:49.9910238Z  34 │     [`RegionInferenceContext`] and invoking its [`solve`]
2019-12-13T01:44:49.9911102Z     │
2019-12-13T01:44:49.9911944Z 
2019-12-13T01:44:49.9911944Z 
2019-12-13T01:44:49.9912721Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/universal_regions/struct.UniversalRegions.html"
2019-12-13T01:44:49.9913517Z     ┌── borrow_check/region_inference.md:50:5 ───
2019-12-13T01:44:49.9913967Z     │
2019-12-13T01:44:49.9913967Z     │
2019-12-13T01:44:49.9914464Z  50 │ The [`UniversalRegions`] type represents a collection of _universal_ regions
2019-12-13T01:44:49.9915533Z     │
2019-12-13T01:44:49.9915689Z 
2019-12-13T01:44:49.9915689Z 
2019-12-13T01:44:49.9916208Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/universal_regions/struct.UniversalRegions.html"
2019-12-13T01:44:49.9916841Z     ┌── borrow_check/region_inference.md:53:12 ───
2019-12-13T01:44:49.9917219Z     │
2019-12-13T01:44:49.9917219Z     │
2019-12-13T01:44:49.9917686Z  53 │ variables. [`UniversalRegions`] contains indices for all the free regions in
2019-12-13T01:44:49.9918537Z     │
2019-12-13T01:44:49.9918702Z 
2019-12-13T01:44:49.9919229Z error: The server responded with 404 Not Found for "https://github.com/rust-lang/rust/tree/master/src/librustc_mir/borrow_check/nll/region_infer/"
2019-12-13T01:44:49.9919430Z 
2019-12-13T01:44:49.9919430Z 
2019-12-13T01:44:49.9919850Z     ┌── borrow_check/region_inference.md:81:34 ───
2019-12-13T01:44:49.9920257Z     │
2019-12-13T01:44:49.9920661Z  81 │ for all regions is maintained in [the
2019-12-13T01:44:49.9921847Z     │                                  ^ Server responded with 404 Not Found
2019-12-13T01:44:49.9922766Z     │
2019-12-13T01:44:49.9922982Z 
2019-12-13T01:44:49.9923601Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/constraint_generation/fn.generate_constraints.html"
2019-12-13T01:44:49.9924315Z      ┌── borrow_check/region_inference.md:116:45 ───
2019-12-13T01:44:49.9924905Z      │
2019-12-13T01:44:49.9926720Z  116 │    used. These constraints are collected by [`generate_constraints`].
2019-12-13T01:44:49.9927043Z      │                                             ^ Server responded with 404 Not Found
2019-12-13T01:44:49.9927043Z      │                                             ^ Server responded with 404 Not Found
2019-12-13T01:44:49.9927252Z      │
2019-12-13T01:44:49.9927305Z 
2019-12-13T01:44:49.9927683Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9927797Z 
2019-12-13T01:44:49.9928039Z      ┌── borrow_check/region_inference.md:131:1 ───
2019-12-13T01:44:49.9928249Z      │
2019-12-13T01:44:49.9928456Z  131 │ [`propagate_constraints`].
2019-12-13T01:44:49.9928892Z      │
2019-12-13T01:44:49.9928944Z 
2019-12-13T01:44:49.9929316Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9929427Z 
2019-12-13T01:44:49.9929427Z 
2019-12-13T01:44:49.9929666Z      ┌── borrow_check/region_inference.md:134:9 ───
2019-12-13T01:44:49.9929877Z      │
2019-12-13T01:44:49.9930145Z  134 │ calling [`check_type_tests`]. This checks constraints like `T: 'a`. Second, we
2019-12-13T01:44:49.9930793Z      │
2019-12-13T01:44:49.9930847Z 
2019-12-13T01:44:49.9931742Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9931858Z 
2019-12-13T01:44:49.9931858Z 
2019-12-13T01:44:49.9932123Z      ┌── borrow_check/region_inference.md:136:1 ───
2019-12-13T01:44:49.9932352Z      │
2019-12-13T01:44:49.9932645Z  136 │ [`check_universal_regions`]. This checks that for each region `'a` if `'a`
2019-12-13T01:44:49.9933140Z      │
2019-12-13T01:44:49.9933195Z 
2019-12-13T01:44:49.9933721Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9933843Z 
---
2019-12-13T01:44:49.9936065Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9936166Z 
2019-12-13T01:44:49.9936397Z      ┌── borrow_check/region_inference.md:208:3 ───
2019-12-13T01:44:49.9936607Z      │
2019-12-13T01:44:49.9936855Z  208 │ - [`constraints`]: contains all the outlives constraints.
2019-12-13T01:44:49.9937318Z      │
2019-12-13T01:44:49.9937354Z 
2019-12-13T01:44:49.9937719Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9937829Z 
2019-12-13T01:44:49.9937829Z 
2019-12-13T01:44:49.9938063Z      ┌── borrow_check/region_inference.md:209:3 ───
2019-12-13T01:44:49.9938275Z      │
2019-12-13T01:44:49.9938522Z  209 │ - [`liveness_constraints`]: contains all the liveness constraints.
2019-12-13T01:44:49.9938985Z      │
2019-12-13T01:44:49.9939020Z 
2019-12-13T01:44:49.9939383Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9939483Z 
2019-12-13T01:44:49.9939483Z 
2019-12-13T01:44:49.9939724Z      ┌── borrow_check/region_inference.md:210:3 ───
2019-12-13T01:44:49.9940113Z      │
2019-12-13T01:44:49.9940353Z  210 │ - [`universal_regions`]: contains the `UniversalRegions` returned by
2019-12-13T01:44:49.9940802Z      │
2019-12-13T01:44:49.9940836Z 
2019-12-13T01:44:49.9941589Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9941953Z 
2019-12-13T01:44:49.9941953Z 
2019-12-13T01:44:49.9942255Z      ┌── borrow_check/region_inference.md:212:3 ───
2019-12-13T01:44:49.9942493Z      │
2019-12-13T01:44:49.9942780Z  212 │ - [`universal_region_relations`]: contains relations known to be true about
2019-12-13T01:44:49.9943294Z      │
2019-12-13T01:44:49.9943333Z 
2019-12-13T01:44:49.9943752Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9943863Z 
2019-12-13T01:44:49.9943863Z 
2019-12-13T01:44:49.9944121Z      ┌── borrow_check/region_inference.md:217:3 ───
2019-12-13T01:44:49.9944352Z      │
2019-12-13T01:44:49.9944654Z  217 │ - [`type_tests`]: contains some constraints on types that we must check after
2019-12-13T01:44:49.9945440Z      │
2019-12-13T01:44:49.9945475Z 
2019-12-13T01:44:49.9945861Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9945946Z 
2019-12-13T01:44:49.9945946Z 
2019-12-13T01:44:49.9946178Z      ┌── borrow_check/region_inference.md:219:3 ───
2019-12-13T01:44:49.9946389Z      │
2019-12-13T01:44:49.9946661Z  219 │ - [`closure_bounds_mapping`]: used for propagating region constraints from
2019-12-13T01:44:49.9947218Z      │
2019-12-13T01:44:49.9947255Z 
2019-12-13T01:44:49.9947793Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9947875Z 
2019-12-13T01:44:49.9947875Z 
2019-12-13T01:44:49.9948345Z      ┌── borrow_check/region_inference.md:232:40 ───
2019-12-13T01:44:49.9948546Z      │
2019-12-13T01:44:49.9948831Z  232 │ inference. This is done by calling the [`solve`] method on the context. This
2019-12-13T01:44:49.9949347Z      │
2019-12-13T01:44:49.9949382Z 
2019-12-13T01:44:49.9949775Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9949861Z 
2019-12-13T01:44:49.9949861Z 
2019-12-13T01:44:49.9950136Z      ┌── borrow_check/region_inference.md:233:18 ───
2019-12-13T01:44:49.9950339Z      │
2019-12-13T01:44:49.9950620Z  233 │ is where we call [`propagate_constraints`] and then check the resulting type
2019-12-13T01:44:49.9951108Z      │
2019-12-13T01:44:49.9951553Z 
2019-12-13T01:44:49.9952209Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9952301Z 
2019-12-13T01:44:49.9952301Z 
2019-12-13T01:44:49.9952605Z    ┌── borrow_check/region_inference/constraint_propagation.md:4:22 ───
2019-12-13T01:44:49.9952825Z    │
2019-12-13T01:44:49.9953121Z  4 │ which is done in the [`propagate_constraints`] function.  There are
2019-12-13T01:44:49.9953642Z    │
2019-12-13T01:44:49.9953682Z 
2019-12-13T01:44:49.9953682Z 
2019-12-13T01:44:49.9954116Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/values/struct.LivenessValues.html"
2019-12-13T01:44:49.9954552Z     ┌── borrow_check/region_inference/constraint_propagation.md:68:6 ───
2019-12-13T01:44:49.9954791Z     │
2019-12-13T01:44:49.9954791Z     │
2019-12-13T01:44:49.9955250Z  68 │ type [`LivenessValues`]). This way we only need a single bit for each
2019-12-13T01:44:49.9955717Z     │
2019-12-13T01:44:49.9955752Z 
2019-12-13T01:44:49.9955752Z 
2019-12-13T01:44:49.9956132Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/constraints/struct.OutlivesConstraintSet.html"
2019-12-13T01:44:49.9956488Z      ┌── borrow_check/region_inference/constraint_propagation.md:103:1 ───
2019-12-13T01:44:49.9956686Z      │
2019-12-13T01:44:49.9956686Z      │
2019-12-13T01:44:49.9956967Z  103 │ [`ConstraintSet`]. The constraint set is basically just a list of `'a:
2019-12-13T01:44:49.9957413Z      │
2019-12-13T01:44:49.9957448Z 
2019-12-13T01:44:49.9957448Z 
2019-12-13T01:44:49.9957827Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/constraints/struct.OutlivesConstraintSet.html"
2019-12-13T01:44:49.9958324Z      ┌── borrow_check/region_inference/constraint_propagation.md:109:1 ───
2019-12-13T01:44:49.9958522Z      │
2019-12-13T01:44:49.9958522Z      │
2019-12-13T01:44:49.9958792Z  109 │ [converted into the form of a graph][graph-fn], where the nodes of the
2019-12-13T01:44:49.9959237Z      │
2019-12-13T01:44:49.9959273Z 
2019-12-13T01:44:49.9959654Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9959738Z 
2019-12-13T01:44:49.9959738Z 
2019-12-13T01:44:49.9960351Z      ┌── borrow_check/region_inference/constraint_propagation.md:112:1 ───
2019-12-13T01:44:49.9960584Z      │
2019-12-13T01:44:49.9960864Z  112 │ [`RegionInferenceContext::new`] function that creates the inference
2019-12-13T01:44:49.9970989Z      │
2019-12-13T01:44:49.9971052Z 
2019-12-13T01:44:49.9972105Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9972207Z 
2019-12-13T01:44:49.9972207Z 
2019-12-13T01:44:49.9972530Z      ┌── borrow_check/region_inference/constraint_propagation.md:134:51 ───
2019-12-13T01:44:49.9972753Z      │
2019-12-13T01:44:49.9973061Z  134 │ the constraint graph. The result is stored in the [`constraint_sccs`]
2019-12-13T01:44:49.9973639Z      │
2019-12-13T01:44:49.9973693Z 
2019-12-13T01:44:49.9974124Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9974216Z 
2019-12-13T01:44:49.9974216Z 
2019-12-13T01:44:49.9974519Z      ┌── borrow_check/region_inference/constraint_propagation.md:145:1 ───
2019-12-13T01:44:49.9974769Z      │
2019-12-13T01:44:49.9975199Z  145 │ [`scc_values`] field stores the values of each SCC. To get the value
2019-12-13T01:44:49.9975662Z      │
2019-12-13T01:44:49.9975714Z 
2019-12-13T01:44:49.9976094Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9976196Z 
2019-12-13T01:44:49.9976196Z 
2019-12-13T01:44:49.9976465Z      ┌── borrow_check/region_inference/constraint_propagation.md:187:48 ───
2019-12-13T01:44:49.9976685Z      │
2019-12-13T01:44:49.9976968Z  187 │ In the region inferencer, this step is done in [`RegionInferenceContext::new`].
2019-12-13T01:44:49.9977499Z      │
2019-12-13T01:44:49.9977551Z 
2019-12-13T01:44:49.9977927Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9978043Z 
2019-12-13T01:44:49.9978043Z 
2019-12-13T01:44:49.9978314Z      ┌── borrow_check/region_inference/constraint_propagation.md:205:38 ───
2019-12-13T01:44:49.9978537Z      │
2019-12-13T01:44:49.9978793Z  205 │ In the code, this work starts in the [`propagate_constraints`]
2019-12-13T01:44:49.9979299Z      │
2019-12-13T01:44:49.9979351Z 
2019-12-13T01:44:49.9979739Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9979843Z 
2019-12-13T01:44:49.9979843Z 
2019-12-13T01:44:49.9980110Z      ┌── borrow_check/region_inference/constraint_propagation.md:216:10 ───
2019-12-13T01:44:49.9980332Z      │
2019-12-13T01:44:49.9980562Z  216 │ added in [`RegionInferenceContext::new`].
2019-12-13T01:44:49.9981556Z      │          ^ Server responded with 404 Not Found
2019-12-13T01:44:49.9981781Z      │
2019-12-13T01:44:49.9981838Z 
2019-12-13T01:44:49.9982249Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/universal_regions/struct.UniversalRegions.html"
2019-12-13T01:44:49.9982692Z     ┌── borrow_check/region_inference/lifetime_parameters.md:25:13 ───
2019-12-13T01:44:49.9982956Z     │
2019-12-13T01:44:49.9982956Z     │
2019-12-13T01:44:49.9983249Z  25 │ construct a [`UniversalRegions`] struct. This struct tracks the
2019-12-13T01:44:49.9984001Z     │
2019-12-13T01:44:49.9984045Z 
2019-12-13T01:44:49.9984045Z 
2019-12-13T01:44:49.9984511Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/type_check/free_region_relations/struct.UniversalRegionRelations.html"
2019-12-13T01:44:49.9985142Z     ┌── borrow_check/region_inference/lifetime_parameters.md:27:10 ───
2019-12-13T01:44:49.9985361Z     │
2019-12-13T01:44:49.9985361Z     │
2019-12-13T01:44:49.9985635Z  27 │ create a [`UniversalRegionRelations`] struct, which tracks their
2019-12-13T01:44:49.9986093Z     │
2019-12-13T01:44:49.9986128Z 
2019-12-13T01:44:49.9986128Z 
2019-12-13T01:44:49.9986535Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/type_check/free_region_relations/struct.UniversalRegionRelations.html"
2019-12-13T01:44:49.9986912Z     ┌── borrow_check/region_inference/lifetime_parameters.md:29:5 ───
2019-12-13T01:44:49.9987114Z     │
2019-12-13T01:44:49.9987114Z     │
2019-12-13T01:44:49.9987380Z  29 │ the [`UniversalRegionRelations`] struct would track that `'a: 'b` is
2019-12-13T01:44:49.9987830Z     │
2019-12-13T01:44:49.9987877Z 
2019-12-13T01:44:49.9987877Z 
2019-12-13T01:44:49.9988282Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/type_check/free_region_relations/struct.UniversalRegionRelations.html"
2019-12-13T01:44:49.9988645Z     ┌── borrow_check/region_inference/lifetime_parameters.md:30:47 ───
2019-12-13T01:44:49.9988842Z     │
2019-12-13T01:44:49.9988842Z     │
2019-12-13T01:44:49.9989110Z  30 │ known to hold (which could be tested with the [`outlives`] function.
2019-12-13T01:44:49.9989612Z     │
2019-12-13T01:44:49.9989658Z 
2019-12-13T01:44:49.9990045Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/universal_regions/enum.RegionClassification.html"
2019-12-13T01:44:49.9990134Z 
---
2019-12-13T01:44:49.9992920Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9993014Z 
2019-12-13T01:44:49.9993317Z     ┌── borrow_check/region_inference/lifetime_parameters.md:87:1 ───
2019-12-13T01:44:49.9993550Z     │
2019-12-13T01:44:49.9993805Z  87 │ [`init_free_and_bound_regions`].
2019-12-13T01:44:49.9994287Z     │
2019-12-13T01:44:49.9994325Z 
2019-12-13T01:44:49.9995057Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/region_infer/struct.RegionInferenceContext.html"
2019-12-13T01:44:49.9995257Z 
2019-12-13T01:44:49.9995257Z 
2019-12-13T01:44:49.9995565Z      ┌── borrow_check/region_inference/lifetime_parameters.md:121:1 ───
2019-12-13T01:44:49.9995764Z      │
2019-12-13T01:44:49.9996210Z  121 │ [`check_universal_regions`] function, which simply iterates over all
2019-12-13T01:44:49.9996828Z      │
2019-12-13T01:44:49.9996862Z 
2019-12-13T01:44:49.9996862Z 
2019-12-13T01:44:49.9997346Z error: The server responded with 404 Not Found for "https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/borrow_check/nll/type_check/free_region_relations/struct.UniversalRegionRelations.html"
2019-12-13T01:44:49.9997747Z      ┌── borrow_check/region_inference/lifetime_parameters.md:123:10 ───
2019-12-13T01:44:49.9997963Z      │
2019-12-13T01:44:49.9997963Z      │
2019-12-13T01:44:49.9998186Z  123 │ declared [`UniversalRegionRelations`].
2019-12-13T01:44:49.9998653Z      │
2019-12-13T01:44:49.9998687Z 
2019-12-13T01:44:49.9998768Z Error: One or more incorrect links
2019-12-13T01:44:49.9998810Z 
---
2019-12-13T01:58:40.6144711Z normalized stderr:
2019-12-13T01:58:40.6145458Z error[E0658]: The `!` type is experimental
2019-12-13T01:58:40.6146313Z   --> $DIR/infallible_destructuring_match.rs:57:30
2019-12-13T01:58:40.6146738Z    |
2019-12-13T01:58:40.6146841Z LL |     let wrapper: Result<i32, !> = Ok(23);
2019-12-13T01:58:40.6147121Z    |
2019-12-13T01:58:40.6148242Z    = note: for more information, see https://github.com/rust-lang/rust/issues/35121
2019-12-13T01:58:40.6148242Z    = note: for more information, see https://github.com/rust-lang/rust/issues/35121
2019-12-13T01:58:40.6180807Z    = help: add `#![feature(never_type)]` to the crate attributes to enable
2019-12-13T01:58:40.6181617Z error: aborting due to previous error
2019-12-13T01:58:40.6208527Z 
2019-12-13T01:58:40.6242341Z For more information about this error, try `rustc --explain E0658`.
2019-12-13T01:58:40.6244503Z 
2019-12-13T01:58:40.6244503Z 
2019-12-13T01:58:40.6244633Z 
2019-12-13T01:58:40.6244722Z expected stderr:
2019-12-13T01:58:40.6244817Z error: you seem to be trying to use match to destructure a single infallible pattern. Consider using `let`
2019-12-13T01:58:40.6245271Z   --> $DIR/infallible_destructuring_match.rs:18:5
2019-12-13T01:58:40.6245353Z    |
2019-12-13T01:58:40.6245434Z LL | /     let data = match wrapper {
2019-12-13T01:58:40.6245744Z LL | |         SingleVariantEnum::Variant(i) => i,
2019-12-13T01:58:40.6246009Z LL | |     };
2019-12-13T01:58:40.6246101Z    | |______^ help: try this: `let SingleVariantEnum::Variant(data) = wrapper;`
2019-12-13T01:58:40.6246667Z    = note: `-D clippy::infallible-destructuring-match` implied by `-D warnings`
2019-12-13T01:58:40.6246720Z 
2019-12-13T01:58:40.6246823Z error: you seem to be trying to use match to destructure a single infallible pattern. Consider using `let`
2019-12-13T01:58:40.6247078Z   --> $DIR/infallible_destructuring_match.rs:39:5
2019-12-13T01:58:40.6247078Z   --> $DIR/infallible_destructuring_match.rs:39:5
2019-12-13T01:58:40.6247163Z    |
2019-12-13T01:58:40.6247216Z LL | /     let data = match wrapper {
2019-12-13T01:58:40.6247296Z LL | |         TupleStruct(i) => i,
2019-12-13T01:58:40.6247356Z LL | |     };
2019-12-13T01:58:40.6247440Z    | |______^ help: try this: `let TupleStruct(data) = wrapper;`
2019-12-13T01:58:40.6247580Z error: you seem to be trying to use match to destructure a single infallible pattern. Consider using `let`
2019-12-13T01:58:40.6247862Z   --> $DIR/infallible_destructuring_match.rs:60:5
2019-12-13T01:58:40.6247928Z    |
2019-12-13T01:58:40.6247997Z LL | /     let data = match wrapper {
2019-12-13T01:58:40.6247997Z LL | /     let data = match wrapper {
2019-12-13T01:58:40.6248060Z LL | |         Ok(i) => i,
2019-12-13T01:58:40.6248136Z LL | |     };
2019-12-13T01:58:40.6248200Z    | |______^ help: try this: `let Ok(data) = wrapper;`
2019-12-13T01:58:40.6248319Z error: aborting due to 3 previous errors
2019-12-13T01:58:40.6248358Z 
2019-12-13T01:58:40.6248406Z 
2019-12-13T01:58:40.6248437Z 
2019-12-13T01:58:40.6248437Z 
2019-12-13T01:58:40.6248504Z diff of stderr:
2019-12-13T01:58:40.6248716Z 
2019-12-13T01:58:40.6249024Z -error: you seem to be trying to use match to destructure a single infallible pattern. Consider using `let`
2019-12-13T01:58:40.6249302Z -  --> $DIR/infallible_destructuring_match.rs:18:5
2019-12-13T01:58:40.6249574Z +error[E0658]: The `!` type is experimental
2019-12-13T01:58:40.6249822Z +  --> $DIR/infallible_destructuring_match.rs:57:30
2019-12-13T01:58:40.6249917Z     |
2019-12-13T01:58:40.6250135Z -LL | /     let data = match wrapper {
2019-12-13T01:58:40.6250400Z -LL | |         SingleVariantEnum::Variant(i) => i,
2019-12-13T01:58:40.6251245Z -LL | |     };
2019-12-13T01:58:40.6257875Z -   | |______^ help: try this: `let SingleVariantEnum::Variant(data) = wrapper;`
2019-12-13T01:58:40.6258012Z +LL |     let wrapper: Result<i32, !> = Ok(23);
2019-12-13T01:58:40.6258182Z     |
2019-12-13T01:58:40.6258481Z -   = note: `-D clippy::infallible-destructuring-match` implied by `-D warnings`
2019-12-13T01:58:40.6258770Z +   = note: for more information, see https://github.com/rust-lang/rust/issues/35121
2019-12-13T01:58:40.6258770Z +   = note: for more information, see https://github.com/rust-lang/rust/issues/35121
2019-12-13T01:58:40.6258885Z +   = help: add `#![feature(never_type)]` to the crate attributes to enable
2019-12-13T01:58:40.6259269Z -error: you seem to be trying to use match to destructure a single infallible pattern. Consider using `let`
2019-12-13T01:58:40.6259552Z -  --> $DIR/infallible_destructuring_match.rs:39:5
2019-12-13T01:58:40.6259752Z -   |
2019-12-13T01:58:40.6259983Z -LL | /     let data = match wrapper {
2019-12-13T01:58:40.6259983Z -LL | /     let data = match wrapper {
2019-12-13T01:58:40.6260363Z -LL | |         TupleStruct(i) => i,
2019-12-13T01:58:40.6260570Z -LL | |     };
2019-12-13T01:58:40.6261268Z -   | |______^ help: try this: `let TupleStruct(data) = wrapper;`
2019-12-13T01:58:40.6261616Z  
2019-12-13T01:58:40.6261991Z -error: you seem to be trying to use match to destructure a single infallible pattern. Consider using `let`
2019-12-13T01:58:40.6262296Z -  --> $DIR/infallible_destructuring_match.rs:60:5
2019-12-13T01:58:40.6262509Z -   |
2019-12-13T01:58:40.6262509Z -   |
2019-12-13T01:58:40.6262757Z -LL | /     let data = match wrapper {
2019-12-13T01:58:40.6262989Z -LL | |         Ok(i) => i,
2019-12-13T01:58:40.6263223Z -LL | |     };
2019-12-13T01:58:40.6263487Z -   | |______^ help: try this: `let Ok(data) = wrapper;`
2019-12-13T01:58:40.6264044Z -error: aborting due to 3 previous errors
2019-12-13T01:58:40.6264464Z -
2019-12-13T01:58:40.6264718Z +For more information about this error, try `rustc --explain E0658`.
2019-12-13T01:58:40.6264791Z  
---
2019-12-13T01:58:40.6265730Z #![feature(exhaustive_patterns)]
2019-12-13T01:58:40.6265819Z #![allow(dead_code, unreachable_code, unused_variables)]
2019-12-13T01:58:40.6265902Z #![allow(clippy::let_and_return)]
2019-12-13T01:58:40.6265943Z 
2019-12-13T01:58:40.6265998Z enum SingleVariantEnum {
2019-12-13T01:58:40.6266074Z     Variant(i32),
2019-12-13T01:58:40.6266186Z 
2019-12-13T01:58:40.6266241Z struct TupleStruct(i32);
2019-12-13T01:58:40.6266297Z 
2019-12-13T01:58:40.6266350Z enum EmptyEnum {}
2019-12-13T01:58:40.6266350Z enum EmptyEnum {}
2019-12-13T01:58:40.6266385Z 
2019-12-13T01:58:40.6266458Z fn infallible_destructuring_match_enum() {
2019-12-13T01:58:40.6266545Z     let wrapper = SingleVariantEnum::Variant(0);
2019-12-13T01:58:40.6266649Z     // This should lint!
2019-12-13T01:58:40.6266726Z     let data = match wrapper {
2019-12-13T01:58:40.6266726Z     let data = match wrapper {
2019-12-13T01:58:40.6266806Z         SingleVariantEnum::Variant(i) => i,
2019-12-13T01:58:40.6266901Z 
2019-12-13T01:58:40.6267120Z     // This shouldn't!
2019-12-13T01:58:40.6267185Z     let data = match wrapper {
2019-12-13T01:58:40.6267185Z     let data = match wrapper {
2019-12-13T01:58:40.6267425Z         SingleVariantEnum::Variant(_) => -1,
2019-12-13T01:58:40.6267538Z 
2019-12-13T01:58:40.6267593Z     // Neither should this!
2019-12-13T01:58:40.6267671Z     let data = match wrapper {
2019-12-13T01:58:40.6267671Z     let data = match wrapper {
2019-12-13T01:58:40.6267899Z         SingleVariantEnum::Variant(i) => -1,
2019-12-13T01:58:40.6268013Z 
2019-12-13T01:58:40.6268013Z 
2019-12-13T01:58:40.6268091Z     let SingleVariantEnum::Variant(data) = wrapper;
2019-12-13T01:58:40.6268202Z 
2019-12-13T01:58:40.6268260Z fn infallible_destructuring_match_struct() {
2019-12-13T01:58:40.6268341Z     let wrapper = TupleStruct(0);
2019-12-13T01:58:40.6268387Z 
2019-12-13T01:58:40.6268387Z 
2019-12-13T01:58:40.6268456Z     // This should lint!
2019-12-13T01:58:40.6268516Z     let data = match wrapper {
2019-12-13T01:58:40.6268594Z         TupleStruct(i) => i,
2019-12-13T01:58:40.6268699Z 
2019-12-13T01:58:40.6268900Z     // This shouldn't!
2019-12-13T01:58:40.6268980Z     let data = match wrapper {
2019-12-13T01:58:40.6269186Z         TupleStruct(_) => -1,
2019-12-13T01:58:40.6269186Z         TupleStruct(_) => -1,
2019-12-13T01:58:40.6269266Z     };
2019-12-13T01:58:40.6269298Z 
2019-12-13T01:58:40.6269367Z     // Neither should this!
2019-12-13T01:58:40.6269428Z     let data = match wrapper {
2019-12-13T01:58:40.6269654Z         TupleStruct(i) => -1,
2019-12-13T01:58:40.6269763Z 
2019-12-13T01:58:40.6269763Z 
2019-12-13T01:58:40.6269819Z     let TupleStruct(data) = wrapper;
2019-12-13T01:58:40.6269930Z 
2019-12-13T01:58:40.6269999Z fn never_enum() {
2019-12-13T01:58:40.6269999Z fn never_enum() {
2019-12-13T01:58:40.6270060Z     let wrapper: Result<i32, !> = Ok(23);
2019-12-13T01:58:40.6270255Z     // This should lint!
2019-12-13T01:58:40.6270316Z     let data = match wrapper {
2019-12-13T01:58:40.6270316Z     let data = match wrapper {
2019-12-13T01:58:40.6270383Z         Ok(i) => i,
2019-12-13T01:58:40.6270480Z 
2019-12-13T01:58:40.6271579Z     // This shouldn't!
2019-12-13T01:58:40.6271671Z     let data = match wrapper {
2019-12-13T01:58:40.6271896Z         Ok(_) => -1,
2019-12-13T01:58:40.6271896Z         Ok(_) => -1,
2019-12-13T01:58:40.6271975Z     };
2019-12-13T01:58:40.6272011Z 
2019-12-13T01:58:40.6272082Z     // Neither should this!
2019-12-13T01:58:40.6272152Z     let data = match wrapper {
2019-12-13T01:58:40.6272386Z         Ok(i) => -1,
2019-12-13T01:58:40.6272608Z 
2019-12-13T01:58:40.6272608Z 
2019-12-13T01:58:40.6272678Z     let Ok(data) = wrapper;
2019-12-13T01:58:40.6272793Z 
2019-12-13T01:58:40.6272866Z impl EmptyEnum {
2019-12-13T01:58:40.6272866Z impl EmptyEnum {
2019-12-13T01:58:40.6273132Z     fn match_on(&self) -> ! {
2019-12-13T01:58:40.6273433Z         // The lint shouldn't pick this up, as `let` won't work here!
2019-12-13T01:58:40.6273529Z         let data = match *self {};
2019-12-13T01:58:40.6273678Z     }
2019-12-13T01:58:40.6273750Z }
2019-12-13T01:58:40.6273786Z 
2019-12-13T01:58:40.6273860Z fn main() {}
---
2019-12-13T01:58:40.6274492Z #![feature(exhaustive_patterns)]
2019-12-13T01:58:40.6274756Z #![allow(dead_code, unreachable_code, unused_variables)]
2019-12-13T01:58:40.6274994Z #![allow(clippy::let_and_return)]
2019-12-13T01:58:40.6275042Z 
2019-12-13T01:58:40.6275107Z enum SingleVariantEnum {
2019-12-13T01:58:40.6275181Z     Variant(i32),
2019-12-13T01:58:40.6275272Z 
2019-12-13T01:58:40.6275338Z struct TupleStruct(i32);
2019-12-13T01:58:40.6275380Z 
2019-12-13T01:58:40.6275446Z enum EmptyEnum {}
2019-12-13T01:58:40.6275446Z enum EmptyEnum {}
2019-12-13T01:58:40.6275483Z 
2019-12-13T01:58:40.6275551Z fn infallible_destructuring_match_enum() {
2019-12-13T01:58:40.6275632Z     let wrapper = SingleVariantEnum::Variant(0);
2019-12-13T01:58:40.6275741Z     // This should lint!
2019-12-13T01:58:40.6275741Z     // This should lint!
2019-12-13T01:58:40.6275822Z     let SingleVariantEnum::Variant(data) = wrapper;
2019-12-13T01:58:40.6276078Z     // This shouldn't!
2019-12-13T01:58:40.6276159Z     let data = match wrapper {
2019-12-13T01:58:40.6276159Z     let data = match wrapper {
2019-12-13T01:58:40.6276399Z         SingleVariantEnum::Variant(_) => -1,
2019-12-13T01:58:40.6276502Z 
2019-12-13T01:58:40.6276571Z     // Neither should this!
2019-12-13T01:58:40.6276645Z     let data = match wrapper {
2019-12-13T01:58:40.6276645Z     let data = match wrapper {
2019-12-13T01:58:40.6276882Z         SingleVariantEnum::Variant(i) => -1,
2019-12-13T01:58:40.6276998Z 
2019-12-13T01:58:40.6276998Z 
2019-12-13T01:58:40.6277060Z     let SingleVariantEnum::Variant(data) = wrapper;
2019-12-13T01:58:40.6277169Z 
2019-12-13T01:58:40.6277239Z fn infallible_destructuring_match_struct() {
2019-12-13T01:58:40.6277313Z     let wrapper = TupleStruct(0);
2019-12-13T01:58:40.6277365Z 
2019-12-13T01:58:40.6277365Z 
2019-12-13T01:58:40.6277420Z     // This should lint!
2019-12-13T01:58:40.6277499Z     let TupleStruct(data) = wrapper;
2019-12-13T01:58:40.6277919Z     // This shouldn't!
2019-12-13T01:58:40.6277983Z     let data = match wrapper {
2019-12-13T01:58:40.6278198Z         TupleStruct(_) => -1,
2019-12-13T01:58:40.6278261Z     };
2019-12-13T01:58:40.6278261Z     };
2019-12-13T01:58:40.6278304Z 
2019-12-13T01:58:40.6278358Z     // Neither should this!
2019-12-13T01:58:40.6278432Z     let data = match wrapper {
2019-12-13T01:58:40.6278634Z         TupleStruct(i) => -1,
2019-12-13T01:58:40.6278749Z 
2019-12-13T01:58:40.6278749Z 
2019-12-13T01:58:40.6278814Z     let TupleStruct(data) = wrapper;
2019-12-13T01:58:40.6278907Z 
2019-12-13T01:58:40.6278972Z fn never_enum() {
2019-12-13T01:58:40.6278972Z fn never_enum() {
2019-12-13T01:58:40.6279045Z     let wrapper: Result<i32, !> = Ok(23);
2019-12-13T01:58:40.6279142Z     // This should lint!
2019-12-13T01:58:40.6279142Z     // This should lint!
2019-12-13T01:58:40.6279301Z     let Ok(data) = wrapper;
2019-12-13T01:58:40.6279566Z     // This shouldn't!
2019-12-13T01:58:40.6279807Z     let data = match wrapper {
2019-12-13T01:58:40.6280015Z         Ok(_) => -1,
2019-12-13T01:58:40.6280076Z     };
2019-12-13T01:58:40.6280076Z     };
2019-12-13T01:58:40.6280118Z 
2019-12-13T01:58:40.6280176Z     // Neither should this!
2019-12-13T01:58:40.6280247Z     let data = match wrapper {
2019-12-13T01:58:40.6280615Z         Ok(i) => -1,
2019-12-13T01:58:40.6280924Z 
2019-12-13T01:58:40.6280924Z 
2019-12-13T01:58:40.6281000Z     let Ok(data) = wrapper;
2019-12-13T01:58:40.6281115Z 
2019-12-13T01:58:40.6281538Z impl EmptyEnum {
2019-12-13T01:58:40.6281538Z impl EmptyEnum {
2019-12-13T01:58:40.6281888Z     fn match_on(&self) -> ! {
2019-12-13T01:58:40.6282178Z         // The lint shouldn't pick this up, as `let` won't work here!
2019-12-13T01:58:40.6282279Z         let data = match *self {};
2019-12-13T01:58:40.6282425Z     }
2019-12-13T01:58:40.6282497Z }
2019-12-13T01:58:40.6282545Z 
2019-12-13T01:58:40.6282607Z fn main() {}
---
2019-12-13T01:58:40.6283116Z  #![feature(exhaustive_patterns)]
2019-12-13T01:58:40.6283199Z  #![allow(dead_code, unreachable_code, unused_variables)]
2019-12-13T01:58:40.6283293Z  #![allow(clippy::let_and_return)]
2019-12-13T01:58:40.6283361Z  
2019-12-13T01:58:40.6283439Z  enum SingleVariantEnum {
2019-12-13T01:58:40.6283521Z      Variant(i32),
2019-12-13T01:58:40.6283669Z  
2019-12-13T01:58:40.6283732Z  struct TupleStruct(i32);
2019-12-13T01:58:40.6283808Z  
2019-12-13T01:58:40.6283869Z  enum EmptyEnum {}
2019-12-13T01:58:40.6283869Z  enum EmptyEnum {}
2019-12-13T01:58:40.6283949Z  
2019-12-13T01:58:40.6284014Z  fn infallible_destructuring_match_enum() {
2019-12-13T01:58:40.6284271Z      let wrapper = SingleVariantEnum::Variant(0);
2019-12-13T01:58:40.6284577Z      // This should lint!
2019-12-13T01:58:40.6284577Z      // This should lint!
2019-12-13T01:58:40.6285006Z -    let SingleVariantEnum::Variant(data) = wrapper;
2019-12-13T01:58:40.6285078Z +    let data = match wrapper {
2019-12-13T01:58:40.6285159Z +        SingleVariantEnum::Variant(i) => i,
2019-12-13T01:58:40.6285285Z  
2019-12-13T01:58:40.6285476Z      // This shouldn't!
2019-12-13T01:58:40.6285551Z      let data = match wrapper {
2019-12-13T01:58:40.6285551Z      let data = match wrapper {
2019-12-13T01:58:40.6285771Z          SingleVariantEnum::Variant(_) => -1,
2019-12-13T01:58:40.6285900Z  
2019-12-13T01:58:40.6285967Z      // Neither should this!
2019-12-13T01:58:40.6286051Z      let data = match wrapper {
2019-12-13T01:58:40.6286051Z      let data = match wrapper {
2019-12-13T01:58:40.6286273Z          SingleVariantEnum::Variant(i) => -1,
2019-12-13T01:58:40.6286404Z  
2019-12-13T01:58:40.6286404Z  
2019-12-13T01:58:40.6286474Z      let SingleVariantEnum::Variant(data) = wrapper;
2019-12-13T01:58:40.6286603Z  
2019-12-13T01:58:40.6286669Z  fn infallible_destructuring_match_struct() {
2019-12-13T01:58:40.6286746Z      let wrapper = TupleStruct(0);
2019-12-13T01:58:40.6286806Z  
2019-12-13T01:58:40.6286806Z  
2019-12-13T01:58:40.6286872Z      // This should lint!
2019-12-13T01:58:40.6287101Z -    let TupleStruct(data) = wrapper;
2019-12-13T01:58:40.6287168Z +    let data = match wrapper {
2019-12-13T01:58:40.6287242Z +        TupleStruct(i) => i,
2019-12-13T01:58:40.6287367Z  
2019-12-13T01:58:40.6287555Z      // This shouldn't!
2019-12-13T01:58:40.6287635Z      let data = match wrapper {
2019-12-13T01:58:40.6287840Z          TupleStruct(_) => -1,
2019-12-13T01:58:40.6287840Z          TupleStruct(_) => -1,
2019-12-13T01:58:40.6287924Z      };
2019-12-13T01:58:40.6287976Z  
2019-12-13T01:58:40.6288044Z      // Neither should this!
2019-12-13T01:58:40.6288119Z      let data = match wrapper {
2019-12-13T01:58:40.6288326Z          TupleStruct(i) => -1,
2019-12-13T01:58:40.6288450Z  
2019-12-13T01:58:40.6288450Z  
2019-12-13T01:58:40.6288512Z      let TupleStruct(data) = wrapper;
2019-12-13T01:58:40.6288745Z  
2019-12-13T01:58:40.6288799Z  fn never_enum() {
2019-12-13T01:58:40.6288799Z  fn never_enum() {
2019-12-13T01:58:40.6288874Z      let wrapper: Result<i32, !> = Ok(23);
2019-12-13T01:58:40.6289005Z      // This should lint!
2019-12-13T01:58:40.6289005Z      // This should lint!
2019-12-13T01:58:40.6289256Z -    let Ok(data) = wrapper;
2019-12-13T01:58:40.6289321Z +    let data = match wrapper {
2019-12-13T01:58:40.6289396Z +        Ok(i) => i,
2019-12-13T01:58:40.6289522Z  
2019-12-13T01:58:40.6289714Z      // This shouldn't!
2019-12-13T01:58:40.6289791Z      let data = match wrapper {
2019-12-13T01:58:40.6289985Z          Ok(_) => -1,
2019-12-13T01:58:40.6289985Z          Ok(_) => -1,
2019-12-13T01:58:40.6290133Z      };
2019-12-13T01:58:40.6290191Z  
2019-12-13T01:58:40.6290264Z      // Neither should this!
2019-12-13T01:58:40.6290325Z      let data = match wrapper {
2019-12-13T01:58:40.6291026Z          Ok(i) => -1,
2019-12-13T01:58:40.6291177Z  
2019-12-13T01:58:40.6291177Z  
2019-12-13T01:58:40.6291251Z      let Ok(data) = wrapper;
2019-12-13T01:58:40.6291399Z  
2019-12-13T01:58:40.6291462Z  impl EmptyEnum {
2019-12-13T01:58:40.6291462Z  impl EmptyEnum {
2019-12-13T01:58:40.6291717Z      fn match_on(&self) -> ! {
2019-12-13T01:58:40.6291999Z          // The lint shouldn't pick this up, as `let` won't work here!
2019-12-13T01:58:40.6292103Z          let data = match *self {};
2019-12-13T01:58:40.6292255Z      }
2019-12-13T01:58:40.6292328Z  }
2019-12-13T01:58:40.6292388Z  
2019-12-13T01:58:40.6292459Z  fn main() {}
---
2019-12-13T01:58:40.6297569Z 
2019-12-13T01:58:40.6297782Z ------------------------------------------
2019-12-13T01:58:40.6297863Z stderr:
2019-12-13T01:58:40.6298084Z ------------------------------------------
2019-12-13T01:58:40.6301186Z {"message":"The `!` type is experimental","code":{"code":"E0658","explanation":"An unstable feature was used.\n\nErroneous code example:\n\n