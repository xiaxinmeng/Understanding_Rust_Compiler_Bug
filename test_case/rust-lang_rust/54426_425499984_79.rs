\n\nIf we control the definition of a type, we can implement `Clone` on it ourselves\nwith `#[derive(Clone)]`.\n\nSome types have no ownership semantics at all and are trivial to duplicate. An\nexample is `i32` and the other number types. We don't have to call `.clone()` to\nclone them, because they are marked `Copy` in addition to `Clone`.  Implicit\ncloning is more convenient in this case. We can mark our own types `Copy` if\nall their members also are marked `Copy`.\n\nIn the example below, we implement a `Point` type. Because it only stores two\nintegers, we opt-out of ownership semantics with `Copy`.column_end":12,"is_primary":true,"text":[{"text":"        f(f(10));","highlight_start":11,"highlight_end":12}],"label":"value used here after move","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"error[E0382]: use of moved value: `f*`\n  --> /checkout/src/test/ui/borrowck/two-phase-nonrecv-autoref.rs:95:11\n   |\nLL |         f(f(10));\n   |         - ^ value used here after move\n   |         |\n   |         value moved here\n\n"}
[00:48:10] {"message":"cannot borrow `a` as immutable because it is also borrowed as mutable","code":{"code":"E0502","explanation":"\nThis error indicates that you are trying to borrow a variable as mutable when it\nhas already been borrowed as immutable.\n\nExample of erroneous code:\n\n