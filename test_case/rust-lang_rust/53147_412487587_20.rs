\nuse std::cell::RefCell;\n\nstruct TheDarkKnight;\n\nimpl TheDarkKnight {\n    fn nothing_is_true(&self) {} // First case, we don't take ownership\n}\n\nfn main() {\n    let x = RefCell::ntring`, which does not implement the `Copy` trait","code":null,"level":"note","spans":[{"file_name":"/checkout/src/test/ui/nll/move-errors.rs","byte_start":1638,"byte_end":1639,"line_start":90,"line_end":90,"column_start":14,"column_end":15,"is_primary":true,"text":[{"text":"        B::V(s) => (),","highlight_start":14,"highlight_end":15}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":null},{"message":"consider borrowing here","code":null,"level":"help","spans":[{"file_name":"/checkout/src/test/ui/nll/move-errors.rs","byte_start":1580,"byte_end":1584,"line_start":87,"line_end":87,"column_start":11,"column_end":15,"is_primary":true,"text":[{"text":"    match x[0] {","highlight_start":11,"highlight_end":15}],"label":null,"suggested_replacement":"&x[0]","suggestion_applicability":"Unspecified","expansion":null}],"children":[],"rendered":null}],"rendered":"error[E0508]: cannot move out of type `[B; 1]`, a non-copy array\n  --> /checkout/src/test/ui/nll/move-errors.rs:87:11\n   |\nLL |     match x[0] {\n   |           ^^^^\n   |           |\n   |           cannot move out of here\n   |           help: consider borrowing here: `&x[0]`\nLL |     //~^ ERROR\nLL |         B::U(d) => (),\n   |              - data moved here\nLL |         B::V(s) => (),\n   |              - ... and here\n   |\nnote: move occurs because `d` has type `D`, which does not implement the `Copy` trait\n  --> /checkout/src/test/ui/nll/move-errors.rs:89:14\n   |\nLL |         B::U(d) => (),\n   |              ^\nnote: move occurs because `s` has type `std::string::String`, which does not impancy: FancyNum\n}\n\nimpl Drop for DropStruct {\n    fn drop(&mut self) {\n        // Destruct DropStruct, possibly using FancyNum\n    }\n}\n\nfn main() {\n    let drop_struct = DropStruct{fancy: FancyNum{num: 5}};\n    let ref fancy_field = drop_struct.fancy; // No more errors!\n    println!(\"Fancy: {}\", fancy_field.num);\n    // implicit call to `drop_struct.drop()` as drop_struct goes out of scope\n}\n