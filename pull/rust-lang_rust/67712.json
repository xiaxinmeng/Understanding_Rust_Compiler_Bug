{"url": "https://api.github.com/repos/rust-lang/rust/pulls/67712", "id": 357908384, "node_id": "MDExOlB1bGxSZXF1ZXN0MzU3OTA4Mzg0", "html_url": "https://github.com/rust-lang/rust/pull/67712", "diff_url": "https://github.com/rust-lang/rust/pull/67712.diff", "patch_url": "https://github.com/rust-lang/rust/pull/67712.patch", "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/67712", "number": 67712, "state": "closed", "locked": false, "title": "Stabilize `#![feature(slice_patterns)]` in 1.42.0", "user": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "body": "# Stabilization report\r\n\r\nThe following is the stabilization report for `#![feature(slice_patterns)]`.\r\nThis report is the collaborative effort of @matthewjasper and @Centril.\r\n\r\nTracking issue: https://github.com/rust-lang/rust/issues/62254\r\n[Version target](https://forge.rust-lang.org/#current-release-versions): 1.42 (2020-01-30 => beta, 2020-03-12 => stable).\r\n\r\n## Backstory: slice patterns\r\n\r\nIt is already possible to use slice patterns on stable Rust to match on arrays and slices. For example, to match on a slice, you may write:\r\n\r\n```rust\r\nfn foo(slice: &[&str]) {\r\n    match slice {\r\n        [] => { dbg!() }\r\n        [a] => { dbg!(a); }\r\n        [a, b] => { dbg!(a, b); }\r\n        _ => {}\r\n    //  ^ Fallback -- necessary because the length is unknown!\r\n    }\r\n}\r\n```\r\n\r\nTo match on an array, you may instead write:\r\n\r\n```rust\r\nfn bar([a, b, c]: [u8; 3]) {}\r\n//     --------- Length is known, so pattern is irrefutable.\r\n```\r\n\r\nHowever, on stable Rust, it is not yet possible to match on a subslice or subarray.\r\n\r\n## A quick user guide: Subslice patterns\r\n\r\nThe ability to match on a subslice or subarray is gated under `#![feature(slice_patterns)]` and is what is proposed for stabilization here.\r\n\r\n### The syntax of subslice patterns\r\n\r\nSubslice / subarray patterns come in two flavors syntactically.\r\n\r\nCommon to both flavors is they use the token `..`, referred as a *\"rest pattern\"* in a pattern context. This rest pattern functions as a variable-length pattern, matching whatever amount of elements that haven't been matched already before and after.\r\n\r\nWhen `..` is used syntactically as an element of a slice-pattern, either directly (1), or as part of a binding pattern (2), it becomes a subslice pattern.\r\n\r\nOn stable Rust, a rest pattern `..` can also be used in a tuple or tuple-struct pattern with `let (x, ..) = (1, 2, 3);` and `let TS(x, ..) = TS(1, 2, 3);` respectively.\r\n\r\n### (1) Matching on a subslice without binding it\r\n\r\n```rust\r\nfn base(string: &str) -> u8 {\r\n    match string.as_bytes() {\r\n        [b'0', b'x', ..] => 16,\r\n        [b'0', b'o', ..] => 8,\r\n        [b'0', b'b', ..] => 2,\r\n        _ => 10,\r\n    }\r\n}\r\n\r\nfn main() {\r\n    assert_eq!(base(\"0xFF\"), 16);\r\n    assert_eq!(base(\"0x\"), 16);\r\n}\r\n```\r\n\r\nIn the function `base`, the pattern `[b'0', b'x', ..]` will match on any byte-string slice with the *prefix* `0x`. Note that `..` may match on nothing, so `0x` is a valid match.\r\n\r\n### (2) Binding a subslice:\r\n\r\n```rust\r\nfn main() {\r\n    #[derive(PartialEq, Debug)]\r\n    struct X(u8);\r\n    let xs: Vec<X> = vec![X(0), X(1), X(2)];\r\n\r\n    if let [start @ .., end] = &*xs {\r\n        //              --- bind on last element, assuming there is one.\r\n        //  ---------- bind the initial elements, if there are any.\r\n        assert_eq!(start, &[X(0), X(1)] as &[X]);\r\n        assert_eq!(end, &X(2));\r\n        let _: &[X] = start;\r\n        let _: &X = end;\r\n    }\r\n}\r\n```\r\n\r\nIn this case, `[start @ .., end]`  will match any non-empty slice, binding the last element to `end` and any elements before that to `start`. Note in particular that, as above, `start` may match on the empty slice.\r\n\r\n### Only one `..` per slice pattern\r\n\r\nIn today's stable Rust, a tuple (struct) pattern `(a, b, c)` can only have one subtuple pattern (e.g., `(a, .., c)`). That is, if there is a rest pattern, it may only occur once. Any `..` that follow, as in e.g., `(a, .., b, ..)` will cause an error, as there is no way for the compiler to know what `b` applies to. This rule also applies to slice patterns. That is, you may also not write `[a, .., b, ..]`.\r\n\r\n## Motivation\r\n\r\n[PR #67569]: https://github.com/rust-lang/rust/pull/67569/files\r\n\r\nSlice patterns provide a natural and efficient way to pattern match on slices and arrays. This is particularly useful as slices and arrays are quite a common occurence in modern software targeting modern hardware. However, as aforementioned, it's not yet possible to perform incomplete matches, which is seen in `fn base`, an example taken from the `rustc` codebase itself. This is where subslice patterns come in and extend slice patterns with the natural syntax `xs @ ..` and `..`, where the latter is already used for tuples and tuple structs. As an example of how subslice patterns can be used to clean up code, we have [PR #67569]. In this PR, slice patterns enabled us to improve readability and reduce unsafety, at no loss to performance.\r\n\r\n## Technical specification\r\n\r\n### Grammar\r\n\r\nThe following specification is a *sub-set* of the grammar necessary to explain what interests us here. Note that stabilizing subslice patterns does not alter the stable grammar. The stabilization contains purely semantic changes.\r\n\r\n```rust\r\nBinding = reference:\"ref\"? mutable:\"mut\"? name:IDENT;\r\n\r\nPat =\r\n  | ... // elided\r\n  | Rest: \"..\"\r\n  | Binding:{ binding:Binding { \"@\" subpat:Pat }? }\r\n  | Slice:{ \"[\" elems:Pat* %% \",\" \"]\" }\r\n  | Paren:{ \"(\" pat:Pat \")\" }\r\n  | Tuple:{ path:Path? \"(\" elems:Pat* &% \",\" \")\" }\r\n  ;\r\n```\r\n\r\nNotes:\r\n\r\n1. `(..)` is interpreted as a `Tuple`, not a `Paren`.\r\n   This means that `[a, (..)]` is interpreted as `Slice[Binding(a), Tuple[Rest]]` and not `Slice[Binding(a), Paren(Rest)]`.\r\n\r\n### Name resolution\r\n\r\n[resolve_pattern_inner]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/late/struct.LateResolutionVisitor.html#method.resolve_pattern_inner\r\n[product context]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_resolve/late/enum.PatBoundCtx.html#variant.Product\r\n\r\nA slice pattern is [resolved][resolve_pattern_inner] as a [product context] and `..` is given no special treatment.\r\n\r\n### Abstract syntax of slice patterns\r\n\r\nThe abstract syntax (HIR level) is defined like so:\r\n\r\n```rust\r\nenum PatKind {\r\n    ... // Other unimportant stuff.\r\n    Wild,\r\n    Binding {\r\n        binding: Binding,\r\n        subpat: Option<Pat>,\r\n    },\r\n    Slice {\r\n        before: List<Pat>,\r\n        slice: Option<Pat>,\r\n        after: List<Pat>,\r\n    },\r\n}\r\n```\r\n\r\n[`hir::PatKind`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/enum.PatKind.html\r\n\r\nThe executable definition is found in [`hir::PatKind`].\r\n\r\n### Lowering to abstract syntax\r\n\r\nLowering a slice pattern to its abstract syntax proceeds by:\r\n\r\n1. Lowering each element pattern of the slice pattern, where:\r\n\r\n    1. `..` is lowered to `_`,\r\n       recording that it was a subslice pattern,\r\n\r\n    2. `binding @ ..` is lowered to `binding @ _`,\r\n       recording that it was a subslice pattern,\r\n\r\n    3. and all other patterns are lowered as normal,\r\n       recording that it was not a subslice pattern.\r\n\r\n2. Taking all lowered elements until the first subslice pattern.\r\n\r\n3. Take all following elements.\r\n\r\n   If there are any,\r\n\r\n      1. The head is the sub-`slice` pattern.\r\n      2. The tail (`after`) must not contain a subslice pattern,\r\n         or an error occurs.\r\n\r\n[`LoweringContext::lower_pat_slice`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/hir/lowering/struct.LoweringContext.html#method.lower_pat_slice\r\n\r\nThe full executable definition can be found in [`LoweringContext::lower_pat_slice`].\r\n\r\n### Type checking slice patterns\r\n\r\n#### Default binding modes\r\n\r\n[non-reference pattern]: https://doc.rust-lang.org/nightly/reference/patterns.html#binding-modes\r\n[`is_non_ref_pat`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/struct.FnCtxt.html#method.is_non_ref_pat\r\n[peel_off_references]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/struct.FnCtxt.html#method.peel_off_references\r\n\r\nA slice pattern is a [non-reference pattern] as defined in [`is_non_ref_pat`]. This means that when type checking a slice pattern, as many immediate reference types are [peeled off][peel_off_references] from the `expected` type as possible and the default binding mode is adjusted to by-reference before checking the slice pattern. See https://github.com/rust-lang/rust/pull/63118/#issuecomment-524161584 for an algorithmic description.\r\n\r\n[RFC 2359]: https://github.com/rust-lang/rfcs/blob/master/text/2359-subslice-pattern-syntax.md\r\n\r\n[rfc-2359-gle]: https://github.com/rust-lang/rfcs/blob/master/text/2359-subslice-pattern-syntax.md#guide-level-explanation\r\n\r\nSee [RFC 2359]'s [guide-level explanation][rfc-2359-gle] and the tests listed below for examples of what effect this has.\r\n\r\n#### Checking the pattern\r\n\r\nType checking a slice pattern proceeds as follows:\r\n\r\n1. Resolve any type variables by a single level.\r\n   If the result still is a type variable, error.\r\n\r\n2. Determine the expected type for any subslice pattern (`slice_ty`) and for elements (`inner_ty`) depending on the expected type.\r\n\r\n   1. If the expected type is an array (`[E; N]`):\r\n\r\n      1. Evaluate the length of the array.\r\n         If the length couldn't be evaluated, error.\r\n         This may occur when we have e.g., `const N: usize`.\r\n         Now `N` is known.\r\n\r\n      2. If there is no sub-`slice` pattern,\r\n         check `len(before) == N`,\r\n         and otherwise error.\r\n\r\n      3. Otherwise,\r\n         set `S = N - len(before) - len(after)`,\r\n         and check `N >= 0` and otherwise error.\r\n         Set `slice_ty = [E; S]`.\r\n\r\n      Set `inner_ty = E`.\r\n\r\n   2. If the expected type is a slice (`[E]`),\r\n      set `inner_ty = E` and `slice_ty = [E]`.\r\n\r\n   3. Otherwise, error.\r\n\r\n3. Check each element in `before` and `after` against `inner_ty`.\r\n4. If it exists, check `slice` against `slice_ty`.\r\n\r\n[`check_pat_slice`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_typeck/check/struct.FnCtxt.html#method.check_pat_slice\r\n\r\nFor an executable definition, see [`check_pat_slice`].\r\n\r\n### Typed abstract syntax of slice and array patterns\r\n\r\nThe typed abstract syntax (HAIR level) is defined like so:\r\n\r\n```rust\r\nenum PatKind {\r\n    ... // Other unimportant stuff.\r\n    Wild,\r\n    Binding {\r\n        ... // Elided.\r\n    }\r\n    Slice {\r\n        prefix: List<Pat>,\r\n        slice: Option<Pat>,\r\n        suffix: List<Pat>,\r\n    },\r\n    Array {\r\n        prefix: List<Pat>,\r\n        slice: Option<Pat>,\r\n        suffix: List<Pat>,\r\n    },\r\n}\r\n```\r\n\r\n[`hair::pattern::PatKind`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/hair/pattern/enum.PatKind.html\r\n\r\nThe executable definition is found in [`hair::pattern::PatKind`].\r\n\r\n### Lowering to typed abstract syntax\r\n\r\nLowering a slice pattern to its typed abstract syntax proceeds by:\r\n\r\n1. Lowering each pattern in `before` into `prefix`.\r\n2. Lowering the `slice`, if it exists, into `slice`.\r\n   1. A `Wild` pattern in abstract syntax is lowered to `Wild`.\r\n   2. A `Binding` pattern in abstract syntax is lowered to `Binding { .. }`.\r\n3. Lowering each pattern in `after` into `after`.\r\n4. If the type is `[E; N]`, construct `PatKind::Array { prefix, slice, after }`, otherwise `PatKind::Slice { prefix, slice, after }`.\r\n\r\n[`PatCtxt::slice_or_array_pattern`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir/hair/pattern/struct.PatCtxt.html#method.slice_or_array_pattern\r\n\r\nThe executable definition is found in [`PatCtxt::slice_or_array_pattern`].\r\n\r\n### Exhaustiveness checking\r\n\r\nLet `E` be the element type of a slice or array.\r\n\r\n- For array types, `[E; N]` with a known length `N`, the full set of constructors required for an exahustive match is the sequence `ctors(E)^N` where `ctors` denotes the constructors required for an exhaustive match of `E`.\r\n\r\n- Otherwise, for slice types `[E]`, or for an array type with an unknown length `[E; ?L]`, the full set of constructors is the infinite sequence `\u22c3_i=0^\u221e ctors(E)^i`. This entails that an exhaustive match without a cover-all pattern (e.g. `_` or `binding`) or a subslice pattern (e.g., `[..]` or `[_, _, ..]`) is impossible.\r\n\r\n- `PatKind::{Slice, Array}(prefix, None, suffix @ [])` cover a sequence of of `len(prefix)` covered by `patterns`. Note that `suffix.len() > 0` with `slice == None` is unrepresentable.\r\n\r\n- `PatKind::{Slice, Array}(prefix, Some(s), suffix)` cover a `sequence` with `prefix` as the start and `suffix` as the end and where `len(prefix) + len(suffix) <= len(sequence)`. The `..` in the middle is interpreted as an unbounded number of `_`s in terms of exhaustiveness checking.\r\n\r\n### MIR representation\r\n\r\nThe relevant MIR representation for the lowering into MIR, which is discussed in the next section, includes:\r\n\r\n```rust\r\nenum Rvalue {\r\n    // ...\r\n    /// The length of a `[X]` or `[X; N]` value.\r\n    Len(Place),\r\n}\r\n\r\nstruct Place {\r\n    base: PlaceBase,\r\n    projection: List<PlaceElem>,\r\n}\r\n\r\nenum ProjectionElem {\r\n    // ...\r\n    ConstantIndex {\r\n        offset: Nat,\r\n        min_length: Nat,\r\n        from_end: bool,\r\n    },\r\n    Subslice {\r\n        from: Nat,\r\n        to: Nat,\r\n        from_end: bool,\r\n    },\r\n}\r\n```\r\n\r\n### Lowering to MIR\r\n\r\n* For a slice pattern matching a slice, where the pattern has `N` elements specified, there is a check that the `Rvalue::Len` of the slice is at least `N` to decide if the pattern can match.\r\n\r\n* There are two kinds of `ProjectionElem` used for slice patterns:\r\n\r\n    1. `ProjectionElem::ConstantIndex` is an array or slice element with a known index. As a shorthand it's written `base[offset of min_length]` if `from_end` is false and `base[-offset of min_length]` if `from_end` is true. `base[-offset of min_length]` is the `len(base) - offset`th element of `base`.\r\n\r\n    2. `ProjectionElem::Subslice` is a subslice of an array or slice with known bounds. As a shorthand it's written `base[from..to]` if `from_end` is false and `base[from:-to]` if `from_end` is true. `base[from:-to]` is the subslice `base[from..len(base) - to]`.\r\n\r\n    * Note that `ProjectionElem::Index` is used for indexing expressions, but not for slice patterns. It's written `base[idx]`.\r\n\r\n* When binding an array pattern, any individual element binding is lowered to an assignment or borrow of `base[offset of len]` where `offset` is the element's index in the array and `len` is the array's length.\r\n\r\n* When binding a slice pattern, let `N` be the number of elements that have patterns. Elements before the subslice pattern (`prefix`) are lowered to `base[offset of N]` where `offset` is the element's index from the start. Elements after the subslice pattern (`suffix`) are lowered to `base[-offset of N]` where `offset` is the element's index from the end, plus 1.\r\n\r\n* Subslices of arrays are lowered to `base[from..to]` where `from` is the number of elements before the subslice pattern and `to = len(array) - len(suffix)` is the length of the array minus the number of elements after the subslice pattern.\r\n\r\n* Subslices of slices are lowered to `base[from:-to]` where `from` is the number of elements before the subslice pattern (`len(prefix)`) and `to` is the number of elements after the subslice pattern (`len(suffix)`).\r\n\r\n### Safety and const checking\r\n\r\n* Subslice patterns do not introduce any new unsafe operations.\r\n\r\n* As subslice patterns for arrays are irrefutable, they are allowed in const contexts. As are `[..]` and `[ref y @ ..]` patterns for slices. However, `ref mut` bindings are only allowed with `feature(const_mut_refs)` for now.\r\n\r\n* As other subslice patterns for slices require a `match`, `if let`, or `while let`, they are only allowed with `feature(const_if_match, const_fn)` for now.\r\n\r\n* Subslice patterns may occur in promoted constants.\r\n\r\n### Borrow and move checking\r\n\r\n* A subslice pattern can be moved from if it has an array type `[E; N]` and the parent array can be moved from.\r\n\r\n* Moving from an array subslice pattern moves from all of the elements of the array within the subslice.\r\n\r\n    * If the subslice contains at least one element, this means that dynamic indexing (`arr[idx]`) is no longer allowed on the array.\r\n\r\n    * The array can be reinitialized and can still be matched with another slice pattern that uses a disjoint set of elements.\r\n\r\n* A subslice pattern can be mutably borrowed if the parent array/slice can be mutably borrowed.\r\n\r\n* When determining whether an access conflicts with a borrow and at least one is a slice pattern:\r\n\r\n    * `x[from..to]` always conflicts with `x` and `x[idx]` (where `idx` is a variable).\r\n\r\n    * `x[from..to]` conflicts with `x[idx of len]` if `from <= idx` and `idx < to` (that is, `idx \u2208 from..to`).\r\n\r\n    * `x[from..to]` conflicts with `x[from2..to2]` if `from < to2` and `from2 < to` (that is, `(from..to) \u2229 (from2..to2) \u2260 \u2205`).\r\n\r\n    * `x[from:-to]` always conflicts with `x`, `x[idx]`, and `x[from2:-to2]`.\r\n\r\n    * `x[from:-to]` conflicts with `x[idx of len]` if `from <= idx`.\r\n\r\n    * `x[from:-to]` conflicts with `x[-idx of len]` if `to < idx`.\r\n\r\n* A constant index from the end conflicts with other elements as follows:\r\n\r\n    * `x[-idx of len]` always conflicts with `x` and `x[idx]`.\r\n\r\n    * `x[-idx of len]` conflicts with `x[-idx2 of len2]` if `idx == idx2`.\r\n\r\n    * `x[-idx of len]` conflicts with `x[idx2 of len2]` if `idx + idx2 >= max(len, len2)`.\r\n\r\n## Tests\r\n\r\nThe tests can be primarily seen in the PR itself. Here are some of them:\r\n\r\n### Parsing (3)\r\n\r\n* Testing that `..` patterns are syntactically allowed in all pattern contexts (2)\r\n    * [pattern/rest-pat-syntactic.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/rest-pat-syntactic.rs)\r\n    * [ignore-all-the-things.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/ignore-allthe-things.rs)\r\n\r\n* Slice patterns allow a trailing comma, including after `..` (1)\r\n    * [trailing-comma.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/trailing-comma.rs)\r\n\r\n### Lowering (2)\r\n\r\n* `@ ..` isn't allowed outside of slice patterns and only allowed once in each pattern (1)\r\n    * [pattern/rest-pat-semantic-disallowed.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/rest-pat-semantic-disallowed.rs)\r\n\r\n* Mulitple `..` patterns are not allowed (1)\r\n    * [parser/match-vec-invalid.rs](https://github.com/rust-lang/rust/blob/53712f8637dbe326df569a90814aae1cc5429710/src/test/ui/parser/match-vec-invalid.rs)\r\n\r\n### Type checking (5)\r\n\r\n* Default binding modes apply to slice patterns (2)\r\n    * [rfc-2005-default-binding-mode/slice.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/rfc-2005-default-binding-mode/slice.rs)\r\n    * [rfcs/rfc-2005-default-binding-mode/slice.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/rfcs/rfc-2005-default-binding-mode/slice.rs)\r\n\r\n* Array patterns cannot have more elements in the pattern than in the array (2)\r\n    * [match/match-vec-mismatch.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/match/match-vec-mismatch.rs)\r\n    * [error-codes/E0528.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/error-codes/E0528.rs)\r\n\r\n* Array subslice patterns have array types (1)\r\n    * [array-slice-vec/subslice-patterns-pass.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/array-slice-vec/subslice-patterns-pass.rs)\r\n\r\n### Exhaustiveness and usefulness checking (20)\r\n\r\n* Large subslice matches don't stack-overflow the exhaustiveness checker (1)\r\n    * [pattern/issue-53820-slice-pattern-large-array.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/issue-53820-slice-pattern-large-array.rs)\r\n\r\n* Array patterns with subslices are irrefutable (1)\r\n    * [issues/issue-7784.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/issues/issue-7784.rs)\r\n\r\n* `[xs @ ..]` slice patterns are irrefutable (1)\r\n    * [binding/irrefutable-slice-patterns.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/binding/irrefutable-slice-patterns.rs)\r\n\r\n* Subslice patterns can match zero-length slices (2)\r\n    * [issues/issue-15080.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/issues/issue-15080.rs)\r\n    * [issues/issue-15104.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/issues/issue-15104.rs)\r\n\r\n* General tests (13)\r\n    * [issues/issue-12369.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/issues/issue-12369.rs)\r\n    * [issues/issue-37598.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/issues/issue-37598.rs)\r\n    * [pattern/usefulness/match-vec-unreachable.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/usefulness/match-vec-unreachable.rs)\r\n    * [pattern/usefulness/non-exhaustive-match.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/usefulness/non-exhaustive-match.rs)\r\n    * [pattern/usefulness/non-exhaustive-match-nested.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/usefulness/non-exhaustive-match-nested.rs)\r\n    * [pattern/usefulness/non-exhaustive-pattern-witness.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/usefulness/non-exhaustive-pattern-witness.rs)\r\n    * [pattern/usefulness/65413-constants-and-slices-exhaustiveness.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/usefulness/65413-constants-and-slices-exhaustiveness.rs)\r\n    * [pattern/usefulness/match-byte-array-patterns.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/usefulness/match-byte-array-patterns.rs)\r\n    * [pattern/usefulness/match-slice-patterns.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/usefulness/match-slice-patterns.rs)\r\n    * [pattern/usefulness/slice-patterns-exhaustiveness.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/usefulness/slice-patterns-exhaustiveness.rs)\r\n    * [pattern/usefulness/slice-patterns-irrefutable.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/usefulness/slice-patterns-irrefutable.rs)\r\n    * [pattern/usefulness/slice-patterns-reachability.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/usefulness/slice-patterns-reachability.rs)\r\n    * [uninhabited/uninhabited-patterns.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/uninhabited/uninhabited-patterns.rs)\r\n\r\n* Interactions with or-patterns (2)\r\n    * [or-patterns/exhaustiveness-pass.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/or-patterns/exhaustiveness-pass.rs)\r\n    * [or-patterns/exhaustiveness-unreachable-pattern.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/or-patterns/exhaustiveness-unreachable-pattern.rs)\r\n\r\n### Borrow checking (28)\r\n\r\n* Slice patterns can only move from owned, fixed-length arrays (4)\r\n    * [borrowck/borrowck-move-out-of-vec-tail.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-move-out-of-vec-tail.rs)\r\n    * [moves/move-out-of-slice-2.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/moves/move-out-of-slice-2.rs)\r\n    * [moves/move-out-of-array-ref.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/moves/move-out-of-array-ref.rs)\r\n    * [issues/issue-12567.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/issues/issue-12567.rs)\r\n\r\n* Moves from arrays are tracked by element (2)\r\n    * [borrowck/borrowck-move-out-from-array-no-overlap.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-move-out-from-array-no-overlap.rs)\r\n    * [borrowck/borrowck-move-out-from-array-use-no-overlap.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-move-out-from-array-use-no-overlap.rs)\r\n\r\n* Slice patterns cannot be used on moved-from slices/arrays (2)\r\n    * [borrowck/borrowck-move-out-from-array.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-move-out-from-array.rs)\r\n    * [borrowck/borrowck-move-out-from-array-use.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-move-out-from-array-use.rs)\r\n\r\n* Slice patterns cannot be used with conflicting borrows (3)\r\n    * [borrowck/borrowck-describe-lvalue.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-describe-lvalue.rs)\r\n    * [borrowck/borrowck-slice-pattern-element-loan-array.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-slice-pattern-element-loan-array.rs)\r\n    * [borrowck/borrowck-slice-pattern-element-loan-slice.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-slice-pattern-element-loan-slice.rs)\r\n\r\n* Borrows from slice patterns are tracked and only conflict when there is possible overlap (6)\r\n    * [borrowck/borrowck-slice-pattern-element-loan-array-no-overlap.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-slice-pattern-element-loan-array-no-overlap.rs)\r\n    * [borrowck/borrowck-slice-pattern-element-loan-slice-no-overlap.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-slice-pattern-element-loan-slice-no-overlap.rs)\r\n    * [borrowck/borrowck-slice-pattern-element-loan-rpass.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-slice-pattern-element-loan-rpass.rs)\r\n    * [borrowck/borrowck-vec-pattern-element-loan.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-vec-pattern-element-loan.rs)\r\n    * [borrowck/borrowck-vec-pattern-loan-from-mut.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-vec-pattern-loan-from-mut.rs)\r\n    * [borrowck/borrowck-vec-pattern-tail-element-loan.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-vec-pattern-tail-element-loan.rs)\r\n\r\n* Slice patterns affect indexing expressions (1)\r\n    * [borrowck/borrowck-vec-pattern-move-tail.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-vec-pattern-move-tail.rs)\r\n\r\n* Borrow and move interactions with `box` patterns (1)\r\n    * [borrowck/borrowck-vec-pattern-move-tail.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-vec-pattern-move-tail.rs)\r\n\r\n* Slice patterns correctly affect inference of closure captures (2)\r\n    * [borrowck/borrowck-closures-slice-patterns.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-closures-slice-patterns.rs)\r\n    * [borrowck/borrowck-closures-slice-patterns-ok.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-closures-slice-patterns-ok.rs)\r\n\r\n* Interactions with `#![feature(bindings_after_at)]` (7)\r\n    * [pattern/bindings-after-at/borrowck-move-and-move.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/bindings-after-at/borrowck-move-and-move.rs)\r\n    * [pattern/bindings-after-at/borrowck-pat-at-and-box-pass.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box-pass.rs)\r\n    * [pattern/bindings-after-at/borrowck-pat-at-and-box.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/bindings-after-at/borrowck-pat-at-and-box.rs)\r\n    * [pattern/bindings-after-at/borrowck-pat-by-copy-bindings-in-at.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/bindings-after-at/borrowck-pat-by-copy-bindings-in-at.rs)\r\n    * [pattern/bindings-after-at/borrowck-pat-ref-both-sides.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-both-sides.rs)\r\n    * [pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-and-ref.rs)\r\n    * [pattern/bindings-after-at/borrowck-pat-ref-mut-twice.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/pattern/bindings-after-at/borrowck-pat-ref-mut-twice.rs)\r\n\r\n* Misc (1)\r\n    * [issues/issue-26619.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/issues/issue-26619.rs)\r\n\r\n### MIR lowering (1)\r\n\r\n* [uniform_array_move_out.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/mir-opt/uniform_array_move_out.rs)\r\n\r\n### Evaluation (19)\r\n\r\n* Slice patterns don't cause leaks or double drops (2)\r\n    * [drop/dynamic-drop.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/drop/dynamic-drop.rs)\r\n    * [drop/dynamic-drop-async.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/drop/dynamic-drop-async.rs)\r\n\r\n* General run-pass tests (10)\r\n    * [array-slice-vec/subslice-patterns-pass.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/array-slice-vec/subslice-patterns-pass.rs)\r\n    * [array-slice-vec/vec-matching-fixed.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/array-slice-vec/vec-matching-fixed.rs)\r\n    * [array-slice-vec/vec-matching-fold.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/array-slice-vec/vec-matching-fold.rs)\r\n    * [array-slice-vec/vec-matching-legal-tail-element-borrow.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/array-slice-vec/vec-matching-legal-tail-element-borrow.rs)\r\n    * [array-slice-vec/vec-matching.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/array-slice-vec/vec-matching.rs)\r\n    * [array-slice-vec/vec-tail-matching.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/array-slice-vec/vec-tail-matching.rs)\r\n    * [binding/irrefutable-slice-patterns.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/binding/irrefutable-slice-patterns.rs)\r\n    * [binding/match-byte-array-patterns.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/binding/match-byte-array-patterns.rs)\r\n    * [binding/match-vec-alternatives.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/binding/match-vec-alternatives.rs)\r\n    * [borrowck/borrowck-slice-pattern-element-loan-rpass.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/borrowck/borrowck-slice-pattern-element-loan-rpass.rs)\r\n\r\n* Matching a large by-value array (1)\r\n    * [issues/issue-17877.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/issues/issue-17877.rs)\r\n\r\n* Uninhabited elements (1)\r\n    * [binding/empty-types-in-patterns.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/binding/empty-types-in-patterns.rs)\r\n\r\n* Zero-sized elements (3)\r\n    * [binding/zero_sized_subslice_match.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/binding/zero_sized_subslice_match.rs)\r\n    * [array-slice-vec/subslice-patterns-const-eval.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/array-slice-vec/subslice-patterns-const-eval.rs)\r\n    * [array-slice-vec/subslice-patterns-const-eval-match.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/array-slice-vec/subslice-patterns-const-eval-match.rs)\r\n\r\n* Evaluation in const contexts (2)\r\n    * [array-slice-vec/subslice-patterns-const-eval.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/array-slice-vec/subslice-patterns-const-eval.rs)\r\n    * [array-slice-vec/subslice-patterns-const-eval-match.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/array-slice-vec/subslice-patterns-const-eval-match.rs)\r\n\r\n## Misc (1)\r\n\r\n* Exercising a case where const-prop cased an ICE (1)\r\n    * [consts/const_prop_slice_pat_ice.rs](https://github.com/rust-lang/rust/blob/acb6690e1d58fc5f262ada5b5030fe73e601f1e8/src/test/ui/consts/const_prop_slice_pat_ice.rs)\r\n\r\n## History\r\n\r\n- 2012-12-08, commit https://github.com/rust-lang/rust/commit/1968cb315af9d128ee4457738fddd1eba275277f\r\n  Author: Jakub Wieczorek\r\n  Reviewers: @graydon \r\n\r\n  This is where slice patterns were first implemented. It is particularly instructive to read the `vec-tail-matching.rs` test.\r\n\r\n- 2013-08-20, issue https://github.com/rust-lang/rust/issues/8636\r\n  Author: @huonw\r\n  Fixed by @mikhail-m1 in https://github.com/rust-lang/rust/pull/51894\r\n\r\n  The issue describes a problem wherein the borrow-checker would not consider disjointness when checking mutable references in slice patterns.\r\n\r\n- 2014-09-03, RFC https://github.com/rust-lang/rfcs/pull/164\r\n  Author: @brson\r\n  Reviewers: The Core Team\r\n\r\n  The RFC decided to feature gate slice patterns due to concerns over lack of oversight and the exhaustiveness checking logic not having seen much love. Since then, the exhaustivenss checking algorithm, in particular for slice patterns, has been substantially refactored and tests have been added.\r\n\r\n- 2014-09-03, RFC https://github.com/rust-lang/rfcs/pull/202\r\n  Author: @krdln\r\n  Reviewers: The Core Team\r\n\r\n  > Change syntax of subslices matching from `..xs` to `xs..` to be more consistent with the rest of the language and allow future backwards compatible improvements.\r\n\r\n  In 2019, https://github.com/rust-lang/rfcs/pull/2359 changed the syntax again in favor of `..` and `xs @ ..`.\r\n\r\n- 2014-09-08, PR https://github.com/rust-lang/rust/pull/17052\r\n  Author: @pcwalton\r\n  Reviewers: @alexcrichton and @sfackler\r\n\r\n  This implemented the feature gating as specified in https://github.com/rust-lang/rfcs/pull/164.\r\n\r\n- 2015-03-06, RFC https://github.com/rust-lang/rfcs/pull/495\r\n  Author: @P1start\r\n  Reviewers: The Core Team\r\n\r\n  The RFC changed array and slice patterns like so:\r\n\r\n  - Made them only match on arrays (`[T; N]`) and slice types (`[T]`), not references to slice types (`& mut? [T]`).\r\n  - Made subslice matching yield a value of type `[T; N]` or `[T]`, not `& mut? [T]`.\r\n  - Allowed multiple mutable references to be made to different parts of the same array or slice in array patterns.\r\n\r\n  These changes were made to fit with the introduction of DSTs like `[T]` as well as with e.g. `box [a, b, c]` (`Box<[T]>`) in the future. All points remain true today, in particular with the advent of default binding modes.\r\n\r\n- 2015-03-22, PR https://github.com/rust-lang/rust/pull/23361\r\n  Author: @petrochenkov\r\n  Reviewers: Unknown\r\n\r\n  The PR adjusted codegen (\"trans\") such that `let ref a = *\"abcdef\"` would no longer ICE, paving the way for https://github.com/rust-lang/rfcs/pull/495.\r\n\r\n- 2015-05-28, PR https://github.com/rust-lang/rust/pull/23794\r\n  Author: @brson\r\n  Reviewers: @nrc\r\n\r\n  The PR feature gated slice patterns in more contexts.\r\n\r\n- 2016-06-09, PR https://github.com/rust-lang/rust/pull/32202\r\n  Author: @arielb1\r\n  Reviewers: @eddyb and @nikomatsakis\r\n\r\n  This implemented RFC https://github.com/rust-lang/rfcs/pull/495 via a MIR based implementation fixing some bugs.\r\n\r\n- 2016-09-16, PR https://github.com/rust-lang/rust/pull/36353\r\n  Author: @arielb1\r\n  Reviewers: @nagisa, @pnkfelix, and @nikomatsakis\r\n\r\n  The PR made move-checker improvements prohibiting moves out of slices.\r\n\r\n- 2018-02-17, PR https://github.com/rust-lang/rust/pull/47926\r\n  Author: @mikhail-m1\r\n  Reviewers: @nikomatsakis\r\n\r\n  This added the `UniformArrayMoveOut` which converted move-out-from-array by `Subslice` and `ConstIndex {.., from_end: true }` to `ConstIndex` move out(s) from the beginning of the array. This fixed some problems with the MIR borrow-checker and drop-elaboration of arrays.\r\n\r\n  Unfortunately, the transformation ultimately proved insufficient for soundness and was removed and replaced in https://github.com/rust-lang/rust/pull/66650.\r\n\r\n- 2018-02-19, PR https://github.com/rust-lang/rust/pull/48355\r\n  Author: @mikhail-m1\r\n  Reviewers: @nikomatsakis\r\n\r\n  After https://github.com/rust-lang/rust/pull/47926, this restored some MIR optimizations after drop-elaboration and borrow-checking.\r\n\r\n- 2018-03-20, PR https://github.com/rust-lang/rust/pull/48516\r\n  Author: @petrochenkov\r\n  Reviewers: @nikomatsakis\r\n\r\n  This stabilized fixed length slice patterns `[a, b, c]` without variable length subslices and moved subslice patterns into `#![feature(slice_patterns)`. See https://github.com/rust-lang/rust/issues/48836 wherein the language team accepted the proposal to stabilize.\r\n\r\n- 2018-07-06, PR https://github.com/rust-lang/rust/pull/51894\r\n  Author: @mikhail-m1\r\n  Reviewers: @nikomatsakis\r\n\r\n  https://github.com/rust-lang/rust/issues/8636 was fixed such that the borrow-checker would consider disjointness with respect to mutable references in slice patterns.\r\n\r\n- 2019-06-30, RFC https://github.com/rust-lang/rfcs/pull/2359\r\n  Author: @petrochenkov\r\n  Reviewers: The Language Team\r\n\r\n  The RFC switched the syntax of subslice patterns to `{$binding @}? ..` as opposed to `.. $pat?` (which was what the RFC originally proposed). This RFC reignited the work towards finishing the implementation and the testing of slice patterns which eventually lead to this stabilization proposal.\r\n\r\n- 2019-06-30, RFC https://github.com/rust-lang/rfcs/pull/2707\r\n  Author: @petrochenkov\r\n  Reviewers: The Language Team\r\n\r\n  This RFC built upon https://github.com/rust-lang/rfcs/pull/2359 turning `..` into a full-fledged pattern (`Pat |= Rest:\"..\" ;`), as opposed to a special part of slice and tuple patterns, moving previously syntactic restrictions into semantic ones.\r\n\r\n- 2019-07-03, PR https://github.com/rust-lang/rust/pull/62255\r\n  Author: @Centril\r\n  Reviewers: @varkor\r\n\r\n  This closed the old tracking issue (https://github.com/rust-lang/rust/issues/23121) in favor of the new one (https://github.com/rust-lang/rust/issues/62254) due to the new RFCs having been accepted.\r\n\r\n- 2019-07-28, PR https://github.com/rust-lang/rust/pull/62550\r\n  Author: @Centril\r\n  Reviewers: @petrochenkov and @eddyb\r\n\r\n  Implemented RFCs https://github.com/rust-lang/rfcs/pull/2707 and https://github.com/rust-lang/rfcs/pull/2359 by introducing the `..` syntactic rest pattern form as well as changing the lowering to subslice and subtuple patterns and the necessary semantic restrictions as per the RFCs. \r\n\r\n  Moreover, the parser was cleaned up to use a more generic framework for parsing sequences of things. This framework was employed in parsing slice patterns.\r\n\r\n  Finally, the PR introduced parser recovery for half-open ranges (e.g., `..X`, `..=X`, and `X..`), demonstrating in practice that the RFCs proposed syntax will enable half-open ranges if we want to add those (which is done in https://github.com/rust-lang/rust/pull/67258).\r\n\r\n- 2019-07-30, PR https://github.com/rust-lang/rust/pull/63111\r\n  Author: @Centril\r\n  Reviewers: @estebank\r\n\r\n  Added a test which comprehensively exercised the parsing of `..` rest patterns. That is, the PR exercised the specification in https://github.com/rust-lang/rfcs/pull/2707. Moreover, a test was added for the semantic restrictions noted in the RFC.\r\n\r\n- 2019-07-31, PR https://github.com/rust-lang/rust/pull/63129\r\n  Author: @Centril\r\n  Reviewers: @oli-obk\r\n\r\n  Hardened the test-suite for subslice and subarray patterns with a run-pass tests. This test exercises both type checking and dynamic semantics.\r\n\r\n- 2019-09-15, PR https://github.com/rust-analyzer/rust-analyzer/pull/1848\r\n  Author: @ecstatic-morse\r\n  Reviewers: @matklad\r\n\r\n  This implemented the syntactic change (rest patterns, `..`) in rust-analyzer.\r\n\r\n- 2019-11-05, PR https://github.com/rust-lang/rust/pull/65874\r\n  Author: @Nadrieril\r\n  Reviewers: @varkor, @arielb1, and @Centril\r\n\r\n  Usefulness / exhaustiveness checking saw a major refactoring clarifying the analysis by emphasizing that each row of the matrix can be seen as a sort of stack from which we pop constructors.\r\n\r\n- 2019-11-12, PR https://github.com/rust-lang/rust/pull/66129\r\n  Author: @Nadrieril\r\n  Reviewers: @varkor, @Centril, and @estebank\r\n\r\n  Usefulness / exhaustiveness checking of slice patterns were refactored in favor of clearer code. Before the PR, variable-length slice patterns were eagerly expanded into a union of fixed-length slices. They now have their own special constructor, which allows expanding them more lazily. As a side-effect, this improved diagnostics. Moreover, the test suite for exhaustiveness checking of slice patterns was hardened.\r\n\r\n- 2019-11-20, PR https://github.com/rust-lang/rust/pull/66497\r\n  Author: @Nadrieril\r\n  Reviewers: @varkor and @Centril\r\n\r\n  Building on the previous PR, this one fixed a bug https://github.com/rust-lang/rust/issues/53820 wherein sufficiently large subarray patterns (`match [0u8; 16*1024] { [..] => {}}`) would result in crashing the compiler with a stack-overflow. The PR did this by treating array patterns in a more first-class way (using a variable-length mechanism also used for slices) rather than like large tuples. This also had the effect of improving diagnostics for non-exhaustive matches.\r\n\r\n- 2019-11-28, PR https://github.com/rust-lang/rust/pull/66603\r\n  Author: @Nadrieril\r\n  Reviewers: @varkor\r\n\r\n  Fixed a bug https://github.com/rust-lang/rust/issues/65413 wherein constants, slice patterns, and exhaustiveness checking interacted in a suboptimal way conspiring to suggest that a reachable arm was in fact unreachable.\r\n\r\n- 2019-12-12, PR https://github.com/rust-lang/rust/pull/66650\r\n  Author: @matthewjasper\r\n  Reviewers: @pnkfelix and @Centril\r\n\r\n  Removed the `UniformArrayMoveOut` MIR transformation pass in favor of baking the necessary logic into the borrow-checker, drop elaboration and MIR building itself. This fixed a number of bugs, including a soundness hole https://github.com/rust-lang/rust/issues/66502. Moreover, the PR added a slew of tests for borrow- and move-checking of slice patterns as well as a test for the dynamic semantics of dropping subslice patterns.\r\n\r\n- 2019-12-16, PR https://github.com/rust-lang/rust/pull/67318\r\n  Author: @Centril\r\n  Reviewers: @matthewjasper\r\n\r\n  Improved documentation for AST->HIR lowering + type checking of slice as well as minor code simplification.\r\n\r\n- 2019-12-21, PR https://github.com/rust-lang/rust/pull/67467\r\n  Author: @matthewjasper\r\n  Reviewers: @oli-obk, @RalfJung, and @Centril\r\n\r\n  Fixed bugs in the const evaluation of slice patterns and added tests for const evaluation as well as borrow- and move-checking.\r\n\r\n- 2019-12-22, PR https://github.com/rust-lang/rust/pull/67439\r\n  Author: @Centril\r\n  Reviewers: @matthewjasper\r\n\r\n  Cleaned up HAIR lowering of slice patterns, removing special cased dead code for the unrepresentable `[a, b] @ ..`. The PR also refactored type checking for slice patterns.\r\n\r\n- 2019-12-23, PR https://github.com/rust-lang/rust/pull/67546\r\n  Author: @oli-obk\r\n  Reviewers: @varkor and @RalfJung\r\n\r\n  Fixed an ICE in the MIR interpretation of slice patterns.\r\n\r\n- 2019-12-24, PR https://github.com/rust-lang/rust/pull/66296\r\n  Author: @Centril\r\n  Reviewers: @pnkfelix and @matthewjasper\r\n\r\n  This implemented `#![feature(bindings_after_at)]` which allows writing e.g. `a @ Some([_, b @ ..])`. This is not directly linked to slice patterns other than with patterns in general. However, the combination of the feature and `slice_patterns` received some testing in the PR.\r\n\r\n- 2020-01-09, PR https://github.com/rust-lang/rust/pull/67990\r\n  Author: @Centril\r\n  Reviewers: @matthewjasper\r\n\r\n  This hardened move-checker tests for `match` expressions in relation to https://github.com/rust-lang/rust/issues/53114.\r\n\r\n- This PR stabilizes `slice_patterns`.\r\n\r\n## Related / possible future work\r\n\r\nThere is on-going work to improve pattern matching in other ways (the relevance of some of these are indirect, and only by composition):\r\n\r\n- OR-patterns, `pat_0 | .. | pat_n` is almost implemented.\r\n  Tracking issue: https://github.com/rust-lang/rust/issues/54883\r\n\r\n- Bindings after `@`, e.g., `x @ Some(y)` is implemented.\r\n  Tracking issue: https://github.com/rust-lang/rust/issues/65490\r\n\r\n- Half-open range patterns, e.g., `X..`, `..X`, and `..=X` as well as exclusive range patterns, e.g., `X..Y`.\r\n  Tracking issue: https://github.com/rust-lang/rust/issues/67264 and https://github.com/rust-lang/rust/issues/37854\r\n  The relevance here is that this work demonstrates, in practice, that there are no syntactic conflicts introduced by the stabilization of subslice patterns.\r\n\r\nAs for more direct improvements to slice patterns, some avenues could be:\r\n\r\n- Box patterns, e.g., `box [a, b, .., c]` to match on `Box<[T]>`.\r\n  Tracking issue: https://github.com/rust-lang/rust/issues/29641\r\n  This issue currently has no path to stabilization.\r\n\r\n  Note that it is currently possible to match on `Box<[T]>` or `Vec<T>` by first dereferencing them to slices.\r\n\r\n- `DerefPure`, which would allow e.g., using slice patterns to match on `Vec<T>` (e.g., moving out of it).\r\n\r\nAnother idea which was raised by [RFC 2707](https://github.com/rust-lang/rfcs/blob/master/text/2707-dotdot-patterns.md#future-possibilities) and [RFC 2359](https://github.com/rust-lang/rfcs/blob/master/text/2359-subslice-pattern-syntax.md#pat-vs-pat) was to allow binding a subtuple pattern. That is, we could allow `(a, xs @ .., b)`. However, while we could allow by-value bindings to `..` as in `xs @ ..` at zero cost, the same cannot be said of by-reference bindings, e.g. `(a, ref xs @ .., b)`. The issue here becomes that for a reference to be legal, we have to represent `xs` contiguously in memory. In effect, we are forced into a [`HList`](https://docs.rs/frunk/0.3.1/frunk/hlist/struct.HCons.html) based representation for tuples.", "created_at": "2019-12-30T00:43:03Z", "updated_at": "2021-07-12T16:46:02Z", "closed_at": "2020-01-18T22:09:13Z", "merged_at": "2020-01-18T22:09:13Z", "merge_commit_sha": "57b6843100b247b6065b71e4485572dda4bfccc6", "assignee": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}], "requested_reviewers": [], "requested_teams": [], "labels": [{"id": 211668019, "node_id": "MDU6TGFiZWwyMTE2NjgwMTk=", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-lang", "name": "T-lang", "color": "bfd4f2", "default": false, "description": "Relevant to the language team, which will review and decide on the PR/issue."}, {"id": 223796632, "node_id": "MDU6TGFiZWwyMjM3OTY2MzI=", "url": "https://api.github.com/repos/rust-lang/rust/labels/relnotes", "name": "relnotes", "color": "fad8c7", "default": false, "description": "Marks issues that should be documented in the release notes of the next release."}, {"id": 583437191, "node_id": "MDU6TGFiZWw1ODM0MzcxOTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/S-waiting-on-bors", "name": "S-waiting-on-bors", "color": "d3dddd", "default": false, "description": "Status: Waiting on bors to run and complete tests. Bors will change the label on completion."}, {"id": 919710011, "node_id": "MDU6TGFiZWw5MTk3MTAwMTE=", "url": "https://api.github.com/repos/rust-lang/rust/labels/disposition-merge", "name": "disposition-merge", "color": "008800", "default": false, "description": "This issue / PR is in PFCP or FCP with a disposition to merge it."}, {"id": 923282386, "node_id": "MDU6TGFiZWw5MjMyODIzODY=", "url": "https://api.github.com/repos/rust-lang/rust/labels/finished-final-comment-period", "name": "finished-final-comment-period", "color": "f9e189", "default": false, "description": "The final comment period is finished for this PR / Issue."}], "milestone": {"url": "https://api.github.com/repos/rust-lang/rust/milestones/69", "html_url": "https://github.com/rust-lang/rust/milestone/69", "labels_url": "https://api.github.com/repos/rust-lang/rust/milestones/69/labels", "id": 4924613, "node_id": "MDk6TWlsZXN0b25lNDkyNDYxMw==", "number": 69, "title": "1.42", "description": "", "creator": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "open_issues": 0, "closed_issues": 16, "state": "closed", "created_at": "2019-12-12T08:11:16Z", "updated_at": "2020-04-02T19:20:58Z", "due_on": "2020-03-12T07:00:00Z", "closed_at": "2020-04-02T19:20:58Z"}, "draft": false, "commits_url": "https://api.github.com/repos/rust-lang/rust/pulls/67712/commits", "review_comments_url": "https://api.github.com/repos/rust-lang/rust/pulls/67712/comments", "review_comment_url": "https://api.github.com/repos/rust-lang/rust/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/67712/comments", "statuses_url": "https://api.github.com/repos/rust-lang/rust/statuses/57b6843100b247b6065b71e4485572dda4bfccc6", "head": {"label": "Centril:stabilize-slice_patterns", "ref": "stabilize-slice_patterns", "sha": "57b6843100b247b6065b71e4485572dda4bfccc6", "user": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "repo": {"id": 110026416, "node_id": "MDEwOlJlcG9zaXRvcnkxMTAwMjY0MTY=", "name": "rust", "full_name": "Centril/rust", "private": false, "owner": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "html_url": "https://github.com/Centril/rust", "description": "A safe, concurrent, practical language.", "fork": true, "url": "https://api.github.com/repos/Centril/rust", "forks_url": "https://api.github.com/repos/Centril/rust/forks", "keys_url": "https://api.github.com/repos/Centril/rust/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/Centril/rust/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/Centril/rust/teams", "hooks_url": "https://api.github.com/repos/Centril/rust/hooks", "issue_events_url": "https://api.github.com/repos/Centril/rust/issues/events{/number}", "events_url": "https://api.github.com/repos/Centril/rust/events", "assignees_url": "https://api.github.com/repos/Centril/rust/assignees{/user}", "branches_url": "https://api.github.com/repos/Centril/rust/branches{/branch}", "tags_url": "https://api.github.com/repos/Centril/rust/tags", "blobs_url": "https://api.github.com/repos/Centril/rust/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/Centril/rust/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/Centril/rust/git/refs{/sha}", "trees_url": "https://api.github.com/repos/Centril/rust/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/Centril/rust/statuses/{sha}", "languages_url": "https://api.github.com/repos/Centril/rust/languages", "stargazers_url": "https://api.github.com/repos/Centril/rust/stargazers", "contributors_url": "https://api.github.com/repos/Centril/rust/contributors", "subscribers_url": "https://api.github.com/repos/Centril/rust/subscribers", "subscription_url": "https://api.github.com/repos/Centril/rust/subscription", "commits_url": "https://api.github.com/repos/Centril/rust/commits{/sha}", "git_commits_url": "https://api.github.com/repos/Centril/rust/git/commits{/sha}", "comments_url": "https://api.github.com/repos/Centril/rust/comments{/number}", "issue_comment_url": "https://api.github.com/repos/Centril/rust/issues/comments{/number}", "contents_url": "https://api.github.com/repos/Centril/rust/contents/{+path}", "compare_url": "https://api.github.com/repos/Centril/rust/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/Centril/rust/merges", "archive_url": "https://api.github.com/repos/Centril/rust/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/Centril/rust/downloads", "issues_url": "https://api.github.com/repos/Centril/rust/issues{/number}", "pulls_url": "https://api.github.com/repos/Centril/rust/pulls{/number}", "milestones_url": "https://api.github.com/repos/Centril/rust/milestones{/number}", "notifications_url": "https://api.github.com/repos/Centril/rust/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/Centril/rust/labels{/name}", "releases_url": "https://api.github.com/repos/Centril/rust/releases{/id}", "deployments_url": "https://api.github.com/repos/Centril/rust/deployments", "created_at": "2017-11-08T20:24:22Z", "updated_at": "2020-04-13T03:23:48Z", "pushed_at": "2020-04-15T23:17:57Z", "git_url": "git://github.com/Centril/rust.git", "ssh_url": "git@github.com:Centril/rust.git", "clone_url": "https://github.com/Centril/rust.git", "svn_url": "https://github.com/Centril/rust", "homepage": "https://www.rust-lang.org", "size": 503428, "stargazers_count": 0, "watchers_count": 0, "language": "Rust", "has_issues": false, "has_projects": true, "has_downloads": true, "has_wiki": false, "has_pages": false, "has_discussions": false, "forks_count": 1, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 0, "license": {"key": "other", "name": "Other", "spdx_id": "NOASSERTION", "url": null, "node_id": "MDc6TGljZW5zZTA="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": [], "visibility": "public", "forks": 1, "open_issues": 0, "watchers": 0, "default_branch": "master"}}, "base": {"label": "rust-lang:master", "ref": "master", "sha": "779f85bac6b304dd4cad5981acf053a2c0601582", "user": {"login": "rust-lang", "id": 5430905, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU0MzA5MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5430905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rust-lang", "html_url": "https://github.com/rust-lang", "followers_url": "https://api.github.com/users/rust-lang/followers", "following_url": "https://api.github.com/users/rust-lang/following{/other_user}", "gists_url": "https://api.github.com/users/rust-lang/gists{/gist_id}", "starred_url": "https://api.github.com/users/rust-lang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rust-lang/subscriptions", "organizations_url": "https://api.github.com/users/rust-lang/orgs", "repos_url": "https://api.github.com/users/rust-lang/repos", "events_url": "https://api.github.com/users/rust-lang/events{/privacy}", "received_events_url": "https://api.github.com/users/rust-lang/received_events", "type": "Organization", "site_admin": false}, "repo": {"id": 724712, "node_id": "MDEwOlJlcG9zaXRvcnk3MjQ3MTI=", "name": "rust", "full_name": "rust-lang/rust", "private": false, "owner": {"login": "rust-lang", "id": 5430905, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU0MzA5MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5430905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rust-lang", "html_url": "https://github.com/rust-lang", "followers_url": "https://api.github.com/users/rust-lang/followers", "following_url": "https://api.github.com/users/rust-lang/following{/other_user}", "gists_url": "https://api.github.com/users/rust-lang/gists{/gist_id}", "starred_url": "https://api.github.com/users/rust-lang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rust-lang/subscriptions", "organizations_url": "https://api.github.com/users/rust-lang/orgs", "repos_url": "https://api.github.com/users/rust-lang/repos", "events_url": "https://api.github.com/users/rust-lang/events{/privacy}", "received_events_url": "https://api.github.com/users/rust-lang/received_events", "type": "Organization", "site_admin": false}, "html_url": "https://github.com/rust-lang/rust", "description": "Empowering everyone to build reliable and efficient software.", "fork": false, "url": "https://api.github.com/repos/rust-lang/rust", "forks_url": "https://api.github.com/repos/rust-lang/rust/forks", "keys_url": "https://api.github.com/repos/rust-lang/rust/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/rust-lang/rust/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/rust-lang/rust/teams", "hooks_url": "https://api.github.com/repos/rust-lang/rust/hooks", "issue_events_url": "https://api.github.com/repos/rust-lang/rust/issues/events{/number}", "events_url": "https://api.github.com/repos/rust-lang/rust/events", "assignees_url": "https://api.github.com/repos/rust-lang/rust/assignees{/user}", "branches_url": "https://api.github.com/repos/rust-lang/rust/branches{/branch}", "tags_url": "https://api.github.com/repos/rust-lang/rust/tags", "blobs_url": "https://api.github.com/repos/rust-lang/rust/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/rust-lang/rust/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/rust-lang/rust/git/refs{/sha}", "trees_url": "https://api.github.com/repos/rust-lang/rust/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/rust-lang/rust/statuses/{sha}", "languages_url": "https://api.github.com/repos/rust-lang/rust/languages", "stargazers_url": "https://api.github.com/repos/rust-lang/rust/stargazers", "contributors_url": "https://api.github.com/repos/rust-lang/rust/contributors", "subscribers_url": "https://api.github.com/repos/rust-lang/rust/subscribers", "subscription_url": "https://api.github.com/repos/rust-lang/rust/subscription", "commits_url": "https://api.github.com/repos/rust-lang/rust/commits{/sha}", "git_commits_url": "https://api.github.com/repos/rust-lang/rust/git/commits{/sha}", "comments_url": "https://api.github.com/repos/rust-lang/rust/comments{/number}", "issue_comment_url": "https://api.github.com/repos/rust-lang/rust/issues/comments{/number}", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/{+path}", "compare_url": "https://api.github.com/repos/rust-lang/rust/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/rust-lang/rust/merges", "archive_url": "https://api.github.com/repos/rust-lang/rust/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/rust-lang/rust/downloads", "issues_url": "https://api.github.com/repos/rust-lang/rust/issues{/number}", "pulls_url": "https://api.github.com/repos/rust-lang/rust/pulls{/number}", "milestones_url": "https://api.github.com/repos/rust-lang/rust/milestones{/number}", "notifications_url": "https://api.github.com/repos/rust-lang/rust/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/rust-lang/rust/labels{/name}", "releases_url": "https://api.github.com/repos/rust-lang/rust/releases{/id}", "deployments_url": "https://api.github.com/repos/rust-lang/rust/deployments", "created_at": "2010-06-16T20:39:03Z", "updated_at": "2023-06-20T02:25:36Z", "pushed_at": "2023-06-20T02:02:30Z", "git_url": "git://github.com/rust-lang/rust.git", "ssh_url": "git@github.com:rust-lang/rust.git", "clone_url": "https://github.com/rust-lang/rust.git", "svn_url": "https://github.com/rust-lang/rust", "homepage": "https://www.rust-lang.org", "size": 930398, "stargazers_count": 82759, "watchers_count": 82759, "language": "Rust", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": false, "has_pages": false, "has_discussions": false, "forks_count": 10960, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 9627, "license": {"key": "other", "name": "Other", "spdx_id": "NOASSERTION", "url": null, "node_id": "MDc6TGljZW5zZTA="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["compiler", "hacktoberfest", "language", "rust"], "visibility": "public", "forks": 10960, "open_issues": 9627, "watchers": 82759, "default_branch": "master"}}, "_links": {"self": {"href": "https://api.github.com/repos/rust-lang/rust/pulls/67712"}, "html": {"href": "https://github.com/rust-lang/rust/pull/67712"}, "issue": {"href": "https://api.github.com/repos/rust-lang/rust/issues/67712"}, "comments": {"href": "https://api.github.com/repos/rust-lang/rust/issues/67712/comments"}, "review_comments": {"href": "https://api.github.com/repos/rust-lang/rust/pulls/67712/comments"}, "review_comment": {"href": "https://api.github.com/repos/rust-lang/rust/pulls/comments{/number}"}, "commits": {"href": "https://api.github.com/repos/rust-lang/rust/pulls/67712/commits"}, "statuses": {"href": "https://api.github.com/repos/rust-lang/rust/statuses/57b6843100b247b6065b71e4485572dda4bfccc6"}}, "author_association": "CONTRIBUTOR", "auto_merge": null, "active_lock_reason": null, "merged": true, "mergeable": null, "rebaseable": null, "mergeable_state": "unknown", "merged_by": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "comments": 26, "review_comments": 4, "maintainer_can_modify": false, "commits": 8, "additions": 387, "deletions": 666, "changed_files": 142}