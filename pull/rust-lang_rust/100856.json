{"url": "https://api.github.com/repos/rust-lang/rust/pulls/100856", "id": 1032129750, "node_id": "PR_kwDOAAsO6M49hQzW", "html_url": "https://github.com/rust-lang/rust/pull/100856", "diff_url": "https://github.com/rust-lang/rust/pull/100856.diff", "patch_url": "https://github.com/rust-lang/rust/pull/100856.patch", "issue_url": "https://api.github.com/repos/rust-lang/rust/issues/100856", "number": 100856, "state": "closed", "locked": false, "title": "Improve performance of stable sort", "user": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "body": "This reworks the internals of slice::sort. Mainly:\r\n\r\n- Introduce branchless swap_next_if and optimized sortX functions\r\n- Speedup core batch extension with sort16\r\n- Many small tweaks to reduce the amount of branches/jumps\r\n\r\nThis commit is incomplete and MUST NOT be merged as is. It is missing Copy\r\ndetection and would break uniqueness preservation of values that are being\r\nsorted.\r\n\r\n---\r\n\r\nThis initially started as an exploration to port [fluxsort](https://github.com/scandum/fluxsort) to Rust. Together with ideas from the recent libcxx sort improvement, namely optimal sorting networks, this PR aims to improve the performance of `slice::sort`.\r\n\r\nBefore submitting this PR, I wanted good answers for these two questions:\r\n\r\n- How can I know that it works correctly?\r\n- How can I know it is actually faster?\r\n\r\nMaybe I've used it wrong, but I did not find a comprehensive set of tests for sort in the std test suite. Even simple bugs, manually added to the existing code, still passed the library/std suite. So I embarked on creating my own test and benchmark suite https://github.com/Voultapher/sort-research-rs. Having a variety of test types, pattern and sizes.\r\n\r\n## How can I know that it works correctly?\r\n\r\n- The new implementation is tested with a variety of tests. [Varying types, input size and test logic](https://github.com/Voultapher/sort-research-rs/blob/19db1c2a2f1b747e2d5f5d7d68ffa51355a51017/tests/main.rs)\r\n- miri does not complain when running the tests\r\n- Repeatedly running the tests with random inputs has not yielded failures (In its current form. While developing I had many bugs)\r\n- Careful analysis and reasoning of the code. Augmented with comments.\r\n- debug_asserts for invariants where doing so is reasonably cheap\r\n- Review process via PR\r\n- Potential nightly adoption and feedback\r\n\r\n## How can I know it is actually faster?\r\n\r\nBenchmarking is notoriously tricky. Along the way I've mad all kinds of mistakes, ranging from false randomness. Not being representative enough. Botching type distributions and more. In it's current form the benchmark suite tests along 4 dimensions:\r\n\r\n- Input type\r\n- Input pattern\r\n- Input size\r\n- hot/cold prediction state\r\n\r\n### input type\r\n\r\nI chose 5 types that are to represent some of the types users will call this generic sort implementation with:\r\n\r\n- `i32` basic type often used to test sorting algorithms.\r\n- `u64` common type for usize on 64-bit machines. Sorting indices is very common.\r\n- `String` Larger type that is not Copy and does heap access.\r\n- `1k` Very large stack value 1kb, not Copy.\r\n- `f128` 16 byte stack value that is Copy but has a relatively expensive cmp implementation.\r\n\r\n### Input pattern\r\n\r\nI chose 11 input patterns. Sorting algorithms behave wildly different based on the input pattern. And most hight performance implementation try to be some kind of adaptive.\r\n\r\n- random\r\n- random_uniform\r\n- random_random_size\r\n- all_equal\r\n- ascending\r\n- descending\r\n- ascending_saw_5\r\n- ascending_saw_20\r\n- descending_saw_5\r\n- descending_saw_20\r\n- pipe_organ\r\n\r\nFor more details on the input patterns, take a look at their [implementation](https://github.com/Voultapher/sort-research-rs/blob/19db1c2a2f1b747e2d5f5d7d68ffa51355a51017/src/patterns.rs).\r\n\r\n### Input size\r\n\r\nWhile in general sorting random data should be n log(n), the specifics might be quite different. So it's important to get a representative set of test sizes. I chose these:\r\n\r\n```rust\r\nlet test_sizes = [\r\n    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 16, 17, 19, 20, 24, 36, 50, 101, 200, 500, 1_000,\r\n    2_048, 10_000, 100_000, 1_000_000,\r\n];\r\n```\r\n\r\n#### hot/cold prediction state\r\n\r\nModern CPUs are highly out-of-order and speculative to extract as much Instruction Level Parallelism (ILP) as possible. This is highly dependent on speculation. And while the common way to do benchmarks is good to get reliable standalone numbers, their magnitude might be misleading in programs that do more than just calling sort in a tight loop. So I run every benchmark twice once via criterion `iter_batched` (hot) and `iter_batch PerIteration` with a function in-between that attempts to flush the Branch Target Buffer (BTB) and does a syscall for good measure too. The cold benchmarks are not necessarily representative for the absolute gains in a particular application, nor are the hot results. But together they give a decent range of possible speedups.\r\n\r\n\r\n### What makes a sort algorithm fast\r\n\r\nTalking in depth about all kinds of sort algorithm would go too deep here, especially given, that this does not change the underlying algorithm. But merely augments it with branchless code that can extract more ILP. Broadly speaking a generic sorting algorithms runtime will depend on 3 factors:\r\n\r\n- How cheap is your type to compare?\r\n- How expensive is your type to move?\r\n- How well can access to your type be predicted?\r\n\r\nFor example, a `u64` is very cheap to compare, very cheap to move and many of them fit into a cache line. And only that cache line is needed to compare them. A type like `u64` will give you pretty close to the maximum performance of the sorting algorithm. In contrast, `String` is potentially expensive to compare, relatively cheap to move and access is hard to predict. And a type like `f128` (just a name used for testing, not an official literal) is rather expensive to compare, it does two f64 divisions for each comparison, is cheap to move, and access is easily predicted. Given the vast freedom Rust users have, the sort algorithm can only do a best effort for common use cases and be reasonably good in others. If you decompress files with each comparison, that will be your bottleneck. Rust users can implement arbitrarily expensive `is_less` functions, and the key metric for such cases is how many comparisons are performed by the implementation. As I was developing the optimisations, I took great care to ensure that not only was it faster, but also not significantly slower. For example by measuring the total comparisons done for each input, type + pattern + size combination.\r\n\r\n- [new_stable vs std_stable](https://github.com/Voultapher/sort-research-rs/blob/0003488ea89c9260e8b3a83f7d2cc737d2f0d91e/results/cf11b1e/analysis/std_stable_vs_new_stable_comparisons.txt)\r\n- [std_unstable vs std_stable](https://github.com/Voultapher/sort-research-rs/blob/0003488ea89c9260e8b3a83f7d2cc737d2f0d91e/results/cf11b1e/analysis/std_stable_vs_std_unstable_comparisons.txt)\r\n\r\nFor non Copy types the total comparisons done are roughly equal. For Copy types and random input, it's 6% more on average. And while at first it might seem intuitive that more comparisons means higher runtime. That's not true for various reasons, mostly cache access. For example `sort_unstable` does on average for random input, and input size > 20 14% more comparisons. There are even some pathological inputs such as `pipe_organ` where the merge sort with streak analysis is vastly superior. For `u64-pipe_organ-10000` the stable sort performs 20k comparisons while unstable sort does 130k. If your type is expensive to compare, unstable sort will quickly loose its advantage.\r\n\r\n### Benchmark results\r\n\r\nWhich the 4 input dimensions, we get 2.5k individual benchmarks. I ran them on 3 different microarchitectures. Comparing new_stable with std_stable, gives us 15k data points. That's a lot and requires some kind of analysis. The raw results are [here](https://github.com/Voultapher/sort-research-rs/tree/0003488ea89c9260e8b3a83f7d2cc737d2f0d91e/results/cf11b1e), feel free to crush the numbers yourself, I probably did some mistakes.\r\n\r\nTLDR:\r\n\r\n- The biggest winners are Copy types, in random order. Such scenarios see 30-100% speedup.\r\n- Non Copy types remain largely the same, with some outliers that I guess are dependent on memory layout and alignment and other factors.\r\n- Some scenarios see slowdowns, but they are pretty contained\r\n- Wider and deeper microarchitectures see relatively larger wins (ie. current and future designs)\r\n\r\nTest setup:\r\n\r\nCompiler: rustc 1.65.0-nightly (29e4a9ee0 2022-08-10)\r\n\r\nMachines:\r\n- AMD 5900X (Zen3)\r\n- Intel i7-5500U (Broadwell)\r\n- Apple M1 Pro (Firestorm)\r\n\r\nhot-u64 (Zen3)\r\n\r\n<img width=\"610\" alt=\"Screenshot 2022-08-21 at 22 14 38\" src=\"https://user-images.githubusercontent.com/6864584/185809198-bf66c588-bb7f-481d-ba74-4d59d03e7d5d.png\">\r\n\r\nThis plots the `hot-u64` results. Everything above 0 means the new implementation was faster and everything below means the current version was faster. Check out an [interactive version here](https://voultapher.github.io/sort-research-rs/results/cf11b1e/analysis/zen3/hot-overview), you can hover over all the values to see the relative speedup. Note, the speedup is calculated symmetrically, so it doesn't matter which 'side' you view it from.\r\n\r\nhot-u64-random <= 20 (Firestorm)\r\n\r\n<img width=\"610\" alt=\"Screenshot 2022-08-21 at 23 10 35\" src=\"https://user-images.githubusercontent.com/6864584/185811076-b899bf23-3de3-4f81-8903-873f1e49ba5f.png\">\r\n\r\n[Interactive version here](https://voultapher.github.io/sort-research-rs/results/cf11b1e/analysis/firestorm/hot-u64-detail) you have to scroll down a bit to get to random. But the other ones are interesting too of course.\r\n\r\nhot-u64 (Firestorm)\r\n\r\n<img width=\"610\" alt=\"Screenshot 2022-08-21 at 22 13 40\" src=\"https://user-images.githubusercontent.com/6864584/185809184-8050e135-1488-41d4-8525-602c21ad24eb.png\">\r\n\r\nHere you can see what I suspect is the really wide core flexing it's ILP capabilities, speeding up sorting a slice of 16 random `u64` by 2.4x.\r\n\r\nhot-u64 (Broadwell)\r\n\r\n<img width=\"610\" alt=\"Screenshot 2022-08-21 at 22 14 38\" src=\"https://user-images.githubusercontent.com/6864584/185809213-ef1d608b-c5aa-4ca7-a4b0-248f655807c1.png\">\r\n\r\nEven on older hardware the results look promising.\r\n\r\nYou can explore [all results here](https://voultapher.github.io/sort-research-rs/results/cf11b1e/). Note, I accidentally forgot to add 16 as test size when running the benchmarks on the Zen3 machine, the other two have this included. But from what I see the difference is not too big.\r\n\r\n---\r\n\r\n\r\n### Outstanding work\r\n\r\n- Get the `is_copy` check to work within the standard library. I used specialisation in my repo, but I'm not sure what the right path forward here would be. On the surface it seems like a relatively simple property to check.\r\n- Talk about the expected behaviour when `is_less` panics inside `sort16` during the final parity merge. With the current double copy, it retains the current behaviour of leaving `v` in a valid state *and* preserving all its original elements. A faster version is possible, by omitting the two copy calls, and directly writing the result of `parity_merge` into `arr_ptr`, however this changes the current behaviour. Should `is_less` panic, `v` will be left in a valid state *but* there might be duplicate elements, losing the original set. The question is, how many people rely on such behaviour? How big of a footgun is that? Is the price worth having everyone pay it when they don't need it? Would documentation be enough?\r\n\r\nA note on 'uniqueness preservation'. Maybe this concept has a name, but I don't know it. I did experiments of allowing the `sort16` approach for non Copy types, however I saw slowdowns for such types, even when limiting it to relatively cheap to move types. I suspect Copy is a pretty good heuristic for types that are cheap to compare, move and access. But what makes them crucially the only ones applicable, is not panic safety as I initially thought. With the two extra copy's `sort16` which could be done only for non Copy types, that part is solved. However, what memory location is dereferenced and used to call `is_less` is the tricky part. By creating a shallow copy of type and using that address to call `is_less`, if this value is then not copied back, and used along the chain as 'unique' object along the progress of code, you could observe that for all intents and purposes, the type that is in your mutable slice, is the one you put in there. But if you self modify yourself inside `is_less` this self modification can be lost. That's exactly what `parity_merge8` and `parity_merge` do. The way they sweep along the slice overlapping between 'iterations' might compare something from src, copy it and then use src again for a comparison, but then later `dest` is copied back into `v`, which has only seen one of the comparisons. And crucially `Cell` is not Copy, which means such logical foot guns are not possible with Copy types, or not to my knowledge. I wrote a test for it [here](https://github.com/Voultapher/sort-research-rs/blob/0003488ea89c9260e8b3a83f7d2cc737d2f0d91e/tests/main.rs#L391).\r\n\r\nI would love to see if this improvement has any noticeable effect on compile times. Coarse analysis showed some places where the compiler uses stable sort with suitable types.\r\n\r\n### Future work\r\n\r\n- For input_size <20 stable and unstable sort both use insertion sort, albeit slightly different implementations. The same speedups here could be applied to unstable sort.\r\n- If I find the time I want to investigate porting the merge part of fluxsort and see if that speeds things up. My main worry is correctness. It's quite liberal in it's use of pointers and I've already discovered memory and logic bugs in the parts that I ported. For <16 elements its somewhat possible to think about in my head. But for general situations, I fear it might require formal verification, to attain the expected level of confidence.\r\n- Use sort16 to speedup unstable sort, or in general look into improving unstable sort.\r\n\r\nThis is my first time contributing to the standard library, my apologies if I missed or got something important wrong.\r\n", "created_at": "2022-08-21T21:17:57Z", "updated_at": "2023-01-26T07:57:05Z", "closed_at": "2023-01-26T07:57:05Z", "merged_at": null, "merge_commit_sha": "97d0e03c8b2d24c306b1a480abf9d9782fa10be3", "assignee": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "assignees": [{"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}], "requested_reviewers": [], "requested_teams": [], "labels": [{"id": 583436937, "node_id": "MDU6TGFiZWw1ODM0MzY5Mzc=", "url": "https://api.github.com/repos/rust-lang/rust/labels/S-waiting-on-author", "name": "S-waiting-on-author", "color": "d3dddd", "default": false, "description": "Status: This is awaiting some action (such as code changes or more information) from the author."}, {"id": 2011781731, "node_id": "MDU6TGFiZWwyMDExNzgxNzMx", "url": "https://api.github.com/repos/rust-lang/rust/labels/T-libs", "name": "T-libs", "color": "bfd4f2", "default": false, "description": "Relevant to the library team, which will review and decide on the PR/issue."}], "milestone": null, "draft": false, "commits_url": "https://api.github.com/repos/rust-lang/rust/pulls/100856/commits", "review_comments_url": "https://api.github.com/repos/rust-lang/rust/pulls/100856/comments", "review_comment_url": "https://api.github.com/repos/rust-lang/rust/pulls/comments{/number}", "comments_url": "https://api.github.com/repos/rust-lang/rust/issues/100856/comments", "statuses_url": "https://api.github.com/repos/rust-lang/rust/statuses/061d4e80386fd4f310d4f55f99860eb533374c01", "head": {"label": "Voultapher:speedup-stable-sort", "ref": "speedup-stable-sort", "sha": "061d4e80386fd4f310d4f55f99860eb533374c01", "user": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "repo": {"id": 134465592, "node_id": "MDEwOlJlcG9zaXRvcnkxMzQ0NjU1OTI=", "name": "rust", "full_name": "Voultapher/rust", "private": false, "owner": {"login": "Voultapher", "id": 6864584, "node_id": "MDQ6VXNlcjY4NjQ1ODQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6864584?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Voultapher", "html_url": "https://github.com/Voultapher", "followers_url": "https://api.github.com/users/Voultapher/followers", "following_url": "https://api.github.com/users/Voultapher/following{/other_user}", "gists_url": "https://api.github.com/users/Voultapher/gists{/gist_id}", "starred_url": "https://api.github.com/users/Voultapher/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Voultapher/subscriptions", "organizations_url": "https://api.github.com/users/Voultapher/orgs", "repos_url": "https://api.github.com/users/Voultapher/repos", "events_url": "https://api.github.com/users/Voultapher/events{/privacy}", "received_events_url": "https://api.github.com/users/Voultapher/received_events", "type": "User", "site_admin": false}, "html_url": "https://github.com/Voultapher/rust", "description": "A safe, concurrent, practical language.", "fork": true, "url": "https://api.github.com/repos/Voultapher/rust", "forks_url": "https://api.github.com/repos/Voultapher/rust/forks", "keys_url": "https://api.github.com/repos/Voultapher/rust/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/Voultapher/rust/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/Voultapher/rust/teams", "hooks_url": "https://api.github.com/repos/Voultapher/rust/hooks", "issue_events_url": "https://api.github.com/repos/Voultapher/rust/issues/events{/number}", "events_url": "https://api.github.com/repos/Voultapher/rust/events", "assignees_url": "https://api.github.com/repos/Voultapher/rust/assignees{/user}", "branches_url": "https://api.github.com/repos/Voultapher/rust/branches{/branch}", "tags_url": "https://api.github.com/repos/Voultapher/rust/tags", "blobs_url": "https://api.github.com/repos/Voultapher/rust/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/Voultapher/rust/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/Voultapher/rust/git/refs{/sha}", "trees_url": "https://api.github.com/repos/Voultapher/rust/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/Voultapher/rust/statuses/{sha}", "languages_url": "https://api.github.com/repos/Voultapher/rust/languages", "stargazers_url": "https://api.github.com/repos/Voultapher/rust/stargazers", "contributors_url": "https://api.github.com/repos/Voultapher/rust/contributors", "subscribers_url": "https://api.github.com/repos/Voultapher/rust/subscribers", "subscription_url": "https://api.github.com/repos/Voultapher/rust/subscription", "commits_url": "https://api.github.com/repos/Voultapher/rust/commits{/sha}", "git_commits_url": "https://api.github.com/repos/Voultapher/rust/git/commits{/sha}", "comments_url": "https://api.github.com/repos/Voultapher/rust/comments{/number}", "issue_comment_url": "https://api.github.com/repos/Voultapher/rust/issues/comments{/number}", "contents_url": "https://api.github.com/repos/Voultapher/rust/contents/{+path}", "compare_url": "https://api.github.com/repos/Voultapher/rust/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/Voultapher/rust/merges", "archive_url": "https://api.github.com/repos/Voultapher/rust/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/Voultapher/rust/downloads", "issues_url": "https://api.github.com/repos/Voultapher/rust/issues{/number}", "pulls_url": "https://api.github.com/repos/Voultapher/rust/pulls{/number}", "milestones_url": "https://api.github.com/repos/Voultapher/rust/milestones{/number}", "notifications_url": "https://api.github.com/repos/Voultapher/rust/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/Voultapher/rust/labels{/name}", "releases_url": "https://api.github.com/repos/Voultapher/rust/releases{/id}", "deployments_url": "https://api.github.com/repos/Voultapher/rust/deployments", "created_at": "2018-05-22T19:27:01Z", "updated_at": "2022-08-01T07:10:08Z", "pushed_at": "2023-05-21T08:33:52Z", "git_url": "git://github.com/Voultapher/rust.git", "ssh_url": "git@github.com:Voultapher/rust.git", "clone_url": "https://github.com/Voultapher/rust.git", "svn_url": "https://github.com/Voultapher/rust", "homepage": "https://www.rust-lang.org", "size": 873523, "stargazers_count": 0, "watchers_count": 0, "language": "Rust", "has_issues": false, "has_projects": true, "has_downloads": true, "has_wiki": false, "has_pages": false, "has_discussions": false, "forks_count": 0, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 0, "license": {"key": "other", "name": "Other", "spdx_id": "NOASSERTION", "url": null, "node_id": "MDc6TGljZW5zZTA="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": [], "visibility": "public", "forks": 0, "open_issues": 0, "watchers": 0, "default_branch": "master"}}, "base": {"label": "rust-lang:master", "ref": "master", "sha": "47c008e440e59d793c2883f7dd712481dc965045", "user": {"login": "rust-lang", "id": 5430905, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU0MzA5MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5430905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rust-lang", "html_url": "https://github.com/rust-lang", "followers_url": "https://api.github.com/users/rust-lang/followers", "following_url": "https://api.github.com/users/rust-lang/following{/other_user}", "gists_url": "https://api.github.com/users/rust-lang/gists{/gist_id}", "starred_url": "https://api.github.com/users/rust-lang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rust-lang/subscriptions", "organizations_url": "https://api.github.com/users/rust-lang/orgs", "repos_url": "https://api.github.com/users/rust-lang/repos", "events_url": "https://api.github.com/users/rust-lang/events{/privacy}", "received_events_url": "https://api.github.com/users/rust-lang/received_events", "type": "Organization", "site_admin": false}, "repo": {"id": 724712, "node_id": "MDEwOlJlcG9zaXRvcnk3MjQ3MTI=", "name": "rust", "full_name": "rust-lang/rust", "private": false, "owner": {"login": "rust-lang", "id": 5430905, "node_id": "MDEyOk9yZ2FuaXphdGlvbjU0MzA5MDU=", "avatar_url": "https://avatars.githubusercontent.com/u/5430905?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rust-lang", "html_url": "https://github.com/rust-lang", "followers_url": "https://api.github.com/users/rust-lang/followers", "following_url": "https://api.github.com/users/rust-lang/following{/other_user}", "gists_url": "https://api.github.com/users/rust-lang/gists{/gist_id}", "starred_url": "https://api.github.com/users/rust-lang/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rust-lang/subscriptions", "organizations_url": "https://api.github.com/users/rust-lang/orgs", "repos_url": "https://api.github.com/users/rust-lang/repos", "events_url": "https://api.github.com/users/rust-lang/events{/privacy}", "received_events_url": "https://api.github.com/users/rust-lang/received_events", "type": "Organization", "site_admin": false}, "html_url": "https://github.com/rust-lang/rust", "description": "Empowering everyone to build reliable and efficient software.", "fork": false, "url": "https://api.github.com/repos/rust-lang/rust", "forks_url": "https://api.github.com/repos/rust-lang/rust/forks", "keys_url": "https://api.github.com/repos/rust-lang/rust/keys{/key_id}", "collaborators_url": "https://api.github.com/repos/rust-lang/rust/collaborators{/collaborator}", "teams_url": "https://api.github.com/repos/rust-lang/rust/teams", "hooks_url": "https://api.github.com/repos/rust-lang/rust/hooks", "issue_events_url": "https://api.github.com/repos/rust-lang/rust/issues/events{/number}", "events_url": "https://api.github.com/repos/rust-lang/rust/events", "assignees_url": "https://api.github.com/repos/rust-lang/rust/assignees{/user}", "branches_url": "https://api.github.com/repos/rust-lang/rust/branches{/branch}", "tags_url": "https://api.github.com/repos/rust-lang/rust/tags", "blobs_url": "https://api.github.com/repos/rust-lang/rust/git/blobs{/sha}", "git_tags_url": "https://api.github.com/repos/rust-lang/rust/git/tags{/sha}", "git_refs_url": "https://api.github.com/repos/rust-lang/rust/git/refs{/sha}", "trees_url": "https://api.github.com/repos/rust-lang/rust/git/trees{/sha}", "statuses_url": "https://api.github.com/repos/rust-lang/rust/statuses/{sha}", "languages_url": "https://api.github.com/repos/rust-lang/rust/languages", "stargazers_url": "https://api.github.com/repos/rust-lang/rust/stargazers", "contributors_url": "https://api.github.com/repos/rust-lang/rust/contributors", "subscribers_url": "https://api.github.com/repos/rust-lang/rust/subscribers", "subscription_url": "https://api.github.com/repos/rust-lang/rust/subscription", "commits_url": "https://api.github.com/repos/rust-lang/rust/commits{/sha}", "git_commits_url": "https://api.github.com/repos/rust-lang/rust/git/commits{/sha}", "comments_url": "https://api.github.com/repos/rust-lang/rust/comments{/number}", "issue_comment_url": "https://api.github.com/repos/rust-lang/rust/issues/comments{/number}", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/{+path}", "compare_url": "https://api.github.com/repos/rust-lang/rust/compare/{base}...{head}", "merges_url": "https://api.github.com/repos/rust-lang/rust/merges", "archive_url": "https://api.github.com/repos/rust-lang/rust/{archive_format}{/ref}", "downloads_url": "https://api.github.com/repos/rust-lang/rust/downloads", "issues_url": "https://api.github.com/repos/rust-lang/rust/issues{/number}", "pulls_url": "https://api.github.com/repos/rust-lang/rust/pulls{/number}", "milestones_url": "https://api.github.com/repos/rust-lang/rust/milestones{/number}", "notifications_url": "https://api.github.com/repos/rust-lang/rust/notifications{?since,all,participating}", "labels_url": "https://api.github.com/repos/rust-lang/rust/labels{/name}", "releases_url": "https://api.github.com/repos/rust-lang/rust/releases{/id}", "deployments_url": "https://api.github.com/repos/rust-lang/rust/deployments", "created_at": "2010-06-16T20:39:03Z", "updated_at": "2023-06-20T05:47:10Z", "pushed_at": "2023-06-20T05:32:43Z", "git_url": "git://github.com/rust-lang/rust.git", "ssh_url": "git@github.com:rust-lang/rust.git", "clone_url": "https://github.com/rust-lang/rust.git", "svn_url": "https://github.com/rust-lang/rust", "homepage": "https://www.rust-lang.org", "size": 930404, "stargazers_count": 82764, "watchers_count": 82764, "language": "Rust", "has_issues": true, "has_projects": true, "has_downloads": true, "has_wiki": false, "has_pages": false, "has_discussions": false, "forks_count": 10964, "mirror_url": null, "archived": false, "disabled": false, "open_issues_count": 9633, "license": {"key": "other", "name": "Other", "spdx_id": "NOASSERTION", "url": null, "node_id": "MDc6TGljZW5zZTA="}, "allow_forking": true, "is_template": false, "web_commit_signoff_required": false, "topics": ["compiler", "hacktoberfest", "language", "rust"], "visibility": "public", "forks": 10964, "open_issues": 9633, "watchers": 82764, "default_branch": "master"}}, "_links": {"self": {"href": "https://api.github.com/repos/rust-lang/rust/pulls/100856"}, "html": {"href": "https://github.com/rust-lang/rust/pull/100856"}, "issue": {"href": "https://api.github.com/repos/rust-lang/rust/issues/100856"}, "comments": {"href": "https://api.github.com/repos/rust-lang/rust/issues/100856/comments"}, "review_comments": {"href": "https://api.github.com/repos/rust-lang/rust/pulls/100856/comments"}, "review_comment": {"href": "https://api.github.com/repos/rust-lang/rust/pulls/comments{/number}"}, "commits": {"href": "https://api.github.com/repos/rust-lang/rust/pulls/100856/commits"}, "statuses": {"href": "https://api.github.com/repos/rust-lang/rust/statuses/061d4e80386fd4f310d4f55f99860eb533374c01"}}, "author_association": "CONTRIBUTOR", "auto_merge": null, "active_lock_reason": null, "merged": false, "mergeable": false, "rebaseable": false, "mergeable_state": "dirty", "merged_by": null, "comments": 42, "review_comments": 3, "maintainer_can_modify": false, "commits": 5, "additions": 589, "deletions": 149, "changed_files": 1}